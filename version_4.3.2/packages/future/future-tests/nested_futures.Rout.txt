
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:26:36.356] plan(): Setting new future strategy stack:
[10:26:36.356] List of future strategies:
[10:26:36.356] 1. sequential:
[10:26:36.356]    - args: function (..., envir = parent.frame())
[10:26:36.356]    - tweaked: FALSE
[10:26:36.356]    - call: future::plan("sequential")
[10:26:36.370] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[10:26:36.422] plan(): Setting new future strategy stack:
[10:26:36.422] List of future strategies:
[10:26:36.422] 1. sequential:
[10:26:36.422]    - args: function (..., envir = parent.frame())
[10:26:36.422]    - tweaked: FALSE
[10:26:36.422]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.422] 2. sequential:
[10:26:36.422]    - args: function (..., envir = parent.frame())
[10:26:36.422]    - tweaked: FALSE
[10:26:36.422]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.434] plan(): nbrOfWorkers() = 1
[10:26:36.435] getGlobalsAndPackages() ...
[10:26:36.436] Searching for globals...
[10:26:36.458] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:36.458] Searching for globals ... DONE
[10:26:36.458] Resolving globals: FALSE
[10:26:36.460] The total size of the 2 globals is 22.60 KiB (23144 bytes)
[10:26:36.460] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 22.60 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (22.48 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:36.461] - globals: [2] ‘nested’, ‘strategy2’
[10:26:36.461] - packages: [1] ‘future’
[10:26:36.461] getGlobalsAndPackages() ... DONE
[10:26:36.462] run() for ‘Future’ ...
[10:26:36.462] - state: ‘created’
[10:26:36.462] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:36.462] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:36.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:36.462]   - Field: ‘label’
[10:26:36.463]   - Field: ‘local’
[10:26:36.463]   - Field: ‘owner’
[10:26:36.463]   - Field: ‘envir’
[10:26:36.463]   - Field: ‘packages’
[10:26:36.463]   - Field: ‘gc’
[10:26:36.463]   - Field: ‘conditions’
[10:26:36.463]   - Field: ‘expr’
[10:26:36.463]   - Field: ‘uuid’
[10:26:36.463]   - Field: ‘seed’
[10:26:36.463]   - Field: ‘version’
[10:26:36.463]   - Field: ‘result’
[10:26:36.464]   - Field: ‘asynchronous’
[10:26:36.464]   - Field: ‘calls’
[10:26:36.464]   - Field: ‘globals’
[10:26:36.464]   - Field: ‘stdout’
[10:26:36.464]   - Field: ‘earlySignal’
[10:26:36.464]   - Field: ‘lazy’
[10:26:36.464]   - Field: ‘state’
[10:26:36.464] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:36.464] - Launch lazy future ...
[10:26:36.465] Packages needed by the future expression (n = 1): ‘future’
[10:26:36.465] Packages needed by future strategies (n = 1): ‘future’
[10:26:36.466] {
[10:26:36.466]     {
[10:26:36.466]         {
[10:26:36.466]             ...future.startTime <- base::Sys.time()
[10:26:36.466]             {
[10:26:36.466]                 {
[10:26:36.466]                   {
[10:26:36.466]                     {
[10:26:36.466]                       base::local({
[10:26:36.466]                         has_future <- base::requireNamespace("future", 
[10:26:36.466]                           quietly = TRUE)
[10:26:36.466]                         if (has_future) {
[10:26:36.466]                           ns <- base::getNamespace("future")
[10:26:36.466]                           version <- ns[[".package"]][["version"]]
[10:26:36.466]                           if (is.null(version)) 
[10:26:36.466]                             version <- utils::packageVersion("future")
[10:26:36.466]                         }
[10:26:36.466]                         else {
[10:26:36.466]                           version <- NULL
[10:26:36.466]                         }
[10:26:36.466]                         if (!has_future || version < "1.8.0") {
[10:26:36.466]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.466]                             "", base::R.version$version.string), 
[10:26:36.466]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:36.466]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.466]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.466]                               "release", "version")], collapse = " "), 
[10:26:36.466]                             hostname = base::Sys.info()[["nodename"]])
[10:26:36.466]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.466]                             info)
[10:26:36.466]                           info <- base::paste(info, collapse = "; ")
[10:26:36.466]                           if (!has_future) {
[10:26:36.466]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.466]                               info)
[10:26:36.466]                           }
[10:26:36.466]                           else {
[10:26:36.466]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.466]                               info, version)
[10:26:36.466]                           }
[10:26:36.466]                           base::stop(msg)
[10:26:36.466]                         }
[10:26:36.466]                       })
[10:26:36.466]                     }
[10:26:36.466]                     base::local({
[10:26:36.466]                       for (pkg in "future") {
[10:26:36.466]                         base::loadNamespace(pkg)
[10:26:36.466]                         base::library(pkg, character.only = TRUE)
[10:26:36.466]                       }
[10:26:36.466]                     })
[10:26:36.466]                   }
[10:26:36.466]                   options(future.plan = NULL)
[10:26:36.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.466]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:36.466]                   {
[10:26:36.466]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.466]                     if (!future$lazy) 
[10:26:36.466]                       future <- run(future)
[10:26:36.466]                     invisible(future)
[10:26:36.466]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.466]                 }
[10:26:36.466]                 ...future.workdir <- getwd()
[10:26:36.466]             }
[10:26:36.466]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.466]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.466]         }
[10:26:36.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.466]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.466]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.466]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.466]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.466]             base::names(...future.oldOptions))
[10:26:36.466]     }
[10:26:36.466]     if (FALSE) {
[10:26:36.466]     }
[10:26:36.466]     else {
[10:26:36.466]         if (TRUE) {
[10:26:36.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.466]                 open = "w")
[10:26:36.466]         }
[10:26:36.466]         else {
[10:26:36.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.466]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.466]         }
[10:26:36.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.466]             base::sink(type = "output", split = FALSE)
[10:26:36.466]             base::close(...future.stdout)
[10:26:36.466]         }, add = TRUE)
[10:26:36.466]     }
[10:26:36.466]     ...future.frame <- base::sys.nframe()
[10:26:36.466]     ...future.conditions <- base::list()
[10:26:36.466]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.466]     if (FALSE) {
[10:26:36.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.466]     }
[10:26:36.466]     ...future.result <- base::tryCatch({
[10:26:36.466]         base::withCallingHandlers({
[10:26:36.466]             ...future.value <- base::withVisible(base::local({
[10:26:36.466]                 a <- 1L
[10:26:36.466]                 plan_a <- unclass(future::plan("list"))
[10:26:36.466]                 nested_a <- nested[-1]
[10:26:36.466]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:36.466]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.466]                   strategy2))
[10:26:36.466]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:36.466]                   "init") <- NULL
[10:26:36.466]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:36.466]                   "init") <- NULL
[10:26:36.466]                 stopifnot(all.equal(plan_a, nested_a))
[10:26:36.466]                 y %<-% {
[10:26:36.466]                   b <- 2L
[10:26:36.466]                   plan_b <- future::plan("list")
[10:26:36.466]                   nested_b <- nested_a[-1]
[10:26:36.466]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:36.466]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.466]                     "sequential"))
[10:26:36.466]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:36.466]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:36.466]                 }
[10:26:36.466]                 y
[10:26:36.466]             }))
[10:26:36.466]             future::FutureResult(value = ...future.value$value, 
[10:26:36.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.466]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.466]                     ...future.globalenv.names))
[10:26:36.466]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.466]         }, condition = base::local({
[10:26:36.466]             c <- base::c
[10:26:36.466]             inherits <- base::inherits
[10:26:36.466]             invokeRestart <- base::invokeRestart
[10:26:36.466]             length <- base::length
[10:26:36.466]             list <- base::list
[10:26:36.466]             seq.int <- base::seq.int
[10:26:36.466]             signalCondition <- base::signalCondition
[10:26:36.466]             sys.calls <- base::sys.calls
[10:26:36.466]             `[[` <- base::`[[`
[10:26:36.466]             `+` <- base::`+`
[10:26:36.466]             `<<-` <- base::`<<-`
[10:26:36.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.466]                   3L)]
[10:26:36.466]             }
[10:26:36.466]             function(cond) {
[10:26:36.466]                 is_error <- inherits(cond, "error")
[10:26:36.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.466]                   NULL)
[10:26:36.466]                 if (is_error) {
[10:26:36.466]                   sessionInformation <- function() {
[10:26:36.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.466]                       search = base::search(), system = base::Sys.info())
[10:26:36.466]                   }
[10:26:36.466]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.466]                     cond$call), session = sessionInformation(), 
[10:26:36.466]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.466]                   signalCondition(cond)
[10:26:36.466]                 }
[10:26:36.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.466]                 "immediateCondition"))) {
[10:26:36.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.466]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.466]                   if (TRUE && !signal) {
[10:26:36.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.466]                     {
[10:26:36.466]                       inherits <- base::inherits
[10:26:36.466]                       invokeRestart <- base::invokeRestart
[10:26:36.466]                       is.null <- base::is.null
[10:26:36.466]                       muffled <- FALSE
[10:26:36.466]                       if (inherits(cond, "message")) {
[10:26:36.466]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.466]                         if (muffled) 
[10:26:36.466]                           invokeRestart("muffleMessage")
[10:26:36.466]                       }
[10:26:36.466]                       else if (inherits(cond, "warning")) {
[10:26:36.466]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.466]                         if (muffled) 
[10:26:36.466]                           invokeRestart("muffleWarning")
[10:26:36.466]                       }
[10:26:36.466]                       else if (inherits(cond, "condition")) {
[10:26:36.466]                         if (!is.null(pattern)) {
[10:26:36.466]                           computeRestarts <- base::computeRestarts
[10:26:36.466]                           grepl <- base::grepl
[10:26:36.466]                           restarts <- computeRestarts(cond)
[10:26:36.466]                           for (restart in restarts) {
[10:26:36.466]                             name <- restart$name
[10:26:36.466]                             if (is.null(name)) 
[10:26:36.466]                               next
[10:26:36.466]                             if (!grepl(pattern, name)) 
[10:26:36.466]                               next
[10:26:36.466]                             invokeRestart(restart)
[10:26:36.466]                             muffled <- TRUE
[10:26:36.466]                             break
[10:26:36.466]                           }
[10:26:36.466]                         }
[10:26:36.466]                       }
[10:26:36.466]                       invisible(muffled)
[10:26:36.466]                     }
[10:26:36.466]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.466]                   }
[10:26:36.466]                 }
[10:26:36.466]                 else {
[10:26:36.466]                   if (TRUE) {
[10:26:36.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.466]                     {
[10:26:36.466]                       inherits <- base::inherits
[10:26:36.466]                       invokeRestart <- base::invokeRestart
[10:26:36.466]                       is.null <- base::is.null
[10:26:36.466]                       muffled <- FALSE
[10:26:36.466]                       if (inherits(cond, "message")) {
[10:26:36.466]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.466]                         if (muffled) 
[10:26:36.466]                           invokeRestart("muffleMessage")
[10:26:36.466]                       }
[10:26:36.466]                       else if (inherits(cond, "warning")) {
[10:26:36.466]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.466]                         if (muffled) 
[10:26:36.466]                           invokeRestart("muffleWarning")
[10:26:36.466]                       }
[10:26:36.466]                       else if (inherits(cond, "condition")) {
[10:26:36.466]                         if (!is.null(pattern)) {
[10:26:36.466]                           computeRestarts <- base::computeRestarts
[10:26:36.466]                           grepl <- base::grepl
[10:26:36.466]                           restarts <- computeRestarts(cond)
[10:26:36.466]                           for (restart in restarts) {
[10:26:36.466]                             name <- restart$name
[10:26:36.466]                             if (is.null(name)) 
[10:26:36.466]                               next
[10:26:36.466]                             if (!grepl(pattern, name)) 
[10:26:36.466]                               next
[10:26:36.466]                             invokeRestart(restart)
[10:26:36.466]                             muffled <- TRUE
[10:26:36.466]                             break
[10:26:36.466]                           }
[10:26:36.466]                         }
[10:26:36.466]                       }
[10:26:36.466]                       invisible(muffled)
[10:26:36.466]                     }
[10:26:36.466]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.466]                   }
[10:26:36.466]                 }
[10:26:36.466]             }
[10:26:36.466]         }))
[10:26:36.466]     }, error = function(ex) {
[10:26:36.466]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.466]                 ...future.rng), started = ...future.startTime, 
[10:26:36.466]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.466]             version = "1.8"), class = "FutureResult")
[10:26:36.466]     }, finally = {
[10:26:36.466]         if (!identical(...future.workdir, getwd())) 
[10:26:36.466]             setwd(...future.workdir)
[10:26:36.466]         {
[10:26:36.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.466]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.466]             }
[10:26:36.466]             base::options(...future.oldOptions)
[10:26:36.466]             if (.Platform$OS.type == "windows") {
[10:26:36.466]                 old_names <- names(...future.oldEnvVars)
[10:26:36.466]                 envs <- base::Sys.getenv()
[10:26:36.466]                 names <- names(envs)
[10:26:36.466]                 common <- intersect(names, old_names)
[10:26:36.466]                 added <- setdiff(names, old_names)
[10:26:36.466]                 removed <- setdiff(old_names, names)
[10:26:36.466]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.466]                   envs[common]]
[10:26:36.466]                 NAMES <- toupper(changed)
[10:26:36.466]                 args <- list()
[10:26:36.466]                 for (kk in seq_along(NAMES)) {
[10:26:36.466]                   name <- changed[[kk]]
[10:26:36.466]                   NAME <- NAMES[[kk]]
[10:26:36.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.466]                     next
[10:26:36.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.466]                 }
[10:26:36.466]                 NAMES <- toupper(added)
[10:26:36.466]                 for (kk in seq_along(NAMES)) {
[10:26:36.466]                   name <- added[[kk]]
[10:26:36.466]                   NAME <- NAMES[[kk]]
[10:26:36.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.466]                     next
[10:26:36.466]                   args[[name]] <- ""
[10:26:36.466]                 }
[10:26:36.466]                 NAMES <- toupper(removed)
[10:26:36.466]                 for (kk in seq_along(NAMES)) {
[10:26:36.466]                   name <- removed[[kk]]
[10:26:36.466]                   NAME <- NAMES[[kk]]
[10:26:36.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.466]                     next
[10:26:36.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.466]                 }
[10:26:36.466]                 if (length(args) > 0) 
[10:26:36.466]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.466]             }
[10:26:36.466]             else {
[10:26:36.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.466]             }
[10:26:36.466]             {
[10:26:36.466]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.466]                   0L) {
[10:26:36.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.466]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.466]                   base::options(opts)
[10:26:36.466]                 }
[10:26:36.466]                 {
[10:26:36.466]                   {
[10:26:36.466]                     NULL
[10:26:36.466]                     RNGkind("Mersenne-Twister")
[10:26:36.466]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:36.466]                       inherits = FALSE)
[10:26:36.466]                   }
[10:26:36.466]                   options(future.plan = NULL)
[10:26:36.466]                   if (is.na(NA_character_)) 
[10:26:36.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.466]                   future::plan(list(a = function (..., envir = parent.frame()) 
[10:26:36.466]                   {
[10:26:36.466]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.466]                     if (!future$lazy) 
[10:26:36.466]                       future <- run(future)
[10:26:36.466]                     invisible(future)
[10:26:36.466]                   }, b = function (..., envir = parent.frame()) 
[10:26:36.466]                   {
[10:26:36.466]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.466]                     if (!future$lazy) 
[10:26:36.466]                       future <- run(future)
[10:26:36.466]                     invisible(future)
[10:26:36.466]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.466]                 }
[10:26:36.466]             }
[10:26:36.466]         }
[10:26:36.466]     })
[10:26:36.466]     if (TRUE) {
[10:26:36.466]         base::sink(type = "output", split = FALSE)
[10:26:36.466]         if (TRUE) {
[10:26:36.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.466]         }
[10:26:36.466]         else {
[10:26:36.466]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.466]         }
[10:26:36.466]         base::close(...future.stdout)
[10:26:36.466]         ...future.stdout <- NULL
[10:26:36.466]     }
[10:26:36.466]     ...future.result$conditions <- ...future.conditions
[10:26:36.466]     ...future.result$finished <- base::Sys.time()
[10:26:36.466]     ...future.result
[10:26:36.466] }
[10:26:36.468] assign_globals() ...
[10:26:36.468] List of 2
[10:26:36.468]  $ nested   :List of 2
[10:26:36.468]   ..$ a:function (..., envir = parent.frame())  
[10:26:36.468]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:36.468]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.468]   ..$ b:function (..., envir = parent.frame())  
[10:26:36.468]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:36.468]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.468]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:36.468]  $ strategy2: chr "sequential"
[10:26:36.468]  - attr(*, "where")=List of 2
[10:26:36.468]   ..$ nested   :<environment: R_EmptyEnv> 
[10:26:36.468]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:26:36.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.468]  - attr(*, "resolved")= logi FALSE
[10:26:36.468]  - attr(*, "total_size")= num 23144
[10:26:36.468]  - attr(*, "already-done")= logi TRUE
[10:26:36.475] - copied ‘nested’ to environment
[10:26:36.475] - copied ‘strategy2’ to environment
[10:26:36.475] assign_globals() ... done
[10:26:36.476] plan(): Setting new future strategy stack:
[10:26:36.476] List of future strategies:
[10:26:36.476] 1. sequential:
[10:26:36.476]    - args: function (..., envir = parent.frame())
[10:26:36.476]    - tweaked: FALSE
[10:26:36.476]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.476] plan(): nbrOfWorkers() = 1
[10:26:36.513] plan(): Setting new future strategy stack:
[10:26:36.513] List of future strategies:
[10:26:36.513] 1. sequential:
[10:26:36.513]    - args: function (..., envir = parent.frame())
[10:26:36.513]    - tweaked: FALSE
[10:26:36.513]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.513] 2. sequential:
[10:26:36.513]    - args: function (..., envir = parent.frame())
[10:26:36.513]    - tweaked: FALSE
[10:26:36.513]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.514] plan(): nbrOfWorkers() = 1
[10:26:36.514] SequentialFuture started (and completed)
[10:26:36.514] signalConditions() ...
[10:26:36.514]  - include = ‘immediateCondition’
[10:26:36.514]  - exclude = 
[10:26:36.514]  - resignal = FALSE
[10:26:36.514]  - Number of conditions: 54
[10:26:36.514] signalConditions() ... done
[10:26:36.515] - Launch lazy future ... done
[10:26:36.515] run() for ‘SequentialFuture’ ... done
[10:26:36.515] signalConditions() ...
[10:26:36.515]  - include = ‘immediateCondition’
[10:26:36.515]  - exclude = 
[10:26:36.515]  - resignal = FALSE
[10:26:36.515]  - Number of conditions: 54
[10:26:36.515] signalConditions() ... done
[10:26:36.515] Future state: ‘finished’
[10:26:36.515] signalConditions() ...
[10:26:36.516]  - include = ‘condition’
[10:26:36.516]  - exclude = ‘immediateCondition’
[10:26:36.516]  - resignal = TRUE
[10:26:36.516]  - Number of conditions: 54
[10:26:36.516]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.477] getGlobalsAndPackages() ...
[10:26:36.516]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.478] Searching for globals...
[10:26:36.516]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.496] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:26:36.516]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.496] Searching for globals ... DONE
[10:26:36.516]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.496] Resolving globals: FALSE
[10:26:36.516]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.497] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[10:26:36.517]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.497] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:26:36.517]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.498] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:26:36.517]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.498] 
[10:26:36.517]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.498] getGlobalsAndPackages() ... DONE
[10:26:36.517]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.498] run() for ‘Future’ ...
[10:26:36.517]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.498] - state: ‘created’
[10:26:36.517]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.498] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:36.518]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:36.518]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:36.518]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499]   - Field: ‘label’
[10:26:36.518]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499]   - Field: ‘local’
[10:26:36.518]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499]   - Field: ‘owner’
[10:26:36.518]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499]   - Field: ‘envir’
[10:26:36.518]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499]   - Field: ‘packages’
[10:26:36.518]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499]   - Field: ‘gc’
[10:26:36.519]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.499]   - Field: ‘conditions’
[10:26:36.519]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘expr’
[10:26:36.519]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘uuid’
[10:26:36.519]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘seed’
[10:26:36.519]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘version’
[10:26:36.519]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘result’
[10:26:36.519]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘asynchronous’
[10:26:36.519]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘calls’
[10:26:36.520]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘globals’
[10:26:36.520]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘stdout’
[10:26:36.520]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘earlySignal’
[10:26:36.520]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.500]   - Field: ‘lazy’
[10:26:36.520]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.501]   - Field: ‘state’
[10:26:36.520]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:36.520]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.501] - Launch lazy future ...
[10:26:36.520]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.501] Packages needed by the future expression (n = 0): <none>
[10:26:36.521]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.501] Packages needed by future strategies (n = 0): <none>
[10:26:36.521]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.502] {
[10:26:36.502]     {
[10:26:36.502]         {
[10:26:36.502]             ...future.startTime <- base::Sys.time()
[10:26:36.502]             {
[10:26:36.502]                 {
[10:26:36.502]                   {
[10:26:36.502]                     base::local({
[10:26:36.502]                       has_future <- base::requireNamespace("future", 
[10:26:36.502]                         quietly = TRUE)
[10:26:36.502]                       if (has_future) {
[10:26:36.502]                         ns <- base::getNamespace("future")
[10:26:36.502]                         version <- ns[[".package"]][["version"]]
[10:26:36.502]                         if (is.null(version)) 
[10:26:36.502]                           version <- utils::packageVersion("future")
[10:26:36.502]                       }
[10:26:36.502]                       else {
[10:26:36.502]                         version <- NULL
[10:26:36.502]                       }
[10:26:36.502]                       if (!has_future || version < "1.8.0") {
[10:26:36.502]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.502]                           "", base::R.version$version.string), 
[10:26:36.502]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:36.502]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.502]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.502]                             "release", "version")], collapse = " "), 
[10:26:36.502]                           hostname = base::Sys.info()[["nodename"]])
[10:26:36.502]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.502]                           info)
[10:26:36.502]                         info <- base::paste(info, collapse = "; ")
[10:26:36.502]                         if (!has_future) {
[10:26:36.502]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.502]                             info)
[10:26:36.502]                         }
[10:26:36.502]                         else {
[10:26:36.502]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.502]                             info, version)
[10:26:36.502]                         }
[10:26:36.502]                         base::stop(msg)
[10:26:36.502]                       }
[10:26:36.502]                     })
[10:26:36.502]                   }
[10:26:36.502]                   options(future.plan = NULL)
[10:26:36.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:36.502]                 }
[10:26:36.502]                 ...future.workdir <- getwd()
[10:26:36.502]             }
[10:26:36.502]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.502]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.502]         }
[10:26:36.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.502]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.502]             base::names(...future.oldOptions))
[10:26:36.502]     }
[10:26:36.502]     if (FALSE) {
[10:26:36.502]     }
[10:26:36.502]     else {
[10:26:36.502]         if (TRUE) {
[10:26:36.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.502]                 open = "w")
[10:26:36.502]         }
[10:26:36.502]         else {
[10:26:36.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.502]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.502]         }
[10:26:36.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.502]             base::sink(type = "output", split = FALSE)
[10:26:36.502]             base::close(...future.stdout)
[10:26:36.502]         }, add = TRUE)
[10:26:36.502]     }
[10:26:36.502]     ...future.frame <- base::sys.nframe()
[10:26:36.502]     ...future.conditions <- base::list()
[10:26:36.502]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.502]     if (FALSE) {
[10:26:36.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.502]     }
[10:26:36.502]     ...future.result <- base::tryCatch({
[10:26:36.502]         base::withCallingHandlers({
[10:26:36.502]             ...future.value <- base::withVisible(base::local({
[10:26:36.502]                 b <- 2L
[10:26:36.502]                 plan_b <- future::plan("list")
[10:26:36.502]                 nested_b <- nested_a[-1]
[10:26:36.502]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:36.502]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.502]                   "sequential"))
[10:26:36.502]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:36.502]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:36.502]             }))
[10:26:36.502]             future::FutureResult(value = ...future.value$value, 
[10:26:36.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.502]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.502]                     ...future.globalenv.names))
[10:26:36.502]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.502]         }, condition = base::local({
[10:26:36.502]             c <- base::c
[10:26:36.502]             inherits <- base::inherits
[10:26:36.502]             invokeRestart <- base::invokeRestart
[10:26:36.502]             length <- base::length
[10:26:36.502]             list <- base::list
[10:26:36.502]             seq.int <- base::seq.int
[10:26:36.502]             signalCondition <- base::signalCondition
[10:26:36.502]             sys.calls <- base::sys.calls
[10:26:36.502]             `[[` <- base::`[[`
[10:26:36.502]             `+` <- base::`+`
[10:26:36.502]             `<<-` <- base::`<<-`
[10:26:36.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.502]                   3L)]
[10:26:36.502]             }
[10:26:36.502]             function(cond) {
[10:26:36.502]                 is_error <- inherits(cond, "error")
[10:26:36.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.502]                   NULL)
[10:26:36.502]                 if (is_error) {
[10:26:36.502]                   sessionInformation <- function() {
[10:26:36.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.502]                       search = base::search(), system = base::Sys.info())
[10:26:36.502]                   }
[10:26:36.502]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.502]                     cond$call), session = sessionInformation(), 
[10:26:36.502]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.502]                   signalCondition(cond)
[10:26:36.502]                 }
[10:26:36.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.502]                 "immediateCondition"))) {
[10:26:36.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.502]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.502]                   if (TRUE && !signal) {
[10:26:36.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.502]                     {
[10:26:36.502]                       inherits <- base::inherits
[10:26:36.502]                       invokeRestart <- base::invokeRestart
[10:26:36.502]                       is.null <- base::is.null
[10:26:36.502]                       muffled <- FALSE
[10:26:36.502]                       if (inherits(cond, "message")) {
[10:26:36.502]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.502]                         if (muffled) 
[10:26:36.502]                           invokeRestart("muffleMessage")
[10:26:36.502]                       }
[10:26:36.502]                       else if (inherits(cond, "warning")) {
[10:26:36.502]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.502]                         if (muffled) 
[10:26:36.502]                           invokeRestart("muffleWarning")
[10:26:36.502]                       }
[10:26:36.502]                       else if (inherits(cond, "condition")) {
[10:26:36.502]                         if (!is.null(pattern)) {
[10:26:36.502]                           computeRestarts <- base::computeRestarts
[10:26:36.502]                           grepl <- base::grepl
[10:26:36.502]                           restarts <- computeRestarts(cond)
[10:26:36.502]                           for (restart in restarts) {
[10:26:36.502]                             name <- restart$name
[10:26:36.502]                             if (is.null(name)) 
[10:26:36.502]                               next
[10:26:36.502]                             if (!grepl(pattern, name)) 
[10:26:36.502]                               next
[10:26:36.502]                             invokeRestart(restart)
[10:26:36.502]                             muffled <- TRUE
[10:26:36.502]                             break
[10:26:36.502]                           }
[10:26:36.502]                         }
[10:26:36.502]                       }
[10:26:36.502]                       invisible(muffled)
[10:26:36.502]                     }
[10:26:36.502]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.502]                   }
[10:26:36.502]                 }
[10:26:36.502]                 else {
[10:26:36.502]                   if (TRUE) {
[10:26:36.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.502]                     {
[10:26:36.502]                       inherits <- base::inherits
[10:26:36.502]                       invokeRestart <- base::invokeRestart
[10:26:36.502]                       is.null <- base::is.null
[10:26:36.502]                       muffled <- FALSE
[10:26:36.502]                       if (inherits(cond, "message")) {
[10:26:36.502]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.502]                         if (muffled) 
[10:26:36.502]                           invokeRestart("muffleMessage")
[10:26:36.502]                       }
[10:26:36.502]                       else if (inherits(cond, "warning")) {
[10:26:36.502]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.502]                         if (muffled) 
[10:26:36.502]                           invokeRestart("muffleWarning")
[10:26:36.502]                       }
[10:26:36.502]                       else if (inherits(cond, "condition")) {
[10:26:36.502]                         if (!is.null(pattern)) {
[10:26:36.502]                           computeRestarts <- base::computeRestarts
[10:26:36.502]                           grepl <- base::grepl
[10:26:36.502]                           restarts <- computeRestarts(cond)
[10:26:36.502]                           for (restart in restarts) {
[10:26:36.502]                             name <- restart$name
[10:26:36.502]                             if (is.null(name)) 
[10:26:36.502]                               next
[10:26:36.502]                             if (!grepl(pattern, name)) 
[10:26:36.502]                               next
[10:26:36.502]                             invokeRestart(restart)
[10:26:36.502]                             muffled <- TRUE
[10:26:36.502]                             break
[10:26:36.502]                           }
[10:26:36.502]                         }
[10:26:36.502]                       }
[10:26:36.502]                       invisible(muffled)
[10:26:36.502]                     }
[10:26:36.502]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.502]                   }
[10:26:36.502]                 }
[10:26:36.502]             }
[10:26:36.502]         }))
[10:26:36.502]     }, error = function(ex) {
[10:26:36.502]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.502]                 ...future.rng), started = ...future.startTime, 
[10:26:36.502]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.502]             version = "1.8"), class = "FutureResult")
[10:26:36.502]     }, finally = {
[10:26:36.502]         if (!identical(...future.workdir, getwd())) 
[10:26:36.502]             setwd(...future.workdir)
[10:26:36.502]         {
[10:26:36.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.502]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.502]             }
[10:26:36.502]             base::options(...future.oldOptions)
[10:26:36.502]             if (.Platform$OS.type == "windows") {
[10:26:36.502]                 old_names <- names(...future.oldEnvVars)
[10:26:36.502]                 envs <- base::Sys.getenv()
[10:26:36.502]                 names <- names(envs)
[10:26:36.502]                 common <- intersect(names, old_names)
[10:26:36.502]                 added <- setdiff(names, old_names)
[10:26:36.502]                 removed <- setdiff(old_names, names)
[10:26:36.502]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.502]                   envs[common]]
[10:26:36.502]                 NAMES <- toupper(changed)
[10:26:36.502]                 args <- list()
[10:26:36.502]                 for (kk in seq_along(NAMES)) {
[10:26:36.502]                   name <- changed[[kk]]
[10:26:36.502]                   NAME <- NAMES[[kk]]
[10:26:36.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.502]                     next
[10:26:36.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.502]                 }
[10:26:36.502]                 NAMES <- toupper(added)
[10:26:36.502]                 for (kk in seq_along(NAMES)) {
[10:26:36.502]                   name <- added[[kk]]
[10:26:36.502]                   NAME <- NAMES[[kk]]
[10:26:36.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.502]                     next
[10:26:36.502]                   args[[name]] <- ""
[10:26:36.502]                 }
[10:26:36.502]                 NAMES <- toupper(removed)
[10:26:36.502]                 for (kk in seq_along(NAMES)) {
[10:26:36.502]                   name <- removed[[kk]]
[10:26:36.502]                   NAME <- NAMES[[kk]]
[10:26:36.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.502]                     next
[10:26:36.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.502]                 }
[10:26:36.502]                 if (length(args) > 0) 
[10:26:36.502]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.502]             }
[10:26:36.502]             else {
[10:26:36.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.502]             }
[10:26:36.502]             {
[10:26:36.502]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.502]                   0L) {
[10:26:36.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.502]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.502]                   base::options(opts)
[10:26:36.502]                 }
[10:26:36.502]                 {
[10:26:36.502]                   {
[10:26:36.502]                     NULL
[10:26:36.502]                     RNGkind("Mersenne-Twister")
[10:26:36.502]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:36.502]                       inherits = FALSE)
[10:26:36.502]                   }
[10:26:36.502]                   options(future.plan = NULL)
[10:26:36.502]                   if (is.na(NA_character_)) 
[10:26:36.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.502]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:36.502]                   {
[10:26:36.502]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.502]                     if (!future$lazy) 
[10:26:36.502]                       future <- run(future)
[10:26:36.502]                     invisible(future)
[10:26:36.502]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.502]                 }
[10:26:36.502]             }
[10:26:36.502]         }
[10:26:36.502]     })
[10:26:36.502]     if (TRUE) {
[10:26:36.502]         base::sink(type = "output", split = FALSE)
[10:26:36.502]         if (TRUE) {
[10:26:36.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.502]         }
[10:26:36.502]         else {
[10:26:36.502]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.502]         }
[10:26:36.502]         base::close(...future.stdout)
[10:26:36.502]         ...future.stdout <- NULL
[10:26:36.502]     }
[10:26:36.502]     ...future.result$conditions <- ...future.conditions
[10:26:36.502]     ...future.result$finished <- base::Sys.time()
[10:26:36.502]     ...future.result
[10:26:36.502] }
[10:26:36.521]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.503] assign_globals() ...
[10:26:36.521]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.503] List of 3
[10:26:36.503]  $ nested_a:List of 1
[10:26:36.503]   ..$ b:function (..., envir = parent.frame())  
[10:26:36.503]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:36.503]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.503]  $ a       : int 1
[10:26:36.503]  $ plan_a  :List of 1
[10:26:36.503]   ..$ b:function (..., envir = parent.frame())  
[10:26:36.503]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:36.503]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.503]  - attr(*, "where")=List of 3
[10:26:36.503]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:26:36.503]   ..$ a       :<environment: R_EmptyEnv> 
[10:26:36.503]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:26:36.503]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.503]  - attr(*, "resolved")= logi FALSE
[10:26:36.503]  - attr(*, "total_size")= num 23080
[10:26:36.503]  - attr(*, "already-done")= logi TRUE
[10:26:36.521]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.509] - copied ‘nested_a’ to environment
[10:26:36.521]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.509] - copied ‘a’ to environment
[10:26:36.521]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.509] - copied ‘plan_a’ to environment
[10:26:36.522]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.509] assign_globals() ... done
[10:26:36.522]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.510] plan(): Setting new future strategy stack:
[10:26:36.522]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.510] List of future strategies:
[10:26:36.510] 1. sequential:
[10:26:36.510]    - args: function (..., envir = parent.frame())
[10:26:36.510]    - tweaked: FALSE
[10:26:36.510]    - call: NULL
[10:26:36.522]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.510] plan(): nbrOfWorkers() = 1
[10:26:36.522]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.511] plan(): Setting new future strategy stack:
[10:26:36.522]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.511] List of future strategies:
[10:26:36.511] 1. sequential:
[10:26:36.511]    - args: function (..., envir = parent.frame())
[10:26:36.511]    - tweaked: FALSE
[10:26:36.511]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.522]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.512] plan(): nbrOfWorkers() = 1
[10:26:36.522]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.512] SequentialFuture started (and completed)
[10:26:36.523]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.512] - Launch lazy future ... done
[10:26:36.523]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.512] run() for ‘SequentialFuture’ ... done
[10:26:36.523] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:36.528] getGlobalsAndPackages() ...
[10:26:36.528] Searching for globals...
[10:26:36.530] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:36.530] Searching for globals ... DONE
[10:26:36.530] Resolving globals: FALSE
[10:26:36.531] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:36.531] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:36.531] - globals: [1] ‘data’
[10:26:36.531] - packages: [1] ‘future’
[10:26:36.531] getGlobalsAndPackages() ... DONE
[10:26:36.532] run() for ‘Future’ ...
[10:26:36.532] - state: ‘created’
[10:26:36.532] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:36.532] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:36.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:36.532]   - Field: ‘label’
[10:26:36.532]   - Field: ‘local’
[10:26:36.532]   - Field: ‘owner’
[10:26:36.533]   - Field: ‘envir’
[10:26:36.533]   - Field: ‘packages’
[10:26:36.533]   - Field: ‘gc’
[10:26:36.533]   - Field: ‘conditions’
[10:26:36.533]   - Field: ‘expr’
[10:26:36.533]   - Field: ‘uuid’
[10:26:36.533]   - Field: ‘seed’
[10:26:36.533]   - Field: ‘version’
[10:26:36.533]   - Field: ‘result’
[10:26:36.533]   - Field: ‘asynchronous’
[10:26:36.533]   - Field: ‘calls’
[10:26:36.534]   - Field: ‘globals’
[10:26:36.534]   - Field: ‘stdout’
[10:26:36.534]   - Field: ‘earlySignal’
[10:26:36.534]   - Field: ‘lazy’
[10:26:36.534]   - Field: ‘state’
[10:26:36.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:36.534] - Launch lazy future ...
[10:26:36.534] Packages needed by the future expression (n = 1): ‘future’
[10:26:36.534] Packages needed by future strategies (n = 1): ‘future’
[10:26:36.535] {
[10:26:36.535]     {
[10:26:36.535]         {
[10:26:36.535]             ...future.startTime <- base::Sys.time()
[10:26:36.535]             {
[10:26:36.535]                 {
[10:26:36.535]                   {
[10:26:36.535]                     {
[10:26:36.535]                       base::local({
[10:26:36.535]                         has_future <- base::requireNamespace("future", 
[10:26:36.535]                           quietly = TRUE)
[10:26:36.535]                         if (has_future) {
[10:26:36.535]                           ns <- base::getNamespace("future")
[10:26:36.535]                           version <- ns[[".package"]][["version"]]
[10:26:36.535]                           if (is.null(version)) 
[10:26:36.535]                             version <- utils::packageVersion("future")
[10:26:36.535]                         }
[10:26:36.535]                         else {
[10:26:36.535]                           version <- NULL
[10:26:36.535]                         }
[10:26:36.535]                         if (!has_future || version < "1.8.0") {
[10:26:36.535]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.535]                             "", base::R.version$version.string), 
[10:26:36.535]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:36.535]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.535]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.535]                               "release", "version")], collapse = " "), 
[10:26:36.535]                             hostname = base::Sys.info()[["nodename"]])
[10:26:36.535]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.535]                             info)
[10:26:36.535]                           info <- base::paste(info, collapse = "; ")
[10:26:36.535]                           if (!has_future) {
[10:26:36.535]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.535]                               info)
[10:26:36.535]                           }
[10:26:36.535]                           else {
[10:26:36.535]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.535]                               info, version)
[10:26:36.535]                           }
[10:26:36.535]                           base::stop(msg)
[10:26:36.535]                         }
[10:26:36.535]                       })
[10:26:36.535]                     }
[10:26:36.535]                     base::local({
[10:26:36.535]                       for (pkg in "future") {
[10:26:36.535]                         base::loadNamespace(pkg)
[10:26:36.535]                         base::library(pkg, character.only = TRUE)
[10:26:36.535]                       }
[10:26:36.535]                     })
[10:26:36.535]                   }
[10:26:36.535]                   options(future.plan = NULL)
[10:26:36.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.535]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:36.535]                   {
[10:26:36.535]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.535]                     if (!future$lazy) 
[10:26:36.535]                       future <- run(future)
[10:26:36.535]                     invisible(future)
[10:26:36.535]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.535]                 }
[10:26:36.535]                 ...future.workdir <- getwd()
[10:26:36.535]             }
[10:26:36.535]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.535]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.535]         }
[10:26:36.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.535]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.535]             base::names(...future.oldOptions))
[10:26:36.535]     }
[10:26:36.535]     if (FALSE) {
[10:26:36.535]     }
[10:26:36.535]     else {
[10:26:36.535]         if (TRUE) {
[10:26:36.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.535]                 open = "w")
[10:26:36.535]         }
[10:26:36.535]         else {
[10:26:36.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.535]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.535]         }
[10:26:36.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.535]             base::sink(type = "output", split = FALSE)
[10:26:36.535]             base::close(...future.stdout)
[10:26:36.535]         }, add = TRUE)
[10:26:36.535]     }
[10:26:36.535]     ...future.frame <- base::sys.nframe()
[10:26:36.535]     ...future.conditions <- base::list()
[10:26:36.535]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.535]     if (FALSE) {
[10:26:36.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.535]     }
[10:26:36.535]     ...future.result <- base::tryCatch({
[10:26:36.535]         base::withCallingHandlers({
[10:26:36.535]             ...future.value <- base::withVisible(base::local({
[10:26:36.535]                 value(future(subset(data, a == 2)))
[10:26:36.535]             }))
[10:26:36.535]             future::FutureResult(value = ...future.value$value, 
[10:26:36.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.535]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.535]                     ...future.globalenv.names))
[10:26:36.535]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.535]         }, condition = base::local({
[10:26:36.535]             c <- base::c
[10:26:36.535]             inherits <- base::inherits
[10:26:36.535]             invokeRestart <- base::invokeRestart
[10:26:36.535]             length <- base::length
[10:26:36.535]             list <- base::list
[10:26:36.535]             seq.int <- base::seq.int
[10:26:36.535]             signalCondition <- base::signalCondition
[10:26:36.535]             sys.calls <- base::sys.calls
[10:26:36.535]             `[[` <- base::`[[`
[10:26:36.535]             `+` <- base::`+`
[10:26:36.535]             `<<-` <- base::`<<-`
[10:26:36.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.535]                   3L)]
[10:26:36.535]             }
[10:26:36.535]             function(cond) {
[10:26:36.535]                 is_error <- inherits(cond, "error")
[10:26:36.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.535]                   NULL)
[10:26:36.535]                 if (is_error) {
[10:26:36.535]                   sessionInformation <- function() {
[10:26:36.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.535]                       search = base::search(), system = base::Sys.info())
[10:26:36.535]                   }
[10:26:36.535]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.535]                     cond$call), session = sessionInformation(), 
[10:26:36.535]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.535]                   signalCondition(cond)
[10:26:36.535]                 }
[10:26:36.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.535]                 "immediateCondition"))) {
[10:26:36.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.535]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.535]                   if (TRUE && !signal) {
[10:26:36.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.535]                     {
[10:26:36.535]                       inherits <- base::inherits
[10:26:36.535]                       invokeRestart <- base::invokeRestart
[10:26:36.535]                       is.null <- base::is.null
[10:26:36.535]                       muffled <- FALSE
[10:26:36.535]                       if (inherits(cond, "message")) {
[10:26:36.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.535]                         if (muffled) 
[10:26:36.535]                           invokeRestart("muffleMessage")
[10:26:36.535]                       }
[10:26:36.535]                       else if (inherits(cond, "warning")) {
[10:26:36.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.535]                         if (muffled) 
[10:26:36.535]                           invokeRestart("muffleWarning")
[10:26:36.535]                       }
[10:26:36.535]                       else if (inherits(cond, "condition")) {
[10:26:36.535]                         if (!is.null(pattern)) {
[10:26:36.535]                           computeRestarts <- base::computeRestarts
[10:26:36.535]                           grepl <- base::grepl
[10:26:36.535]                           restarts <- computeRestarts(cond)
[10:26:36.535]                           for (restart in restarts) {
[10:26:36.535]                             name <- restart$name
[10:26:36.535]                             if (is.null(name)) 
[10:26:36.535]                               next
[10:26:36.535]                             if (!grepl(pattern, name)) 
[10:26:36.535]                               next
[10:26:36.535]                             invokeRestart(restart)
[10:26:36.535]                             muffled <- TRUE
[10:26:36.535]                             break
[10:26:36.535]                           }
[10:26:36.535]                         }
[10:26:36.535]                       }
[10:26:36.535]                       invisible(muffled)
[10:26:36.535]                     }
[10:26:36.535]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.535]                   }
[10:26:36.535]                 }
[10:26:36.535]                 else {
[10:26:36.535]                   if (TRUE) {
[10:26:36.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.535]                     {
[10:26:36.535]                       inherits <- base::inherits
[10:26:36.535]                       invokeRestart <- base::invokeRestart
[10:26:36.535]                       is.null <- base::is.null
[10:26:36.535]                       muffled <- FALSE
[10:26:36.535]                       if (inherits(cond, "message")) {
[10:26:36.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.535]                         if (muffled) 
[10:26:36.535]                           invokeRestart("muffleMessage")
[10:26:36.535]                       }
[10:26:36.535]                       else if (inherits(cond, "warning")) {
[10:26:36.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.535]                         if (muffled) 
[10:26:36.535]                           invokeRestart("muffleWarning")
[10:26:36.535]                       }
[10:26:36.535]                       else if (inherits(cond, "condition")) {
[10:26:36.535]                         if (!is.null(pattern)) {
[10:26:36.535]                           computeRestarts <- base::computeRestarts
[10:26:36.535]                           grepl <- base::grepl
[10:26:36.535]                           restarts <- computeRestarts(cond)
[10:26:36.535]                           for (restart in restarts) {
[10:26:36.535]                             name <- restart$name
[10:26:36.535]                             if (is.null(name)) 
[10:26:36.535]                               next
[10:26:36.535]                             if (!grepl(pattern, name)) 
[10:26:36.535]                               next
[10:26:36.535]                             invokeRestart(restart)
[10:26:36.535]                             muffled <- TRUE
[10:26:36.535]                             break
[10:26:36.535]                           }
[10:26:36.535]                         }
[10:26:36.535]                       }
[10:26:36.535]                       invisible(muffled)
[10:26:36.535]                     }
[10:26:36.535]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.535]                   }
[10:26:36.535]                 }
[10:26:36.535]             }
[10:26:36.535]         }))
[10:26:36.535]     }, error = function(ex) {
[10:26:36.535]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.535]                 ...future.rng), started = ...future.startTime, 
[10:26:36.535]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.535]             version = "1.8"), class = "FutureResult")
[10:26:36.535]     }, finally = {
[10:26:36.535]         if (!identical(...future.workdir, getwd())) 
[10:26:36.535]             setwd(...future.workdir)
[10:26:36.535]         {
[10:26:36.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.535]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.535]             }
[10:26:36.535]             base::options(...future.oldOptions)
[10:26:36.535]             if (.Platform$OS.type == "windows") {
[10:26:36.535]                 old_names <- names(...future.oldEnvVars)
[10:26:36.535]                 envs <- base::Sys.getenv()
[10:26:36.535]                 names <- names(envs)
[10:26:36.535]                 common <- intersect(names, old_names)
[10:26:36.535]                 added <- setdiff(names, old_names)
[10:26:36.535]                 removed <- setdiff(old_names, names)
[10:26:36.535]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.535]                   envs[common]]
[10:26:36.535]                 NAMES <- toupper(changed)
[10:26:36.535]                 args <- list()
[10:26:36.535]                 for (kk in seq_along(NAMES)) {
[10:26:36.535]                   name <- changed[[kk]]
[10:26:36.535]                   NAME <- NAMES[[kk]]
[10:26:36.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.535]                     next
[10:26:36.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.535]                 }
[10:26:36.535]                 NAMES <- toupper(added)
[10:26:36.535]                 for (kk in seq_along(NAMES)) {
[10:26:36.535]                   name <- added[[kk]]
[10:26:36.535]                   NAME <- NAMES[[kk]]
[10:26:36.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.535]                     next
[10:26:36.535]                   args[[name]] <- ""
[10:26:36.535]                 }
[10:26:36.535]                 NAMES <- toupper(removed)
[10:26:36.535]                 for (kk in seq_along(NAMES)) {
[10:26:36.535]                   name <- removed[[kk]]
[10:26:36.535]                   NAME <- NAMES[[kk]]
[10:26:36.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.535]                     next
[10:26:36.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.535]                 }
[10:26:36.535]                 if (length(args) > 0) 
[10:26:36.535]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.535]             }
[10:26:36.535]             else {
[10:26:36.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.535]             }
[10:26:36.535]             {
[10:26:36.535]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.535]                   0L) {
[10:26:36.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.535]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.535]                   base::options(opts)
[10:26:36.535]                 }
[10:26:36.535]                 {
[10:26:36.535]                   {
[10:26:36.535]                     NULL
[10:26:36.535]                     RNGkind("Mersenne-Twister")
[10:26:36.535]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:36.535]                       inherits = FALSE)
[10:26:36.535]                   }
[10:26:36.535]                   options(future.plan = NULL)
[10:26:36.535]                   if (is.na(NA_character_)) 
[10:26:36.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.535]                   future::plan(list(a = function (..., envir = parent.frame()) 
[10:26:36.535]                   {
[10:26:36.535]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.535]                     if (!future$lazy) 
[10:26:36.535]                       future <- run(future)
[10:26:36.535]                     invisible(future)
[10:26:36.535]                   }, b = function (..., envir = parent.frame()) 
[10:26:36.535]                   {
[10:26:36.535]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.535]                     if (!future$lazy) 
[10:26:36.535]                       future <- run(future)
[10:26:36.535]                     invisible(future)
[10:26:36.535]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.535]                 }
[10:26:36.535]             }
[10:26:36.535]         }
[10:26:36.535]     })
[10:26:36.535]     if (TRUE) {
[10:26:36.535]         base::sink(type = "output", split = FALSE)
[10:26:36.535]         if (TRUE) {
[10:26:36.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.535]         }
[10:26:36.535]         else {
[10:26:36.535]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.535]         }
[10:26:36.535]         base::close(...future.stdout)
[10:26:36.535]         ...future.stdout <- NULL
[10:26:36.535]     }
[10:26:36.535]     ...future.result$conditions <- ...future.conditions
[10:26:36.535]     ...future.result$finished <- base::Sys.time()
[10:26:36.535]     ...future.result
[10:26:36.535] }
[10:26:36.536] assign_globals() ...
[10:26:36.537] List of 1
[10:26:36.537]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:36.537]   ..$ a: int [1:3] 1 2 3
[10:26:36.537]   ..$ b: int [1:3] 3 2 1
[10:26:36.537]  - attr(*, "where")=List of 1
[10:26:36.537]   ..$ data:<environment: R_EmptyEnv> 
[10:26:36.537]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.537]  - attr(*, "resolved")= logi FALSE
[10:26:36.537]  - attr(*, "total_size")= num 128
[10:26:36.537]  - attr(*, "already-done")= logi TRUE
[10:26:36.540] - copied ‘data’ to environment
[10:26:36.540] assign_globals() ... done
[10:26:36.540] plan(): Setting new future strategy stack:
[10:26:36.540] List of future strategies:
[10:26:36.540] 1. sequential:
[10:26:36.540]    - args: function (..., envir = parent.frame())
[10:26:36.540]    - tweaked: FALSE
[10:26:36.540]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.540] plan(): nbrOfWorkers() = 1
[10:26:36.568] plan(): Setting new future strategy stack:
[10:26:36.568] List of future strategies:
[10:26:36.568] 1. sequential:
[10:26:36.568]    - args: function (..., envir = parent.frame())
[10:26:36.568]    - tweaked: FALSE
[10:26:36.568]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.568] 2. sequential:
[10:26:36.568]    - args: function (..., envir = parent.frame())
[10:26:36.568]    - tweaked: FALSE
[10:26:36.568]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.569] plan(): nbrOfWorkers() = 1
[10:26:36.569] SequentialFuture started (and completed)
[10:26:36.569] signalConditions() ...
[10:26:36.569]  - include = ‘immediateCondition’
[10:26:36.569]  - exclude = 
[10:26:36.569]  - resignal = FALSE
[10:26:36.569]  - Number of conditions: 52
[10:26:36.570] signalConditions() ... done
[10:26:36.570] - Launch lazy future ... done
[10:26:36.570] run() for ‘SequentialFuture’ ... done
[10:26:36.570] signalConditions() ...
[10:26:36.570]  - include = ‘immediateCondition’
[10:26:36.570]  - exclude = 
[10:26:36.570]  - resignal = FALSE
[10:26:36.570]  - Number of conditions: 52
[10:26:36.570] signalConditions() ... done
[10:26:36.570] Future state: ‘finished’
[10:26:36.571] signalConditions() ...
[10:26:36.571]  - include = ‘condition’
[10:26:36.571]  - exclude = ‘immediateCondition’
[10:26:36.571]  - resignal = TRUE
[10:26:36.571]  - Number of conditions: 52
[10:26:36.571]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.541] getGlobalsAndPackages() ...
[10:26:36.571]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.541] Searching for globals...
[10:26:36.571]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.555] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:36.571]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.555] Searching for globals ... DONE
[10:26:36.572]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.555] Resolving globals: FALSE
[10:26:36.572]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.556] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:36.572]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.556] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:36.572]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.556] - globals: [1] ‘data’
[10:26:36.572]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.556] 
[10:26:36.574]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.556] getGlobalsAndPackages() ... DONE
[10:26:36.574]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.557] run() for ‘Future’ ...
[10:26:36.574]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.557] - state: ‘created’
[10:26:36.574]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.557] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:36.574]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.557] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:36.574]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:36.575]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.557]   - Field: ‘label’
[10:26:36.575]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.557]   - Field: ‘local’
[10:26:36.575]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘owner’
[10:26:36.575]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘envir’
[10:26:36.575]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘packages’
[10:26:36.575]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘gc’
[10:26:36.575]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘conditions’
[10:26:36.575]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘expr’
[10:26:36.576]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘uuid’
[10:26:36.576]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘seed’
[10:26:36.576]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘version’
[10:26:36.576]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.558]   - Field: ‘result’
[10:26:36.576]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559]   - Field: ‘asynchronous’
[10:26:36.576]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559]   - Field: ‘calls’
[10:26:36.576]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559]   - Field: ‘globals’
[10:26:36.577]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559]   - Field: ‘stdout’
[10:26:36.577]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559]   - Field: ‘earlySignal’
[10:26:36.577]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559]   - Field: ‘lazy’
[10:26:36.577]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559]   - Field: ‘state’
[10:26:36.577]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:36.577]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.559] - Launch lazy future ...
[10:26:36.577]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.560] Packages needed by the future expression (n = 0): <none>
[10:26:36.577]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.560] Packages needed by future strategies (n = 0): <none>
[10:26:36.578]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.560] {
[10:26:36.560]     {
[10:26:36.560]         {
[10:26:36.560]             ...future.startTime <- base::Sys.time()
[10:26:36.560]             {
[10:26:36.560]                 {
[10:26:36.560]                   {
[10:26:36.560]                     base::local({
[10:26:36.560]                       has_future <- base::requireNamespace("future", 
[10:26:36.560]                         quietly = TRUE)
[10:26:36.560]                       if (has_future) {
[10:26:36.560]                         ns <- base::getNamespace("future")
[10:26:36.560]                         version <- ns[[".package"]][["version"]]
[10:26:36.560]                         if (is.null(version)) 
[10:26:36.560]                           version <- utils::packageVersion("future")
[10:26:36.560]                       }
[10:26:36.560]                       else {
[10:26:36.560]                         version <- NULL
[10:26:36.560]                       }
[10:26:36.560]                       if (!has_future || version < "1.8.0") {
[10:26:36.560]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.560]                           "", base::R.version$version.string), 
[10:26:36.560]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:36.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.560]                             "release", "version")], collapse = " "), 
[10:26:36.560]                           hostname = base::Sys.info()[["nodename"]])
[10:26:36.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.560]                           info)
[10:26:36.560]                         info <- base::paste(info, collapse = "; ")
[10:26:36.560]                         if (!has_future) {
[10:26:36.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.560]                             info)
[10:26:36.560]                         }
[10:26:36.560]                         else {
[10:26:36.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.560]                             info, version)
[10:26:36.560]                         }
[10:26:36.560]                         base::stop(msg)
[10:26:36.560]                       }
[10:26:36.560]                     })
[10:26:36.560]                   }
[10:26:36.560]                   options(future.plan = NULL)
[10:26:36.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:36.560]                 }
[10:26:36.560]                 ...future.workdir <- getwd()
[10:26:36.560]             }
[10:26:36.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.560]         }
[10:26:36.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.560]             base::names(...future.oldOptions))
[10:26:36.560]     }
[10:26:36.560]     if (FALSE) {
[10:26:36.560]     }
[10:26:36.560]     else {
[10:26:36.560]         if (TRUE) {
[10:26:36.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.560]                 open = "w")
[10:26:36.560]         }
[10:26:36.560]         else {
[10:26:36.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.560]         }
[10:26:36.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.560]             base::sink(type = "output", split = FALSE)
[10:26:36.560]             base::close(...future.stdout)
[10:26:36.560]         }, add = TRUE)
[10:26:36.560]     }
[10:26:36.560]     ...future.frame <- base::sys.nframe()
[10:26:36.560]     ...future.conditions <- base::list()
[10:26:36.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.560]     if (FALSE) {
[10:26:36.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.560]     }
[10:26:36.560]     ...future.result <- base::tryCatch({
[10:26:36.560]         base::withCallingHandlers({
[10:26:36.560]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:26:36.560]                 a == 2)))
[10:26:36.560]             future::FutureResult(value = ...future.value$value, 
[10:26:36.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.560]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.560]                     ...future.globalenv.names))
[10:26:36.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.560]         }, condition = base::local({
[10:26:36.560]             c <- base::c
[10:26:36.560]             inherits <- base::inherits
[10:26:36.560]             invokeRestart <- base::invokeRestart
[10:26:36.560]             length <- base::length
[10:26:36.560]             list <- base::list
[10:26:36.560]             seq.int <- base::seq.int
[10:26:36.560]             signalCondition <- base::signalCondition
[10:26:36.560]             sys.calls <- base::sys.calls
[10:26:36.560]             `[[` <- base::`[[`
[10:26:36.560]             `+` <- base::`+`
[10:26:36.560]             `<<-` <- base::`<<-`
[10:26:36.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.560]                   3L)]
[10:26:36.560]             }
[10:26:36.560]             function(cond) {
[10:26:36.560]                 is_error <- inherits(cond, "error")
[10:26:36.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.560]                   NULL)
[10:26:36.560]                 if (is_error) {
[10:26:36.560]                   sessionInformation <- function() {
[10:26:36.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.560]                       search = base::search(), system = base::Sys.info())
[10:26:36.560]                   }
[10:26:36.560]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.560]                     cond$call), session = sessionInformation(), 
[10:26:36.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.560]                   signalCondition(cond)
[10:26:36.560]                 }
[10:26:36.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.560]                 "immediateCondition"))) {
[10:26:36.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.560]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.560]                   if (TRUE && !signal) {
[10:26:36.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.560]                     {
[10:26:36.560]                       inherits <- base::inherits
[10:26:36.560]                       invokeRestart <- base::invokeRestart
[10:26:36.560]                       is.null <- base::is.null
[10:26:36.560]                       muffled <- FALSE
[10:26:36.560]                       if (inherits(cond, "message")) {
[10:26:36.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.560]                         if (muffled) 
[10:26:36.560]                           invokeRestart("muffleMessage")
[10:26:36.560]                       }
[10:26:36.560]                       else if (inherits(cond, "warning")) {
[10:26:36.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.560]                         if (muffled) 
[10:26:36.560]                           invokeRestart("muffleWarning")
[10:26:36.560]                       }
[10:26:36.560]                       else if (inherits(cond, "condition")) {
[10:26:36.560]                         if (!is.null(pattern)) {
[10:26:36.560]                           computeRestarts <- base::computeRestarts
[10:26:36.560]                           grepl <- base::grepl
[10:26:36.560]                           restarts <- computeRestarts(cond)
[10:26:36.560]                           for (restart in restarts) {
[10:26:36.560]                             name <- restart$name
[10:26:36.560]                             if (is.null(name)) 
[10:26:36.560]                               next
[10:26:36.560]                             if (!grepl(pattern, name)) 
[10:26:36.560]                               next
[10:26:36.560]                             invokeRestart(restart)
[10:26:36.560]                             muffled <- TRUE
[10:26:36.560]                             break
[10:26:36.560]                           }
[10:26:36.560]                         }
[10:26:36.560]                       }
[10:26:36.560]                       invisible(muffled)
[10:26:36.560]                     }
[10:26:36.560]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.560]                   }
[10:26:36.560]                 }
[10:26:36.560]                 else {
[10:26:36.560]                   if (TRUE) {
[10:26:36.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.560]                     {
[10:26:36.560]                       inherits <- base::inherits
[10:26:36.560]                       invokeRestart <- base::invokeRestart
[10:26:36.560]                       is.null <- base::is.null
[10:26:36.560]                       muffled <- FALSE
[10:26:36.560]                       if (inherits(cond, "message")) {
[10:26:36.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.560]                         if (muffled) 
[10:26:36.560]                           invokeRestart("muffleMessage")
[10:26:36.560]                       }
[10:26:36.560]                       else if (inherits(cond, "warning")) {
[10:26:36.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.560]                         if (muffled) 
[10:26:36.560]                           invokeRestart("muffleWarning")
[10:26:36.560]                       }
[10:26:36.560]                       else if (inherits(cond, "condition")) {
[10:26:36.560]                         if (!is.null(pattern)) {
[10:26:36.560]                           computeRestarts <- base::computeRestarts
[10:26:36.560]                           grepl <- base::grepl
[10:26:36.560]                           restarts <- computeRestarts(cond)
[10:26:36.560]                           for (restart in restarts) {
[10:26:36.560]                             name <- restart$name
[10:26:36.560]                             if (is.null(name)) 
[10:26:36.560]                               next
[10:26:36.560]                             if (!grepl(pattern, name)) 
[10:26:36.560]                               next
[10:26:36.560]                             invokeRestart(restart)
[10:26:36.560]                             muffled <- TRUE
[10:26:36.560]                             break
[10:26:36.560]                           }
[10:26:36.560]                         }
[10:26:36.560]                       }
[10:26:36.560]                       invisible(muffled)
[10:26:36.560]                     }
[10:26:36.560]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.560]                   }
[10:26:36.560]                 }
[10:26:36.560]             }
[10:26:36.560]         }))
[10:26:36.560]     }, error = function(ex) {
[10:26:36.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.560]                 ...future.rng), started = ...future.startTime, 
[10:26:36.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.560]             version = "1.8"), class = "FutureResult")
[10:26:36.560]     }, finally = {
[10:26:36.560]         if (!identical(...future.workdir, getwd())) 
[10:26:36.560]             setwd(...future.workdir)
[10:26:36.560]         {
[10:26:36.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.560]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.560]             }
[10:26:36.560]             base::options(...future.oldOptions)
[10:26:36.560]             if (.Platform$OS.type == "windows") {
[10:26:36.560]                 old_names <- names(...future.oldEnvVars)
[10:26:36.560]                 envs <- base::Sys.getenv()
[10:26:36.560]                 names <- names(envs)
[10:26:36.560]                 common <- intersect(names, old_names)
[10:26:36.560]                 added <- setdiff(names, old_names)
[10:26:36.560]                 removed <- setdiff(old_names, names)
[10:26:36.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.560]                   envs[common]]
[10:26:36.560]                 NAMES <- toupper(changed)
[10:26:36.560]                 args <- list()
[10:26:36.560]                 for (kk in seq_along(NAMES)) {
[10:26:36.560]                   name <- changed[[kk]]
[10:26:36.560]                   NAME <- NAMES[[kk]]
[10:26:36.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.560]                     next
[10:26:36.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.560]                 }
[10:26:36.560]                 NAMES <- toupper(added)
[10:26:36.560]                 for (kk in seq_along(NAMES)) {
[10:26:36.560]                   name <- added[[kk]]
[10:26:36.560]                   NAME <- NAMES[[kk]]
[10:26:36.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.560]                     next
[10:26:36.560]                   args[[name]] <- ""
[10:26:36.560]                 }
[10:26:36.560]                 NAMES <- toupper(removed)
[10:26:36.560]                 for (kk in seq_along(NAMES)) {
[10:26:36.560]                   name <- removed[[kk]]
[10:26:36.560]                   NAME <- NAMES[[kk]]
[10:26:36.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.560]                     next
[10:26:36.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.560]                 }
[10:26:36.560]                 if (length(args) > 0) 
[10:26:36.560]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.560]             }
[10:26:36.560]             else {
[10:26:36.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.560]             }
[10:26:36.560]             {
[10:26:36.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.560]                   0L) {
[10:26:36.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.560]                   base::options(opts)
[10:26:36.560]                 }
[10:26:36.560]                 {
[10:26:36.560]                   {
[10:26:36.560]                     NULL
[10:26:36.560]                     RNGkind("Mersenne-Twister")
[10:26:36.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:36.560]                       inherits = FALSE)
[10:26:36.560]                   }
[10:26:36.560]                   options(future.plan = NULL)
[10:26:36.560]                   if (is.na(NA_character_)) 
[10:26:36.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.560]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:36.560]                   {
[10:26:36.560]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.560]                     if (!future$lazy) 
[10:26:36.560]                       future <- run(future)
[10:26:36.560]                     invisible(future)
[10:26:36.560]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.560]                 }
[10:26:36.560]             }
[10:26:36.560]         }
[10:26:36.560]     })
[10:26:36.560]     if (TRUE) {
[10:26:36.560]         base::sink(type = "output", split = FALSE)
[10:26:36.560]         if (TRUE) {
[10:26:36.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.560]         }
[10:26:36.560]         else {
[10:26:36.560]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.560]         }
[10:26:36.560]         base::close(...future.stdout)
[10:26:36.560]         ...future.stdout <- NULL
[10:26:36.560]     }
[10:26:36.560]     ...future.result$conditions <- ...future.conditions
[10:26:36.560]     ...future.result$finished <- base::Sys.time()
[10:26:36.560]     ...future.result
[10:26:36.560] }
[10:26:36.578]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.562] assign_globals() ...
[10:26:36.578]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.562] List of 1
[10:26:36.562]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:36.562]   ..$ a: int [1:3] 1 2 3
[10:26:36.562]   ..$ b: int [1:3] 3 2 1
[10:26:36.562]  - attr(*, "where")=List of 1
[10:26:36.562]   ..$ data:<environment: R_EmptyEnv> 
[10:26:36.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.562]  - attr(*, "resolved")= logi FALSE
[10:26:36.562]  - attr(*, "total_size")= num 128
[10:26:36.562]  - attr(*, "already-done")= logi TRUE
[10:26:36.578]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.565] - copied ‘data’ to environment
[10:26:36.578]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.565] assign_globals() ... done
[10:26:36.578]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.566] plan(): Setting new future strategy stack:
[10:26:36.578]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.566] List of future strategies:
[10:26:36.566] 1. sequential:
[10:26:36.566]    - args: function (..., envir = parent.frame())
[10:26:36.566]    - tweaked: FALSE
[10:26:36.566]    - call: NULL
[10:26:36.579]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.566] plan(): nbrOfWorkers() = 1
[10:26:36.579]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.567] plan(): Setting new future strategy stack:
[10:26:36.579]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.567] List of future strategies:
[10:26:36.567] 1. sequential:
[10:26:36.567]    - args: function (..., envir = parent.frame())
[10:26:36.567]    - tweaked: FALSE
[10:26:36.567]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.579]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.567] plan(): nbrOfWorkers() = 1
[10:26:36.579]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.567] SequentialFuture started (and completed)
[10:26:36.579]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.568] - Launch lazy future ... done
[10:26:36.579]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.568] run() for ‘SequentialFuture’ ... done
[10:26:36.580] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[10:26:36.580] plan(): Setting new future strategy stack:
[10:26:36.580] List of future strategies:
[10:26:36.580] 1. sequential:
[10:26:36.580]    - args: function (..., envir = parent.frame())
[10:26:36.580]    - tweaked: FALSE
[10:26:36.580]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.580] 2. multicore:
[10:26:36.580]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:36.580]    - tweaked: FALSE
[10:26:36.580]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.581] plan(): nbrOfWorkers() = 1
[10:26:36.581] getGlobalsAndPackages() ...
[10:26:36.581] Searching for globals...
[10:26:36.598] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:36.599] Searching for globals ... DONE
[10:26:36.599] Resolving globals: FALSE
[10:26:36.600] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[10:26:36.600] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:36.600] - globals: [2] ‘nested’, ‘strategy2’
[10:26:36.600] - packages: [1] ‘future’
[10:26:36.601] getGlobalsAndPackages() ... DONE
[10:26:36.601] run() for ‘Future’ ...
[10:26:36.601] - state: ‘created’
[10:26:36.601] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:36.601] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:36.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:36.602]   - Field: ‘label’
[10:26:36.602]   - Field: ‘local’
[10:26:36.602]   - Field: ‘owner’
[10:26:36.602]   - Field: ‘envir’
[10:26:36.602]   - Field: ‘packages’
[10:26:36.602]   - Field: ‘gc’
[10:26:36.602]   - Field: ‘conditions’
[10:26:36.602]   - Field: ‘expr’
[10:26:36.602]   - Field: ‘uuid’
[10:26:36.602]   - Field: ‘seed’
[10:26:36.603]   - Field: ‘version’
[10:26:36.603]   - Field: ‘result’
[10:26:36.603]   - Field: ‘asynchronous’
[10:26:36.603]   - Field: ‘calls’
[10:26:36.603]   - Field: ‘globals’
[10:26:36.603]   - Field: ‘stdout’
[10:26:36.603]   - Field: ‘earlySignal’
[10:26:36.603]   - Field: ‘lazy’
[10:26:36.603]   - Field: ‘state’
[10:26:36.603] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:36.603] - Launch lazy future ...
[10:26:36.604] Packages needed by the future expression (n = 1): ‘future’
[10:26:36.604] Packages needed by future strategies (n = 1): ‘future’
[10:26:36.604] {
[10:26:36.604]     {
[10:26:36.604]         {
[10:26:36.604]             ...future.startTime <- base::Sys.time()
[10:26:36.604]             {
[10:26:36.604]                 {
[10:26:36.604]                   {
[10:26:36.604]                     {
[10:26:36.604]                       base::local({
[10:26:36.604]                         has_future <- base::requireNamespace("future", 
[10:26:36.604]                           quietly = TRUE)
[10:26:36.604]                         if (has_future) {
[10:26:36.604]                           ns <- base::getNamespace("future")
[10:26:36.604]                           version <- ns[[".package"]][["version"]]
[10:26:36.604]                           if (is.null(version)) 
[10:26:36.604]                             version <- utils::packageVersion("future")
[10:26:36.604]                         }
[10:26:36.604]                         else {
[10:26:36.604]                           version <- NULL
[10:26:36.604]                         }
[10:26:36.604]                         if (!has_future || version < "1.8.0") {
[10:26:36.604]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.604]                             "", base::R.version$version.string), 
[10:26:36.604]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:36.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.604]                               "release", "version")], collapse = " "), 
[10:26:36.604]                             hostname = base::Sys.info()[["nodename"]])
[10:26:36.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.604]                             info)
[10:26:36.604]                           info <- base::paste(info, collapse = "; ")
[10:26:36.604]                           if (!has_future) {
[10:26:36.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.604]                               info)
[10:26:36.604]                           }
[10:26:36.604]                           else {
[10:26:36.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.604]                               info, version)
[10:26:36.604]                           }
[10:26:36.604]                           base::stop(msg)
[10:26:36.604]                         }
[10:26:36.604]                       })
[10:26:36.604]                     }
[10:26:36.604]                     base::local({
[10:26:36.604]                       for (pkg in "future") {
[10:26:36.604]                         base::loadNamespace(pkg)
[10:26:36.604]                         base::library(pkg, character.only = TRUE)
[10:26:36.604]                       }
[10:26:36.604]                     })
[10:26:36.604]                   }
[10:26:36.604]                   options(future.plan = NULL)
[10:26:36.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.604]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:36.604]                     envir = parent.frame()) 
[10:26:36.604]                   {
[10:26:36.604]                     default_workers <- missing(workers)
[10:26:36.604]                     if (is.function(workers)) 
[10:26:36.604]                       workers <- workers()
[10:26:36.604]                     workers <- structure(as.integer(workers), 
[10:26:36.604]                       class = class(workers))
[10:26:36.604]                     stop_if_not(is.finite(workers), workers >= 
[10:26:36.604]                       1L)
[10:26:36.604]                     if ((workers == 1L && !inherits(workers, 
[10:26:36.604]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:36.604]                       if (default_workers) 
[10:26:36.604]                         supportsMulticore(warn = TRUE)
[10:26:36.604]                       return(sequential(..., envir = envir))
[10:26:36.604]                     }
[10:26:36.604]                     oopts <- options(mc.cores = workers)
[10:26:36.604]                     on.exit(options(oopts))
[10:26:36.604]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:36.604]                       envir = envir)
[10:26:36.604]                     if (!future$lazy) 
[10:26:36.604]                       future <- run(future)
[10:26:36.604]                     invisible(future)
[10:26:36.604]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.604]                 }
[10:26:36.604]                 ...future.workdir <- getwd()
[10:26:36.604]             }
[10:26:36.604]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.604]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.604]         }
[10:26:36.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.604]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.604]             base::names(...future.oldOptions))
[10:26:36.604]     }
[10:26:36.604]     if (FALSE) {
[10:26:36.604]     }
[10:26:36.604]     else {
[10:26:36.604]         if (TRUE) {
[10:26:36.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.604]                 open = "w")
[10:26:36.604]         }
[10:26:36.604]         else {
[10:26:36.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.604]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.604]         }
[10:26:36.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.604]             base::sink(type = "output", split = FALSE)
[10:26:36.604]             base::close(...future.stdout)
[10:26:36.604]         }, add = TRUE)
[10:26:36.604]     }
[10:26:36.604]     ...future.frame <- base::sys.nframe()
[10:26:36.604]     ...future.conditions <- base::list()
[10:26:36.604]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.604]     if (FALSE) {
[10:26:36.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.604]     }
[10:26:36.604]     ...future.result <- base::tryCatch({
[10:26:36.604]         base::withCallingHandlers({
[10:26:36.604]             ...future.value <- base::withVisible(base::local({
[10:26:36.604]                 a <- 1L
[10:26:36.604]                 plan_a <- unclass(future::plan("list"))
[10:26:36.604]                 nested_a <- nested[-1]
[10:26:36.604]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:36.604]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.604]                   strategy2))
[10:26:36.604]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:36.604]                   "init") <- NULL
[10:26:36.604]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:36.604]                   "init") <- NULL
[10:26:36.604]                 stopifnot(all.equal(plan_a, nested_a))
[10:26:36.604]                 y %<-% {
[10:26:36.604]                   b <- 2L
[10:26:36.604]                   plan_b <- future::plan("list")
[10:26:36.604]                   nested_b <- nested_a[-1]
[10:26:36.604]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:36.604]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.604]                     "sequential"))
[10:26:36.604]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:36.604]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:36.604]                 }
[10:26:36.604]                 y
[10:26:36.604]             }))
[10:26:36.604]             future::FutureResult(value = ...future.value$value, 
[10:26:36.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.604]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.604]                     ...future.globalenv.names))
[10:26:36.604]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.604]         }, condition = base::local({
[10:26:36.604]             c <- base::c
[10:26:36.604]             inherits <- base::inherits
[10:26:36.604]             invokeRestart <- base::invokeRestart
[10:26:36.604]             length <- base::length
[10:26:36.604]             list <- base::list
[10:26:36.604]             seq.int <- base::seq.int
[10:26:36.604]             signalCondition <- base::signalCondition
[10:26:36.604]             sys.calls <- base::sys.calls
[10:26:36.604]             `[[` <- base::`[[`
[10:26:36.604]             `+` <- base::`+`
[10:26:36.604]             `<<-` <- base::`<<-`
[10:26:36.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.604]                   3L)]
[10:26:36.604]             }
[10:26:36.604]             function(cond) {
[10:26:36.604]                 is_error <- inherits(cond, "error")
[10:26:36.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.604]                   NULL)
[10:26:36.604]                 if (is_error) {
[10:26:36.604]                   sessionInformation <- function() {
[10:26:36.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.604]                       search = base::search(), system = base::Sys.info())
[10:26:36.604]                   }
[10:26:36.604]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.604]                     cond$call), session = sessionInformation(), 
[10:26:36.604]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.604]                   signalCondition(cond)
[10:26:36.604]                 }
[10:26:36.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.604]                 "immediateCondition"))) {
[10:26:36.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.604]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.604]                   if (TRUE && !signal) {
[10:26:36.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.604]                     {
[10:26:36.604]                       inherits <- base::inherits
[10:26:36.604]                       invokeRestart <- base::invokeRestart
[10:26:36.604]                       is.null <- base::is.null
[10:26:36.604]                       muffled <- FALSE
[10:26:36.604]                       if (inherits(cond, "message")) {
[10:26:36.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.604]                         if (muffled) 
[10:26:36.604]                           invokeRestart("muffleMessage")
[10:26:36.604]                       }
[10:26:36.604]                       else if (inherits(cond, "warning")) {
[10:26:36.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.604]                         if (muffled) 
[10:26:36.604]                           invokeRestart("muffleWarning")
[10:26:36.604]                       }
[10:26:36.604]                       else if (inherits(cond, "condition")) {
[10:26:36.604]                         if (!is.null(pattern)) {
[10:26:36.604]                           computeRestarts <- base::computeRestarts
[10:26:36.604]                           grepl <- base::grepl
[10:26:36.604]                           restarts <- computeRestarts(cond)
[10:26:36.604]                           for (restart in restarts) {
[10:26:36.604]                             name <- restart$name
[10:26:36.604]                             if (is.null(name)) 
[10:26:36.604]                               next
[10:26:36.604]                             if (!grepl(pattern, name)) 
[10:26:36.604]                               next
[10:26:36.604]                             invokeRestart(restart)
[10:26:36.604]                             muffled <- TRUE
[10:26:36.604]                             break
[10:26:36.604]                           }
[10:26:36.604]                         }
[10:26:36.604]                       }
[10:26:36.604]                       invisible(muffled)
[10:26:36.604]                     }
[10:26:36.604]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.604]                   }
[10:26:36.604]                 }
[10:26:36.604]                 else {
[10:26:36.604]                   if (TRUE) {
[10:26:36.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.604]                     {
[10:26:36.604]                       inherits <- base::inherits
[10:26:36.604]                       invokeRestart <- base::invokeRestart
[10:26:36.604]                       is.null <- base::is.null
[10:26:36.604]                       muffled <- FALSE
[10:26:36.604]                       if (inherits(cond, "message")) {
[10:26:36.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.604]                         if (muffled) 
[10:26:36.604]                           invokeRestart("muffleMessage")
[10:26:36.604]                       }
[10:26:36.604]                       else if (inherits(cond, "warning")) {
[10:26:36.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.604]                         if (muffled) 
[10:26:36.604]                           invokeRestart("muffleWarning")
[10:26:36.604]                       }
[10:26:36.604]                       else if (inherits(cond, "condition")) {
[10:26:36.604]                         if (!is.null(pattern)) {
[10:26:36.604]                           computeRestarts <- base::computeRestarts
[10:26:36.604]                           grepl <- base::grepl
[10:26:36.604]                           restarts <- computeRestarts(cond)
[10:26:36.604]                           for (restart in restarts) {
[10:26:36.604]                             name <- restart$name
[10:26:36.604]                             if (is.null(name)) 
[10:26:36.604]                               next
[10:26:36.604]                             if (!grepl(pattern, name)) 
[10:26:36.604]                               next
[10:26:36.604]                             invokeRestart(restart)
[10:26:36.604]                             muffled <- TRUE
[10:26:36.604]                             break
[10:26:36.604]                           }
[10:26:36.604]                         }
[10:26:36.604]                       }
[10:26:36.604]                       invisible(muffled)
[10:26:36.604]                     }
[10:26:36.604]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.604]                   }
[10:26:36.604]                 }
[10:26:36.604]             }
[10:26:36.604]         }))
[10:26:36.604]     }, error = function(ex) {
[10:26:36.604]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.604]                 ...future.rng), started = ...future.startTime, 
[10:26:36.604]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.604]             version = "1.8"), class = "FutureResult")
[10:26:36.604]     }, finally = {
[10:26:36.604]         if (!identical(...future.workdir, getwd())) 
[10:26:36.604]             setwd(...future.workdir)
[10:26:36.604]         {
[10:26:36.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.604]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.604]             }
[10:26:36.604]             base::options(...future.oldOptions)
[10:26:36.604]             if (.Platform$OS.type == "windows") {
[10:26:36.604]                 old_names <- names(...future.oldEnvVars)
[10:26:36.604]                 envs <- base::Sys.getenv()
[10:26:36.604]                 names <- names(envs)
[10:26:36.604]                 common <- intersect(names, old_names)
[10:26:36.604]                 added <- setdiff(names, old_names)
[10:26:36.604]                 removed <- setdiff(old_names, names)
[10:26:36.604]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.604]                   envs[common]]
[10:26:36.604]                 NAMES <- toupper(changed)
[10:26:36.604]                 args <- list()
[10:26:36.604]                 for (kk in seq_along(NAMES)) {
[10:26:36.604]                   name <- changed[[kk]]
[10:26:36.604]                   NAME <- NAMES[[kk]]
[10:26:36.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.604]                     next
[10:26:36.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.604]                 }
[10:26:36.604]                 NAMES <- toupper(added)
[10:26:36.604]                 for (kk in seq_along(NAMES)) {
[10:26:36.604]                   name <- added[[kk]]
[10:26:36.604]                   NAME <- NAMES[[kk]]
[10:26:36.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.604]                     next
[10:26:36.604]                   args[[name]] <- ""
[10:26:36.604]                 }
[10:26:36.604]                 NAMES <- toupper(removed)
[10:26:36.604]                 for (kk in seq_along(NAMES)) {
[10:26:36.604]                   name <- removed[[kk]]
[10:26:36.604]                   NAME <- NAMES[[kk]]
[10:26:36.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.604]                     next
[10:26:36.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.604]                 }
[10:26:36.604]                 if (length(args) > 0) 
[10:26:36.604]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.604]             }
[10:26:36.604]             else {
[10:26:36.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.604]             }
[10:26:36.604]             {
[10:26:36.604]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.604]                   0L) {
[10:26:36.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.604]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.604]                   base::options(opts)
[10:26:36.604]                 }
[10:26:36.604]                 {
[10:26:36.604]                   {
[10:26:36.604]                     NULL
[10:26:36.604]                     RNGkind("Mersenne-Twister")
[10:26:36.604]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:36.604]                       inherits = FALSE)
[10:26:36.604]                   }
[10:26:36.604]                   options(future.plan = NULL)
[10:26:36.604]                   if (is.na(NA_character_)) 
[10:26:36.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.604]                   future::plan(list(a = function (..., envir = parent.frame()) 
[10:26:36.604]                   {
[10:26:36.604]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.604]                     if (!future$lazy) 
[10:26:36.604]                       future <- run(future)
[10:26:36.604]                     invisible(future)
[10:26:36.604]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:36.604]                     envir = parent.frame()) 
[10:26:36.604]                   {
[10:26:36.604]                     default_workers <- missing(workers)
[10:26:36.604]                     if (is.function(workers)) 
[10:26:36.604]                       workers <- workers()
[10:26:36.604]                     workers <- structure(as.integer(workers), 
[10:26:36.604]                       class = class(workers))
[10:26:36.604]                     stop_if_not(is.finite(workers), workers >= 
[10:26:36.604]                       1L)
[10:26:36.604]                     if ((workers == 1L && !inherits(workers, 
[10:26:36.604]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:36.604]                       if (default_workers) 
[10:26:36.604]                         supportsMulticore(warn = TRUE)
[10:26:36.604]                       return(sequential(..., envir = envir))
[10:26:36.604]                     }
[10:26:36.604]                     oopts <- options(mc.cores = workers)
[10:26:36.604]                     on.exit(options(oopts))
[10:26:36.604]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:36.604]                       envir = envir)
[10:26:36.604]                     if (!future$lazy) 
[10:26:36.604]                       future <- run(future)
[10:26:36.604]                     invisible(future)
[10:26:36.604]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.604]                 }
[10:26:36.604]             }
[10:26:36.604]         }
[10:26:36.604]     })
[10:26:36.604]     if (TRUE) {
[10:26:36.604]         base::sink(type = "output", split = FALSE)
[10:26:36.604]         if (TRUE) {
[10:26:36.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.604]         }
[10:26:36.604]         else {
[10:26:36.604]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.604]         }
[10:26:36.604]         base::close(...future.stdout)
[10:26:36.604]         ...future.stdout <- NULL
[10:26:36.604]     }
[10:26:36.604]     ...future.result$conditions <- ...future.conditions
[10:26:36.604]     ...future.result$finished <- base::Sys.time()
[10:26:36.604]     ...future.result
[10:26:36.604] }
[10:26:36.606] assign_globals() ...
[10:26:36.606] List of 2
[10:26:36.606]  $ nested   :List of 2
[10:26:36.606]   ..$ a:function (..., envir = parent.frame())  
[10:26:36.606]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:36.606]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.606]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:36.606]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:36.606]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.606]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:36.606]  $ strategy2: chr "multicore"
[10:26:36.606]  - attr(*, "where")=List of 2
[10:26:36.606]   ..$ nested   :<environment: R_EmptyEnv> 
[10:26:36.606]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:26:36.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.606]  - attr(*, "resolved")= logi FALSE
[10:26:36.606]  - attr(*, "total_size")= num 59224
[10:26:36.606]  - attr(*, "already-done")= logi TRUE
[10:26:36.611] - copied ‘nested’ to environment
[10:26:36.611] - copied ‘strategy2’ to environment
[10:26:36.611] assign_globals() ... done
[10:26:36.612] plan(): Setting new future strategy stack:
[10:26:36.612] List of future strategies:
[10:26:36.612] 1. multicore:
[10:26:36.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:36.612]    - tweaked: FALSE
[10:26:36.612]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.617] plan(): nbrOfWorkers() = 2
[10:26:36.674] plan(): Setting new future strategy stack:
[10:26:36.674] List of future strategies:
[10:26:36.674] 1. sequential:
[10:26:36.674]    - args: function (..., envir = parent.frame())
[10:26:36.674]    - tweaked: FALSE
[10:26:36.674]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.674] 2. multicore:
[10:26:36.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:36.674]    - tweaked: FALSE
[10:26:36.674]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.674] plan(): nbrOfWorkers() = 1
[10:26:36.675] SequentialFuture started (and completed)
[10:26:36.675] signalConditions() ...
[10:26:36.675]  - include = ‘immediateCondition’
[10:26:36.675]  - exclude = 
[10:26:36.675]  - resignal = FALSE
[10:26:36.675]  - Number of conditions: 57
[10:26:36.676] signalConditions() ... done
[10:26:36.676] - Launch lazy future ... done
[10:26:36.676] run() for ‘SequentialFuture’ ... done
[10:26:36.676] signalConditions() ...
[10:26:36.676]  - include = ‘immediateCondition’
[10:26:36.676]  - exclude = 
[10:26:36.676]  - resignal = FALSE
[10:26:36.677]  - Number of conditions: 57
[10:26:36.677] signalConditions() ... done
[10:26:36.677] Future state: ‘finished’
[10:26:36.677] signalConditions() ...
[10:26:36.677]  - include = ‘condition’
[10:26:36.677]  - exclude = ‘immediateCondition’
[10:26:36.677]  - resignal = TRUE
[10:26:36.678]  - Number of conditions: 57
[10:26:36.678]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.618] getGlobalsAndPackages() ...
[10:26:36.678]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.618] Searching for globals...
[10:26:36.678]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.635] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:26:36.678]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.636] Searching for globals ... DONE
[10:26:36.678]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.636] Resolving globals: FALSE
[10:26:36.678]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.636] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[10:26:36.679]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.637] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:26:36.679]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.637] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:26:36.679]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.637] 
[10:26:36.679]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.637] getGlobalsAndPackages() ... DONE
[10:26:36.679]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.637] run() for ‘Future’ ...
[10:26:36.679]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.638] - state: ‘created’
[10:26:36.680]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:36.680]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.641] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:36.680]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.641] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:36.680]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.641]   - Field: ‘label’
[10:26:36.680]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘local’
[10:26:36.680]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘owner’
[10:26:36.680]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘envir’
[10:26:36.681]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘workers’
[10:26:36.681]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘packages’
[10:26:36.681]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘gc’
[10:26:36.681]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘job’
[10:26:36.681]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘conditions’
[10:26:36.681]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.642]   - Field: ‘expr’
[10:26:36.682]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘uuid’
[10:26:36.682]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘seed’
[10:26:36.682]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘version’
[10:26:36.682]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘result’
[10:26:36.682]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘asynchronous’
[10:26:36.682]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘calls’
[10:26:36.683]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘globals’
[10:26:36.683]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘stdout’
[10:26:36.683]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘earlySignal’
[10:26:36.683]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘lazy’
[10:26:36.683]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.643]   - Field: ‘state’
[10:26:36.683]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:36.683]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.644] - Launch lazy future ...
[10:26:36.684]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.645] Packages needed by the future expression (n = 0): <none>
[10:26:36.684]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.645] Packages needed by future strategies (n = 0): <none>
[10:26:36.684]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.645] {
[10:26:36.645]     {
[10:26:36.645]         {
[10:26:36.645]             ...future.startTime <- base::Sys.time()
[10:26:36.645]             {
[10:26:36.645]                 {
[10:26:36.645]                   {
[10:26:36.645]                     {
[10:26:36.645]                       base::local({
[10:26:36.645]                         has_future <- base::requireNamespace("future", 
[10:26:36.645]                           quietly = TRUE)
[10:26:36.645]                         if (has_future) {
[10:26:36.645]                           ns <- base::getNamespace("future")
[10:26:36.645]                           version <- ns[[".package"]][["version"]]
[10:26:36.645]                           if (is.null(version)) 
[10:26:36.645]                             version <- utils::packageVersion("future")
[10:26:36.645]                         }
[10:26:36.645]                         else {
[10:26:36.645]                           version <- NULL
[10:26:36.645]                         }
[10:26:36.645]                         if (!has_future || version < "1.8.0") {
[10:26:36.645]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.645]                             "", base::R.version$version.string), 
[10:26:36.645]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:36.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.645]                               "release", "version")], collapse = " "), 
[10:26:36.645]                             hostname = base::Sys.info()[["nodename"]])
[10:26:36.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.645]                             info)
[10:26:36.645]                           info <- base::paste(info, collapse = "; ")
[10:26:36.645]                           if (!has_future) {
[10:26:36.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.645]                               info)
[10:26:36.645]                           }
[10:26:36.645]                           else {
[10:26:36.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.645]                               info, version)
[10:26:36.645]                           }
[10:26:36.645]                           base::stop(msg)
[10:26:36.645]                         }
[10:26:36.645]                       })
[10:26:36.645]                     }
[10:26:36.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:36.645]                     base::options(mc.cores = 1L)
[10:26:36.645]                   }
[10:26:36.645]                   options(future.plan = NULL)
[10:26:36.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:36.645]                 }
[10:26:36.645]                 ...future.workdir <- getwd()
[10:26:36.645]             }
[10:26:36.645]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.645]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.645]         }
[10:26:36.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.645]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.645]             base::names(...future.oldOptions))
[10:26:36.645]     }
[10:26:36.645]     if (FALSE) {
[10:26:36.645]     }
[10:26:36.645]     else {
[10:26:36.645]         if (TRUE) {
[10:26:36.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.645]                 open = "w")
[10:26:36.645]         }
[10:26:36.645]         else {
[10:26:36.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.645]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.645]         }
[10:26:36.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.645]             base::sink(type = "output", split = FALSE)
[10:26:36.645]             base::close(...future.stdout)
[10:26:36.645]         }, add = TRUE)
[10:26:36.645]     }
[10:26:36.645]     ...future.frame <- base::sys.nframe()
[10:26:36.645]     ...future.conditions <- base::list()
[10:26:36.645]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.645]     if (FALSE) {
[10:26:36.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.645]     }
[10:26:36.645]     ...future.result <- base::tryCatch({
[10:26:36.645]         base::withCallingHandlers({
[10:26:36.645]             ...future.value <- base::withVisible(base::local({
[10:26:36.645]                 withCallingHandlers({
[10:26:36.645]                   {
[10:26:36.645]                     b <- 2L
[10:26:36.645]                     plan_b <- future::plan("list")
[10:26:36.645]                     nested_b <- nested_a[-1]
[10:26:36.645]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:36.645]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.645]                       "sequential"))
[10:26:36.645]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:36.645]                       b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:36.645]                   }
[10:26:36.645]                 }, immediateCondition = function(cond) {
[10:26:36.645]                   save_rds <- function (object, pathname, ...) 
[10:26:36.645]                   {
[10:26:36.645]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:36.645]                     if (file_test("-f", pathname_tmp)) {
[10:26:36.645]                       fi_tmp <- file.info(pathname_tmp)
[10:26:36.645]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:36.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:36.645]                         fi_tmp[["mtime"]])
[10:26:36.645]                     }
[10:26:36.645]                     tryCatch({
[10:26:36.645]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:36.645]                     }, error = function(ex) {
[10:26:36.645]                       msg <- conditionMessage(ex)
[10:26:36.645]                       fi_tmp <- file.info(pathname_tmp)
[10:26:36.645]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:36.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:36.645]                         fi_tmp[["mtime"]], msg)
[10:26:36.645]                       ex$message <- msg
[10:26:36.645]                       stop(ex)
[10:26:36.645]                     })
[10:26:36.645]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:36.645]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:36.645]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:36.645]                       fi_tmp <- file.info(pathname_tmp)
[10:26:36.645]                       fi <- file.info(pathname)
[10:26:36.645]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:36.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:36.645]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:36.645]                         fi[["size"]], fi[["mtime"]])
[10:26:36.645]                       stop(msg)
[10:26:36.645]                     }
[10:26:36.645]                     invisible(pathname)
[10:26:36.645]                   }
[10:26:36.645]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:36.645]                     rootPath = tempdir()) 
[10:26:36.645]                   {
[10:26:36.645]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:36.645]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:36.645]                       tmpdir = path, fileext = ".rds")
[10:26:36.645]                     save_rds(obj, file)
[10:26:36.645]                   }
[10:26:36.645]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:36.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.645]                   {
[10:26:36.645]                     inherits <- base::inherits
[10:26:36.645]                     invokeRestart <- base::invokeRestart
[10:26:36.645]                     is.null <- base::is.null
[10:26:36.645]                     muffled <- FALSE
[10:26:36.645]                     if (inherits(cond, "message")) {
[10:26:36.645]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:36.645]                       if (muffled) 
[10:26:36.645]                         invokeRestart("muffleMessage")
[10:26:36.645]                     }
[10:26:36.645]                     else if (inherits(cond, "warning")) {
[10:26:36.645]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:36.645]                       if (muffled) 
[10:26:36.645]                         invokeRestart("muffleWarning")
[10:26:36.645]                     }
[10:26:36.645]                     else if (inherits(cond, "condition")) {
[10:26:36.645]                       if (!is.null(pattern)) {
[10:26:36.645]                         computeRestarts <- base::computeRestarts
[10:26:36.645]                         grepl <- base::grepl
[10:26:36.645]                         restarts <- computeRestarts(cond)
[10:26:36.645]                         for (restart in restarts) {
[10:26:36.645]                           name <- restart$name
[10:26:36.645]                           if (is.null(name)) 
[10:26:36.645]                             next
[10:26:36.645]                           if (!grepl(pattern, name)) 
[10:26:36.645]                             next
[10:26:36.645]                           invokeRestart(restart)
[10:26:36.645]                           muffled <- TRUE
[10:26:36.645]                           break
[10:26:36.645]                         }
[10:26:36.645]                       }
[10:26:36.645]                     }
[10:26:36.645]                     invisible(muffled)
[10:26:36.645]                   }
[10:26:36.645]                   muffleCondition(cond)
[10:26:36.645]                 })
[10:26:36.645]             }))
[10:26:36.645]             future::FutureResult(value = ...future.value$value, 
[10:26:36.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.645]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.645]                     ...future.globalenv.names))
[10:26:36.645]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.645]         }, condition = base::local({
[10:26:36.645]             c <- base::c
[10:26:36.645]             inherits <- base::inherits
[10:26:36.645]             invokeRestart <- base::invokeRestart
[10:26:36.645]             length <- base::length
[10:26:36.645]             list <- base::list
[10:26:36.645]             seq.int <- base::seq.int
[10:26:36.645]             signalCondition <- base::signalCondition
[10:26:36.645]             sys.calls <- base::sys.calls
[10:26:36.645]             `[[` <- base::`[[`
[10:26:36.645]             `+` <- base::`+`
[10:26:36.645]             `<<-` <- base::`<<-`
[10:26:36.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.645]                   3L)]
[10:26:36.645]             }
[10:26:36.645]             function(cond) {
[10:26:36.645]                 is_error <- inherits(cond, "error")
[10:26:36.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.645]                   NULL)
[10:26:36.645]                 if (is_error) {
[10:26:36.645]                   sessionInformation <- function() {
[10:26:36.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.645]                       search = base::search(), system = base::Sys.info())
[10:26:36.645]                   }
[10:26:36.645]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.645]                     cond$call), session = sessionInformation(), 
[10:26:36.645]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.645]                   signalCondition(cond)
[10:26:36.645]                 }
[10:26:36.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.645]                 "immediateCondition"))) {
[10:26:36.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.645]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.645]                   if (TRUE && !signal) {
[10:26:36.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.645]                     {
[10:26:36.645]                       inherits <- base::inherits
[10:26:36.645]                       invokeRestart <- base::invokeRestart
[10:26:36.645]                       is.null <- base::is.null
[10:26:36.645]                       muffled <- FALSE
[10:26:36.645]                       if (inherits(cond, "message")) {
[10:26:36.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.645]                         if (muffled) 
[10:26:36.645]                           invokeRestart("muffleMessage")
[10:26:36.645]                       }
[10:26:36.645]                       else if (inherits(cond, "warning")) {
[10:26:36.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.645]                         if (muffled) 
[10:26:36.645]                           invokeRestart("muffleWarning")
[10:26:36.645]                       }
[10:26:36.645]                       else if (inherits(cond, "condition")) {
[10:26:36.645]                         if (!is.null(pattern)) {
[10:26:36.645]                           computeRestarts <- base::computeRestarts
[10:26:36.645]                           grepl <- base::grepl
[10:26:36.645]                           restarts <- computeRestarts(cond)
[10:26:36.645]                           for (restart in restarts) {
[10:26:36.645]                             name <- restart$name
[10:26:36.645]                             if (is.null(name)) 
[10:26:36.645]                               next
[10:26:36.645]                             if (!grepl(pattern, name)) 
[10:26:36.645]                               next
[10:26:36.645]                             invokeRestart(restart)
[10:26:36.645]                             muffled <- TRUE
[10:26:36.645]                             break
[10:26:36.645]                           }
[10:26:36.645]                         }
[10:26:36.645]                       }
[10:26:36.645]                       invisible(muffled)
[10:26:36.645]                     }
[10:26:36.645]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.645]                   }
[10:26:36.645]                 }
[10:26:36.645]                 else {
[10:26:36.645]                   if (TRUE) {
[10:26:36.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.645]                     {
[10:26:36.645]                       inherits <- base::inherits
[10:26:36.645]                       invokeRestart <- base::invokeRestart
[10:26:36.645]                       is.null <- base::is.null
[10:26:36.645]                       muffled <- FALSE
[10:26:36.645]                       if (inherits(cond, "message")) {
[10:26:36.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.645]                         if (muffled) 
[10:26:36.645]                           invokeRestart("muffleMessage")
[10:26:36.645]                       }
[10:26:36.645]                       else if (inherits(cond, "warning")) {
[10:26:36.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.645]                         if (muffled) 
[10:26:36.645]                           invokeRestart("muffleWarning")
[10:26:36.645]                       }
[10:26:36.645]                       else if (inherits(cond, "condition")) {
[10:26:36.645]                         if (!is.null(pattern)) {
[10:26:36.645]                           computeRestarts <- base::computeRestarts
[10:26:36.645]                           grepl <- base::grepl
[10:26:36.645]                           restarts <- computeRestarts(cond)
[10:26:36.645]                           for (restart in restarts) {
[10:26:36.645]                             name <- restart$name
[10:26:36.645]                             if (is.null(name)) 
[10:26:36.645]                               next
[10:26:36.645]                             if (!grepl(pattern, name)) 
[10:26:36.645]                               next
[10:26:36.645]                             invokeRestart(restart)
[10:26:36.645]                             muffled <- TRUE
[10:26:36.645]                             break
[10:26:36.645]                           }
[10:26:36.645]                         }
[10:26:36.645]                       }
[10:26:36.645]                       invisible(muffled)
[10:26:36.645]                     }
[10:26:36.645]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.645]                   }
[10:26:36.645]                 }
[10:26:36.645]             }
[10:26:36.645]         }))
[10:26:36.645]     }, error = function(ex) {
[10:26:36.645]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.645]                 ...future.rng), started = ...future.startTime, 
[10:26:36.645]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.645]             version = "1.8"), class = "FutureResult")
[10:26:36.645]     }, finally = {
[10:26:36.645]         if (!identical(...future.workdir, getwd())) 
[10:26:36.645]             setwd(...future.workdir)
[10:26:36.645]         {
[10:26:36.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.645]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.645]             }
[10:26:36.645]             base::options(...future.oldOptions)
[10:26:36.645]             if (.Platform$OS.type == "windows") {
[10:26:36.645]                 old_names <- names(...future.oldEnvVars)
[10:26:36.645]                 envs <- base::Sys.getenv()
[10:26:36.645]                 names <- names(envs)
[10:26:36.645]                 common <- intersect(names, old_names)
[10:26:36.645]                 added <- setdiff(names, old_names)
[10:26:36.645]                 removed <- setdiff(old_names, names)
[10:26:36.645]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.645]                   envs[common]]
[10:26:36.645]                 NAMES <- toupper(changed)
[10:26:36.645]                 args <- list()
[10:26:36.645]                 for (kk in seq_along(NAMES)) {
[10:26:36.645]                   name <- changed[[kk]]
[10:26:36.645]                   NAME <- NAMES[[kk]]
[10:26:36.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.645]                     next
[10:26:36.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.645]                 }
[10:26:36.645]                 NAMES <- toupper(added)
[10:26:36.645]                 for (kk in seq_along(NAMES)) {
[10:26:36.645]                   name <- added[[kk]]
[10:26:36.645]                   NAME <- NAMES[[kk]]
[10:26:36.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.645]                     next
[10:26:36.645]                   args[[name]] <- ""
[10:26:36.645]                 }
[10:26:36.645]                 NAMES <- toupper(removed)
[10:26:36.645]                 for (kk in seq_along(NAMES)) {
[10:26:36.645]                   name <- removed[[kk]]
[10:26:36.645]                   NAME <- NAMES[[kk]]
[10:26:36.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.645]                     next
[10:26:36.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.645]                 }
[10:26:36.645]                 if (length(args) > 0) 
[10:26:36.645]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.645]             }
[10:26:36.645]             else {
[10:26:36.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.645]             }
[10:26:36.645]             {
[10:26:36.645]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.645]                   0L) {
[10:26:36.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.645]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.645]                   base::options(opts)
[10:26:36.645]                 }
[10:26:36.645]                 {
[10:26:36.645]                   {
[10:26:36.645]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:36.645]                     NULL
[10:26:36.645]                   }
[10:26:36.645]                   options(future.plan = NULL)
[10:26:36.645]                   if (is.na(NA_character_)) 
[10:26:36.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.645]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:36.645]                     envir = parent.frame()) 
[10:26:36.645]                   {
[10:26:36.645]                     default_workers <- missing(workers)
[10:26:36.645]                     if (is.function(workers)) 
[10:26:36.645]                       workers <- workers()
[10:26:36.645]                     workers <- structure(as.integer(workers), 
[10:26:36.645]                       class = class(workers))
[10:26:36.645]                     stop_if_not(is.finite(workers), workers >= 
[10:26:36.645]                       1L)
[10:26:36.645]                     if ((workers == 1L && !inherits(workers, 
[10:26:36.645]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:36.645]                       if (default_workers) 
[10:26:36.645]                         supportsMulticore(warn = TRUE)
[10:26:36.645]                       return(sequential(..., envir = envir))
[10:26:36.645]                     }
[10:26:36.645]                     oopts <- options(mc.cores = workers)
[10:26:36.645]                     on.exit(options(oopts))
[10:26:36.645]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:36.645]                       envir = envir)
[10:26:36.645]                     if (!future$lazy) 
[10:26:36.645]                       future <- run(future)
[10:26:36.645]                     invisible(future)
[10:26:36.645]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.645]                 }
[10:26:36.645]             }
[10:26:36.645]         }
[10:26:36.645]     })
[10:26:36.645]     if (TRUE) {
[10:26:36.645]         base::sink(type = "output", split = FALSE)
[10:26:36.645]         if (TRUE) {
[10:26:36.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.645]         }
[10:26:36.645]         else {
[10:26:36.645]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.645]         }
[10:26:36.645]         base::close(...future.stdout)
[10:26:36.645]         ...future.stdout <- NULL
[10:26:36.645]     }
[10:26:36.645]     ...future.result$conditions <- ...future.conditions
[10:26:36.645]     ...future.result$finished <- base::Sys.time()
[10:26:36.645]     ...future.result
[10:26:36.645] }
[10:26:36.684]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.648] assign_globals() ...
[10:26:36.684]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.648] List of 3
[10:26:36.648]  $ nested_a:List of 1
[10:26:36.648]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:36.648]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:36.648]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.648]  $ a       : int 1
[10:26:36.648]  $ plan_a  :List of 1
[10:26:36.648]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:36.648]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:36.648]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.648]  - attr(*, "where")=List of 3
[10:26:36.648]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:26:36.648]   ..$ a       :<environment: R_EmptyEnv> 
[10:26:36.648]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:26:36.648]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.648]  - attr(*, "resolved")= logi FALSE
[10:26:36.648]  - attr(*, "total_size")= num 95240
[10:26:36.648]  - attr(*, "already-done")= logi TRUE
[10:26:36.684]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.652] - copied ‘nested_a’ to environment
[10:26:36.685]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.652] - copied ‘a’ to environment
[10:26:36.685]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.653] - copied ‘plan_a’ to environment
[10:26:36.685]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.653] assign_globals() ... done
[10:26:36.685]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.653] requestCore(): workers = 2
[10:26:36.685]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.656] MulticoreFuture started
[10:26:36.685]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.657] - Launch lazy future ... done
[10:26:36.686]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.657] run() for ‘MulticoreFuture’ ... done
[10:26:36.686]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.658] result() for MulticoreFuture ...
[10:26:36.686]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.670] result() for MulticoreFuture ...
[10:26:36.686]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.670] result() for MulticoreFuture ... done
[10:26:36.686]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.670] result() for MulticoreFuture ... done
[10:26:36.686]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.670] result() for MulticoreFuture ...
[10:26:36.686]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.670] result() for MulticoreFuture ... done
[10:26:36.687] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:36.692] getGlobalsAndPackages() ...
[10:26:36.692] Searching for globals...
[10:26:36.694] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:36.694] Searching for globals ... DONE
[10:26:36.694] Resolving globals: FALSE
[10:26:36.695] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:36.695] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:36.695] - globals: [1] ‘data’
[10:26:36.695] - packages: [1] ‘future’
[10:26:36.695] getGlobalsAndPackages() ... DONE
[10:26:36.696] run() for ‘Future’ ...
[10:26:36.696] - state: ‘created’
[10:26:36.696] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:36.696] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:36.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:36.696]   - Field: ‘label’
[10:26:36.696]   - Field: ‘local’
[10:26:36.697]   - Field: ‘owner’
[10:26:36.697]   - Field: ‘envir’
[10:26:36.697]   - Field: ‘packages’
[10:26:36.697]   - Field: ‘gc’
[10:26:36.697]   - Field: ‘conditions’
[10:26:36.698]   - Field: ‘expr’
[10:26:36.698]   - Field: ‘uuid’
[10:26:36.698]   - Field: ‘seed’
[10:26:36.698]   - Field: ‘version’
[10:26:36.699]   - Field: ‘result’
[10:26:36.699]   - Field: ‘asynchronous’
[10:26:36.699]   - Field: ‘calls’
[10:26:36.699]   - Field: ‘globals’
[10:26:36.699]   - Field: ‘stdout’
[10:26:36.699]   - Field: ‘earlySignal’
[10:26:36.699]   - Field: ‘lazy’
[10:26:36.699]   - Field: ‘state’
[10:26:36.699] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:36.699] - Launch lazy future ...
[10:26:36.700] Packages needed by the future expression (n = 1): ‘future’
[10:26:36.700] Packages needed by future strategies (n = 1): ‘future’
[10:26:36.700] {
[10:26:36.700]     {
[10:26:36.700]         {
[10:26:36.700]             ...future.startTime <- base::Sys.time()
[10:26:36.700]             {
[10:26:36.700]                 {
[10:26:36.700]                   {
[10:26:36.700]                     {
[10:26:36.700]                       base::local({
[10:26:36.700]                         has_future <- base::requireNamespace("future", 
[10:26:36.700]                           quietly = TRUE)
[10:26:36.700]                         if (has_future) {
[10:26:36.700]                           ns <- base::getNamespace("future")
[10:26:36.700]                           version <- ns[[".package"]][["version"]]
[10:26:36.700]                           if (is.null(version)) 
[10:26:36.700]                             version <- utils::packageVersion("future")
[10:26:36.700]                         }
[10:26:36.700]                         else {
[10:26:36.700]                           version <- NULL
[10:26:36.700]                         }
[10:26:36.700]                         if (!has_future || version < "1.8.0") {
[10:26:36.700]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.700]                             "", base::R.version$version.string), 
[10:26:36.700]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:36.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.700]                               "release", "version")], collapse = " "), 
[10:26:36.700]                             hostname = base::Sys.info()[["nodename"]])
[10:26:36.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.700]                             info)
[10:26:36.700]                           info <- base::paste(info, collapse = "; ")
[10:26:36.700]                           if (!has_future) {
[10:26:36.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.700]                               info)
[10:26:36.700]                           }
[10:26:36.700]                           else {
[10:26:36.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.700]                               info, version)
[10:26:36.700]                           }
[10:26:36.700]                           base::stop(msg)
[10:26:36.700]                         }
[10:26:36.700]                       })
[10:26:36.700]                     }
[10:26:36.700]                     base::local({
[10:26:36.700]                       for (pkg in "future") {
[10:26:36.700]                         base::loadNamespace(pkg)
[10:26:36.700]                         base::library(pkg, character.only = TRUE)
[10:26:36.700]                       }
[10:26:36.700]                     })
[10:26:36.700]                   }
[10:26:36.700]                   options(future.plan = NULL)
[10:26:36.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.700]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:36.700]                     envir = parent.frame()) 
[10:26:36.700]                   {
[10:26:36.700]                     default_workers <- missing(workers)
[10:26:36.700]                     if (is.function(workers)) 
[10:26:36.700]                       workers <- workers()
[10:26:36.700]                     workers <- structure(as.integer(workers), 
[10:26:36.700]                       class = class(workers))
[10:26:36.700]                     stop_if_not(is.finite(workers), workers >= 
[10:26:36.700]                       1L)
[10:26:36.700]                     if ((workers == 1L && !inherits(workers, 
[10:26:36.700]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:36.700]                       if (default_workers) 
[10:26:36.700]                         supportsMulticore(warn = TRUE)
[10:26:36.700]                       return(sequential(..., envir = envir))
[10:26:36.700]                     }
[10:26:36.700]                     oopts <- options(mc.cores = workers)
[10:26:36.700]                     on.exit(options(oopts))
[10:26:36.700]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:36.700]                       envir = envir)
[10:26:36.700]                     if (!future$lazy) 
[10:26:36.700]                       future <- run(future)
[10:26:36.700]                     invisible(future)
[10:26:36.700]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.700]                 }
[10:26:36.700]                 ...future.workdir <- getwd()
[10:26:36.700]             }
[10:26:36.700]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.700]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.700]         }
[10:26:36.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.700]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.700]             base::names(...future.oldOptions))
[10:26:36.700]     }
[10:26:36.700]     if (FALSE) {
[10:26:36.700]     }
[10:26:36.700]     else {
[10:26:36.700]         if (TRUE) {
[10:26:36.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.700]                 open = "w")
[10:26:36.700]         }
[10:26:36.700]         else {
[10:26:36.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.700]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.700]         }
[10:26:36.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.700]             base::sink(type = "output", split = FALSE)
[10:26:36.700]             base::close(...future.stdout)
[10:26:36.700]         }, add = TRUE)
[10:26:36.700]     }
[10:26:36.700]     ...future.frame <- base::sys.nframe()
[10:26:36.700]     ...future.conditions <- base::list()
[10:26:36.700]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.700]     if (FALSE) {
[10:26:36.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.700]     }
[10:26:36.700]     ...future.result <- base::tryCatch({
[10:26:36.700]         base::withCallingHandlers({
[10:26:36.700]             ...future.value <- base::withVisible(base::local({
[10:26:36.700]                 value(future(subset(data, a == 2)))
[10:26:36.700]             }))
[10:26:36.700]             future::FutureResult(value = ...future.value$value, 
[10:26:36.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.700]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.700]                     ...future.globalenv.names))
[10:26:36.700]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.700]         }, condition = base::local({
[10:26:36.700]             c <- base::c
[10:26:36.700]             inherits <- base::inherits
[10:26:36.700]             invokeRestart <- base::invokeRestart
[10:26:36.700]             length <- base::length
[10:26:36.700]             list <- base::list
[10:26:36.700]             seq.int <- base::seq.int
[10:26:36.700]             signalCondition <- base::signalCondition
[10:26:36.700]             sys.calls <- base::sys.calls
[10:26:36.700]             `[[` <- base::`[[`
[10:26:36.700]             `+` <- base::`+`
[10:26:36.700]             `<<-` <- base::`<<-`
[10:26:36.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.700]                   3L)]
[10:26:36.700]             }
[10:26:36.700]             function(cond) {
[10:26:36.700]                 is_error <- inherits(cond, "error")
[10:26:36.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.700]                   NULL)
[10:26:36.700]                 if (is_error) {
[10:26:36.700]                   sessionInformation <- function() {
[10:26:36.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.700]                       search = base::search(), system = base::Sys.info())
[10:26:36.700]                   }
[10:26:36.700]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.700]                     cond$call), session = sessionInformation(), 
[10:26:36.700]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.700]                   signalCondition(cond)
[10:26:36.700]                 }
[10:26:36.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.700]                 "immediateCondition"))) {
[10:26:36.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.700]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.700]                   if (TRUE && !signal) {
[10:26:36.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.700]                     {
[10:26:36.700]                       inherits <- base::inherits
[10:26:36.700]                       invokeRestart <- base::invokeRestart
[10:26:36.700]                       is.null <- base::is.null
[10:26:36.700]                       muffled <- FALSE
[10:26:36.700]                       if (inherits(cond, "message")) {
[10:26:36.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.700]                         if (muffled) 
[10:26:36.700]                           invokeRestart("muffleMessage")
[10:26:36.700]                       }
[10:26:36.700]                       else if (inherits(cond, "warning")) {
[10:26:36.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.700]                         if (muffled) 
[10:26:36.700]                           invokeRestart("muffleWarning")
[10:26:36.700]                       }
[10:26:36.700]                       else if (inherits(cond, "condition")) {
[10:26:36.700]                         if (!is.null(pattern)) {
[10:26:36.700]                           computeRestarts <- base::computeRestarts
[10:26:36.700]                           grepl <- base::grepl
[10:26:36.700]                           restarts <- computeRestarts(cond)
[10:26:36.700]                           for (restart in restarts) {
[10:26:36.700]                             name <- restart$name
[10:26:36.700]                             if (is.null(name)) 
[10:26:36.700]                               next
[10:26:36.700]                             if (!grepl(pattern, name)) 
[10:26:36.700]                               next
[10:26:36.700]                             invokeRestart(restart)
[10:26:36.700]                             muffled <- TRUE
[10:26:36.700]                             break
[10:26:36.700]                           }
[10:26:36.700]                         }
[10:26:36.700]                       }
[10:26:36.700]                       invisible(muffled)
[10:26:36.700]                     }
[10:26:36.700]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.700]                   }
[10:26:36.700]                 }
[10:26:36.700]                 else {
[10:26:36.700]                   if (TRUE) {
[10:26:36.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.700]                     {
[10:26:36.700]                       inherits <- base::inherits
[10:26:36.700]                       invokeRestart <- base::invokeRestart
[10:26:36.700]                       is.null <- base::is.null
[10:26:36.700]                       muffled <- FALSE
[10:26:36.700]                       if (inherits(cond, "message")) {
[10:26:36.700]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.700]                         if (muffled) 
[10:26:36.700]                           invokeRestart("muffleMessage")
[10:26:36.700]                       }
[10:26:36.700]                       else if (inherits(cond, "warning")) {
[10:26:36.700]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.700]                         if (muffled) 
[10:26:36.700]                           invokeRestart("muffleWarning")
[10:26:36.700]                       }
[10:26:36.700]                       else if (inherits(cond, "condition")) {
[10:26:36.700]                         if (!is.null(pattern)) {
[10:26:36.700]                           computeRestarts <- base::computeRestarts
[10:26:36.700]                           grepl <- base::grepl
[10:26:36.700]                           restarts <- computeRestarts(cond)
[10:26:36.700]                           for (restart in restarts) {
[10:26:36.700]                             name <- restart$name
[10:26:36.700]                             if (is.null(name)) 
[10:26:36.700]                               next
[10:26:36.700]                             if (!grepl(pattern, name)) 
[10:26:36.700]                               next
[10:26:36.700]                             invokeRestart(restart)
[10:26:36.700]                             muffled <- TRUE
[10:26:36.700]                             break
[10:26:36.700]                           }
[10:26:36.700]                         }
[10:26:36.700]                       }
[10:26:36.700]                       invisible(muffled)
[10:26:36.700]                     }
[10:26:36.700]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.700]                   }
[10:26:36.700]                 }
[10:26:36.700]             }
[10:26:36.700]         }))
[10:26:36.700]     }, error = function(ex) {
[10:26:36.700]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.700]                 ...future.rng), started = ...future.startTime, 
[10:26:36.700]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.700]             version = "1.8"), class = "FutureResult")
[10:26:36.700]     }, finally = {
[10:26:36.700]         if (!identical(...future.workdir, getwd())) 
[10:26:36.700]             setwd(...future.workdir)
[10:26:36.700]         {
[10:26:36.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.700]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.700]             }
[10:26:36.700]             base::options(...future.oldOptions)
[10:26:36.700]             if (.Platform$OS.type == "windows") {
[10:26:36.700]                 old_names <- names(...future.oldEnvVars)
[10:26:36.700]                 envs <- base::Sys.getenv()
[10:26:36.700]                 names <- names(envs)
[10:26:36.700]                 common <- intersect(names, old_names)
[10:26:36.700]                 added <- setdiff(names, old_names)
[10:26:36.700]                 removed <- setdiff(old_names, names)
[10:26:36.700]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.700]                   envs[common]]
[10:26:36.700]                 NAMES <- toupper(changed)
[10:26:36.700]                 args <- list()
[10:26:36.700]                 for (kk in seq_along(NAMES)) {
[10:26:36.700]                   name <- changed[[kk]]
[10:26:36.700]                   NAME <- NAMES[[kk]]
[10:26:36.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.700]                     next
[10:26:36.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.700]                 }
[10:26:36.700]                 NAMES <- toupper(added)
[10:26:36.700]                 for (kk in seq_along(NAMES)) {
[10:26:36.700]                   name <- added[[kk]]
[10:26:36.700]                   NAME <- NAMES[[kk]]
[10:26:36.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.700]                     next
[10:26:36.700]                   args[[name]] <- ""
[10:26:36.700]                 }
[10:26:36.700]                 NAMES <- toupper(removed)
[10:26:36.700]                 for (kk in seq_along(NAMES)) {
[10:26:36.700]                   name <- removed[[kk]]
[10:26:36.700]                   NAME <- NAMES[[kk]]
[10:26:36.700]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.700]                     next
[10:26:36.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.700]                 }
[10:26:36.700]                 if (length(args) > 0) 
[10:26:36.700]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.700]             }
[10:26:36.700]             else {
[10:26:36.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.700]             }
[10:26:36.700]             {
[10:26:36.700]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.700]                   0L) {
[10:26:36.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.700]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.700]                   base::options(opts)
[10:26:36.700]                 }
[10:26:36.700]                 {
[10:26:36.700]                   {
[10:26:36.700]                     NULL
[10:26:36.700]                     RNGkind("Mersenne-Twister")
[10:26:36.700]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:36.700]                       inherits = FALSE)
[10:26:36.700]                   }
[10:26:36.700]                   options(future.plan = NULL)
[10:26:36.700]                   if (is.na(NA_character_)) 
[10:26:36.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.700]                   future::plan(list(a = function (..., envir = parent.frame()) 
[10:26:36.700]                   {
[10:26:36.700]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.700]                     if (!future$lazy) 
[10:26:36.700]                       future <- run(future)
[10:26:36.700]                     invisible(future)
[10:26:36.700]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:36.700]                     envir = parent.frame()) 
[10:26:36.700]                   {
[10:26:36.700]                     default_workers <- missing(workers)
[10:26:36.700]                     if (is.function(workers)) 
[10:26:36.700]                       workers <- workers()
[10:26:36.700]                     workers <- structure(as.integer(workers), 
[10:26:36.700]                       class = class(workers))
[10:26:36.700]                     stop_if_not(is.finite(workers), workers >= 
[10:26:36.700]                       1L)
[10:26:36.700]                     if ((workers == 1L && !inherits(workers, 
[10:26:36.700]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:36.700]                       if (default_workers) 
[10:26:36.700]                         supportsMulticore(warn = TRUE)
[10:26:36.700]                       return(sequential(..., envir = envir))
[10:26:36.700]                     }
[10:26:36.700]                     oopts <- options(mc.cores = workers)
[10:26:36.700]                     on.exit(options(oopts))
[10:26:36.700]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:36.700]                       envir = envir)
[10:26:36.700]                     if (!future$lazy) 
[10:26:36.700]                       future <- run(future)
[10:26:36.700]                     invisible(future)
[10:26:36.700]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.700]                 }
[10:26:36.700]             }
[10:26:36.700]         }
[10:26:36.700]     })
[10:26:36.700]     if (TRUE) {
[10:26:36.700]         base::sink(type = "output", split = FALSE)
[10:26:36.700]         if (TRUE) {
[10:26:36.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.700]         }
[10:26:36.700]         else {
[10:26:36.700]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.700]         }
[10:26:36.700]         base::close(...future.stdout)
[10:26:36.700]         ...future.stdout <- NULL
[10:26:36.700]     }
[10:26:36.700]     ...future.result$conditions <- ...future.conditions
[10:26:36.700]     ...future.result$finished <- base::Sys.time()
[10:26:36.700]     ...future.result
[10:26:36.700] }
[10:26:36.702] assign_globals() ...
[10:26:36.702] List of 1
[10:26:36.702]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:36.702]   ..$ a: int [1:3] 1 2 3
[10:26:36.702]   ..$ b: int [1:3] 3 2 1
[10:26:36.702]  - attr(*, "where")=List of 1
[10:26:36.702]   ..$ data:<environment: R_EmptyEnv> 
[10:26:36.702]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.702]  - attr(*, "resolved")= logi FALSE
[10:26:36.702]  - attr(*, "total_size")= num 128
[10:26:36.702]  - attr(*, "already-done")= logi TRUE
[10:26:36.705] - copied ‘data’ to environment
[10:26:36.705] assign_globals() ... done
[10:26:36.706] plan(): Setting new future strategy stack:
[10:26:36.706] List of future strategies:
[10:26:36.706] 1. multicore:
[10:26:36.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:36.706]    - tweaked: FALSE
[10:26:36.706]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.709] plan(): nbrOfWorkers() = 2
[10:26:36.753] plan(): Setting new future strategy stack:
[10:26:36.753] List of future strategies:
[10:26:36.753] 1. sequential:
[10:26:36.753]    - args: function (..., envir = parent.frame())
[10:26:36.753]    - tweaked: FALSE
[10:26:36.753]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.753] 2. multicore:
[10:26:36.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:36.753]    - tweaked: FALSE
[10:26:36.753]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.754] plan(): nbrOfWorkers() = 1
[10:26:36.754] SequentialFuture started (and completed)
[10:26:36.754] signalConditions() ...
[10:26:36.754]  - include = ‘immediateCondition’
[10:26:36.754]  - exclude = 
[10:26:36.755]  - resignal = FALSE
[10:26:36.755]  - Number of conditions: 55
[10:26:36.755] signalConditions() ... done
[10:26:36.755] - Launch lazy future ... done
[10:26:36.755] run() for ‘SequentialFuture’ ... done
[10:26:36.755] signalConditions() ...
[10:26:36.755]  - include = ‘immediateCondition’
[10:26:36.755]  - exclude = 
[10:26:36.756]  - resignal = FALSE
[10:26:36.756]  - Number of conditions: 55
[10:26:36.756] signalConditions() ... done
[10:26:36.758] Future state: ‘finished’
[10:26:36.758] signalConditions() ...
[10:26:36.759]  - include = ‘condition’
[10:26:36.759]  - exclude = ‘immediateCondition’
[10:26:36.759]  - resignal = TRUE
[10:26:36.759]  - Number of conditions: 55
[10:26:36.759]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.710] getGlobalsAndPackages() ...
[10:26:36.759]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.710] Searching for globals...
[10:26:36.759]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.724] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:36.760]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.725] Searching for globals ... DONE
[10:26:36.760]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.725] Resolving globals: FALSE
[10:26:36.760]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.725] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:36.760]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.726] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:36.760]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.726] - globals: [1] ‘data’
[10:26:36.761]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.726] 
[10:26:36.761]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.726] getGlobalsAndPackages() ... DONE
[10:26:36.761]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.726] run() for ‘Future’ ...
[10:26:36.761]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.726] - state: ‘created’
[10:26:36.761]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.726] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:36.762]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.730] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:36.762]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:36.762]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.730]   - Field: ‘label’
[10:26:36.762]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.730]   - Field: ‘local’
[10:26:36.762]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.730]   - Field: ‘owner’
[10:26:36.763]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.730]   - Field: ‘envir’
[10:26:36.763]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘workers’
[10:26:36.763]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘packages’
[10:26:36.763]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘gc’
[10:26:36.763]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘job’
[10:26:36.763]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘conditions’
[10:26:36.764]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘expr’
[10:26:36.764]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘uuid’
[10:26:36.764]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘seed’
[10:26:36.764]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.731]   - Field: ‘version’
[10:26:36.764]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘result’
[10:26:36.764]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘asynchronous’
[10:26:36.765]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘calls’
[10:26:36.765]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘globals’
[10:26:36.765]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘stdout’
[10:26:36.765]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘earlySignal’
[10:26:36.765]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘lazy’
[10:26:36.765]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732]   - Field: ‘state’
[10:26:36.766]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:36.766]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.732] - Launch lazy future ...
[10:26:36.766]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.733] Packages needed by the future expression (n = 0): <none>
[10:26:36.766]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.733] Packages needed by future strategies (n = 0): <none>
[10:26:36.766]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.733] {
[10:26:36.733]     {
[10:26:36.733]         {
[10:26:36.733]             ...future.startTime <- base::Sys.time()
[10:26:36.733]             {
[10:26:36.733]                 {
[10:26:36.733]                   {
[10:26:36.733]                     {
[10:26:36.733]                       base::local({
[10:26:36.733]                         has_future <- base::requireNamespace("future", 
[10:26:36.733]                           quietly = TRUE)
[10:26:36.733]                         if (has_future) {
[10:26:36.733]                           ns <- base::getNamespace("future")
[10:26:36.733]                           version <- ns[[".package"]][["version"]]
[10:26:36.733]                           if (is.null(version)) 
[10:26:36.733]                             version <- utils::packageVersion("future")
[10:26:36.733]                         }
[10:26:36.733]                         else {
[10:26:36.733]                           version <- NULL
[10:26:36.733]                         }
[10:26:36.733]                         if (!has_future || version < "1.8.0") {
[10:26:36.733]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.733]                             "", base::R.version$version.string), 
[10:26:36.733]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:36.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.733]                               "release", "version")], collapse = " "), 
[10:26:36.733]                             hostname = base::Sys.info()[["nodename"]])
[10:26:36.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.733]                             info)
[10:26:36.733]                           info <- base::paste(info, collapse = "; ")
[10:26:36.733]                           if (!has_future) {
[10:26:36.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.733]                               info)
[10:26:36.733]                           }
[10:26:36.733]                           else {
[10:26:36.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.733]                               info, version)
[10:26:36.733]                           }
[10:26:36.733]                           base::stop(msg)
[10:26:36.733]                         }
[10:26:36.733]                       })
[10:26:36.733]                     }
[10:26:36.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:36.733]                     base::options(mc.cores = 1L)
[10:26:36.733]                   }
[10:26:36.733]                   options(future.plan = NULL)
[10:26:36.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:36.733]                 }
[10:26:36.733]                 ...future.workdir <- getwd()
[10:26:36.733]             }
[10:26:36.733]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.733]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.733]         }
[10:26:36.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.733]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.733]             base::names(...future.oldOptions))
[10:26:36.733]     }
[10:26:36.733]     if (FALSE) {
[10:26:36.733]     }
[10:26:36.733]     else {
[10:26:36.733]         if (TRUE) {
[10:26:36.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.733]                 open = "w")
[10:26:36.733]         }
[10:26:36.733]         else {
[10:26:36.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.733]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.733]         }
[10:26:36.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.733]             base::sink(type = "output", split = FALSE)
[10:26:36.733]             base::close(...future.stdout)
[10:26:36.733]         }, add = TRUE)
[10:26:36.733]     }
[10:26:36.733]     ...future.frame <- base::sys.nframe()
[10:26:36.733]     ...future.conditions <- base::list()
[10:26:36.733]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.733]     if (FALSE) {
[10:26:36.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.733]     }
[10:26:36.733]     ...future.result <- base::tryCatch({
[10:26:36.733]         base::withCallingHandlers({
[10:26:36.733]             ...future.value <- base::withVisible(base::local({
[10:26:36.733]                 withCallingHandlers({
[10:26:36.733]                   subset(data, a == 2)
[10:26:36.733]                 }, immediateCondition = function(cond) {
[10:26:36.733]                   save_rds <- function (object, pathname, ...) 
[10:26:36.733]                   {
[10:26:36.733]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:36.733]                     if (file_test("-f", pathname_tmp)) {
[10:26:36.733]                       fi_tmp <- file.info(pathname_tmp)
[10:26:36.733]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:36.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:36.733]                         fi_tmp[["mtime"]])
[10:26:36.733]                     }
[10:26:36.733]                     tryCatch({
[10:26:36.733]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:36.733]                     }, error = function(ex) {
[10:26:36.733]                       msg <- conditionMessage(ex)
[10:26:36.733]                       fi_tmp <- file.info(pathname_tmp)
[10:26:36.733]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:36.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:36.733]                         fi_tmp[["mtime"]], msg)
[10:26:36.733]                       ex$message <- msg
[10:26:36.733]                       stop(ex)
[10:26:36.733]                     })
[10:26:36.733]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:36.733]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:36.733]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:36.733]                       fi_tmp <- file.info(pathname_tmp)
[10:26:36.733]                       fi <- file.info(pathname)
[10:26:36.733]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:36.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:36.733]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:36.733]                         fi[["size"]], fi[["mtime"]])
[10:26:36.733]                       stop(msg)
[10:26:36.733]                     }
[10:26:36.733]                     invisible(pathname)
[10:26:36.733]                   }
[10:26:36.733]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:36.733]                     rootPath = tempdir()) 
[10:26:36.733]                   {
[10:26:36.733]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:36.733]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:36.733]                       tmpdir = path, fileext = ".rds")
[10:26:36.733]                     save_rds(obj, file)
[10:26:36.733]                   }
[10:26:36.733]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:36.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.733]                   {
[10:26:36.733]                     inherits <- base::inherits
[10:26:36.733]                     invokeRestart <- base::invokeRestart
[10:26:36.733]                     is.null <- base::is.null
[10:26:36.733]                     muffled <- FALSE
[10:26:36.733]                     if (inherits(cond, "message")) {
[10:26:36.733]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:36.733]                       if (muffled) 
[10:26:36.733]                         invokeRestart("muffleMessage")
[10:26:36.733]                     }
[10:26:36.733]                     else if (inherits(cond, "warning")) {
[10:26:36.733]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:36.733]                       if (muffled) 
[10:26:36.733]                         invokeRestart("muffleWarning")
[10:26:36.733]                     }
[10:26:36.733]                     else if (inherits(cond, "condition")) {
[10:26:36.733]                       if (!is.null(pattern)) {
[10:26:36.733]                         computeRestarts <- base::computeRestarts
[10:26:36.733]                         grepl <- base::grepl
[10:26:36.733]                         restarts <- computeRestarts(cond)
[10:26:36.733]                         for (restart in restarts) {
[10:26:36.733]                           name <- restart$name
[10:26:36.733]                           if (is.null(name)) 
[10:26:36.733]                             next
[10:26:36.733]                           if (!grepl(pattern, name)) 
[10:26:36.733]                             next
[10:26:36.733]                           invokeRestart(restart)
[10:26:36.733]                           muffled <- TRUE
[10:26:36.733]                           break
[10:26:36.733]                         }
[10:26:36.733]                       }
[10:26:36.733]                     }
[10:26:36.733]                     invisible(muffled)
[10:26:36.733]                   }
[10:26:36.733]                   muffleCondition(cond)
[10:26:36.733]                 })
[10:26:36.733]             }))
[10:26:36.733]             future::FutureResult(value = ...future.value$value, 
[10:26:36.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.733]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.733]                     ...future.globalenv.names))
[10:26:36.733]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.733]         }, condition = base::local({
[10:26:36.733]             c <- base::c
[10:26:36.733]             inherits <- base::inherits
[10:26:36.733]             invokeRestart <- base::invokeRestart
[10:26:36.733]             length <- base::length
[10:26:36.733]             list <- base::list
[10:26:36.733]             seq.int <- base::seq.int
[10:26:36.733]             signalCondition <- base::signalCondition
[10:26:36.733]             sys.calls <- base::sys.calls
[10:26:36.733]             `[[` <- base::`[[`
[10:26:36.733]             `+` <- base::`+`
[10:26:36.733]             `<<-` <- base::`<<-`
[10:26:36.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.733]                   3L)]
[10:26:36.733]             }
[10:26:36.733]             function(cond) {
[10:26:36.733]                 is_error <- inherits(cond, "error")
[10:26:36.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.733]                   NULL)
[10:26:36.733]                 if (is_error) {
[10:26:36.733]                   sessionInformation <- function() {
[10:26:36.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.733]                       search = base::search(), system = base::Sys.info())
[10:26:36.733]                   }
[10:26:36.733]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.733]                     cond$call), session = sessionInformation(), 
[10:26:36.733]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.733]                   signalCondition(cond)
[10:26:36.733]                 }
[10:26:36.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.733]                 "immediateCondition"))) {
[10:26:36.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.733]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.733]                   if (TRUE && !signal) {
[10:26:36.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.733]                     {
[10:26:36.733]                       inherits <- base::inherits
[10:26:36.733]                       invokeRestart <- base::invokeRestart
[10:26:36.733]                       is.null <- base::is.null
[10:26:36.733]                       muffled <- FALSE
[10:26:36.733]                       if (inherits(cond, "message")) {
[10:26:36.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.733]                         if (muffled) 
[10:26:36.733]                           invokeRestart("muffleMessage")
[10:26:36.733]                       }
[10:26:36.733]                       else if (inherits(cond, "warning")) {
[10:26:36.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.733]                         if (muffled) 
[10:26:36.733]                           invokeRestart("muffleWarning")
[10:26:36.733]                       }
[10:26:36.733]                       else if (inherits(cond, "condition")) {
[10:26:36.733]                         if (!is.null(pattern)) {
[10:26:36.733]                           computeRestarts <- base::computeRestarts
[10:26:36.733]                           grepl <- base::grepl
[10:26:36.733]                           restarts <- computeRestarts(cond)
[10:26:36.733]                           for (restart in restarts) {
[10:26:36.733]                             name <- restart$name
[10:26:36.733]                             if (is.null(name)) 
[10:26:36.733]                               next
[10:26:36.733]                             if (!grepl(pattern, name)) 
[10:26:36.733]                               next
[10:26:36.733]                             invokeRestart(restart)
[10:26:36.733]                             muffled <- TRUE
[10:26:36.733]                             break
[10:26:36.733]                           }
[10:26:36.733]                         }
[10:26:36.733]                       }
[10:26:36.733]                       invisible(muffled)
[10:26:36.733]                     }
[10:26:36.733]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.733]                   }
[10:26:36.733]                 }
[10:26:36.733]                 else {
[10:26:36.733]                   if (TRUE) {
[10:26:36.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.733]                     {
[10:26:36.733]                       inherits <- base::inherits
[10:26:36.733]                       invokeRestart <- base::invokeRestart
[10:26:36.733]                       is.null <- base::is.null
[10:26:36.733]                       muffled <- FALSE
[10:26:36.733]                       if (inherits(cond, "message")) {
[10:26:36.733]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.733]                         if (muffled) 
[10:26:36.733]                           invokeRestart("muffleMessage")
[10:26:36.733]                       }
[10:26:36.733]                       else if (inherits(cond, "warning")) {
[10:26:36.733]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.733]                         if (muffled) 
[10:26:36.733]                           invokeRestart("muffleWarning")
[10:26:36.733]                       }
[10:26:36.733]                       else if (inherits(cond, "condition")) {
[10:26:36.733]                         if (!is.null(pattern)) {
[10:26:36.733]                           computeRestarts <- base::computeRestarts
[10:26:36.733]                           grepl <- base::grepl
[10:26:36.733]                           restarts <- computeRestarts(cond)
[10:26:36.733]                           for (restart in restarts) {
[10:26:36.733]                             name <- restart$name
[10:26:36.733]                             if (is.null(name)) 
[10:26:36.733]                               next
[10:26:36.733]                             if (!grepl(pattern, name)) 
[10:26:36.733]                               next
[10:26:36.733]                             invokeRestart(restart)
[10:26:36.733]                             muffled <- TRUE
[10:26:36.733]                             break
[10:26:36.733]                           }
[10:26:36.733]                         }
[10:26:36.733]                       }
[10:26:36.733]                       invisible(muffled)
[10:26:36.733]                     }
[10:26:36.733]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.733]                   }
[10:26:36.733]                 }
[10:26:36.733]             }
[10:26:36.733]         }))
[10:26:36.733]     }, error = function(ex) {
[10:26:36.733]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.733]                 ...future.rng), started = ...future.startTime, 
[10:26:36.733]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.733]             version = "1.8"), class = "FutureResult")
[10:26:36.733]     }, finally = {
[10:26:36.733]         if (!identical(...future.workdir, getwd())) 
[10:26:36.733]             setwd(...future.workdir)
[10:26:36.733]         {
[10:26:36.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.733]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.733]             }
[10:26:36.733]             base::options(...future.oldOptions)
[10:26:36.733]             if (.Platform$OS.type == "windows") {
[10:26:36.733]                 old_names <- names(...future.oldEnvVars)
[10:26:36.733]                 envs <- base::Sys.getenv()
[10:26:36.733]                 names <- names(envs)
[10:26:36.733]                 common <- intersect(names, old_names)
[10:26:36.733]                 added <- setdiff(names, old_names)
[10:26:36.733]                 removed <- setdiff(old_names, names)
[10:26:36.733]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.733]                   envs[common]]
[10:26:36.733]                 NAMES <- toupper(changed)
[10:26:36.733]                 args <- list()
[10:26:36.733]                 for (kk in seq_along(NAMES)) {
[10:26:36.733]                   name <- changed[[kk]]
[10:26:36.733]                   NAME <- NAMES[[kk]]
[10:26:36.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.733]                     next
[10:26:36.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.733]                 }
[10:26:36.733]                 NAMES <- toupper(added)
[10:26:36.733]                 for (kk in seq_along(NAMES)) {
[10:26:36.733]                   name <- added[[kk]]
[10:26:36.733]                   NAME <- NAMES[[kk]]
[10:26:36.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.733]                     next
[10:26:36.733]                   args[[name]] <- ""
[10:26:36.733]                 }
[10:26:36.733]                 NAMES <- toupper(removed)
[10:26:36.733]                 for (kk in seq_along(NAMES)) {
[10:26:36.733]                   name <- removed[[kk]]
[10:26:36.733]                   NAME <- NAMES[[kk]]
[10:26:36.733]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.733]                     next
[10:26:36.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.733]                 }
[10:26:36.733]                 if (length(args) > 0) 
[10:26:36.733]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.733]             }
[10:26:36.733]             else {
[10:26:36.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.733]             }
[10:26:36.733]             {
[10:26:36.733]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.733]                   0L) {
[10:26:36.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.733]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.733]                   base::options(opts)
[10:26:36.733]                 }
[10:26:36.733]                 {
[10:26:36.733]                   {
[10:26:36.733]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:36.733]                     NULL
[10:26:36.733]                   }
[10:26:36.733]                   options(future.plan = NULL)
[10:26:36.733]                   if (is.na(NA_character_)) 
[10:26:36.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.733]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:36.733]                     envir = parent.frame()) 
[10:26:36.733]                   {
[10:26:36.733]                     default_workers <- missing(workers)
[10:26:36.733]                     if (is.function(workers)) 
[10:26:36.733]                       workers <- workers()
[10:26:36.733]                     workers <- structure(as.integer(workers), 
[10:26:36.733]                       class = class(workers))
[10:26:36.733]                     stop_if_not(is.finite(workers), workers >= 
[10:26:36.733]                       1L)
[10:26:36.733]                     if ((workers == 1L && !inherits(workers, 
[10:26:36.733]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:36.733]                       if (default_workers) 
[10:26:36.733]                         supportsMulticore(warn = TRUE)
[10:26:36.733]                       return(sequential(..., envir = envir))
[10:26:36.733]                     }
[10:26:36.733]                     oopts <- options(mc.cores = workers)
[10:26:36.733]                     on.exit(options(oopts))
[10:26:36.733]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:36.733]                       envir = envir)
[10:26:36.733]                     if (!future$lazy) 
[10:26:36.733]                       future <- run(future)
[10:26:36.733]                     invisible(future)
[10:26:36.733]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.733]                 }
[10:26:36.733]             }
[10:26:36.733]         }
[10:26:36.733]     })
[10:26:36.733]     if (TRUE) {
[10:26:36.733]         base::sink(type = "output", split = FALSE)
[10:26:36.733]         if (TRUE) {
[10:26:36.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.733]         }
[10:26:36.733]         else {
[10:26:36.733]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.733]         }
[10:26:36.733]         base::close(...future.stdout)
[10:26:36.733]         ...future.stdout <- NULL
[10:26:36.733]     }
[10:26:36.733]     ...future.result$conditions <- ...future.conditions
[10:26:36.733]     ...future.result$finished <- base::Sys.time()
[10:26:36.733]     ...future.result
[10:26:36.733] }
[10:26:36.766]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.735] assign_globals() ...
[10:26:36.766]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.736] List of 1
[10:26:36.736]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:36.736]   ..$ a: int [1:3] 1 2 3
[10:26:36.736]   ..$ b: int [1:3] 3 2 1
[10:26:36.736]  - attr(*, "where")=List of 1
[10:26:36.736]   ..$ data:<environment: R_EmptyEnv> 
[10:26:36.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.736]  - attr(*, "resolved")= logi FALSE
[10:26:36.736]  - attr(*, "total_size")= num 128
[10:26:36.736]  - attr(*, "already-done")= logi TRUE
[10:26:36.767]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.739] - copied ‘data’ to environment
[10:26:36.767]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.739] assign_globals() ... done
[10:26:36.767]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.739] requestCore(): workers = 2
[10:26:36.767]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.741] MulticoreFuture started
[10:26:36.767]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.742] - Launch lazy future ... done
[10:26:36.767]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.742] run() for ‘MulticoreFuture’ ... done
[10:26:36.768]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.742] result() for MulticoreFuture ...
[10:26:36.768]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.752] result() for MulticoreFuture ...
[10:26:36.768]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.752] result() for MulticoreFuture ... done
[10:26:36.768]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.752] result() for MulticoreFuture ... done
[10:26:36.768]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.752] result() for MulticoreFuture ...
[10:26:36.768]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.752] result() for MulticoreFuture ... done
[10:26:36.769] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[10:26:36.769] plan(): Setting new future strategy stack:
[10:26:36.769] List of future strategies:
[10:26:36.769] 1. sequential:
[10:26:36.769]    - args: function (..., envir = parent.frame())
[10:26:36.769]    - tweaked: FALSE
[10:26:36.769]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.769] 2. multisession:
[10:26:36.769]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:36.769]    - tweaked: FALSE
[10:26:36.769]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.770] plan(): nbrOfWorkers() = 1
[10:26:36.770] getGlobalsAndPackages() ...
[10:26:36.770] Searching for globals...
[10:26:36.788] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:36.788] Searching for globals ... DONE
[10:26:36.788] Resolving globals: FALSE
[10:26:36.789] The total size of the 2 globals is 55.41 KiB (56736 bytes)
[10:26:36.790] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.41 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.29 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:36.790] - globals: [2] ‘nested’, ‘strategy2’
[10:26:36.790] - packages: [1] ‘future’
[10:26:36.790] getGlobalsAndPackages() ... DONE
[10:26:36.790] run() for ‘Future’ ...
[10:26:36.791] - state: ‘created’
[10:26:36.791] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:36.791] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:36.791] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:36.791]   - Field: ‘label’
[10:26:36.791]   - Field: ‘local’
[10:26:36.791]   - Field: ‘owner’
[10:26:36.791]   - Field: ‘envir’
[10:26:36.792]   - Field: ‘packages’
[10:26:36.792]   - Field: ‘gc’
[10:26:36.792]   - Field: ‘conditions’
[10:26:36.792]   - Field: ‘expr’
[10:26:36.792]   - Field: ‘uuid’
[10:26:36.792]   - Field: ‘seed’
[10:26:36.792]   - Field: ‘version’
[10:26:36.792]   - Field: ‘result’
[10:26:36.792]   - Field: ‘asynchronous’
[10:26:36.792]   - Field: ‘calls’
[10:26:36.792]   - Field: ‘globals’
[10:26:36.793]   - Field: ‘stdout’
[10:26:36.793]   - Field: ‘earlySignal’
[10:26:36.793]   - Field: ‘lazy’
[10:26:36.793]   - Field: ‘state’
[10:26:36.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:36.793] - Launch lazy future ...
[10:26:36.793] Packages needed by the future expression (n = 1): ‘future’
[10:26:36.793] Packages needed by future strategies (n = 1): ‘future’
[10:26:36.794] {
[10:26:36.794]     {
[10:26:36.794]         {
[10:26:36.794]             ...future.startTime <- base::Sys.time()
[10:26:36.794]             {
[10:26:36.794]                 {
[10:26:36.794]                   {
[10:26:36.794]                     {
[10:26:36.794]                       base::local({
[10:26:36.794]                         has_future <- base::requireNamespace("future", 
[10:26:36.794]                           quietly = TRUE)
[10:26:36.794]                         if (has_future) {
[10:26:36.794]                           ns <- base::getNamespace("future")
[10:26:36.794]                           version <- ns[[".package"]][["version"]]
[10:26:36.794]                           if (is.null(version)) 
[10:26:36.794]                             version <- utils::packageVersion("future")
[10:26:36.794]                         }
[10:26:36.794]                         else {
[10:26:36.794]                           version <- NULL
[10:26:36.794]                         }
[10:26:36.794]                         if (!has_future || version < "1.8.0") {
[10:26:36.794]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:36.794]                             "", base::R.version$version.string), 
[10:26:36.794]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:36.794]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:36.794]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:36.794]                               "release", "version")], collapse = " "), 
[10:26:36.794]                             hostname = base::Sys.info()[["nodename"]])
[10:26:36.794]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:36.794]                             info)
[10:26:36.794]                           info <- base::paste(info, collapse = "; ")
[10:26:36.794]                           if (!has_future) {
[10:26:36.794]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:36.794]                               info)
[10:26:36.794]                           }
[10:26:36.794]                           else {
[10:26:36.794]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:36.794]                               info, version)
[10:26:36.794]                           }
[10:26:36.794]                           base::stop(msg)
[10:26:36.794]                         }
[10:26:36.794]                       })
[10:26:36.794]                     }
[10:26:36.794]                     base::local({
[10:26:36.794]                       for (pkg in "future") {
[10:26:36.794]                         base::loadNamespace(pkg)
[10:26:36.794]                         base::library(pkg, character.only = TRUE)
[10:26:36.794]                       }
[10:26:36.794]                     })
[10:26:36.794]                   }
[10:26:36.794]                   options(future.plan = NULL)
[10:26:36.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.794]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:36.794]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:36.794]                     envir = parent.frame()) 
[10:26:36.794]                   {
[10:26:36.794]                     if (is.function(workers)) 
[10:26:36.794]                       workers <- workers()
[10:26:36.794]                     workers <- structure(as.integer(workers), 
[10:26:36.794]                       class = class(workers))
[10:26:36.794]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:36.794]                       workers >= 1)
[10:26:36.794]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:36.794]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:36.794]                     }
[10:26:36.794]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:36.794]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:36.794]                       envir = envir)
[10:26:36.794]                     if (!future$lazy) 
[10:26:36.794]                       future <- run(future)
[10:26:36.794]                     invisible(future)
[10:26:36.794]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.794]                 }
[10:26:36.794]                 ...future.workdir <- getwd()
[10:26:36.794]             }
[10:26:36.794]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:36.794]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:36.794]         }
[10:26:36.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:36.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:36.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:36.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:36.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:36.794]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:36.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:36.794]             base::names(...future.oldOptions))
[10:26:36.794]     }
[10:26:36.794]     if (FALSE) {
[10:26:36.794]     }
[10:26:36.794]     else {
[10:26:36.794]         if (TRUE) {
[10:26:36.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:36.794]                 open = "w")
[10:26:36.794]         }
[10:26:36.794]         else {
[10:26:36.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:36.794]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:36.794]         }
[10:26:36.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:36.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:36.794]             base::sink(type = "output", split = FALSE)
[10:26:36.794]             base::close(...future.stdout)
[10:26:36.794]         }, add = TRUE)
[10:26:36.794]     }
[10:26:36.794]     ...future.frame <- base::sys.nframe()
[10:26:36.794]     ...future.conditions <- base::list()
[10:26:36.794]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:36.794]     if (FALSE) {
[10:26:36.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:36.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:36.794]     }
[10:26:36.794]     ...future.result <- base::tryCatch({
[10:26:36.794]         base::withCallingHandlers({
[10:26:36.794]             ...future.value <- base::withVisible(base::local({
[10:26:36.794]                 a <- 1L
[10:26:36.794]                 plan_a <- unclass(future::plan("list"))
[10:26:36.794]                 nested_a <- nested[-1]
[10:26:36.794]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:36.794]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.794]                   strategy2))
[10:26:36.794]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:36.794]                   "init") <- NULL
[10:26:36.794]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:36.794]                   "init") <- NULL
[10:26:36.794]                 stopifnot(all.equal(plan_a, nested_a))
[10:26:36.794]                 y %<-% {
[10:26:36.794]                   b <- 2L
[10:26:36.794]                   plan_b <- future::plan("list")
[10:26:36.794]                   nested_b <- nested_a[-1]
[10:26:36.794]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:36.794]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:36.794]                     "sequential"))
[10:26:36.794]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:36.794]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:36.794]                 }
[10:26:36.794]                 y
[10:26:36.794]             }))
[10:26:36.794]             future::FutureResult(value = ...future.value$value, 
[10:26:36.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.794]                   ...future.rng), globalenv = if (FALSE) 
[10:26:36.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:36.794]                     ...future.globalenv.names))
[10:26:36.794]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:36.794]         }, condition = base::local({
[10:26:36.794]             c <- base::c
[10:26:36.794]             inherits <- base::inherits
[10:26:36.794]             invokeRestart <- base::invokeRestart
[10:26:36.794]             length <- base::length
[10:26:36.794]             list <- base::list
[10:26:36.794]             seq.int <- base::seq.int
[10:26:36.794]             signalCondition <- base::signalCondition
[10:26:36.794]             sys.calls <- base::sys.calls
[10:26:36.794]             `[[` <- base::`[[`
[10:26:36.794]             `+` <- base::`+`
[10:26:36.794]             `<<-` <- base::`<<-`
[10:26:36.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:36.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:36.794]                   3L)]
[10:26:36.794]             }
[10:26:36.794]             function(cond) {
[10:26:36.794]                 is_error <- inherits(cond, "error")
[10:26:36.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:36.794]                   NULL)
[10:26:36.794]                 if (is_error) {
[10:26:36.794]                   sessionInformation <- function() {
[10:26:36.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:36.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:36.794]                       search = base::search(), system = base::Sys.info())
[10:26:36.794]                   }
[10:26:36.794]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:36.794]                     cond$call), session = sessionInformation(), 
[10:26:36.794]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:36.794]                   signalCondition(cond)
[10:26:36.794]                 }
[10:26:36.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:36.794]                 "immediateCondition"))) {
[10:26:36.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:36.794]                   ...future.conditions[[length(...future.conditions) + 
[10:26:36.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:36.794]                   if (TRUE && !signal) {
[10:26:36.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.794]                     {
[10:26:36.794]                       inherits <- base::inherits
[10:26:36.794]                       invokeRestart <- base::invokeRestart
[10:26:36.794]                       is.null <- base::is.null
[10:26:36.794]                       muffled <- FALSE
[10:26:36.794]                       if (inherits(cond, "message")) {
[10:26:36.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.794]                         if (muffled) 
[10:26:36.794]                           invokeRestart("muffleMessage")
[10:26:36.794]                       }
[10:26:36.794]                       else if (inherits(cond, "warning")) {
[10:26:36.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.794]                         if (muffled) 
[10:26:36.794]                           invokeRestart("muffleWarning")
[10:26:36.794]                       }
[10:26:36.794]                       else if (inherits(cond, "condition")) {
[10:26:36.794]                         if (!is.null(pattern)) {
[10:26:36.794]                           computeRestarts <- base::computeRestarts
[10:26:36.794]                           grepl <- base::grepl
[10:26:36.794]                           restarts <- computeRestarts(cond)
[10:26:36.794]                           for (restart in restarts) {
[10:26:36.794]                             name <- restart$name
[10:26:36.794]                             if (is.null(name)) 
[10:26:36.794]                               next
[10:26:36.794]                             if (!grepl(pattern, name)) 
[10:26:36.794]                               next
[10:26:36.794]                             invokeRestart(restart)
[10:26:36.794]                             muffled <- TRUE
[10:26:36.794]                             break
[10:26:36.794]                           }
[10:26:36.794]                         }
[10:26:36.794]                       }
[10:26:36.794]                       invisible(muffled)
[10:26:36.794]                     }
[10:26:36.794]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.794]                   }
[10:26:36.794]                 }
[10:26:36.794]                 else {
[10:26:36.794]                   if (TRUE) {
[10:26:36.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:36.794]                     {
[10:26:36.794]                       inherits <- base::inherits
[10:26:36.794]                       invokeRestart <- base::invokeRestart
[10:26:36.794]                       is.null <- base::is.null
[10:26:36.794]                       muffled <- FALSE
[10:26:36.794]                       if (inherits(cond, "message")) {
[10:26:36.794]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:36.794]                         if (muffled) 
[10:26:36.794]                           invokeRestart("muffleMessage")
[10:26:36.794]                       }
[10:26:36.794]                       else if (inherits(cond, "warning")) {
[10:26:36.794]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:36.794]                         if (muffled) 
[10:26:36.794]                           invokeRestart("muffleWarning")
[10:26:36.794]                       }
[10:26:36.794]                       else if (inherits(cond, "condition")) {
[10:26:36.794]                         if (!is.null(pattern)) {
[10:26:36.794]                           computeRestarts <- base::computeRestarts
[10:26:36.794]                           grepl <- base::grepl
[10:26:36.794]                           restarts <- computeRestarts(cond)
[10:26:36.794]                           for (restart in restarts) {
[10:26:36.794]                             name <- restart$name
[10:26:36.794]                             if (is.null(name)) 
[10:26:36.794]                               next
[10:26:36.794]                             if (!grepl(pattern, name)) 
[10:26:36.794]                               next
[10:26:36.794]                             invokeRestart(restart)
[10:26:36.794]                             muffled <- TRUE
[10:26:36.794]                             break
[10:26:36.794]                           }
[10:26:36.794]                         }
[10:26:36.794]                       }
[10:26:36.794]                       invisible(muffled)
[10:26:36.794]                     }
[10:26:36.794]                     muffleCondition(cond, pattern = "^muffle")
[10:26:36.794]                   }
[10:26:36.794]                 }
[10:26:36.794]             }
[10:26:36.794]         }))
[10:26:36.794]     }, error = function(ex) {
[10:26:36.794]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:36.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:36.794]                 ...future.rng), started = ...future.startTime, 
[10:26:36.794]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:36.794]             version = "1.8"), class = "FutureResult")
[10:26:36.794]     }, finally = {
[10:26:36.794]         if (!identical(...future.workdir, getwd())) 
[10:26:36.794]             setwd(...future.workdir)
[10:26:36.794]         {
[10:26:36.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:36.794]                 ...future.oldOptions$nwarnings <- NULL
[10:26:36.794]             }
[10:26:36.794]             base::options(...future.oldOptions)
[10:26:36.794]             if (.Platform$OS.type == "windows") {
[10:26:36.794]                 old_names <- names(...future.oldEnvVars)
[10:26:36.794]                 envs <- base::Sys.getenv()
[10:26:36.794]                 names <- names(envs)
[10:26:36.794]                 common <- intersect(names, old_names)
[10:26:36.794]                 added <- setdiff(names, old_names)
[10:26:36.794]                 removed <- setdiff(old_names, names)
[10:26:36.794]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:36.794]                   envs[common]]
[10:26:36.794]                 NAMES <- toupper(changed)
[10:26:36.794]                 args <- list()
[10:26:36.794]                 for (kk in seq_along(NAMES)) {
[10:26:36.794]                   name <- changed[[kk]]
[10:26:36.794]                   NAME <- NAMES[[kk]]
[10:26:36.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.794]                     next
[10:26:36.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.794]                 }
[10:26:36.794]                 NAMES <- toupper(added)
[10:26:36.794]                 for (kk in seq_along(NAMES)) {
[10:26:36.794]                   name <- added[[kk]]
[10:26:36.794]                   NAME <- NAMES[[kk]]
[10:26:36.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.794]                     next
[10:26:36.794]                   args[[name]] <- ""
[10:26:36.794]                 }
[10:26:36.794]                 NAMES <- toupper(removed)
[10:26:36.794]                 for (kk in seq_along(NAMES)) {
[10:26:36.794]                   name <- removed[[kk]]
[10:26:36.794]                   NAME <- NAMES[[kk]]
[10:26:36.794]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:36.794]                     next
[10:26:36.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:36.794]                 }
[10:26:36.794]                 if (length(args) > 0) 
[10:26:36.794]                   base::do.call(base::Sys.setenv, args = args)
[10:26:36.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:36.794]             }
[10:26:36.794]             else {
[10:26:36.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:36.794]             }
[10:26:36.794]             {
[10:26:36.794]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:36.794]                   0L) {
[10:26:36.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:36.794]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:36.794]                   base::options(opts)
[10:26:36.794]                 }
[10:26:36.794]                 {
[10:26:36.794]                   {
[10:26:36.794]                     NULL
[10:26:36.794]                     RNGkind("Mersenne-Twister")
[10:26:36.794]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:36.794]                       inherits = FALSE)
[10:26:36.794]                   }
[10:26:36.794]                   options(future.plan = NULL)
[10:26:36.794]                   if (is.na(NA_character_)) 
[10:26:36.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:36.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:36.794]                   future::plan(list(a = function (..., envir = parent.frame()) 
[10:26:36.794]                   {
[10:26:36.794]                     future <- SequentialFuture(..., envir = envir)
[10:26:36.794]                     if (!future$lazy) 
[10:26:36.794]                       future <- run(future)
[10:26:36.794]                     invisible(future)
[10:26:36.794]                   }, b = function (..., workers = availableCores(), 
[10:26:36.794]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:36.794]                     envir = parent.frame()) 
[10:26:36.794]                   {
[10:26:36.794]                     if (is.function(workers)) 
[10:26:36.794]                       workers <- workers()
[10:26:36.794]                     workers <- structure(as.integer(workers), 
[10:26:36.794]                       class = class(workers))
[10:26:36.794]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:36.794]                       workers >= 1)
[10:26:36.794]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:36.794]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:36.794]                     }
[10:26:36.794]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:36.794]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:36.794]                       envir = envir)
[10:26:36.794]                     if (!future$lazy) 
[10:26:36.794]                       future <- run(future)
[10:26:36.794]                     invisible(future)
[10:26:36.794]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:36.794]                 }
[10:26:36.794]             }
[10:26:36.794]         }
[10:26:36.794]     })
[10:26:36.794]     if (TRUE) {
[10:26:36.794]         base::sink(type = "output", split = FALSE)
[10:26:36.794]         if (TRUE) {
[10:26:36.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:36.794]         }
[10:26:36.794]         else {
[10:26:36.794]             ...future.result["stdout"] <- base::list(NULL)
[10:26:36.794]         }
[10:26:36.794]         base::close(...future.stdout)
[10:26:36.794]         ...future.stdout <- NULL
[10:26:36.794]     }
[10:26:36.794]     ...future.result$conditions <- ...future.conditions
[10:26:36.794]     ...future.result$finished <- base::Sys.time()
[10:26:36.794]     ...future.result
[10:26:36.794] }
[10:26:36.796] assign_globals() ...
[10:26:36.796] List of 2
[10:26:36.796]  $ nested   :List of 2
[10:26:36.796]   ..$ a:function (..., envir = parent.frame())  
[10:26:36.796]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:36.796]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.796]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:36.796]     envir = parent.frame())  
[10:26:36.796]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:26:36.796]   .. ..- attr(*, "init")= logi TRUE
[10:26:36.796]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:26:36.796]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:36.796]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:36.796]  $ strategy2: chr "multisession"
[10:26:36.796]  - attr(*, "where")=List of 2
[10:26:36.796]   ..$ nested   :<environment: R_EmptyEnv> 
[10:26:36.796]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:26:36.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:36.796]  - attr(*, "resolved")= logi FALSE
[10:26:36.796]  - attr(*, "total_size")= num 56736
[10:26:36.796]  - attr(*, "already-done")= logi TRUE
[10:26:36.803] - copied ‘nested’ to environment
[10:26:36.803] - copied ‘strategy2’ to environment
[10:26:36.803] assign_globals() ... done
[10:26:36.804] plan(): Setting new future strategy stack:
[10:26:36.804] List of future strategies:
[10:26:36.804] 1. multisession:
[10:26:36.804]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:36.804]    - tweaked: FALSE
[10:26:36.804]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:36.808] plan(): nbrOfWorkers() = 2
[10:26:37.594] plan(): Setting new future strategy stack:
[10:26:37.594] List of future strategies:
[10:26:37.594] 1. sequential:
[10:26:37.594]    - args: function (..., envir = parent.frame())
[10:26:37.594]    - tweaked: FALSE
[10:26:37.594]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.594] 2. multisession:
[10:26:37.594]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:37.594]    - tweaked: FALSE
[10:26:37.594]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.594] plan(): nbrOfWorkers() = 1
[10:26:37.595] SequentialFuture started (and completed)
[10:26:37.595] signalConditions() ...
[10:26:37.595]  - include = ‘immediateCondition’
[10:26:37.595]  - exclude = 
[10:26:37.595]  - resignal = FALSE
[10:26:37.595]  - Number of conditions: 97
[10:26:37.596] signalConditions() ... done
[10:26:37.596] - Launch lazy future ... done
[10:26:37.596] run() for ‘SequentialFuture’ ... done
[10:26:37.596] signalConditions() ...
[10:26:37.596]  - include = ‘immediateCondition’
[10:26:37.596]  - exclude = 
[10:26:37.596]  - resignal = FALSE
[10:26:37.596]  - Number of conditions: 97
[10:26:37.597] signalConditions() ... done
[10:26:37.597] Future state: ‘finished’
[10:26:37.597] signalConditions() ...
[10:26:37.597]  - include = ‘condition’
[10:26:37.597]  - exclude = ‘immediateCondition’
[10:26:37.597]  - resignal = TRUE
[10:26:37.597]  - Number of conditions: 97
[10:26:37.598]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.808] getGlobalsAndPackages() ...
[10:26:37.598]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.809] Searching for globals...
[10:26:37.598]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.827] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:26:37.598]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.828] Searching for globals ... DONE
[10:26:37.598]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.828] Resolving globals: FALSE
[10:26:37.598]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.828] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[10:26:37.599]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.829] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:26:37.599]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.829] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:26:37.599]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.829] 
[10:26:37.599]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.829] getGlobalsAndPackages() ... DONE
[10:26:37.599]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.830] run() for ‘Future’ ...
[10:26:37.599]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.830] - state: ‘created’
[10:26:37.600]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.830] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:37.600]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.836] [local output] makeClusterPSOCK() ...
[10:26:37.600]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.898] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:37.600]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.900] [local output] Base port: 11288
[10:26:37.600]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.900] [local output] Getting setup options for 2 cluster nodes ...
[10:26:37.601]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.900] [local output]  - Node 1 of 2 ...
[10:26:37.601]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.900] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:37.601]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:36.901] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b75e221d7.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b75e221d7.pid")'’
[10:26:37.601]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.091] - Possible to infer worker's PID: TRUE
[10:26:37.601]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.091] [local output] Rscript port: 11288

[10:26:37.601]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.091] [local output]  - Node 2 of 2 ...
[10:26:37.602]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.092] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:37.602]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.092] [local output] Rscript port: 11288

[10:26:37.602]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.093] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:37.602]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.093] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:37.602]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.093] [local output] Setting up PSOCK nodes in parallel
[10:26:37.602]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.094] List of 36
[10:26:37.094]  $ worker          : chr "localhost"
[10:26:37.094]   ..- attr(*, "localhost")= logi TRUE
[10:26:37.094]  $ master          : chr "localhost"
[10:26:37.094]  $ port            : int 11288
[10:26:37.094]  $ connectTimeout  : num 120
[10:26:37.094]  $ timeout         : num 2592000
[10:26:37.094]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:37.094]  $ homogeneous     : logi TRUE
[10:26:37.094]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:37.094]  $ rscript_envs    : NULL
[10:26:37.094]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:37.094]  $ rscript_startup : NULL
[10:26:37.094]  $ rscript_sh      : chr "sh"
[10:26:37.094]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:37.094]  $ methods         : logi TRUE
[10:26:37.094]  $ socketOptions   : chr "no-delay"
[10:26:37.094]  $ useXDR          : logi FALSE
[10:26:37.094]  $ outfile         : chr "/dev/null"
[10:26:37.094]  $ renice          : int NA
[10:26:37.094]  $ rshcmd          : NULL
[10:26:37.094]  $ user            : chr(0) 
[10:26:37.094]  $ revtunnel       : logi FALSE
[10:26:37.094]  $ rshlogfile      : NULL
[10:26:37.094]  $ rshopts         : chr(0) 
[10:26:37.094]  $ rank            : int 1
[10:26:37.094]  $ manual          : logi FALSE
[10:26:37.094]  $ dryrun          : logi FALSE
[10:26:37.094]  $ quiet           : logi FALSE
[10:26:37.094]  $ setup_strategy  : chr "parallel"
[10:26:37.094]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:37.094]  $ pidfile         : chr "/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b75e221d7.pid"
[10:26:37.094]  $ rshcmd_label    : NULL
[10:26:37.094]  $ rsh_call        : NULL
[10:26:37.094]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:37.094]  $ localMachine    : logi TRUE
[10:26:37.094]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:37.094]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:37.094]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:37.094]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:37.094]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:37.094]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:37.094]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:37.094]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:37.094]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:37.094]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:37.094]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:37.094]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:37.094]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:37.094]  $ arguments       :List of 28
[10:26:37.094]   ..$ worker          : chr "localhost"
[10:26:37.094]   ..$ master          : NULL
[10:26:37.094]   ..$ port            : int 11288
[10:26:37.094]   ..$ connectTimeout  : num 120
[10:26:37.094]   ..$ timeout         : num 2592000
[10:26:37.094]   ..$ rscript         : NULL
[10:26:37.094]   ..$ homogeneous     : NULL
[10:26:37.094]   ..$ rscript_args    : NULL
[10:26:37.094]   ..$ rscript_envs    : NULL
[10:26:37.094]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:37.094]   ..$ rscript_startup : NULL
[10:26:37.094]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:37.094]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:37.094]   ..$ methods         : logi TRUE
[10:26:37.094]   ..$ socketOptions   : chr "no-delay"
[10:26:37.094]   ..$ useXDR          : logi FALSE
[10:26:37.094]   ..$ outfile         : chr "/dev/null"
[10:26:37.094]   ..$ renice          : int NA
[10:26:37.094]   ..$ rshcmd          : NULL
[10:26:37.094]   ..$ user            : NULL
[10:26:37.094]   ..$ revtunnel       : logi NA
[10:26:37.094]   ..$ rshlogfile      : NULL
[10:26:37.094]   ..$ rshopts         : NULL
[10:26:37.094]   ..$ rank            : int 1
[10:26:37.094]   ..$ manual          : logi FALSE
[10:26:37.094]   ..$ dryrun          : logi FALSE
[10:26:37.094]   ..$ quiet           : logi FALSE
[10:26:37.094]   ..$ setup_strategy  : chr "parallel"
[10:26:37.094]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:37.603]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.110] [local output] System call to launch all workers:
[10:26:37.603]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.111] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b75e221d7.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11288 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:37.603]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.111] [local output] Starting PSOCK main server
[10:26:37.603]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.116] [local output] Workers launched
[10:26:37.603]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.116] [local output] Waiting for workers to connect back
[10:26:37.603]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.117]  - [local output] 0 workers out of 2 ready
[10:26:37.604]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.383]  - [local output] 0 workers out of 2 ready
[10:26:37.604]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.384]  - [local output] 1 workers out of 2 ready
[10:26:37.604]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.384]  - [local output] 2 workers out of 2 ready
[10:26:37.604]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.385] [local output] Launching of workers completed
[10:26:37.604]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.385] [local output] Collecting session information from workers
[10:26:37.604]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.386] [local output]  - Worker #1 of 2
[10:26:37.605]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.386] [local output]  - Worker #2 of 2
[10:26:37.605]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.386] [local output] makeClusterPSOCK() ... done
[10:26:37.605]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:37.605]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:37.605]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘node’
[10:26:37.606]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘label’
[10:26:37.606]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘local’
[10:26:37.606]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘owner’
[10:26:37.606]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘envir’
[10:26:37.606]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘workers’
[10:26:37.606]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘packages’
[10:26:37.607]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.398]   - Field: ‘gc’
[10:26:37.607]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘conditions’
[10:26:37.607]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘persistent’
[10:26:37.607]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘expr’
[10:26:37.607]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘uuid’
[10:26:37.607]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘seed’
[10:26:37.608]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘version’
[10:26:37.608]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘result’
[10:26:37.608]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.399]   - Field: ‘asynchronous’
[10:26:37.608]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.400]   - Field: ‘calls’
[10:26:37.608]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.400]   - Field: ‘globals’
[10:26:37.608]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.400]   - Field: ‘stdout’
[10:26:37.609]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.400]   - Field: ‘earlySignal’
[10:26:37.609]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.400]   - Field: ‘lazy’
[10:26:37.609]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.400]   - Field: ‘state’
[10:26:37.609]  - Condition #68: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:37.609]  - Condition #69: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.401] - Launch lazy future ...
[10:26:37.609]  - Condition #70: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.401] Packages needed by the future expression (n = 0): <none>
[10:26:37.610]  - Condition #71: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.402] Packages needed by future strategies (n = 0): <none>
[10:26:37.610]  - Condition #72: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.402] {
[10:26:37.402]     {
[10:26:37.402]         {
[10:26:37.402]             ...future.startTime <- base::Sys.time()
[10:26:37.402]             {
[10:26:37.402]                 {
[10:26:37.402]                   {
[10:26:37.402]                     {
[10:26:37.402]                       base::local({
[10:26:37.402]                         has_future <- base::requireNamespace("future", 
[10:26:37.402]                           quietly = TRUE)
[10:26:37.402]                         if (has_future) {
[10:26:37.402]                           ns <- base::getNamespace("future")
[10:26:37.402]                           version <- ns[[".package"]][["version"]]
[10:26:37.402]                           if (is.null(version)) 
[10:26:37.402]                             version <- utils::packageVersion("future")
[10:26:37.402]                         }
[10:26:37.402]                         else {
[10:26:37.402]                           version <- NULL
[10:26:37.402]                         }
[10:26:37.402]                         if (!has_future || version < "1.8.0") {
[10:26:37.402]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.402]                             "", base::R.version$version.string), 
[10:26:37.402]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:37.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:37.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.402]                               "release", "version")], collapse = " "), 
[10:26:37.402]                             hostname = base::Sys.info()[["nodename"]])
[10:26:37.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.402]                             info)
[10:26:37.402]                           info <- base::paste(info, collapse = "; ")
[10:26:37.402]                           if (!has_future) {
[10:26:37.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.402]                               info)
[10:26:37.402]                           }
[10:26:37.402]                           else {
[10:26:37.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.402]                               info, version)
[10:26:37.402]                           }
[10:26:37.402]                           base::stop(msg)
[10:26:37.402]                         }
[10:26:37.402]                       })
[10:26:37.402]                     }
[10:26:37.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:37.402]                     base::options(mc.cores = 1L)
[10:26:37.402]                   }
[10:26:37.402]                   options(future.plan = NULL)
[10:26:37.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:37.402]                 }
[10:26:37.402]                 ...future.workdir <- getwd()
[10:26:37.402]             }
[10:26:37.402]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.402]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.402]         }
[10:26:37.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.402]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.402]             base::names(...future.oldOptions))
[10:26:37.402]     }
[10:26:37.402]     if (FALSE) {
[10:26:37.402]     }
[10:26:37.402]     else {
[10:26:37.402]         if (TRUE) {
[10:26:37.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.402]                 open = "w")
[10:26:37.402]         }
[10:26:37.402]         else {
[10:26:37.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.402]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.402]         }
[10:26:37.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.402]             base::sink(type = "output", split = FALSE)
[10:26:37.402]             base::close(...future.stdout)
[10:26:37.402]         }, add = TRUE)
[10:26:37.402]     }
[10:26:37.402]     ...future.frame <- base::sys.nframe()
[10:26:37.402]     ...future.conditions <- base::list()
[10:26:37.402]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.402]     if (FALSE) {
[10:26:37.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.402]     }
[10:26:37.402]     ...future.result <- base::tryCatch({
[10:26:37.402]         base::withCallingHandlers({
[10:26:37.402]             ...future.value <- base::withVisible(base::local({
[10:26:37.402]                 ...future.makeSendCondition <- base::local({
[10:26:37.402]                   sendCondition <- NULL
[10:26:37.402]                   function(frame = 1L) {
[10:26:37.402]                     if (is.function(sendCondition)) 
[10:26:37.402]                       return(sendCondition)
[10:26:37.402]                     ns <- getNamespace("parallel")
[10:26:37.402]                     if (exists("sendData", mode = "function", 
[10:26:37.402]                       envir = ns)) {
[10:26:37.402]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:37.402]                         envir = ns)
[10:26:37.402]                       envir <- sys.frame(frame)
[10:26:37.402]                       master <- NULL
[10:26:37.402]                       while (!identical(envir, .GlobalEnv) && 
[10:26:37.402]                         !identical(envir, emptyenv())) {
[10:26:37.402]                         if (exists("master", mode = "list", envir = envir, 
[10:26:37.402]                           inherits = FALSE)) {
[10:26:37.402]                           master <- get("master", mode = "list", 
[10:26:37.402]                             envir = envir, inherits = FALSE)
[10:26:37.402]                           if (inherits(master, c("SOCKnode", 
[10:26:37.402]                             "SOCK0node"))) {
[10:26:37.402]                             sendCondition <<- function(cond) {
[10:26:37.402]                               data <- list(type = "VALUE", value = cond, 
[10:26:37.402]                                 success = TRUE)
[10:26:37.402]                               parallel_sendData(master, data)
[10:26:37.402]                             }
[10:26:37.402]                             return(sendCondition)
[10:26:37.402]                           }
[10:26:37.402]                         }
[10:26:37.402]                         frame <- frame + 1L
[10:26:37.402]                         envir <- sys.frame(frame)
[10:26:37.402]                       }
[10:26:37.402]                     }
[10:26:37.402]                     sendCondition <<- function(cond) NULL
[10:26:37.402]                   }
[10:26:37.402]                 })
[10:26:37.402]                 withCallingHandlers({
[10:26:37.402]                   {
[10:26:37.402]                     b <- 2L
[10:26:37.402]                     plan_b <- future::plan("list")
[10:26:37.402]                     nested_b <- nested_a[-1]
[10:26:37.402]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:37.402]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:37.402]                       "sequential"))
[10:26:37.402]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:37.402]                       b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:37.402]                   }
[10:26:37.402]                 }, immediateCondition = function(cond) {
[10:26:37.402]                   sendCondition <- ...future.makeSendCondition()
[10:26:37.402]                   sendCondition(cond)
[10:26:37.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.402]                   {
[10:26:37.402]                     inherits <- base::inherits
[10:26:37.402]                     invokeRestart <- base::invokeRestart
[10:26:37.402]                     is.null <- base::is.null
[10:26:37.402]                     muffled <- FALSE
[10:26:37.402]                     if (inherits(cond, "message")) {
[10:26:37.402]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:37.402]                       if (muffled) 
[10:26:37.402]                         invokeRestart("muffleMessage")
[10:26:37.402]                     }
[10:26:37.402]                     else if (inherits(cond, "warning")) {
[10:26:37.402]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:37.402]                       if (muffled) 
[10:26:37.402]                         invokeRestart("muffleWarning")
[10:26:37.402]                     }
[10:26:37.402]                     else if (inherits(cond, "condition")) {
[10:26:37.402]                       if (!is.null(pattern)) {
[10:26:37.402]                         computeRestarts <- base::computeRestarts
[10:26:37.402]                         grepl <- base::grepl
[10:26:37.402]                         restarts <- computeRestarts(cond)
[10:26:37.402]                         for (restart in restarts) {
[10:26:37.402]                           name <- restart$name
[10:26:37.402]                           if (is.null(name)) 
[10:26:37.402]                             next
[10:26:37.402]                           if (!grepl(pattern, name)) 
[10:26:37.402]                             next
[10:26:37.402]                           invokeRestart(restart)
[10:26:37.402]                           muffled <- TRUE
[10:26:37.402]                           break
[10:26:37.402]                         }
[10:26:37.402]                       }
[10:26:37.402]                     }
[10:26:37.402]                     invisible(muffled)
[10:26:37.402]                   }
[10:26:37.402]                   muffleCondition(cond)
[10:26:37.402]                 })
[10:26:37.402]             }))
[10:26:37.402]             future::FutureResult(value = ...future.value$value, 
[10:26:37.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.402]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.402]                     ...future.globalenv.names))
[10:26:37.402]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.402]         }, condition = base::local({
[10:26:37.402]             c <- base::c
[10:26:37.402]             inherits <- base::inherits
[10:26:37.402]             invokeRestart <- base::invokeRestart
[10:26:37.402]             length <- base::length
[10:26:37.402]             list <- base::list
[10:26:37.402]             seq.int <- base::seq.int
[10:26:37.402]             signalCondition <- base::signalCondition
[10:26:37.402]             sys.calls <- base::sys.calls
[10:26:37.402]             `[[` <- base::`[[`
[10:26:37.402]             `+` <- base::`+`
[10:26:37.402]             `<<-` <- base::`<<-`
[10:26:37.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.402]                   3L)]
[10:26:37.402]             }
[10:26:37.402]             function(cond) {
[10:26:37.402]                 is_error <- inherits(cond, "error")
[10:26:37.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.402]                   NULL)
[10:26:37.402]                 if (is_error) {
[10:26:37.402]                   sessionInformation <- function() {
[10:26:37.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.402]                       search = base::search(), system = base::Sys.info())
[10:26:37.402]                   }
[10:26:37.402]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.402]                     cond$call), session = sessionInformation(), 
[10:26:37.402]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.402]                   signalCondition(cond)
[10:26:37.402]                 }
[10:26:37.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.402]                 "immediateCondition"))) {
[10:26:37.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.402]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.402]                   if (TRUE && !signal) {
[10:26:37.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.402]                     {
[10:26:37.402]                       inherits <- base::inherits
[10:26:37.402]                       invokeRestart <- base::invokeRestart
[10:26:37.402]                       is.null <- base::is.null
[10:26:37.402]                       muffled <- FALSE
[10:26:37.402]                       if (inherits(cond, "message")) {
[10:26:37.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.402]                         if (muffled) 
[10:26:37.402]                           invokeRestart("muffleMessage")
[10:26:37.402]                       }
[10:26:37.402]                       else if (inherits(cond, "warning")) {
[10:26:37.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.402]                         if (muffled) 
[10:26:37.402]                           invokeRestart("muffleWarning")
[10:26:37.402]                       }
[10:26:37.402]                       else if (inherits(cond, "condition")) {
[10:26:37.402]                         if (!is.null(pattern)) {
[10:26:37.402]                           computeRestarts <- base::computeRestarts
[10:26:37.402]                           grepl <- base::grepl
[10:26:37.402]                           restarts <- computeRestarts(cond)
[10:26:37.402]                           for (restart in restarts) {
[10:26:37.402]                             name <- restart$name
[10:26:37.402]                             if (is.null(name)) 
[10:26:37.402]                               next
[10:26:37.402]                             if (!grepl(pattern, name)) 
[10:26:37.402]                               next
[10:26:37.402]                             invokeRestart(restart)
[10:26:37.402]                             muffled <- TRUE
[10:26:37.402]                             break
[10:26:37.402]                           }
[10:26:37.402]                         }
[10:26:37.402]                       }
[10:26:37.402]                       invisible(muffled)
[10:26:37.402]                     }
[10:26:37.402]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.402]                   }
[10:26:37.402]                 }
[10:26:37.402]                 else {
[10:26:37.402]                   if (TRUE) {
[10:26:37.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.402]                     {
[10:26:37.402]                       inherits <- base::inherits
[10:26:37.402]                       invokeRestart <- base::invokeRestart
[10:26:37.402]                       is.null <- base::is.null
[10:26:37.402]                       muffled <- FALSE
[10:26:37.402]                       if (inherits(cond, "message")) {
[10:26:37.402]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.402]                         if (muffled) 
[10:26:37.402]                           invokeRestart("muffleMessage")
[10:26:37.402]                       }
[10:26:37.402]                       else if (inherits(cond, "warning")) {
[10:26:37.402]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.402]                         if (muffled) 
[10:26:37.402]                           invokeRestart("muffleWarning")
[10:26:37.402]                       }
[10:26:37.402]                       else if (inherits(cond, "condition")) {
[10:26:37.402]                         if (!is.null(pattern)) {
[10:26:37.402]                           computeRestarts <- base::computeRestarts
[10:26:37.402]                           grepl <- base::grepl
[10:26:37.402]                           restarts <- computeRestarts(cond)
[10:26:37.402]                           for (restart in restarts) {
[10:26:37.402]                             name <- restart$name
[10:26:37.402]                             if (is.null(name)) 
[10:26:37.402]                               next
[10:26:37.402]                             if (!grepl(pattern, name)) 
[10:26:37.402]                               next
[10:26:37.402]                             invokeRestart(restart)
[10:26:37.402]                             muffled <- TRUE
[10:26:37.402]                             break
[10:26:37.402]                           }
[10:26:37.402]                         }
[10:26:37.402]                       }
[10:26:37.402]                       invisible(muffled)
[10:26:37.402]                     }
[10:26:37.402]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.402]                   }
[10:26:37.402]                 }
[10:26:37.402]             }
[10:26:37.402]         }))
[10:26:37.402]     }, error = function(ex) {
[10:26:37.402]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.402]                 ...future.rng), started = ...future.startTime, 
[10:26:37.402]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.402]             version = "1.8"), class = "FutureResult")
[10:26:37.402]     }, finally = {
[10:26:37.402]         if (!identical(...future.workdir, getwd())) 
[10:26:37.402]             setwd(...future.workdir)
[10:26:37.402]         {
[10:26:37.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.402]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.402]             }
[10:26:37.402]             base::options(...future.oldOptions)
[10:26:37.402]             if (.Platform$OS.type == "windows") {
[10:26:37.402]                 old_names <- names(...future.oldEnvVars)
[10:26:37.402]                 envs <- base::Sys.getenv()
[10:26:37.402]                 names <- names(envs)
[10:26:37.402]                 common <- intersect(names, old_names)
[10:26:37.402]                 added <- setdiff(names, old_names)
[10:26:37.402]                 removed <- setdiff(old_names, names)
[10:26:37.402]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.402]                   envs[common]]
[10:26:37.402]                 NAMES <- toupper(changed)
[10:26:37.402]                 args <- list()
[10:26:37.402]                 for (kk in seq_along(NAMES)) {
[10:26:37.402]                   name <- changed[[kk]]
[10:26:37.402]                   NAME <- NAMES[[kk]]
[10:26:37.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.402]                     next
[10:26:37.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.402]                 }
[10:26:37.402]                 NAMES <- toupper(added)
[10:26:37.402]                 for (kk in seq_along(NAMES)) {
[10:26:37.402]                   name <- added[[kk]]
[10:26:37.402]                   NAME <- NAMES[[kk]]
[10:26:37.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.402]                     next
[10:26:37.402]                   args[[name]] <- ""
[10:26:37.402]                 }
[10:26:37.402]                 NAMES <- toupper(removed)
[10:26:37.402]                 for (kk in seq_along(NAMES)) {
[10:26:37.402]                   name <- removed[[kk]]
[10:26:37.402]                   NAME <- NAMES[[kk]]
[10:26:37.402]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.402]                     next
[10:26:37.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.402]                 }
[10:26:37.402]                 if (length(args) > 0) 
[10:26:37.402]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.402]             }
[10:26:37.402]             else {
[10:26:37.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.402]             }
[10:26:37.402]             {
[10:26:37.402]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.402]                   0L) {
[10:26:37.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.402]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.402]                   base::options(opts)
[10:26:37.402]                 }
[10:26:37.402]                 {
[10:26:37.402]                   {
[10:26:37.402]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:37.402]                     NULL
[10:26:37.402]                   }
[10:26:37.402]                   options(future.plan = NULL)
[10:26:37.402]                   if (is.na(NA_character_)) 
[10:26:37.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.402]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:37.402]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:37.402]                     envir = parent.frame()) 
[10:26:37.402]                   {
[10:26:37.402]                     if (is.function(workers)) 
[10:26:37.402]                       workers <- workers()
[10:26:37.402]                     workers <- structure(as.integer(workers), 
[10:26:37.402]                       class = class(workers))
[10:26:37.402]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:37.402]                       workers >= 1)
[10:26:37.402]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:37.402]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:37.402]                     }
[10:26:37.402]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:37.402]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:37.402]                       envir = envir)
[10:26:37.402]                     if (!future$lazy) 
[10:26:37.402]                       future <- run(future)
[10:26:37.402]                     invisible(future)
[10:26:37.402]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.402]                 }
[10:26:37.402]             }
[10:26:37.402]         }
[10:26:37.402]     })
[10:26:37.402]     if (TRUE) {
[10:26:37.402]         base::sink(type = "output", split = FALSE)
[10:26:37.402]         if (TRUE) {
[10:26:37.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.402]         }
[10:26:37.402]         else {
[10:26:37.402]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.402]         }
[10:26:37.402]         base::close(...future.stdout)
[10:26:37.402]         ...future.stdout <- NULL
[10:26:37.402]     }
[10:26:37.402]     ...future.result$conditions <- ...future.conditions
[10:26:37.402]     ...future.result$finished <- base::Sys.time()
[10:26:37.402]     ...future.result
[10:26:37.402] }
[10:26:37.610]  - Condition #73: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.457] Exporting 3 global objects (87.82 KiB) to cluster node #1 ...
[10:26:37.610]  - Condition #74: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.458] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ...
[10:26:37.610]  - Condition #75: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.458] Exporting ‘nested_a’ (43.88 KiB) to cluster node #1 ... DONE
[10:26:37.610]  - Condition #76: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.459] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[10:26:37.611]  - Condition #77: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.459] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[10:26:37.611]  - Condition #78: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.459] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ...
[10:26:37.611]  - Condition #79: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.502] Exporting ‘plan_a’ (43.88 KiB) to cluster node #1 ... DONE
[10:26:37.611]  - Condition #80: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.502] Exporting 3 global objects (87.82 KiB) to cluster node #1 ... DONE
[10:26:37.611]  - Condition #81: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.503] MultisessionFuture started
[10:26:37.611]  - Condition #82: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.503] - Launch lazy future ... done
[10:26:37.612]  - Condition #83: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.503] run() for ‘MultisessionFuture’ ... done
[10:26:37.612]  - Condition #84: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.503] result() for ClusterFuture ...
[10:26:37.612]  - Condition #85: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.504] receiveMessageFromWorker() for ClusterFuture ...
[10:26:37.612]  - Condition #86: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.504] - Validating connection of MultisessionFuture
[10:26:37.612]  - Condition #87: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.591] - received message: FutureResult
[10:26:37.612]  - Condition #88: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.592] - Received FutureResult
[10:26:37.613]  - Condition #89: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.592] - Erased future from FutureRegistry
[10:26:37.613]  - Condition #90: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.592] result() for ClusterFuture ...
[10:26:37.613]  - Condition #91: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.592] - result already collected: FutureResult
[10:26:37.613]  - Condition #92: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.592] result() for ClusterFuture ... done
[10:26:37.613]  - Condition #93: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.592] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:37.613]  - Condition #94: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.593] result() for ClusterFuture ... done
[10:26:37.614]  - Condition #95: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.593] result() for ClusterFuture ...
[10:26:37.614]  - Condition #96: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.593] - result already collected: FutureResult
[10:26:37.614]  - Condition #97: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.593] result() for ClusterFuture ... done
[10:26:37.614] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:37.621] getGlobalsAndPackages() ...
[10:26:37.621] Searching for globals...
[10:26:37.623] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:37.623] Searching for globals ... DONE
[10:26:37.623] Resolving globals: FALSE
[10:26:37.624] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:37.624] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:37.625] - globals: [1] ‘data’
[10:26:37.625] - packages: [1] ‘future’
[10:26:37.625] getGlobalsAndPackages() ... DONE
[10:26:37.625] run() for ‘Future’ ...
[10:26:37.625] - state: ‘created’
[10:26:37.625] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:37.626] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:37.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:37.626]   - Field: ‘label’
[10:26:37.626]   - Field: ‘local’
[10:26:37.626]   - Field: ‘owner’
[10:26:37.626]   - Field: ‘envir’
[10:26:37.627]   - Field: ‘packages’
[10:26:37.627]   - Field: ‘gc’
[10:26:37.627]   - Field: ‘conditions’
[10:26:37.627]   - Field: ‘expr’
[10:26:37.627]   - Field: ‘uuid’
[10:26:37.627]   - Field: ‘seed’
[10:26:37.627]   - Field: ‘version’
[10:26:37.627]   - Field: ‘result’
[10:26:37.627]   - Field: ‘asynchronous’
[10:26:37.628]   - Field: ‘calls’
[10:26:37.628]   - Field: ‘globals’
[10:26:37.628]   - Field: ‘stdout’
[10:26:37.628]   - Field: ‘earlySignal’
[10:26:37.628]   - Field: ‘lazy’
[10:26:37.628]   - Field: ‘state’
[10:26:37.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:37.628] - Launch lazy future ...
[10:26:37.629] Packages needed by the future expression (n = 1): ‘future’
[10:26:37.629] Packages needed by future strategies (n = 1): ‘future’
[10:26:37.630] {
[10:26:37.630]     {
[10:26:37.630]         {
[10:26:37.630]             ...future.startTime <- base::Sys.time()
[10:26:37.630]             {
[10:26:37.630]                 {
[10:26:37.630]                   {
[10:26:37.630]                     {
[10:26:37.630]                       base::local({
[10:26:37.630]                         has_future <- base::requireNamespace("future", 
[10:26:37.630]                           quietly = TRUE)
[10:26:37.630]                         if (has_future) {
[10:26:37.630]                           ns <- base::getNamespace("future")
[10:26:37.630]                           version <- ns[[".package"]][["version"]]
[10:26:37.630]                           if (is.null(version)) 
[10:26:37.630]                             version <- utils::packageVersion("future")
[10:26:37.630]                         }
[10:26:37.630]                         else {
[10:26:37.630]                           version <- NULL
[10:26:37.630]                         }
[10:26:37.630]                         if (!has_future || version < "1.8.0") {
[10:26:37.630]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.630]                             "", base::R.version$version.string), 
[10:26:37.630]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:37.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:37.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.630]                               "release", "version")], collapse = " "), 
[10:26:37.630]                             hostname = base::Sys.info()[["nodename"]])
[10:26:37.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.630]                             info)
[10:26:37.630]                           info <- base::paste(info, collapse = "; ")
[10:26:37.630]                           if (!has_future) {
[10:26:37.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.630]                               info)
[10:26:37.630]                           }
[10:26:37.630]                           else {
[10:26:37.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.630]                               info, version)
[10:26:37.630]                           }
[10:26:37.630]                           base::stop(msg)
[10:26:37.630]                         }
[10:26:37.630]                       })
[10:26:37.630]                     }
[10:26:37.630]                     base::local({
[10:26:37.630]                       for (pkg in "future") {
[10:26:37.630]                         base::loadNamespace(pkg)
[10:26:37.630]                         base::library(pkg, character.only = TRUE)
[10:26:37.630]                       }
[10:26:37.630]                     })
[10:26:37.630]                   }
[10:26:37.630]                   options(future.plan = NULL)
[10:26:37.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.630]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:37.630]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:37.630]                     envir = parent.frame()) 
[10:26:37.630]                   {
[10:26:37.630]                     if (is.function(workers)) 
[10:26:37.630]                       workers <- workers()
[10:26:37.630]                     workers <- structure(as.integer(workers), 
[10:26:37.630]                       class = class(workers))
[10:26:37.630]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:37.630]                       workers >= 1)
[10:26:37.630]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:37.630]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:37.630]                     }
[10:26:37.630]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:37.630]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:37.630]                       envir = envir)
[10:26:37.630]                     if (!future$lazy) 
[10:26:37.630]                       future <- run(future)
[10:26:37.630]                     invisible(future)
[10:26:37.630]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.630]                 }
[10:26:37.630]                 ...future.workdir <- getwd()
[10:26:37.630]             }
[10:26:37.630]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.630]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.630]         }
[10:26:37.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.630]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.630]             base::names(...future.oldOptions))
[10:26:37.630]     }
[10:26:37.630]     if (FALSE) {
[10:26:37.630]     }
[10:26:37.630]     else {
[10:26:37.630]         if (TRUE) {
[10:26:37.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.630]                 open = "w")
[10:26:37.630]         }
[10:26:37.630]         else {
[10:26:37.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.630]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.630]         }
[10:26:37.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.630]             base::sink(type = "output", split = FALSE)
[10:26:37.630]             base::close(...future.stdout)
[10:26:37.630]         }, add = TRUE)
[10:26:37.630]     }
[10:26:37.630]     ...future.frame <- base::sys.nframe()
[10:26:37.630]     ...future.conditions <- base::list()
[10:26:37.630]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.630]     if (FALSE) {
[10:26:37.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.630]     }
[10:26:37.630]     ...future.result <- base::tryCatch({
[10:26:37.630]         base::withCallingHandlers({
[10:26:37.630]             ...future.value <- base::withVisible(base::local({
[10:26:37.630]                 value(future(subset(data, a == 2)))
[10:26:37.630]             }))
[10:26:37.630]             future::FutureResult(value = ...future.value$value, 
[10:26:37.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.630]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.630]                     ...future.globalenv.names))
[10:26:37.630]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.630]         }, condition = base::local({
[10:26:37.630]             c <- base::c
[10:26:37.630]             inherits <- base::inherits
[10:26:37.630]             invokeRestart <- base::invokeRestart
[10:26:37.630]             length <- base::length
[10:26:37.630]             list <- base::list
[10:26:37.630]             seq.int <- base::seq.int
[10:26:37.630]             signalCondition <- base::signalCondition
[10:26:37.630]             sys.calls <- base::sys.calls
[10:26:37.630]             `[[` <- base::`[[`
[10:26:37.630]             `+` <- base::`+`
[10:26:37.630]             `<<-` <- base::`<<-`
[10:26:37.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.630]                   3L)]
[10:26:37.630]             }
[10:26:37.630]             function(cond) {
[10:26:37.630]                 is_error <- inherits(cond, "error")
[10:26:37.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.630]                   NULL)
[10:26:37.630]                 if (is_error) {
[10:26:37.630]                   sessionInformation <- function() {
[10:26:37.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.630]                       search = base::search(), system = base::Sys.info())
[10:26:37.630]                   }
[10:26:37.630]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.630]                     cond$call), session = sessionInformation(), 
[10:26:37.630]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.630]                   signalCondition(cond)
[10:26:37.630]                 }
[10:26:37.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.630]                 "immediateCondition"))) {
[10:26:37.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.630]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.630]                   if (TRUE && !signal) {
[10:26:37.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.630]                     {
[10:26:37.630]                       inherits <- base::inherits
[10:26:37.630]                       invokeRestart <- base::invokeRestart
[10:26:37.630]                       is.null <- base::is.null
[10:26:37.630]                       muffled <- FALSE
[10:26:37.630]                       if (inherits(cond, "message")) {
[10:26:37.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.630]                         if (muffled) 
[10:26:37.630]                           invokeRestart("muffleMessage")
[10:26:37.630]                       }
[10:26:37.630]                       else if (inherits(cond, "warning")) {
[10:26:37.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.630]                         if (muffled) 
[10:26:37.630]                           invokeRestart("muffleWarning")
[10:26:37.630]                       }
[10:26:37.630]                       else if (inherits(cond, "condition")) {
[10:26:37.630]                         if (!is.null(pattern)) {
[10:26:37.630]                           computeRestarts <- base::computeRestarts
[10:26:37.630]                           grepl <- base::grepl
[10:26:37.630]                           restarts <- computeRestarts(cond)
[10:26:37.630]                           for (restart in restarts) {
[10:26:37.630]                             name <- restart$name
[10:26:37.630]                             if (is.null(name)) 
[10:26:37.630]                               next
[10:26:37.630]                             if (!grepl(pattern, name)) 
[10:26:37.630]                               next
[10:26:37.630]                             invokeRestart(restart)
[10:26:37.630]                             muffled <- TRUE
[10:26:37.630]                             break
[10:26:37.630]                           }
[10:26:37.630]                         }
[10:26:37.630]                       }
[10:26:37.630]                       invisible(muffled)
[10:26:37.630]                     }
[10:26:37.630]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.630]                   }
[10:26:37.630]                 }
[10:26:37.630]                 else {
[10:26:37.630]                   if (TRUE) {
[10:26:37.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.630]                     {
[10:26:37.630]                       inherits <- base::inherits
[10:26:37.630]                       invokeRestart <- base::invokeRestart
[10:26:37.630]                       is.null <- base::is.null
[10:26:37.630]                       muffled <- FALSE
[10:26:37.630]                       if (inherits(cond, "message")) {
[10:26:37.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.630]                         if (muffled) 
[10:26:37.630]                           invokeRestart("muffleMessage")
[10:26:37.630]                       }
[10:26:37.630]                       else if (inherits(cond, "warning")) {
[10:26:37.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.630]                         if (muffled) 
[10:26:37.630]                           invokeRestart("muffleWarning")
[10:26:37.630]                       }
[10:26:37.630]                       else if (inherits(cond, "condition")) {
[10:26:37.630]                         if (!is.null(pattern)) {
[10:26:37.630]                           computeRestarts <- base::computeRestarts
[10:26:37.630]                           grepl <- base::grepl
[10:26:37.630]                           restarts <- computeRestarts(cond)
[10:26:37.630]                           for (restart in restarts) {
[10:26:37.630]                             name <- restart$name
[10:26:37.630]                             if (is.null(name)) 
[10:26:37.630]                               next
[10:26:37.630]                             if (!grepl(pattern, name)) 
[10:26:37.630]                               next
[10:26:37.630]                             invokeRestart(restart)
[10:26:37.630]                             muffled <- TRUE
[10:26:37.630]                             break
[10:26:37.630]                           }
[10:26:37.630]                         }
[10:26:37.630]                       }
[10:26:37.630]                       invisible(muffled)
[10:26:37.630]                     }
[10:26:37.630]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.630]                   }
[10:26:37.630]                 }
[10:26:37.630]             }
[10:26:37.630]         }))
[10:26:37.630]     }, error = function(ex) {
[10:26:37.630]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.630]                 ...future.rng), started = ...future.startTime, 
[10:26:37.630]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.630]             version = "1.8"), class = "FutureResult")
[10:26:37.630]     }, finally = {
[10:26:37.630]         if (!identical(...future.workdir, getwd())) 
[10:26:37.630]             setwd(...future.workdir)
[10:26:37.630]         {
[10:26:37.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.630]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.630]             }
[10:26:37.630]             base::options(...future.oldOptions)
[10:26:37.630]             if (.Platform$OS.type == "windows") {
[10:26:37.630]                 old_names <- names(...future.oldEnvVars)
[10:26:37.630]                 envs <- base::Sys.getenv()
[10:26:37.630]                 names <- names(envs)
[10:26:37.630]                 common <- intersect(names, old_names)
[10:26:37.630]                 added <- setdiff(names, old_names)
[10:26:37.630]                 removed <- setdiff(old_names, names)
[10:26:37.630]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.630]                   envs[common]]
[10:26:37.630]                 NAMES <- toupper(changed)
[10:26:37.630]                 args <- list()
[10:26:37.630]                 for (kk in seq_along(NAMES)) {
[10:26:37.630]                   name <- changed[[kk]]
[10:26:37.630]                   NAME <- NAMES[[kk]]
[10:26:37.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.630]                     next
[10:26:37.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.630]                 }
[10:26:37.630]                 NAMES <- toupper(added)
[10:26:37.630]                 for (kk in seq_along(NAMES)) {
[10:26:37.630]                   name <- added[[kk]]
[10:26:37.630]                   NAME <- NAMES[[kk]]
[10:26:37.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.630]                     next
[10:26:37.630]                   args[[name]] <- ""
[10:26:37.630]                 }
[10:26:37.630]                 NAMES <- toupper(removed)
[10:26:37.630]                 for (kk in seq_along(NAMES)) {
[10:26:37.630]                   name <- removed[[kk]]
[10:26:37.630]                   NAME <- NAMES[[kk]]
[10:26:37.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.630]                     next
[10:26:37.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.630]                 }
[10:26:37.630]                 if (length(args) > 0) 
[10:26:37.630]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.630]             }
[10:26:37.630]             else {
[10:26:37.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.630]             }
[10:26:37.630]             {
[10:26:37.630]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.630]                   0L) {
[10:26:37.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.630]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.630]                   base::options(opts)
[10:26:37.630]                 }
[10:26:37.630]                 {
[10:26:37.630]                   {
[10:26:37.630]                     NULL
[10:26:37.630]                     RNGkind("Mersenne-Twister")
[10:26:37.630]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:37.630]                       inherits = FALSE)
[10:26:37.630]                   }
[10:26:37.630]                   options(future.plan = NULL)
[10:26:37.630]                   if (is.na(NA_character_)) 
[10:26:37.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.630]                   future::plan(list(a = function (..., envir = parent.frame()) 
[10:26:37.630]                   {
[10:26:37.630]                     future <- SequentialFuture(..., envir = envir)
[10:26:37.630]                     if (!future$lazy) 
[10:26:37.630]                       future <- run(future)
[10:26:37.630]                     invisible(future)
[10:26:37.630]                   }, b = function (..., workers = availableCores(), 
[10:26:37.630]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:37.630]                     envir = parent.frame()) 
[10:26:37.630]                   {
[10:26:37.630]                     if (is.function(workers)) 
[10:26:37.630]                       workers <- workers()
[10:26:37.630]                     workers <- structure(as.integer(workers), 
[10:26:37.630]                       class = class(workers))
[10:26:37.630]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:37.630]                       workers >= 1)
[10:26:37.630]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:37.630]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:37.630]                     }
[10:26:37.630]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:37.630]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:37.630]                       envir = envir)
[10:26:37.630]                     if (!future$lazy) 
[10:26:37.630]                       future <- run(future)
[10:26:37.630]                     invisible(future)
[10:26:37.630]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.630]                 }
[10:26:37.630]             }
[10:26:37.630]         }
[10:26:37.630]     })
[10:26:37.630]     if (TRUE) {
[10:26:37.630]         base::sink(type = "output", split = FALSE)
[10:26:37.630]         if (TRUE) {
[10:26:37.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.630]         }
[10:26:37.630]         else {
[10:26:37.630]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.630]         }
[10:26:37.630]         base::close(...future.stdout)
[10:26:37.630]         ...future.stdout <- NULL
[10:26:37.630]     }
[10:26:37.630]     ...future.result$conditions <- ...future.conditions
[10:26:37.630]     ...future.result$finished <- base::Sys.time()
[10:26:37.630]     ...future.result
[10:26:37.630] }
[10:26:37.632] assign_globals() ...
[10:26:37.632] List of 1
[10:26:37.632]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:37.632]   ..$ a: int [1:3] 1 2 3
[10:26:37.632]   ..$ b: int [1:3] 3 2 1
[10:26:37.632]  - attr(*, "where")=List of 1
[10:26:37.632]   ..$ data:<environment: R_EmptyEnv> 
[10:26:37.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:37.632]  - attr(*, "resolved")= logi FALSE
[10:26:37.632]  - attr(*, "total_size")= num 128
[10:26:37.632]  - attr(*, "already-done")= logi TRUE
[10:26:37.638] - copied ‘data’ to environment
[10:26:37.638] assign_globals() ... done
[10:26:37.638] plan(): Setting new future strategy stack:
[10:26:37.638] List of future strategies:
[10:26:37.638] 1. multisession:
[10:26:37.638]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:37.638]    - tweaked: FALSE
[10:26:37.638]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.642] plan(): nbrOfWorkers() = 2
[10:26:37.729] plan(): Setting new future strategy stack:
[10:26:37.729] List of future strategies:
[10:26:37.729] 1. sequential:
[10:26:37.729]    - args: function (..., envir = parent.frame())
[10:26:37.729]    - tweaked: FALSE
[10:26:37.729]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.729] 2. multisession:
[10:26:37.729]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:37.729]    - tweaked: FALSE
[10:26:37.729]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.729] plan(): nbrOfWorkers() = 1
[10:26:37.730] SequentialFuture started (and completed)
[10:26:37.730] signalConditions() ...
[10:26:37.730]  - include = ‘immediateCondition’
[10:26:37.730]  - exclude = 
[10:26:37.730]  - resignal = FALSE
[10:26:37.730]  - Number of conditions: 63
[10:26:37.730] signalConditions() ... done
[10:26:37.730] - Launch lazy future ... done
[10:26:37.730] run() for ‘SequentialFuture’ ... done
[10:26:37.731] signalConditions() ...
[10:26:37.731]  - include = ‘immediateCondition’
[10:26:37.731]  - exclude = 
[10:26:37.731]  - resignal = FALSE
[10:26:37.731]  - Number of conditions: 63
[10:26:37.731] signalConditions() ... done
[10:26:37.731] Future state: ‘finished’
[10:26:37.731] signalConditions() ...
[10:26:37.731]  - include = ‘condition’
[10:26:37.731]  - exclude = ‘immediateCondition’
[10:26:37.732]  - resignal = TRUE
[10:26:37.732]  - Number of conditions: 63
[10:26:37.732]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.643] getGlobalsAndPackages() ...
[10:26:37.732]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.643] Searching for globals...
[10:26:37.732]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.656] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:37.732]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.656] Searching for globals ... DONE
[10:26:37.732]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.656] Resolving globals: FALSE
[10:26:37.732]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.657] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:37.733]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.657] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:37.733]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.658] - globals: [1] ‘data’
[10:26:37.733]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.658] 
[10:26:37.733]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.658] getGlobalsAndPackages() ... DONE
[10:26:37.733]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.658] run() for ‘Future’ ...
[10:26:37.733]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.658] - state: ‘created’
[10:26:37.733]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.658] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:37.734]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.672] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:37.734]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:37.734]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.672]   - Field: ‘node’
[10:26:37.734]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘label’
[10:26:37.734]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘local’
[10:26:37.734]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘owner’
[10:26:37.734]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘envir’
[10:26:37.734]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘workers’
[10:26:37.735]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘packages’
[10:26:37.735]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘gc’
[10:26:37.735]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘conditions’
[10:26:37.735]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.673]   - Field: ‘persistent’
[10:26:37.735]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘expr’
[10:26:37.735]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘uuid’
[10:26:37.735]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘seed’
[10:26:37.736]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘version’
[10:26:37.736]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘result’
[10:26:37.736]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘asynchronous’
[10:26:37.736]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘calls’
[10:26:37.736]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘globals’
[10:26:37.736]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.674]   - Field: ‘stdout’
[10:26:37.736]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.675]   - Field: ‘earlySignal’
[10:26:37.736]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.675]   - Field: ‘lazy’
[10:26:37.737]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.675]   - Field: ‘state’
[10:26:37.737]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.675] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:37.737]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.675] - Launch lazy future ...
[10:26:37.737]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.675] Packages needed by the future expression (n = 0): <none>
[10:26:37.737]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.675] Packages needed by future strategies (n = 0): <none>
[10:26:37.737]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.676] {
[10:26:37.676]     {
[10:26:37.676]         {
[10:26:37.676]             ...future.startTime <- base::Sys.time()
[10:26:37.676]             {
[10:26:37.676]                 {
[10:26:37.676]                   {
[10:26:37.676]                     {
[10:26:37.676]                       base::local({
[10:26:37.676]                         has_future <- base::requireNamespace("future", 
[10:26:37.676]                           quietly = TRUE)
[10:26:37.676]                         if (has_future) {
[10:26:37.676]                           ns <- base::getNamespace("future")
[10:26:37.676]                           version <- ns[[".package"]][["version"]]
[10:26:37.676]                           if (is.null(version)) 
[10:26:37.676]                             version <- utils::packageVersion("future")
[10:26:37.676]                         }
[10:26:37.676]                         else {
[10:26:37.676]                           version <- NULL
[10:26:37.676]                         }
[10:26:37.676]                         if (!has_future || version < "1.8.0") {
[10:26:37.676]                           info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.676]                             "", base::R.version$version.string), 
[10:26:37.676]                             platform = base::sprintf("%s (%s-bit)", 
[10:26:37.676]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:37.676]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.676]                               "release", "version")], collapse = " "), 
[10:26:37.676]                             hostname = base::Sys.info()[["nodename"]])
[10:26:37.676]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.676]                             info)
[10:26:37.676]                           info <- base::paste(info, collapse = "; ")
[10:26:37.676]                           if (!has_future) {
[10:26:37.676]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.676]                               info)
[10:26:37.676]                           }
[10:26:37.676]                           else {
[10:26:37.676]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.676]                               info, version)
[10:26:37.676]                           }
[10:26:37.676]                           base::stop(msg)
[10:26:37.676]                         }
[10:26:37.676]                       })
[10:26:37.676]                     }
[10:26:37.676]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:37.676]                     base::options(mc.cores = 1L)
[10:26:37.676]                   }
[10:26:37.676]                   options(future.plan = NULL)
[10:26:37.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:37.676]                 }
[10:26:37.676]                 ...future.workdir <- getwd()
[10:26:37.676]             }
[10:26:37.676]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.676]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.676]         }
[10:26:37.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.676]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.676]             base::names(...future.oldOptions))
[10:26:37.676]     }
[10:26:37.676]     if (FALSE) {
[10:26:37.676]     }
[10:26:37.676]     else {
[10:26:37.676]         if (TRUE) {
[10:26:37.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.676]                 open = "w")
[10:26:37.676]         }
[10:26:37.676]         else {
[10:26:37.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.676]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.676]         }
[10:26:37.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.676]             base::sink(type = "output", split = FALSE)
[10:26:37.676]             base::close(...future.stdout)
[10:26:37.676]         }, add = TRUE)
[10:26:37.676]     }
[10:26:37.676]     ...future.frame <- base::sys.nframe()
[10:26:37.676]     ...future.conditions <- base::list()
[10:26:37.676]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.676]     if (FALSE) {
[10:26:37.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.676]     }
[10:26:37.676]     ...future.result <- base::tryCatch({
[10:26:37.676]         base::withCallingHandlers({
[10:26:37.676]             ...future.value <- base::withVisible(base::local({
[10:26:37.676]                 ...future.makeSendCondition <- base::local({
[10:26:37.676]                   sendCondition <- NULL
[10:26:37.676]                   function(frame = 1L) {
[10:26:37.676]                     if (is.function(sendCondition)) 
[10:26:37.676]                       return(sendCondition)
[10:26:37.676]                     ns <- getNamespace("parallel")
[10:26:37.676]                     if (exists("sendData", mode = "function", 
[10:26:37.676]                       envir = ns)) {
[10:26:37.676]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:37.676]                         envir = ns)
[10:26:37.676]                       envir <- sys.frame(frame)
[10:26:37.676]                       master <- NULL
[10:26:37.676]                       while (!identical(envir, .GlobalEnv) && 
[10:26:37.676]                         !identical(envir, emptyenv())) {
[10:26:37.676]                         if (exists("master", mode = "list", envir = envir, 
[10:26:37.676]                           inherits = FALSE)) {
[10:26:37.676]                           master <- get("master", mode = "list", 
[10:26:37.676]                             envir = envir, inherits = FALSE)
[10:26:37.676]                           if (inherits(master, c("SOCKnode", 
[10:26:37.676]                             "SOCK0node"))) {
[10:26:37.676]                             sendCondition <<- function(cond) {
[10:26:37.676]                               data <- list(type = "VALUE", value = cond, 
[10:26:37.676]                                 success = TRUE)
[10:26:37.676]                               parallel_sendData(master, data)
[10:26:37.676]                             }
[10:26:37.676]                             return(sendCondition)
[10:26:37.676]                           }
[10:26:37.676]                         }
[10:26:37.676]                         frame <- frame + 1L
[10:26:37.676]                         envir <- sys.frame(frame)
[10:26:37.676]                       }
[10:26:37.676]                     }
[10:26:37.676]                     sendCondition <<- function(cond) NULL
[10:26:37.676]                   }
[10:26:37.676]                 })
[10:26:37.676]                 withCallingHandlers({
[10:26:37.676]                   subset(data, a == 2)
[10:26:37.676]                 }, immediateCondition = function(cond) {
[10:26:37.676]                   sendCondition <- ...future.makeSendCondition()
[10:26:37.676]                   sendCondition(cond)
[10:26:37.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.676]                   {
[10:26:37.676]                     inherits <- base::inherits
[10:26:37.676]                     invokeRestart <- base::invokeRestart
[10:26:37.676]                     is.null <- base::is.null
[10:26:37.676]                     muffled <- FALSE
[10:26:37.676]                     if (inherits(cond, "message")) {
[10:26:37.676]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:37.676]                       if (muffled) 
[10:26:37.676]                         invokeRestart("muffleMessage")
[10:26:37.676]                     }
[10:26:37.676]                     else if (inherits(cond, "warning")) {
[10:26:37.676]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:37.676]                       if (muffled) 
[10:26:37.676]                         invokeRestart("muffleWarning")
[10:26:37.676]                     }
[10:26:37.676]                     else if (inherits(cond, "condition")) {
[10:26:37.676]                       if (!is.null(pattern)) {
[10:26:37.676]                         computeRestarts <- base::computeRestarts
[10:26:37.676]                         grepl <- base::grepl
[10:26:37.676]                         restarts <- computeRestarts(cond)
[10:26:37.676]                         for (restart in restarts) {
[10:26:37.676]                           name <- restart$name
[10:26:37.676]                           if (is.null(name)) 
[10:26:37.676]                             next
[10:26:37.676]                           if (!grepl(pattern, name)) 
[10:26:37.676]                             next
[10:26:37.676]                           invokeRestart(restart)
[10:26:37.676]                           muffled <- TRUE
[10:26:37.676]                           break
[10:26:37.676]                         }
[10:26:37.676]                       }
[10:26:37.676]                     }
[10:26:37.676]                     invisible(muffled)
[10:26:37.676]                   }
[10:26:37.676]                   muffleCondition(cond)
[10:26:37.676]                 })
[10:26:37.676]             }))
[10:26:37.676]             future::FutureResult(value = ...future.value$value, 
[10:26:37.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.676]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.676]                     ...future.globalenv.names))
[10:26:37.676]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.676]         }, condition = base::local({
[10:26:37.676]             c <- base::c
[10:26:37.676]             inherits <- base::inherits
[10:26:37.676]             invokeRestart <- base::invokeRestart
[10:26:37.676]             length <- base::length
[10:26:37.676]             list <- base::list
[10:26:37.676]             seq.int <- base::seq.int
[10:26:37.676]             signalCondition <- base::signalCondition
[10:26:37.676]             sys.calls <- base::sys.calls
[10:26:37.676]             `[[` <- base::`[[`
[10:26:37.676]             `+` <- base::`+`
[10:26:37.676]             `<<-` <- base::`<<-`
[10:26:37.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.676]                   3L)]
[10:26:37.676]             }
[10:26:37.676]             function(cond) {
[10:26:37.676]                 is_error <- inherits(cond, "error")
[10:26:37.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.676]                   NULL)
[10:26:37.676]                 if (is_error) {
[10:26:37.676]                   sessionInformation <- function() {
[10:26:37.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.676]                       search = base::search(), system = base::Sys.info())
[10:26:37.676]                   }
[10:26:37.676]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.676]                     cond$call), session = sessionInformation(), 
[10:26:37.676]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.676]                   signalCondition(cond)
[10:26:37.676]                 }
[10:26:37.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.676]                 "immediateCondition"))) {
[10:26:37.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.676]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.676]                   if (TRUE && !signal) {
[10:26:37.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.676]                     {
[10:26:37.676]                       inherits <- base::inherits
[10:26:37.676]                       invokeRestart <- base::invokeRestart
[10:26:37.676]                       is.null <- base::is.null
[10:26:37.676]                       muffled <- FALSE
[10:26:37.676]                       if (inherits(cond, "message")) {
[10:26:37.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.676]                         if (muffled) 
[10:26:37.676]                           invokeRestart("muffleMessage")
[10:26:37.676]                       }
[10:26:37.676]                       else if (inherits(cond, "warning")) {
[10:26:37.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.676]                         if (muffled) 
[10:26:37.676]                           invokeRestart("muffleWarning")
[10:26:37.676]                       }
[10:26:37.676]                       else if (inherits(cond, "condition")) {
[10:26:37.676]                         if (!is.null(pattern)) {
[10:26:37.676]                           computeRestarts <- base::computeRestarts
[10:26:37.676]                           grepl <- base::grepl
[10:26:37.676]                           restarts <- computeRestarts(cond)
[10:26:37.676]                           for (restart in restarts) {
[10:26:37.676]                             name <- restart$name
[10:26:37.676]                             if (is.null(name)) 
[10:26:37.676]                               next
[10:26:37.676]                             if (!grepl(pattern, name)) 
[10:26:37.676]                               next
[10:26:37.676]                             invokeRestart(restart)
[10:26:37.676]                             muffled <- TRUE
[10:26:37.676]                             break
[10:26:37.676]                           }
[10:26:37.676]                         }
[10:26:37.676]                       }
[10:26:37.676]                       invisible(muffled)
[10:26:37.676]                     }
[10:26:37.676]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.676]                   }
[10:26:37.676]                 }
[10:26:37.676]                 else {
[10:26:37.676]                   if (TRUE) {
[10:26:37.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.676]                     {
[10:26:37.676]                       inherits <- base::inherits
[10:26:37.676]                       invokeRestart <- base::invokeRestart
[10:26:37.676]                       is.null <- base::is.null
[10:26:37.676]                       muffled <- FALSE
[10:26:37.676]                       if (inherits(cond, "message")) {
[10:26:37.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.676]                         if (muffled) 
[10:26:37.676]                           invokeRestart("muffleMessage")
[10:26:37.676]                       }
[10:26:37.676]                       else if (inherits(cond, "warning")) {
[10:26:37.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.676]                         if (muffled) 
[10:26:37.676]                           invokeRestart("muffleWarning")
[10:26:37.676]                       }
[10:26:37.676]                       else if (inherits(cond, "condition")) {
[10:26:37.676]                         if (!is.null(pattern)) {
[10:26:37.676]                           computeRestarts <- base::computeRestarts
[10:26:37.676]                           grepl <- base::grepl
[10:26:37.676]                           restarts <- computeRestarts(cond)
[10:26:37.676]                           for (restart in restarts) {
[10:26:37.676]                             name <- restart$name
[10:26:37.676]                             if (is.null(name)) 
[10:26:37.676]                               next
[10:26:37.676]                             if (!grepl(pattern, name)) 
[10:26:37.676]                               next
[10:26:37.676]                             invokeRestart(restart)
[10:26:37.676]                             muffled <- TRUE
[10:26:37.676]                             break
[10:26:37.676]                           }
[10:26:37.676]                         }
[10:26:37.676]                       }
[10:26:37.676]                       invisible(muffled)
[10:26:37.676]                     }
[10:26:37.676]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.676]                   }
[10:26:37.676]                 }
[10:26:37.676]             }
[10:26:37.676]         }))
[10:26:37.676]     }, error = function(ex) {
[10:26:37.676]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.676]                 ...future.rng), started = ...future.startTime, 
[10:26:37.676]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.676]             version = "1.8"), class = "FutureResult")
[10:26:37.676]     }, finally = {
[10:26:37.676]         if (!identical(...future.workdir, getwd())) 
[10:26:37.676]             setwd(...future.workdir)
[10:26:37.676]         {
[10:26:37.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.676]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.676]             }
[10:26:37.676]             base::options(...future.oldOptions)
[10:26:37.676]             if (.Platform$OS.type == "windows") {
[10:26:37.676]                 old_names <- names(...future.oldEnvVars)
[10:26:37.676]                 envs <- base::Sys.getenv()
[10:26:37.676]                 names <- names(envs)
[10:26:37.676]                 common <- intersect(names, old_names)
[10:26:37.676]                 added <- setdiff(names, old_names)
[10:26:37.676]                 removed <- setdiff(old_names, names)
[10:26:37.676]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.676]                   envs[common]]
[10:26:37.676]                 NAMES <- toupper(changed)
[10:26:37.676]                 args <- list()
[10:26:37.676]                 for (kk in seq_along(NAMES)) {
[10:26:37.676]                   name <- changed[[kk]]
[10:26:37.676]                   NAME <- NAMES[[kk]]
[10:26:37.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.676]                     next
[10:26:37.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.676]                 }
[10:26:37.676]                 NAMES <- toupper(added)
[10:26:37.676]                 for (kk in seq_along(NAMES)) {
[10:26:37.676]                   name <- added[[kk]]
[10:26:37.676]                   NAME <- NAMES[[kk]]
[10:26:37.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.676]                     next
[10:26:37.676]                   args[[name]] <- ""
[10:26:37.676]                 }
[10:26:37.676]                 NAMES <- toupper(removed)
[10:26:37.676]                 for (kk in seq_along(NAMES)) {
[10:26:37.676]                   name <- removed[[kk]]
[10:26:37.676]                   NAME <- NAMES[[kk]]
[10:26:37.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.676]                     next
[10:26:37.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.676]                 }
[10:26:37.676]                 if (length(args) > 0) 
[10:26:37.676]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.676]             }
[10:26:37.676]             else {
[10:26:37.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.676]             }
[10:26:37.676]             {
[10:26:37.676]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.676]                   0L) {
[10:26:37.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.676]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.676]                   base::options(opts)
[10:26:37.676]                 }
[10:26:37.676]                 {
[10:26:37.676]                   {
[10:26:37.676]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:37.676]                     NULL
[10:26:37.676]                   }
[10:26:37.676]                   options(future.plan = NULL)
[10:26:37.676]                   if (is.na(NA_character_)) 
[10:26:37.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.676]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:37.676]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:37.676]                     envir = parent.frame()) 
[10:26:37.676]                   {
[10:26:37.676]                     if (is.function(workers)) 
[10:26:37.676]                       workers <- workers()
[10:26:37.676]                     workers <- structure(as.integer(workers), 
[10:26:37.676]                       class = class(workers))
[10:26:37.676]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:37.676]                       workers >= 1)
[10:26:37.676]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:37.676]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:37.676]                     }
[10:26:37.676]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:37.676]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:37.676]                       envir = envir)
[10:26:37.676]                     if (!future$lazy) 
[10:26:37.676]                       future <- run(future)
[10:26:37.676]                     invisible(future)
[10:26:37.676]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.676]                 }
[10:26:37.676]             }
[10:26:37.676]         }
[10:26:37.676]     })
[10:26:37.676]     if (TRUE) {
[10:26:37.676]         base::sink(type = "output", split = FALSE)
[10:26:37.676]         if (TRUE) {
[10:26:37.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.676]         }
[10:26:37.676]         else {
[10:26:37.676]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.676]         }
[10:26:37.676]         base::close(...future.stdout)
[10:26:37.676]         ...future.stdout <- NULL
[10:26:37.676]     }
[10:26:37.676]     ...future.result$conditions <- ...future.conditions
[10:26:37.676]     ...future.result$finished <- base::Sys.time()
[10:26:37.676]     ...future.result
[10:26:37.676] }
[10:26:37.737]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.679] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:26:37.738]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.679] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:26:37.738]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.679] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:26:37.738]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.679] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:26:37.738]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.680] MultisessionFuture started
[10:26:37.738]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.680] - Launch lazy future ... done
[10:26:37.738]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.680] run() for ‘MultisessionFuture’ ... done
[10:26:37.738]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.680] result() for ClusterFuture ...
[10:26:37.739]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.680] receiveMessageFromWorker() for ClusterFuture ...
[10:26:37.739]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.681] - Validating connection of MultisessionFuture
[10:26:37.739]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.727] - received message: FutureResult
[10:26:37.739]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.727] - Received FutureResult
[10:26:37.739]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.727] - Erased future from FutureRegistry
[10:26:37.739]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.727] result() for ClusterFuture ...
[10:26:37.739]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.727] - result already collected: FutureResult
[10:26:37.739]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.728] result() for ClusterFuture ... done
[10:26:37.740]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.728] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:37.740]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.728] result() for ClusterFuture ... done
[10:26:37.740]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.728] result() for ClusterFuture ...
[10:26:37.740]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.728] - result already collected: FutureResult
[10:26:37.740]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.728] result() for ClusterFuture ... done
[10:26:37.740] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[10:26:37.741] plan(): Setting new future strategy stack:
[10:26:37.741] List of future strategies:
[10:26:37.741] 1. multicore:
[10:26:37.741]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:37.741]    - tweaked: FALSE
[10:26:37.741]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.741] 2. sequential:
[10:26:37.741]    - args: function (..., envir = parent.frame())
[10:26:37.741]    - tweaked: FALSE
[10:26:37.741]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.746] plan(): nbrOfWorkers() = 2
[10:26:37.747] getGlobalsAndPackages() ...
[10:26:37.747] Searching for globals...
[10:26:37.770] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:37.770] Searching for globals ... DONE
[10:26:37.771] Resolving globals: FALSE
[10:26:37.771] The total size of the 2 globals is 57.84 KiB (59224 bytes)
[10:26:37.772] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 57.84 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (57.72 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:37.772] - globals: [2] ‘nested’, ‘strategy2’
[10:26:37.772] - packages: [1] ‘future’
[10:26:37.772] getGlobalsAndPackages() ... DONE
[10:26:37.773] run() for ‘Future’ ...
[10:26:37.773] - state: ‘created’
[10:26:37.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:37.776] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:37.777] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:37.777]   - Field: ‘label’
[10:26:37.777]   - Field: ‘local’
[10:26:37.777]   - Field: ‘owner’
[10:26:37.777]   - Field: ‘envir’
[10:26:37.777]   - Field: ‘workers’
[10:26:37.777]   - Field: ‘packages’
[10:26:37.777]   - Field: ‘gc’
[10:26:37.777]   - Field: ‘job’
[10:26:37.778]   - Field: ‘conditions’
[10:26:37.778]   - Field: ‘expr’
[10:26:37.778]   - Field: ‘uuid’
[10:26:37.778]   - Field: ‘seed’
[10:26:37.778]   - Field: ‘version’
[10:26:37.778]   - Field: ‘result’
[10:26:37.778]   - Field: ‘asynchronous’
[10:26:37.778]   - Field: ‘calls’
[10:26:37.778]   - Field: ‘globals’
[10:26:37.778]   - Field: ‘stdout’
[10:26:37.778]   - Field: ‘earlySignal’
[10:26:37.779]   - Field: ‘lazy’
[10:26:37.779]   - Field: ‘state’
[10:26:37.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:37.779] - Launch lazy future ...
[10:26:37.779] Packages needed by the future expression (n = 1): ‘future’
[10:26:37.779] Packages needed by future strategies (n = 1): ‘future’
[10:26:37.780] {
[10:26:37.780]     {
[10:26:37.780]         {
[10:26:37.780]             ...future.startTime <- base::Sys.time()
[10:26:37.780]             {
[10:26:37.780]                 {
[10:26:37.780]                   {
[10:26:37.780]                     {
[10:26:37.780]                       {
[10:26:37.780]                         base::local({
[10:26:37.780]                           has_future <- base::requireNamespace("future", 
[10:26:37.780]                             quietly = TRUE)
[10:26:37.780]                           if (has_future) {
[10:26:37.780]                             ns <- base::getNamespace("future")
[10:26:37.780]                             version <- ns[[".package"]][["version"]]
[10:26:37.780]                             if (is.null(version)) 
[10:26:37.780]                               version <- utils::packageVersion("future")
[10:26:37.780]                           }
[10:26:37.780]                           else {
[10:26:37.780]                             version <- NULL
[10:26:37.780]                           }
[10:26:37.780]                           if (!has_future || version < "1.8.0") {
[10:26:37.780]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.780]                               "", base::R.version$version.string), 
[10:26:37.780]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:37.780]                                 base::R.version$platform, 8 * 
[10:26:37.780]                                   base::.Machine$sizeof.pointer), 
[10:26:37.780]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.780]                                 "release", "version")], collapse = " "), 
[10:26:37.780]                               hostname = base::Sys.info()[["nodename"]])
[10:26:37.780]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.780]                               info)
[10:26:37.780]                             info <- base::paste(info, collapse = "; ")
[10:26:37.780]                             if (!has_future) {
[10:26:37.780]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.780]                                 info)
[10:26:37.780]                             }
[10:26:37.780]                             else {
[10:26:37.780]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.780]                                 info, version)
[10:26:37.780]                             }
[10:26:37.780]                             base::stop(msg)
[10:26:37.780]                           }
[10:26:37.780]                         })
[10:26:37.780]                       }
[10:26:37.780]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:37.780]                       base::options(mc.cores = 1L)
[10:26:37.780]                     }
[10:26:37.780]                     base::local({
[10:26:37.780]                       for (pkg in "future") {
[10:26:37.780]                         base::loadNamespace(pkg)
[10:26:37.780]                         base::library(pkg, character.only = TRUE)
[10:26:37.780]                       }
[10:26:37.780]                     })
[10:26:37.780]                   }
[10:26:37.780]                   options(future.plan = NULL)
[10:26:37.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.780]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:37.780]                   {
[10:26:37.780]                     future <- SequentialFuture(..., envir = envir)
[10:26:37.780]                     if (!future$lazy) 
[10:26:37.780]                       future <- run(future)
[10:26:37.780]                     invisible(future)
[10:26:37.780]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.780]                 }
[10:26:37.780]                 ...future.workdir <- getwd()
[10:26:37.780]             }
[10:26:37.780]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.780]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.780]         }
[10:26:37.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.780]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.780]             base::names(...future.oldOptions))
[10:26:37.780]     }
[10:26:37.780]     if (FALSE) {
[10:26:37.780]     }
[10:26:37.780]     else {
[10:26:37.780]         if (TRUE) {
[10:26:37.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.780]                 open = "w")
[10:26:37.780]         }
[10:26:37.780]         else {
[10:26:37.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.780]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.780]         }
[10:26:37.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.780]             base::sink(type = "output", split = FALSE)
[10:26:37.780]             base::close(...future.stdout)
[10:26:37.780]         }, add = TRUE)
[10:26:37.780]     }
[10:26:37.780]     ...future.frame <- base::sys.nframe()
[10:26:37.780]     ...future.conditions <- base::list()
[10:26:37.780]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.780]     if (FALSE) {
[10:26:37.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.780]     }
[10:26:37.780]     ...future.result <- base::tryCatch({
[10:26:37.780]         base::withCallingHandlers({
[10:26:37.780]             ...future.value <- base::withVisible(base::local({
[10:26:37.780]                 withCallingHandlers({
[10:26:37.780]                   {
[10:26:37.780]                     a <- 1L
[10:26:37.780]                     plan_a <- unclass(future::plan("list"))
[10:26:37.780]                     nested_a <- nested[-1]
[10:26:37.780]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:37.780]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:37.780]                       strategy2))
[10:26:37.780]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:37.780]                       "init") <- NULL
[10:26:37.780]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:37.780]                       "init") <- NULL
[10:26:37.780]                     stopifnot(all.equal(plan_a, nested_a))
[10:26:37.780]                     y %<-% {
[10:26:37.780]                       b <- 2L
[10:26:37.780]                       plan_b <- future::plan("list")
[10:26:37.780]                       nested_b <- nested_a[-1]
[10:26:37.780]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:37.780]                         1L, inherits(plan_b[[1]], "future"), 
[10:26:37.780]                         inherits(future::plan("next"), "sequential"))
[10:26:37.780]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:37.780]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:37.780]                     }
[10:26:37.780]                     y
[10:26:37.780]                   }
[10:26:37.780]                 }, immediateCondition = function(cond) {
[10:26:37.780]                   save_rds <- function (object, pathname, ...) 
[10:26:37.780]                   {
[10:26:37.780]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:37.780]                     if (file_test("-f", pathname_tmp)) {
[10:26:37.780]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.780]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:37.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.780]                         fi_tmp[["mtime"]])
[10:26:37.780]                     }
[10:26:37.780]                     tryCatch({
[10:26:37.780]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:37.780]                     }, error = function(ex) {
[10:26:37.780]                       msg <- conditionMessage(ex)
[10:26:37.780]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.780]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:37.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.780]                         fi_tmp[["mtime"]], msg)
[10:26:37.780]                       ex$message <- msg
[10:26:37.780]                       stop(ex)
[10:26:37.780]                     })
[10:26:37.780]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:37.780]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:37.780]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:37.780]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.780]                       fi <- file.info(pathname)
[10:26:37.780]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:37.780]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.780]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:37.780]                         fi[["size"]], fi[["mtime"]])
[10:26:37.780]                       stop(msg)
[10:26:37.780]                     }
[10:26:37.780]                     invisible(pathname)
[10:26:37.780]                   }
[10:26:37.780]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:37.780]                     rootPath = tempdir()) 
[10:26:37.780]                   {
[10:26:37.780]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:37.780]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:37.780]                       tmpdir = path, fileext = ".rds")
[10:26:37.780]                     save_rds(obj, file)
[10:26:37.780]                   }
[10:26:37.780]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:37.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.780]                   {
[10:26:37.780]                     inherits <- base::inherits
[10:26:37.780]                     invokeRestart <- base::invokeRestart
[10:26:37.780]                     is.null <- base::is.null
[10:26:37.780]                     muffled <- FALSE
[10:26:37.780]                     if (inherits(cond, "message")) {
[10:26:37.780]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:37.780]                       if (muffled) 
[10:26:37.780]                         invokeRestart("muffleMessage")
[10:26:37.780]                     }
[10:26:37.780]                     else if (inherits(cond, "warning")) {
[10:26:37.780]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:37.780]                       if (muffled) 
[10:26:37.780]                         invokeRestart("muffleWarning")
[10:26:37.780]                     }
[10:26:37.780]                     else if (inherits(cond, "condition")) {
[10:26:37.780]                       if (!is.null(pattern)) {
[10:26:37.780]                         computeRestarts <- base::computeRestarts
[10:26:37.780]                         grepl <- base::grepl
[10:26:37.780]                         restarts <- computeRestarts(cond)
[10:26:37.780]                         for (restart in restarts) {
[10:26:37.780]                           name <- restart$name
[10:26:37.780]                           if (is.null(name)) 
[10:26:37.780]                             next
[10:26:37.780]                           if (!grepl(pattern, name)) 
[10:26:37.780]                             next
[10:26:37.780]                           invokeRestart(restart)
[10:26:37.780]                           muffled <- TRUE
[10:26:37.780]                           break
[10:26:37.780]                         }
[10:26:37.780]                       }
[10:26:37.780]                     }
[10:26:37.780]                     invisible(muffled)
[10:26:37.780]                   }
[10:26:37.780]                   muffleCondition(cond)
[10:26:37.780]                 })
[10:26:37.780]             }))
[10:26:37.780]             future::FutureResult(value = ...future.value$value, 
[10:26:37.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.780]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.780]                     ...future.globalenv.names))
[10:26:37.780]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.780]         }, condition = base::local({
[10:26:37.780]             c <- base::c
[10:26:37.780]             inherits <- base::inherits
[10:26:37.780]             invokeRestart <- base::invokeRestart
[10:26:37.780]             length <- base::length
[10:26:37.780]             list <- base::list
[10:26:37.780]             seq.int <- base::seq.int
[10:26:37.780]             signalCondition <- base::signalCondition
[10:26:37.780]             sys.calls <- base::sys.calls
[10:26:37.780]             `[[` <- base::`[[`
[10:26:37.780]             `+` <- base::`+`
[10:26:37.780]             `<<-` <- base::`<<-`
[10:26:37.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.780]                   3L)]
[10:26:37.780]             }
[10:26:37.780]             function(cond) {
[10:26:37.780]                 is_error <- inherits(cond, "error")
[10:26:37.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.780]                   NULL)
[10:26:37.780]                 if (is_error) {
[10:26:37.780]                   sessionInformation <- function() {
[10:26:37.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.780]                       search = base::search(), system = base::Sys.info())
[10:26:37.780]                   }
[10:26:37.780]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.780]                     cond$call), session = sessionInformation(), 
[10:26:37.780]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.780]                   signalCondition(cond)
[10:26:37.780]                 }
[10:26:37.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.780]                 "immediateCondition"))) {
[10:26:37.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.780]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.780]                   if (TRUE && !signal) {
[10:26:37.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.780]                     {
[10:26:37.780]                       inherits <- base::inherits
[10:26:37.780]                       invokeRestart <- base::invokeRestart
[10:26:37.780]                       is.null <- base::is.null
[10:26:37.780]                       muffled <- FALSE
[10:26:37.780]                       if (inherits(cond, "message")) {
[10:26:37.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.780]                         if (muffled) 
[10:26:37.780]                           invokeRestart("muffleMessage")
[10:26:37.780]                       }
[10:26:37.780]                       else if (inherits(cond, "warning")) {
[10:26:37.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.780]                         if (muffled) 
[10:26:37.780]                           invokeRestart("muffleWarning")
[10:26:37.780]                       }
[10:26:37.780]                       else if (inherits(cond, "condition")) {
[10:26:37.780]                         if (!is.null(pattern)) {
[10:26:37.780]                           computeRestarts <- base::computeRestarts
[10:26:37.780]                           grepl <- base::grepl
[10:26:37.780]                           restarts <- computeRestarts(cond)
[10:26:37.780]                           for (restart in restarts) {
[10:26:37.780]                             name <- restart$name
[10:26:37.780]                             if (is.null(name)) 
[10:26:37.780]                               next
[10:26:37.780]                             if (!grepl(pattern, name)) 
[10:26:37.780]                               next
[10:26:37.780]                             invokeRestart(restart)
[10:26:37.780]                             muffled <- TRUE
[10:26:37.780]                             break
[10:26:37.780]                           }
[10:26:37.780]                         }
[10:26:37.780]                       }
[10:26:37.780]                       invisible(muffled)
[10:26:37.780]                     }
[10:26:37.780]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.780]                   }
[10:26:37.780]                 }
[10:26:37.780]                 else {
[10:26:37.780]                   if (TRUE) {
[10:26:37.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.780]                     {
[10:26:37.780]                       inherits <- base::inherits
[10:26:37.780]                       invokeRestart <- base::invokeRestart
[10:26:37.780]                       is.null <- base::is.null
[10:26:37.780]                       muffled <- FALSE
[10:26:37.780]                       if (inherits(cond, "message")) {
[10:26:37.780]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.780]                         if (muffled) 
[10:26:37.780]                           invokeRestart("muffleMessage")
[10:26:37.780]                       }
[10:26:37.780]                       else if (inherits(cond, "warning")) {
[10:26:37.780]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.780]                         if (muffled) 
[10:26:37.780]                           invokeRestart("muffleWarning")
[10:26:37.780]                       }
[10:26:37.780]                       else if (inherits(cond, "condition")) {
[10:26:37.780]                         if (!is.null(pattern)) {
[10:26:37.780]                           computeRestarts <- base::computeRestarts
[10:26:37.780]                           grepl <- base::grepl
[10:26:37.780]                           restarts <- computeRestarts(cond)
[10:26:37.780]                           for (restart in restarts) {
[10:26:37.780]                             name <- restart$name
[10:26:37.780]                             if (is.null(name)) 
[10:26:37.780]                               next
[10:26:37.780]                             if (!grepl(pattern, name)) 
[10:26:37.780]                               next
[10:26:37.780]                             invokeRestart(restart)
[10:26:37.780]                             muffled <- TRUE
[10:26:37.780]                             break
[10:26:37.780]                           }
[10:26:37.780]                         }
[10:26:37.780]                       }
[10:26:37.780]                       invisible(muffled)
[10:26:37.780]                     }
[10:26:37.780]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.780]                   }
[10:26:37.780]                 }
[10:26:37.780]             }
[10:26:37.780]         }))
[10:26:37.780]     }, error = function(ex) {
[10:26:37.780]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.780]                 ...future.rng), started = ...future.startTime, 
[10:26:37.780]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.780]             version = "1.8"), class = "FutureResult")
[10:26:37.780]     }, finally = {
[10:26:37.780]         if (!identical(...future.workdir, getwd())) 
[10:26:37.780]             setwd(...future.workdir)
[10:26:37.780]         {
[10:26:37.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.780]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.780]             }
[10:26:37.780]             base::options(...future.oldOptions)
[10:26:37.780]             if (.Platform$OS.type == "windows") {
[10:26:37.780]                 old_names <- names(...future.oldEnvVars)
[10:26:37.780]                 envs <- base::Sys.getenv()
[10:26:37.780]                 names <- names(envs)
[10:26:37.780]                 common <- intersect(names, old_names)
[10:26:37.780]                 added <- setdiff(names, old_names)
[10:26:37.780]                 removed <- setdiff(old_names, names)
[10:26:37.780]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.780]                   envs[common]]
[10:26:37.780]                 NAMES <- toupper(changed)
[10:26:37.780]                 args <- list()
[10:26:37.780]                 for (kk in seq_along(NAMES)) {
[10:26:37.780]                   name <- changed[[kk]]
[10:26:37.780]                   NAME <- NAMES[[kk]]
[10:26:37.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.780]                     next
[10:26:37.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.780]                 }
[10:26:37.780]                 NAMES <- toupper(added)
[10:26:37.780]                 for (kk in seq_along(NAMES)) {
[10:26:37.780]                   name <- added[[kk]]
[10:26:37.780]                   NAME <- NAMES[[kk]]
[10:26:37.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.780]                     next
[10:26:37.780]                   args[[name]] <- ""
[10:26:37.780]                 }
[10:26:37.780]                 NAMES <- toupper(removed)
[10:26:37.780]                 for (kk in seq_along(NAMES)) {
[10:26:37.780]                   name <- removed[[kk]]
[10:26:37.780]                   NAME <- NAMES[[kk]]
[10:26:37.780]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.780]                     next
[10:26:37.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.780]                 }
[10:26:37.780]                 if (length(args) > 0) 
[10:26:37.780]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.780]             }
[10:26:37.780]             else {
[10:26:37.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.780]             }
[10:26:37.780]             {
[10:26:37.780]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.780]                   0L) {
[10:26:37.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.780]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.780]                   base::options(opts)
[10:26:37.780]                 }
[10:26:37.780]                 {
[10:26:37.780]                   {
[10:26:37.780]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:37.780]                     NULL
[10:26:37.780]                   }
[10:26:37.780]                   options(future.plan = NULL)
[10:26:37.780]                   if (is.na(NA_character_)) 
[10:26:37.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.780]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:37.780]                     envir = parent.frame()) 
[10:26:37.780]                   {
[10:26:37.780]                     default_workers <- missing(workers)
[10:26:37.780]                     if (is.function(workers)) 
[10:26:37.780]                       workers <- workers()
[10:26:37.780]                     workers <- structure(as.integer(workers), 
[10:26:37.780]                       class = class(workers))
[10:26:37.780]                     stop_if_not(is.finite(workers), workers >= 
[10:26:37.780]                       1L)
[10:26:37.780]                     if ((workers == 1L && !inherits(workers, 
[10:26:37.780]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:37.780]                       if (default_workers) 
[10:26:37.780]                         supportsMulticore(warn = TRUE)
[10:26:37.780]                       return(sequential(..., envir = envir))
[10:26:37.780]                     }
[10:26:37.780]                     oopts <- options(mc.cores = workers)
[10:26:37.780]                     on.exit(options(oopts))
[10:26:37.780]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:37.780]                       envir = envir)
[10:26:37.780]                     if (!future$lazy) 
[10:26:37.780]                       future <- run(future)
[10:26:37.780]                     invisible(future)
[10:26:37.780]                   }, b = function (..., envir = parent.frame()) 
[10:26:37.780]                   {
[10:26:37.780]                     future <- SequentialFuture(..., envir = envir)
[10:26:37.780]                     if (!future$lazy) 
[10:26:37.780]                       future <- run(future)
[10:26:37.780]                     invisible(future)
[10:26:37.780]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.780]                 }
[10:26:37.780]             }
[10:26:37.780]         }
[10:26:37.780]     })
[10:26:37.780]     if (TRUE) {
[10:26:37.780]         base::sink(type = "output", split = FALSE)
[10:26:37.780]         if (TRUE) {
[10:26:37.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.780]         }
[10:26:37.780]         else {
[10:26:37.780]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.780]         }
[10:26:37.780]         base::close(...future.stdout)
[10:26:37.780]         ...future.stdout <- NULL
[10:26:37.780]     }
[10:26:37.780]     ...future.result$conditions <- ...future.conditions
[10:26:37.780]     ...future.result$finished <- base::Sys.time()
[10:26:37.780]     ...future.result
[10:26:37.780] }
[10:26:37.782] assign_globals() ...
[10:26:37.782] List of 2
[10:26:37.782]  $ nested   :List of 2
[10:26:37.782]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:37.782]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:37.782]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:37.782]   ..$ b:function (..., envir = parent.frame())  
[10:26:37.782]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:37.782]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:37.782]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:37.782]  $ strategy2: chr "sequential"
[10:26:37.782]  - attr(*, "where")=List of 2
[10:26:37.782]   ..$ nested   :<environment: R_EmptyEnv> 
[10:26:37.782]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:26:37.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:37.782]  - attr(*, "resolved")= logi FALSE
[10:26:37.782]  - attr(*, "total_size")= num 59224
[10:26:37.782]  - attr(*, "already-done")= logi TRUE
[10:26:37.787] - copied ‘nested’ to environment
[10:26:37.787] - copied ‘strategy2’ to environment
[10:26:37.787] assign_globals() ... done
[10:26:37.787] requestCore(): workers = 2
[10:26:37.790] MulticoreFuture started
[10:26:37.790] - Launch lazy future ... done
[10:26:37.790] run() for ‘MulticoreFuture’ ... done
[10:26:37.791] result() for MulticoreFuture ...
[10:26:37.791] plan(): Setting new future strategy stack:
[10:26:37.792] List of future strategies:
[10:26:37.792] 1. sequential:
[10:26:37.792]    - args: function (..., envir = parent.frame())
[10:26:37.792]    - tweaked: FALSE
[10:26:37.792]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.793] plan(): nbrOfWorkers() = 1
[10:26:37.830] plan(): Setting new future strategy stack:
[10:26:37.830] List of future strategies:
[10:26:37.830] 1. multicore:
[10:26:37.830]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:37.830]    - tweaked: FALSE
[10:26:37.830]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.830] 2. sequential:
[10:26:37.830]    - args: function (..., envir = parent.frame())
[10:26:37.830]    - tweaked: FALSE
[10:26:37.830]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.834] plan(): nbrOfWorkers() = 2
[10:26:37.835] result() for MulticoreFuture ...
[10:26:37.836] result() for MulticoreFuture ... done
[10:26:37.836] signalConditions() ...
[10:26:37.836]  - include = ‘immediateCondition’
[10:26:37.836]  - exclude = 
[10:26:37.836]  - resignal = FALSE
[10:26:37.836]  - Number of conditions: 54
[10:26:37.836] signalConditions() ... done
[10:26:37.837] result() for MulticoreFuture ... done
[10:26:37.837] result() for MulticoreFuture ...
[10:26:37.837] result() for MulticoreFuture ... done
[10:26:37.837] signalConditions() ...
[10:26:37.837]  - include = ‘immediateCondition’
[10:26:37.837]  - exclude = 
[10:26:37.837]  - resignal = FALSE
[10:26:37.837]  - Number of conditions: 54
[10:26:37.838] signalConditions() ... done
[10:26:37.838] Future state: ‘finished’
[10:26:37.838] result() for MulticoreFuture ...
[10:26:37.838] result() for MulticoreFuture ... done
[10:26:37.838] signalConditions() ...
[10:26:37.838]  - include = ‘condition’
[10:26:37.838]  - exclude = ‘immediateCondition’
[10:26:37.838]  - resignal = TRUE
[10:26:37.839]  - Number of conditions: 54
[10:26:37.839]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.795] getGlobalsAndPackages() ...
[10:26:37.839]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.795] Searching for globals...
[10:26:37.839]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.805] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:26:37.839]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.805] Searching for globals ... DONE
[10:26:37.839]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.805] Resolving globals: FALSE
[10:26:37.840]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.807] The total size of the 3 globals is 22.54 KiB (23080 bytes)
[10:26:37.840]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.808] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 22.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (11.24 KiB of class ‘list’), ‘plan_a’ (11.24 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:26:37.840]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.808] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:26:37.840]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.808] 
[10:26:37.840]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.808] getGlobalsAndPackages() ... DONE
[10:26:37.841]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.809] run() for ‘Future’ ...
[10:26:37.841]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.809] - state: ‘created’
[10:26:37.841]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.810] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:37.841]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.810] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:37.841]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:37.842]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.810]   - Field: ‘label’
[10:26:37.842]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.811]   - Field: ‘local’
[10:26:37.842]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.811]   - Field: ‘owner’
[10:26:37.842]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.811]   - Field: ‘envir’
[10:26:37.842]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.811]   - Field: ‘packages’
[10:26:37.842]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.811]   - Field: ‘gc’
[10:26:37.843]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.811]   - Field: ‘conditions’
[10:26:37.843]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.812]   - Field: ‘expr’
[10:26:37.843]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.812]   - Field: ‘uuid’
[10:26:37.843]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.812]   - Field: ‘seed’
[10:26:37.843]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.812]   - Field: ‘version’
[10:26:37.844]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.812]   - Field: ‘result’
[10:26:37.844]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.812]   - Field: ‘asynchronous’
[10:26:37.844]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.813]   - Field: ‘calls’
[10:26:37.844]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.813]   - Field: ‘globals’
[10:26:37.844]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.813]   - Field: ‘stdout’
[10:26:37.845]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.813]   - Field: ‘earlySignal’
[10:26:37.845]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.813]   - Field: ‘lazy’
[10:26:37.845]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.813]   - Field: ‘state’
[10:26:37.845]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.814] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:37.845]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.814] - Launch lazy future ...
[10:26:37.845]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.814] Packages needed by the future expression (n = 0): <none>
[10:26:37.846]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.814] Packages needed by future strategies (n = 0): <none>
[10:26:37.846]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.815] {
[10:26:37.815]     {
[10:26:37.815]         {
[10:26:37.815]             ...future.startTime <- base::Sys.time()
[10:26:37.815]             {
[10:26:37.815]                 {
[10:26:37.815]                   {
[10:26:37.815]                     base::local({
[10:26:37.815]                       has_future <- base::requireNamespace("future", 
[10:26:37.815]                         quietly = TRUE)
[10:26:37.815]                       if (has_future) {
[10:26:37.815]                         ns <- base::getNamespace("future")
[10:26:37.815]                         version <- ns[[".package"]][["version"]]
[10:26:37.815]                         if (is.null(version)) 
[10:26:37.815]                           version <- utils::packageVersion("future")
[10:26:37.815]                       }
[10:26:37.815]                       else {
[10:26:37.815]                         version <- NULL
[10:26:37.815]                       }
[10:26:37.815]                       if (!has_future || version < "1.8.0") {
[10:26:37.815]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.815]                           "", base::R.version$version.string), 
[10:26:37.815]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:37.815]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:37.815]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.815]                             "release", "version")], collapse = " "), 
[10:26:37.815]                           hostname = base::Sys.info()[["nodename"]])
[10:26:37.815]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.815]                           info)
[10:26:37.815]                         info <- base::paste(info, collapse = "; ")
[10:26:37.815]                         if (!has_future) {
[10:26:37.815]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.815]                             info)
[10:26:37.815]                         }
[10:26:37.815]                         else {
[10:26:37.815]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.815]                             info, version)
[10:26:37.815]                         }
[10:26:37.815]                         base::stop(msg)
[10:26:37.815]                       }
[10:26:37.815]                     })
[10:26:37.815]                   }
[10:26:37.815]                   options(future.plan = NULL)
[10:26:37.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:37.815]                 }
[10:26:37.815]                 ...future.workdir <- getwd()
[10:26:37.815]             }
[10:26:37.815]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.815]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.815]         }
[10:26:37.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.815]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.815]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.815]             base::names(...future.oldOptions))
[10:26:37.815]     }
[10:26:37.815]     if (FALSE) {
[10:26:37.815]     }
[10:26:37.815]     else {
[10:26:37.815]         if (TRUE) {
[10:26:37.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.815]                 open = "w")
[10:26:37.815]         }
[10:26:37.815]         else {
[10:26:37.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.815]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.815]         }
[10:26:37.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.815]             base::sink(type = "output", split = FALSE)
[10:26:37.815]             base::close(...future.stdout)
[10:26:37.815]         }, add = TRUE)
[10:26:37.815]     }
[10:26:37.815]     ...future.frame <- base::sys.nframe()
[10:26:37.815]     ...future.conditions <- base::list()
[10:26:37.815]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.815]     if (FALSE) {
[10:26:37.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.815]     }
[10:26:37.815]     ...future.result <- base::tryCatch({
[10:26:37.815]         base::withCallingHandlers({
[10:26:37.815]             ...future.value <- base::withVisible(base::local({
[10:26:37.815]                 b <- 2L
[10:26:37.815]                 plan_b <- future::plan("list")
[10:26:37.815]                 nested_b <- nested_a[-1]
[10:26:37.815]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:37.815]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:37.815]                   "sequential"))
[10:26:37.815]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:37.815]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:37.815]             }))
[10:26:37.815]             future::FutureResult(value = ...future.value$value, 
[10:26:37.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.815]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.815]                     ...future.globalenv.names))
[10:26:37.815]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.815]         }, condition = base::local({
[10:26:37.815]             c <- base::c
[10:26:37.815]             inherits <- base::inherits
[10:26:37.815]             invokeRestart <- base::invokeRestart
[10:26:37.815]             length <- base::length
[10:26:37.815]             list <- base::list
[10:26:37.815]             seq.int <- base::seq.int
[10:26:37.815]             signalCondition <- base::signalCondition
[10:26:37.815]             sys.calls <- base::sys.calls
[10:26:37.815]             `[[` <- base::`[[`
[10:26:37.815]             `+` <- base::`+`
[10:26:37.815]             `<<-` <- base::`<<-`
[10:26:37.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.815]                   3L)]
[10:26:37.815]             }
[10:26:37.815]             function(cond) {
[10:26:37.815]                 is_error <- inherits(cond, "error")
[10:26:37.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.815]                   NULL)
[10:26:37.815]                 if (is_error) {
[10:26:37.815]                   sessionInformation <- function() {
[10:26:37.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.815]                       search = base::search(), system = base::Sys.info())
[10:26:37.815]                   }
[10:26:37.815]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.815]                     cond$call), session = sessionInformation(), 
[10:26:37.815]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.815]                   signalCondition(cond)
[10:26:37.815]                 }
[10:26:37.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.815]                 "immediateCondition"))) {
[10:26:37.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.815]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.815]                   if (TRUE && !signal) {
[10:26:37.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.815]                     {
[10:26:37.815]                       inherits <- base::inherits
[10:26:37.815]                       invokeRestart <- base::invokeRestart
[10:26:37.815]                       is.null <- base::is.null
[10:26:37.815]                       muffled <- FALSE
[10:26:37.815]                       if (inherits(cond, "message")) {
[10:26:37.815]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.815]                         if (muffled) 
[10:26:37.815]                           invokeRestart("muffleMessage")
[10:26:37.815]                       }
[10:26:37.815]                       else if (inherits(cond, "warning")) {
[10:26:37.815]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.815]                         if (muffled) 
[10:26:37.815]                           invokeRestart("muffleWarning")
[10:26:37.815]                       }
[10:26:37.815]                       else if (inherits(cond, "condition")) {
[10:26:37.815]                         if (!is.null(pattern)) {
[10:26:37.815]                           computeRestarts <- base::computeRestarts
[10:26:37.815]                           grepl <- base::grepl
[10:26:37.815]                           restarts <- computeRestarts(cond)
[10:26:37.815]                           for (restart in restarts) {
[10:26:37.815]                             name <- restart$name
[10:26:37.815]                             if (is.null(name)) 
[10:26:37.815]                               next
[10:26:37.815]                             if (!grepl(pattern, name)) 
[10:26:37.815]                               next
[10:26:37.815]                             invokeRestart(restart)
[10:26:37.815]                             muffled <- TRUE
[10:26:37.815]                             break
[10:26:37.815]                           }
[10:26:37.815]                         }
[10:26:37.815]                       }
[10:26:37.815]                       invisible(muffled)
[10:26:37.815]                     }
[10:26:37.815]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.815]                   }
[10:26:37.815]                 }
[10:26:37.815]                 else {
[10:26:37.815]                   if (TRUE) {
[10:26:37.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.815]                     {
[10:26:37.815]                       inherits <- base::inherits
[10:26:37.815]                       invokeRestart <- base::invokeRestart
[10:26:37.815]                       is.null <- base::is.null
[10:26:37.815]                       muffled <- FALSE
[10:26:37.815]                       if (inherits(cond, "message")) {
[10:26:37.815]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.815]                         if (muffled) 
[10:26:37.815]                           invokeRestart("muffleMessage")
[10:26:37.815]                       }
[10:26:37.815]                       else if (inherits(cond, "warning")) {
[10:26:37.815]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.815]                         if (muffled) 
[10:26:37.815]                           invokeRestart("muffleWarning")
[10:26:37.815]                       }
[10:26:37.815]                       else if (inherits(cond, "condition")) {
[10:26:37.815]                         if (!is.null(pattern)) {
[10:26:37.815]                           computeRestarts <- base::computeRestarts
[10:26:37.815]                           grepl <- base::grepl
[10:26:37.815]                           restarts <- computeRestarts(cond)
[10:26:37.815]                           for (restart in restarts) {
[10:26:37.815]                             name <- restart$name
[10:26:37.815]                             if (is.null(name)) 
[10:26:37.815]                               next
[10:26:37.815]                             if (!grepl(pattern, name)) 
[10:26:37.815]                               next
[10:26:37.815]                             invokeRestart(restart)
[10:26:37.815]                             muffled <- TRUE
[10:26:37.815]                             break
[10:26:37.815]                           }
[10:26:37.815]                         }
[10:26:37.815]                       }
[10:26:37.815]                       invisible(muffled)
[10:26:37.815]                     }
[10:26:37.815]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.815]                   }
[10:26:37.815]                 }
[10:26:37.815]             }
[10:26:37.815]         }))
[10:26:37.815]     }, error = function(ex) {
[10:26:37.815]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.815]                 ...future.rng), started = ...future.startTime, 
[10:26:37.815]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.815]             version = "1.8"), class = "FutureResult")
[10:26:37.815]     }, finally = {
[10:26:37.815]         if (!identical(...future.workdir, getwd())) 
[10:26:37.815]             setwd(...future.workdir)
[10:26:37.815]         {
[10:26:37.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.815]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.815]             }
[10:26:37.815]             base::options(...future.oldOptions)
[10:26:37.815]             if (.Platform$OS.type == "windows") {
[10:26:37.815]                 old_names <- names(...future.oldEnvVars)
[10:26:37.815]                 envs <- base::Sys.getenv()
[10:26:37.815]                 names <- names(envs)
[10:26:37.815]                 common <- intersect(names, old_names)
[10:26:37.815]                 added <- setdiff(names, old_names)
[10:26:37.815]                 removed <- setdiff(old_names, names)
[10:26:37.815]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.815]                   envs[common]]
[10:26:37.815]                 NAMES <- toupper(changed)
[10:26:37.815]                 args <- list()
[10:26:37.815]                 for (kk in seq_along(NAMES)) {
[10:26:37.815]                   name <- changed[[kk]]
[10:26:37.815]                   NAME <- NAMES[[kk]]
[10:26:37.815]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.815]                     next
[10:26:37.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.815]                 }
[10:26:37.815]                 NAMES <- toupper(added)
[10:26:37.815]                 for (kk in seq_along(NAMES)) {
[10:26:37.815]                   name <- added[[kk]]
[10:26:37.815]                   NAME <- NAMES[[kk]]
[10:26:37.815]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.815]                     next
[10:26:37.815]                   args[[name]] <- ""
[10:26:37.815]                 }
[10:26:37.815]                 NAMES <- toupper(removed)
[10:26:37.815]                 for (kk in seq_along(NAMES)) {
[10:26:37.815]                   name <- removed[[kk]]
[10:26:37.815]                   NAME <- NAMES[[kk]]
[10:26:37.815]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.815]                     next
[10:26:37.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.815]                 }
[10:26:37.815]                 if (length(args) > 0) 
[10:26:37.815]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.815]             }
[10:26:37.815]             else {
[10:26:37.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.815]             }
[10:26:37.815]             {
[10:26:37.815]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.815]                   0L) {
[10:26:37.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.815]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.815]                   base::options(opts)
[10:26:37.815]                 }
[10:26:37.815]                 {
[10:26:37.815]                   {
[10:26:37.815]                     NULL
[10:26:37.815]                     RNGkind("Mersenne-Twister")
[10:26:37.815]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:37.815]                       inherits = FALSE)
[10:26:37.815]                   }
[10:26:37.815]                   options(future.plan = NULL)
[10:26:37.815]                   if (is.na(NA_character_)) 
[10:26:37.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.815]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:37.815]                   {
[10:26:37.815]                     future <- SequentialFuture(..., envir = envir)
[10:26:37.815]                     if (!future$lazy) 
[10:26:37.815]                       future <- run(future)
[10:26:37.815]                     invisible(future)
[10:26:37.815]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.815]                 }
[10:26:37.815]             }
[10:26:37.815]         }
[10:26:37.815]     })
[10:26:37.815]     if (TRUE) {
[10:26:37.815]         base::sink(type = "output", split = FALSE)
[10:26:37.815]         if (TRUE) {
[10:26:37.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.815]         }
[10:26:37.815]         else {
[10:26:37.815]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.815]         }
[10:26:37.815]         base::close(...future.stdout)
[10:26:37.815]         ...future.stdout <- NULL
[10:26:37.815]     }
[10:26:37.815]     ...future.result$conditions <- ...future.conditions
[10:26:37.815]     ...future.result$finished <- base::Sys.time()
[10:26:37.815]     ...future.result
[10:26:37.815] }
[10:26:37.846]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.817] assign_globals() ...
[10:26:37.846]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.818] List of 3
[10:26:37.818]  $ nested_a:List of 1
[10:26:37.818]   ..$ b:function (..., envir = parent.frame())  
[10:26:37.818]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:37.818]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:37.818]  $ a       : int 1
[10:26:37.818]  $ plan_a  :List of 1
[10:26:37.818]   ..$ b:function (..., envir = parent.frame())  
[10:26:37.818]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:26:37.818]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:37.818]  - attr(*, "where")=List of 3
[10:26:37.818]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:26:37.818]   ..$ a       :<environment: R_EmptyEnv> 
[10:26:37.818]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:26:37.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:37.818]  - attr(*, "resolved")= logi FALSE
[10:26:37.818]  - attr(*, "total_size")= num 23080
[10:26:37.818]  - attr(*, "already-done")= logi TRUE
[10:26:37.846]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.825] - copied ‘nested_a’ to environment
[10:26:37.847]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.825] - copied ‘a’ to environment
[10:26:37.847]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.825] - copied ‘plan_a’ to environment
[10:26:37.847]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.826] assign_globals() ... done
[10:26:37.847]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.826] plan(): Setting new future strategy stack:
[10:26:37.847]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.826] List of future strategies:
[10:26:37.826] 1. sequential:
[10:26:37.826]    - args: function (..., envir = parent.frame())
[10:26:37.826]    - tweaked: FALSE
[10:26:37.826]    - call: NULL
[10:26:37.847]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.827] plan(): nbrOfWorkers() = 1
[10:26:37.848]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.828] plan(): Setting new future strategy stack:
[10:26:37.848]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.828] List of future strategies:
[10:26:37.828] 1. sequential:
[10:26:37.828]    - args: function (..., envir = parent.frame())
[10:26:37.828]    - tweaked: FALSE
[10:26:37.828]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.848]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.828] plan(): nbrOfWorkers() = 1
[10:26:37.848]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.829] SequentialFuture started (and completed)
[10:26:37.848]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.829] - Launch lazy future ... done
[10:26:37.848]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.829] run() for ‘SequentialFuture’ ... done
[10:26:37.849] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:37.855] getGlobalsAndPackages() ...
[10:26:37.855] Searching for globals...
[10:26:37.856] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:37.857] Searching for globals ... DONE
[10:26:37.857] Resolving globals: FALSE
[10:26:37.857] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:37.858] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:37.858] - globals: [1] ‘data’
[10:26:37.858] - packages: [1] ‘future’
[10:26:37.858] getGlobalsAndPackages() ... DONE
[10:26:37.859] run() for ‘Future’ ...
[10:26:37.859] - state: ‘created’
[10:26:37.859] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:37.863] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:37.863] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:37.863]   - Field: ‘label’
[10:26:37.863]   - Field: ‘local’
[10:26:37.863]   - Field: ‘owner’
[10:26:37.864]   - Field: ‘envir’
[10:26:37.864]   - Field: ‘workers’
[10:26:37.864]   - Field: ‘packages’
[10:26:37.864]   - Field: ‘gc’
[10:26:37.864]   - Field: ‘job’
[10:26:37.864]   - Field: ‘conditions’
[10:26:37.864]   - Field: ‘expr’
[10:26:37.864]   - Field: ‘uuid’
[10:26:37.864]   - Field: ‘seed’
[10:26:37.865]   - Field: ‘version’
[10:26:37.865]   - Field: ‘result’
[10:26:37.865]   - Field: ‘asynchronous’
[10:26:37.865]   - Field: ‘calls’
[10:26:37.865]   - Field: ‘globals’
[10:26:37.865]   - Field: ‘stdout’
[10:26:37.865]   - Field: ‘earlySignal’
[10:26:37.865]   - Field: ‘lazy’
[10:26:37.865]   - Field: ‘state’
[10:26:37.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:37.866] - Launch lazy future ...
[10:26:37.866] Packages needed by the future expression (n = 1): ‘future’
[10:26:37.866] Packages needed by future strategies (n = 1): ‘future’
[10:26:37.867] {
[10:26:37.867]     {
[10:26:37.867]         {
[10:26:37.867]             ...future.startTime <- base::Sys.time()
[10:26:37.867]             {
[10:26:37.867]                 {
[10:26:37.867]                   {
[10:26:37.867]                     {
[10:26:37.867]                       {
[10:26:37.867]                         base::local({
[10:26:37.867]                           has_future <- base::requireNamespace("future", 
[10:26:37.867]                             quietly = TRUE)
[10:26:37.867]                           if (has_future) {
[10:26:37.867]                             ns <- base::getNamespace("future")
[10:26:37.867]                             version <- ns[[".package"]][["version"]]
[10:26:37.867]                             if (is.null(version)) 
[10:26:37.867]                               version <- utils::packageVersion("future")
[10:26:37.867]                           }
[10:26:37.867]                           else {
[10:26:37.867]                             version <- NULL
[10:26:37.867]                           }
[10:26:37.867]                           if (!has_future || version < "1.8.0") {
[10:26:37.867]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.867]                               "", base::R.version$version.string), 
[10:26:37.867]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:37.867]                                 base::R.version$platform, 8 * 
[10:26:37.867]                                   base::.Machine$sizeof.pointer), 
[10:26:37.867]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.867]                                 "release", "version")], collapse = " "), 
[10:26:37.867]                               hostname = base::Sys.info()[["nodename"]])
[10:26:37.867]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.867]                               info)
[10:26:37.867]                             info <- base::paste(info, collapse = "; ")
[10:26:37.867]                             if (!has_future) {
[10:26:37.867]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.867]                                 info)
[10:26:37.867]                             }
[10:26:37.867]                             else {
[10:26:37.867]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.867]                                 info, version)
[10:26:37.867]                             }
[10:26:37.867]                             base::stop(msg)
[10:26:37.867]                           }
[10:26:37.867]                         })
[10:26:37.867]                       }
[10:26:37.867]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:37.867]                       base::options(mc.cores = 1L)
[10:26:37.867]                     }
[10:26:37.867]                     base::local({
[10:26:37.867]                       for (pkg in "future") {
[10:26:37.867]                         base::loadNamespace(pkg)
[10:26:37.867]                         base::library(pkg, character.only = TRUE)
[10:26:37.867]                       }
[10:26:37.867]                     })
[10:26:37.867]                   }
[10:26:37.867]                   options(future.plan = NULL)
[10:26:37.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.867]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:37.867]                   {
[10:26:37.867]                     future <- SequentialFuture(..., envir = envir)
[10:26:37.867]                     if (!future$lazy) 
[10:26:37.867]                       future <- run(future)
[10:26:37.867]                     invisible(future)
[10:26:37.867]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.867]                 }
[10:26:37.867]                 ...future.workdir <- getwd()
[10:26:37.867]             }
[10:26:37.867]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.867]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.867]         }
[10:26:37.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.867]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.867]             base::names(...future.oldOptions))
[10:26:37.867]     }
[10:26:37.867]     if (FALSE) {
[10:26:37.867]     }
[10:26:37.867]     else {
[10:26:37.867]         if (TRUE) {
[10:26:37.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.867]                 open = "w")
[10:26:37.867]         }
[10:26:37.867]         else {
[10:26:37.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.867]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.867]         }
[10:26:37.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.867]             base::sink(type = "output", split = FALSE)
[10:26:37.867]             base::close(...future.stdout)
[10:26:37.867]         }, add = TRUE)
[10:26:37.867]     }
[10:26:37.867]     ...future.frame <- base::sys.nframe()
[10:26:37.867]     ...future.conditions <- base::list()
[10:26:37.867]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.867]     if (FALSE) {
[10:26:37.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.867]     }
[10:26:37.867]     ...future.result <- base::tryCatch({
[10:26:37.867]         base::withCallingHandlers({
[10:26:37.867]             ...future.value <- base::withVisible(base::local({
[10:26:37.867]                 withCallingHandlers({
[10:26:37.867]                   {
[10:26:37.867]                     value(future(subset(data, a == 2)))
[10:26:37.867]                   }
[10:26:37.867]                 }, immediateCondition = function(cond) {
[10:26:37.867]                   save_rds <- function (object, pathname, ...) 
[10:26:37.867]                   {
[10:26:37.867]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:37.867]                     if (file_test("-f", pathname_tmp)) {
[10:26:37.867]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.867]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:37.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.867]                         fi_tmp[["mtime"]])
[10:26:37.867]                     }
[10:26:37.867]                     tryCatch({
[10:26:37.867]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:37.867]                     }, error = function(ex) {
[10:26:37.867]                       msg <- conditionMessage(ex)
[10:26:37.867]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.867]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:37.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.867]                         fi_tmp[["mtime"]], msg)
[10:26:37.867]                       ex$message <- msg
[10:26:37.867]                       stop(ex)
[10:26:37.867]                     })
[10:26:37.867]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:37.867]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:37.867]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:37.867]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.867]                       fi <- file.info(pathname)
[10:26:37.867]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:37.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.867]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:37.867]                         fi[["size"]], fi[["mtime"]])
[10:26:37.867]                       stop(msg)
[10:26:37.867]                     }
[10:26:37.867]                     invisible(pathname)
[10:26:37.867]                   }
[10:26:37.867]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:37.867]                     rootPath = tempdir()) 
[10:26:37.867]                   {
[10:26:37.867]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:37.867]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:37.867]                       tmpdir = path, fileext = ".rds")
[10:26:37.867]                     save_rds(obj, file)
[10:26:37.867]                   }
[10:26:37.867]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:37.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.867]                   {
[10:26:37.867]                     inherits <- base::inherits
[10:26:37.867]                     invokeRestart <- base::invokeRestart
[10:26:37.867]                     is.null <- base::is.null
[10:26:37.867]                     muffled <- FALSE
[10:26:37.867]                     if (inherits(cond, "message")) {
[10:26:37.867]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:37.867]                       if (muffled) 
[10:26:37.867]                         invokeRestart("muffleMessage")
[10:26:37.867]                     }
[10:26:37.867]                     else if (inherits(cond, "warning")) {
[10:26:37.867]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:37.867]                       if (muffled) 
[10:26:37.867]                         invokeRestart("muffleWarning")
[10:26:37.867]                     }
[10:26:37.867]                     else if (inherits(cond, "condition")) {
[10:26:37.867]                       if (!is.null(pattern)) {
[10:26:37.867]                         computeRestarts <- base::computeRestarts
[10:26:37.867]                         grepl <- base::grepl
[10:26:37.867]                         restarts <- computeRestarts(cond)
[10:26:37.867]                         for (restart in restarts) {
[10:26:37.867]                           name <- restart$name
[10:26:37.867]                           if (is.null(name)) 
[10:26:37.867]                             next
[10:26:37.867]                           if (!grepl(pattern, name)) 
[10:26:37.867]                             next
[10:26:37.867]                           invokeRestart(restart)
[10:26:37.867]                           muffled <- TRUE
[10:26:37.867]                           break
[10:26:37.867]                         }
[10:26:37.867]                       }
[10:26:37.867]                     }
[10:26:37.867]                     invisible(muffled)
[10:26:37.867]                   }
[10:26:37.867]                   muffleCondition(cond)
[10:26:37.867]                 })
[10:26:37.867]             }))
[10:26:37.867]             future::FutureResult(value = ...future.value$value, 
[10:26:37.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.867]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.867]                     ...future.globalenv.names))
[10:26:37.867]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.867]         }, condition = base::local({
[10:26:37.867]             c <- base::c
[10:26:37.867]             inherits <- base::inherits
[10:26:37.867]             invokeRestart <- base::invokeRestart
[10:26:37.867]             length <- base::length
[10:26:37.867]             list <- base::list
[10:26:37.867]             seq.int <- base::seq.int
[10:26:37.867]             signalCondition <- base::signalCondition
[10:26:37.867]             sys.calls <- base::sys.calls
[10:26:37.867]             `[[` <- base::`[[`
[10:26:37.867]             `+` <- base::`+`
[10:26:37.867]             `<<-` <- base::`<<-`
[10:26:37.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.867]                   3L)]
[10:26:37.867]             }
[10:26:37.867]             function(cond) {
[10:26:37.867]                 is_error <- inherits(cond, "error")
[10:26:37.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.867]                   NULL)
[10:26:37.867]                 if (is_error) {
[10:26:37.867]                   sessionInformation <- function() {
[10:26:37.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.867]                       search = base::search(), system = base::Sys.info())
[10:26:37.867]                   }
[10:26:37.867]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.867]                     cond$call), session = sessionInformation(), 
[10:26:37.867]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.867]                   signalCondition(cond)
[10:26:37.867]                 }
[10:26:37.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.867]                 "immediateCondition"))) {
[10:26:37.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.867]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.867]                   if (TRUE && !signal) {
[10:26:37.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.867]                     {
[10:26:37.867]                       inherits <- base::inherits
[10:26:37.867]                       invokeRestart <- base::invokeRestart
[10:26:37.867]                       is.null <- base::is.null
[10:26:37.867]                       muffled <- FALSE
[10:26:37.867]                       if (inherits(cond, "message")) {
[10:26:37.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.867]                         if (muffled) 
[10:26:37.867]                           invokeRestart("muffleMessage")
[10:26:37.867]                       }
[10:26:37.867]                       else if (inherits(cond, "warning")) {
[10:26:37.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.867]                         if (muffled) 
[10:26:37.867]                           invokeRestart("muffleWarning")
[10:26:37.867]                       }
[10:26:37.867]                       else if (inherits(cond, "condition")) {
[10:26:37.867]                         if (!is.null(pattern)) {
[10:26:37.867]                           computeRestarts <- base::computeRestarts
[10:26:37.867]                           grepl <- base::grepl
[10:26:37.867]                           restarts <- computeRestarts(cond)
[10:26:37.867]                           for (restart in restarts) {
[10:26:37.867]                             name <- restart$name
[10:26:37.867]                             if (is.null(name)) 
[10:26:37.867]                               next
[10:26:37.867]                             if (!grepl(pattern, name)) 
[10:26:37.867]                               next
[10:26:37.867]                             invokeRestart(restart)
[10:26:37.867]                             muffled <- TRUE
[10:26:37.867]                             break
[10:26:37.867]                           }
[10:26:37.867]                         }
[10:26:37.867]                       }
[10:26:37.867]                       invisible(muffled)
[10:26:37.867]                     }
[10:26:37.867]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.867]                   }
[10:26:37.867]                 }
[10:26:37.867]                 else {
[10:26:37.867]                   if (TRUE) {
[10:26:37.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.867]                     {
[10:26:37.867]                       inherits <- base::inherits
[10:26:37.867]                       invokeRestart <- base::invokeRestart
[10:26:37.867]                       is.null <- base::is.null
[10:26:37.867]                       muffled <- FALSE
[10:26:37.867]                       if (inherits(cond, "message")) {
[10:26:37.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.867]                         if (muffled) 
[10:26:37.867]                           invokeRestart("muffleMessage")
[10:26:37.867]                       }
[10:26:37.867]                       else if (inherits(cond, "warning")) {
[10:26:37.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.867]                         if (muffled) 
[10:26:37.867]                           invokeRestart("muffleWarning")
[10:26:37.867]                       }
[10:26:37.867]                       else if (inherits(cond, "condition")) {
[10:26:37.867]                         if (!is.null(pattern)) {
[10:26:37.867]                           computeRestarts <- base::computeRestarts
[10:26:37.867]                           grepl <- base::grepl
[10:26:37.867]                           restarts <- computeRestarts(cond)
[10:26:37.867]                           for (restart in restarts) {
[10:26:37.867]                             name <- restart$name
[10:26:37.867]                             if (is.null(name)) 
[10:26:37.867]                               next
[10:26:37.867]                             if (!grepl(pattern, name)) 
[10:26:37.867]                               next
[10:26:37.867]                             invokeRestart(restart)
[10:26:37.867]                             muffled <- TRUE
[10:26:37.867]                             break
[10:26:37.867]                           }
[10:26:37.867]                         }
[10:26:37.867]                       }
[10:26:37.867]                       invisible(muffled)
[10:26:37.867]                     }
[10:26:37.867]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.867]                   }
[10:26:37.867]                 }
[10:26:37.867]             }
[10:26:37.867]         }))
[10:26:37.867]     }, error = function(ex) {
[10:26:37.867]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.867]                 ...future.rng), started = ...future.startTime, 
[10:26:37.867]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.867]             version = "1.8"), class = "FutureResult")
[10:26:37.867]     }, finally = {
[10:26:37.867]         if (!identical(...future.workdir, getwd())) 
[10:26:37.867]             setwd(...future.workdir)
[10:26:37.867]         {
[10:26:37.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.867]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.867]             }
[10:26:37.867]             base::options(...future.oldOptions)
[10:26:37.867]             if (.Platform$OS.type == "windows") {
[10:26:37.867]                 old_names <- names(...future.oldEnvVars)
[10:26:37.867]                 envs <- base::Sys.getenv()
[10:26:37.867]                 names <- names(envs)
[10:26:37.867]                 common <- intersect(names, old_names)
[10:26:37.867]                 added <- setdiff(names, old_names)
[10:26:37.867]                 removed <- setdiff(old_names, names)
[10:26:37.867]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.867]                   envs[common]]
[10:26:37.867]                 NAMES <- toupper(changed)
[10:26:37.867]                 args <- list()
[10:26:37.867]                 for (kk in seq_along(NAMES)) {
[10:26:37.867]                   name <- changed[[kk]]
[10:26:37.867]                   NAME <- NAMES[[kk]]
[10:26:37.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.867]                     next
[10:26:37.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.867]                 }
[10:26:37.867]                 NAMES <- toupper(added)
[10:26:37.867]                 for (kk in seq_along(NAMES)) {
[10:26:37.867]                   name <- added[[kk]]
[10:26:37.867]                   NAME <- NAMES[[kk]]
[10:26:37.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.867]                     next
[10:26:37.867]                   args[[name]] <- ""
[10:26:37.867]                 }
[10:26:37.867]                 NAMES <- toupper(removed)
[10:26:37.867]                 for (kk in seq_along(NAMES)) {
[10:26:37.867]                   name <- removed[[kk]]
[10:26:37.867]                   NAME <- NAMES[[kk]]
[10:26:37.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.867]                     next
[10:26:37.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.867]                 }
[10:26:37.867]                 if (length(args) > 0) 
[10:26:37.867]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.867]             }
[10:26:37.867]             else {
[10:26:37.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.867]             }
[10:26:37.867]             {
[10:26:37.867]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.867]                   0L) {
[10:26:37.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.867]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.867]                   base::options(opts)
[10:26:37.867]                 }
[10:26:37.867]                 {
[10:26:37.867]                   {
[10:26:37.867]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:37.867]                     NULL
[10:26:37.867]                   }
[10:26:37.867]                   options(future.plan = NULL)
[10:26:37.867]                   if (is.na(NA_character_)) 
[10:26:37.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.867]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:37.867]                     envir = parent.frame()) 
[10:26:37.867]                   {
[10:26:37.867]                     default_workers <- missing(workers)
[10:26:37.867]                     if (is.function(workers)) 
[10:26:37.867]                       workers <- workers()
[10:26:37.867]                     workers <- structure(as.integer(workers), 
[10:26:37.867]                       class = class(workers))
[10:26:37.867]                     stop_if_not(is.finite(workers), workers >= 
[10:26:37.867]                       1L)
[10:26:37.867]                     if ((workers == 1L && !inherits(workers, 
[10:26:37.867]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:37.867]                       if (default_workers) 
[10:26:37.867]                         supportsMulticore(warn = TRUE)
[10:26:37.867]                       return(sequential(..., envir = envir))
[10:26:37.867]                     }
[10:26:37.867]                     oopts <- options(mc.cores = workers)
[10:26:37.867]                     on.exit(options(oopts))
[10:26:37.867]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:37.867]                       envir = envir)
[10:26:37.867]                     if (!future$lazy) 
[10:26:37.867]                       future <- run(future)
[10:26:37.867]                     invisible(future)
[10:26:37.867]                   }, b = function (..., envir = parent.frame()) 
[10:26:37.867]                   {
[10:26:37.867]                     future <- SequentialFuture(..., envir = envir)
[10:26:37.867]                     if (!future$lazy) 
[10:26:37.867]                       future <- run(future)
[10:26:37.867]                     invisible(future)
[10:26:37.867]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.867]                 }
[10:26:37.867]             }
[10:26:37.867]         }
[10:26:37.867]     })
[10:26:37.867]     if (TRUE) {
[10:26:37.867]         base::sink(type = "output", split = FALSE)
[10:26:37.867]         if (TRUE) {
[10:26:37.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.867]         }
[10:26:37.867]         else {
[10:26:37.867]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.867]         }
[10:26:37.867]         base::close(...future.stdout)
[10:26:37.867]         ...future.stdout <- NULL
[10:26:37.867]     }
[10:26:37.867]     ...future.result$conditions <- ...future.conditions
[10:26:37.867]     ...future.result$finished <- base::Sys.time()
[10:26:37.867]     ...future.result
[10:26:37.867] }
[10:26:37.870] assign_globals() ...
[10:26:37.870] List of 1
[10:26:37.870]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:37.870]   ..$ a: int [1:3] 1 2 3
[10:26:37.870]   ..$ b: int [1:3] 3 2 1
[10:26:37.870]  - attr(*, "where")=List of 1
[10:26:37.870]   ..$ data:<environment: R_EmptyEnv> 
[10:26:37.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:37.870]  - attr(*, "resolved")= logi FALSE
[10:26:37.870]  - attr(*, "total_size")= num 128
[10:26:37.870]  - attr(*, "already-done")= logi TRUE
[10:26:37.873] - copied ‘data’ to environment
[10:26:37.873] assign_globals() ... done
[10:26:37.874] requestCore(): workers = 2
[10:26:37.876] MulticoreFuture started
[10:26:37.876] - Launch lazy future ... done
[10:26:37.876] run() for ‘MulticoreFuture’ ... done
[10:26:37.877] result() for MulticoreFuture ...
[10:26:37.877] plan(): Setting new future strategy stack:
[10:26:37.878] List of future strategies:
[10:26:37.878] 1. sequential:
[10:26:37.878]    - args: function (..., envir = parent.frame())
[10:26:37.878]    - tweaked: FALSE
[10:26:37.878]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.879] plan(): nbrOfWorkers() = 1
[10:26:37.902] plan(): Setting new future strategy stack:
[10:26:37.902] List of future strategies:
[10:26:37.902] 1. multicore:
[10:26:37.902]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:37.902]    - tweaked: FALSE
[10:26:37.902]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.902] 2. sequential:
[10:26:37.902]    - args: function (..., envir = parent.frame())
[10:26:37.902]    - tweaked: FALSE
[10:26:37.902]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.907] plan(): nbrOfWorkers() = 2
[10:26:37.908] result() for MulticoreFuture ...
[10:26:37.909] result() for MulticoreFuture ... done
[10:26:37.909] signalConditions() ...
[10:26:37.909]  - include = ‘immediateCondition’
[10:26:37.909]  - exclude = 
[10:26:37.909]  - resignal = FALSE
[10:26:37.909]  - Number of conditions: 52
[10:26:37.909] signalConditions() ... done
[10:26:37.909] result() for MulticoreFuture ... done
[10:26:37.910] result() for MulticoreFuture ...
[10:26:37.910] result() for MulticoreFuture ... done
[10:26:37.910] signalConditions() ...
[10:26:37.910]  - include = ‘immediateCondition’
[10:26:37.910]  - exclude = 
[10:26:37.910]  - resignal = FALSE
[10:26:37.910]  - Number of conditions: 52
[10:26:37.910] signalConditions() ... done
[10:26:37.911] Future state: ‘finished’
[10:26:37.911] result() for MulticoreFuture ...
[10:26:37.911] result() for MulticoreFuture ... done
[10:26:37.911] signalConditions() ...
[10:26:37.911]  - include = ‘condition’
[10:26:37.911]  - exclude = ‘immediateCondition’
[10:26:37.911]  - resignal = TRUE
[10:26:37.911]  - Number of conditions: 52
[10:26:37.911]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.880] getGlobalsAndPackages() ...
[10:26:37.912]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.880] Searching for globals...
[10:26:37.912]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.882] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:37.912]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.882] Searching for globals ... DONE
[10:26:37.912]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.882] Resolving globals: FALSE
[10:26:37.912]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.883] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:37.912]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.884] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:37.913]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.884] - globals: [1] ‘data’
[10:26:37.913]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.884] 
[10:26:37.913]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.884] getGlobalsAndPackages() ... DONE
[10:26:37.913]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.885] run() for ‘Future’ ...
[10:26:37.913]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.885] - state: ‘created’
[10:26:37.913]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.886] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:26:37.914]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.886] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:37.914]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:37.914]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.886]   - Field: ‘label’
[10:26:37.914]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.887]   - Field: ‘local’
[10:26:37.914]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.887]   - Field: ‘owner’
[10:26:37.914]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.887]   - Field: ‘envir’
[10:26:37.914]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.887]   - Field: ‘packages’
[10:26:37.915]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.887]   - Field: ‘gc’
[10:26:37.915]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.887]   - Field: ‘conditions’
[10:26:37.915]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.888]   - Field: ‘expr’
[10:26:37.915]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.888]   - Field: ‘uuid’
[10:26:37.915]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.888]   - Field: ‘seed’
[10:26:37.915]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.888]   - Field: ‘version’
[10:26:37.916]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.888]   - Field: ‘result’
[10:26:37.916]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.888]   - Field: ‘asynchronous’
[10:26:37.916]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.889]   - Field: ‘calls’
[10:26:37.916]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.889]   - Field: ‘globals’
[10:26:37.916]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.889]   - Field: ‘stdout’
[10:26:37.916]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.889]   - Field: ‘earlySignal’
[10:26:37.916]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.889]   - Field: ‘lazy’
[10:26:37.917]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.889]   - Field: ‘state’
[10:26:37.917]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.889] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:37.917]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.890] - Launch lazy future ...
[10:26:37.917]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.890] Packages needed by the future expression (n = 0): <none>
[10:26:37.917]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.890] Packages needed by future strategies (n = 0): <none>
[10:26:37.917]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.891] {
[10:26:37.891]     {
[10:26:37.891]         {
[10:26:37.891]             ...future.startTime <- base::Sys.time()
[10:26:37.891]             {
[10:26:37.891]                 {
[10:26:37.891]                   {
[10:26:37.891]                     base::local({
[10:26:37.891]                       has_future <- base::requireNamespace("future", 
[10:26:37.891]                         quietly = TRUE)
[10:26:37.891]                       if (has_future) {
[10:26:37.891]                         ns <- base::getNamespace("future")
[10:26:37.891]                         version <- ns[[".package"]][["version"]]
[10:26:37.891]                         if (is.null(version)) 
[10:26:37.891]                           version <- utils::packageVersion("future")
[10:26:37.891]                       }
[10:26:37.891]                       else {
[10:26:37.891]                         version <- NULL
[10:26:37.891]                       }
[10:26:37.891]                       if (!has_future || version < "1.8.0") {
[10:26:37.891]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.891]                           "", base::R.version$version.string), 
[10:26:37.891]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:37.891]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:37.891]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.891]                             "release", "version")], collapse = " "), 
[10:26:37.891]                           hostname = base::Sys.info()[["nodename"]])
[10:26:37.891]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.891]                           info)
[10:26:37.891]                         info <- base::paste(info, collapse = "; ")
[10:26:37.891]                         if (!has_future) {
[10:26:37.891]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.891]                             info)
[10:26:37.891]                         }
[10:26:37.891]                         else {
[10:26:37.891]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.891]                             info, version)
[10:26:37.891]                         }
[10:26:37.891]                         base::stop(msg)
[10:26:37.891]                       }
[10:26:37.891]                     })
[10:26:37.891]                   }
[10:26:37.891]                   options(future.plan = NULL)
[10:26:37.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:37.891]                 }
[10:26:37.891]                 ...future.workdir <- getwd()
[10:26:37.891]             }
[10:26:37.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.891]         }
[10:26:37.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.891]             base::names(...future.oldOptions))
[10:26:37.891]     }
[10:26:37.891]     if (FALSE) {
[10:26:37.891]     }
[10:26:37.891]     else {
[10:26:37.891]         if (TRUE) {
[10:26:37.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.891]                 open = "w")
[10:26:37.891]         }
[10:26:37.891]         else {
[10:26:37.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.891]         }
[10:26:37.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.891]             base::sink(type = "output", split = FALSE)
[10:26:37.891]             base::close(...future.stdout)
[10:26:37.891]         }, add = TRUE)
[10:26:37.891]     }
[10:26:37.891]     ...future.frame <- base::sys.nframe()
[10:26:37.891]     ...future.conditions <- base::list()
[10:26:37.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.891]     if (FALSE) {
[10:26:37.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.891]     }
[10:26:37.891]     ...future.result <- base::tryCatch({
[10:26:37.891]         base::withCallingHandlers({
[10:26:37.891]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:26:37.891]                 a == 2)))
[10:26:37.891]             future::FutureResult(value = ...future.value$value, 
[10:26:37.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.891]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.891]                     ...future.globalenv.names))
[10:26:37.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.891]         }, condition = base::local({
[10:26:37.891]             c <- base::c
[10:26:37.891]             inherits <- base::inherits
[10:26:37.891]             invokeRestart <- base::invokeRestart
[10:26:37.891]             length <- base::length
[10:26:37.891]             list <- base::list
[10:26:37.891]             seq.int <- base::seq.int
[10:26:37.891]             signalCondition <- base::signalCondition
[10:26:37.891]             sys.calls <- base::sys.calls
[10:26:37.891]             `[[` <- base::`[[`
[10:26:37.891]             `+` <- base::`+`
[10:26:37.891]             `<<-` <- base::`<<-`
[10:26:37.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.891]                   3L)]
[10:26:37.891]             }
[10:26:37.891]             function(cond) {
[10:26:37.891]                 is_error <- inherits(cond, "error")
[10:26:37.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.891]                   NULL)
[10:26:37.891]                 if (is_error) {
[10:26:37.891]                   sessionInformation <- function() {
[10:26:37.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.891]                       search = base::search(), system = base::Sys.info())
[10:26:37.891]                   }
[10:26:37.891]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.891]                     cond$call), session = sessionInformation(), 
[10:26:37.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.891]                   signalCondition(cond)
[10:26:37.891]                 }
[10:26:37.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.891]                 "immediateCondition"))) {
[10:26:37.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.891]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.891]                   if (TRUE && !signal) {
[10:26:37.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.891]                     {
[10:26:37.891]                       inherits <- base::inherits
[10:26:37.891]                       invokeRestart <- base::invokeRestart
[10:26:37.891]                       is.null <- base::is.null
[10:26:37.891]                       muffled <- FALSE
[10:26:37.891]                       if (inherits(cond, "message")) {
[10:26:37.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.891]                         if (muffled) 
[10:26:37.891]                           invokeRestart("muffleMessage")
[10:26:37.891]                       }
[10:26:37.891]                       else if (inherits(cond, "warning")) {
[10:26:37.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.891]                         if (muffled) 
[10:26:37.891]                           invokeRestart("muffleWarning")
[10:26:37.891]                       }
[10:26:37.891]                       else if (inherits(cond, "condition")) {
[10:26:37.891]                         if (!is.null(pattern)) {
[10:26:37.891]                           computeRestarts <- base::computeRestarts
[10:26:37.891]                           grepl <- base::grepl
[10:26:37.891]                           restarts <- computeRestarts(cond)
[10:26:37.891]                           for (restart in restarts) {
[10:26:37.891]                             name <- restart$name
[10:26:37.891]                             if (is.null(name)) 
[10:26:37.891]                               next
[10:26:37.891]                             if (!grepl(pattern, name)) 
[10:26:37.891]                               next
[10:26:37.891]                             invokeRestart(restart)
[10:26:37.891]                             muffled <- TRUE
[10:26:37.891]                             break
[10:26:37.891]                           }
[10:26:37.891]                         }
[10:26:37.891]                       }
[10:26:37.891]                       invisible(muffled)
[10:26:37.891]                     }
[10:26:37.891]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.891]                   }
[10:26:37.891]                 }
[10:26:37.891]                 else {
[10:26:37.891]                   if (TRUE) {
[10:26:37.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.891]                     {
[10:26:37.891]                       inherits <- base::inherits
[10:26:37.891]                       invokeRestart <- base::invokeRestart
[10:26:37.891]                       is.null <- base::is.null
[10:26:37.891]                       muffled <- FALSE
[10:26:37.891]                       if (inherits(cond, "message")) {
[10:26:37.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.891]                         if (muffled) 
[10:26:37.891]                           invokeRestart("muffleMessage")
[10:26:37.891]                       }
[10:26:37.891]                       else if (inherits(cond, "warning")) {
[10:26:37.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.891]                         if (muffled) 
[10:26:37.891]                           invokeRestart("muffleWarning")
[10:26:37.891]                       }
[10:26:37.891]                       else if (inherits(cond, "condition")) {
[10:26:37.891]                         if (!is.null(pattern)) {
[10:26:37.891]                           computeRestarts <- base::computeRestarts
[10:26:37.891]                           grepl <- base::grepl
[10:26:37.891]                           restarts <- computeRestarts(cond)
[10:26:37.891]                           for (restart in restarts) {
[10:26:37.891]                             name <- restart$name
[10:26:37.891]                             if (is.null(name)) 
[10:26:37.891]                               next
[10:26:37.891]                             if (!grepl(pattern, name)) 
[10:26:37.891]                               next
[10:26:37.891]                             invokeRestart(restart)
[10:26:37.891]                             muffled <- TRUE
[10:26:37.891]                             break
[10:26:37.891]                           }
[10:26:37.891]                         }
[10:26:37.891]                       }
[10:26:37.891]                       invisible(muffled)
[10:26:37.891]                     }
[10:26:37.891]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.891]                   }
[10:26:37.891]                 }
[10:26:37.891]             }
[10:26:37.891]         }))
[10:26:37.891]     }, error = function(ex) {
[10:26:37.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.891]                 ...future.rng), started = ...future.startTime, 
[10:26:37.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.891]             version = "1.8"), class = "FutureResult")
[10:26:37.891]     }, finally = {
[10:26:37.891]         if (!identical(...future.workdir, getwd())) 
[10:26:37.891]             setwd(...future.workdir)
[10:26:37.891]         {
[10:26:37.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.891]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.891]             }
[10:26:37.891]             base::options(...future.oldOptions)
[10:26:37.891]             if (.Platform$OS.type == "windows") {
[10:26:37.891]                 old_names <- names(...future.oldEnvVars)
[10:26:37.891]                 envs <- base::Sys.getenv()
[10:26:37.891]                 names <- names(envs)
[10:26:37.891]                 common <- intersect(names, old_names)
[10:26:37.891]                 added <- setdiff(names, old_names)
[10:26:37.891]                 removed <- setdiff(old_names, names)
[10:26:37.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.891]                   envs[common]]
[10:26:37.891]                 NAMES <- toupper(changed)
[10:26:37.891]                 args <- list()
[10:26:37.891]                 for (kk in seq_along(NAMES)) {
[10:26:37.891]                   name <- changed[[kk]]
[10:26:37.891]                   NAME <- NAMES[[kk]]
[10:26:37.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.891]                     next
[10:26:37.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.891]                 }
[10:26:37.891]                 NAMES <- toupper(added)
[10:26:37.891]                 for (kk in seq_along(NAMES)) {
[10:26:37.891]                   name <- added[[kk]]
[10:26:37.891]                   NAME <- NAMES[[kk]]
[10:26:37.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.891]                     next
[10:26:37.891]                   args[[name]] <- ""
[10:26:37.891]                 }
[10:26:37.891]                 NAMES <- toupper(removed)
[10:26:37.891]                 for (kk in seq_along(NAMES)) {
[10:26:37.891]                   name <- removed[[kk]]
[10:26:37.891]                   NAME <- NAMES[[kk]]
[10:26:37.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.891]                     next
[10:26:37.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.891]                 }
[10:26:37.891]                 if (length(args) > 0) 
[10:26:37.891]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.891]             }
[10:26:37.891]             else {
[10:26:37.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.891]             }
[10:26:37.891]             {
[10:26:37.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.891]                   0L) {
[10:26:37.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.891]                   base::options(opts)
[10:26:37.891]                 }
[10:26:37.891]                 {
[10:26:37.891]                   {
[10:26:37.891]                     NULL
[10:26:37.891]                     RNGkind("Mersenne-Twister")
[10:26:37.891]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:37.891]                       inherits = FALSE)
[10:26:37.891]                   }
[10:26:37.891]                   options(future.plan = NULL)
[10:26:37.891]                   if (is.na(NA_character_)) 
[10:26:37.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.891]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:37.891]                   {
[10:26:37.891]                     future <- SequentialFuture(..., envir = envir)
[10:26:37.891]                     if (!future$lazy) 
[10:26:37.891]                       future <- run(future)
[10:26:37.891]                     invisible(future)
[10:26:37.891]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.891]                 }
[10:26:37.891]             }
[10:26:37.891]         }
[10:26:37.891]     })
[10:26:37.891]     if (TRUE) {
[10:26:37.891]         base::sink(type = "output", split = FALSE)
[10:26:37.891]         if (TRUE) {
[10:26:37.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.891]         }
[10:26:37.891]         else {
[10:26:37.891]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.891]         }
[10:26:37.891]         base::close(...future.stdout)
[10:26:37.891]         ...future.stdout <- NULL
[10:26:37.891]     }
[10:26:37.891]     ...future.result$conditions <- ...future.conditions
[10:26:37.891]     ...future.result$finished <- base::Sys.time()
[10:26:37.891]     ...future.result
[10:26:37.891] }
[10:26:37.918]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.893] assign_globals() ...
[10:26:37.918]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.893] List of 1
[10:26:37.893]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:37.893]   ..$ a: int [1:3] 1 2 3
[10:26:37.893]   ..$ b: int [1:3] 3 2 1
[10:26:37.893]  - attr(*, "where")=List of 1
[10:26:37.893]   ..$ data:<environment: R_EmptyEnv> 
[10:26:37.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:37.893]  - attr(*, "resolved")= logi FALSE
[10:26:37.893]  - attr(*, "total_size")= num 128
[10:26:37.893]  - attr(*, "already-done")= logi TRUE
[10:26:37.918]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.898] - copied ‘data’ to environment
[10:26:37.918]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.898] assign_globals() ... done
[10:26:37.918]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.899] plan(): Setting new future strategy stack:
[10:26:37.918]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.899] List of future strategies:
[10:26:37.899] 1. sequential:
[10:26:37.899]    - args: function (..., envir = parent.frame())
[10:26:37.899]    - tweaked: FALSE
[10:26:37.899]    - call: NULL
[10:26:37.919]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.899] plan(): nbrOfWorkers() = 1
[10:26:37.919]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.900] plan(): Setting new future strategy stack:
[10:26:37.919]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.901] List of future strategies:
[10:26:37.901] 1. sequential:
[10:26:37.901]    - args: function (..., envir = parent.frame())
[10:26:37.901]    - tweaked: FALSE
[10:26:37.901]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.919]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.901] plan(): nbrOfWorkers() = 1
[10:26:37.919]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.901] SequentialFuture started (and completed)
[10:26:37.919]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.902] - Launch lazy future ... done
[10:26:37.919]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.902] run() for ‘SequentialFuture’ ... done
[10:26:37.920] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[10:26:37.920] plan(): Setting new future strategy stack:
[10:26:37.920] List of future strategies:
[10:26:37.920] 1. multicore:
[10:26:37.920]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:37.920]    - tweaked: FALSE
[10:26:37.920]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.920] 2. multicore:
[10:26:37.920]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:37.920]    - tweaked: FALSE
[10:26:37.920]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.925] plan(): nbrOfWorkers() = 2
[10:26:37.925] getGlobalsAndPackages() ...
[10:26:37.925] Searching for globals...
[10:26:37.947] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:37.948] Searching for globals ... DONE
[10:26:37.948] Resolving globals: FALSE
[10:26:37.949] The total size of the 2 globals is 93.07 KiB (95304 bytes)
[10:26:37.949] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 93.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (92.95 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:37.950] - globals: [2] ‘nested’, ‘strategy2’
[10:26:37.950] - packages: [1] ‘future’
[10:26:37.950] getGlobalsAndPackages() ... DONE
[10:26:37.950] run() for ‘Future’ ...
[10:26:37.950] - state: ‘created’
[10:26:37.951] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:37.954] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:37.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:37.955]   - Field: ‘label’
[10:26:37.955]   - Field: ‘local’
[10:26:37.955]   - Field: ‘owner’
[10:26:37.955]   - Field: ‘envir’
[10:26:37.955]   - Field: ‘workers’
[10:26:37.955]   - Field: ‘packages’
[10:26:37.955]   - Field: ‘gc’
[10:26:37.955]   - Field: ‘job’
[10:26:37.956]   - Field: ‘conditions’
[10:26:37.956]   - Field: ‘expr’
[10:26:37.956]   - Field: ‘uuid’
[10:26:37.956]   - Field: ‘seed’
[10:26:37.956]   - Field: ‘version’
[10:26:37.956]   - Field: ‘result’
[10:26:37.956]   - Field: ‘asynchronous’
[10:26:37.956]   - Field: ‘calls’
[10:26:37.956]   - Field: ‘globals’
[10:26:37.956]   - Field: ‘stdout’
[10:26:37.957]   - Field: ‘earlySignal’
[10:26:37.957]   - Field: ‘lazy’
[10:26:37.957]   - Field: ‘state’
[10:26:37.957] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:37.957] - Launch lazy future ...
[10:26:37.957] Packages needed by the future expression (n = 1): ‘future’
[10:26:37.958] Packages needed by future strategies (n = 1): ‘future’
[10:26:37.958] {
[10:26:37.958]     {
[10:26:37.958]         {
[10:26:37.958]             ...future.startTime <- base::Sys.time()
[10:26:37.958]             {
[10:26:37.958]                 {
[10:26:37.958]                   {
[10:26:37.958]                     {
[10:26:37.958]                       {
[10:26:37.958]                         base::local({
[10:26:37.958]                           has_future <- base::requireNamespace("future", 
[10:26:37.958]                             quietly = TRUE)
[10:26:37.958]                           if (has_future) {
[10:26:37.958]                             ns <- base::getNamespace("future")
[10:26:37.958]                             version <- ns[[".package"]][["version"]]
[10:26:37.958]                             if (is.null(version)) 
[10:26:37.958]                               version <- utils::packageVersion("future")
[10:26:37.958]                           }
[10:26:37.958]                           else {
[10:26:37.958]                             version <- NULL
[10:26:37.958]                           }
[10:26:37.958]                           if (!has_future || version < "1.8.0") {
[10:26:37.958]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:37.958]                               "", base::R.version$version.string), 
[10:26:37.958]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:37.958]                                 base::R.version$platform, 8 * 
[10:26:37.958]                                   base::.Machine$sizeof.pointer), 
[10:26:37.958]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:37.958]                                 "release", "version")], collapse = " "), 
[10:26:37.958]                               hostname = base::Sys.info()[["nodename"]])
[10:26:37.958]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:37.958]                               info)
[10:26:37.958]                             info <- base::paste(info, collapse = "; ")
[10:26:37.958]                             if (!has_future) {
[10:26:37.958]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:37.958]                                 info)
[10:26:37.958]                             }
[10:26:37.958]                             else {
[10:26:37.958]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:37.958]                                 info, version)
[10:26:37.958]                             }
[10:26:37.958]                             base::stop(msg)
[10:26:37.958]                           }
[10:26:37.958]                         })
[10:26:37.958]                       }
[10:26:37.958]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:37.958]                       base::options(mc.cores = 1L)
[10:26:37.958]                     }
[10:26:37.958]                     base::local({
[10:26:37.958]                       for (pkg in "future") {
[10:26:37.958]                         base::loadNamespace(pkg)
[10:26:37.958]                         base::library(pkg, character.only = TRUE)
[10:26:37.958]                       }
[10:26:37.958]                     })
[10:26:37.958]                   }
[10:26:37.958]                   options(future.plan = NULL)
[10:26:37.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.958]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:37.958]                     envir = parent.frame()) 
[10:26:37.958]                   {
[10:26:37.958]                     default_workers <- missing(workers)
[10:26:37.958]                     if (is.function(workers)) 
[10:26:37.958]                       workers <- workers()
[10:26:37.958]                     workers <- structure(as.integer(workers), 
[10:26:37.958]                       class = class(workers))
[10:26:37.958]                     stop_if_not(is.finite(workers), workers >= 
[10:26:37.958]                       1L)
[10:26:37.958]                     if ((workers == 1L && !inherits(workers, 
[10:26:37.958]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:37.958]                       if (default_workers) 
[10:26:37.958]                         supportsMulticore(warn = TRUE)
[10:26:37.958]                       return(sequential(..., envir = envir))
[10:26:37.958]                     }
[10:26:37.958]                     oopts <- options(mc.cores = workers)
[10:26:37.958]                     on.exit(options(oopts))
[10:26:37.958]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:37.958]                       envir = envir)
[10:26:37.958]                     if (!future$lazy) 
[10:26:37.958]                       future <- run(future)
[10:26:37.958]                     invisible(future)
[10:26:37.958]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.958]                 }
[10:26:37.958]                 ...future.workdir <- getwd()
[10:26:37.958]             }
[10:26:37.958]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:37.958]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:37.958]         }
[10:26:37.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:37.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:37.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:37.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:37.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:37.958]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:37.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:37.958]             base::names(...future.oldOptions))
[10:26:37.958]     }
[10:26:37.958]     if (FALSE) {
[10:26:37.958]     }
[10:26:37.958]     else {
[10:26:37.958]         if (TRUE) {
[10:26:37.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:37.958]                 open = "w")
[10:26:37.958]         }
[10:26:37.958]         else {
[10:26:37.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:37.958]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:37.958]         }
[10:26:37.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:37.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:37.958]             base::sink(type = "output", split = FALSE)
[10:26:37.958]             base::close(...future.stdout)
[10:26:37.958]         }, add = TRUE)
[10:26:37.958]     }
[10:26:37.958]     ...future.frame <- base::sys.nframe()
[10:26:37.958]     ...future.conditions <- base::list()
[10:26:37.958]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:37.958]     if (FALSE) {
[10:26:37.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:37.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:37.958]     }
[10:26:37.958]     ...future.result <- base::tryCatch({
[10:26:37.958]         base::withCallingHandlers({
[10:26:37.958]             ...future.value <- base::withVisible(base::local({
[10:26:37.958]                 withCallingHandlers({
[10:26:37.958]                   {
[10:26:37.958]                     a <- 1L
[10:26:37.958]                     plan_a <- unclass(future::plan("list"))
[10:26:37.958]                     nested_a <- nested[-1]
[10:26:37.958]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:37.958]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:37.958]                       strategy2))
[10:26:37.958]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:37.958]                       "init") <- NULL
[10:26:37.958]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:37.958]                       "init") <- NULL
[10:26:37.958]                     stopifnot(all.equal(plan_a, nested_a))
[10:26:37.958]                     y %<-% {
[10:26:37.958]                       b <- 2L
[10:26:37.958]                       plan_b <- future::plan("list")
[10:26:37.958]                       nested_b <- nested_a[-1]
[10:26:37.958]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:37.958]                         1L, inherits(plan_b[[1]], "future"), 
[10:26:37.958]                         inherits(future::plan("next"), "sequential"))
[10:26:37.958]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:37.958]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:37.958]                     }
[10:26:37.958]                     y
[10:26:37.958]                   }
[10:26:37.958]                 }, immediateCondition = function(cond) {
[10:26:37.958]                   save_rds <- function (object, pathname, ...) 
[10:26:37.958]                   {
[10:26:37.958]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:37.958]                     if (file_test("-f", pathname_tmp)) {
[10:26:37.958]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.958]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:37.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.958]                         fi_tmp[["mtime"]])
[10:26:37.958]                     }
[10:26:37.958]                     tryCatch({
[10:26:37.958]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:37.958]                     }, error = function(ex) {
[10:26:37.958]                       msg <- conditionMessage(ex)
[10:26:37.958]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.958]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:37.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.958]                         fi_tmp[["mtime"]], msg)
[10:26:37.958]                       ex$message <- msg
[10:26:37.958]                       stop(ex)
[10:26:37.958]                     })
[10:26:37.958]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:37.958]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:37.958]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:37.958]                       fi_tmp <- file.info(pathname_tmp)
[10:26:37.958]                       fi <- file.info(pathname)
[10:26:37.958]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:37.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:37.958]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:37.958]                         fi[["size"]], fi[["mtime"]])
[10:26:37.958]                       stop(msg)
[10:26:37.958]                     }
[10:26:37.958]                     invisible(pathname)
[10:26:37.958]                   }
[10:26:37.958]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:37.958]                     rootPath = tempdir()) 
[10:26:37.958]                   {
[10:26:37.958]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:37.958]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:37.958]                       tmpdir = path, fileext = ".rds")
[10:26:37.958]                     save_rds(obj, file)
[10:26:37.958]                   }
[10:26:37.958]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:37.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.958]                   {
[10:26:37.958]                     inherits <- base::inherits
[10:26:37.958]                     invokeRestart <- base::invokeRestart
[10:26:37.958]                     is.null <- base::is.null
[10:26:37.958]                     muffled <- FALSE
[10:26:37.958]                     if (inherits(cond, "message")) {
[10:26:37.958]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:37.958]                       if (muffled) 
[10:26:37.958]                         invokeRestart("muffleMessage")
[10:26:37.958]                     }
[10:26:37.958]                     else if (inherits(cond, "warning")) {
[10:26:37.958]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:37.958]                       if (muffled) 
[10:26:37.958]                         invokeRestart("muffleWarning")
[10:26:37.958]                     }
[10:26:37.958]                     else if (inherits(cond, "condition")) {
[10:26:37.958]                       if (!is.null(pattern)) {
[10:26:37.958]                         computeRestarts <- base::computeRestarts
[10:26:37.958]                         grepl <- base::grepl
[10:26:37.958]                         restarts <- computeRestarts(cond)
[10:26:37.958]                         for (restart in restarts) {
[10:26:37.958]                           name <- restart$name
[10:26:37.958]                           if (is.null(name)) 
[10:26:37.958]                             next
[10:26:37.958]                           if (!grepl(pattern, name)) 
[10:26:37.958]                             next
[10:26:37.958]                           invokeRestart(restart)
[10:26:37.958]                           muffled <- TRUE
[10:26:37.958]                           break
[10:26:37.958]                         }
[10:26:37.958]                       }
[10:26:37.958]                     }
[10:26:37.958]                     invisible(muffled)
[10:26:37.958]                   }
[10:26:37.958]                   muffleCondition(cond)
[10:26:37.958]                 })
[10:26:37.958]             }))
[10:26:37.958]             future::FutureResult(value = ...future.value$value, 
[10:26:37.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.958]                   ...future.rng), globalenv = if (FALSE) 
[10:26:37.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:37.958]                     ...future.globalenv.names))
[10:26:37.958]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:37.958]         }, condition = base::local({
[10:26:37.958]             c <- base::c
[10:26:37.958]             inherits <- base::inherits
[10:26:37.958]             invokeRestart <- base::invokeRestart
[10:26:37.958]             length <- base::length
[10:26:37.958]             list <- base::list
[10:26:37.958]             seq.int <- base::seq.int
[10:26:37.958]             signalCondition <- base::signalCondition
[10:26:37.958]             sys.calls <- base::sys.calls
[10:26:37.958]             `[[` <- base::`[[`
[10:26:37.958]             `+` <- base::`+`
[10:26:37.958]             `<<-` <- base::`<<-`
[10:26:37.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:37.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:37.958]                   3L)]
[10:26:37.958]             }
[10:26:37.958]             function(cond) {
[10:26:37.958]                 is_error <- inherits(cond, "error")
[10:26:37.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:37.958]                   NULL)
[10:26:37.958]                 if (is_error) {
[10:26:37.958]                   sessionInformation <- function() {
[10:26:37.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:37.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:37.958]                       search = base::search(), system = base::Sys.info())
[10:26:37.958]                   }
[10:26:37.958]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:37.958]                     cond$call), session = sessionInformation(), 
[10:26:37.958]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:37.958]                   signalCondition(cond)
[10:26:37.958]                 }
[10:26:37.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:37.958]                 "immediateCondition"))) {
[10:26:37.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:37.958]                   ...future.conditions[[length(...future.conditions) + 
[10:26:37.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:37.958]                   if (TRUE && !signal) {
[10:26:37.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.958]                     {
[10:26:37.958]                       inherits <- base::inherits
[10:26:37.958]                       invokeRestart <- base::invokeRestart
[10:26:37.958]                       is.null <- base::is.null
[10:26:37.958]                       muffled <- FALSE
[10:26:37.958]                       if (inherits(cond, "message")) {
[10:26:37.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.958]                         if (muffled) 
[10:26:37.958]                           invokeRestart("muffleMessage")
[10:26:37.958]                       }
[10:26:37.958]                       else if (inherits(cond, "warning")) {
[10:26:37.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.958]                         if (muffled) 
[10:26:37.958]                           invokeRestart("muffleWarning")
[10:26:37.958]                       }
[10:26:37.958]                       else if (inherits(cond, "condition")) {
[10:26:37.958]                         if (!is.null(pattern)) {
[10:26:37.958]                           computeRestarts <- base::computeRestarts
[10:26:37.958]                           grepl <- base::grepl
[10:26:37.958]                           restarts <- computeRestarts(cond)
[10:26:37.958]                           for (restart in restarts) {
[10:26:37.958]                             name <- restart$name
[10:26:37.958]                             if (is.null(name)) 
[10:26:37.958]                               next
[10:26:37.958]                             if (!grepl(pattern, name)) 
[10:26:37.958]                               next
[10:26:37.958]                             invokeRestart(restart)
[10:26:37.958]                             muffled <- TRUE
[10:26:37.958]                             break
[10:26:37.958]                           }
[10:26:37.958]                         }
[10:26:37.958]                       }
[10:26:37.958]                       invisible(muffled)
[10:26:37.958]                     }
[10:26:37.958]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.958]                   }
[10:26:37.958]                 }
[10:26:37.958]                 else {
[10:26:37.958]                   if (TRUE) {
[10:26:37.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:37.958]                     {
[10:26:37.958]                       inherits <- base::inherits
[10:26:37.958]                       invokeRestart <- base::invokeRestart
[10:26:37.958]                       is.null <- base::is.null
[10:26:37.958]                       muffled <- FALSE
[10:26:37.958]                       if (inherits(cond, "message")) {
[10:26:37.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:37.958]                         if (muffled) 
[10:26:37.958]                           invokeRestart("muffleMessage")
[10:26:37.958]                       }
[10:26:37.958]                       else if (inherits(cond, "warning")) {
[10:26:37.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:37.958]                         if (muffled) 
[10:26:37.958]                           invokeRestart("muffleWarning")
[10:26:37.958]                       }
[10:26:37.958]                       else if (inherits(cond, "condition")) {
[10:26:37.958]                         if (!is.null(pattern)) {
[10:26:37.958]                           computeRestarts <- base::computeRestarts
[10:26:37.958]                           grepl <- base::grepl
[10:26:37.958]                           restarts <- computeRestarts(cond)
[10:26:37.958]                           for (restart in restarts) {
[10:26:37.958]                             name <- restart$name
[10:26:37.958]                             if (is.null(name)) 
[10:26:37.958]                               next
[10:26:37.958]                             if (!grepl(pattern, name)) 
[10:26:37.958]                               next
[10:26:37.958]                             invokeRestart(restart)
[10:26:37.958]                             muffled <- TRUE
[10:26:37.958]                             break
[10:26:37.958]                           }
[10:26:37.958]                         }
[10:26:37.958]                       }
[10:26:37.958]                       invisible(muffled)
[10:26:37.958]                     }
[10:26:37.958]                     muffleCondition(cond, pattern = "^muffle")
[10:26:37.958]                   }
[10:26:37.958]                 }
[10:26:37.958]             }
[10:26:37.958]         }))
[10:26:37.958]     }, error = function(ex) {
[10:26:37.958]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:37.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:37.958]                 ...future.rng), started = ...future.startTime, 
[10:26:37.958]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:37.958]             version = "1.8"), class = "FutureResult")
[10:26:37.958]     }, finally = {
[10:26:37.958]         if (!identical(...future.workdir, getwd())) 
[10:26:37.958]             setwd(...future.workdir)
[10:26:37.958]         {
[10:26:37.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:37.958]                 ...future.oldOptions$nwarnings <- NULL
[10:26:37.958]             }
[10:26:37.958]             base::options(...future.oldOptions)
[10:26:37.958]             if (.Platform$OS.type == "windows") {
[10:26:37.958]                 old_names <- names(...future.oldEnvVars)
[10:26:37.958]                 envs <- base::Sys.getenv()
[10:26:37.958]                 names <- names(envs)
[10:26:37.958]                 common <- intersect(names, old_names)
[10:26:37.958]                 added <- setdiff(names, old_names)
[10:26:37.958]                 removed <- setdiff(old_names, names)
[10:26:37.958]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:37.958]                   envs[common]]
[10:26:37.958]                 NAMES <- toupper(changed)
[10:26:37.958]                 args <- list()
[10:26:37.958]                 for (kk in seq_along(NAMES)) {
[10:26:37.958]                   name <- changed[[kk]]
[10:26:37.958]                   NAME <- NAMES[[kk]]
[10:26:37.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.958]                     next
[10:26:37.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.958]                 }
[10:26:37.958]                 NAMES <- toupper(added)
[10:26:37.958]                 for (kk in seq_along(NAMES)) {
[10:26:37.958]                   name <- added[[kk]]
[10:26:37.958]                   NAME <- NAMES[[kk]]
[10:26:37.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.958]                     next
[10:26:37.958]                   args[[name]] <- ""
[10:26:37.958]                 }
[10:26:37.958]                 NAMES <- toupper(removed)
[10:26:37.958]                 for (kk in seq_along(NAMES)) {
[10:26:37.958]                   name <- removed[[kk]]
[10:26:37.958]                   NAME <- NAMES[[kk]]
[10:26:37.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:37.958]                     next
[10:26:37.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:37.958]                 }
[10:26:37.958]                 if (length(args) > 0) 
[10:26:37.958]                   base::do.call(base::Sys.setenv, args = args)
[10:26:37.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:37.958]             }
[10:26:37.958]             else {
[10:26:37.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:37.958]             }
[10:26:37.958]             {
[10:26:37.958]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:37.958]                   0L) {
[10:26:37.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:37.958]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:37.958]                   base::options(opts)
[10:26:37.958]                 }
[10:26:37.958]                 {
[10:26:37.958]                   {
[10:26:37.958]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:37.958]                     NULL
[10:26:37.958]                   }
[10:26:37.958]                   options(future.plan = NULL)
[10:26:37.958]                   if (is.na(NA_character_)) 
[10:26:37.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:37.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:37.958]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:37.958]                     envir = parent.frame()) 
[10:26:37.958]                   {
[10:26:37.958]                     default_workers <- missing(workers)
[10:26:37.958]                     if (is.function(workers)) 
[10:26:37.958]                       workers <- workers()
[10:26:37.958]                     workers <- structure(as.integer(workers), 
[10:26:37.958]                       class = class(workers))
[10:26:37.958]                     stop_if_not(is.finite(workers), workers >= 
[10:26:37.958]                       1L)
[10:26:37.958]                     if ((workers == 1L && !inherits(workers, 
[10:26:37.958]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:37.958]                       if (default_workers) 
[10:26:37.958]                         supportsMulticore(warn = TRUE)
[10:26:37.958]                       return(sequential(..., envir = envir))
[10:26:37.958]                     }
[10:26:37.958]                     oopts <- options(mc.cores = workers)
[10:26:37.958]                     on.exit(options(oopts))
[10:26:37.958]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:37.958]                       envir = envir)
[10:26:37.958]                     if (!future$lazy) 
[10:26:37.958]                       future <- run(future)
[10:26:37.958]                     invisible(future)
[10:26:37.958]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:37.958]                     envir = parent.frame()) 
[10:26:37.958]                   {
[10:26:37.958]                     default_workers <- missing(workers)
[10:26:37.958]                     if (is.function(workers)) 
[10:26:37.958]                       workers <- workers()
[10:26:37.958]                     workers <- structure(as.integer(workers), 
[10:26:37.958]                       class = class(workers))
[10:26:37.958]                     stop_if_not(is.finite(workers), workers >= 
[10:26:37.958]                       1L)
[10:26:37.958]                     if ((workers == 1L && !inherits(workers, 
[10:26:37.958]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:37.958]                       if (default_workers) 
[10:26:37.958]                         supportsMulticore(warn = TRUE)
[10:26:37.958]                       return(sequential(..., envir = envir))
[10:26:37.958]                     }
[10:26:37.958]                     oopts <- options(mc.cores = workers)
[10:26:37.958]                     on.exit(options(oopts))
[10:26:37.958]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:37.958]                       envir = envir)
[10:26:37.958]                     if (!future$lazy) 
[10:26:37.958]                       future <- run(future)
[10:26:37.958]                     invisible(future)
[10:26:37.958]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:37.958]                 }
[10:26:37.958]             }
[10:26:37.958]         }
[10:26:37.958]     })
[10:26:37.958]     if (TRUE) {
[10:26:37.958]         base::sink(type = "output", split = FALSE)
[10:26:37.958]         if (TRUE) {
[10:26:37.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:37.958]         }
[10:26:37.958]         else {
[10:26:37.958]             ...future.result["stdout"] <- base::list(NULL)
[10:26:37.958]         }
[10:26:37.958]         base::close(...future.stdout)
[10:26:37.958]         ...future.stdout <- NULL
[10:26:37.958]     }
[10:26:37.958]     ...future.result$conditions <- ...future.conditions
[10:26:37.958]     ...future.result$finished <- base::Sys.time()
[10:26:37.958]     ...future.result
[10:26:37.958] }
[10:26:37.961] assign_globals() ...
[10:26:37.961] List of 2
[10:26:37.961]  $ nested   :List of 2
[10:26:37.961]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:37.961]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:37.961]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:37.961]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:37.961]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:37.961]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:37.961]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:37.961]  $ strategy2: chr "multicore"
[10:26:37.961]  - attr(*, "where")=List of 2
[10:26:37.961]   ..$ nested   :<environment: R_EmptyEnv> 
[10:26:37.961]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:26:37.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:37.961]  - attr(*, "resolved")= logi FALSE
[10:26:37.961]  - attr(*, "total_size")= num 95304
[10:26:37.961]  - attr(*, "already-done")= logi TRUE
[10:26:37.967] - copied ‘nested’ to environment
[10:26:37.967] - copied ‘strategy2’ to environment
[10:26:37.967] assign_globals() ... done
[10:26:37.968] requestCore(): workers = 2
[10:26:37.970] MulticoreFuture started
[10:26:37.971] - Launch lazy future ... done
[10:26:37.971] run() for ‘MulticoreFuture’ ... done
[10:26:37.971] result() for MulticoreFuture ...
[10:26:37.972] plan(): Setting new future strategy stack:
[10:26:37.972] List of future strategies:
[10:26:37.972] 1. multicore:
[10:26:37.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:37.972]    - tweaked: FALSE
[10:26:37.972]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:37.978] plan(): nbrOfWorkers() = 1
[10:26:38.019] plan(): Setting new future strategy stack:
[10:26:38.019] List of future strategies:
[10:26:38.019] 1. multicore:
[10:26:38.019]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.019]    - tweaked: FALSE
[10:26:38.019]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.019] 2. multicore:
[10:26:38.019]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.019]    - tweaked: FALSE
[10:26:38.019]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.023] plan(): nbrOfWorkers() = 2
[10:26:38.024] result() for MulticoreFuture ...
[10:26:38.024] result() for MulticoreFuture ... done
[10:26:38.025] signalConditions() ...
[10:26:38.025]  - include = ‘immediateCondition’
[10:26:38.025]  - exclude = 
[10:26:38.025]  - resignal = FALSE
[10:26:38.025]  - Number of conditions: 54
[10:26:38.025] signalConditions() ... done
[10:26:38.025] result() for MulticoreFuture ... done
[10:26:38.026] result() for MulticoreFuture ...
[10:26:38.026] result() for MulticoreFuture ... done
[10:26:38.026] signalConditions() ...
[10:26:38.026]  - include = ‘immediateCondition’
[10:26:38.026]  - exclude = 
[10:26:38.026]  - resignal = FALSE
[10:26:38.026]  - Number of conditions: 54
[10:26:38.026] signalConditions() ... done
[10:26:38.027] Future state: ‘finished’
[10:26:38.027] result() for MulticoreFuture ...
[10:26:38.027] result() for MulticoreFuture ... done
[10:26:38.027] signalConditions() ...
[10:26:38.027]  - include = ‘condition’
[10:26:38.027]  - exclude = ‘immediateCondition’
[10:26:38.027]  - resignal = TRUE
[10:26:38.027]  - Number of conditions: 54
[10:26:38.028]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.980] getGlobalsAndPackages() ...
[10:26:38.028]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.980] Searching for globals...
[10:26:38.028]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.988] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:26:38.028]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.988] Searching for globals ... DONE
[10:26:38.028]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.989] Resolving globals: FALSE
[10:26:38.028]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.990] The total size of the 3 globals is 93.01 KiB (95240 bytes)
[10:26:38.029]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.990] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 93.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (46.48 KiB of class ‘list’), ‘plan_a’ (46.48 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:26:38.029]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.991] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:26:38.029]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.991] 
[10:26:38.029]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.991] getGlobalsAndPackages() ... DONE
[10:26:38.029]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.992] run() for ‘Future’ ...
[10:26:38.029]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.992] - state: ‘created’
[10:26:38.030]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.992] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.030]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:38.030]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:38.030]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.997]   - Field: ‘label’
[10:26:38.030]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.997]   - Field: ‘local’
[10:26:38.030]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.997]   - Field: ‘owner’
[10:26:38.031]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.997]   - Field: ‘envir’
[10:26:38.031]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.997]   - Field: ‘packages’
[10:26:38.031]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.998]   - Field: ‘gc’
[10:26:38.031]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.998]   - Field: ‘conditions’
[10:26:38.031]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.998]   - Field: ‘expr’
[10:26:38.031]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.998]   - Field: ‘uuid’
[10:26:38.031]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.998]   - Field: ‘seed’
[10:26:38.032]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.998]   - Field: ‘version’
[10:26:38.032]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.998]   - Field: ‘result’
[10:26:38.032]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.999]   - Field: ‘asynchronous’
[10:26:38.032]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.999]   - Field: ‘calls’
[10:26:38.032]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.999]   - Field: ‘globals’
[10:26:38.032]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.999]   - Field: ‘stdout’
[10:26:38.033]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.999]   - Field: ‘earlySignal’
[10:26:38.033]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:37.999]   - Field: ‘lazy’
[10:26:38.033]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.000]   - Field: ‘state’
[10:26:38.033]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:38.033]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.000] - Launch lazy future ...
[10:26:38.033]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.000] Packages needed by the future expression (n = 0): <none>
[10:26:38.033]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.000] Packages needed by future strategies (n = 0): <none>
[10:26:38.034]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.001] {
[10:26:38.001]     {
[10:26:38.001]         {
[10:26:38.001]             ...future.startTime <- base::Sys.time()
[10:26:38.001]             {
[10:26:38.001]                 {
[10:26:38.001]                   {
[10:26:38.001]                     base::local({
[10:26:38.001]                       has_future <- base::requireNamespace("future", 
[10:26:38.001]                         quietly = TRUE)
[10:26:38.001]                       if (has_future) {
[10:26:38.001]                         ns <- base::getNamespace("future")
[10:26:38.001]                         version <- ns[[".package"]][["version"]]
[10:26:38.001]                         if (is.null(version)) 
[10:26:38.001]                           version <- utils::packageVersion("future")
[10:26:38.001]                       }
[10:26:38.001]                       else {
[10:26:38.001]                         version <- NULL
[10:26:38.001]                       }
[10:26:38.001]                       if (!has_future || version < "1.8.0") {
[10:26:38.001]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.001]                           "", base::R.version$version.string), 
[10:26:38.001]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:38.001]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:38.001]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.001]                             "release", "version")], collapse = " "), 
[10:26:38.001]                           hostname = base::Sys.info()[["nodename"]])
[10:26:38.001]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.001]                           info)
[10:26:38.001]                         info <- base::paste(info, collapse = "; ")
[10:26:38.001]                         if (!has_future) {
[10:26:38.001]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.001]                             info)
[10:26:38.001]                         }
[10:26:38.001]                         else {
[10:26:38.001]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.001]                             info, version)
[10:26:38.001]                         }
[10:26:38.001]                         base::stop(msg)
[10:26:38.001]                       }
[10:26:38.001]                     })
[10:26:38.001]                   }
[10:26:38.001]                   options(future.plan = NULL)
[10:26:38.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:38.001]                 }
[10:26:38.001]                 ...future.workdir <- getwd()
[10:26:38.001]             }
[10:26:38.001]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.001]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.001]         }
[10:26:38.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.001]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.001]             base::names(...future.oldOptions))
[10:26:38.001]     }
[10:26:38.001]     if (FALSE) {
[10:26:38.001]     }
[10:26:38.001]     else {
[10:26:38.001]         if (TRUE) {
[10:26:38.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.001]                 open = "w")
[10:26:38.001]         }
[10:26:38.001]         else {
[10:26:38.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.001]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.001]         }
[10:26:38.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.001]             base::sink(type = "output", split = FALSE)
[10:26:38.001]             base::close(...future.stdout)
[10:26:38.001]         }, add = TRUE)
[10:26:38.001]     }
[10:26:38.001]     ...future.frame <- base::sys.nframe()
[10:26:38.001]     ...future.conditions <- base::list()
[10:26:38.001]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.001]     if (FALSE) {
[10:26:38.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.001]     }
[10:26:38.001]     ...future.result <- base::tryCatch({
[10:26:38.001]         base::withCallingHandlers({
[10:26:38.001]             ...future.value <- base::withVisible(base::local({
[10:26:38.001]                 b <- 2L
[10:26:38.001]                 plan_b <- future::plan("list")
[10:26:38.001]                 nested_b <- nested_a[-1]
[10:26:38.001]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:38.001]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:38.001]                   "sequential"))
[10:26:38.001]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:38.001]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:38.001]             }))
[10:26:38.001]             future::FutureResult(value = ...future.value$value, 
[10:26:38.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.001]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.001]                     ...future.globalenv.names))
[10:26:38.001]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.001]         }, condition = base::local({
[10:26:38.001]             c <- base::c
[10:26:38.001]             inherits <- base::inherits
[10:26:38.001]             invokeRestart <- base::invokeRestart
[10:26:38.001]             length <- base::length
[10:26:38.001]             list <- base::list
[10:26:38.001]             seq.int <- base::seq.int
[10:26:38.001]             signalCondition <- base::signalCondition
[10:26:38.001]             sys.calls <- base::sys.calls
[10:26:38.001]             `[[` <- base::`[[`
[10:26:38.001]             `+` <- base::`+`
[10:26:38.001]             `<<-` <- base::`<<-`
[10:26:38.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.001]                   3L)]
[10:26:38.001]             }
[10:26:38.001]             function(cond) {
[10:26:38.001]                 is_error <- inherits(cond, "error")
[10:26:38.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.001]                   NULL)
[10:26:38.001]                 if (is_error) {
[10:26:38.001]                   sessionInformation <- function() {
[10:26:38.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.001]                       search = base::search(), system = base::Sys.info())
[10:26:38.001]                   }
[10:26:38.001]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.001]                     cond$call), session = sessionInformation(), 
[10:26:38.001]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.001]                   signalCondition(cond)
[10:26:38.001]                 }
[10:26:38.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.001]                 "immediateCondition"))) {
[10:26:38.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.001]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.001]                   if (TRUE && !signal) {
[10:26:38.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.001]                     {
[10:26:38.001]                       inherits <- base::inherits
[10:26:38.001]                       invokeRestart <- base::invokeRestart
[10:26:38.001]                       is.null <- base::is.null
[10:26:38.001]                       muffled <- FALSE
[10:26:38.001]                       if (inherits(cond, "message")) {
[10:26:38.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.001]                         if (muffled) 
[10:26:38.001]                           invokeRestart("muffleMessage")
[10:26:38.001]                       }
[10:26:38.001]                       else if (inherits(cond, "warning")) {
[10:26:38.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.001]                         if (muffled) 
[10:26:38.001]                           invokeRestart("muffleWarning")
[10:26:38.001]                       }
[10:26:38.001]                       else if (inherits(cond, "condition")) {
[10:26:38.001]                         if (!is.null(pattern)) {
[10:26:38.001]                           computeRestarts <- base::computeRestarts
[10:26:38.001]                           grepl <- base::grepl
[10:26:38.001]                           restarts <- computeRestarts(cond)
[10:26:38.001]                           for (restart in restarts) {
[10:26:38.001]                             name <- restart$name
[10:26:38.001]                             if (is.null(name)) 
[10:26:38.001]                               next
[10:26:38.001]                             if (!grepl(pattern, name)) 
[10:26:38.001]                               next
[10:26:38.001]                             invokeRestart(restart)
[10:26:38.001]                             muffled <- TRUE
[10:26:38.001]                             break
[10:26:38.001]                           }
[10:26:38.001]                         }
[10:26:38.001]                       }
[10:26:38.001]                       invisible(muffled)
[10:26:38.001]                     }
[10:26:38.001]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.001]                   }
[10:26:38.001]                 }
[10:26:38.001]                 else {
[10:26:38.001]                   if (TRUE) {
[10:26:38.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.001]                     {
[10:26:38.001]                       inherits <- base::inherits
[10:26:38.001]                       invokeRestart <- base::invokeRestart
[10:26:38.001]                       is.null <- base::is.null
[10:26:38.001]                       muffled <- FALSE
[10:26:38.001]                       if (inherits(cond, "message")) {
[10:26:38.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.001]                         if (muffled) 
[10:26:38.001]                           invokeRestart("muffleMessage")
[10:26:38.001]                       }
[10:26:38.001]                       else if (inherits(cond, "warning")) {
[10:26:38.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.001]                         if (muffled) 
[10:26:38.001]                           invokeRestart("muffleWarning")
[10:26:38.001]                       }
[10:26:38.001]                       else if (inherits(cond, "condition")) {
[10:26:38.001]                         if (!is.null(pattern)) {
[10:26:38.001]                           computeRestarts <- base::computeRestarts
[10:26:38.001]                           grepl <- base::grepl
[10:26:38.001]                           restarts <- computeRestarts(cond)
[10:26:38.001]                           for (restart in restarts) {
[10:26:38.001]                             name <- restart$name
[10:26:38.001]                             if (is.null(name)) 
[10:26:38.001]                               next
[10:26:38.001]                             if (!grepl(pattern, name)) 
[10:26:38.001]                               next
[10:26:38.001]                             invokeRestart(restart)
[10:26:38.001]                             muffled <- TRUE
[10:26:38.001]                             break
[10:26:38.001]                           }
[10:26:38.001]                         }
[10:26:38.001]                       }
[10:26:38.001]                       invisible(muffled)
[10:26:38.001]                     }
[10:26:38.001]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.001]                   }
[10:26:38.001]                 }
[10:26:38.001]             }
[10:26:38.001]         }))
[10:26:38.001]     }, error = function(ex) {
[10:26:38.001]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.001]                 ...future.rng), started = ...future.startTime, 
[10:26:38.001]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.001]             version = "1.8"), class = "FutureResult")
[10:26:38.001]     }, finally = {
[10:26:38.001]         if (!identical(...future.workdir, getwd())) 
[10:26:38.001]             setwd(...future.workdir)
[10:26:38.001]         {
[10:26:38.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.001]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.001]             }
[10:26:38.001]             base::options(...future.oldOptions)
[10:26:38.001]             if (.Platform$OS.type == "windows") {
[10:26:38.001]                 old_names <- names(...future.oldEnvVars)
[10:26:38.001]                 envs <- base::Sys.getenv()
[10:26:38.001]                 names <- names(envs)
[10:26:38.001]                 common <- intersect(names, old_names)
[10:26:38.001]                 added <- setdiff(names, old_names)
[10:26:38.001]                 removed <- setdiff(old_names, names)
[10:26:38.001]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.001]                   envs[common]]
[10:26:38.001]                 NAMES <- toupper(changed)
[10:26:38.001]                 args <- list()
[10:26:38.001]                 for (kk in seq_along(NAMES)) {
[10:26:38.001]                   name <- changed[[kk]]
[10:26:38.001]                   NAME <- NAMES[[kk]]
[10:26:38.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.001]                     next
[10:26:38.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.001]                 }
[10:26:38.001]                 NAMES <- toupper(added)
[10:26:38.001]                 for (kk in seq_along(NAMES)) {
[10:26:38.001]                   name <- added[[kk]]
[10:26:38.001]                   NAME <- NAMES[[kk]]
[10:26:38.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.001]                     next
[10:26:38.001]                   args[[name]] <- ""
[10:26:38.001]                 }
[10:26:38.001]                 NAMES <- toupper(removed)
[10:26:38.001]                 for (kk in seq_along(NAMES)) {
[10:26:38.001]                   name <- removed[[kk]]
[10:26:38.001]                   NAME <- NAMES[[kk]]
[10:26:38.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.001]                     next
[10:26:38.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.001]                 }
[10:26:38.001]                 if (length(args) > 0) 
[10:26:38.001]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.001]             }
[10:26:38.001]             else {
[10:26:38.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.001]             }
[10:26:38.001]             {
[10:26:38.001]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.001]                   0L) {
[10:26:38.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.001]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.001]                   base::options(opts)
[10:26:38.001]                 }
[10:26:38.001]                 {
[10:26:38.001]                   {
[10:26:38.001]                     NULL
[10:26:38.001]                     RNGkind("Mersenne-Twister")
[10:26:38.001]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:38.001]                       inherits = FALSE)
[10:26:38.001]                   }
[10:26:38.001]                   options(future.plan = NULL)
[10:26:38.001]                   if (is.na(NA_character_)) 
[10:26:38.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.001]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:38.001]                     envir = parent.frame()) 
[10:26:38.001]                   {
[10:26:38.001]                     default_workers <- missing(workers)
[10:26:38.001]                     if (is.function(workers)) 
[10:26:38.001]                       workers <- workers()
[10:26:38.001]                     workers <- structure(as.integer(workers), 
[10:26:38.001]                       class = class(workers))
[10:26:38.001]                     stop_if_not(is.finite(workers), workers >= 
[10:26:38.001]                       1L)
[10:26:38.001]                     if ((workers == 1L && !inherits(workers, 
[10:26:38.001]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:38.001]                       if (default_workers) 
[10:26:38.001]                         supportsMulticore(warn = TRUE)
[10:26:38.001]                       return(sequential(..., envir = envir))
[10:26:38.001]                     }
[10:26:38.001]                     oopts <- options(mc.cores = workers)
[10:26:38.001]                     on.exit(options(oopts))
[10:26:38.001]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:38.001]                       envir = envir)
[10:26:38.001]                     if (!future$lazy) 
[10:26:38.001]                       future <- run(future)
[10:26:38.001]                     invisible(future)
[10:26:38.001]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.001]                 }
[10:26:38.001]             }
[10:26:38.001]         }
[10:26:38.001]     })
[10:26:38.001]     if (TRUE) {
[10:26:38.001]         base::sink(type = "output", split = FALSE)
[10:26:38.001]         if (TRUE) {
[10:26:38.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.001]         }
[10:26:38.001]         else {
[10:26:38.001]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.001]         }
[10:26:38.001]         base::close(...future.stdout)
[10:26:38.001]         ...future.stdout <- NULL
[10:26:38.001]     }
[10:26:38.001]     ...future.result$conditions <- ...future.conditions
[10:26:38.001]     ...future.result$finished <- base::Sys.time()
[10:26:38.001]     ...future.result
[10:26:38.001] }
[10:26:38.034]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.004] assign_globals() ...
[10:26:38.034]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.004] List of 3
[10:26:38.004]  $ nested_a:List of 1
[10:26:38.004]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:38.004]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:38.004]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:38.004]  $ a       : int 1
[10:26:38.004]  $ plan_a  :List of 1
[10:26:38.004]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:38.004]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:38.004]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:38.004]  - attr(*, "where")=List of 3
[10:26:38.004]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:26:38.004]   ..$ a       :<environment: R_EmptyEnv> 
[10:26:38.004]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:26:38.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:38.004]  - attr(*, "resolved")= logi FALSE
[10:26:38.004]  - attr(*, "total_size")= num 95240
[10:26:38.004]  - attr(*, "already-done")= logi TRUE
[10:26:38.034]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.011] - copied ‘nested_a’ to environment
[10:26:38.034]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.011] - copied ‘a’ to environment
[10:26:38.034]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.011] - copied ‘plan_a’ to environment
[10:26:38.035]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.011] assign_globals() ... done
[10:26:38.035]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.012] plan(): Setting new future strategy stack:
[10:26:38.035]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.012] List of future strategies:
[10:26:38.012] 1. sequential:
[10:26:38.012]    - args: function (..., envir = parent.frame())
[10:26:38.012]    - tweaked: FALSE
[10:26:38.012]    - call: NULL
[10:26:38.035]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.012] plan(): nbrOfWorkers() = 1
[10:26:38.035]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.013] plan(): Setting new future strategy stack:
[10:26:38.035]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.014] List of future strategies:
[10:26:38.014] 1. multicore:
[10:26:38.014]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.014]    - tweaked: FALSE
[10:26:38.014]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.036]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.017] plan(): nbrOfWorkers() = 1
[10:26:38.036]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.018] SequentialFuture started (and completed)
[10:26:38.036]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.018] - Launch lazy future ... done
[10:26:38.036]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.018] run() for ‘SequentialFuture’ ... done
[10:26:38.036] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:38.042] getGlobalsAndPackages() ...
[10:26:38.042] Searching for globals...
[10:26:38.044] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:38.044] Searching for globals ... DONE
[10:26:38.044] Resolving globals: FALSE
[10:26:38.045] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:38.046] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:38.046] - globals: [1] ‘data’
[10:26:38.046] - packages: [1] ‘future’
[10:26:38.046] getGlobalsAndPackages() ... DONE
[10:26:38.046] run() for ‘Future’ ...
[10:26:38.046] - state: ‘created’
[10:26:38.047] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.051] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:38.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:38.051]   - Field: ‘label’
[10:26:38.051]   - Field: ‘local’
[10:26:38.051]   - Field: ‘owner’
[10:26:38.051]   - Field: ‘envir’
[10:26:38.052]   - Field: ‘workers’
[10:26:38.052]   - Field: ‘packages’
[10:26:38.052]   - Field: ‘gc’
[10:26:38.052]   - Field: ‘job’
[10:26:38.052]   - Field: ‘conditions’
[10:26:38.052]   - Field: ‘expr’
[10:26:38.052]   - Field: ‘uuid’
[10:26:38.052]   - Field: ‘seed’
[10:26:38.052]   - Field: ‘version’
[10:26:38.053]   - Field: ‘result’
[10:26:38.053]   - Field: ‘asynchronous’
[10:26:38.053]   - Field: ‘calls’
[10:26:38.053]   - Field: ‘globals’
[10:26:38.053]   - Field: ‘stdout’
[10:26:38.053]   - Field: ‘earlySignal’
[10:26:38.053]   - Field: ‘lazy’
[10:26:38.053]   - Field: ‘state’
[10:26:38.053] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:38.054] - Launch lazy future ...
[10:26:38.054] Packages needed by the future expression (n = 1): ‘future’
[10:26:38.054] Packages needed by future strategies (n = 1): ‘future’
[10:26:38.055] {
[10:26:38.055]     {
[10:26:38.055]         {
[10:26:38.055]             ...future.startTime <- base::Sys.time()
[10:26:38.055]             {
[10:26:38.055]                 {
[10:26:38.055]                   {
[10:26:38.055]                     {
[10:26:38.055]                       {
[10:26:38.055]                         base::local({
[10:26:38.055]                           has_future <- base::requireNamespace("future", 
[10:26:38.055]                             quietly = TRUE)
[10:26:38.055]                           if (has_future) {
[10:26:38.055]                             ns <- base::getNamespace("future")
[10:26:38.055]                             version <- ns[[".package"]][["version"]]
[10:26:38.055]                             if (is.null(version)) 
[10:26:38.055]                               version <- utils::packageVersion("future")
[10:26:38.055]                           }
[10:26:38.055]                           else {
[10:26:38.055]                             version <- NULL
[10:26:38.055]                           }
[10:26:38.055]                           if (!has_future || version < "1.8.0") {
[10:26:38.055]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.055]                               "", base::R.version$version.string), 
[10:26:38.055]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:38.055]                                 base::R.version$platform, 8 * 
[10:26:38.055]                                   base::.Machine$sizeof.pointer), 
[10:26:38.055]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.055]                                 "release", "version")], collapse = " "), 
[10:26:38.055]                               hostname = base::Sys.info()[["nodename"]])
[10:26:38.055]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.055]                               info)
[10:26:38.055]                             info <- base::paste(info, collapse = "; ")
[10:26:38.055]                             if (!has_future) {
[10:26:38.055]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.055]                                 info)
[10:26:38.055]                             }
[10:26:38.055]                             else {
[10:26:38.055]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.055]                                 info, version)
[10:26:38.055]                             }
[10:26:38.055]                             base::stop(msg)
[10:26:38.055]                           }
[10:26:38.055]                         })
[10:26:38.055]                       }
[10:26:38.055]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:38.055]                       base::options(mc.cores = 1L)
[10:26:38.055]                     }
[10:26:38.055]                     base::local({
[10:26:38.055]                       for (pkg in "future") {
[10:26:38.055]                         base::loadNamespace(pkg)
[10:26:38.055]                         base::library(pkg, character.only = TRUE)
[10:26:38.055]                       }
[10:26:38.055]                     })
[10:26:38.055]                   }
[10:26:38.055]                   options(future.plan = NULL)
[10:26:38.055]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.055]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:38.055]                     envir = parent.frame()) 
[10:26:38.055]                   {
[10:26:38.055]                     default_workers <- missing(workers)
[10:26:38.055]                     if (is.function(workers)) 
[10:26:38.055]                       workers <- workers()
[10:26:38.055]                     workers <- structure(as.integer(workers), 
[10:26:38.055]                       class = class(workers))
[10:26:38.055]                     stop_if_not(is.finite(workers), workers >= 
[10:26:38.055]                       1L)
[10:26:38.055]                     if ((workers == 1L && !inherits(workers, 
[10:26:38.055]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:38.055]                       if (default_workers) 
[10:26:38.055]                         supportsMulticore(warn = TRUE)
[10:26:38.055]                       return(sequential(..., envir = envir))
[10:26:38.055]                     }
[10:26:38.055]                     oopts <- options(mc.cores = workers)
[10:26:38.055]                     on.exit(options(oopts))
[10:26:38.055]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:38.055]                       envir = envir)
[10:26:38.055]                     if (!future$lazy) 
[10:26:38.055]                       future <- run(future)
[10:26:38.055]                     invisible(future)
[10:26:38.055]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.055]                 }
[10:26:38.055]                 ...future.workdir <- getwd()
[10:26:38.055]             }
[10:26:38.055]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.055]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.055]         }
[10:26:38.055]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.055]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.055]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.055]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.055]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.055]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.055]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.055]             base::names(...future.oldOptions))
[10:26:38.055]     }
[10:26:38.055]     if (FALSE) {
[10:26:38.055]     }
[10:26:38.055]     else {
[10:26:38.055]         if (TRUE) {
[10:26:38.055]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.055]                 open = "w")
[10:26:38.055]         }
[10:26:38.055]         else {
[10:26:38.055]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.055]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.055]         }
[10:26:38.055]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.055]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.055]             base::sink(type = "output", split = FALSE)
[10:26:38.055]             base::close(...future.stdout)
[10:26:38.055]         }, add = TRUE)
[10:26:38.055]     }
[10:26:38.055]     ...future.frame <- base::sys.nframe()
[10:26:38.055]     ...future.conditions <- base::list()
[10:26:38.055]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.055]     if (FALSE) {
[10:26:38.055]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.055]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.055]     }
[10:26:38.055]     ...future.result <- base::tryCatch({
[10:26:38.055]         base::withCallingHandlers({
[10:26:38.055]             ...future.value <- base::withVisible(base::local({
[10:26:38.055]                 withCallingHandlers({
[10:26:38.055]                   {
[10:26:38.055]                     value(future(subset(data, a == 2)))
[10:26:38.055]                   }
[10:26:38.055]                 }, immediateCondition = function(cond) {
[10:26:38.055]                   save_rds <- function (object, pathname, ...) 
[10:26:38.055]                   {
[10:26:38.055]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:38.055]                     if (file_test("-f", pathname_tmp)) {
[10:26:38.055]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.055]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:38.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.055]                         fi_tmp[["mtime"]])
[10:26:38.055]                     }
[10:26:38.055]                     tryCatch({
[10:26:38.055]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:38.055]                     }, error = function(ex) {
[10:26:38.055]                       msg <- conditionMessage(ex)
[10:26:38.055]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.055]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:38.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.055]                         fi_tmp[["mtime"]], msg)
[10:26:38.055]                       ex$message <- msg
[10:26:38.055]                       stop(ex)
[10:26:38.055]                     })
[10:26:38.055]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:38.055]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:38.055]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:38.055]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.055]                       fi <- file.info(pathname)
[10:26:38.055]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:38.055]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.055]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:38.055]                         fi[["size"]], fi[["mtime"]])
[10:26:38.055]                       stop(msg)
[10:26:38.055]                     }
[10:26:38.055]                     invisible(pathname)
[10:26:38.055]                   }
[10:26:38.055]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:38.055]                     rootPath = tempdir()) 
[10:26:38.055]                   {
[10:26:38.055]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:38.055]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:38.055]                       tmpdir = path, fileext = ".rds")
[10:26:38.055]                     save_rds(obj, file)
[10:26:38.055]                   }
[10:26:38.055]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:38.055]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.055]                   {
[10:26:38.055]                     inherits <- base::inherits
[10:26:38.055]                     invokeRestart <- base::invokeRestart
[10:26:38.055]                     is.null <- base::is.null
[10:26:38.055]                     muffled <- FALSE
[10:26:38.055]                     if (inherits(cond, "message")) {
[10:26:38.055]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:38.055]                       if (muffled) 
[10:26:38.055]                         invokeRestart("muffleMessage")
[10:26:38.055]                     }
[10:26:38.055]                     else if (inherits(cond, "warning")) {
[10:26:38.055]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:38.055]                       if (muffled) 
[10:26:38.055]                         invokeRestart("muffleWarning")
[10:26:38.055]                     }
[10:26:38.055]                     else if (inherits(cond, "condition")) {
[10:26:38.055]                       if (!is.null(pattern)) {
[10:26:38.055]                         computeRestarts <- base::computeRestarts
[10:26:38.055]                         grepl <- base::grepl
[10:26:38.055]                         restarts <- computeRestarts(cond)
[10:26:38.055]                         for (restart in restarts) {
[10:26:38.055]                           name <- restart$name
[10:26:38.055]                           if (is.null(name)) 
[10:26:38.055]                             next
[10:26:38.055]                           if (!grepl(pattern, name)) 
[10:26:38.055]                             next
[10:26:38.055]                           invokeRestart(restart)
[10:26:38.055]                           muffled <- TRUE
[10:26:38.055]                           break
[10:26:38.055]                         }
[10:26:38.055]                       }
[10:26:38.055]                     }
[10:26:38.055]                     invisible(muffled)
[10:26:38.055]                   }
[10:26:38.055]                   muffleCondition(cond)
[10:26:38.055]                 })
[10:26:38.055]             }))
[10:26:38.055]             future::FutureResult(value = ...future.value$value, 
[10:26:38.055]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.055]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.055]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.055]                     ...future.globalenv.names))
[10:26:38.055]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.055]         }, condition = base::local({
[10:26:38.055]             c <- base::c
[10:26:38.055]             inherits <- base::inherits
[10:26:38.055]             invokeRestart <- base::invokeRestart
[10:26:38.055]             length <- base::length
[10:26:38.055]             list <- base::list
[10:26:38.055]             seq.int <- base::seq.int
[10:26:38.055]             signalCondition <- base::signalCondition
[10:26:38.055]             sys.calls <- base::sys.calls
[10:26:38.055]             `[[` <- base::`[[`
[10:26:38.055]             `+` <- base::`+`
[10:26:38.055]             `<<-` <- base::`<<-`
[10:26:38.055]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.055]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.055]                   3L)]
[10:26:38.055]             }
[10:26:38.055]             function(cond) {
[10:26:38.055]                 is_error <- inherits(cond, "error")
[10:26:38.055]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.055]                   NULL)
[10:26:38.055]                 if (is_error) {
[10:26:38.055]                   sessionInformation <- function() {
[10:26:38.055]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.055]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.055]                       search = base::search(), system = base::Sys.info())
[10:26:38.055]                   }
[10:26:38.055]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.055]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.055]                     cond$call), session = sessionInformation(), 
[10:26:38.055]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.055]                   signalCondition(cond)
[10:26:38.055]                 }
[10:26:38.055]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.055]                 "immediateCondition"))) {
[10:26:38.055]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.055]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.055]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.055]                   if (TRUE && !signal) {
[10:26:38.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.055]                     {
[10:26:38.055]                       inherits <- base::inherits
[10:26:38.055]                       invokeRestart <- base::invokeRestart
[10:26:38.055]                       is.null <- base::is.null
[10:26:38.055]                       muffled <- FALSE
[10:26:38.055]                       if (inherits(cond, "message")) {
[10:26:38.055]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.055]                         if (muffled) 
[10:26:38.055]                           invokeRestart("muffleMessage")
[10:26:38.055]                       }
[10:26:38.055]                       else if (inherits(cond, "warning")) {
[10:26:38.055]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.055]                         if (muffled) 
[10:26:38.055]                           invokeRestart("muffleWarning")
[10:26:38.055]                       }
[10:26:38.055]                       else if (inherits(cond, "condition")) {
[10:26:38.055]                         if (!is.null(pattern)) {
[10:26:38.055]                           computeRestarts <- base::computeRestarts
[10:26:38.055]                           grepl <- base::grepl
[10:26:38.055]                           restarts <- computeRestarts(cond)
[10:26:38.055]                           for (restart in restarts) {
[10:26:38.055]                             name <- restart$name
[10:26:38.055]                             if (is.null(name)) 
[10:26:38.055]                               next
[10:26:38.055]                             if (!grepl(pattern, name)) 
[10:26:38.055]                               next
[10:26:38.055]                             invokeRestart(restart)
[10:26:38.055]                             muffled <- TRUE
[10:26:38.055]                             break
[10:26:38.055]                           }
[10:26:38.055]                         }
[10:26:38.055]                       }
[10:26:38.055]                       invisible(muffled)
[10:26:38.055]                     }
[10:26:38.055]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.055]                   }
[10:26:38.055]                 }
[10:26:38.055]                 else {
[10:26:38.055]                   if (TRUE) {
[10:26:38.055]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.055]                     {
[10:26:38.055]                       inherits <- base::inherits
[10:26:38.055]                       invokeRestart <- base::invokeRestart
[10:26:38.055]                       is.null <- base::is.null
[10:26:38.055]                       muffled <- FALSE
[10:26:38.055]                       if (inherits(cond, "message")) {
[10:26:38.055]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.055]                         if (muffled) 
[10:26:38.055]                           invokeRestart("muffleMessage")
[10:26:38.055]                       }
[10:26:38.055]                       else if (inherits(cond, "warning")) {
[10:26:38.055]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.055]                         if (muffled) 
[10:26:38.055]                           invokeRestart("muffleWarning")
[10:26:38.055]                       }
[10:26:38.055]                       else if (inherits(cond, "condition")) {
[10:26:38.055]                         if (!is.null(pattern)) {
[10:26:38.055]                           computeRestarts <- base::computeRestarts
[10:26:38.055]                           grepl <- base::grepl
[10:26:38.055]                           restarts <- computeRestarts(cond)
[10:26:38.055]                           for (restart in restarts) {
[10:26:38.055]                             name <- restart$name
[10:26:38.055]                             if (is.null(name)) 
[10:26:38.055]                               next
[10:26:38.055]                             if (!grepl(pattern, name)) 
[10:26:38.055]                               next
[10:26:38.055]                             invokeRestart(restart)
[10:26:38.055]                             muffled <- TRUE
[10:26:38.055]                             break
[10:26:38.055]                           }
[10:26:38.055]                         }
[10:26:38.055]                       }
[10:26:38.055]                       invisible(muffled)
[10:26:38.055]                     }
[10:26:38.055]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.055]                   }
[10:26:38.055]                 }
[10:26:38.055]             }
[10:26:38.055]         }))
[10:26:38.055]     }, error = function(ex) {
[10:26:38.055]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.055]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.055]                 ...future.rng), started = ...future.startTime, 
[10:26:38.055]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.055]             version = "1.8"), class = "FutureResult")
[10:26:38.055]     }, finally = {
[10:26:38.055]         if (!identical(...future.workdir, getwd())) 
[10:26:38.055]             setwd(...future.workdir)
[10:26:38.055]         {
[10:26:38.055]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.055]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.055]             }
[10:26:38.055]             base::options(...future.oldOptions)
[10:26:38.055]             if (.Platform$OS.type == "windows") {
[10:26:38.055]                 old_names <- names(...future.oldEnvVars)
[10:26:38.055]                 envs <- base::Sys.getenv()
[10:26:38.055]                 names <- names(envs)
[10:26:38.055]                 common <- intersect(names, old_names)
[10:26:38.055]                 added <- setdiff(names, old_names)
[10:26:38.055]                 removed <- setdiff(old_names, names)
[10:26:38.055]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.055]                   envs[common]]
[10:26:38.055]                 NAMES <- toupper(changed)
[10:26:38.055]                 args <- list()
[10:26:38.055]                 for (kk in seq_along(NAMES)) {
[10:26:38.055]                   name <- changed[[kk]]
[10:26:38.055]                   NAME <- NAMES[[kk]]
[10:26:38.055]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.055]                     next
[10:26:38.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.055]                 }
[10:26:38.055]                 NAMES <- toupper(added)
[10:26:38.055]                 for (kk in seq_along(NAMES)) {
[10:26:38.055]                   name <- added[[kk]]
[10:26:38.055]                   NAME <- NAMES[[kk]]
[10:26:38.055]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.055]                     next
[10:26:38.055]                   args[[name]] <- ""
[10:26:38.055]                 }
[10:26:38.055]                 NAMES <- toupper(removed)
[10:26:38.055]                 for (kk in seq_along(NAMES)) {
[10:26:38.055]                   name <- removed[[kk]]
[10:26:38.055]                   NAME <- NAMES[[kk]]
[10:26:38.055]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.055]                     next
[10:26:38.055]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.055]                 }
[10:26:38.055]                 if (length(args) > 0) 
[10:26:38.055]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.055]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.055]             }
[10:26:38.055]             else {
[10:26:38.055]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.055]             }
[10:26:38.055]             {
[10:26:38.055]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.055]                   0L) {
[10:26:38.055]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.055]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.055]                   base::options(opts)
[10:26:38.055]                 }
[10:26:38.055]                 {
[10:26:38.055]                   {
[10:26:38.055]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:38.055]                     NULL
[10:26:38.055]                   }
[10:26:38.055]                   options(future.plan = NULL)
[10:26:38.055]                   if (is.na(NA_character_)) 
[10:26:38.055]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.055]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.055]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:38.055]                     envir = parent.frame()) 
[10:26:38.055]                   {
[10:26:38.055]                     default_workers <- missing(workers)
[10:26:38.055]                     if (is.function(workers)) 
[10:26:38.055]                       workers <- workers()
[10:26:38.055]                     workers <- structure(as.integer(workers), 
[10:26:38.055]                       class = class(workers))
[10:26:38.055]                     stop_if_not(is.finite(workers), workers >= 
[10:26:38.055]                       1L)
[10:26:38.055]                     if ((workers == 1L && !inherits(workers, 
[10:26:38.055]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:38.055]                       if (default_workers) 
[10:26:38.055]                         supportsMulticore(warn = TRUE)
[10:26:38.055]                       return(sequential(..., envir = envir))
[10:26:38.055]                     }
[10:26:38.055]                     oopts <- options(mc.cores = workers)
[10:26:38.055]                     on.exit(options(oopts))
[10:26:38.055]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:38.055]                       envir = envir)
[10:26:38.055]                     if (!future$lazy) 
[10:26:38.055]                       future <- run(future)
[10:26:38.055]                     invisible(future)
[10:26:38.055]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:38.055]                     envir = parent.frame()) 
[10:26:38.055]                   {
[10:26:38.055]                     default_workers <- missing(workers)
[10:26:38.055]                     if (is.function(workers)) 
[10:26:38.055]                       workers <- workers()
[10:26:38.055]                     workers <- structure(as.integer(workers), 
[10:26:38.055]                       class = class(workers))
[10:26:38.055]                     stop_if_not(is.finite(workers), workers >= 
[10:26:38.055]                       1L)
[10:26:38.055]                     if ((workers == 1L && !inherits(workers, 
[10:26:38.055]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:38.055]                       if (default_workers) 
[10:26:38.055]                         supportsMulticore(warn = TRUE)
[10:26:38.055]                       return(sequential(..., envir = envir))
[10:26:38.055]                     }
[10:26:38.055]                     oopts <- options(mc.cores = workers)
[10:26:38.055]                     on.exit(options(oopts))
[10:26:38.055]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:38.055]                       envir = envir)
[10:26:38.055]                     if (!future$lazy) 
[10:26:38.055]                       future <- run(future)
[10:26:38.055]                     invisible(future)
[10:26:38.055]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.055]                 }
[10:26:38.055]             }
[10:26:38.055]         }
[10:26:38.055]     })
[10:26:38.055]     if (TRUE) {
[10:26:38.055]         base::sink(type = "output", split = FALSE)
[10:26:38.055]         if (TRUE) {
[10:26:38.055]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.055]         }
[10:26:38.055]         else {
[10:26:38.055]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.055]         }
[10:26:38.055]         base::close(...future.stdout)
[10:26:38.055]         ...future.stdout <- NULL
[10:26:38.055]     }
[10:26:38.055]     ...future.result$conditions <- ...future.conditions
[10:26:38.055]     ...future.result$finished <- base::Sys.time()
[10:26:38.055]     ...future.result
[10:26:38.055] }
[10:26:38.058] assign_globals() ...
[10:26:38.058] List of 1
[10:26:38.058]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:38.058]   ..$ a: int [1:3] 1 2 3
[10:26:38.058]   ..$ b: int [1:3] 3 2 1
[10:26:38.058]  - attr(*, "where")=List of 1
[10:26:38.058]   ..$ data:<environment: R_EmptyEnv> 
[10:26:38.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:38.058]  - attr(*, "resolved")= logi FALSE
[10:26:38.058]  - attr(*, "total_size")= num 128
[10:26:38.058]  - attr(*, "already-done")= logi TRUE
[10:26:38.062] - copied ‘data’ to environment
[10:26:38.062] assign_globals() ... done
[10:26:38.062] requestCore(): workers = 2
[10:26:38.064] MulticoreFuture started
[10:26:38.065] - Launch lazy future ... done
[10:26:38.065] run() for ‘MulticoreFuture’ ... done
[10:26:38.065] result() for MulticoreFuture ...
[10:26:38.066] plan(): Setting new future strategy stack:
[10:26:38.066] List of future strategies:
[10:26:38.066] 1. multicore:
[10:26:38.066]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.066]    - tweaked: FALSE
[10:26:38.066]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.072] plan(): nbrOfWorkers() = 1
[10:26:38.107] plan(): Setting new future strategy stack:
[10:26:38.108] List of future strategies:
[10:26:38.108] 1. multicore:
[10:26:38.108]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.108]    - tweaked: FALSE
[10:26:38.108]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.108] 2. multicore:
[10:26:38.108]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.108]    - tweaked: FALSE
[10:26:38.108]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.112] plan(): nbrOfWorkers() = 2
[10:26:38.113] result() for MulticoreFuture ...
[10:26:38.113] result() for MulticoreFuture ... done
[10:26:38.113] signalConditions() ...
[10:26:38.113]  - include = ‘immediateCondition’
[10:26:38.113]  - exclude = 
[10:26:38.113]  - resignal = FALSE
[10:26:38.113]  - Number of conditions: 52
[10:26:38.114] signalConditions() ... done
[10:26:38.114] result() for MulticoreFuture ... done
[10:26:38.114] result() for MulticoreFuture ...
[10:26:38.114] result() for MulticoreFuture ... done
[10:26:38.114] signalConditions() ...
[10:26:38.114]  - include = ‘immediateCondition’
[10:26:38.114]  - exclude = 
[10:26:38.114]  - resignal = FALSE
[10:26:38.114]  - Number of conditions: 52
[10:26:38.115] signalConditions() ... done
[10:26:38.115] Future state: ‘finished’
[10:26:38.115] result() for MulticoreFuture ...
[10:26:38.115] result() for MulticoreFuture ... done
[10:26:38.115] signalConditions() ...
[10:26:38.115]  - include = ‘condition’
[10:26:38.115]  - exclude = ‘immediateCondition’
[10:26:38.115]  - resignal = TRUE
[10:26:38.116]  - Number of conditions: 52
[10:26:38.116]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.072] getGlobalsAndPackages() ...
[10:26:38.116]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.073] Searching for globals...
[10:26:38.116]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.074] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:38.116]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.075] Searching for globals ... DONE
[10:26:38.116]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.075] Resolving globals: FALSE
[10:26:38.117]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.076] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:38.117]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.076] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:38.117]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.077] - globals: [1] ‘data’
[10:26:38.117]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.077] 
[10:26:38.117]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.077] getGlobalsAndPackages() ... DONE
[10:26:38.117]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.078] run() for ‘Future’ ...
[10:26:38.117]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.078] - state: ‘created’
[10:26:38.118]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.078] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.118]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.082] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:38.118]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:38.118]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.083]   - Field: ‘label’
[10:26:38.118]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.083]   - Field: ‘local’
[10:26:38.118]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.083]   - Field: ‘owner’
[10:26:38.119]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.083]   - Field: ‘envir’
[10:26:38.119]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.083]   - Field: ‘packages’
[10:26:38.119]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.083]   - Field: ‘gc’
[10:26:38.119]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.084]   - Field: ‘conditions’
[10:26:38.119]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.084]   - Field: ‘expr’
[10:26:38.119]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.084]   - Field: ‘uuid’
[10:26:38.120]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.084]   - Field: ‘seed’
[10:26:38.120]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.084]   - Field: ‘version’
[10:26:38.120]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.084]   - Field: ‘result’
[10:26:38.120]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.085]   - Field: ‘asynchronous’
[10:26:38.120]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.085]   - Field: ‘calls’
[10:26:38.120]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.085]   - Field: ‘globals’
[10:26:38.120]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.085]   - Field: ‘stdout’
[10:26:38.121]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.085]   - Field: ‘earlySignal’
[10:26:38.121]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.085]   - Field: ‘lazy’
[10:26:38.121]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.086]   - Field: ‘state’
[10:26:38.121]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:38.121]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.086] - Launch lazy future ...
[10:26:38.121]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.086] Packages needed by the future expression (n = 0): <none>
[10:26:38.122]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.086] Packages needed by future strategies (n = 0): <none>
[10:26:38.122]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.087] {
[10:26:38.087]     {
[10:26:38.087]         {
[10:26:38.087]             ...future.startTime <- base::Sys.time()
[10:26:38.087]             {
[10:26:38.087]                 {
[10:26:38.087]                   {
[10:26:38.087]                     base::local({
[10:26:38.087]                       has_future <- base::requireNamespace("future", 
[10:26:38.087]                         quietly = TRUE)
[10:26:38.087]                       if (has_future) {
[10:26:38.087]                         ns <- base::getNamespace("future")
[10:26:38.087]                         version <- ns[[".package"]][["version"]]
[10:26:38.087]                         if (is.null(version)) 
[10:26:38.087]                           version <- utils::packageVersion("future")
[10:26:38.087]                       }
[10:26:38.087]                       else {
[10:26:38.087]                         version <- NULL
[10:26:38.087]                       }
[10:26:38.087]                       if (!has_future || version < "1.8.0") {
[10:26:38.087]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.087]                           "", base::R.version$version.string), 
[10:26:38.087]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:38.087]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:38.087]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.087]                             "release", "version")], collapse = " "), 
[10:26:38.087]                           hostname = base::Sys.info()[["nodename"]])
[10:26:38.087]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.087]                           info)
[10:26:38.087]                         info <- base::paste(info, collapse = "; ")
[10:26:38.087]                         if (!has_future) {
[10:26:38.087]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.087]                             info)
[10:26:38.087]                         }
[10:26:38.087]                         else {
[10:26:38.087]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.087]                             info, version)
[10:26:38.087]                         }
[10:26:38.087]                         base::stop(msg)
[10:26:38.087]                       }
[10:26:38.087]                     })
[10:26:38.087]                   }
[10:26:38.087]                   options(future.plan = NULL)
[10:26:38.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:38.087]                 }
[10:26:38.087]                 ...future.workdir <- getwd()
[10:26:38.087]             }
[10:26:38.087]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.087]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.087]         }
[10:26:38.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.087]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.087]             base::names(...future.oldOptions))
[10:26:38.087]     }
[10:26:38.087]     if (FALSE) {
[10:26:38.087]     }
[10:26:38.087]     else {
[10:26:38.087]         if (TRUE) {
[10:26:38.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.087]                 open = "w")
[10:26:38.087]         }
[10:26:38.087]         else {
[10:26:38.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.087]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.087]         }
[10:26:38.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.087]             base::sink(type = "output", split = FALSE)
[10:26:38.087]             base::close(...future.stdout)
[10:26:38.087]         }, add = TRUE)
[10:26:38.087]     }
[10:26:38.087]     ...future.frame <- base::sys.nframe()
[10:26:38.087]     ...future.conditions <- base::list()
[10:26:38.087]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.087]     if (FALSE) {
[10:26:38.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.087]     }
[10:26:38.087]     ...future.result <- base::tryCatch({
[10:26:38.087]         base::withCallingHandlers({
[10:26:38.087]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:26:38.087]                 a == 2)))
[10:26:38.087]             future::FutureResult(value = ...future.value$value, 
[10:26:38.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.087]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.087]                     ...future.globalenv.names))
[10:26:38.087]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.087]         }, condition = base::local({
[10:26:38.087]             c <- base::c
[10:26:38.087]             inherits <- base::inherits
[10:26:38.087]             invokeRestart <- base::invokeRestart
[10:26:38.087]             length <- base::length
[10:26:38.087]             list <- base::list
[10:26:38.087]             seq.int <- base::seq.int
[10:26:38.087]             signalCondition <- base::signalCondition
[10:26:38.087]             sys.calls <- base::sys.calls
[10:26:38.087]             `[[` <- base::`[[`
[10:26:38.087]             `+` <- base::`+`
[10:26:38.087]             `<<-` <- base::`<<-`
[10:26:38.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.087]                   3L)]
[10:26:38.087]             }
[10:26:38.087]             function(cond) {
[10:26:38.087]                 is_error <- inherits(cond, "error")
[10:26:38.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.087]                   NULL)
[10:26:38.087]                 if (is_error) {
[10:26:38.087]                   sessionInformation <- function() {
[10:26:38.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.087]                       search = base::search(), system = base::Sys.info())
[10:26:38.087]                   }
[10:26:38.087]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.087]                     cond$call), session = sessionInformation(), 
[10:26:38.087]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.087]                   signalCondition(cond)
[10:26:38.087]                 }
[10:26:38.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.087]                 "immediateCondition"))) {
[10:26:38.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.087]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.087]                   if (TRUE && !signal) {
[10:26:38.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.087]                     {
[10:26:38.087]                       inherits <- base::inherits
[10:26:38.087]                       invokeRestart <- base::invokeRestart
[10:26:38.087]                       is.null <- base::is.null
[10:26:38.087]                       muffled <- FALSE
[10:26:38.087]                       if (inherits(cond, "message")) {
[10:26:38.087]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.087]                         if (muffled) 
[10:26:38.087]                           invokeRestart("muffleMessage")
[10:26:38.087]                       }
[10:26:38.087]                       else if (inherits(cond, "warning")) {
[10:26:38.087]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.087]                         if (muffled) 
[10:26:38.087]                           invokeRestart("muffleWarning")
[10:26:38.087]                       }
[10:26:38.087]                       else if (inherits(cond, "condition")) {
[10:26:38.087]                         if (!is.null(pattern)) {
[10:26:38.087]                           computeRestarts <- base::computeRestarts
[10:26:38.087]                           grepl <- base::grepl
[10:26:38.087]                           restarts <- computeRestarts(cond)
[10:26:38.087]                           for (restart in restarts) {
[10:26:38.087]                             name <- restart$name
[10:26:38.087]                             if (is.null(name)) 
[10:26:38.087]                               next
[10:26:38.087]                             if (!grepl(pattern, name)) 
[10:26:38.087]                               next
[10:26:38.087]                             invokeRestart(restart)
[10:26:38.087]                             muffled <- TRUE
[10:26:38.087]                             break
[10:26:38.087]                           }
[10:26:38.087]                         }
[10:26:38.087]                       }
[10:26:38.087]                       invisible(muffled)
[10:26:38.087]                     }
[10:26:38.087]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.087]                   }
[10:26:38.087]                 }
[10:26:38.087]                 else {
[10:26:38.087]                   if (TRUE) {
[10:26:38.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.087]                     {
[10:26:38.087]                       inherits <- base::inherits
[10:26:38.087]                       invokeRestart <- base::invokeRestart
[10:26:38.087]                       is.null <- base::is.null
[10:26:38.087]                       muffled <- FALSE
[10:26:38.087]                       if (inherits(cond, "message")) {
[10:26:38.087]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.087]                         if (muffled) 
[10:26:38.087]                           invokeRestart("muffleMessage")
[10:26:38.087]                       }
[10:26:38.087]                       else if (inherits(cond, "warning")) {
[10:26:38.087]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.087]                         if (muffled) 
[10:26:38.087]                           invokeRestart("muffleWarning")
[10:26:38.087]                       }
[10:26:38.087]                       else if (inherits(cond, "condition")) {
[10:26:38.087]                         if (!is.null(pattern)) {
[10:26:38.087]                           computeRestarts <- base::computeRestarts
[10:26:38.087]                           grepl <- base::grepl
[10:26:38.087]                           restarts <- computeRestarts(cond)
[10:26:38.087]                           for (restart in restarts) {
[10:26:38.087]                             name <- restart$name
[10:26:38.087]                             if (is.null(name)) 
[10:26:38.087]                               next
[10:26:38.087]                             if (!grepl(pattern, name)) 
[10:26:38.087]                               next
[10:26:38.087]                             invokeRestart(restart)
[10:26:38.087]                             muffled <- TRUE
[10:26:38.087]                             break
[10:26:38.087]                           }
[10:26:38.087]                         }
[10:26:38.087]                       }
[10:26:38.087]                       invisible(muffled)
[10:26:38.087]                     }
[10:26:38.087]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.087]                   }
[10:26:38.087]                 }
[10:26:38.087]             }
[10:26:38.087]         }))
[10:26:38.087]     }, error = function(ex) {
[10:26:38.087]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.087]                 ...future.rng), started = ...future.startTime, 
[10:26:38.087]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.087]             version = "1.8"), class = "FutureResult")
[10:26:38.087]     }, finally = {
[10:26:38.087]         if (!identical(...future.workdir, getwd())) 
[10:26:38.087]             setwd(...future.workdir)
[10:26:38.087]         {
[10:26:38.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.087]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.087]             }
[10:26:38.087]             base::options(...future.oldOptions)
[10:26:38.087]             if (.Platform$OS.type == "windows") {
[10:26:38.087]                 old_names <- names(...future.oldEnvVars)
[10:26:38.087]                 envs <- base::Sys.getenv()
[10:26:38.087]                 names <- names(envs)
[10:26:38.087]                 common <- intersect(names, old_names)
[10:26:38.087]                 added <- setdiff(names, old_names)
[10:26:38.087]                 removed <- setdiff(old_names, names)
[10:26:38.087]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.087]                   envs[common]]
[10:26:38.087]                 NAMES <- toupper(changed)
[10:26:38.087]                 args <- list()
[10:26:38.087]                 for (kk in seq_along(NAMES)) {
[10:26:38.087]                   name <- changed[[kk]]
[10:26:38.087]                   NAME <- NAMES[[kk]]
[10:26:38.087]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.087]                     next
[10:26:38.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.087]                 }
[10:26:38.087]                 NAMES <- toupper(added)
[10:26:38.087]                 for (kk in seq_along(NAMES)) {
[10:26:38.087]                   name <- added[[kk]]
[10:26:38.087]                   NAME <- NAMES[[kk]]
[10:26:38.087]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.087]                     next
[10:26:38.087]                   args[[name]] <- ""
[10:26:38.087]                 }
[10:26:38.087]                 NAMES <- toupper(removed)
[10:26:38.087]                 for (kk in seq_along(NAMES)) {
[10:26:38.087]                   name <- removed[[kk]]
[10:26:38.087]                   NAME <- NAMES[[kk]]
[10:26:38.087]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.087]                     next
[10:26:38.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.087]                 }
[10:26:38.087]                 if (length(args) > 0) 
[10:26:38.087]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.087]             }
[10:26:38.087]             else {
[10:26:38.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.087]             }
[10:26:38.087]             {
[10:26:38.087]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.087]                   0L) {
[10:26:38.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.087]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.087]                   base::options(opts)
[10:26:38.087]                 }
[10:26:38.087]                 {
[10:26:38.087]                   {
[10:26:38.087]                     NULL
[10:26:38.087]                     RNGkind("Mersenne-Twister")
[10:26:38.087]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:38.087]                       inherits = FALSE)
[10:26:38.087]                   }
[10:26:38.087]                   options(future.plan = NULL)
[10:26:38.087]                   if (is.na(NA_character_)) 
[10:26:38.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.087]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:38.087]                     envir = parent.frame()) 
[10:26:38.087]                   {
[10:26:38.087]                     default_workers <- missing(workers)
[10:26:38.087]                     if (is.function(workers)) 
[10:26:38.087]                       workers <- workers()
[10:26:38.087]                     workers <- structure(as.integer(workers), 
[10:26:38.087]                       class = class(workers))
[10:26:38.087]                     stop_if_not(is.finite(workers), workers >= 
[10:26:38.087]                       1L)
[10:26:38.087]                     if ((workers == 1L && !inherits(workers, 
[10:26:38.087]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:38.087]                       if (default_workers) 
[10:26:38.087]                         supportsMulticore(warn = TRUE)
[10:26:38.087]                       return(sequential(..., envir = envir))
[10:26:38.087]                     }
[10:26:38.087]                     oopts <- options(mc.cores = workers)
[10:26:38.087]                     on.exit(options(oopts))
[10:26:38.087]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:38.087]                       envir = envir)
[10:26:38.087]                     if (!future$lazy) 
[10:26:38.087]                       future <- run(future)
[10:26:38.087]                     invisible(future)
[10:26:38.087]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.087]                 }
[10:26:38.087]             }
[10:26:38.087]         }
[10:26:38.087]     })
[10:26:38.087]     if (TRUE) {
[10:26:38.087]         base::sink(type = "output", split = FALSE)
[10:26:38.087]         if (TRUE) {
[10:26:38.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.087]         }
[10:26:38.087]         else {
[10:26:38.087]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.087]         }
[10:26:38.087]         base::close(...future.stdout)
[10:26:38.087]         ...future.stdout <- NULL
[10:26:38.087]     }
[10:26:38.087]     ...future.result$conditions <- ...future.conditions
[10:26:38.087]     ...future.result$finished <- base::Sys.time()
[10:26:38.087]     ...future.result
[10:26:38.087] }
[10:26:38.122]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.089] assign_globals() ...
[10:26:38.122]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.090] List of 1
[10:26:38.090]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:38.090]   ..$ a: int [1:3] 1 2 3
[10:26:38.090]   ..$ b: int [1:3] 3 2 1
[10:26:38.090]  - attr(*, "where")=List of 1
[10:26:38.090]   ..$ data:<environment: R_EmptyEnv> 
[10:26:38.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:38.090]  - attr(*, "resolved")= logi FALSE
[10:26:38.090]  - attr(*, "total_size")= num 128
[10:26:38.090]  - attr(*, "already-done")= logi TRUE
[10:26:38.122]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.099] - copied ‘data’ to environment
[10:26:38.122]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.100] assign_globals() ... done
[10:26:38.123]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.100] plan(): Setting new future strategy stack:
[10:26:38.123]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.100] List of future strategies:
[10:26:38.100] 1. sequential:
[10:26:38.100]    - args: function (..., envir = parent.frame())
[10:26:38.100]    - tweaked: FALSE
[10:26:38.100]    - call: NULL
[10:26:38.123]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.101] plan(): nbrOfWorkers() = 1
[10:26:38.123]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.102] plan(): Setting new future strategy stack:
[10:26:38.123]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.102] List of future strategies:
[10:26:38.102] 1. multicore:
[10:26:38.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.102]    - tweaked: FALSE
[10:26:38.102]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.123]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.106] plan(): nbrOfWorkers() = 1
[10:26:38.123]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.106] SequentialFuture started (and completed)
[10:26:38.124]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.107] - Launch lazy future ... done
[10:26:38.124]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.107] run() for ‘SequentialFuture’ ... done
[10:26:38.124] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[10:26:38.124] plan(): Setting new future strategy stack:
[10:26:38.125] List of future strategies:
[10:26:38.125] 1. multicore:
[10:26:38.125]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.125]    - tweaked: FALSE
[10:26:38.125]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.125] 2. multisession:
[10:26:38.125]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.125]    - tweaked: FALSE
[10:26:38.125]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.129] plan(): nbrOfWorkers() = 2
[10:26:38.129] getGlobalsAndPackages() ...
[10:26:38.130] Searching for globals...
[10:26:38.153] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:38.153] Searching for globals ... DONE
[10:26:38.153] Resolving globals: FALSE
[10:26:38.154] The total size of the 2 globals is 90.64 KiB (92816 bytes)
[10:26:38.155] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.64 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.52 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:38.155] - globals: [2] ‘nested’, ‘strategy2’
[10:26:38.155] - packages: [1] ‘future’
[10:26:38.155] getGlobalsAndPackages() ... DONE
[10:26:38.156] run() for ‘Future’ ...
[10:26:38.156] - state: ‘created’
[10:26:38.156] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:38.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:38.160]   - Field: ‘label’
[10:26:38.160]   - Field: ‘local’
[10:26:38.160]   - Field: ‘owner’
[10:26:38.160]   - Field: ‘envir’
[10:26:38.160]   - Field: ‘workers’
[10:26:38.161]   - Field: ‘packages’
[10:26:38.161]   - Field: ‘gc’
[10:26:38.161]   - Field: ‘job’
[10:26:38.161]   - Field: ‘conditions’
[10:26:38.161]   - Field: ‘expr’
[10:26:38.161]   - Field: ‘uuid’
[10:26:38.161]   - Field: ‘seed’
[10:26:38.161]   - Field: ‘version’
[10:26:38.162]   - Field: ‘result’
[10:26:38.162]   - Field: ‘asynchronous’
[10:26:38.162]   - Field: ‘calls’
[10:26:38.162]   - Field: ‘globals’
[10:26:38.162]   - Field: ‘stdout’
[10:26:38.162]   - Field: ‘earlySignal’
[10:26:38.162]   - Field: ‘lazy’
[10:26:38.162]   - Field: ‘state’
[10:26:38.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:38.163] - Launch lazy future ...
[10:26:38.163] Packages needed by the future expression (n = 1): ‘future’
[10:26:38.163] Packages needed by future strategies (n = 1): ‘future’
[10:26:38.164] {
[10:26:38.164]     {
[10:26:38.164]         {
[10:26:38.164]             ...future.startTime <- base::Sys.time()
[10:26:38.164]             {
[10:26:38.164]                 {
[10:26:38.164]                   {
[10:26:38.164]                     {
[10:26:38.164]                       {
[10:26:38.164]                         base::local({
[10:26:38.164]                           has_future <- base::requireNamespace("future", 
[10:26:38.164]                             quietly = TRUE)
[10:26:38.164]                           if (has_future) {
[10:26:38.164]                             ns <- base::getNamespace("future")
[10:26:38.164]                             version <- ns[[".package"]][["version"]]
[10:26:38.164]                             if (is.null(version)) 
[10:26:38.164]                               version <- utils::packageVersion("future")
[10:26:38.164]                           }
[10:26:38.164]                           else {
[10:26:38.164]                             version <- NULL
[10:26:38.164]                           }
[10:26:38.164]                           if (!has_future || version < "1.8.0") {
[10:26:38.164]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.164]                               "", base::R.version$version.string), 
[10:26:38.164]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:38.164]                                 base::R.version$platform, 8 * 
[10:26:38.164]                                   base::.Machine$sizeof.pointer), 
[10:26:38.164]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.164]                                 "release", "version")], collapse = " "), 
[10:26:38.164]                               hostname = base::Sys.info()[["nodename"]])
[10:26:38.164]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.164]                               info)
[10:26:38.164]                             info <- base::paste(info, collapse = "; ")
[10:26:38.164]                             if (!has_future) {
[10:26:38.164]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.164]                                 info)
[10:26:38.164]                             }
[10:26:38.164]                             else {
[10:26:38.164]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.164]                                 info, version)
[10:26:38.164]                             }
[10:26:38.164]                             base::stop(msg)
[10:26:38.164]                           }
[10:26:38.164]                         })
[10:26:38.164]                       }
[10:26:38.164]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:38.164]                       base::options(mc.cores = 1L)
[10:26:38.164]                     }
[10:26:38.164]                     base::local({
[10:26:38.164]                       for (pkg in "future") {
[10:26:38.164]                         base::loadNamespace(pkg)
[10:26:38.164]                         base::library(pkg, character.only = TRUE)
[10:26:38.164]                       }
[10:26:38.164]                     })
[10:26:38.164]                   }
[10:26:38.164]                   options(future.plan = NULL)
[10:26:38.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.164]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:38.164]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.164]                     envir = parent.frame()) 
[10:26:38.164]                   {
[10:26:38.164]                     if (is.function(workers)) 
[10:26:38.164]                       workers <- workers()
[10:26:38.164]                     workers <- structure(as.integer(workers), 
[10:26:38.164]                       class = class(workers))
[10:26:38.164]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.164]                       workers >= 1)
[10:26:38.164]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.164]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.164]                     }
[10:26:38.164]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.164]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.164]                       envir = envir)
[10:26:38.164]                     if (!future$lazy) 
[10:26:38.164]                       future <- run(future)
[10:26:38.164]                     invisible(future)
[10:26:38.164]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.164]                 }
[10:26:38.164]                 ...future.workdir <- getwd()
[10:26:38.164]             }
[10:26:38.164]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.164]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.164]         }
[10:26:38.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.164]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.164]             base::names(...future.oldOptions))
[10:26:38.164]     }
[10:26:38.164]     if (FALSE) {
[10:26:38.164]     }
[10:26:38.164]     else {
[10:26:38.164]         if (TRUE) {
[10:26:38.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.164]                 open = "w")
[10:26:38.164]         }
[10:26:38.164]         else {
[10:26:38.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.164]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.164]         }
[10:26:38.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.164]             base::sink(type = "output", split = FALSE)
[10:26:38.164]             base::close(...future.stdout)
[10:26:38.164]         }, add = TRUE)
[10:26:38.164]     }
[10:26:38.164]     ...future.frame <- base::sys.nframe()
[10:26:38.164]     ...future.conditions <- base::list()
[10:26:38.164]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.164]     if (FALSE) {
[10:26:38.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.164]     }
[10:26:38.164]     ...future.result <- base::tryCatch({
[10:26:38.164]         base::withCallingHandlers({
[10:26:38.164]             ...future.value <- base::withVisible(base::local({
[10:26:38.164]                 withCallingHandlers({
[10:26:38.164]                   {
[10:26:38.164]                     a <- 1L
[10:26:38.164]                     plan_a <- unclass(future::plan("list"))
[10:26:38.164]                     nested_a <- nested[-1]
[10:26:38.164]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:38.164]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:38.164]                       strategy2))
[10:26:38.164]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:38.164]                       "init") <- NULL
[10:26:38.164]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:38.164]                       "init") <- NULL
[10:26:38.164]                     stopifnot(all.equal(plan_a, nested_a))
[10:26:38.164]                     y %<-% {
[10:26:38.164]                       b <- 2L
[10:26:38.164]                       plan_b <- future::plan("list")
[10:26:38.164]                       nested_b <- nested_a[-1]
[10:26:38.164]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:38.164]                         1L, inherits(plan_b[[1]], "future"), 
[10:26:38.164]                         inherits(future::plan("next"), "sequential"))
[10:26:38.164]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:38.164]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:38.164]                     }
[10:26:38.164]                     y
[10:26:38.164]                   }
[10:26:38.164]                 }, immediateCondition = function(cond) {
[10:26:38.164]                   save_rds <- function (object, pathname, ...) 
[10:26:38.164]                   {
[10:26:38.164]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:38.164]                     if (file_test("-f", pathname_tmp)) {
[10:26:38.164]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.164]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:38.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.164]                         fi_tmp[["mtime"]])
[10:26:38.164]                     }
[10:26:38.164]                     tryCatch({
[10:26:38.164]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:38.164]                     }, error = function(ex) {
[10:26:38.164]                       msg <- conditionMessage(ex)
[10:26:38.164]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.164]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:38.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.164]                         fi_tmp[["mtime"]], msg)
[10:26:38.164]                       ex$message <- msg
[10:26:38.164]                       stop(ex)
[10:26:38.164]                     })
[10:26:38.164]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:38.164]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:38.164]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:38.164]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.164]                       fi <- file.info(pathname)
[10:26:38.164]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:38.164]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.164]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:38.164]                         fi[["size"]], fi[["mtime"]])
[10:26:38.164]                       stop(msg)
[10:26:38.164]                     }
[10:26:38.164]                     invisible(pathname)
[10:26:38.164]                   }
[10:26:38.164]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:38.164]                     rootPath = tempdir()) 
[10:26:38.164]                   {
[10:26:38.164]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:38.164]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:38.164]                       tmpdir = path, fileext = ".rds")
[10:26:38.164]                     save_rds(obj, file)
[10:26:38.164]                   }
[10:26:38.164]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:38.164]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.164]                   {
[10:26:38.164]                     inherits <- base::inherits
[10:26:38.164]                     invokeRestart <- base::invokeRestart
[10:26:38.164]                     is.null <- base::is.null
[10:26:38.164]                     muffled <- FALSE
[10:26:38.164]                     if (inherits(cond, "message")) {
[10:26:38.164]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:38.164]                       if (muffled) 
[10:26:38.164]                         invokeRestart("muffleMessage")
[10:26:38.164]                     }
[10:26:38.164]                     else if (inherits(cond, "warning")) {
[10:26:38.164]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:38.164]                       if (muffled) 
[10:26:38.164]                         invokeRestart("muffleWarning")
[10:26:38.164]                     }
[10:26:38.164]                     else if (inherits(cond, "condition")) {
[10:26:38.164]                       if (!is.null(pattern)) {
[10:26:38.164]                         computeRestarts <- base::computeRestarts
[10:26:38.164]                         grepl <- base::grepl
[10:26:38.164]                         restarts <- computeRestarts(cond)
[10:26:38.164]                         for (restart in restarts) {
[10:26:38.164]                           name <- restart$name
[10:26:38.164]                           if (is.null(name)) 
[10:26:38.164]                             next
[10:26:38.164]                           if (!grepl(pattern, name)) 
[10:26:38.164]                             next
[10:26:38.164]                           invokeRestart(restart)
[10:26:38.164]                           muffled <- TRUE
[10:26:38.164]                           break
[10:26:38.164]                         }
[10:26:38.164]                       }
[10:26:38.164]                     }
[10:26:38.164]                     invisible(muffled)
[10:26:38.164]                   }
[10:26:38.164]                   muffleCondition(cond)
[10:26:38.164]                 })
[10:26:38.164]             }))
[10:26:38.164]             future::FutureResult(value = ...future.value$value, 
[10:26:38.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.164]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.164]                     ...future.globalenv.names))
[10:26:38.164]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.164]         }, condition = base::local({
[10:26:38.164]             c <- base::c
[10:26:38.164]             inherits <- base::inherits
[10:26:38.164]             invokeRestart <- base::invokeRestart
[10:26:38.164]             length <- base::length
[10:26:38.164]             list <- base::list
[10:26:38.164]             seq.int <- base::seq.int
[10:26:38.164]             signalCondition <- base::signalCondition
[10:26:38.164]             sys.calls <- base::sys.calls
[10:26:38.164]             `[[` <- base::`[[`
[10:26:38.164]             `+` <- base::`+`
[10:26:38.164]             `<<-` <- base::`<<-`
[10:26:38.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.164]                   3L)]
[10:26:38.164]             }
[10:26:38.164]             function(cond) {
[10:26:38.164]                 is_error <- inherits(cond, "error")
[10:26:38.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.164]                   NULL)
[10:26:38.164]                 if (is_error) {
[10:26:38.164]                   sessionInformation <- function() {
[10:26:38.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.164]                       search = base::search(), system = base::Sys.info())
[10:26:38.164]                   }
[10:26:38.164]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.164]                     cond$call), session = sessionInformation(), 
[10:26:38.164]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.164]                   signalCondition(cond)
[10:26:38.164]                 }
[10:26:38.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.164]                 "immediateCondition"))) {
[10:26:38.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.164]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.164]                   if (TRUE && !signal) {
[10:26:38.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.164]                     {
[10:26:38.164]                       inherits <- base::inherits
[10:26:38.164]                       invokeRestart <- base::invokeRestart
[10:26:38.164]                       is.null <- base::is.null
[10:26:38.164]                       muffled <- FALSE
[10:26:38.164]                       if (inherits(cond, "message")) {
[10:26:38.164]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.164]                         if (muffled) 
[10:26:38.164]                           invokeRestart("muffleMessage")
[10:26:38.164]                       }
[10:26:38.164]                       else if (inherits(cond, "warning")) {
[10:26:38.164]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.164]                         if (muffled) 
[10:26:38.164]                           invokeRestart("muffleWarning")
[10:26:38.164]                       }
[10:26:38.164]                       else if (inherits(cond, "condition")) {
[10:26:38.164]                         if (!is.null(pattern)) {
[10:26:38.164]                           computeRestarts <- base::computeRestarts
[10:26:38.164]                           grepl <- base::grepl
[10:26:38.164]                           restarts <- computeRestarts(cond)
[10:26:38.164]                           for (restart in restarts) {
[10:26:38.164]                             name <- restart$name
[10:26:38.164]                             if (is.null(name)) 
[10:26:38.164]                               next
[10:26:38.164]                             if (!grepl(pattern, name)) 
[10:26:38.164]                               next
[10:26:38.164]                             invokeRestart(restart)
[10:26:38.164]                             muffled <- TRUE
[10:26:38.164]                             break
[10:26:38.164]                           }
[10:26:38.164]                         }
[10:26:38.164]                       }
[10:26:38.164]                       invisible(muffled)
[10:26:38.164]                     }
[10:26:38.164]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.164]                   }
[10:26:38.164]                 }
[10:26:38.164]                 else {
[10:26:38.164]                   if (TRUE) {
[10:26:38.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.164]                     {
[10:26:38.164]                       inherits <- base::inherits
[10:26:38.164]                       invokeRestart <- base::invokeRestart
[10:26:38.164]                       is.null <- base::is.null
[10:26:38.164]                       muffled <- FALSE
[10:26:38.164]                       if (inherits(cond, "message")) {
[10:26:38.164]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.164]                         if (muffled) 
[10:26:38.164]                           invokeRestart("muffleMessage")
[10:26:38.164]                       }
[10:26:38.164]                       else if (inherits(cond, "warning")) {
[10:26:38.164]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.164]                         if (muffled) 
[10:26:38.164]                           invokeRestart("muffleWarning")
[10:26:38.164]                       }
[10:26:38.164]                       else if (inherits(cond, "condition")) {
[10:26:38.164]                         if (!is.null(pattern)) {
[10:26:38.164]                           computeRestarts <- base::computeRestarts
[10:26:38.164]                           grepl <- base::grepl
[10:26:38.164]                           restarts <- computeRestarts(cond)
[10:26:38.164]                           for (restart in restarts) {
[10:26:38.164]                             name <- restart$name
[10:26:38.164]                             if (is.null(name)) 
[10:26:38.164]                               next
[10:26:38.164]                             if (!grepl(pattern, name)) 
[10:26:38.164]                               next
[10:26:38.164]                             invokeRestart(restart)
[10:26:38.164]                             muffled <- TRUE
[10:26:38.164]                             break
[10:26:38.164]                           }
[10:26:38.164]                         }
[10:26:38.164]                       }
[10:26:38.164]                       invisible(muffled)
[10:26:38.164]                     }
[10:26:38.164]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.164]                   }
[10:26:38.164]                 }
[10:26:38.164]             }
[10:26:38.164]         }))
[10:26:38.164]     }, error = function(ex) {
[10:26:38.164]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.164]                 ...future.rng), started = ...future.startTime, 
[10:26:38.164]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.164]             version = "1.8"), class = "FutureResult")
[10:26:38.164]     }, finally = {
[10:26:38.164]         if (!identical(...future.workdir, getwd())) 
[10:26:38.164]             setwd(...future.workdir)
[10:26:38.164]         {
[10:26:38.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.164]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.164]             }
[10:26:38.164]             base::options(...future.oldOptions)
[10:26:38.164]             if (.Platform$OS.type == "windows") {
[10:26:38.164]                 old_names <- names(...future.oldEnvVars)
[10:26:38.164]                 envs <- base::Sys.getenv()
[10:26:38.164]                 names <- names(envs)
[10:26:38.164]                 common <- intersect(names, old_names)
[10:26:38.164]                 added <- setdiff(names, old_names)
[10:26:38.164]                 removed <- setdiff(old_names, names)
[10:26:38.164]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.164]                   envs[common]]
[10:26:38.164]                 NAMES <- toupper(changed)
[10:26:38.164]                 args <- list()
[10:26:38.164]                 for (kk in seq_along(NAMES)) {
[10:26:38.164]                   name <- changed[[kk]]
[10:26:38.164]                   NAME <- NAMES[[kk]]
[10:26:38.164]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.164]                     next
[10:26:38.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.164]                 }
[10:26:38.164]                 NAMES <- toupper(added)
[10:26:38.164]                 for (kk in seq_along(NAMES)) {
[10:26:38.164]                   name <- added[[kk]]
[10:26:38.164]                   NAME <- NAMES[[kk]]
[10:26:38.164]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.164]                     next
[10:26:38.164]                   args[[name]] <- ""
[10:26:38.164]                 }
[10:26:38.164]                 NAMES <- toupper(removed)
[10:26:38.164]                 for (kk in seq_along(NAMES)) {
[10:26:38.164]                   name <- removed[[kk]]
[10:26:38.164]                   NAME <- NAMES[[kk]]
[10:26:38.164]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.164]                     next
[10:26:38.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.164]                 }
[10:26:38.164]                 if (length(args) > 0) 
[10:26:38.164]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.164]             }
[10:26:38.164]             else {
[10:26:38.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.164]             }
[10:26:38.164]             {
[10:26:38.164]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.164]                   0L) {
[10:26:38.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.164]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.164]                   base::options(opts)
[10:26:38.164]                 }
[10:26:38.164]                 {
[10:26:38.164]                   {
[10:26:38.164]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:38.164]                     NULL
[10:26:38.164]                   }
[10:26:38.164]                   options(future.plan = NULL)
[10:26:38.164]                   if (is.na(NA_character_)) 
[10:26:38.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.164]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:38.164]                     envir = parent.frame()) 
[10:26:38.164]                   {
[10:26:38.164]                     default_workers <- missing(workers)
[10:26:38.164]                     if (is.function(workers)) 
[10:26:38.164]                       workers <- workers()
[10:26:38.164]                     workers <- structure(as.integer(workers), 
[10:26:38.164]                       class = class(workers))
[10:26:38.164]                     stop_if_not(is.finite(workers), workers >= 
[10:26:38.164]                       1L)
[10:26:38.164]                     if ((workers == 1L && !inherits(workers, 
[10:26:38.164]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:38.164]                       if (default_workers) 
[10:26:38.164]                         supportsMulticore(warn = TRUE)
[10:26:38.164]                       return(sequential(..., envir = envir))
[10:26:38.164]                     }
[10:26:38.164]                     oopts <- options(mc.cores = workers)
[10:26:38.164]                     on.exit(options(oopts))
[10:26:38.164]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:38.164]                       envir = envir)
[10:26:38.164]                     if (!future$lazy) 
[10:26:38.164]                       future <- run(future)
[10:26:38.164]                     invisible(future)
[10:26:38.164]                   }, b = function (..., workers = availableCores(), 
[10:26:38.164]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.164]                     envir = parent.frame()) 
[10:26:38.164]                   {
[10:26:38.164]                     if (is.function(workers)) 
[10:26:38.164]                       workers <- workers()
[10:26:38.164]                     workers <- structure(as.integer(workers), 
[10:26:38.164]                       class = class(workers))
[10:26:38.164]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.164]                       workers >= 1)
[10:26:38.164]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.164]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.164]                     }
[10:26:38.164]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.164]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.164]                       envir = envir)
[10:26:38.164]                     if (!future$lazy) 
[10:26:38.164]                       future <- run(future)
[10:26:38.164]                     invisible(future)
[10:26:38.164]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.164]                 }
[10:26:38.164]             }
[10:26:38.164]         }
[10:26:38.164]     })
[10:26:38.164]     if (TRUE) {
[10:26:38.164]         base::sink(type = "output", split = FALSE)
[10:26:38.164]         if (TRUE) {
[10:26:38.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.164]         }
[10:26:38.164]         else {
[10:26:38.164]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.164]         }
[10:26:38.164]         base::close(...future.stdout)
[10:26:38.164]         ...future.stdout <- NULL
[10:26:38.164]     }
[10:26:38.164]     ...future.result$conditions <- ...future.conditions
[10:26:38.164]     ...future.result$finished <- base::Sys.time()
[10:26:38.164]     ...future.result
[10:26:38.164] }
[10:26:38.167] assign_globals() ...
[10:26:38.167] List of 2
[10:26:38.167]  $ nested   :List of 2
[10:26:38.167]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:26:38.167]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:26:38.167]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:38.167]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.167]     envir = parent.frame())  
[10:26:38.167]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:26:38.167]   .. ..- attr(*, "init")= logi TRUE
[10:26:38.167]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:26:38.167]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:38.167]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:38.167]  $ strategy2: chr "multisession"
[10:26:38.167]  - attr(*, "where")=List of 2
[10:26:38.167]   ..$ nested   :<environment: R_EmptyEnv> 
[10:26:38.167]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:26:38.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:38.167]  - attr(*, "resolved")= logi FALSE
[10:26:38.167]  - attr(*, "total_size")= num 92816
[10:26:38.167]  - attr(*, "already-done")= logi TRUE
[10:26:38.173] - copied ‘nested’ to environment
[10:26:38.173] - copied ‘strategy2’ to environment
[10:26:38.173] assign_globals() ... done
[10:26:38.173] requestCore(): workers = 2
[10:26:38.176] MulticoreFuture started
[10:26:38.176] - Launch lazy future ... done
[10:26:38.176] run() for ‘MulticoreFuture’ ... done
[10:26:38.177] result() for MulticoreFuture ...
[10:26:38.177] plan(): Setting new future strategy stack:
[10:26:38.178] List of future strategies:
[10:26:38.178] 1. multisession:
[10:26:38.178]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.178]    - tweaked: FALSE
[10:26:38.178]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.183] plan(): nbrOfWorkers() = 1
[10:26:38.224] plan(): Setting new future strategy stack:
[10:26:38.224] List of future strategies:
[10:26:38.224] 1. multicore:
[10:26:38.224]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.224]    - tweaked: FALSE
[10:26:38.224]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.224] 2. multisession:
[10:26:38.224]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.224]    - tweaked: FALSE
[10:26:38.224]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.228] plan(): nbrOfWorkers() = 2
[10:26:38.230] result() for MulticoreFuture ...
[10:26:38.230] result() for MulticoreFuture ... done
[10:26:38.230] signalConditions() ...
[10:26:38.230]  - include = ‘immediateCondition’
[10:26:38.230]  - exclude = 
[10:26:38.230]  - resignal = FALSE
[10:26:38.230]  - Number of conditions: 54
[10:26:38.231] signalConditions() ... done
[10:26:38.231] result() for MulticoreFuture ... done
[10:26:38.231] result() for MulticoreFuture ...
[10:26:38.231] result() for MulticoreFuture ... done
[10:26:38.231] signalConditions() ...
[10:26:38.231]  - include = ‘immediateCondition’
[10:26:38.231]  - exclude = 
[10:26:38.231]  - resignal = FALSE
[10:26:38.231]  - Number of conditions: 54
[10:26:38.232] signalConditions() ... done
[10:26:38.232] Future state: ‘finished’
[10:26:38.232] result() for MulticoreFuture ...
[10:26:38.232] result() for MulticoreFuture ... done
[10:26:38.232] signalConditions() ...
[10:26:38.232]  - include = ‘condition’
[10:26:38.232]  - exclude = ‘immediateCondition’
[10:26:38.232]  - resignal = TRUE
[10:26:38.233]  - Number of conditions: 54
[10:26:38.233]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.185] getGlobalsAndPackages() ...
[10:26:38.233]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.185] Searching for globals...
[10:26:38.233]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.193] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:26:38.233]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.193] Searching for globals ... DONE
[10:26:38.233]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.193] Resolving globals: FALSE
[10:26:38.233]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.194] The total size of the 3 globals is 87.82 KiB (89928 bytes)
[10:26:38.234]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.195] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 87.82 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (43.88 KiB of class ‘list’), ‘plan_a’ (43.88 KiB of class ‘list’) and ‘a’ (56 bytes of class ‘numeric’)
[10:26:38.234]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.195] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:26:38.234]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.196] 
[10:26:38.234]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.196] getGlobalsAndPackages() ... DONE
[10:26:38.234]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.196] run() for ‘Future’ ...
[10:26:38.234]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.197] - state: ‘created’
[10:26:38.235]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.197] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.235]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:38.235]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:38.235]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.201]   - Field: ‘label’
[10:26:38.235]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.201]   - Field: ‘local’
[10:26:38.235]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.202]   - Field: ‘owner’
[10:26:38.235]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.202]   - Field: ‘envir’
[10:26:38.236]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.202]   - Field: ‘packages’
[10:26:38.236]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.202]   - Field: ‘gc’
[10:26:38.236]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.202]   - Field: ‘conditions’
[10:26:38.236]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.202]   - Field: ‘expr’
[10:26:38.236]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.203]   - Field: ‘uuid’
[10:26:38.236]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.203]   - Field: ‘seed’
[10:26:38.237]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.203]   - Field: ‘version’
[10:26:38.237]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.203]   - Field: ‘result’
[10:26:38.237]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.203]   - Field: ‘asynchronous’
[10:26:38.237]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.203]   - Field: ‘calls’
[10:26:38.237]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.204]   - Field: ‘globals’
[10:26:38.237]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.204]   - Field: ‘stdout’
[10:26:38.237]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.204]   - Field: ‘earlySignal’
[10:26:38.238]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.204]   - Field: ‘lazy’
[10:26:38.238]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.204]   - Field: ‘state’
[10:26:38.238]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:38.238]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.204] - Launch lazy future ...
[10:26:38.238]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.205] Packages needed by the future expression (n = 0): <none>
[10:26:38.238]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.205] Packages needed by future strategies (n = 0): <none>
[10:26:38.239]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.206] {
[10:26:38.206]     {
[10:26:38.206]         {
[10:26:38.206]             ...future.startTime <- base::Sys.time()
[10:26:38.206]             {
[10:26:38.206]                 {
[10:26:38.206]                   {
[10:26:38.206]                     base::local({
[10:26:38.206]                       has_future <- base::requireNamespace("future", 
[10:26:38.206]                         quietly = TRUE)
[10:26:38.206]                       if (has_future) {
[10:26:38.206]                         ns <- base::getNamespace("future")
[10:26:38.206]                         version <- ns[[".package"]][["version"]]
[10:26:38.206]                         if (is.null(version)) 
[10:26:38.206]                           version <- utils::packageVersion("future")
[10:26:38.206]                       }
[10:26:38.206]                       else {
[10:26:38.206]                         version <- NULL
[10:26:38.206]                       }
[10:26:38.206]                       if (!has_future || version < "1.8.0") {
[10:26:38.206]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.206]                           "", base::R.version$version.string), 
[10:26:38.206]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:38.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:38.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.206]                             "release", "version")], collapse = " "), 
[10:26:38.206]                           hostname = base::Sys.info()[["nodename"]])
[10:26:38.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.206]                           info)
[10:26:38.206]                         info <- base::paste(info, collapse = "; ")
[10:26:38.206]                         if (!has_future) {
[10:26:38.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.206]                             info)
[10:26:38.206]                         }
[10:26:38.206]                         else {
[10:26:38.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.206]                             info, version)
[10:26:38.206]                         }
[10:26:38.206]                         base::stop(msg)
[10:26:38.206]                       }
[10:26:38.206]                     })
[10:26:38.206]                   }
[10:26:38.206]                   options(future.plan = NULL)
[10:26:38.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:38.206]                 }
[10:26:38.206]                 ...future.workdir <- getwd()
[10:26:38.206]             }
[10:26:38.206]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.206]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.206]         }
[10:26:38.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.206]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.206]             base::names(...future.oldOptions))
[10:26:38.206]     }
[10:26:38.206]     if (FALSE) {
[10:26:38.206]     }
[10:26:38.206]     else {
[10:26:38.206]         if (TRUE) {
[10:26:38.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.206]                 open = "w")
[10:26:38.206]         }
[10:26:38.206]         else {
[10:26:38.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.206]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.206]         }
[10:26:38.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.206]             base::sink(type = "output", split = FALSE)
[10:26:38.206]             base::close(...future.stdout)
[10:26:38.206]         }, add = TRUE)
[10:26:38.206]     }
[10:26:38.206]     ...future.frame <- base::sys.nframe()
[10:26:38.206]     ...future.conditions <- base::list()
[10:26:38.206]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.206]     if (FALSE) {
[10:26:38.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.206]     }
[10:26:38.206]     ...future.result <- base::tryCatch({
[10:26:38.206]         base::withCallingHandlers({
[10:26:38.206]             ...future.value <- base::withVisible(base::local({
[10:26:38.206]                 b <- 2L
[10:26:38.206]                 plan_b <- future::plan("list")
[10:26:38.206]                 nested_b <- nested_a[-1]
[10:26:38.206]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:38.206]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:26:38.206]                   "sequential"))
[10:26:38.206]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:38.206]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:38.206]             }))
[10:26:38.206]             future::FutureResult(value = ...future.value$value, 
[10:26:38.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.206]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.206]                     ...future.globalenv.names))
[10:26:38.206]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.206]         }, condition = base::local({
[10:26:38.206]             c <- base::c
[10:26:38.206]             inherits <- base::inherits
[10:26:38.206]             invokeRestart <- base::invokeRestart
[10:26:38.206]             length <- base::length
[10:26:38.206]             list <- base::list
[10:26:38.206]             seq.int <- base::seq.int
[10:26:38.206]             signalCondition <- base::signalCondition
[10:26:38.206]             sys.calls <- base::sys.calls
[10:26:38.206]             `[[` <- base::`[[`
[10:26:38.206]             `+` <- base::`+`
[10:26:38.206]             `<<-` <- base::`<<-`
[10:26:38.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.206]                   3L)]
[10:26:38.206]             }
[10:26:38.206]             function(cond) {
[10:26:38.206]                 is_error <- inherits(cond, "error")
[10:26:38.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.206]                   NULL)
[10:26:38.206]                 if (is_error) {
[10:26:38.206]                   sessionInformation <- function() {
[10:26:38.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.206]                       search = base::search(), system = base::Sys.info())
[10:26:38.206]                   }
[10:26:38.206]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.206]                     cond$call), session = sessionInformation(), 
[10:26:38.206]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.206]                   signalCondition(cond)
[10:26:38.206]                 }
[10:26:38.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.206]                 "immediateCondition"))) {
[10:26:38.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.206]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.206]                   if (TRUE && !signal) {
[10:26:38.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.206]                     {
[10:26:38.206]                       inherits <- base::inherits
[10:26:38.206]                       invokeRestart <- base::invokeRestart
[10:26:38.206]                       is.null <- base::is.null
[10:26:38.206]                       muffled <- FALSE
[10:26:38.206]                       if (inherits(cond, "message")) {
[10:26:38.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.206]                         if (muffled) 
[10:26:38.206]                           invokeRestart("muffleMessage")
[10:26:38.206]                       }
[10:26:38.206]                       else if (inherits(cond, "warning")) {
[10:26:38.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.206]                         if (muffled) 
[10:26:38.206]                           invokeRestart("muffleWarning")
[10:26:38.206]                       }
[10:26:38.206]                       else if (inherits(cond, "condition")) {
[10:26:38.206]                         if (!is.null(pattern)) {
[10:26:38.206]                           computeRestarts <- base::computeRestarts
[10:26:38.206]                           grepl <- base::grepl
[10:26:38.206]                           restarts <- computeRestarts(cond)
[10:26:38.206]                           for (restart in restarts) {
[10:26:38.206]                             name <- restart$name
[10:26:38.206]                             if (is.null(name)) 
[10:26:38.206]                               next
[10:26:38.206]                             if (!grepl(pattern, name)) 
[10:26:38.206]                               next
[10:26:38.206]                             invokeRestart(restart)
[10:26:38.206]                             muffled <- TRUE
[10:26:38.206]                             break
[10:26:38.206]                           }
[10:26:38.206]                         }
[10:26:38.206]                       }
[10:26:38.206]                       invisible(muffled)
[10:26:38.206]                     }
[10:26:38.206]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.206]                   }
[10:26:38.206]                 }
[10:26:38.206]                 else {
[10:26:38.206]                   if (TRUE) {
[10:26:38.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.206]                     {
[10:26:38.206]                       inherits <- base::inherits
[10:26:38.206]                       invokeRestart <- base::invokeRestart
[10:26:38.206]                       is.null <- base::is.null
[10:26:38.206]                       muffled <- FALSE
[10:26:38.206]                       if (inherits(cond, "message")) {
[10:26:38.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.206]                         if (muffled) 
[10:26:38.206]                           invokeRestart("muffleMessage")
[10:26:38.206]                       }
[10:26:38.206]                       else if (inherits(cond, "warning")) {
[10:26:38.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.206]                         if (muffled) 
[10:26:38.206]                           invokeRestart("muffleWarning")
[10:26:38.206]                       }
[10:26:38.206]                       else if (inherits(cond, "condition")) {
[10:26:38.206]                         if (!is.null(pattern)) {
[10:26:38.206]                           computeRestarts <- base::computeRestarts
[10:26:38.206]                           grepl <- base::grepl
[10:26:38.206]                           restarts <- computeRestarts(cond)
[10:26:38.206]                           for (restart in restarts) {
[10:26:38.206]                             name <- restart$name
[10:26:38.206]                             if (is.null(name)) 
[10:26:38.206]                               next
[10:26:38.206]                             if (!grepl(pattern, name)) 
[10:26:38.206]                               next
[10:26:38.206]                             invokeRestart(restart)
[10:26:38.206]                             muffled <- TRUE
[10:26:38.206]                             break
[10:26:38.206]                           }
[10:26:38.206]                         }
[10:26:38.206]                       }
[10:26:38.206]                       invisible(muffled)
[10:26:38.206]                     }
[10:26:38.206]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.206]                   }
[10:26:38.206]                 }
[10:26:38.206]             }
[10:26:38.206]         }))
[10:26:38.206]     }, error = function(ex) {
[10:26:38.206]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.206]                 ...future.rng), started = ...future.startTime, 
[10:26:38.206]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.206]             version = "1.8"), class = "FutureResult")
[10:26:38.206]     }, finally = {
[10:26:38.206]         if (!identical(...future.workdir, getwd())) 
[10:26:38.206]             setwd(...future.workdir)
[10:26:38.206]         {
[10:26:38.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.206]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.206]             }
[10:26:38.206]             base::options(...future.oldOptions)
[10:26:38.206]             if (.Platform$OS.type == "windows") {
[10:26:38.206]                 old_names <- names(...future.oldEnvVars)
[10:26:38.206]                 envs <- base::Sys.getenv()
[10:26:38.206]                 names <- names(envs)
[10:26:38.206]                 common <- intersect(names, old_names)
[10:26:38.206]                 added <- setdiff(names, old_names)
[10:26:38.206]                 removed <- setdiff(old_names, names)
[10:26:38.206]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.206]                   envs[common]]
[10:26:38.206]                 NAMES <- toupper(changed)
[10:26:38.206]                 args <- list()
[10:26:38.206]                 for (kk in seq_along(NAMES)) {
[10:26:38.206]                   name <- changed[[kk]]
[10:26:38.206]                   NAME <- NAMES[[kk]]
[10:26:38.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.206]                     next
[10:26:38.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.206]                 }
[10:26:38.206]                 NAMES <- toupper(added)
[10:26:38.206]                 for (kk in seq_along(NAMES)) {
[10:26:38.206]                   name <- added[[kk]]
[10:26:38.206]                   NAME <- NAMES[[kk]]
[10:26:38.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.206]                     next
[10:26:38.206]                   args[[name]] <- ""
[10:26:38.206]                 }
[10:26:38.206]                 NAMES <- toupper(removed)
[10:26:38.206]                 for (kk in seq_along(NAMES)) {
[10:26:38.206]                   name <- removed[[kk]]
[10:26:38.206]                   NAME <- NAMES[[kk]]
[10:26:38.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.206]                     next
[10:26:38.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.206]                 }
[10:26:38.206]                 if (length(args) > 0) 
[10:26:38.206]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.206]             }
[10:26:38.206]             else {
[10:26:38.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.206]             }
[10:26:38.206]             {
[10:26:38.206]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.206]                   0L) {
[10:26:38.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.206]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.206]                   base::options(opts)
[10:26:38.206]                 }
[10:26:38.206]                 {
[10:26:38.206]                   {
[10:26:38.206]                     NULL
[10:26:38.206]                     RNGkind("Mersenne-Twister")
[10:26:38.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:38.206]                       inherits = FALSE)
[10:26:38.206]                   }
[10:26:38.206]                   options(future.plan = NULL)
[10:26:38.206]                   if (is.na(NA_character_)) 
[10:26:38.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.206]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:38.206]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.206]                     envir = parent.frame()) 
[10:26:38.206]                   {
[10:26:38.206]                     if (is.function(workers)) 
[10:26:38.206]                       workers <- workers()
[10:26:38.206]                     workers <- structure(as.integer(workers), 
[10:26:38.206]                       class = class(workers))
[10:26:38.206]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.206]                       workers >= 1)
[10:26:38.206]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.206]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.206]                     }
[10:26:38.206]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.206]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.206]                       envir = envir)
[10:26:38.206]                     if (!future$lazy) 
[10:26:38.206]                       future <- run(future)
[10:26:38.206]                     invisible(future)
[10:26:38.206]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.206]                 }
[10:26:38.206]             }
[10:26:38.206]         }
[10:26:38.206]     })
[10:26:38.206]     if (TRUE) {
[10:26:38.206]         base::sink(type = "output", split = FALSE)
[10:26:38.206]         if (TRUE) {
[10:26:38.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.206]         }
[10:26:38.206]         else {
[10:26:38.206]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.206]         }
[10:26:38.206]         base::close(...future.stdout)
[10:26:38.206]         ...future.stdout <- NULL
[10:26:38.206]     }
[10:26:38.206]     ...future.result$conditions <- ...future.conditions
[10:26:38.206]     ...future.result$finished <- base::Sys.time()
[10:26:38.206]     ...future.result
[10:26:38.206] }
[10:26:38.239]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.208] assign_globals() ...
[10:26:38.239]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.208] List of 3
[10:26:38.208]  $ nested_a:List of 1
[10:26:38.208]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.208]     envir = parent.frame())  
[10:26:38.208]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:26:38.208]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:26:38.208]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:38.208]  $ a       : int 1
[10:26:38.208]  $ plan_a  :List of 1
[10:26:38.208]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.208]     envir = parent.frame())  
[10:26:38.208]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:26:38.208]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:26:38.208]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:26:38.208]  - attr(*, "where")=List of 3
[10:26:38.208]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:26:38.208]   ..$ a       :<environment: R_EmptyEnv> 
[10:26:38.208]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:26:38.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:38.208]  - attr(*, "resolved")= logi FALSE
[10:26:38.208]  - attr(*, "total_size")= num 89928
[10:26:38.208]  - attr(*, "already-done")= logi TRUE
[10:26:38.239]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.216] - copied ‘nested_a’ to environment
[10:26:38.239]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.216] - copied ‘a’ to environment
[10:26:38.239]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.216] - copied ‘plan_a’ to environment
[10:26:38.240]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.217] assign_globals() ... done
[10:26:38.240]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.217] plan(): Setting new future strategy stack:
[10:26:38.240]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.217] List of future strategies:
[10:26:38.217] 1. sequential:
[10:26:38.217]    - args: function (..., envir = parent.frame())
[10:26:38.217]    - tweaked: FALSE
[10:26:38.217]    - call: NULL
[10:26:38.240]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.218] plan(): nbrOfWorkers() = 1
[10:26:38.240]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.219] plan(): Setting new future strategy stack:
[10:26:38.240]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.219] List of future strategies:
[10:26:38.219] 1. multisession:
[10:26:38.219]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.219]    - tweaked: FALSE
[10:26:38.219]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.240]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.223] plan(): nbrOfWorkers() = 1
[10:26:38.241]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.223] SequentialFuture started (and completed)
[10:26:38.241]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.223] - Launch lazy future ... done
[10:26:38.241]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.223] run() for ‘SequentialFuture’ ... done
[10:26:38.241] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:38.248] getGlobalsAndPackages() ...
[10:26:38.248] Searching for globals...
[10:26:38.250] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:38.250] Searching for globals ... DONE
[10:26:38.250] Resolving globals: FALSE
[10:26:38.251] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:38.251] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:38.251] - globals: [1] ‘data’
[10:26:38.251] - packages: [1] ‘future’
[10:26:38.252] getGlobalsAndPackages() ... DONE
[10:26:38.252] run() for ‘Future’ ...
[10:26:38.252] - state: ‘created’
[10:26:38.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.257] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:38.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:26:38.257]   - Field: ‘label’
[10:26:38.257]   - Field: ‘local’
[10:26:38.257]   - Field: ‘owner’
[10:26:38.257]   - Field: ‘envir’
[10:26:38.257]   - Field: ‘workers’
[10:26:38.257]   - Field: ‘packages’
[10:26:38.258]   - Field: ‘gc’
[10:26:38.258]   - Field: ‘job’
[10:26:38.258]   - Field: ‘conditions’
[10:26:38.258]   - Field: ‘expr’
[10:26:38.258]   - Field: ‘uuid’
[10:26:38.258]   - Field: ‘seed’
[10:26:38.258]   - Field: ‘version’
[10:26:38.258]   - Field: ‘result’
[10:26:38.258]   - Field: ‘asynchronous’
[10:26:38.259]   - Field: ‘calls’
[10:26:38.259]   - Field: ‘globals’
[10:26:38.259]   - Field: ‘stdout’
[10:26:38.259]   - Field: ‘earlySignal’
[10:26:38.259]   - Field: ‘lazy’
[10:26:38.259]   - Field: ‘state’
[10:26:38.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:26:38.259] - Launch lazy future ...
[10:26:38.260] Packages needed by the future expression (n = 1): ‘future’
[10:26:38.260] Packages needed by future strategies (n = 1): ‘future’
[10:26:38.261] {
[10:26:38.261]     {
[10:26:38.261]         {
[10:26:38.261]             ...future.startTime <- base::Sys.time()
[10:26:38.261]             {
[10:26:38.261]                 {
[10:26:38.261]                   {
[10:26:38.261]                     {
[10:26:38.261]                       {
[10:26:38.261]                         base::local({
[10:26:38.261]                           has_future <- base::requireNamespace("future", 
[10:26:38.261]                             quietly = TRUE)
[10:26:38.261]                           if (has_future) {
[10:26:38.261]                             ns <- base::getNamespace("future")
[10:26:38.261]                             version <- ns[[".package"]][["version"]]
[10:26:38.261]                             if (is.null(version)) 
[10:26:38.261]                               version <- utils::packageVersion("future")
[10:26:38.261]                           }
[10:26:38.261]                           else {
[10:26:38.261]                             version <- NULL
[10:26:38.261]                           }
[10:26:38.261]                           if (!has_future || version < "1.8.0") {
[10:26:38.261]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.261]                               "", base::R.version$version.string), 
[10:26:38.261]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:38.261]                                 base::R.version$platform, 8 * 
[10:26:38.261]                                   base::.Machine$sizeof.pointer), 
[10:26:38.261]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.261]                                 "release", "version")], collapse = " "), 
[10:26:38.261]                               hostname = base::Sys.info()[["nodename"]])
[10:26:38.261]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.261]                               info)
[10:26:38.261]                             info <- base::paste(info, collapse = "; ")
[10:26:38.261]                             if (!has_future) {
[10:26:38.261]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.261]                                 info)
[10:26:38.261]                             }
[10:26:38.261]                             else {
[10:26:38.261]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.261]                                 info, version)
[10:26:38.261]                             }
[10:26:38.261]                             base::stop(msg)
[10:26:38.261]                           }
[10:26:38.261]                         })
[10:26:38.261]                       }
[10:26:38.261]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:38.261]                       base::options(mc.cores = 1L)
[10:26:38.261]                     }
[10:26:38.261]                     base::local({
[10:26:38.261]                       for (pkg in "future") {
[10:26:38.261]                         base::loadNamespace(pkg)
[10:26:38.261]                         base::library(pkg, character.only = TRUE)
[10:26:38.261]                       }
[10:26:38.261]                     })
[10:26:38.261]                   }
[10:26:38.261]                   options(future.plan = NULL)
[10:26:38.261]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.261]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:38.261]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.261]                     envir = parent.frame()) 
[10:26:38.261]                   {
[10:26:38.261]                     if (is.function(workers)) 
[10:26:38.261]                       workers <- workers()
[10:26:38.261]                     workers <- structure(as.integer(workers), 
[10:26:38.261]                       class = class(workers))
[10:26:38.261]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.261]                       workers >= 1)
[10:26:38.261]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.261]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.261]                     }
[10:26:38.261]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.261]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.261]                       envir = envir)
[10:26:38.261]                     if (!future$lazy) 
[10:26:38.261]                       future <- run(future)
[10:26:38.261]                     invisible(future)
[10:26:38.261]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.261]                 }
[10:26:38.261]                 ...future.workdir <- getwd()
[10:26:38.261]             }
[10:26:38.261]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.261]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.261]         }
[10:26:38.261]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.261]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.261]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.261]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.261]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.261]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.261]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.261]             base::names(...future.oldOptions))
[10:26:38.261]     }
[10:26:38.261]     if (FALSE) {
[10:26:38.261]     }
[10:26:38.261]     else {
[10:26:38.261]         if (TRUE) {
[10:26:38.261]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.261]                 open = "w")
[10:26:38.261]         }
[10:26:38.261]         else {
[10:26:38.261]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.261]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.261]         }
[10:26:38.261]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.261]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.261]             base::sink(type = "output", split = FALSE)
[10:26:38.261]             base::close(...future.stdout)
[10:26:38.261]         }, add = TRUE)
[10:26:38.261]     }
[10:26:38.261]     ...future.frame <- base::sys.nframe()
[10:26:38.261]     ...future.conditions <- base::list()
[10:26:38.261]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.261]     if (FALSE) {
[10:26:38.261]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.261]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.261]     }
[10:26:38.261]     ...future.result <- base::tryCatch({
[10:26:38.261]         base::withCallingHandlers({
[10:26:38.261]             ...future.value <- base::withVisible(base::local({
[10:26:38.261]                 withCallingHandlers({
[10:26:38.261]                   {
[10:26:38.261]                     value(future(subset(data, a == 2)))
[10:26:38.261]                   }
[10:26:38.261]                 }, immediateCondition = function(cond) {
[10:26:38.261]                   save_rds <- function (object, pathname, ...) 
[10:26:38.261]                   {
[10:26:38.261]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:26:38.261]                     if (file_test("-f", pathname_tmp)) {
[10:26:38.261]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.261]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:26:38.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.261]                         fi_tmp[["mtime"]])
[10:26:38.261]                     }
[10:26:38.261]                     tryCatch({
[10:26:38.261]                       saveRDS(object, file = pathname_tmp, ...)
[10:26:38.261]                     }, error = function(ex) {
[10:26:38.261]                       msg <- conditionMessage(ex)
[10:26:38.261]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.261]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:26:38.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.261]                         fi_tmp[["mtime"]], msg)
[10:26:38.261]                       ex$message <- msg
[10:26:38.261]                       stop(ex)
[10:26:38.261]                     })
[10:26:38.261]                     stopifnot(file_test("-f", pathname_tmp))
[10:26:38.261]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:26:38.261]                     if (!res || file_test("-f", pathname_tmp)) {
[10:26:38.261]                       fi_tmp <- file.info(pathname_tmp)
[10:26:38.261]                       fi <- file.info(pathname)
[10:26:38.261]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:26:38.261]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:26:38.261]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:26:38.261]                         fi[["size"]], fi[["mtime"]])
[10:26:38.261]                       stop(msg)
[10:26:38.261]                     }
[10:26:38.261]                     invisible(pathname)
[10:26:38.261]                   }
[10:26:38.261]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:26:38.261]                     rootPath = tempdir()) 
[10:26:38.261]                   {
[10:26:38.261]                     obj <- list(time = Sys.time(), condition = cond)
[10:26:38.261]                     file <- tempfile(pattern = class(cond)[1], 
[10:26:38.261]                       tmpdir = path, fileext = ".rds")
[10:26:38.261]                     save_rds(obj, file)
[10:26:38.261]                   }
[10:26:38.261]                   saveImmediateCondition(cond, path = "/tmp/RtmpPBdnqC/.future/immediateConditions")
[10:26:38.261]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.261]                   {
[10:26:38.261]                     inherits <- base::inherits
[10:26:38.261]                     invokeRestart <- base::invokeRestart
[10:26:38.261]                     is.null <- base::is.null
[10:26:38.261]                     muffled <- FALSE
[10:26:38.261]                     if (inherits(cond, "message")) {
[10:26:38.261]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:38.261]                       if (muffled) 
[10:26:38.261]                         invokeRestart("muffleMessage")
[10:26:38.261]                     }
[10:26:38.261]                     else if (inherits(cond, "warning")) {
[10:26:38.261]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:38.261]                       if (muffled) 
[10:26:38.261]                         invokeRestart("muffleWarning")
[10:26:38.261]                     }
[10:26:38.261]                     else if (inherits(cond, "condition")) {
[10:26:38.261]                       if (!is.null(pattern)) {
[10:26:38.261]                         computeRestarts <- base::computeRestarts
[10:26:38.261]                         grepl <- base::grepl
[10:26:38.261]                         restarts <- computeRestarts(cond)
[10:26:38.261]                         for (restart in restarts) {
[10:26:38.261]                           name <- restart$name
[10:26:38.261]                           if (is.null(name)) 
[10:26:38.261]                             next
[10:26:38.261]                           if (!grepl(pattern, name)) 
[10:26:38.261]                             next
[10:26:38.261]                           invokeRestart(restart)
[10:26:38.261]                           muffled <- TRUE
[10:26:38.261]                           break
[10:26:38.261]                         }
[10:26:38.261]                       }
[10:26:38.261]                     }
[10:26:38.261]                     invisible(muffled)
[10:26:38.261]                   }
[10:26:38.261]                   muffleCondition(cond)
[10:26:38.261]                 })
[10:26:38.261]             }))
[10:26:38.261]             future::FutureResult(value = ...future.value$value, 
[10:26:38.261]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.261]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.261]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.261]                     ...future.globalenv.names))
[10:26:38.261]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.261]         }, condition = base::local({
[10:26:38.261]             c <- base::c
[10:26:38.261]             inherits <- base::inherits
[10:26:38.261]             invokeRestart <- base::invokeRestart
[10:26:38.261]             length <- base::length
[10:26:38.261]             list <- base::list
[10:26:38.261]             seq.int <- base::seq.int
[10:26:38.261]             signalCondition <- base::signalCondition
[10:26:38.261]             sys.calls <- base::sys.calls
[10:26:38.261]             `[[` <- base::`[[`
[10:26:38.261]             `+` <- base::`+`
[10:26:38.261]             `<<-` <- base::`<<-`
[10:26:38.261]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.261]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.261]                   3L)]
[10:26:38.261]             }
[10:26:38.261]             function(cond) {
[10:26:38.261]                 is_error <- inherits(cond, "error")
[10:26:38.261]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.261]                   NULL)
[10:26:38.261]                 if (is_error) {
[10:26:38.261]                   sessionInformation <- function() {
[10:26:38.261]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.261]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.261]                       search = base::search(), system = base::Sys.info())
[10:26:38.261]                   }
[10:26:38.261]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.261]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.261]                     cond$call), session = sessionInformation(), 
[10:26:38.261]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.261]                   signalCondition(cond)
[10:26:38.261]                 }
[10:26:38.261]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.261]                 "immediateCondition"))) {
[10:26:38.261]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.261]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.261]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.261]                   if (TRUE && !signal) {
[10:26:38.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.261]                     {
[10:26:38.261]                       inherits <- base::inherits
[10:26:38.261]                       invokeRestart <- base::invokeRestart
[10:26:38.261]                       is.null <- base::is.null
[10:26:38.261]                       muffled <- FALSE
[10:26:38.261]                       if (inherits(cond, "message")) {
[10:26:38.261]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.261]                         if (muffled) 
[10:26:38.261]                           invokeRestart("muffleMessage")
[10:26:38.261]                       }
[10:26:38.261]                       else if (inherits(cond, "warning")) {
[10:26:38.261]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.261]                         if (muffled) 
[10:26:38.261]                           invokeRestart("muffleWarning")
[10:26:38.261]                       }
[10:26:38.261]                       else if (inherits(cond, "condition")) {
[10:26:38.261]                         if (!is.null(pattern)) {
[10:26:38.261]                           computeRestarts <- base::computeRestarts
[10:26:38.261]                           grepl <- base::grepl
[10:26:38.261]                           restarts <- computeRestarts(cond)
[10:26:38.261]                           for (restart in restarts) {
[10:26:38.261]                             name <- restart$name
[10:26:38.261]                             if (is.null(name)) 
[10:26:38.261]                               next
[10:26:38.261]                             if (!grepl(pattern, name)) 
[10:26:38.261]                               next
[10:26:38.261]                             invokeRestart(restart)
[10:26:38.261]                             muffled <- TRUE
[10:26:38.261]                             break
[10:26:38.261]                           }
[10:26:38.261]                         }
[10:26:38.261]                       }
[10:26:38.261]                       invisible(muffled)
[10:26:38.261]                     }
[10:26:38.261]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.261]                   }
[10:26:38.261]                 }
[10:26:38.261]                 else {
[10:26:38.261]                   if (TRUE) {
[10:26:38.261]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.261]                     {
[10:26:38.261]                       inherits <- base::inherits
[10:26:38.261]                       invokeRestart <- base::invokeRestart
[10:26:38.261]                       is.null <- base::is.null
[10:26:38.261]                       muffled <- FALSE
[10:26:38.261]                       if (inherits(cond, "message")) {
[10:26:38.261]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.261]                         if (muffled) 
[10:26:38.261]                           invokeRestart("muffleMessage")
[10:26:38.261]                       }
[10:26:38.261]                       else if (inherits(cond, "warning")) {
[10:26:38.261]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.261]                         if (muffled) 
[10:26:38.261]                           invokeRestart("muffleWarning")
[10:26:38.261]                       }
[10:26:38.261]                       else if (inherits(cond, "condition")) {
[10:26:38.261]                         if (!is.null(pattern)) {
[10:26:38.261]                           computeRestarts <- base::computeRestarts
[10:26:38.261]                           grepl <- base::grepl
[10:26:38.261]                           restarts <- computeRestarts(cond)
[10:26:38.261]                           for (restart in restarts) {
[10:26:38.261]                             name <- restart$name
[10:26:38.261]                             if (is.null(name)) 
[10:26:38.261]                               next
[10:26:38.261]                             if (!grepl(pattern, name)) 
[10:26:38.261]                               next
[10:26:38.261]                             invokeRestart(restart)
[10:26:38.261]                             muffled <- TRUE
[10:26:38.261]                             break
[10:26:38.261]                           }
[10:26:38.261]                         }
[10:26:38.261]                       }
[10:26:38.261]                       invisible(muffled)
[10:26:38.261]                     }
[10:26:38.261]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.261]                   }
[10:26:38.261]                 }
[10:26:38.261]             }
[10:26:38.261]         }))
[10:26:38.261]     }, error = function(ex) {
[10:26:38.261]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.261]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.261]                 ...future.rng), started = ...future.startTime, 
[10:26:38.261]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.261]             version = "1.8"), class = "FutureResult")
[10:26:38.261]     }, finally = {
[10:26:38.261]         if (!identical(...future.workdir, getwd())) 
[10:26:38.261]             setwd(...future.workdir)
[10:26:38.261]         {
[10:26:38.261]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.261]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.261]             }
[10:26:38.261]             base::options(...future.oldOptions)
[10:26:38.261]             if (.Platform$OS.type == "windows") {
[10:26:38.261]                 old_names <- names(...future.oldEnvVars)
[10:26:38.261]                 envs <- base::Sys.getenv()
[10:26:38.261]                 names <- names(envs)
[10:26:38.261]                 common <- intersect(names, old_names)
[10:26:38.261]                 added <- setdiff(names, old_names)
[10:26:38.261]                 removed <- setdiff(old_names, names)
[10:26:38.261]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.261]                   envs[common]]
[10:26:38.261]                 NAMES <- toupper(changed)
[10:26:38.261]                 args <- list()
[10:26:38.261]                 for (kk in seq_along(NAMES)) {
[10:26:38.261]                   name <- changed[[kk]]
[10:26:38.261]                   NAME <- NAMES[[kk]]
[10:26:38.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.261]                     next
[10:26:38.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.261]                 }
[10:26:38.261]                 NAMES <- toupper(added)
[10:26:38.261]                 for (kk in seq_along(NAMES)) {
[10:26:38.261]                   name <- added[[kk]]
[10:26:38.261]                   NAME <- NAMES[[kk]]
[10:26:38.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.261]                     next
[10:26:38.261]                   args[[name]] <- ""
[10:26:38.261]                 }
[10:26:38.261]                 NAMES <- toupper(removed)
[10:26:38.261]                 for (kk in seq_along(NAMES)) {
[10:26:38.261]                   name <- removed[[kk]]
[10:26:38.261]                   NAME <- NAMES[[kk]]
[10:26:38.261]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.261]                     next
[10:26:38.261]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.261]                 }
[10:26:38.261]                 if (length(args) > 0) 
[10:26:38.261]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.261]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.261]             }
[10:26:38.261]             else {
[10:26:38.261]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.261]             }
[10:26:38.261]             {
[10:26:38.261]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.261]                   0L) {
[10:26:38.261]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.261]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.261]                   base::options(opts)
[10:26:38.261]                 }
[10:26:38.261]                 {
[10:26:38.261]                   {
[10:26:38.261]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:38.261]                     NULL
[10:26:38.261]                   }
[10:26:38.261]                   options(future.plan = NULL)
[10:26:38.261]                   if (is.na(NA_character_)) 
[10:26:38.261]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.261]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.261]                   future::plan(list(a = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:38.261]                     envir = parent.frame()) 
[10:26:38.261]                   {
[10:26:38.261]                     default_workers <- missing(workers)
[10:26:38.261]                     if (is.function(workers)) 
[10:26:38.261]                       workers <- workers()
[10:26:38.261]                     workers <- structure(as.integer(workers), 
[10:26:38.261]                       class = class(workers))
[10:26:38.261]                     stop_if_not(is.finite(workers), workers >= 
[10:26:38.261]                       1L)
[10:26:38.261]                     if ((workers == 1L && !inherits(workers, 
[10:26:38.261]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:38.261]                       if (default_workers) 
[10:26:38.261]                         supportsMulticore(warn = TRUE)
[10:26:38.261]                       return(sequential(..., envir = envir))
[10:26:38.261]                     }
[10:26:38.261]                     oopts <- options(mc.cores = workers)
[10:26:38.261]                     on.exit(options(oopts))
[10:26:38.261]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:38.261]                       envir = envir)
[10:26:38.261]                     if (!future$lazy) 
[10:26:38.261]                       future <- run(future)
[10:26:38.261]                     invisible(future)
[10:26:38.261]                   }, b = function (..., workers = availableCores(), 
[10:26:38.261]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.261]                     envir = parent.frame()) 
[10:26:38.261]                   {
[10:26:38.261]                     if (is.function(workers)) 
[10:26:38.261]                       workers <- workers()
[10:26:38.261]                     workers <- structure(as.integer(workers), 
[10:26:38.261]                       class = class(workers))
[10:26:38.261]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.261]                       workers >= 1)
[10:26:38.261]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.261]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.261]                     }
[10:26:38.261]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.261]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.261]                       envir = envir)
[10:26:38.261]                     if (!future$lazy) 
[10:26:38.261]                       future <- run(future)
[10:26:38.261]                     invisible(future)
[10:26:38.261]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.261]                 }
[10:26:38.261]             }
[10:26:38.261]         }
[10:26:38.261]     })
[10:26:38.261]     if (TRUE) {
[10:26:38.261]         base::sink(type = "output", split = FALSE)
[10:26:38.261]         if (TRUE) {
[10:26:38.261]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.261]         }
[10:26:38.261]         else {
[10:26:38.261]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.261]         }
[10:26:38.261]         base::close(...future.stdout)
[10:26:38.261]         ...future.stdout <- NULL
[10:26:38.261]     }
[10:26:38.261]     ...future.result$conditions <- ...future.conditions
[10:26:38.261]     ...future.result$finished <- base::Sys.time()
[10:26:38.261]     ...future.result
[10:26:38.261] }
[10:26:38.264] assign_globals() ...
[10:26:38.264] List of 1
[10:26:38.264]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:38.264]   ..$ a: int [1:3] 1 2 3
[10:26:38.264]   ..$ b: int [1:3] 3 2 1
[10:26:38.264]  - attr(*, "where")=List of 1
[10:26:38.264]   ..$ data:<environment: R_EmptyEnv> 
[10:26:38.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:38.264]  - attr(*, "resolved")= logi FALSE
[10:26:38.264]  - attr(*, "total_size")= num 128
[10:26:38.264]  - attr(*, "already-done")= logi TRUE
[10:26:38.267] - copied ‘data’ to environment
[10:26:38.267] assign_globals() ... done
[10:26:38.268] requestCore(): workers = 2
[10:26:38.270] MulticoreFuture started
[10:26:38.270] - Launch lazy future ... done
[10:26:38.270] run() for ‘MulticoreFuture’ ... done
[10:26:38.271] result() for MulticoreFuture ...
[10:26:38.271] plan(): Setting new future strategy stack:
[10:26:38.272] List of future strategies:
[10:26:38.272] 1. multisession:
[10:26:38.272]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.272]    - tweaked: FALSE
[10:26:38.272]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.283] plan(): nbrOfWorkers() = 1
[10:26:38.313] plan(): Setting new future strategy stack:
[10:26:38.313] List of future strategies:
[10:26:38.313] 1. multicore:
[10:26:38.313]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:38.313]    - tweaked: FALSE
[10:26:38.313]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.313] 2. multisession:
[10:26:38.313]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.313]    - tweaked: FALSE
[10:26:38.313]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.317] plan(): nbrOfWorkers() = 2
[10:26:38.321] result() for MulticoreFuture ...
[10:26:38.322] result() for MulticoreFuture ... done
[10:26:38.322] signalConditions() ...
[10:26:38.322]  - include = ‘immediateCondition’
[10:26:38.322]  - exclude = 
[10:26:38.322]  - resignal = FALSE
[10:26:38.322]  - Number of conditions: 52
[10:26:38.322] signalConditions() ... done
[10:26:38.323] result() for MulticoreFuture ... done
[10:26:38.323] result() for MulticoreFuture ...
[10:26:38.323] result() for MulticoreFuture ... done
[10:26:38.323] signalConditions() ...
[10:26:38.323]  - include = ‘immediateCondition’
[10:26:38.323]  - exclude = 
[10:26:38.323]  - resignal = FALSE
[10:26:38.323]  - Number of conditions: 52
[10:26:38.323] signalConditions() ... done
[10:26:38.324] Future state: ‘finished’
[10:26:38.324] result() for MulticoreFuture ...
[10:26:38.324] result() for MulticoreFuture ... done
[10:26:38.324] signalConditions() ...
[10:26:38.324]  - include = ‘condition’
[10:26:38.324]  - exclude = ‘immediateCondition’
[10:26:38.324]  - resignal = TRUE
[10:26:38.324]  - Number of conditions: 52
[10:26:38.324]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.283] getGlobalsAndPackages() ...
[10:26:38.325]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.284] Searching for globals...
[10:26:38.325]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.285] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:38.325]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.286] Searching for globals ... DONE
[10:26:38.325]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.286] Resolving globals: FALSE
[10:26:38.325]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.287] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:38.325]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.287] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:38.326]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.287] - globals: [1] ‘data’
[10:26:38.326]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.288] 
[10:26:38.326]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.288] getGlobalsAndPackages() ... DONE
[10:26:38.326]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.289] run() for ‘Future’ ...
[10:26:38.326]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.289] - state: ‘created’
[10:26:38.326]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.289] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.327]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.293] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:26:38.327]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.293] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:26:38.327]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.293]   - Field: ‘label’
[10:26:38.327]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.293]   - Field: ‘local’
[10:26:38.327]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.294]   - Field: ‘owner’
[10:26:38.327]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.294]   - Field: ‘envir’
[10:26:38.327]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.294]   - Field: ‘packages’
[10:26:38.328]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.294]   - Field: ‘gc’
[10:26:38.328]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.294]   - Field: ‘conditions’
[10:26:38.328]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.294]   - Field: ‘expr’
[10:26:38.328]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.295]   - Field: ‘uuid’
[10:26:38.328]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.295]   - Field: ‘seed’
[10:26:38.328]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.295]   - Field: ‘version’
[10:26:38.328]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.295]   - Field: ‘result’
[10:26:38.329]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.295]   - Field: ‘asynchronous’
[10:26:38.329]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.295]   - Field: ‘calls’
[10:26:38.329]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.296]   - Field: ‘globals’
[10:26:38.329]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.296]   - Field: ‘stdout’
[10:26:38.329]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.296]   - Field: ‘earlySignal’
[10:26:38.329]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.296]   - Field: ‘lazy’
[10:26:38.330]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.296]   - Field: ‘state’
[10:26:38.330]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:26:38.330]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.297] - Launch lazy future ...
[10:26:38.330]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.297] Packages needed by the future expression (n = 0): <none>
[10:26:38.330]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.297] Packages needed by future strategies (n = 0): <none>
[10:26:38.330]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.298] {
[10:26:38.298]     {
[10:26:38.298]         {
[10:26:38.298]             ...future.startTime <- base::Sys.time()
[10:26:38.298]             {
[10:26:38.298]                 {
[10:26:38.298]                   {
[10:26:38.298]                     base::local({
[10:26:38.298]                       has_future <- base::requireNamespace("future", 
[10:26:38.298]                         quietly = TRUE)
[10:26:38.298]                       if (has_future) {
[10:26:38.298]                         ns <- base::getNamespace("future")
[10:26:38.298]                         version <- ns[[".package"]][["version"]]
[10:26:38.298]                         if (is.null(version)) 
[10:26:38.298]                           version <- utils::packageVersion("future")
[10:26:38.298]                       }
[10:26:38.298]                       else {
[10:26:38.298]                         version <- NULL
[10:26:38.298]                       }
[10:26:38.298]                       if (!has_future || version < "1.8.0") {
[10:26:38.298]                         info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.298]                           "", base::R.version$version.string), 
[10:26:38.298]                           platform = base::sprintf("%s (%s-bit)", 
[10:26:38.298]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:26:38.298]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.298]                             "release", "version")], collapse = " "), 
[10:26:38.298]                           hostname = base::Sys.info()[["nodename"]])
[10:26:38.298]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.298]                           info)
[10:26:38.298]                         info <- base::paste(info, collapse = "; ")
[10:26:38.298]                         if (!has_future) {
[10:26:38.298]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.298]                             info)
[10:26:38.298]                         }
[10:26:38.298]                         else {
[10:26:38.298]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.298]                             info, version)
[10:26:38.298]                         }
[10:26:38.298]                         base::stop(msg)
[10:26:38.298]                       }
[10:26:38.298]                     })
[10:26:38.298]                   }
[10:26:38.298]                   options(future.plan = NULL)
[10:26:38.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:26:38.298]                 }
[10:26:38.298]                 ...future.workdir <- getwd()
[10:26:38.298]             }
[10:26:38.298]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.298]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.298]         }
[10:26:38.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.298]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.298]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.298]             base::names(...future.oldOptions))
[10:26:38.298]     }
[10:26:38.298]     if (FALSE) {
[10:26:38.298]     }
[10:26:38.298]     else {
[10:26:38.298]         if (TRUE) {
[10:26:38.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.298]                 open = "w")
[10:26:38.298]         }
[10:26:38.298]         else {
[10:26:38.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.298]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.298]         }
[10:26:38.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.298]             base::sink(type = "output", split = FALSE)
[10:26:38.298]             base::close(...future.stdout)
[10:26:38.298]         }, add = TRUE)
[10:26:38.298]     }
[10:26:38.298]     ...future.frame <- base::sys.nframe()
[10:26:38.298]     ...future.conditions <- base::list()
[10:26:38.298]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.298]     if (FALSE) {
[10:26:38.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.298]     }
[10:26:38.298]     ...future.result <- base::tryCatch({
[10:26:38.298]         base::withCallingHandlers({
[10:26:38.298]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:26:38.298]                 a == 2)))
[10:26:38.298]             future::FutureResult(value = ...future.value$value, 
[10:26:38.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.298]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.298]                     ...future.globalenv.names))
[10:26:38.298]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.298]         }, condition = base::local({
[10:26:38.298]             c <- base::c
[10:26:38.298]             inherits <- base::inherits
[10:26:38.298]             invokeRestart <- base::invokeRestart
[10:26:38.298]             length <- base::length
[10:26:38.298]             list <- base::list
[10:26:38.298]             seq.int <- base::seq.int
[10:26:38.298]             signalCondition <- base::signalCondition
[10:26:38.298]             sys.calls <- base::sys.calls
[10:26:38.298]             `[[` <- base::`[[`
[10:26:38.298]             `+` <- base::`+`
[10:26:38.298]             `<<-` <- base::`<<-`
[10:26:38.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.298]                   3L)]
[10:26:38.298]             }
[10:26:38.298]             function(cond) {
[10:26:38.298]                 is_error <- inherits(cond, "error")
[10:26:38.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.298]                   NULL)
[10:26:38.298]                 if (is_error) {
[10:26:38.298]                   sessionInformation <- function() {
[10:26:38.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.298]                       search = base::search(), system = base::Sys.info())
[10:26:38.298]                   }
[10:26:38.298]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.298]                     cond$call), session = sessionInformation(), 
[10:26:38.298]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.298]                   signalCondition(cond)
[10:26:38.298]                 }
[10:26:38.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.298]                 "immediateCondition"))) {
[10:26:38.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.298]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.298]                   if (TRUE && !signal) {
[10:26:38.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.298]                     {
[10:26:38.298]                       inherits <- base::inherits
[10:26:38.298]                       invokeRestart <- base::invokeRestart
[10:26:38.298]                       is.null <- base::is.null
[10:26:38.298]                       muffled <- FALSE
[10:26:38.298]                       if (inherits(cond, "message")) {
[10:26:38.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.298]                         if (muffled) 
[10:26:38.298]                           invokeRestart("muffleMessage")
[10:26:38.298]                       }
[10:26:38.298]                       else if (inherits(cond, "warning")) {
[10:26:38.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.298]                         if (muffled) 
[10:26:38.298]                           invokeRestart("muffleWarning")
[10:26:38.298]                       }
[10:26:38.298]                       else if (inherits(cond, "condition")) {
[10:26:38.298]                         if (!is.null(pattern)) {
[10:26:38.298]                           computeRestarts <- base::computeRestarts
[10:26:38.298]                           grepl <- base::grepl
[10:26:38.298]                           restarts <- computeRestarts(cond)
[10:26:38.298]                           for (restart in restarts) {
[10:26:38.298]                             name <- restart$name
[10:26:38.298]                             if (is.null(name)) 
[10:26:38.298]                               next
[10:26:38.298]                             if (!grepl(pattern, name)) 
[10:26:38.298]                               next
[10:26:38.298]                             invokeRestart(restart)
[10:26:38.298]                             muffled <- TRUE
[10:26:38.298]                             break
[10:26:38.298]                           }
[10:26:38.298]                         }
[10:26:38.298]                       }
[10:26:38.298]                       invisible(muffled)
[10:26:38.298]                     }
[10:26:38.298]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.298]                   }
[10:26:38.298]                 }
[10:26:38.298]                 else {
[10:26:38.298]                   if (TRUE) {
[10:26:38.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.298]                     {
[10:26:38.298]                       inherits <- base::inherits
[10:26:38.298]                       invokeRestart <- base::invokeRestart
[10:26:38.298]                       is.null <- base::is.null
[10:26:38.298]                       muffled <- FALSE
[10:26:38.298]                       if (inherits(cond, "message")) {
[10:26:38.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.298]                         if (muffled) 
[10:26:38.298]                           invokeRestart("muffleMessage")
[10:26:38.298]                       }
[10:26:38.298]                       else if (inherits(cond, "warning")) {
[10:26:38.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.298]                         if (muffled) 
[10:26:38.298]                           invokeRestart("muffleWarning")
[10:26:38.298]                       }
[10:26:38.298]                       else if (inherits(cond, "condition")) {
[10:26:38.298]                         if (!is.null(pattern)) {
[10:26:38.298]                           computeRestarts <- base::computeRestarts
[10:26:38.298]                           grepl <- base::grepl
[10:26:38.298]                           restarts <- computeRestarts(cond)
[10:26:38.298]                           for (restart in restarts) {
[10:26:38.298]                             name <- restart$name
[10:26:38.298]                             if (is.null(name)) 
[10:26:38.298]                               next
[10:26:38.298]                             if (!grepl(pattern, name)) 
[10:26:38.298]                               next
[10:26:38.298]                             invokeRestart(restart)
[10:26:38.298]                             muffled <- TRUE
[10:26:38.298]                             break
[10:26:38.298]                           }
[10:26:38.298]                         }
[10:26:38.298]                       }
[10:26:38.298]                       invisible(muffled)
[10:26:38.298]                     }
[10:26:38.298]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.298]                   }
[10:26:38.298]                 }
[10:26:38.298]             }
[10:26:38.298]         }))
[10:26:38.298]     }, error = function(ex) {
[10:26:38.298]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.298]                 ...future.rng), started = ...future.startTime, 
[10:26:38.298]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.298]             version = "1.8"), class = "FutureResult")
[10:26:38.298]     }, finally = {
[10:26:38.298]         if (!identical(...future.workdir, getwd())) 
[10:26:38.298]             setwd(...future.workdir)
[10:26:38.298]         {
[10:26:38.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.298]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.298]             }
[10:26:38.298]             base::options(...future.oldOptions)
[10:26:38.298]             if (.Platform$OS.type == "windows") {
[10:26:38.298]                 old_names <- names(...future.oldEnvVars)
[10:26:38.298]                 envs <- base::Sys.getenv()
[10:26:38.298]                 names <- names(envs)
[10:26:38.298]                 common <- intersect(names, old_names)
[10:26:38.298]                 added <- setdiff(names, old_names)
[10:26:38.298]                 removed <- setdiff(old_names, names)
[10:26:38.298]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.298]                   envs[common]]
[10:26:38.298]                 NAMES <- toupper(changed)
[10:26:38.298]                 args <- list()
[10:26:38.298]                 for (kk in seq_along(NAMES)) {
[10:26:38.298]                   name <- changed[[kk]]
[10:26:38.298]                   NAME <- NAMES[[kk]]
[10:26:38.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.298]                     next
[10:26:38.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.298]                 }
[10:26:38.298]                 NAMES <- toupper(added)
[10:26:38.298]                 for (kk in seq_along(NAMES)) {
[10:26:38.298]                   name <- added[[kk]]
[10:26:38.298]                   NAME <- NAMES[[kk]]
[10:26:38.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.298]                     next
[10:26:38.298]                   args[[name]] <- ""
[10:26:38.298]                 }
[10:26:38.298]                 NAMES <- toupper(removed)
[10:26:38.298]                 for (kk in seq_along(NAMES)) {
[10:26:38.298]                   name <- removed[[kk]]
[10:26:38.298]                   NAME <- NAMES[[kk]]
[10:26:38.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.298]                     next
[10:26:38.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.298]                 }
[10:26:38.298]                 if (length(args) > 0) 
[10:26:38.298]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.298]             }
[10:26:38.298]             else {
[10:26:38.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.298]             }
[10:26:38.298]             {
[10:26:38.298]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.298]                   0L) {
[10:26:38.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.298]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.298]                   base::options(opts)
[10:26:38.298]                 }
[10:26:38.298]                 {
[10:26:38.298]                   {
[10:26:38.298]                     NULL
[10:26:38.298]                     RNGkind("Mersenne-Twister")
[10:26:38.298]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:26:38.298]                       inherits = FALSE)
[10:26:38.298]                   }
[10:26:38.298]                   options(future.plan = NULL)
[10:26:38.298]                   if (is.na(NA_character_)) 
[10:26:38.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.298]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:38.298]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.298]                     envir = parent.frame()) 
[10:26:38.298]                   {
[10:26:38.298]                     if (is.function(workers)) 
[10:26:38.298]                       workers <- workers()
[10:26:38.298]                     workers <- structure(as.integer(workers), 
[10:26:38.298]                       class = class(workers))
[10:26:38.298]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.298]                       workers >= 1)
[10:26:38.298]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.298]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.298]                     }
[10:26:38.298]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.298]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.298]                       envir = envir)
[10:26:38.298]                     if (!future$lazy) 
[10:26:38.298]                       future <- run(future)
[10:26:38.298]                     invisible(future)
[10:26:38.298]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.298]                 }
[10:26:38.298]             }
[10:26:38.298]         }
[10:26:38.298]     })
[10:26:38.298]     if (TRUE) {
[10:26:38.298]         base::sink(type = "output", split = FALSE)
[10:26:38.298]         if (TRUE) {
[10:26:38.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.298]         }
[10:26:38.298]         else {
[10:26:38.298]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.298]         }
[10:26:38.298]         base::close(...future.stdout)
[10:26:38.298]         ...future.stdout <- NULL
[10:26:38.298]     }
[10:26:38.298]     ...future.result$conditions <- ...future.conditions
[10:26:38.298]     ...future.result$finished <- base::Sys.time()
[10:26:38.298]     ...future.result
[10:26:38.298] }
[10:26:38.331]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.300] assign_globals() ...
[10:26:38.331]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.300] List of 1
[10:26:38.300]  $ data:'data.frame':	3 obs. of  2 variables:
[10:26:38.300]   ..$ a: int [1:3] 1 2 3
[10:26:38.300]   ..$ b: int [1:3] 3 2 1
[10:26:38.300]  - attr(*, "where")=List of 1
[10:26:38.300]   ..$ data:<environment: R_EmptyEnv> 
[10:26:38.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:26:38.300]  - attr(*, "resolved")= logi FALSE
[10:26:38.300]  - attr(*, "total_size")= num 128
[10:26:38.300]  - attr(*, "already-done")= logi TRUE
[10:26:38.331]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.305] - copied ‘data’ to environment
[10:26:38.331]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.305] assign_globals() ... done
[10:26:38.331]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.306] plan(): Setting new future strategy stack:
[10:26:38.331]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.306] List of future strategies:
[10:26:38.306] 1. sequential:
[10:26:38.306]    - args: function (..., envir = parent.frame())
[10:26:38.306]    - tweaked: FALSE
[10:26:38.306]    - call: NULL
[10:26:38.332]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.306] plan(): nbrOfWorkers() = 1
[10:26:38.332]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.307] plan(): Setting new future strategy stack:
[10:26:38.332]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.308] List of future strategies:
[10:26:38.308] 1. multisession:
[10:26:38.308]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.308]    - tweaked: FALSE
[10:26:38.308]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.332]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.311] plan(): nbrOfWorkers() = 1
[10:26:38.332]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.312] SequentialFuture started (and completed)
[10:26:38.332]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.312] - Launch lazy future ... done
[10:26:38.333]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:26:38.312] run() for ‘SequentialFuture’ ... done
[10:26:38.333] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[10:26:38.333] plan(): Setting new future strategy stack:
[10:26:38.333] List of future strategies:
[10:26:38.333] 1. multisession:
[10:26:38.333]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.333]    - tweaked: FALSE
[10:26:38.333]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.333] 2. sequential:
[10:26:38.333]    - args: function (..., envir = parent.frame())
[10:26:38.333]    - tweaked: FALSE
[10:26:38.333]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.334] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:38.334] multisession:
[10:26:38.334] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:38.334] - tweaked: FALSE
[10:26:38.334] - call: plan(list(a = strategy1, b = strategy2))
[10:26:38.338] getGlobalsAndPackages() ...
[10:26:38.339] Not searching for globals
[10:26:38.339] - globals: [0] <none>
[10:26:38.339] getGlobalsAndPackages() ... DONE
[10:26:38.339] [local output] makeClusterPSOCK() ...
[10:26:38.343] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:38.343] [local output] Base port: 11387
[10:26:38.343] [local output] Getting setup options for 2 cluster nodes ...
[10:26:38.344] [local output]  - Node 1 of 2 ...
[10:26:38.344] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:38.345] [local output] Rscript port: 11387

[10:26:38.345] [local output]  - Node 2 of 2 ...
[10:26:38.345] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:38.346] [local output] Rscript port: 11387

[10:26:38.346] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:38.347] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:38.347] [local output] Setting up PSOCK nodes in parallel
[10:26:38.347] List of 36
[10:26:38.347]  $ worker          : chr "localhost"
[10:26:38.347]   ..- attr(*, "localhost")= logi TRUE
[10:26:38.347]  $ master          : chr "localhost"
[10:26:38.347]  $ port            : int 11387
[10:26:38.347]  $ connectTimeout  : num 120
[10:26:38.347]  $ timeout         : num 2592000
[10:26:38.347]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:38.347]  $ homogeneous     : logi TRUE
[10:26:38.347]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:38.347]  $ rscript_envs    : NULL
[10:26:38.347]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:38.347]  $ rscript_startup : NULL
[10:26:38.347]  $ rscript_sh      : chr "sh"
[10:26:38.347]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:38.347]  $ methods         : logi TRUE
[10:26:38.347]  $ socketOptions   : chr "no-delay"
[10:26:38.347]  $ useXDR          : logi FALSE
[10:26:38.347]  $ outfile         : chr "/dev/null"
[10:26:38.347]  $ renice          : int NA
[10:26:38.347]  $ rshcmd          : NULL
[10:26:38.347]  $ user            : chr(0) 
[10:26:38.347]  $ revtunnel       : logi FALSE
[10:26:38.347]  $ rshlogfile      : NULL
[10:26:38.347]  $ rshopts         : chr(0) 
[10:26:38.347]  $ rank            : int 1
[10:26:38.347]  $ manual          : logi FALSE
[10:26:38.347]  $ dryrun          : logi FALSE
[10:26:38.347]  $ quiet           : logi FALSE
[10:26:38.347]  $ setup_strategy  : chr "parallel"
[10:26:38.347]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:38.347]  $ pidfile         : chr "/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b5af69fb6.pid"
[10:26:38.347]  $ rshcmd_label    : NULL
[10:26:38.347]  $ rsh_call        : NULL
[10:26:38.347]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:38.347]  $ localMachine    : logi TRUE
[10:26:38.347]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:38.347]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:38.347]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:38.347]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:38.347]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:38.347]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:38.347]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:38.347]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:38.347]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:38.347]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:38.347]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:38.347]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:38.347]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:38.347]  $ arguments       :List of 28
[10:26:38.347]   ..$ worker          : chr "localhost"
[10:26:38.347]   ..$ master          : NULL
[10:26:38.347]   ..$ port            : int 11387
[10:26:38.347]   ..$ connectTimeout  : num 120
[10:26:38.347]   ..$ timeout         : num 2592000
[10:26:38.347]   ..$ rscript         : NULL
[10:26:38.347]   ..$ homogeneous     : NULL
[10:26:38.347]   ..$ rscript_args    : NULL
[10:26:38.347]   ..$ rscript_envs    : NULL
[10:26:38.347]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:38.347]   ..$ rscript_startup : NULL
[10:26:38.347]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:38.347]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:38.347]   ..$ methods         : logi TRUE
[10:26:38.347]   ..$ socketOptions   : chr "no-delay"
[10:26:38.347]   ..$ useXDR          : logi FALSE
[10:26:38.347]   ..$ outfile         : chr "/dev/null"
[10:26:38.347]   ..$ renice          : int NA
[10:26:38.347]   ..$ rshcmd          : NULL
[10:26:38.347]   ..$ user            : NULL
[10:26:38.347]   ..$ revtunnel       : logi NA
[10:26:38.347]   ..$ rshlogfile      : NULL
[10:26:38.347]   ..$ rshopts         : NULL
[10:26:38.347]   ..$ rank            : int 1
[10:26:38.347]   ..$ manual          : logi FALSE
[10:26:38.347]   ..$ dryrun          : logi FALSE
[10:26:38.347]   ..$ quiet           : logi FALSE
[10:26:38.347]   ..$ setup_strategy  : chr "parallel"
[10:26:38.347]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:38.368] [local output] System call to launch all workers:
[10:26:38.368] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b5af69fb6.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11387 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:38.368] [local output] Starting PSOCK main server
[10:26:38.369] [local output] Workers launched
[10:26:38.369] [local output] Waiting for workers to connect back
[10:26:38.370]  - [local output] 0 workers out of 2 ready
[10:26:38.626]  - [local output] 0 workers out of 2 ready
[10:26:38.627]  - [local output] 1 workers out of 2 ready
[10:26:38.627]  - [local output] 1 workers out of 2 ready
[10:26:38.627]  - [local output] 2 workers out of 2 ready
[10:26:38.627] [local output] Launching of workers completed
[10:26:38.628] [local output] Collecting session information from workers
[10:26:38.628] [local output]  - Worker #1 of 2
[10:26:38.629] [local output]  - Worker #2 of 2
[10:26:38.629] [local output] makeClusterPSOCK() ... done
[10:26:38.640] Packages needed by the future expression (n = 0): <none>
[10:26:38.640] Packages needed by future strategies (n = 1): ‘future’
[10:26:38.641] {
[10:26:38.641]     {
[10:26:38.641]         {
[10:26:38.641]             ...future.startTime <- base::Sys.time()
[10:26:38.641]             {
[10:26:38.641]                 {
[10:26:38.641]                   {
[10:26:38.641]                     {
[10:26:38.641]                       {
[10:26:38.641]                         base::local({
[10:26:38.641]                           has_future <- base::requireNamespace("future", 
[10:26:38.641]                             quietly = TRUE)
[10:26:38.641]                           if (has_future) {
[10:26:38.641]                             ns <- base::getNamespace("future")
[10:26:38.641]                             version <- ns[[".package"]][["version"]]
[10:26:38.641]                             if (is.null(version)) 
[10:26:38.641]                               version <- utils::packageVersion("future")
[10:26:38.641]                           }
[10:26:38.641]                           else {
[10:26:38.641]                             version <- NULL
[10:26:38.641]                           }
[10:26:38.641]                           if (!has_future || version < "1.8.0") {
[10:26:38.641]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.641]                               "", base::R.version$version.string), 
[10:26:38.641]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:38.641]                                 base::R.version$platform, 8 * 
[10:26:38.641]                                   base::.Machine$sizeof.pointer), 
[10:26:38.641]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.641]                                 "release", "version")], collapse = " "), 
[10:26:38.641]                               hostname = base::Sys.info()[["nodename"]])
[10:26:38.641]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.641]                               info)
[10:26:38.641]                             info <- base::paste(info, collapse = "; ")
[10:26:38.641]                             if (!has_future) {
[10:26:38.641]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.641]                                 info)
[10:26:38.641]                             }
[10:26:38.641]                             else {
[10:26:38.641]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.641]                                 info, version)
[10:26:38.641]                             }
[10:26:38.641]                             base::stop(msg)
[10:26:38.641]                           }
[10:26:38.641]                         })
[10:26:38.641]                       }
[10:26:38.641]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:38.641]                       base::options(mc.cores = 1L)
[10:26:38.641]                     }
[10:26:38.641]                     base::local({
[10:26:38.641]                       for (pkg in "future") {
[10:26:38.641]                         base::loadNamespace(pkg)
[10:26:38.641]                         base::library(pkg, character.only = TRUE)
[10:26:38.641]                       }
[10:26:38.641]                     })
[10:26:38.641]                   }
[10:26:38.641]                   options(future.plan = NULL)
[10:26:38.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.641]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:38.641]                   {
[10:26:38.641]                     future <- SequentialFuture(..., envir = envir)
[10:26:38.641]                     if (!future$lazy) 
[10:26:38.641]                       future <- run(future)
[10:26:38.641]                     invisible(future)
[10:26:38.641]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.641]                 }
[10:26:38.641]                 ...future.workdir <- getwd()
[10:26:38.641]             }
[10:26:38.641]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.641]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.641]         }
[10:26:38.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.641]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.641]             base::names(...future.oldOptions))
[10:26:38.641]     }
[10:26:38.641]     if (FALSE) {
[10:26:38.641]     }
[10:26:38.641]     else {
[10:26:38.641]         if (TRUE) {
[10:26:38.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.641]                 open = "w")
[10:26:38.641]         }
[10:26:38.641]         else {
[10:26:38.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.641]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.641]         }
[10:26:38.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.641]             base::sink(type = "output", split = FALSE)
[10:26:38.641]             base::close(...future.stdout)
[10:26:38.641]         }, add = TRUE)
[10:26:38.641]     }
[10:26:38.641]     ...future.frame <- base::sys.nframe()
[10:26:38.641]     ...future.conditions <- base::list()
[10:26:38.641]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.641]     if (FALSE) {
[10:26:38.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.641]     }
[10:26:38.641]     ...future.result <- base::tryCatch({
[10:26:38.641]         base::withCallingHandlers({
[10:26:38.641]             ...future.value <- base::withVisible(base::local({
[10:26:38.641]                 ...future.makeSendCondition <- base::local({
[10:26:38.641]                   sendCondition <- NULL
[10:26:38.641]                   function(frame = 1L) {
[10:26:38.641]                     if (is.function(sendCondition)) 
[10:26:38.641]                       return(sendCondition)
[10:26:38.641]                     ns <- getNamespace("parallel")
[10:26:38.641]                     if (exists("sendData", mode = "function", 
[10:26:38.641]                       envir = ns)) {
[10:26:38.641]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:38.641]                         envir = ns)
[10:26:38.641]                       envir <- sys.frame(frame)
[10:26:38.641]                       master <- NULL
[10:26:38.641]                       while (!identical(envir, .GlobalEnv) && 
[10:26:38.641]                         !identical(envir, emptyenv())) {
[10:26:38.641]                         if (exists("master", mode = "list", envir = envir, 
[10:26:38.641]                           inherits = FALSE)) {
[10:26:38.641]                           master <- get("master", mode = "list", 
[10:26:38.641]                             envir = envir, inherits = FALSE)
[10:26:38.641]                           if (inherits(master, c("SOCKnode", 
[10:26:38.641]                             "SOCK0node"))) {
[10:26:38.641]                             sendCondition <<- function(cond) {
[10:26:38.641]                               data <- list(type = "VALUE", value = cond, 
[10:26:38.641]                                 success = TRUE)
[10:26:38.641]                               parallel_sendData(master, data)
[10:26:38.641]                             }
[10:26:38.641]                             return(sendCondition)
[10:26:38.641]                           }
[10:26:38.641]                         }
[10:26:38.641]                         frame <- frame + 1L
[10:26:38.641]                         envir <- sys.frame(frame)
[10:26:38.641]                       }
[10:26:38.641]                     }
[10:26:38.641]                     sendCondition <<- function(cond) NULL
[10:26:38.641]                   }
[10:26:38.641]                 })
[10:26:38.641]                 withCallingHandlers({
[10:26:38.641]                   NA
[10:26:38.641]                 }, immediateCondition = function(cond) {
[10:26:38.641]                   sendCondition <- ...future.makeSendCondition()
[10:26:38.641]                   sendCondition(cond)
[10:26:38.641]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.641]                   {
[10:26:38.641]                     inherits <- base::inherits
[10:26:38.641]                     invokeRestart <- base::invokeRestart
[10:26:38.641]                     is.null <- base::is.null
[10:26:38.641]                     muffled <- FALSE
[10:26:38.641]                     if (inherits(cond, "message")) {
[10:26:38.641]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:38.641]                       if (muffled) 
[10:26:38.641]                         invokeRestart("muffleMessage")
[10:26:38.641]                     }
[10:26:38.641]                     else if (inherits(cond, "warning")) {
[10:26:38.641]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:38.641]                       if (muffled) 
[10:26:38.641]                         invokeRestart("muffleWarning")
[10:26:38.641]                     }
[10:26:38.641]                     else if (inherits(cond, "condition")) {
[10:26:38.641]                       if (!is.null(pattern)) {
[10:26:38.641]                         computeRestarts <- base::computeRestarts
[10:26:38.641]                         grepl <- base::grepl
[10:26:38.641]                         restarts <- computeRestarts(cond)
[10:26:38.641]                         for (restart in restarts) {
[10:26:38.641]                           name <- restart$name
[10:26:38.641]                           if (is.null(name)) 
[10:26:38.641]                             next
[10:26:38.641]                           if (!grepl(pattern, name)) 
[10:26:38.641]                             next
[10:26:38.641]                           invokeRestart(restart)
[10:26:38.641]                           muffled <- TRUE
[10:26:38.641]                           break
[10:26:38.641]                         }
[10:26:38.641]                       }
[10:26:38.641]                     }
[10:26:38.641]                     invisible(muffled)
[10:26:38.641]                   }
[10:26:38.641]                   muffleCondition(cond)
[10:26:38.641]                 })
[10:26:38.641]             }))
[10:26:38.641]             future::FutureResult(value = ...future.value$value, 
[10:26:38.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.641]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.641]                     ...future.globalenv.names))
[10:26:38.641]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.641]         }, condition = base::local({
[10:26:38.641]             c <- base::c
[10:26:38.641]             inherits <- base::inherits
[10:26:38.641]             invokeRestart <- base::invokeRestart
[10:26:38.641]             length <- base::length
[10:26:38.641]             list <- base::list
[10:26:38.641]             seq.int <- base::seq.int
[10:26:38.641]             signalCondition <- base::signalCondition
[10:26:38.641]             sys.calls <- base::sys.calls
[10:26:38.641]             `[[` <- base::`[[`
[10:26:38.641]             `+` <- base::`+`
[10:26:38.641]             `<<-` <- base::`<<-`
[10:26:38.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.641]                   3L)]
[10:26:38.641]             }
[10:26:38.641]             function(cond) {
[10:26:38.641]                 is_error <- inherits(cond, "error")
[10:26:38.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.641]                   NULL)
[10:26:38.641]                 if (is_error) {
[10:26:38.641]                   sessionInformation <- function() {
[10:26:38.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.641]                       search = base::search(), system = base::Sys.info())
[10:26:38.641]                   }
[10:26:38.641]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.641]                     cond$call), session = sessionInformation(), 
[10:26:38.641]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.641]                   signalCondition(cond)
[10:26:38.641]                 }
[10:26:38.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.641]                 "immediateCondition"))) {
[10:26:38.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.641]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.641]                   if (TRUE && !signal) {
[10:26:38.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.641]                     {
[10:26:38.641]                       inherits <- base::inherits
[10:26:38.641]                       invokeRestart <- base::invokeRestart
[10:26:38.641]                       is.null <- base::is.null
[10:26:38.641]                       muffled <- FALSE
[10:26:38.641]                       if (inherits(cond, "message")) {
[10:26:38.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.641]                         if (muffled) 
[10:26:38.641]                           invokeRestart("muffleMessage")
[10:26:38.641]                       }
[10:26:38.641]                       else if (inherits(cond, "warning")) {
[10:26:38.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.641]                         if (muffled) 
[10:26:38.641]                           invokeRestart("muffleWarning")
[10:26:38.641]                       }
[10:26:38.641]                       else if (inherits(cond, "condition")) {
[10:26:38.641]                         if (!is.null(pattern)) {
[10:26:38.641]                           computeRestarts <- base::computeRestarts
[10:26:38.641]                           grepl <- base::grepl
[10:26:38.641]                           restarts <- computeRestarts(cond)
[10:26:38.641]                           for (restart in restarts) {
[10:26:38.641]                             name <- restart$name
[10:26:38.641]                             if (is.null(name)) 
[10:26:38.641]                               next
[10:26:38.641]                             if (!grepl(pattern, name)) 
[10:26:38.641]                               next
[10:26:38.641]                             invokeRestart(restart)
[10:26:38.641]                             muffled <- TRUE
[10:26:38.641]                             break
[10:26:38.641]                           }
[10:26:38.641]                         }
[10:26:38.641]                       }
[10:26:38.641]                       invisible(muffled)
[10:26:38.641]                     }
[10:26:38.641]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.641]                   }
[10:26:38.641]                 }
[10:26:38.641]                 else {
[10:26:38.641]                   if (TRUE) {
[10:26:38.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.641]                     {
[10:26:38.641]                       inherits <- base::inherits
[10:26:38.641]                       invokeRestart <- base::invokeRestart
[10:26:38.641]                       is.null <- base::is.null
[10:26:38.641]                       muffled <- FALSE
[10:26:38.641]                       if (inherits(cond, "message")) {
[10:26:38.641]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.641]                         if (muffled) 
[10:26:38.641]                           invokeRestart("muffleMessage")
[10:26:38.641]                       }
[10:26:38.641]                       else if (inherits(cond, "warning")) {
[10:26:38.641]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.641]                         if (muffled) 
[10:26:38.641]                           invokeRestart("muffleWarning")
[10:26:38.641]                       }
[10:26:38.641]                       else if (inherits(cond, "condition")) {
[10:26:38.641]                         if (!is.null(pattern)) {
[10:26:38.641]                           computeRestarts <- base::computeRestarts
[10:26:38.641]                           grepl <- base::grepl
[10:26:38.641]                           restarts <- computeRestarts(cond)
[10:26:38.641]                           for (restart in restarts) {
[10:26:38.641]                             name <- restart$name
[10:26:38.641]                             if (is.null(name)) 
[10:26:38.641]                               next
[10:26:38.641]                             if (!grepl(pattern, name)) 
[10:26:38.641]                               next
[10:26:38.641]                             invokeRestart(restart)
[10:26:38.641]                             muffled <- TRUE
[10:26:38.641]                             break
[10:26:38.641]                           }
[10:26:38.641]                         }
[10:26:38.641]                       }
[10:26:38.641]                       invisible(muffled)
[10:26:38.641]                     }
[10:26:38.641]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.641]                   }
[10:26:38.641]                 }
[10:26:38.641]             }
[10:26:38.641]         }))
[10:26:38.641]     }, error = function(ex) {
[10:26:38.641]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.641]                 ...future.rng), started = ...future.startTime, 
[10:26:38.641]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.641]             version = "1.8"), class = "FutureResult")
[10:26:38.641]     }, finally = {
[10:26:38.641]         if (!identical(...future.workdir, getwd())) 
[10:26:38.641]             setwd(...future.workdir)
[10:26:38.641]         {
[10:26:38.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.641]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.641]             }
[10:26:38.641]             base::options(...future.oldOptions)
[10:26:38.641]             if (.Platform$OS.type == "windows") {
[10:26:38.641]                 old_names <- names(...future.oldEnvVars)
[10:26:38.641]                 envs <- base::Sys.getenv()
[10:26:38.641]                 names <- names(envs)
[10:26:38.641]                 common <- intersect(names, old_names)
[10:26:38.641]                 added <- setdiff(names, old_names)
[10:26:38.641]                 removed <- setdiff(old_names, names)
[10:26:38.641]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.641]                   envs[common]]
[10:26:38.641]                 NAMES <- toupper(changed)
[10:26:38.641]                 args <- list()
[10:26:38.641]                 for (kk in seq_along(NAMES)) {
[10:26:38.641]                   name <- changed[[kk]]
[10:26:38.641]                   NAME <- NAMES[[kk]]
[10:26:38.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.641]                     next
[10:26:38.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.641]                 }
[10:26:38.641]                 NAMES <- toupper(added)
[10:26:38.641]                 for (kk in seq_along(NAMES)) {
[10:26:38.641]                   name <- added[[kk]]
[10:26:38.641]                   NAME <- NAMES[[kk]]
[10:26:38.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.641]                     next
[10:26:38.641]                   args[[name]] <- ""
[10:26:38.641]                 }
[10:26:38.641]                 NAMES <- toupper(removed)
[10:26:38.641]                 for (kk in seq_along(NAMES)) {
[10:26:38.641]                   name <- removed[[kk]]
[10:26:38.641]                   NAME <- NAMES[[kk]]
[10:26:38.641]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.641]                     next
[10:26:38.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.641]                 }
[10:26:38.641]                 if (length(args) > 0) 
[10:26:38.641]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.641]             }
[10:26:38.641]             else {
[10:26:38.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.641]             }
[10:26:38.641]             {
[10:26:38.641]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.641]                   0L) {
[10:26:38.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.641]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.641]                   base::options(opts)
[10:26:38.641]                 }
[10:26:38.641]                 {
[10:26:38.641]                   {
[10:26:38.641]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:38.641]                     NULL
[10:26:38.641]                   }
[10:26:38.641]                   options(future.plan = NULL)
[10:26:38.641]                   if (is.na(NA_character_)) 
[10:26:38.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.641]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:38.641]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.641]                     envir = parent.frame()) 
[10:26:38.641]                   {
[10:26:38.641]                     if (is.function(workers)) 
[10:26:38.641]                       workers <- workers()
[10:26:38.641]                     workers <- structure(as.integer(workers), 
[10:26:38.641]                       class = class(workers))
[10:26:38.641]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.641]                       workers >= 1)
[10:26:38.641]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.641]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.641]                     }
[10:26:38.641]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.641]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.641]                       envir = envir)
[10:26:38.641]                     if (!future$lazy) 
[10:26:38.641]                       future <- run(future)
[10:26:38.641]                     invisible(future)
[10:26:38.641]                   }, b = function (..., envir = parent.frame()) 
[10:26:38.641]                   {
[10:26:38.641]                     future <- SequentialFuture(..., envir = envir)
[10:26:38.641]                     if (!future$lazy) 
[10:26:38.641]                       future <- run(future)
[10:26:38.641]                     invisible(future)
[10:26:38.641]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.641]                 }
[10:26:38.641]             }
[10:26:38.641]         }
[10:26:38.641]     })
[10:26:38.641]     if (TRUE) {
[10:26:38.641]         base::sink(type = "output", split = FALSE)
[10:26:38.641]         if (TRUE) {
[10:26:38.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.641]         }
[10:26:38.641]         else {
[10:26:38.641]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.641]         }
[10:26:38.641]         base::close(...future.stdout)
[10:26:38.641]         ...future.stdout <- NULL
[10:26:38.641]     }
[10:26:38.641]     ...future.result$conditions <- ...future.conditions
[10:26:38.641]     ...future.result$finished <- base::Sys.time()
[10:26:38.641]     ...future.result
[10:26:38.641] }
[10:26:38.695] MultisessionFuture started
[10:26:38.696] result() for ClusterFuture ...
[10:26:38.696] receiveMessageFromWorker() for ClusterFuture ...
[10:26:38.696] - Validating connection of MultisessionFuture
[10:26:38.743] - received message: FutureResult
[10:26:38.743] - Received FutureResult
[10:26:38.743] - Erased future from FutureRegistry
[10:26:38.743] result() for ClusterFuture ...
[10:26:38.744] - result already collected: FutureResult
[10:26:38.744] result() for ClusterFuture ... done
[10:26:38.744] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:38.744] result() for ClusterFuture ... done
[10:26:38.744] result() for ClusterFuture ...
[10:26:38.744] - result already collected: FutureResult
[10:26:38.744] result() for ClusterFuture ... done
[10:26:38.744] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:38.748] plan(): nbrOfWorkers() = 2
[10:26:38.748] getGlobalsAndPackages() ...
[10:26:38.748] Searching for globals...
[10:26:38.769] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:38.769] Searching for globals ... DONE
[10:26:38.769] Resolving globals: FALSE
[10:26:38.770] The total size of the 2 globals is 55.46 KiB (56792 bytes)
[10:26:38.771] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 55.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (55.34 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:38.771] - globals: [2] ‘nested’, ‘strategy2’
[10:26:38.771] - packages: [1] ‘future’
[10:26:38.771] getGlobalsAndPackages() ... DONE
[10:26:38.771] run() for ‘Future’ ...
[10:26:38.772] - state: ‘created’
[10:26:38.772] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.786] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:38.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:38.787]   - Field: ‘node’
[10:26:38.787]   - Field: ‘label’
[10:26:38.787]   - Field: ‘local’
[10:26:38.787]   - Field: ‘owner’
[10:26:38.787]   - Field: ‘envir’
[10:26:38.787]   - Field: ‘workers’
[10:26:38.787]   - Field: ‘packages’
[10:26:38.787]   - Field: ‘gc’
[10:26:38.788]   - Field: ‘conditions’
[10:26:38.788]   - Field: ‘persistent’
[10:26:38.788]   - Field: ‘expr’
[10:26:38.788]   - Field: ‘uuid’
[10:26:38.788]   - Field: ‘seed’
[10:26:38.788]   - Field: ‘version’
[10:26:38.788]   - Field: ‘result’
[10:26:38.788]   - Field: ‘asynchronous’
[10:26:38.788]   - Field: ‘calls’
[10:26:38.788]   - Field: ‘globals’
[10:26:38.788]   - Field: ‘stdout’
[10:26:38.788]   - Field: ‘earlySignal’
[10:26:38.789]   - Field: ‘lazy’
[10:26:38.789]   - Field: ‘state’
[10:26:38.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:38.789] - Launch lazy future ...
[10:26:38.789] Packages needed by the future expression (n = 1): ‘future’
[10:26:38.789] Packages needed by future strategies (n = 1): ‘future’
[10:26:38.790] {
[10:26:38.790]     {
[10:26:38.790]         {
[10:26:38.790]             ...future.startTime <- base::Sys.time()
[10:26:38.790]             {
[10:26:38.790]                 {
[10:26:38.790]                   {
[10:26:38.790]                     {
[10:26:38.790]                       {
[10:26:38.790]                         base::local({
[10:26:38.790]                           has_future <- base::requireNamespace("future", 
[10:26:38.790]                             quietly = TRUE)
[10:26:38.790]                           if (has_future) {
[10:26:38.790]                             ns <- base::getNamespace("future")
[10:26:38.790]                             version <- ns[[".package"]][["version"]]
[10:26:38.790]                             if (is.null(version)) 
[10:26:38.790]                               version <- utils::packageVersion("future")
[10:26:38.790]                           }
[10:26:38.790]                           else {
[10:26:38.790]                             version <- NULL
[10:26:38.790]                           }
[10:26:38.790]                           if (!has_future || version < "1.8.0") {
[10:26:38.790]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.790]                               "", base::R.version$version.string), 
[10:26:38.790]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:38.790]                                 base::R.version$platform, 8 * 
[10:26:38.790]                                   base::.Machine$sizeof.pointer), 
[10:26:38.790]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.790]                                 "release", "version")], collapse = " "), 
[10:26:38.790]                               hostname = base::Sys.info()[["nodename"]])
[10:26:38.790]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.790]                               info)
[10:26:38.790]                             info <- base::paste(info, collapse = "; ")
[10:26:38.790]                             if (!has_future) {
[10:26:38.790]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.790]                                 info)
[10:26:38.790]                             }
[10:26:38.790]                             else {
[10:26:38.790]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.790]                                 info, version)
[10:26:38.790]                             }
[10:26:38.790]                             base::stop(msg)
[10:26:38.790]                           }
[10:26:38.790]                         })
[10:26:38.790]                       }
[10:26:38.790]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:38.790]                       base::options(mc.cores = 1L)
[10:26:38.790]                     }
[10:26:38.790]                     base::local({
[10:26:38.790]                       for (pkg in "future") {
[10:26:38.790]                         base::loadNamespace(pkg)
[10:26:38.790]                         base::library(pkg, character.only = TRUE)
[10:26:38.790]                       }
[10:26:38.790]                     })
[10:26:38.790]                   }
[10:26:38.790]                   options(future.plan = NULL)
[10:26:38.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.790]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:38.790]                   {
[10:26:38.790]                     future <- SequentialFuture(..., envir = envir)
[10:26:38.790]                     if (!future$lazy) 
[10:26:38.790]                       future <- run(future)
[10:26:38.790]                     invisible(future)
[10:26:38.790]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.790]                 }
[10:26:38.790]                 ...future.workdir <- getwd()
[10:26:38.790]             }
[10:26:38.790]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.790]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.790]         }
[10:26:38.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.790]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.790]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.790]             base::names(...future.oldOptions))
[10:26:38.790]     }
[10:26:38.790]     if (FALSE) {
[10:26:38.790]     }
[10:26:38.790]     else {
[10:26:38.790]         if (TRUE) {
[10:26:38.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.790]                 open = "w")
[10:26:38.790]         }
[10:26:38.790]         else {
[10:26:38.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.790]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.790]         }
[10:26:38.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.790]             base::sink(type = "output", split = FALSE)
[10:26:38.790]             base::close(...future.stdout)
[10:26:38.790]         }, add = TRUE)
[10:26:38.790]     }
[10:26:38.790]     ...future.frame <- base::sys.nframe()
[10:26:38.790]     ...future.conditions <- base::list()
[10:26:38.790]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.790]     if (FALSE) {
[10:26:38.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.790]     }
[10:26:38.790]     ...future.result <- base::tryCatch({
[10:26:38.790]         base::withCallingHandlers({
[10:26:38.790]             ...future.value <- base::withVisible(base::local({
[10:26:38.790]                 ...future.makeSendCondition <- base::local({
[10:26:38.790]                   sendCondition <- NULL
[10:26:38.790]                   function(frame = 1L) {
[10:26:38.790]                     if (is.function(sendCondition)) 
[10:26:38.790]                       return(sendCondition)
[10:26:38.790]                     ns <- getNamespace("parallel")
[10:26:38.790]                     if (exists("sendData", mode = "function", 
[10:26:38.790]                       envir = ns)) {
[10:26:38.790]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:38.790]                         envir = ns)
[10:26:38.790]                       envir <- sys.frame(frame)
[10:26:38.790]                       master <- NULL
[10:26:38.790]                       while (!identical(envir, .GlobalEnv) && 
[10:26:38.790]                         !identical(envir, emptyenv())) {
[10:26:38.790]                         if (exists("master", mode = "list", envir = envir, 
[10:26:38.790]                           inherits = FALSE)) {
[10:26:38.790]                           master <- get("master", mode = "list", 
[10:26:38.790]                             envir = envir, inherits = FALSE)
[10:26:38.790]                           if (inherits(master, c("SOCKnode", 
[10:26:38.790]                             "SOCK0node"))) {
[10:26:38.790]                             sendCondition <<- function(cond) {
[10:26:38.790]                               data <- list(type = "VALUE", value = cond, 
[10:26:38.790]                                 success = TRUE)
[10:26:38.790]                               parallel_sendData(master, data)
[10:26:38.790]                             }
[10:26:38.790]                             return(sendCondition)
[10:26:38.790]                           }
[10:26:38.790]                         }
[10:26:38.790]                         frame <- frame + 1L
[10:26:38.790]                         envir <- sys.frame(frame)
[10:26:38.790]                       }
[10:26:38.790]                     }
[10:26:38.790]                     sendCondition <<- function(cond) NULL
[10:26:38.790]                   }
[10:26:38.790]                 })
[10:26:38.790]                 withCallingHandlers({
[10:26:38.790]                   {
[10:26:38.790]                     a <- 1L
[10:26:38.790]                     plan_a <- unclass(future::plan("list"))
[10:26:38.790]                     nested_a <- nested[-1]
[10:26:38.790]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:38.790]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:38.790]                       strategy2))
[10:26:38.790]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:38.790]                       "init") <- NULL
[10:26:38.790]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:38.790]                       "init") <- NULL
[10:26:38.790]                     stopifnot(all.equal(plan_a, nested_a))
[10:26:38.790]                     y %<-% {
[10:26:38.790]                       b <- 2L
[10:26:38.790]                       plan_b <- future::plan("list")
[10:26:38.790]                       nested_b <- nested_a[-1]
[10:26:38.790]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:38.790]                         1L, inherits(plan_b[[1]], "future"), 
[10:26:38.790]                         inherits(future::plan("next"), "sequential"))
[10:26:38.790]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:38.790]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:38.790]                     }
[10:26:38.790]                     y
[10:26:38.790]                   }
[10:26:38.790]                 }, immediateCondition = function(cond) {
[10:26:38.790]                   sendCondition <- ...future.makeSendCondition()
[10:26:38.790]                   sendCondition(cond)
[10:26:38.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.790]                   {
[10:26:38.790]                     inherits <- base::inherits
[10:26:38.790]                     invokeRestart <- base::invokeRestart
[10:26:38.790]                     is.null <- base::is.null
[10:26:38.790]                     muffled <- FALSE
[10:26:38.790]                     if (inherits(cond, "message")) {
[10:26:38.790]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:38.790]                       if (muffled) 
[10:26:38.790]                         invokeRestart("muffleMessage")
[10:26:38.790]                     }
[10:26:38.790]                     else if (inherits(cond, "warning")) {
[10:26:38.790]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:38.790]                       if (muffled) 
[10:26:38.790]                         invokeRestart("muffleWarning")
[10:26:38.790]                     }
[10:26:38.790]                     else if (inherits(cond, "condition")) {
[10:26:38.790]                       if (!is.null(pattern)) {
[10:26:38.790]                         computeRestarts <- base::computeRestarts
[10:26:38.790]                         grepl <- base::grepl
[10:26:38.790]                         restarts <- computeRestarts(cond)
[10:26:38.790]                         for (restart in restarts) {
[10:26:38.790]                           name <- restart$name
[10:26:38.790]                           if (is.null(name)) 
[10:26:38.790]                             next
[10:26:38.790]                           if (!grepl(pattern, name)) 
[10:26:38.790]                             next
[10:26:38.790]                           invokeRestart(restart)
[10:26:38.790]                           muffled <- TRUE
[10:26:38.790]                           break
[10:26:38.790]                         }
[10:26:38.790]                       }
[10:26:38.790]                     }
[10:26:38.790]                     invisible(muffled)
[10:26:38.790]                   }
[10:26:38.790]                   muffleCondition(cond)
[10:26:38.790]                 })
[10:26:38.790]             }))
[10:26:38.790]             future::FutureResult(value = ...future.value$value, 
[10:26:38.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.790]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.790]                     ...future.globalenv.names))
[10:26:38.790]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.790]         }, condition = base::local({
[10:26:38.790]             c <- base::c
[10:26:38.790]             inherits <- base::inherits
[10:26:38.790]             invokeRestart <- base::invokeRestart
[10:26:38.790]             length <- base::length
[10:26:38.790]             list <- base::list
[10:26:38.790]             seq.int <- base::seq.int
[10:26:38.790]             signalCondition <- base::signalCondition
[10:26:38.790]             sys.calls <- base::sys.calls
[10:26:38.790]             `[[` <- base::`[[`
[10:26:38.790]             `+` <- base::`+`
[10:26:38.790]             `<<-` <- base::`<<-`
[10:26:38.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.790]                   3L)]
[10:26:38.790]             }
[10:26:38.790]             function(cond) {
[10:26:38.790]                 is_error <- inherits(cond, "error")
[10:26:38.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.790]                   NULL)
[10:26:38.790]                 if (is_error) {
[10:26:38.790]                   sessionInformation <- function() {
[10:26:38.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.790]                       search = base::search(), system = base::Sys.info())
[10:26:38.790]                   }
[10:26:38.790]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.790]                     cond$call), session = sessionInformation(), 
[10:26:38.790]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.790]                   signalCondition(cond)
[10:26:38.790]                 }
[10:26:38.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.790]                 "immediateCondition"))) {
[10:26:38.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.790]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.790]                   if (TRUE && !signal) {
[10:26:38.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.790]                     {
[10:26:38.790]                       inherits <- base::inherits
[10:26:38.790]                       invokeRestart <- base::invokeRestart
[10:26:38.790]                       is.null <- base::is.null
[10:26:38.790]                       muffled <- FALSE
[10:26:38.790]                       if (inherits(cond, "message")) {
[10:26:38.790]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.790]                         if (muffled) 
[10:26:38.790]                           invokeRestart("muffleMessage")
[10:26:38.790]                       }
[10:26:38.790]                       else if (inherits(cond, "warning")) {
[10:26:38.790]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.790]                         if (muffled) 
[10:26:38.790]                           invokeRestart("muffleWarning")
[10:26:38.790]                       }
[10:26:38.790]                       else if (inherits(cond, "condition")) {
[10:26:38.790]                         if (!is.null(pattern)) {
[10:26:38.790]                           computeRestarts <- base::computeRestarts
[10:26:38.790]                           grepl <- base::grepl
[10:26:38.790]                           restarts <- computeRestarts(cond)
[10:26:38.790]                           for (restart in restarts) {
[10:26:38.790]                             name <- restart$name
[10:26:38.790]                             if (is.null(name)) 
[10:26:38.790]                               next
[10:26:38.790]                             if (!grepl(pattern, name)) 
[10:26:38.790]                               next
[10:26:38.790]                             invokeRestart(restart)
[10:26:38.790]                             muffled <- TRUE
[10:26:38.790]                             break
[10:26:38.790]                           }
[10:26:38.790]                         }
[10:26:38.790]                       }
[10:26:38.790]                       invisible(muffled)
[10:26:38.790]                     }
[10:26:38.790]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.790]                   }
[10:26:38.790]                 }
[10:26:38.790]                 else {
[10:26:38.790]                   if (TRUE) {
[10:26:38.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.790]                     {
[10:26:38.790]                       inherits <- base::inherits
[10:26:38.790]                       invokeRestart <- base::invokeRestart
[10:26:38.790]                       is.null <- base::is.null
[10:26:38.790]                       muffled <- FALSE
[10:26:38.790]                       if (inherits(cond, "message")) {
[10:26:38.790]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.790]                         if (muffled) 
[10:26:38.790]                           invokeRestart("muffleMessage")
[10:26:38.790]                       }
[10:26:38.790]                       else if (inherits(cond, "warning")) {
[10:26:38.790]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.790]                         if (muffled) 
[10:26:38.790]                           invokeRestart("muffleWarning")
[10:26:38.790]                       }
[10:26:38.790]                       else if (inherits(cond, "condition")) {
[10:26:38.790]                         if (!is.null(pattern)) {
[10:26:38.790]                           computeRestarts <- base::computeRestarts
[10:26:38.790]                           grepl <- base::grepl
[10:26:38.790]                           restarts <- computeRestarts(cond)
[10:26:38.790]                           for (restart in restarts) {
[10:26:38.790]                             name <- restart$name
[10:26:38.790]                             if (is.null(name)) 
[10:26:38.790]                               next
[10:26:38.790]                             if (!grepl(pattern, name)) 
[10:26:38.790]                               next
[10:26:38.790]                             invokeRestart(restart)
[10:26:38.790]                             muffled <- TRUE
[10:26:38.790]                             break
[10:26:38.790]                           }
[10:26:38.790]                         }
[10:26:38.790]                       }
[10:26:38.790]                       invisible(muffled)
[10:26:38.790]                     }
[10:26:38.790]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.790]                   }
[10:26:38.790]                 }
[10:26:38.790]             }
[10:26:38.790]         }))
[10:26:38.790]     }, error = function(ex) {
[10:26:38.790]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.790]                 ...future.rng), started = ...future.startTime, 
[10:26:38.790]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.790]             version = "1.8"), class = "FutureResult")
[10:26:38.790]     }, finally = {
[10:26:38.790]         if (!identical(...future.workdir, getwd())) 
[10:26:38.790]             setwd(...future.workdir)
[10:26:38.790]         {
[10:26:38.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.790]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.790]             }
[10:26:38.790]             base::options(...future.oldOptions)
[10:26:38.790]             if (.Platform$OS.type == "windows") {
[10:26:38.790]                 old_names <- names(...future.oldEnvVars)
[10:26:38.790]                 envs <- base::Sys.getenv()
[10:26:38.790]                 names <- names(envs)
[10:26:38.790]                 common <- intersect(names, old_names)
[10:26:38.790]                 added <- setdiff(names, old_names)
[10:26:38.790]                 removed <- setdiff(old_names, names)
[10:26:38.790]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.790]                   envs[common]]
[10:26:38.790]                 NAMES <- toupper(changed)
[10:26:38.790]                 args <- list()
[10:26:38.790]                 for (kk in seq_along(NAMES)) {
[10:26:38.790]                   name <- changed[[kk]]
[10:26:38.790]                   NAME <- NAMES[[kk]]
[10:26:38.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.790]                     next
[10:26:38.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.790]                 }
[10:26:38.790]                 NAMES <- toupper(added)
[10:26:38.790]                 for (kk in seq_along(NAMES)) {
[10:26:38.790]                   name <- added[[kk]]
[10:26:38.790]                   NAME <- NAMES[[kk]]
[10:26:38.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.790]                     next
[10:26:38.790]                   args[[name]] <- ""
[10:26:38.790]                 }
[10:26:38.790]                 NAMES <- toupper(removed)
[10:26:38.790]                 for (kk in seq_along(NAMES)) {
[10:26:38.790]                   name <- removed[[kk]]
[10:26:38.790]                   NAME <- NAMES[[kk]]
[10:26:38.790]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.790]                     next
[10:26:38.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.790]                 }
[10:26:38.790]                 if (length(args) > 0) 
[10:26:38.790]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.790]             }
[10:26:38.790]             else {
[10:26:38.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.790]             }
[10:26:38.790]             {
[10:26:38.790]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.790]                   0L) {
[10:26:38.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.790]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.790]                   base::options(opts)
[10:26:38.790]                 }
[10:26:38.790]                 {
[10:26:38.790]                   {
[10:26:38.790]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:38.790]                     NULL
[10:26:38.790]                   }
[10:26:38.790]                   options(future.plan = NULL)
[10:26:38.790]                   if (is.na(NA_character_)) 
[10:26:38.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.790]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:38.790]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.790]                     envir = parent.frame()) 
[10:26:38.790]                   {
[10:26:38.790]                     if (is.function(workers)) 
[10:26:38.790]                       workers <- workers()
[10:26:38.790]                     workers <- structure(as.integer(workers), 
[10:26:38.790]                       class = class(workers))
[10:26:38.790]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.790]                       workers >= 1)
[10:26:38.790]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.790]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.790]                     }
[10:26:38.790]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.790]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.790]                       envir = envir)
[10:26:38.790]                     if (!future$lazy) 
[10:26:38.790]                       future <- run(future)
[10:26:38.790]                     invisible(future)
[10:26:38.790]                   }, b = function (..., envir = parent.frame()) 
[10:26:38.790]                   {
[10:26:38.790]                     future <- SequentialFuture(..., envir = envir)
[10:26:38.790]                     if (!future$lazy) 
[10:26:38.790]                       future <- run(future)
[10:26:38.790]                     invisible(future)
[10:26:38.790]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.790]                 }
[10:26:38.790]             }
[10:26:38.790]         }
[10:26:38.790]     })
[10:26:38.790]     if (TRUE) {
[10:26:38.790]         base::sink(type = "output", split = FALSE)
[10:26:38.790]         if (TRUE) {
[10:26:38.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.790]         }
[10:26:38.790]         else {
[10:26:38.790]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.790]         }
[10:26:38.790]         base::close(...future.stdout)
[10:26:38.790]         ...future.stdout <- NULL
[10:26:38.790]     }
[10:26:38.790]     ...future.result$conditions <- ...future.conditions
[10:26:38.790]     ...future.result$finished <- base::Sys.time()
[10:26:38.790]     ...future.result
[10:26:38.790] }
[10:26:38.793] Exporting 2 global objects (55.46 KiB) to cluster node #1 ...
[10:26:38.793] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ...
[10:26:38.838] Exporting ‘nested’ (55.34 KiB) to cluster node #1 ... DONE
[10:26:38.838] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[10:26:38.839] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[10:26:38.839] Exporting 2 global objects (55.46 KiB) to cluster node #1 ... DONE
[10:26:38.840] MultisessionFuture started
[10:26:38.840] - Launch lazy future ... done
[10:26:38.840] run() for ‘MultisessionFuture’ ... done
[10:26:38.840] result() for ClusterFuture ...
[10:26:38.840] receiveMessageFromWorker() for ClusterFuture ...
[10:26:38.840] - Validating connection of MultisessionFuture
[10:26:38.908] - received message: FutureResult
[10:26:38.908] - Received FutureResult
[10:26:38.908] - Erased future from FutureRegistry
[10:26:38.908] result() for ClusterFuture ...
[10:26:38.908] - result already collected: FutureResult
[10:26:38.908] result() for ClusterFuture ... done
[10:26:38.909] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:38.909] result() for ClusterFuture ... done
[10:26:38.909] result() for ClusterFuture ...
[10:26:38.909] - result already collected: FutureResult
[10:26:38.909] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:38.918] getGlobalsAndPackages() ...
[10:26:38.918] Searching for globals...
[10:26:38.921] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:38.921] Searching for globals ... DONE
[10:26:38.921] Resolving globals: FALSE
[10:26:38.922] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:38.923] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:38.923] - globals: [1] ‘data’
[10:26:38.923] - packages: [1] ‘future’
[10:26:38.923] getGlobalsAndPackages() ... DONE
[10:26:38.924] run() for ‘Future’ ...
[10:26:38.924] - state: ‘created’
[10:26:38.924] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:38.944] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:38.944] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:38.944]   - Field: ‘node’
[10:26:38.944]   - Field: ‘label’
[10:26:38.945]   - Field: ‘local’
[10:26:38.945]   - Field: ‘owner’
[10:26:38.945]   - Field: ‘envir’
[10:26:38.945]   - Field: ‘workers’
[10:26:38.945]   - Field: ‘packages’
[10:26:38.946]   - Field: ‘gc’
[10:26:38.946]   - Field: ‘conditions’
[10:26:38.946]   - Field: ‘persistent’
[10:26:38.946]   - Field: ‘expr’
[10:26:38.946]   - Field: ‘uuid’
[10:26:38.946]   - Field: ‘seed’
[10:26:38.947]   - Field: ‘version’
[10:26:38.947]   - Field: ‘result’
[10:26:38.947]   - Field: ‘asynchronous’
[10:26:38.947]   - Field: ‘calls’
[10:26:38.947]   - Field: ‘globals’
[10:26:38.948]   - Field: ‘stdout’
[10:26:38.948]   - Field: ‘earlySignal’
[10:26:38.948]   - Field: ‘lazy’
[10:26:38.948]   - Field: ‘state’
[10:26:38.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:38.948] - Launch lazy future ...
[10:26:38.949] Packages needed by the future expression (n = 1): ‘future’
[10:26:38.949] Packages needed by future strategies (n = 1): ‘future’
[10:26:38.950] {
[10:26:38.950]     {
[10:26:38.950]         {
[10:26:38.950]             ...future.startTime <- base::Sys.time()
[10:26:38.950]             {
[10:26:38.950]                 {
[10:26:38.950]                   {
[10:26:38.950]                     {
[10:26:38.950]                       {
[10:26:38.950]                         base::local({
[10:26:38.950]                           has_future <- base::requireNamespace("future", 
[10:26:38.950]                             quietly = TRUE)
[10:26:38.950]                           if (has_future) {
[10:26:38.950]                             ns <- base::getNamespace("future")
[10:26:38.950]                             version <- ns[[".package"]][["version"]]
[10:26:38.950]                             if (is.null(version)) 
[10:26:38.950]                               version <- utils::packageVersion("future")
[10:26:38.950]                           }
[10:26:38.950]                           else {
[10:26:38.950]                             version <- NULL
[10:26:38.950]                           }
[10:26:38.950]                           if (!has_future || version < "1.8.0") {
[10:26:38.950]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:38.950]                               "", base::R.version$version.string), 
[10:26:38.950]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:38.950]                                 base::R.version$platform, 8 * 
[10:26:38.950]                                   base::.Machine$sizeof.pointer), 
[10:26:38.950]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:38.950]                                 "release", "version")], collapse = " "), 
[10:26:38.950]                               hostname = base::Sys.info()[["nodename"]])
[10:26:38.950]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:38.950]                               info)
[10:26:38.950]                             info <- base::paste(info, collapse = "; ")
[10:26:38.950]                             if (!has_future) {
[10:26:38.950]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:38.950]                                 info)
[10:26:38.950]                             }
[10:26:38.950]                             else {
[10:26:38.950]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:38.950]                                 info, version)
[10:26:38.950]                             }
[10:26:38.950]                             base::stop(msg)
[10:26:38.950]                           }
[10:26:38.950]                         })
[10:26:38.950]                       }
[10:26:38.950]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:38.950]                       base::options(mc.cores = 1L)
[10:26:38.950]                     }
[10:26:38.950]                     base::local({
[10:26:38.950]                       for (pkg in "future") {
[10:26:38.950]                         base::loadNamespace(pkg)
[10:26:38.950]                         base::library(pkg, character.only = TRUE)
[10:26:38.950]                       }
[10:26:38.950]                     })
[10:26:38.950]                   }
[10:26:38.950]                   options(future.plan = NULL)
[10:26:38.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.950]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:26:38.950]                   {
[10:26:38.950]                     future <- SequentialFuture(..., envir = envir)
[10:26:38.950]                     if (!future$lazy) 
[10:26:38.950]                       future <- run(future)
[10:26:38.950]                     invisible(future)
[10:26:38.950]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.950]                 }
[10:26:38.950]                 ...future.workdir <- getwd()
[10:26:38.950]             }
[10:26:38.950]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:38.950]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:38.950]         }
[10:26:38.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:38.950]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:38.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:38.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:38.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:38.950]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:38.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:38.950]             base::names(...future.oldOptions))
[10:26:38.950]     }
[10:26:38.950]     if (FALSE) {
[10:26:38.950]     }
[10:26:38.950]     else {
[10:26:38.950]         if (TRUE) {
[10:26:38.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:38.950]                 open = "w")
[10:26:38.950]         }
[10:26:38.950]         else {
[10:26:38.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:38.950]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:38.950]         }
[10:26:38.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:38.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:38.950]             base::sink(type = "output", split = FALSE)
[10:26:38.950]             base::close(...future.stdout)
[10:26:38.950]         }, add = TRUE)
[10:26:38.950]     }
[10:26:38.950]     ...future.frame <- base::sys.nframe()
[10:26:38.950]     ...future.conditions <- base::list()
[10:26:38.950]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:38.950]     if (FALSE) {
[10:26:38.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:38.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:38.950]     }
[10:26:38.950]     ...future.result <- base::tryCatch({
[10:26:38.950]         base::withCallingHandlers({
[10:26:38.950]             ...future.value <- base::withVisible(base::local({
[10:26:38.950]                 ...future.makeSendCondition <- base::local({
[10:26:38.950]                   sendCondition <- NULL
[10:26:38.950]                   function(frame = 1L) {
[10:26:38.950]                     if (is.function(sendCondition)) 
[10:26:38.950]                       return(sendCondition)
[10:26:38.950]                     ns <- getNamespace("parallel")
[10:26:38.950]                     if (exists("sendData", mode = "function", 
[10:26:38.950]                       envir = ns)) {
[10:26:38.950]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:38.950]                         envir = ns)
[10:26:38.950]                       envir <- sys.frame(frame)
[10:26:38.950]                       master <- NULL
[10:26:38.950]                       while (!identical(envir, .GlobalEnv) && 
[10:26:38.950]                         !identical(envir, emptyenv())) {
[10:26:38.950]                         if (exists("master", mode = "list", envir = envir, 
[10:26:38.950]                           inherits = FALSE)) {
[10:26:38.950]                           master <- get("master", mode = "list", 
[10:26:38.950]                             envir = envir, inherits = FALSE)
[10:26:38.950]                           if (inherits(master, c("SOCKnode", 
[10:26:38.950]                             "SOCK0node"))) {
[10:26:38.950]                             sendCondition <<- function(cond) {
[10:26:38.950]                               data <- list(type = "VALUE", value = cond, 
[10:26:38.950]                                 success = TRUE)
[10:26:38.950]                               parallel_sendData(master, data)
[10:26:38.950]                             }
[10:26:38.950]                             return(sendCondition)
[10:26:38.950]                           }
[10:26:38.950]                         }
[10:26:38.950]                         frame <- frame + 1L
[10:26:38.950]                         envir <- sys.frame(frame)
[10:26:38.950]                       }
[10:26:38.950]                     }
[10:26:38.950]                     sendCondition <<- function(cond) NULL
[10:26:38.950]                   }
[10:26:38.950]                 })
[10:26:38.950]                 withCallingHandlers({
[10:26:38.950]                   {
[10:26:38.950]                     value(future(subset(data, a == 2)))
[10:26:38.950]                   }
[10:26:38.950]                 }, immediateCondition = function(cond) {
[10:26:38.950]                   sendCondition <- ...future.makeSendCondition()
[10:26:38.950]                   sendCondition(cond)
[10:26:38.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.950]                   {
[10:26:38.950]                     inherits <- base::inherits
[10:26:38.950]                     invokeRestart <- base::invokeRestart
[10:26:38.950]                     is.null <- base::is.null
[10:26:38.950]                     muffled <- FALSE
[10:26:38.950]                     if (inherits(cond, "message")) {
[10:26:38.950]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:38.950]                       if (muffled) 
[10:26:38.950]                         invokeRestart("muffleMessage")
[10:26:38.950]                     }
[10:26:38.950]                     else if (inherits(cond, "warning")) {
[10:26:38.950]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:38.950]                       if (muffled) 
[10:26:38.950]                         invokeRestart("muffleWarning")
[10:26:38.950]                     }
[10:26:38.950]                     else if (inherits(cond, "condition")) {
[10:26:38.950]                       if (!is.null(pattern)) {
[10:26:38.950]                         computeRestarts <- base::computeRestarts
[10:26:38.950]                         grepl <- base::grepl
[10:26:38.950]                         restarts <- computeRestarts(cond)
[10:26:38.950]                         for (restart in restarts) {
[10:26:38.950]                           name <- restart$name
[10:26:38.950]                           if (is.null(name)) 
[10:26:38.950]                             next
[10:26:38.950]                           if (!grepl(pattern, name)) 
[10:26:38.950]                             next
[10:26:38.950]                           invokeRestart(restart)
[10:26:38.950]                           muffled <- TRUE
[10:26:38.950]                           break
[10:26:38.950]                         }
[10:26:38.950]                       }
[10:26:38.950]                     }
[10:26:38.950]                     invisible(muffled)
[10:26:38.950]                   }
[10:26:38.950]                   muffleCondition(cond)
[10:26:38.950]                 })
[10:26:38.950]             }))
[10:26:38.950]             future::FutureResult(value = ...future.value$value, 
[10:26:38.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.950]                   ...future.rng), globalenv = if (FALSE) 
[10:26:38.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:38.950]                     ...future.globalenv.names))
[10:26:38.950]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:38.950]         }, condition = base::local({
[10:26:38.950]             c <- base::c
[10:26:38.950]             inherits <- base::inherits
[10:26:38.950]             invokeRestart <- base::invokeRestart
[10:26:38.950]             length <- base::length
[10:26:38.950]             list <- base::list
[10:26:38.950]             seq.int <- base::seq.int
[10:26:38.950]             signalCondition <- base::signalCondition
[10:26:38.950]             sys.calls <- base::sys.calls
[10:26:38.950]             `[[` <- base::`[[`
[10:26:38.950]             `+` <- base::`+`
[10:26:38.950]             `<<-` <- base::`<<-`
[10:26:38.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:38.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:38.950]                   3L)]
[10:26:38.950]             }
[10:26:38.950]             function(cond) {
[10:26:38.950]                 is_error <- inherits(cond, "error")
[10:26:38.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:38.950]                   NULL)
[10:26:38.950]                 if (is_error) {
[10:26:38.950]                   sessionInformation <- function() {
[10:26:38.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:38.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:38.950]                       search = base::search(), system = base::Sys.info())
[10:26:38.950]                   }
[10:26:38.950]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:38.950]                     cond$call), session = sessionInformation(), 
[10:26:38.950]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:38.950]                   signalCondition(cond)
[10:26:38.950]                 }
[10:26:38.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:38.950]                 "immediateCondition"))) {
[10:26:38.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:38.950]                   ...future.conditions[[length(...future.conditions) + 
[10:26:38.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:38.950]                   if (TRUE && !signal) {
[10:26:38.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.950]                     {
[10:26:38.950]                       inherits <- base::inherits
[10:26:38.950]                       invokeRestart <- base::invokeRestart
[10:26:38.950]                       is.null <- base::is.null
[10:26:38.950]                       muffled <- FALSE
[10:26:38.950]                       if (inherits(cond, "message")) {
[10:26:38.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.950]                         if (muffled) 
[10:26:38.950]                           invokeRestart("muffleMessage")
[10:26:38.950]                       }
[10:26:38.950]                       else if (inherits(cond, "warning")) {
[10:26:38.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.950]                         if (muffled) 
[10:26:38.950]                           invokeRestart("muffleWarning")
[10:26:38.950]                       }
[10:26:38.950]                       else if (inherits(cond, "condition")) {
[10:26:38.950]                         if (!is.null(pattern)) {
[10:26:38.950]                           computeRestarts <- base::computeRestarts
[10:26:38.950]                           grepl <- base::grepl
[10:26:38.950]                           restarts <- computeRestarts(cond)
[10:26:38.950]                           for (restart in restarts) {
[10:26:38.950]                             name <- restart$name
[10:26:38.950]                             if (is.null(name)) 
[10:26:38.950]                               next
[10:26:38.950]                             if (!grepl(pattern, name)) 
[10:26:38.950]                               next
[10:26:38.950]                             invokeRestart(restart)
[10:26:38.950]                             muffled <- TRUE
[10:26:38.950]                             break
[10:26:38.950]                           }
[10:26:38.950]                         }
[10:26:38.950]                       }
[10:26:38.950]                       invisible(muffled)
[10:26:38.950]                     }
[10:26:38.950]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.950]                   }
[10:26:38.950]                 }
[10:26:38.950]                 else {
[10:26:38.950]                   if (TRUE) {
[10:26:38.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:38.950]                     {
[10:26:38.950]                       inherits <- base::inherits
[10:26:38.950]                       invokeRestart <- base::invokeRestart
[10:26:38.950]                       is.null <- base::is.null
[10:26:38.950]                       muffled <- FALSE
[10:26:38.950]                       if (inherits(cond, "message")) {
[10:26:38.950]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:38.950]                         if (muffled) 
[10:26:38.950]                           invokeRestart("muffleMessage")
[10:26:38.950]                       }
[10:26:38.950]                       else if (inherits(cond, "warning")) {
[10:26:38.950]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:38.950]                         if (muffled) 
[10:26:38.950]                           invokeRestart("muffleWarning")
[10:26:38.950]                       }
[10:26:38.950]                       else if (inherits(cond, "condition")) {
[10:26:38.950]                         if (!is.null(pattern)) {
[10:26:38.950]                           computeRestarts <- base::computeRestarts
[10:26:38.950]                           grepl <- base::grepl
[10:26:38.950]                           restarts <- computeRestarts(cond)
[10:26:38.950]                           for (restart in restarts) {
[10:26:38.950]                             name <- restart$name
[10:26:38.950]                             if (is.null(name)) 
[10:26:38.950]                               next
[10:26:38.950]                             if (!grepl(pattern, name)) 
[10:26:38.950]                               next
[10:26:38.950]                             invokeRestart(restart)
[10:26:38.950]                             muffled <- TRUE
[10:26:38.950]                             break
[10:26:38.950]                           }
[10:26:38.950]                         }
[10:26:38.950]                       }
[10:26:38.950]                       invisible(muffled)
[10:26:38.950]                     }
[10:26:38.950]                     muffleCondition(cond, pattern = "^muffle")
[10:26:38.950]                   }
[10:26:38.950]                 }
[10:26:38.950]             }
[10:26:38.950]         }))
[10:26:38.950]     }, error = function(ex) {
[10:26:38.950]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:38.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:38.950]                 ...future.rng), started = ...future.startTime, 
[10:26:38.950]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:38.950]             version = "1.8"), class = "FutureResult")
[10:26:38.950]     }, finally = {
[10:26:38.950]         if (!identical(...future.workdir, getwd())) 
[10:26:38.950]             setwd(...future.workdir)
[10:26:38.950]         {
[10:26:38.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:38.950]                 ...future.oldOptions$nwarnings <- NULL
[10:26:38.950]             }
[10:26:38.950]             base::options(...future.oldOptions)
[10:26:38.950]             if (.Platform$OS.type == "windows") {
[10:26:38.950]                 old_names <- names(...future.oldEnvVars)
[10:26:38.950]                 envs <- base::Sys.getenv()
[10:26:38.950]                 names <- names(envs)
[10:26:38.950]                 common <- intersect(names, old_names)
[10:26:38.950]                 added <- setdiff(names, old_names)
[10:26:38.950]                 removed <- setdiff(old_names, names)
[10:26:38.950]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:38.950]                   envs[common]]
[10:26:38.950]                 NAMES <- toupper(changed)
[10:26:38.950]                 args <- list()
[10:26:38.950]                 for (kk in seq_along(NAMES)) {
[10:26:38.950]                   name <- changed[[kk]]
[10:26:38.950]                   NAME <- NAMES[[kk]]
[10:26:38.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.950]                     next
[10:26:38.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.950]                 }
[10:26:38.950]                 NAMES <- toupper(added)
[10:26:38.950]                 for (kk in seq_along(NAMES)) {
[10:26:38.950]                   name <- added[[kk]]
[10:26:38.950]                   NAME <- NAMES[[kk]]
[10:26:38.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.950]                     next
[10:26:38.950]                   args[[name]] <- ""
[10:26:38.950]                 }
[10:26:38.950]                 NAMES <- toupper(removed)
[10:26:38.950]                 for (kk in seq_along(NAMES)) {
[10:26:38.950]                   name <- removed[[kk]]
[10:26:38.950]                   NAME <- NAMES[[kk]]
[10:26:38.950]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:38.950]                     next
[10:26:38.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:38.950]                 }
[10:26:38.950]                 if (length(args) > 0) 
[10:26:38.950]                   base::do.call(base::Sys.setenv, args = args)
[10:26:38.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:38.950]             }
[10:26:38.950]             else {
[10:26:38.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:38.950]             }
[10:26:38.950]             {
[10:26:38.950]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:38.950]                   0L) {
[10:26:38.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:38.950]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:38.950]                   base::options(opts)
[10:26:38.950]                 }
[10:26:38.950]                 {
[10:26:38.950]                   {
[10:26:38.950]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:38.950]                     NULL
[10:26:38.950]                   }
[10:26:38.950]                   options(future.plan = NULL)
[10:26:38.950]                   if (is.na(NA_character_)) 
[10:26:38.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:38.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:38.950]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:38.950]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:38.950]                     envir = parent.frame()) 
[10:26:38.950]                   {
[10:26:38.950]                     if (is.function(workers)) 
[10:26:38.950]                       workers <- workers()
[10:26:38.950]                     workers <- structure(as.integer(workers), 
[10:26:38.950]                       class = class(workers))
[10:26:38.950]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:38.950]                       workers >= 1)
[10:26:38.950]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:38.950]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:38.950]                     }
[10:26:38.950]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:38.950]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:38.950]                       envir = envir)
[10:26:38.950]                     if (!future$lazy) 
[10:26:38.950]                       future <- run(future)
[10:26:38.950]                     invisible(future)
[10:26:38.950]                   }, b = function (..., envir = parent.frame()) 
[10:26:38.950]                   {
[10:26:38.950]                     future <- SequentialFuture(..., envir = envir)
[10:26:38.950]                     if (!future$lazy) 
[10:26:38.950]                       future <- run(future)
[10:26:38.950]                     invisible(future)
[10:26:38.950]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:38.950]                 }
[10:26:38.950]             }
[10:26:38.950]         }
[10:26:38.950]     })
[10:26:38.950]     if (TRUE) {
[10:26:38.950]         base::sink(type = "output", split = FALSE)
[10:26:38.950]         if (TRUE) {
[10:26:38.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:38.950]         }
[10:26:38.950]         else {
[10:26:38.950]             ...future.result["stdout"] <- base::list(NULL)
[10:26:38.950]         }
[10:26:38.950]         base::close(...future.stdout)
[10:26:38.950]         ...future.stdout <- NULL
[10:26:38.950]     }
[10:26:38.950]     ...future.result$conditions <- ...future.conditions
[10:26:38.950]     ...future.result$finished <- base::Sys.time()
[10:26:38.950]     ...future.result
[10:26:38.950] }
[10:26:38.955] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:26:38.956] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:26:38.956] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:26:38.956] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:26:38.957] MultisessionFuture started
[10:26:38.957] - Launch lazy future ... done
[10:26:38.957] run() for ‘MultisessionFuture’ ... done
[10:26:38.957] result() for ClusterFuture ...
[10:26:38.957] receiveMessageFromWorker() for ClusterFuture ...
[10:26:38.958] - Validating connection of MultisessionFuture
[10:26:39.007] - received message: FutureResult
[10:26:39.008] - Received FutureResult
[10:26:39.008] - Erased future from FutureRegistry
[10:26:39.008] result() for ClusterFuture ...
[10:26:39.008] - result already collected: FutureResult
[10:26:39.008] result() for ClusterFuture ... done
[10:26:39.008] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:39.008] result() for ClusterFuture ... done
[10:26:39.009] result() for ClusterFuture ...
[10:26:39.009] - result already collected: FutureResult
[10:26:39.009] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[10:26:39.009] plan(): Setting new future strategy stack:
[10:26:39.009] List of future strategies:
[10:26:39.009] 1. multisession:
[10:26:39.009]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:39.009]    - tweaked: FALSE
[10:26:39.009]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:39.009] 2. multicore:
[10:26:39.009]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:26:39.009]    - tweaked: FALSE
[10:26:39.009]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:39.010] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:39.010] multisession:
[10:26:39.010] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:39.010] - tweaked: FALSE
[10:26:39.010] - call: plan(list(a = strategy1, b = strategy2))
[10:26:39.014] getGlobalsAndPackages() ...
[10:26:39.014] Not searching for globals
[10:26:39.014] - globals: [0] <none>
[10:26:39.014] getGlobalsAndPackages() ... DONE
[10:26:39.015] [local output] makeClusterPSOCK() ...
[10:26:39.019] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:39.020] [local output] Base port: 11282
[10:26:39.020] [local output] Getting setup options for 2 cluster nodes ...
[10:26:39.020] [local output]  - Node 1 of 2 ...
[10:26:39.021] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:39.022] [local output] Rscript port: 11282

[10:26:39.022] [local output]  - Node 2 of 2 ...
[10:26:39.023] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:39.024] [local output] Rscript port: 11282

[10:26:39.024] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:39.024] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:39.024] [local output] Setting up PSOCK nodes in parallel
[10:26:39.025] List of 36
[10:26:39.025]  $ worker          : chr "localhost"
[10:26:39.025]   ..- attr(*, "localhost")= logi TRUE
[10:26:39.025]  $ master          : chr "localhost"
[10:26:39.025]  $ port            : int 11282
[10:26:39.025]  $ connectTimeout  : num 120
[10:26:39.025]  $ timeout         : num 2592000
[10:26:39.025]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:39.025]  $ homogeneous     : logi TRUE
[10:26:39.025]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:39.025]  $ rscript_envs    : NULL
[10:26:39.025]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:39.025]  $ rscript_startup : NULL
[10:26:39.025]  $ rscript_sh      : chr "sh"
[10:26:39.025]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:39.025]  $ methods         : logi TRUE
[10:26:39.025]  $ socketOptions   : chr "no-delay"
[10:26:39.025]  $ useXDR          : logi FALSE
[10:26:39.025]  $ outfile         : chr "/dev/null"
[10:26:39.025]  $ renice          : int NA
[10:26:39.025]  $ rshcmd          : NULL
[10:26:39.025]  $ user            : chr(0) 
[10:26:39.025]  $ revtunnel       : logi FALSE
[10:26:39.025]  $ rshlogfile      : NULL
[10:26:39.025]  $ rshopts         : chr(0) 
[10:26:39.025]  $ rank            : int 1
[10:26:39.025]  $ manual          : logi FALSE
[10:26:39.025]  $ dryrun          : logi FALSE
[10:26:39.025]  $ quiet           : logi FALSE
[10:26:39.025]  $ setup_strategy  : chr "parallel"
[10:26:39.025]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:39.025]  $ pidfile         : chr "/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b2fc48afb.pid"
[10:26:39.025]  $ rshcmd_label    : NULL
[10:26:39.025]  $ rsh_call        : NULL
[10:26:39.025]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:39.025]  $ localMachine    : logi TRUE
[10:26:39.025]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:39.025]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:39.025]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:39.025]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:39.025]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:39.025]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:39.025]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:39.025]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:39.025]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:39.025]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:39.025]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:39.025]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:39.025]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:39.025]  $ arguments       :List of 28
[10:26:39.025]   ..$ worker          : chr "localhost"
[10:26:39.025]   ..$ master          : NULL
[10:26:39.025]   ..$ port            : int 11282
[10:26:39.025]   ..$ connectTimeout  : num 120
[10:26:39.025]   ..$ timeout         : num 2592000
[10:26:39.025]   ..$ rscript         : NULL
[10:26:39.025]   ..$ homogeneous     : NULL
[10:26:39.025]   ..$ rscript_args    : NULL
[10:26:39.025]   ..$ rscript_envs    : NULL
[10:26:39.025]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:39.025]   ..$ rscript_startup : NULL
[10:26:39.025]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:39.025]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:39.025]   ..$ methods         : logi TRUE
[10:26:39.025]   ..$ socketOptions   : chr "no-delay"
[10:26:39.025]   ..$ useXDR          : logi FALSE
[10:26:39.025]   ..$ outfile         : chr "/dev/null"
[10:26:39.025]   ..$ renice          : int NA
[10:26:39.025]   ..$ rshcmd          : NULL
[10:26:39.025]   ..$ user            : NULL
[10:26:39.025]   ..$ revtunnel       : logi NA
[10:26:39.025]   ..$ rshlogfile      : NULL
[10:26:39.025]   ..$ rshopts         : NULL
[10:26:39.025]   ..$ rank            : int 1
[10:26:39.025]   ..$ manual          : logi FALSE
[10:26:39.025]   ..$ dryrun          : logi FALSE
[10:26:39.025]   ..$ quiet           : logi FALSE
[10:26:39.025]   ..$ setup_strategy  : chr "parallel"
[10:26:39.025]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:39.042] [local output] System call to launch all workers:
[10:26:39.042] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b2fc48afb.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11282 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:39.043] [local output] Starting PSOCK main server
[10:26:39.044] [local output] Workers launched
[10:26:39.044] [local output] Waiting for workers to connect back
[10:26:39.044]  - [local output] 0 workers out of 2 ready
[10:26:39.296]  - [local output] 0 workers out of 2 ready
[10:26:39.296]  - [local output] 1 workers out of 2 ready
[10:26:39.300]  - [local output] 1 workers out of 2 ready
[10:26:39.301]  - [local output] 2 workers out of 2 ready
[10:26:39.301] [local output] Launching of workers completed
[10:26:39.301] [local output] Collecting session information from workers
[10:26:39.302] [local output]  - Worker #1 of 2
[10:26:39.302] [local output]  - Worker #2 of 2
[10:26:39.302] [local output] makeClusterPSOCK() ... done
[10:26:39.313] Packages needed by the future expression (n = 0): <none>
[10:26:39.314] Packages needed by future strategies (n = 1): ‘future’
[10:26:39.314] {
[10:26:39.314]     {
[10:26:39.314]         {
[10:26:39.314]             ...future.startTime <- base::Sys.time()
[10:26:39.314]             {
[10:26:39.314]                 {
[10:26:39.314]                   {
[10:26:39.314]                     {
[10:26:39.314]                       {
[10:26:39.314]                         base::local({
[10:26:39.314]                           has_future <- base::requireNamespace("future", 
[10:26:39.314]                             quietly = TRUE)
[10:26:39.314]                           if (has_future) {
[10:26:39.314]                             ns <- base::getNamespace("future")
[10:26:39.314]                             version <- ns[[".package"]][["version"]]
[10:26:39.314]                             if (is.null(version)) 
[10:26:39.314]                               version <- utils::packageVersion("future")
[10:26:39.314]                           }
[10:26:39.314]                           else {
[10:26:39.314]                             version <- NULL
[10:26:39.314]                           }
[10:26:39.314]                           if (!has_future || version < "1.8.0") {
[10:26:39.314]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:39.314]                               "", base::R.version$version.string), 
[10:26:39.314]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:39.314]                                 base::R.version$platform, 8 * 
[10:26:39.314]                                   base::.Machine$sizeof.pointer), 
[10:26:39.314]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:39.314]                                 "release", "version")], collapse = " "), 
[10:26:39.314]                               hostname = base::Sys.info()[["nodename"]])
[10:26:39.314]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:39.314]                               info)
[10:26:39.314]                             info <- base::paste(info, collapse = "; ")
[10:26:39.314]                             if (!has_future) {
[10:26:39.314]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:39.314]                                 info)
[10:26:39.314]                             }
[10:26:39.314]                             else {
[10:26:39.314]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:39.314]                                 info, version)
[10:26:39.314]                             }
[10:26:39.314]                             base::stop(msg)
[10:26:39.314]                           }
[10:26:39.314]                         })
[10:26:39.314]                       }
[10:26:39.314]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:39.314]                       base::options(mc.cores = 1L)
[10:26:39.314]                     }
[10:26:39.314]                     base::local({
[10:26:39.314]                       for (pkg in "future") {
[10:26:39.314]                         base::loadNamespace(pkg)
[10:26:39.314]                         base::library(pkg, character.only = TRUE)
[10:26:39.314]                       }
[10:26:39.314]                     })
[10:26:39.314]                   }
[10:26:39.314]                   options(future.plan = NULL)
[10:26:39.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:39.314]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:39.314]                     envir = parent.frame()) 
[10:26:39.314]                   {
[10:26:39.314]                     default_workers <- missing(workers)
[10:26:39.314]                     if (is.function(workers)) 
[10:26:39.314]                       workers <- workers()
[10:26:39.314]                     workers <- structure(as.integer(workers), 
[10:26:39.314]                       class = class(workers))
[10:26:39.314]                     stop_if_not(is.finite(workers), workers >= 
[10:26:39.314]                       1L)
[10:26:39.314]                     if ((workers == 1L && !inherits(workers, 
[10:26:39.314]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:39.314]                       if (default_workers) 
[10:26:39.314]                         supportsMulticore(warn = TRUE)
[10:26:39.314]                       return(sequential(..., envir = envir))
[10:26:39.314]                     }
[10:26:39.314]                     oopts <- options(mc.cores = workers)
[10:26:39.314]                     on.exit(options(oopts))
[10:26:39.314]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:39.314]                       envir = envir)
[10:26:39.314]                     if (!future$lazy) 
[10:26:39.314]                       future <- run(future)
[10:26:39.314]                     invisible(future)
[10:26:39.314]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:39.314]                 }
[10:26:39.314]                 ...future.workdir <- getwd()
[10:26:39.314]             }
[10:26:39.314]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:39.314]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:39.314]         }
[10:26:39.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:39.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:39.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:39.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:39.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:39.314]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:39.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:39.314]             base::names(...future.oldOptions))
[10:26:39.314]     }
[10:26:39.314]     if (FALSE) {
[10:26:39.314]     }
[10:26:39.314]     else {
[10:26:39.314]         if (TRUE) {
[10:26:39.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:39.314]                 open = "w")
[10:26:39.314]         }
[10:26:39.314]         else {
[10:26:39.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:39.314]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:39.314]         }
[10:26:39.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:39.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:39.314]             base::sink(type = "output", split = FALSE)
[10:26:39.314]             base::close(...future.stdout)
[10:26:39.314]         }, add = TRUE)
[10:26:39.314]     }
[10:26:39.314]     ...future.frame <- base::sys.nframe()
[10:26:39.314]     ...future.conditions <- base::list()
[10:26:39.314]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:39.314]     if (FALSE) {
[10:26:39.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:39.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:39.314]     }
[10:26:39.314]     ...future.result <- base::tryCatch({
[10:26:39.314]         base::withCallingHandlers({
[10:26:39.314]             ...future.value <- base::withVisible(base::local({
[10:26:39.314]                 ...future.makeSendCondition <- base::local({
[10:26:39.314]                   sendCondition <- NULL
[10:26:39.314]                   function(frame = 1L) {
[10:26:39.314]                     if (is.function(sendCondition)) 
[10:26:39.314]                       return(sendCondition)
[10:26:39.314]                     ns <- getNamespace("parallel")
[10:26:39.314]                     if (exists("sendData", mode = "function", 
[10:26:39.314]                       envir = ns)) {
[10:26:39.314]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:39.314]                         envir = ns)
[10:26:39.314]                       envir <- sys.frame(frame)
[10:26:39.314]                       master <- NULL
[10:26:39.314]                       while (!identical(envir, .GlobalEnv) && 
[10:26:39.314]                         !identical(envir, emptyenv())) {
[10:26:39.314]                         if (exists("master", mode = "list", envir = envir, 
[10:26:39.314]                           inherits = FALSE)) {
[10:26:39.314]                           master <- get("master", mode = "list", 
[10:26:39.314]                             envir = envir, inherits = FALSE)
[10:26:39.314]                           if (inherits(master, c("SOCKnode", 
[10:26:39.314]                             "SOCK0node"))) {
[10:26:39.314]                             sendCondition <<- function(cond) {
[10:26:39.314]                               data <- list(type = "VALUE", value = cond, 
[10:26:39.314]                                 success = TRUE)
[10:26:39.314]                               parallel_sendData(master, data)
[10:26:39.314]                             }
[10:26:39.314]                             return(sendCondition)
[10:26:39.314]                           }
[10:26:39.314]                         }
[10:26:39.314]                         frame <- frame + 1L
[10:26:39.314]                         envir <- sys.frame(frame)
[10:26:39.314]                       }
[10:26:39.314]                     }
[10:26:39.314]                     sendCondition <<- function(cond) NULL
[10:26:39.314]                   }
[10:26:39.314]                 })
[10:26:39.314]                 withCallingHandlers({
[10:26:39.314]                   NA
[10:26:39.314]                 }, immediateCondition = function(cond) {
[10:26:39.314]                   sendCondition <- ...future.makeSendCondition()
[10:26:39.314]                   sendCondition(cond)
[10:26:39.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.314]                   {
[10:26:39.314]                     inherits <- base::inherits
[10:26:39.314]                     invokeRestart <- base::invokeRestart
[10:26:39.314]                     is.null <- base::is.null
[10:26:39.314]                     muffled <- FALSE
[10:26:39.314]                     if (inherits(cond, "message")) {
[10:26:39.314]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:39.314]                       if (muffled) 
[10:26:39.314]                         invokeRestart("muffleMessage")
[10:26:39.314]                     }
[10:26:39.314]                     else if (inherits(cond, "warning")) {
[10:26:39.314]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:39.314]                       if (muffled) 
[10:26:39.314]                         invokeRestart("muffleWarning")
[10:26:39.314]                     }
[10:26:39.314]                     else if (inherits(cond, "condition")) {
[10:26:39.314]                       if (!is.null(pattern)) {
[10:26:39.314]                         computeRestarts <- base::computeRestarts
[10:26:39.314]                         grepl <- base::grepl
[10:26:39.314]                         restarts <- computeRestarts(cond)
[10:26:39.314]                         for (restart in restarts) {
[10:26:39.314]                           name <- restart$name
[10:26:39.314]                           if (is.null(name)) 
[10:26:39.314]                             next
[10:26:39.314]                           if (!grepl(pattern, name)) 
[10:26:39.314]                             next
[10:26:39.314]                           invokeRestart(restart)
[10:26:39.314]                           muffled <- TRUE
[10:26:39.314]                           break
[10:26:39.314]                         }
[10:26:39.314]                       }
[10:26:39.314]                     }
[10:26:39.314]                     invisible(muffled)
[10:26:39.314]                   }
[10:26:39.314]                   muffleCondition(cond)
[10:26:39.314]                 })
[10:26:39.314]             }))
[10:26:39.314]             future::FutureResult(value = ...future.value$value, 
[10:26:39.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:39.314]                   ...future.rng), globalenv = if (FALSE) 
[10:26:39.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:39.314]                     ...future.globalenv.names))
[10:26:39.314]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:39.314]         }, condition = base::local({
[10:26:39.314]             c <- base::c
[10:26:39.314]             inherits <- base::inherits
[10:26:39.314]             invokeRestart <- base::invokeRestart
[10:26:39.314]             length <- base::length
[10:26:39.314]             list <- base::list
[10:26:39.314]             seq.int <- base::seq.int
[10:26:39.314]             signalCondition <- base::signalCondition
[10:26:39.314]             sys.calls <- base::sys.calls
[10:26:39.314]             `[[` <- base::`[[`
[10:26:39.314]             `+` <- base::`+`
[10:26:39.314]             `<<-` <- base::`<<-`
[10:26:39.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:39.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:39.314]                   3L)]
[10:26:39.314]             }
[10:26:39.314]             function(cond) {
[10:26:39.314]                 is_error <- inherits(cond, "error")
[10:26:39.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:39.314]                   NULL)
[10:26:39.314]                 if (is_error) {
[10:26:39.314]                   sessionInformation <- function() {
[10:26:39.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:39.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:39.314]                       search = base::search(), system = base::Sys.info())
[10:26:39.314]                   }
[10:26:39.314]                   ...future.conditions[[length(...future.conditions) + 
[10:26:39.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:39.314]                     cond$call), session = sessionInformation(), 
[10:26:39.314]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:39.314]                   signalCondition(cond)
[10:26:39.314]                 }
[10:26:39.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:39.314]                 "immediateCondition"))) {
[10:26:39.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:39.314]                   ...future.conditions[[length(...future.conditions) + 
[10:26:39.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:39.314]                   if (TRUE && !signal) {
[10:26:39.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.314]                     {
[10:26:39.314]                       inherits <- base::inherits
[10:26:39.314]                       invokeRestart <- base::invokeRestart
[10:26:39.314]                       is.null <- base::is.null
[10:26:39.314]                       muffled <- FALSE
[10:26:39.314]                       if (inherits(cond, "message")) {
[10:26:39.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:39.314]                         if (muffled) 
[10:26:39.314]                           invokeRestart("muffleMessage")
[10:26:39.314]                       }
[10:26:39.314]                       else if (inherits(cond, "warning")) {
[10:26:39.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:39.314]                         if (muffled) 
[10:26:39.314]                           invokeRestart("muffleWarning")
[10:26:39.314]                       }
[10:26:39.314]                       else if (inherits(cond, "condition")) {
[10:26:39.314]                         if (!is.null(pattern)) {
[10:26:39.314]                           computeRestarts <- base::computeRestarts
[10:26:39.314]                           grepl <- base::grepl
[10:26:39.314]                           restarts <- computeRestarts(cond)
[10:26:39.314]                           for (restart in restarts) {
[10:26:39.314]                             name <- restart$name
[10:26:39.314]                             if (is.null(name)) 
[10:26:39.314]                               next
[10:26:39.314]                             if (!grepl(pattern, name)) 
[10:26:39.314]                               next
[10:26:39.314]                             invokeRestart(restart)
[10:26:39.314]                             muffled <- TRUE
[10:26:39.314]                             break
[10:26:39.314]                           }
[10:26:39.314]                         }
[10:26:39.314]                       }
[10:26:39.314]                       invisible(muffled)
[10:26:39.314]                     }
[10:26:39.314]                     muffleCondition(cond, pattern = "^muffle")
[10:26:39.314]                   }
[10:26:39.314]                 }
[10:26:39.314]                 else {
[10:26:39.314]                   if (TRUE) {
[10:26:39.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.314]                     {
[10:26:39.314]                       inherits <- base::inherits
[10:26:39.314]                       invokeRestart <- base::invokeRestart
[10:26:39.314]                       is.null <- base::is.null
[10:26:39.314]                       muffled <- FALSE
[10:26:39.314]                       if (inherits(cond, "message")) {
[10:26:39.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:39.314]                         if (muffled) 
[10:26:39.314]                           invokeRestart("muffleMessage")
[10:26:39.314]                       }
[10:26:39.314]                       else if (inherits(cond, "warning")) {
[10:26:39.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:39.314]                         if (muffled) 
[10:26:39.314]                           invokeRestart("muffleWarning")
[10:26:39.314]                       }
[10:26:39.314]                       else if (inherits(cond, "condition")) {
[10:26:39.314]                         if (!is.null(pattern)) {
[10:26:39.314]                           computeRestarts <- base::computeRestarts
[10:26:39.314]                           grepl <- base::grepl
[10:26:39.314]                           restarts <- computeRestarts(cond)
[10:26:39.314]                           for (restart in restarts) {
[10:26:39.314]                             name <- restart$name
[10:26:39.314]                             if (is.null(name)) 
[10:26:39.314]                               next
[10:26:39.314]                             if (!grepl(pattern, name)) 
[10:26:39.314]                               next
[10:26:39.314]                             invokeRestart(restart)
[10:26:39.314]                             muffled <- TRUE
[10:26:39.314]                             break
[10:26:39.314]                           }
[10:26:39.314]                         }
[10:26:39.314]                       }
[10:26:39.314]                       invisible(muffled)
[10:26:39.314]                     }
[10:26:39.314]                     muffleCondition(cond, pattern = "^muffle")
[10:26:39.314]                   }
[10:26:39.314]                 }
[10:26:39.314]             }
[10:26:39.314]         }))
[10:26:39.314]     }, error = function(ex) {
[10:26:39.314]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:39.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:39.314]                 ...future.rng), started = ...future.startTime, 
[10:26:39.314]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:39.314]             version = "1.8"), class = "FutureResult")
[10:26:39.314]     }, finally = {
[10:26:39.314]         if (!identical(...future.workdir, getwd())) 
[10:26:39.314]             setwd(...future.workdir)
[10:26:39.314]         {
[10:26:39.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:39.314]                 ...future.oldOptions$nwarnings <- NULL
[10:26:39.314]             }
[10:26:39.314]             base::options(...future.oldOptions)
[10:26:39.314]             if (.Platform$OS.type == "windows") {
[10:26:39.314]                 old_names <- names(...future.oldEnvVars)
[10:26:39.314]                 envs <- base::Sys.getenv()
[10:26:39.314]                 names <- names(envs)
[10:26:39.314]                 common <- intersect(names, old_names)
[10:26:39.314]                 added <- setdiff(names, old_names)
[10:26:39.314]                 removed <- setdiff(old_names, names)
[10:26:39.314]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:39.314]                   envs[common]]
[10:26:39.314]                 NAMES <- toupper(changed)
[10:26:39.314]                 args <- list()
[10:26:39.314]                 for (kk in seq_along(NAMES)) {
[10:26:39.314]                   name <- changed[[kk]]
[10:26:39.314]                   NAME <- NAMES[[kk]]
[10:26:39.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.314]                     next
[10:26:39.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:39.314]                 }
[10:26:39.314]                 NAMES <- toupper(added)
[10:26:39.314]                 for (kk in seq_along(NAMES)) {
[10:26:39.314]                   name <- added[[kk]]
[10:26:39.314]                   NAME <- NAMES[[kk]]
[10:26:39.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.314]                     next
[10:26:39.314]                   args[[name]] <- ""
[10:26:39.314]                 }
[10:26:39.314]                 NAMES <- toupper(removed)
[10:26:39.314]                 for (kk in seq_along(NAMES)) {
[10:26:39.314]                   name <- removed[[kk]]
[10:26:39.314]                   NAME <- NAMES[[kk]]
[10:26:39.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.314]                     next
[10:26:39.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:39.314]                 }
[10:26:39.314]                 if (length(args) > 0) 
[10:26:39.314]                   base::do.call(base::Sys.setenv, args = args)
[10:26:39.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:39.314]             }
[10:26:39.314]             else {
[10:26:39.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:39.314]             }
[10:26:39.314]             {
[10:26:39.314]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:39.314]                   0L) {
[10:26:39.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:39.314]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:39.314]                   base::options(opts)
[10:26:39.314]                 }
[10:26:39.314]                 {
[10:26:39.314]                   {
[10:26:39.314]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:39.314]                     NULL
[10:26:39.314]                   }
[10:26:39.314]                   options(future.plan = NULL)
[10:26:39.314]                   if (is.na(NA_character_)) 
[10:26:39.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:39.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:39.314]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:39.314]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:39.314]                     envir = parent.frame()) 
[10:26:39.314]                   {
[10:26:39.314]                     if (is.function(workers)) 
[10:26:39.314]                       workers <- workers()
[10:26:39.314]                     workers <- structure(as.integer(workers), 
[10:26:39.314]                       class = class(workers))
[10:26:39.314]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:39.314]                       workers >= 1)
[10:26:39.314]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:39.314]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:39.314]                     }
[10:26:39.314]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:39.314]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:39.314]                       envir = envir)
[10:26:39.314]                     if (!future$lazy) 
[10:26:39.314]                       future <- run(future)
[10:26:39.314]                     invisible(future)
[10:26:39.314]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:39.314]                     envir = parent.frame()) 
[10:26:39.314]                   {
[10:26:39.314]                     default_workers <- missing(workers)
[10:26:39.314]                     if (is.function(workers)) 
[10:26:39.314]                       workers <- workers()
[10:26:39.314]                     workers <- structure(as.integer(workers), 
[10:26:39.314]                       class = class(workers))
[10:26:39.314]                     stop_if_not(is.finite(workers), workers >= 
[10:26:39.314]                       1L)
[10:26:39.314]                     if ((workers == 1L && !inherits(workers, 
[10:26:39.314]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:39.314]                       if (default_workers) 
[10:26:39.314]                         supportsMulticore(warn = TRUE)
[10:26:39.314]                       return(sequential(..., envir = envir))
[10:26:39.314]                     }
[10:26:39.314]                     oopts <- options(mc.cores = workers)
[10:26:39.314]                     on.exit(options(oopts))
[10:26:39.314]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:39.314]                       envir = envir)
[10:26:39.314]                     if (!future$lazy) 
[10:26:39.314]                       future <- run(future)
[10:26:39.314]                     invisible(future)
[10:26:39.314]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:39.314]                 }
[10:26:39.314]             }
[10:26:39.314]         }
[10:26:39.314]     })
[10:26:39.314]     if (TRUE) {
[10:26:39.314]         base::sink(type = "output", split = FALSE)
[10:26:39.314]         if (TRUE) {
[10:26:39.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:39.314]         }
[10:26:39.314]         else {
[10:26:39.314]             ...future.result["stdout"] <- base::list(NULL)
[10:26:39.314]         }
[10:26:39.314]         base::close(...future.stdout)
[10:26:39.314]         ...future.stdout <- NULL
[10:26:39.314]     }
[10:26:39.314]     ...future.result$conditions <- ...future.conditions
[10:26:39.314]     ...future.result$finished <- base::Sys.time()
[10:26:39.314]     ...future.result
[10:26:39.314] }
[10:26:39.370] MultisessionFuture started
[10:26:39.370] result() for ClusterFuture ...
[10:26:39.370] receiveMessageFromWorker() for ClusterFuture ...
[10:26:39.371] - Validating connection of MultisessionFuture
[10:26:39.423] - received message: FutureResult
[10:26:39.423] - Received FutureResult
[10:26:39.423] - Erased future from FutureRegistry
[10:26:39.424] result() for ClusterFuture ...
[10:26:39.424] - result already collected: FutureResult
[10:26:39.424] result() for ClusterFuture ... done
[10:26:39.424] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:39.424] result() for ClusterFuture ... done
[10:26:39.424] result() for ClusterFuture ...
[10:26:39.424] - result already collected: FutureResult
[10:26:39.424] result() for ClusterFuture ... done
[10:26:39.424] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:39.428] plan(): nbrOfWorkers() = 2
[10:26:39.428] getGlobalsAndPackages() ...
[10:26:39.428] Searching for globals...
[10:26:39.446] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:39.446] Searching for globals ... DONE
[10:26:39.446] Resolving globals: FALSE
[10:26:39.447] The total size of the 2 globals is 90.70 KiB (92872 bytes)
[10:26:39.448] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 90.70 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (90.58 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:39.448] - globals: [2] ‘nested’, ‘strategy2’
[10:26:39.448] - packages: [1] ‘future’
[10:26:39.448] getGlobalsAndPackages() ... DONE
[10:26:39.448] run() for ‘Future’ ...
[10:26:39.449] - state: ‘created’
[10:26:39.449] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:39.465] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:39.465] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:39.466]   - Field: ‘node’
[10:26:39.466]   - Field: ‘label’
[10:26:39.466]   - Field: ‘local’
[10:26:39.466]   - Field: ‘owner’
[10:26:39.466]   - Field: ‘envir’
[10:26:39.466]   - Field: ‘workers’
[10:26:39.466]   - Field: ‘packages’
[10:26:39.466]   - Field: ‘gc’
[10:26:39.466]   - Field: ‘conditions’
[10:26:39.466]   - Field: ‘persistent’
[10:26:39.467]   - Field: ‘expr’
[10:26:39.467]   - Field: ‘uuid’
[10:26:39.467]   - Field: ‘seed’
[10:26:39.467]   - Field: ‘version’
[10:26:39.467]   - Field: ‘result’
[10:26:39.467]   - Field: ‘asynchronous’
[10:26:39.467]   - Field: ‘calls’
[10:26:39.467]   - Field: ‘globals’
[10:26:39.467]   - Field: ‘stdout’
[10:26:39.467]   - Field: ‘earlySignal’
[10:26:39.467]   - Field: ‘lazy’
[10:26:39.468]   - Field: ‘state’
[10:26:39.468] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:39.468] - Launch lazy future ...
[10:26:39.468] Packages needed by the future expression (n = 1): ‘future’
[10:26:39.468] Packages needed by future strategies (n = 1): ‘future’
[10:26:39.469] {
[10:26:39.469]     {
[10:26:39.469]         {
[10:26:39.469]             ...future.startTime <- base::Sys.time()
[10:26:39.469]             {
[10:26:39.469]                 {
[10:26:39.469]                   {
[10:26:39.469]                     {
[10:26:39.469]                       {
[10:26:39.469]                         base::local({
[10:26:39.469]                           has_future <- base::requireNamespace("future", 
[10:26:39.469]                             quietly = TRUE)
[10:26:39.469]                           if (has_future) {
[10:26:39.469]                             ns <- base::getNamespace("future")
[10:26:39.469]                             version <- ns[[".package"]][["version"]]
[10:26:39.469]                             if (is.null(version)) 
[10:26:39.469]                               version <- utils::packageVersion("future")
[10:26:39.469]                           }
[10:26:39.469]                           else {
[10:26:39.469]                             version <- NULL
[10:26:39.469]                           }
[10:26:39.469]                           if (!has_future || version < "1.8.0") {
[10:26:39.469]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:39.469]                               "", base::R.version$version.string), 
[10:26:39.469]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:39.469]                                 base::R.version$platform, 8 * 
[10:26:39.469]                                   base::.Machine$sizeof.pointer), 
[10:26:39.469]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:39.469]                                 "release", "version")], collapse = " "), 
[10:26:39.469]                               hostname = base::Sys.info()[["nodename"]])
[10:26:39.469]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:39.469]                               info)
[10:26:39.469]                             info <- base::paste(info, collapse = "; ")
[10:26:39.469]                             if (!has_future) {
[10:26:39.469]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:39.469]                                 info)
[10:26:39.469]                             }
[10:26:39.469]                             else {
[10:26:39.469]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:39.469]                                 info, version)
[10:26:39.469]                             }
[10:26:39.469]                             base::stop(msg)
[10:26:39.469]                           }
[10:26:39.469]                         })
[10:26:39.469]                       }
[10:26:39.469]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:39.469]                       base::options(mc.cores = 1L)
[10:26:39.469]                     }
[10:26:39.469]                     base::local({
[10:26:39.469]                       for (pkg in "future") {
[10:26:39.469]                         base::loadNamespace(pkg)
[10:26:39.469]                         base::library(pkg, character.only = TRUE)
[10:26:39.469]                       }
[10:26:39.469]                     })
[10:26:39.469]                   }
[10:26:39.469]                   options(future.plan = NULL)
[10:26:39.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:39.469]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:39.469]                     envir = parent.frame()) 
[10:26:39.469]                   {
[10:26:39.469]                     default_workers <- missing(workers)
[10:26:39.469]                     if (is.function(workers)) 
[10:26:39.469]                       workers <- workers()
[10:26:39.469]                     workers <- structure(as.integer(workers), 
[10:26:39.469]                       class = class(workers))
[10:26:39.469]                     stop_if_not(is.finite(workers), workers >= 
[10:26:39.469]                       1L)
[10:26:39.469]                     if ((workers == 1L && !inherits(workers, 
[10:26:39.469]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:39.469]                       if (default_workers) 
[10:26:39.469]                         supportsMulticore(warn = TRUE)
[10:26:39.469]                       return(sequential(..., envir = envir))
[10:26:39.469]                     }
[10:26:39.469]                     oopts <- options(mc.cores = workers)
[10:26:39.469]                     on.exit(options(oopts))
[10:26:39.469]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:39.469]                       envir = envir)
[10:26:39.469]                     if (!future$lazy) 
[10:26:39.469]                       future <- run(future)
[10:26:39.469]                     invisible(future)
[10:26:39.469]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:39.469]                 }
[10:26:39.469]                 ...future.workdir <- getwd()
[10:26:39.469]             }
[10:26:39.469]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:39.469]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:39.469]         }
[10:26:39.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:39.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:39.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:39.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:39.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:39.469]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:39.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:39.469]             base::names(...future.oldOptions))
[10:26:39.469]     }
[10:26:39.469]     if (FALSE) {
[10:26:39.469]     }
[10:26:39.469]     else {
[10:26:39.469]         if (TRUE) {
[10:26:39.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:39.469]                 open = "w")
[10:26:39.469]         }
[10:26:39.469]         else {
[10:26:39.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:39.469]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:39.469]         }
[10:26:39.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:39.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:39.469]             base::sink(type = "output", split = FALSE)
[10:26:39.469]             base::close(...future.stdout)
[10:26:39.469]         }, add = TRUE)
[10:26:39.469]     }
[10:26:39.469]     ...future.frame <- base::sys.nframe()
[10:26:39.469]     ...future.conditions <- base::list()
[10:26:39.469]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:39.469]     if (FALSE) {
[10:26:39.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:39.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:39.469]     }
[10:26:39.469]     ...future.result <- base::tryCatch({
[10:26:39.469]         base::withCallingHandlers({
[10:26:39.469]             ...future.value <- base::withVisible(base::local({
[10:26:39.469]                 ...future.makeSendCondition <- base::local({
[10:26:39.469]                   sendCondition <- NULL
[10:26:39.469]                   function(frame = 1L) {
[10:26:39.469]                     if (is.function(sendCondition)) 
[10:26:39.469]                       return(sendCondition)
[10:26:39.469]                     ns <- getNamespace("parallel")
[10:26:39.469]                     if (exists("sendData", mode = "function", 
[10:26:39.469]                       envir = ns)) {
[10:26:39.469]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:39.469]                         envir = ns)
[10:26:39.469]                       envir <- sys.frame(frame)
[10:26:39.469]                       master <- NULL
[10:26:39.469]                       while (!identical(envir, .GlobalEnv) && 
[10:26:39.469]                         !identical(envir, emptyenv())) {
[10:26:39.469]                         if (exists("master", mode = "list", envir = envir, 
[10:26:39.469]                           inherits = FALSE)) {
[10:26:39.469]                           master <- get("master", mode = "list", 
[10:26:39.469]                             envir = envir, inherits = FALSE)
[10:26:39.469]                           if (inherits(master, c("SOCKnode", 
[10:26:39.469]                             "SOCK0node"))) {
[10:26:39.469]                             sendCondition <<- function(cond) {
[10:26:39.469]                               data <- list(type = "VALUE", value = cond, 
[10:26:39.469]                                 success = TRUE)
[10:26:39.469]                               parallel_sendData(master, data)
[10:26:39.469]                             }
[10:26:39.469]                             return(sendCondition)
[10:26:39.469]                           }
[10:26:39.469]                         }
[10:26:39.469]                         frame <- frame + 1L
[10:26:39.469]                         envir <- sys.frame(frame)
[10:26:39.469]                       }
[10:26:39.469]                     }
[10:26:39.469]                     sendCondition <<- function(cond) NULL
[10:26:39.469]                   }
[10:26:39.469]                 })
[10:26:39.469]                 withCallingHandlers({
[10:26:39.469]                   {
[10:26:39.469]                     a <- 1L
[10:26:39.469]                     plan_a <- unclass(future::plan("list"))
[10:26:39.469]                     nested_a <- nested[-1]
[10:26:39.469]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:39.469]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:39.469]                       strategy2))
[10:26:39.469]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:39.469]                       "init") <- NULL
[10:26:39.469]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:39.469]                       "init") <- NULL
[10:26:39.469]                     stopifnot(all.equal(plan_a, nested_a))
[10:26:39.469]                     y %<-% {
[10:26:39.469]                       b <- 2L
[10:26:39.469]                       plan_b <- future::plan("list")
[10:26:39.469]                       nested_b <- nested_a[-1]
[10:26:39.469]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:39.469]                         1L, inherits(plan_b[[1]], "future"), 
[10:26:39.469]                         inherits(future::plan("next"), "sequential"))
[10:26:39.469]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:39.469]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:39.469]                     }
[10:26:39.469]                     y
[10:26:39.469]                   }
[10:26:39.469]                 }, immediateCondition = function(cond) {
[10:26:39.469]                   sendCondition <- ...future.makeSendCondition()
[10:26:39.469]                   sendCondition(cond)
[10:26:39.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.469]                   {
[10:26:39.469]                     inherits <- base::inherits
[10:26:39.469]                     invokeRestart <- base::invokeRestart
[10:26:39.469]                     is.null <- base::is.null
[10:26:39.469]                     muffled <- FALSE
[10:26:39.469]                     if (inherits(cond, "message")) {
[10:26:39.469]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:39.469]                       if (muffled) 
[10:26:39.469]                         invokeRestart("muffleMessage")
[10:26:39.469]                     }
[10:26:39.469]                     else if (inherits(cond, "warning")) {
[10:26:39.469]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:39.469]                       if (muffled) 
[10:26:39.469]                         invokeRestart("muffleWarning")
[10:26:39.469]                     }
[10:26:39.469]                     else if (inherits(cond, "condition")) {
[10:26:39.469]                       if (!is.null(pattern)) {
[10:26:39.469]                         computeRestarts <- base::computeRestarts
[10:26:39.469]                         grepl <- base::grepl
[10:26:39.469]                         restarts <- computeRestarts(cond)
[10:26:39.469]                         for (restart in restarts) {
[10:26:39.469]                           name <- restart$name
[10:26:39.469]                           if (is.null(name)) 
[10:26:39.469]                             next
[10:26:39.469]                           if (!grepl(pattern, name)) 
[10:26:39.469]                             next
[10:26:39.469]                           invokeRestart(restart)
[10:26:39.469]                           muffled <- TRUE
[10:26:39.469]                           break
[10:26:39.469]                         }
[10:26:39.469]                       }
[10:26:39.469]                     }
[10:26:39.469]                     invisible(muffled)
[10:26:39.469]                   }
[10:26:39.469]                   muffleCondition(cond)
[10:26:39.469]                 })
[10:26:39.469]             }))
[10:26:39.469]             future::FutureResult(value = ...future.value$value, 
[10:26:39.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:39.469]                   ...future.rng), globalenv = if (FALSE) 
[10:26:39.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:39.469]                     ...future.globalenv.names))
[10:26:39.469]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:39.469]         }, condition = base::local({
[10:26:39.469]             c <- base::c
[10:26:39.469]             inherits <- base::inherits
[10:26:39.469]             invokeRestart <- base::invokeRestart
[10:26:39.469]             length <- base::length
[10:26:39.469]             list <- base::list
[10:26:39.469]             seq.int <- base::seq.int
[10:26:39.469]             signalCondition <- base::signalCondition
[10:26:39.469]             sys.calls <- base::sys.calls
[10:26:39.469]             `[[` <- base::`[[`
[10:26:39.469]             `+` <- base::`+`
[10:26:39.469]             `<<-` <- base::`<<-`
[10:26:39.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:39.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:39.469]                   3L)]
[10:26:39.469]             }
[10:26:39.469]             function(cond) {
[10:26:39.469]                 is_error <- inherits(cond, "error")
[10:26:39.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:39.469]                   NULL)
[10:26:39.469]                 if (is_error) {
[10:26:39.469]                   sessionInformation <- function() {
[10:26:39.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:39.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:39.469]                       search = base::search(), system = base::Sys.info())
[10:26:39.469]                   }
[10:26:39.469]                   ...future.conditions[[length(...future.conditions) + 
[10:26:39.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:39.469]                     cond$call), session = sessionInformation(), 
[10:26:39.469]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:39.469]                   signalCondition(cond)
[10:26:39.469]                 }
[10:26:39.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:39.469]                 "immediateCondition"))) {
[10:26:39.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:39.469]                   ...future.conditions[[length(...future.conditions) + 
[10:26:39.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:39.469]                   if (TRUE && !signal) {
[10:26:39.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.469]                     {
[10:26:39.469]                       inherits <- base::inherits
[10:26:39.469]                       invokeRestart <- base::invokeRestart
[10:26:39.469]                       is.null <- base::is.null
[10:26:39.469]                       muffled <- FALSE
[10:26:39.469]                       if (inherits(cond, "message")) {
[10:26:39.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:39.469]                         if (muffled) 
[10:26:39.469]                           invokeRestart("muffleMessage")
[10:26:39.469]                       }
[10:26:39.469]                       else if (inherits(cond, "warning")) {
[10:26:39.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:39.469]                         if (muffled) 
[10:26:39.469]                           invokeRestart("muffleWarning")
[10:26:39.469]                       }
[10:26:39.469]                       else if (inherits(cond, "condition")) {
[10:26:39.469]                         if (!is.null(pattern)) {
[10:26:39.469]                           computeRestarts <- base::computeRestarts
[10:26:39.469]                           grepl <- base::grepl
[10:26:39.469]                           restarts <- computeRestarts(cond)
[10:26:39.469]                           for (restart in restarts) {
[10:26:39.469]                             name <- restart$name
[10:26:39.469]                             if (is.null(name)) 
[10:26:39.469]                               next
[10:26:39.469]                             if (!grepl(pattern, name)) 
[10:26:39.469]                               next
[10:26:39.469]                             invokeRestart(restart)
[10:26:39.469]                             muffled <- TRUE
[10:26:39.469]                             break
[10:26:39.469]                           }
[10:26:39.469]                         }
[10:26:39.469]                       }
[10:26:39.469]                       invisible(muffled)
[10:26:39.469]                     }
[10:26:39.469]                     muffleCondition(cond, pattern = "^muffle")
[10:26:39.469]                   }
[10:26:39.469]                 }
[10:26:39.469]                 else {
[10:26:39.469]                   if (TRUE) {
[10:26:39.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.469]                     {
[10:26:39.469]                       inherits <- base::inherits
[10:26:39.469]                       invokeRestart <- base::invokeRestart
[10:26:39.469]                       is.null <- base::is.null
[10:26:39.469]                       muffled <- FALSE
[10:26:39.469]                       if (inherits(cond, "message")) {
[10:26:39.469]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:39.469]                         if (muffled) 
[10:26:39.469]                           invokeRestart("muffleMessage")
[10:26:39.469]                       }
[10:26:39.469]                       else if (inherits(cond, "warning")) {
[10:26:39.469]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:39.469]                         if (muffled) 
[10:26:39.469]                           invokeRestart("muffleWarning")
[10:26:39.469]                       }
[10:26:39.469]                       else if (inherits(cond, "condition")) {
[10:26:39.469]                         if (!is.null(pattern)) {
[10:26:39.469]                           computeRestarts <- base::computeRestarts
[10:26:39.469]                           grepl <- base::grepl
[10:26:39.469]                           restarts <- computeRestarts(cond)
[10:26:39.469]                           for (restart in restarts) {
[10:26:39.469]                             name <- restart$name
[10:26:39.469]                             if (is.null(name)) 
[10:26:39.469]                               next
[10:26:39.469]                             if (!grepl(pattern, name)) 
[10:26:39.469]                               next
[10:26:39.469]                             invokeRestart(restart)
[10:26:39.469]                             muffled <- TRUE
[10:26:39.469]                             break
[10:26:39.469]                           }
[10:26:39.469]                         }
[10:26:39.469]                       }
[10:26:39.469]                       invisible(muffled)
[10:26:39.469]                     }
[10:26:39.469]                     muffleCondition(cond, pattern = "^muffle")
[10:26:39.469]                   }
[10:26:39.469]                 }
[10:26:39.469]             }
[10:26:39.469]         }))
[10:26:39.469]     }, error = function(ex) {
[10:26:39.469]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:39.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:39.469]                 ...future.rng), started = ...future.startTime, 
[10:26:39.469]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:39.469]             version = "1.8"), class = "FutureResult")
[10:26:39.469]     }, finally = {
[10:26:39.469]         if (!identical(...future.workdir, getwd())) 
[10:26:39.469]             setwd(...future.workdir)
[10:26:39.469]         {
[10:26:39.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:39.469]                 ...future.oldOptions$nwarnings <- NULL
[10:26:39.469]             }
[10:26:39.469]             base::options(...future.oldOptions)
[10:26:39.469]             if (.Platform$OS.type == "windows") {
[10:26:39.469]                 old_names <- names(...future.oldEnvVars)
[10:26:39.469]                 envs <- base::Sys.getenv()
[10:26:39.469]                 names <- names(envs)
[10:26:39.469]                 common <- intersect(names, old_names)
[10:26:39.469]                 added <- setdiff(names, old_names)
[10:26:39.469]                 removed <- setdiff(old_names, names)
[10:26:39.469]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:39.469]                   envs[common]]
[10:26:39.469]                 NAMES <- toupper(changed)
[10:26:39.469]                 args <- list()
[10:26:39.469]                 for (kk in seq_along(NAMES)) {
[10:26:39.469]                   name <- changed[[kk]]
[10:26:39.469]                   NAME <- NAMES[[kk]]
[10:26:39.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.469]                     next
[10:26:39.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:39.469]                 }
[10:26:39.469]                 NAMES <- toupper(added)
[10:26:39.469]                 for (kk in seq_along(NAMES)) {
[10:26:39.469]                   name <- added[[kk]]
[10:26:39.469]                   NAME <- NAMES[[kk]]
[10:26:39.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.469]                     next
[10:26:39.469]                   args[[name]] <- ""
[10:26:39.469]                 }
[10:26:39.469]                 NAMES <- toupper(removed)
[10:26:39.469]                 for (kk in seq_along(NAMES)) {
[10:26:39.469]                   name <- removed[[kk]]
[10:26:39.469]                   NAME <- NAMES[[kk]]
[10:26:39.469]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.469]                     next
[10:26:39.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:39.469]                 }
[10:26:39.469]                 if (length(args) > 0) 
[10:26:39.469]                   base::do.call(base::Sys.setenv, args = args)
[10:26:39.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:39.469]             }
[10:26:39.469]             else {
[10:26:39.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:39.469]             }
[10:26:39.469]             {
[10:26:39.469]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:39.469]                   0L) {
[10:26:39.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:39.469]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:39.469]                   base::options(opts)
[10:26:39.469]                 }
[10:26:39.469]                 {
[10:26:39.469]                   {
[10:26:39.469]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:39.469]                     NULL
[10:26:39.469]                   }
[10:26:39.469]                   options(future.plan = NULL)
[10:26:39.469]                   if (is.na(NA_character_)) 
[10:26:39.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:39.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:39.469]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:39.469]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:39.469]                     envir = parent.frame()) 
[10:26:39.469]                   {
[10:26:39.469]                     if (is.function(workers)) 
[10:26:39.469]                       workers <- workers()
[10:26:39.469]                     workers <- structure(as.integer(workers), 
[10:26:39.469]                       class = class(workers))
[10:26:39.469]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:39.469]                       workers >= 1)
[10:26:39.469]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:39.469]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:39.469]                     }
[10:26:39.469]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:39.469]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:39.469]                       envir = envir)
[10:26:39.469]                     if (!future$lazy) 
[10:26:39.469]                       future <- run(future)
[10:26:39.469]                     invisible(future)
[10:26:39.469]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:39.469]                     envir = parent.frame()) 
[10:26:39.469]                   {
[10:26:39.469]                     default_workers <- missing(workers)
[10:26:39.469]                     if (is.function(workers)) 
[10:26:39.469]                       workers <- workers()
[10:26:39.469]                     workers <- structure(as.integer(workers), 
[10:26:39.469]                       class = class(workers))
[10:26:39.469]                     stop_if_not(is.finite(workers), workers >= 
[10:26:39.469]                       1L)
[10:26:39.469]                     if ((workers == 1L && !inherits(workers, 
[10:26:39.469]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:39.469]                       if (default_workers) 
[10:26:39.469]                         supportsMulticore(warn = TRUE)
[10:26:39.469]                       return(sequential(..., envir = envir))
[10:26:39.469]                     }
[10:26:39.469]                     oopts <- options(mc.cores = workers)
[10:26:39.469]                     on.exit(options(oopts))
[10:26:39.469]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:39.469]                       envir = envir)
[10:26:39.469]                     if (!future$lazy) 
[10:26:39.469]                       future <- run(future)
[10:26:39.469]                     invisible(future)
[10:26:39.469]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:39.469]                 }
[10:26:39.469]             }
[10:26:39.469]         }
[10:26:39.469]     })
[10:26:39.469]     if (TRUE) {
[10:26:39.469]         base::sink(type = "output", split = FALSE)
[10:26:39.469]         if (TRUE) {
[10:26:39.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:39.469]         }
[10:26:39.469]         else {
[10:26:39.469]             ...future.result["stdout"] <- base::list(NULL)
[10:26:39.469]         }
[10:26:39.469]         base::close(...future.stdout)
[10:26:39.469]         ...future.stdout <- NULL
[10:26:39.469]     }
[10:26:39.469]     ...future.result$conditions <- ...future.conditions
[10:26:39.469]     ...future.result$finished <- base::Sys.time()
[10:26:39.469]     ...future.result
[10:26:39.469] }
[10:26:39.472] Exporting 2 global objects (90.70 KiB) to cluster node #1 ...
[10:26:39.473] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ...
[10:26:39.514] Exporting ‘nested’ (90.58 KiB) to cluster node #1 ... DONE
[10:26:39.514] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[10:26:39.515] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[10:26:39.515] Exporting 2 global objects (90.70 KiB) to cluster node #1 ... DONE
[10:26:39.515] MultisessionFuture started
[10:26:39.516] - Launch lazy future ... done
[10:26:39.516] run() for ‘MultisessionFuture’ ... done
[10:26:39.516] result() for ClusterFuture ...
[10:26:39.516] receiveMessageFromWorker() for ClusterFuture ...
[10:26:39.516] - Validating connection of MultisessionFuture
[10:26:39.592] - received message: FutureResult
[10:26:39.593] - Received FutureResult
[10:26:39.593] - Erased future from FutureRegistry
[10:26:39.593] result() for ClusterFuture ...
[10:26:39.593] - result already collected: FutureResult
[10:26:39.593] result() for ClusterFuture ... done
[10:26:39.593] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:39.593] result() for ClusterFuture ... done
[10:26:39.593] result() for ClusterFuture ...
[10:26:39.593] - result already collected: FutureResult
[10:26:39.594] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:39.599] getGlobalsAndPackages() ...
[10:26:39.599] Searching for globals...
[10:26:39.600] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:39.600] Searching for globals ... DONE
[10:26:39.600] Resolving globals: FALSE
[10:26:39.601] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:39.601] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:39.602] - globals: [1] ‘data’
[10:26:39.602] - packages: [1] ‘future’
[10:26:39.602] getGlobalsAndPackages() ... DONE
[10:26:39.602] run() for ‘Future’ ...
[10:26:39.602] - state: ‘created’
[10:26:39.602] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:39.616] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:39.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:39.617]   - Field: ‘node’
[10:26:39.617]   - Field: ‘label’
[10:26:39.617]   - Field: ‘local’
[10:26:39.617]   - Field: ‘owner’
[10:26:39.617]   - Field: ‘envir’
[10:26:39.617]   - Field: ‘workers’
[10:26:39.617]   - Field: ‘packages’
[10:26:39.617]   - Field: ‘gc’
[10:26:39.618]   - Field: ‘conditions’
[10:26:39.618]   - Field: ‘persistent’
[10:26:39.618]   - Field: ‘expr’
[10:26:39.618]   - Field: ‘uuid’
[10:26:39.618]   - Field: ‘seed’
[10:26:39.618]   - Field: ‘version’
[10:26:39.618]   - Field: ‘result’
[10:26:39.618]   - Field: ‘asynchronous’
[10:26:39.618]   - Field: ‘calls’
[10:26:39.618]   - Field: ‘globals’
[10:26:39.618]   - Field: ‘stdout’
[10:26:39.619]   - Field: ‘earlySignal’
[10:26:39.619]   - Field: ‘lazy’
[10:26:39.619]   - Field: ‘state’
[10:26:39.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:39.619] - Launch lazy future ...
[10:26:39.619] Packages needed by the future expression (n = 1): ‘future’
[10:26:39.619] Packages needed by future strategies (n = 1): ‘future’
[10:26:39.620] {
[10:26:39.620]     {
[10:26:39.620]         {
[10:26:39.620]             ...future.startTime <- base::Sys.time()
[10:26:39.620]             {
[10:26:39.620]                 {
[10:26:39.620]                   {
[10:26:39.620]                     {
[10:26:39.620]                       {
[10:26:39.620]                         base::local({
[10:26:39.620]                           has_future <- base::requireNamespace("future", 
[10:26:39.620]                             quietly = TRUE)
[10:26:39.620]                           if (has_future) {
[10:26:39.620]                             ns <- base::getNamespace("future")
[10:26:39.620]                             version <- ns[[".package"]][["version"]]
[10:26:39.620]                             if (is.null(version)) 
[10:26:39.620]                               version <- utils::packageVersion("future")
[10:26:39.620]                           }
[10:26:39.620]                           else {
[10:26:39.620]                             version <- NULL
[10:26:39.620]                           }
[10:26:39.620]                           if (!has_future || version < "1.8.0") {
[10:26:39.620]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:39.620]                               "", base::R.version$version.string), 
[10:26:39.620]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:39.620]                                 base::R.version$platform, 8 * 
[10:26:39.620]                                   base::.Machine$sizeof.pointer), 
[10:26:39.620]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:39.620]                                 "release", "version")], collapse = " "), 
[10:26:39.620]                               hostname = base::Sys.info()[["nodename"]])
[10:26:39.620]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:39.620]                               info)
[10:26:39.620]                             info <- base::paste(info, collapse = "; ")
[10:26:39.620]                             if (!has_future) {
[10:26:39.620]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:39.620]                                 info)
[10:26:39.620]                             }
[10:26:39.620]                             else {
[10:26:39.620]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:39.620]                                 info, version)
[10:26:39.620]                             }
[10:26:39.620]                             base::stop(msg)
[10:26:39.620]                           }
[10:26:39.620]                         })
[10:26:39.620]                       }
[10:26:39.620]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:39.620]                       base::options(mc.cores = 1L)
[10:26:39.620]                     }
[10:26:39.620]                     base::local({
[10:26:39.620]                       for (pkg in "future") {
[10:26:39.620]                         base::loadNamespace(pkg)
[10:26:39.620]                         base::library(pkg, character.only = TRUE)
[10:26:39.620]                       }
[10:26:39.620]                     })
[10:26:39.620]                   }
[10:26:39.620]                   options(future.plan = NULL)
[10:26:39.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:39.620]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:39.620]                     envir = parent.frame()) 
[10:26:39.620]                   {
[10:26:39.620]                     default_workers <- missing(workers)
[10:26:39.620]                     if (is.function(workers)) 
[10:26:39.620]                       workers <- workers()
[10:26:39.620]                     workers <- structure(as.integer(workers), 
[10:26:39.620]                       class = class(workers))
[10:26:39.620]                     stop_if_not(is.finite(workers), workers >= 
[10:26:39.620]                       1L)
[10:26:39.620]                     if ((workers == 1L && !inherits(workers, 
[10:26:39.620]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:39.620]                       if (default_workers) 
[10:26:39.620]                         supportsMulticore(warn = TRUE)
[10:26:39.620]                       return(sequential(..., envir = envir))
[10:26:39.620]                     }
[10:26:39.620]                     oopts <- options(mc.cores = workers)
[10:26:39.620]                     on.exit(options(oopts))
[10:26:39.620]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:39.620]                       envir = envir)
[10:26:39.620]                     if (!future$lazy) 
[10:26:39.620]                       future <- run(future)
[10:26:39.620]                     invisible(future)
[10:26:39.620]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:39.620]                 }
[10:26:39.620]                 ...future.workdir <- getwd()
[10:26:39.620]             }
[10:26:39.620]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:39.620]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:39.620]         }
[10:26:39.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:39.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:39.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:39.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:39.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:39.620]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:39.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:39.620]             base::names(...future.oldOptions))
[10:26:39.620]     }
[10:26:39.620]     if (FALSE) {
[10:26:39.620]     }
[10:26:39.620]     else {
[10:26:39.620]         if (TRUE) {
[10:26:39.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:39.620]                 open = "w")
[10:26:39.620]         }
[10:26:39.620]         else {
[10:26:39.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:39.620]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:39.620]         }
[10:26:39.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:39.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:39.620]             base::sink(type = "output", split = FALSE)
[10:26:39.620]             base::close(...future.stdout)
[10:26:39.620]         }, add = TRUE)
[10:26:39.620]     }
[10:26:39.620]     ...future.frame <- base::sys.nframe()
[10:26:39.620]     ...future.conditions <- base::list()
[10:26:39.620]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:39.620]     if (FALSE) {
[10:26:39.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:39.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:39.620]     }
[10:26:39.620]     ...future.result <- base::tryCatch({
[10:26:39.620]         base::withCallingHandlers({
[10:26:39.620]             ...future.value <- base::withVisible(base::local({
[10:26:39.620]                 ...future.makeSendCondition <- base::local({
[10:26:39.620]                   sendCondition <- NULL
[10:26:39.620]                   function(frame = 1L) {
[10:26:39.620]                     if (is.function(sendCondition)) 
[10:26:39.620]                       return(sendCondition)
[10:26:39.620]                     ns <- getNamespace("parallel")
[10:26:39.620]                     if (exists("sendData", mode = "function", 
[10:26:39.620]                       envir = ns)) {
[10:26:39.620]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:39.620]                         envir = ns)
[10:26:39.620]                       envir <- sys.frame(frame)
[10:26:39.620]                       master <- NULL
[10:26:39.620]                       while (!identical(envir, .GlobalEnv) && 
[10:26:39.620]                         !identical(envir, emptyenv())) {
[10:26:39.620]                         if (exists("master", mode = "list", envir = envir, 
[10:26:39.620]                           inherits = FALSE)) {
[10:26:39.620]                           master <- get("master", mode = "list", 
[10:26:39.620]                             envir = envir, inherits = FALSE)
[10:26:39.620]                           if (inherits(master, c("SOCKnode", 
[10:26:39.620]                             "SOCK0node"))) {
[10:26:39.620]                             sendCondition <<- function(cond) {
[10:26:39.620]                               data <- list(type = "VALUE", value = cond, 
[10:26:39.620]                                 success = TRUE)
[10:26:39.620]                               parallel_sendData(master, data)
[10:26:39.620]                             }
[10:26:39.620]                             return(sendCondition)
[10:26:39.620]                           }
[10:26:39.620]                         }
[10:26:39.620]                         frame <- frame + 1L
[10:26:39.620]                         envir <- sys.frame(frame)
[10:26:39.620]                       }
[10:26:39.620]                     }
[10:26:39.620]                     sendCondition <<- function(cond) NULL
[10:26:39.620]                   }
[10:26:39.620]                 })
[10:26:39.620]                 withCallingHandlers({
[10:26:39.620]                   {
[10:26:39.620]                     value(future(subset(data, a == 2)))
[10:26:39.620]                   }
[10:26:39.620]                 }, immediateCondition = function(cond) {
[10:26:39.620]                   sendCondition <- ...future.makeSendCondition()
[10:26:39.620]                   sendCondition(cond)
[10:26:39.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.620]                   {
[10:26:39.620]                     inherits <- base::inherits
[10:26:39.620]                     invokeRestart <- base::invokeRestart
[10:26:39.620]                     is.null <- base::is.null
[10:26:39.620]                     muffled <- FALSE
[10:26:39.620]                     if (inherits(cond, "message")) {
[10:26:39.620]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:39.620]                       if (muffled) 
[10:26:39.620]                         invokeRestart("muffleMessage")
[10:26:39.620]                     }
[10:26:39.620]                     else if (inherits(cond, "warning")) {
[10:26:39.620]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:39.620]                       if (muffled) 
[10:26:39.620]                         invokeRestart("muffleWarning")
[10:26:39.620]                     }
[10:26:39.620]                     else if (inherits(cond, "condition")) {
[10:26:39.620]                       if (!is.null(pattern)) {
[10:26:39.620]                         computeRestarts <- base::computeRestarts
[10:26:39.620]                         grepl <- base::grepl
[10:26:39.620]                         restarts <- computeRestarts(cond)
[10:26:39.620]                         for (restart in restarts) {
[10:26:39.620]                           name <- restart$name
[10:26:39.620]                           if (is.null(name)) 
[10:26:39.620]                             next
[10:26:39.620]                           if (!grepl(pattern, name)) 
[10:26:39.620]                             next
[10:26:39.620]                           invokeRestart(restart)
[10:26:39.620]                           muffled <- TRUE
[10:26:39.620]                           break
[10:26:39.620]                         }
[10:26:39.620]                       }
[10:26:39.620]                     }
[10:26:39.620]                     invisible(muffled)
[10:26:39.620]                   }
[10:26:39.620]                   muffleCondition(cond)
[10:26:39.620]                 })
[10:26:39.620]             }))
[10:26:39.620]             future::FutureResult(value = ...future.value$value, 
[10:26:39.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:39.620]                   ...future.rng), globalenv = if (FALSE) 
[10:26:39.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:39.620]                     ...future.globalenv.names))
[10:26:39.620]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:39.620]         }, condition = base::local({
[10:26:39.620]             c <- base::c
[10:26:39.620]             inherits <- base::inherits
[10:26:39.620]             invokeRestart <- base::invokeRestart
[10:26:39.620]             length <- base::length
[10:26:39.620]             list <- base::list
[10:26:39.620]             seq.int <- base::seq.int
[10:26:39.620]             signalCondition <- base::signalCondition
[10:26:39.620]             sys.calls <- base::sys.calls
[10:26:39.620]             `[[` <- base::`[[`
[10:26:39.620]             `+` <- base::`+`
[10:26:39.620]             `<<-` <- base::`<<-`
[10:26:39.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:39.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:39.620]                   3L)]
[10:26:39.620]             }
[10:26:39.620]             function(cond) {
[10:26:39.620]                 is_error <- inherits(cond, "error")
[10:26:39.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:39.620]                   NULL)
[10:26:39.620]                 if (is_error) {
[10:26:39.620]                   sessionInformation <- function() {
[10:26:39.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:39.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:39.620]                       search = base::search(), system = base::Sys.info())
[10:26:39.620]                   }
[10:26:39.620]                   ...future.conditions[[length(...future.conditions) + 
[10:26:39.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:39.620]                     cond$call), session = sessionInformation(), 
[10:26:39.620]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:39.620]                   signalCondition(cond)
[10:26:39.620]                 }
[10:26:39.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:39.620]                 "immediateCondition"))) {
[10:26:39.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:39.620]                   ...future.conditions[[length(...future.conditions) + 
[10:26:39.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:39.620]                   if (TRUE && !signal) {
[10:26:39.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.620]                     {
[10:26:39.620]                       inherits <- base::inherits
[10:26:39.620]                       invokeRestart <- base::invokeRestart
[10:26:39.620]                       is.null <- base::is.null
[10:26:39.620]                       muffled <- FALSE
[10:26:39.620]                       if (inherits(cond, "message")) {
[10:26:39.620]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:39.620]                         if (muffled) 
[10:26:39.620]                           invokeRestart("muffleMessage")
[10:26:39.620]                       }
[10:26:39.620]                       else if (inherits(cond, "warning")) {
[10:26:39.620]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:39.620]                         if (muffled) 
[10:26:39.620]                           invokeRestart("muffleWarning")
[10:26:39.620]                       }
[10:26:39.620]                       else if (inherits(cond, "condition")) {
[10:26:39.620]                         if (!is.null(pattern)) {
[10:26:39.620]                           computeRestarts <- base::computeRestarts
[10:26:39.620]                           grepl <- base::grepl
[10:26:39.620]                           restarts <- computeRestarts(cond)
[10:26:39.620]                           for (restart in restarts) {
[10:26:39.620]                             name <- restart$name
[10:26:39.620]                             if (is.null(name)) 
[10:26:39.620]                               next
[10:26:39.620]                             if (!grepl(pattern, name)) 
[10:26:39.620]                               next
[10:26:39.620]                             invokeRestart(restart)
[10:26:39.620]                             muffled <- TRUE
[10:26:39.620]                             break
[10:26:39.620]                           }
[10:26:39.620]                         }
[10:26:39.620]                       }
[10:26:39.620]                       invisible(muffled)
[10:26:39.620]                     }
[10:26:39.620]                     muffleCondition(cond, pattern = "^muffle")
[10:26:39.620]                   }
[10:26:39.620]                 }
[10:26:39.620]                 else {
[10:26:39.620]                   if (TRUE) {
[10:26:39.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:39.620]                     {
[10:26:39.620]                       inherits <- base::inherits
[10:26:39.620]                       invokeRestart <- base::invokeRestart
[10:26:39.620]                       is.null <- base::is.null
[10:26:39.620]                       muffled <- FALSE
[10:26:39.620]                       if (inherits(cond, "message")) {
[10:26:39.620]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:39.620]                         if (muffled) 
[10:26:39.620]                           invokeRestart("muffleMessage")
[10:26:39.620]                       }
[10:26:39.620]                       else if (inherits(cond, "warning")) {
[10:26:39.620]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:39.620]                         if (muffled) 
[10:26:39.620]                           invokeRestart("muffleWarning")
[10:26:39.620]                       }
[10:26:39.620]                       else if (inherits(cond, "condition")) {
[10:26:39.620]                         if (!is.null(pattern)) {
[10:26:39.620]                           computeRestarts <- base::computeRestarts
[10:26:39.620]                           grepl <- base::grepl
[10:26:39.620]                           restarts <- computeRestarts(cond)
[10:26:39.620]                           for (restart in restarts) {
[10:26:39.620]                             name <- restart$name
[10:26:39.620]                             if (is.null(name)) 
[10:26:39.620]                               next
[10:26:39.620]                             if (!grepl(pattern, name)) 
[10:26:39.620]                               next
[10:26:39.620]                             invokeRestart(restart)
[10:26:39.620]                             muffled <- TRUE
[10:26:39.620]                             break
[10:26:39.620]                           }
[10:26:39.620]                         }
[10:26:39.620]                       }
[10:26:39.620]                       invisible(muffled)
[10:26:39.620]                     }
[10:26:39.620]                     muffleCondition(cond, pattern = "^muffle")
[10:26:39.620]                   }
[10:26:39.620]                 }
[10:26:39.620]             }
[10:26:39.620]         }))
[10:26:39.620]     }, error = function(ex) {
[10:26:39.620]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:39.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:39.620]                 ...future.rng), started = ...future.startTime, 
[10:26:39.620]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:39.620]             version = "1.8"), class = "FutureResult")
[10:26:39.620]     }, finally = {
[10:26:39.620]         if (!identical(...future.workdir, getwd())) 
[10:26:39.620]             setwd(...future.workdir)
[10:26:39.620]         {
[10:26:39.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:39.620]                 ...future.oldOptions$nwarnings <- NULL
[10:26:39.620]             }
[10:26:39.620]             base::options(...future.oldOptions)
[10:26:39.620]             if (.Platform$OS.type == "windows") {
[10:26:39.620]                 old_names <- names(...future.oldEnvVars)
[10:26:39.620]                 envs <- base::Sys.getenv()
[10:26:39.620]                 names <- names(envs)
[10:26:39.620]                 common <- intersect(names, old_names)
[10:26:39.620]                 added <- setdiff(names, old_names)
[10:26:39.620]                 removed <- setdiff(old_names, names)
[10:26:39.620]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:39.620]                   envs[common]]
[10:26:39.620]                 NAMES <- toupper(changed)
[10:26:39.620]                 args <- list()
[10:26:39.620]                 for (kk in seq_along(NAMES)) {
[10:26:39.620]                   name <- changed[[kk]]
[10:26:39.620]                   NAME <- NAMES[[kk]]
[10:26:39.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.620]                     next
[10:26:39.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:39.620]                 }
[10:26:39.620]                 NAMES <- toupper(added)
[10:26:39.620]                 for (kk in seq_along(NAMES)) {
[10:26:39.620]                   name <- added[[kk]]
[10:26:39.620]                   NAME <- NAMES[[kk]]
[10:26:39.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.620]                     next
[10:26:39.620]                   args[[name]] <- ""
[10:26:39.620]                 }
[10:26:39.620]                 NAMES <- toupper(removed)
[10:26:39.620]                 for (kk in seq_along(NAMES)) {
[10:26:39.620]                   name <- removed[[kk]]
[10:26:39.620]                   NAME <- NAMES[[kk]]
[10:26:39.620]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:39.620]                     next
[10:26:39.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:39.620]                 }
[10:26:39.620]                 if (length(args) > 0) 
[10:26:39.620]                   base::do.call(base::Sys.setenv, args = args)
[10:26:39.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:39.620]             }
[10:26:39.620]             else {
[10:26:39.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:39.620]             }
[10:26:39.620]             {
[10:26:39.620]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:39.620]                   0L) {
[10:26:39.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:39.620]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:39.620]                   base::options(opts)
[10:26:39.620]                 }
[10:26:39.620]                 {
[10:26:39.620]                   {
[10:26:39.620]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:39.620]                     NULL
[10:26:39.620]                   }
[10:26:39.620]                   options(future.plan = NULL)
[10:26:39.620]                   if (is.na(NA_character_)) 
[10:26:39.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:39.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:39.620]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:39.620]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:39.620]                     envir = parent.frame()) 
[10:26:39.620]                   {
[10:26:39.620]                     if (is.function(workers)) 
[10:26:39.620]                       workers <- workers()
[10:26:39.620]                     workers <- structure(as.integer(workers), 
[10:26:39.620]                       class = class(workers))
[10:26:39.620]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:39.620]                       workers >= 1)
[10:26:39.620]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:39.620]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:39.620]                     }
[10:26:39.620]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:39.620]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:39.620]                       envir = envir)
[10:26:39.620]                     if (!future$lazy) 
[10:26:39.620]                       future <- run(future)
[10:26:39.620]                     invisible(future)
[10:26:39.620]                   }, b = function (..., workers = availableCores(constraints = "multicore"), 
[10:26:39.620]                     envir = parent.frame()) 
[10:26:39.620]                   {
[10:26:39.620]                     default_workers <- missing(workers)
[10:26:39.620]                     if (is.function(workers)) 
[10:26:39.620]                       workers <- workers()
[10:26:39.620]                     workers <- structure(as.integer(workers), 
[10:26:39.620]                       class = class(workers))
[10:26:39.620]                     stop_if_not(is.finite(workers), workers >= 
[10:26:39.620]                       1L)
[10:26:39.620]                     if ((workers == 1L && !inherits(workers, 
[10:26:39.620]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:26:39.620]                       if (default_workers) 
[10:26:39.620]                         supportsMulticore(warn = TRUE)
[10:26:39.620]                       return(sequential(..., envir = envir))
[10:26:39.620]                     }
[10:26:39.620]                     oopts <- options(mc.cores = workers)
[10:26:39.620]                     on.exit(options(oopts))
[10:26:39.620]                     future <- MulticoreFuture(..., workers = workers, 
[10:26:39.620]                       envir = envir)
[10:26:39.620]                     if (!future$lazy) 
[10:26:39.620]                       future <- run(future)
[10:26:39.620]                     invisible(future)
[10:26:39.620]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:39.620]                 }
[10:26:39.620]             }
[10:26:39.620]         }
[10:26:39.620]     })
[10:26:39.620]     if (TRUE) {
[10:26:39.620]         base::sink(type = "output", split = FALSE)
[10:26:39.620]         if (TRUE) {
[10:26:39.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:39.620]         }
[10:26:39.620]         else {
[10:26:39.620]             ...future.result["stdout"] <- base::list(NULL)
[10:26:39.620]         }
[10:26:39.620]         base::close(...future.stdout)
[10:26:39.620]         ...future.stdout <- NULL
[10:26:39.620]     }
[10:26:39.620]     ...future.result$conditions <- ...future.conditions
[10:26:39.620]     ...future.result$finished <- base::Sys.time()
[10:26:39.620]     ...future.result
[10:26:39.620] }
[10:26:39.623] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:26:39.623] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:26:39.624] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:26:39.624] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:26:39.624] MultisessionFuture started
[10:26:39.624] - Launch lazy future ... done
[10:26:39.624] run() for ‘MultisessionFuture’ ... done
[10:26:39.625] result() for ClusterFuture ...
[10:26:39.625] receiveMessageFromWorker() for ClusterFuture ...
[10:26:39.625] - Validating connection of MultisessionFuture
[10:26:39.687] - received message: FutureResult
[10:26:39.688] - Received FutureResult
[10:26:39.688] - Erased future from FutureRegistry
[10:26:39.688] result() for ClusterFuture ...
[10:26:39.688] - result already collected: FutureResult
[10:26:39.688] result() for ClusterFuture ... done
[10:26:39.688] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:39.688] result() for ClusterFuture ... done
[10:26:39.688] result() for ClusterFuture ...
[10:26:39.689] - result already collected: FutureResult
[10:26:39.689] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[10:26:39.689] plan(): Setting new future strategy stack:
[10:26:39.689] List of future strategies:
[10:26:39.689] 1. multisession:
[10:26:39.689]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:39.689]    - tweaked: FALSE
[10:26:39.689]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:39.689] 2. multisession:
[10:26:39.689]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:39.689]    - tweaked: FALSE
[10:26:39.689]    - call: plan(list(a = strategy1, b = strategy2))
[10:26:39.690] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:26:39.690] multisession:
[10:26:39.690] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:26:39.690] - tweaked: FALSE
[10:26:39.690] - call: plan(list(a = strategy1, b = strategy2))
[10:26:39.695] getGlobalsAndPackages() ...
[10:26:39.695] Not searching for globals
[10:26:39.696] - globals: [0] <none>
[10:26:39.696] getGlobalsAndPackages() ... DONE
[10:26:39.696] [local output] makeClusterPSOCK() ...
[10:26:39.701] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:26:39.702] [local output] Base port: 11105
[10:26:39.702] [local output] Getting setup options for 2 cluster nodes ...
[10:26:39.702] [local output]  - Node 1 of 2 ...
[10:26:39.703] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:39.704] [local output] Rscript port: 11105

[10:26:39.704] [local output]  - Node 2 of 2 ...
[10:26:39.705] [local output] localMachine=TRUE => revtunnel=FALSE

[10:26:39.706] [local output] Rscript port: 11105

[10:26:39.706] [local output] Getting setup options for 2 cluster nodes ... done
[10:26:39.706] [local output]  - Parallel setup requested for some PSOCK nodes
[10:26:39.707] [local output] Setting up PSOCK nodes in parallel
[10:26:39.707] List of 36
[10:26:39.707]  $ worker          : chr "localhost"
[10:26:39.707]   ..- attr(*, "localhost")= logi TRUE
[10:26:39.707]  $ master          : chr "localhost"
[10:26:39.707]  $ port            : int 11105
[10:26:39.707]  $ connectTimeout  : num 120
[10:26:39.707]  $ timeout         : num 2592000
[10:26:39.707]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:26:39.707]  $ homogeneous     : logi TRUE
[10:26:39.707]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:26:39.707]  $ rscript_envs    : NULL
[10:26:39.707]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:39.707]  $ rscript_startup : NULL
[10:26:39.707]  $ rscript_sh      : chr "sh"
[10:26:39.707]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:39.707]  $ methods         : logi TRUE
[10:26:39.707]  $ socketOptions   : chr "no-delay"
[10:26:39.707]  $ useXDR          : logi FALSE
[10:26:39.707]  $ outfile         : chr "/dev/null"
[10:26:39.707]  $ renice          : int NA
[10:26:39.707]  $ rshcmd          : NULL
[10:26:39.707]  $ user            : chr(0) 
[10:26:39.707]  $ revtunnel       : logi FALSE
[10:26:39.707]  $ rshlogfile      : NULL
[10:26:39.707]  $ rshopts         : chr(0) 
[10:26:39.707]  $ rank            : int 1
[10:26:39.707]  $ manual          : logi FALSE
[10:26:39.707]  $ dryrun          : logi FALSE
[10:26:39.707]  $ quiet           : logi FALSE
[10:26:39.707]  $ setup_strategy  : chr "parallel"
[10:26:39.707]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:39.707]  $ pidfile         : chr "/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b7f42fd8f.pid"
[10:26:39.707]  $ rshcmd_label    : NULL
[10:26:39.707]  $ rsh_call        : NULL
[10:26:39.707]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:26:39.707]  $ localMachine    : logi TRUE
[10:26:39.707]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:26:39.707]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:26:39.707]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:26:39.707]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:26:39.707]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:26:39.707]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:26:39.707]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:26:39.707]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:26:39.707]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:26:39.707]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:26:39.707]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:26:39.707]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:26:39.707]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:26:39.707]  $ arguments       :List of 28
[10:26:39.707]   ..$ worker          : chr "localhost"
[10:26:39.707]   ..$ master          : NULL
[10:26:39.707]   ..$ port            : int 11105
[10:26:39.707]   ..$ connectTimeout  : num 120
[10:26:39.707]   ..$ timeout         : num 2592000
[10:26:39.707]   ..$ rscript         : NULL
[10:26:39.707]   ..$ homogeneous     : NULL
[10:26:39.707]   ..$ rscript_args    : NULL
[10:26:39.707]   ..$ rscript_envs    : NULL
[10:26:39.707]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:26:39.707]   ..$ rscript_startup : NULL
[10:26:39.707]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:26:39.707]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:26:39.707]   ..$ methods         : logi TRUE
[10:26:39.707]   ..$ socketOptions   : chr "no-delay"
[10:26:39.707]   ..$ useXDR          : logi FALSE
[10:26:39.707]   ..$ outfile         : chr "/dev/null"
[10:26:39.707]   ..$ renice          : int NA
[10:26:39.707]   ..$ rshcmd          : NULL
[10:26:39.707]   ..$ user            : NULL
[10:26:39.707]   ..$ revtunnel       : logi NA
[10:26:39.707]   ..$ rshlogfile      : NULL
[10:26:39.707]   ..$ rshopts         : NULL
[10:26:39.707]   ..$ rank            : int 1
[10:26:39.707]   ..$ manual          : logi FALSE
[10:26:39.707]   ..$ dryrun          : logi FALSE
[10:26:39.707]   ..$ quiet           : logi FALSE
[10:26:39.707]   ..$ setup_strategy  : chr "parallel"
[10:26:39.707]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:26:39.727] [local output] System call to launch all workers:
[10:26:39.727] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpPBdnqC/worker.rank=1.parallelly.parent=89227.15c8b7f42fd8f.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11105 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:26:39.727] [local output] Starting PSOCK main server
[10:26:39.729] [local output] Workers launched
[10:26:39.729] [local output] Waiting for workers to connect back
[10:26:39.729]  - [local output] 0 workers out of 2 ready
[10:26:39.976]  - [local output] 0 workers out of 2 ready
[10:26:39.977]  - [local output] 1 workers out of 2 ready
[10:26:39.988]  - [local output] 1 workers out of 2 ready
[10:26:39.988]  - [local output] 2 workers out of 2 ready
[10:26:39.988] [local output] Launching of workers completed
[10:26:39.988] [local output] Collecting session information from workers
[10:26:39.989] [local output]  - Worker #1 of 2
[10:26:39.990] [local output]  - Worker #2 of 2
[10:26:39.990] [local output] makeClusterPSOCK() ... done
[10:26:40.001] Packages needed by the future expression (n = 0): <none>
[10:26:40.001] Packages needed by future strategies (n = 1): ‘future’
[10:26:40.001] {
[10:26:40.001]     {
[10:26:40.001]         {
[10:26:40.001]             ...future.startTime <- base::Sys.time()
[10:26:40.001]             {
[10:26:40.001]                 {
[10:26:40.001]                   {
[10:26:40.001]                     {
[10:26:40.001]                       {
[10:26:40.001]                         base::local({
[10:26:40.001]                           has_future <- base::requireNamespace("future", 
[10:26:40.001]                             quietly = TRUE)
[10:26:40.001]                           if (has_future) {
[10:26:40.001]                             ns <- base::getNamespace("future")
[10:26:40.001]                             version <- ns[[".package"]][["version"]]
[10:26:40.001]                             if (is.null(version)) 
[10:26:40.001]                               version <- utils::packageVersion("future")
[10:26:40.001]                           }
[10:26:40.001]                           else {
[10:26:40.001]                             version <- NULL
[10:26:40.001]                           }
[10:26:40.001]                           if (!has_future || version < "1.8.0") {
[10:26:40.001]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:40.001]                               "", base::R.version$version.string), 
[10:26:40.001]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:40.001]                                 base::R.version$platform, 8 * 
[10:26:40.001]                                   base::.Machine$sizeof.pointer), 
[10:26:40.001]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:40.001]                                 "release", "version")], collapse = " "), 
[10:26:40.001]                               hostname = base::Sys.info()[["nodename"]])
[10:26:40.001]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:40.001]                               info)
[10:26:40.001]                             info <- base::paste(info, collapse = "; ")
[10:26:40.001]                             if (!has_future) {
[10:26:40.001]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:40.001]                                 info)
[10:26:40.001]                             }
[10:26:40.001]                             else {
[10:26:40.001]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:40.001]                                 info, version)
[10:26:40.001]                             }
[10:26:40.001]                             base::stop(msg)
[10:26:40.001]                           }
[10:26:40.001]                         })
[10:26:40.001]                       }
[10:26:40.001]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:40.001]                       base::options(mc.cores = 1L)
[10:26:40.001]                     }
[10:26:40.001]                     base::local({
[10:26:40.001]                       for (pkg in "future") {
[10:26:40.001]                         base::loadNamespace(pkg)
[10:26:40.001]                         base::library(pkg, character.only = TRUE)
[10:26:40.001]                       }
[10:26:40.001]                     })
[10:26:40.001]                   }
[10:26:40.001]                   options(future.plan = NULL)
[10:26:40.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:40.001]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:40.001]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.001]                     envir = parent.frame()) 
[10:26:40.001]                   {
[10:26:40.001]                     if (is.function(workers)) 
[10:26:40.001]                       workers <- workers()
[10:26:40.001]                     workers <- structure(as.integer(workers), 
[10:26:40.001]                       class = class(workers))
[10:26:40.001]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.001]                       workers >= 1)
[10:26:40.001]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.001]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.001]                     }
[10:26:40.001]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.001]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.001]                       envir = envir)
[10:26:40.001]                     if (!future$lazy) 
[10:26:40.001]                       future <- run(future)
[10:26:40.001]                     invisible(future)
[10:26:40.001]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:40.001]                 }
[10:26:40.001]                 ...future.workdir <- getwd()
[10:26:40.001]             }
[10:26:40.001]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:40.001]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:40.001]         }
[10:26:40.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:40.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:40.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:40.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:40.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:40.001]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:40.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:40.001]             base::names(...future.oldOptions))
[10:26:40.001]     }
[10:26:40.001]     if (FALSE) {
[10:26:40.001]     }
[10:26:40.001]     else {
[10:26:40.001]         if (TRUE) {
[10:26:40.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:40.001]                 open = "w")
[10:26:40.001]         }
[10:26:40.001]         else {
[10:26:40.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:40.001]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:40.001]         }
[10:26:40.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:40.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:40.001]             base::sink(type = "output", split = FALSE)
[10:26:40.001]             base::close(...future.stdout)
[10:26:40.001]         }, add = TRUE)
[10:26:40.001]     }
[10:26:40.001]     ...future.frame <- base::sys.nframe()
[10:26:40.001]     ...future.conditions <- base::list()
[10:26:40.001]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:40.001]     if (FALSE) {
[10:26:40.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:40.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:40.001]     }
[10:26:40.001]     ...future.result <- base::tryCatch({
[10:26:40.001]         base::withCallingHandlers({
[10:26:40.001]             ...future.value <- base::withVisible(base::local({
[10:26:40.001]                 ...future.makeSendCondition <- base::local({
[10:26:40.001]                   sendCondition <- NULL
[10:26:40.001]                   function(frame = 1L) {
[10:26:40.001]                     if (is.function(sendCondition)) 
[10:26:40.001]                       return(sendCondition)
[10:26:40.001]                     ns <- getNamespace("parallel")
[10:26:40.001]                     if (exists("sendData", mode = "function", 
[10:26:40.001]                       envir = ns)) {
[10:26:40.001]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:40.001]                         envir = ns)
[10:26:40.001]                       envir <- sys.frame(frame)
[10:26:40.001]                       master <- NULL
[10:26:40.001]                       while (!identical(envir, .GlobalEnv) && 
[10:26:40.001]                         !identical(envir, emptyenv())) {
[10:26:40.001]                         if (exists("master", mode = "list", envir = envir, 
[10:26:40.001]                           inherits = FALSE)) {
[10:26:40.001]                           master <- get("master", mode = "list", 
[10:26:40.001]                             envir = envir, inherits = FALSE)
[10:26:40.001]                           if (inherits(master, c("SOCKnode", 
[10:26:40.001]                             "SOCK0node"))) {
[10:26:40.001]                             sendCondition <<- function(cond) {
[10:26:40.001]                               data <- list(type = "VALUE", value = cond, 
[10:26:40.001]                                 success = TRUE)
[10:26:40.001]                               parallel_sendData(master, data)
[10:26:40.001]                             }
[10:26:40.001]                             return(sendCondition)
[10:26:40.001]                           }
[10:26:40.001]                         }
[10:26:40.001]                         frame <- frame + 1L
[10:26:40.001]                         envir <- sys.frame(frame)
[10:26:40.001]                       }
[10:26:40.001]                     }
[10:26:40.001]                     sendCondition <<- function(cond) NULL
[10:26:40.001]                   }
[10:26:40.001]                 })
[10:26:40.001]                 withCallingHandlers({
[10:26:40.001]                   NA
[10:26:40.001]                 }, immediateCondition = function(cond) {
[10:26:40.001]                   sendCondition <- ...future.makeSendCondition()
[10:26:40.001]                   sendCondition(cond)
[10:26:40.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.001]                   {
[10:26:40.001]                     inherits <- base::inherits
[10:26:40.001]                     invokeRestart <- base::invokeRestart
[10:26:40.001]                     is.null <- base::is.null
[10:26:40.001]                     muffled <- FALSE
[10:26:40.001]                     if (inherits(cond, "message")) {
[10:26:40.001]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:40.001]                       if (muffled) 
[10:26:40.001]                         invokeRestart("muffleMessage")
[10:26:40.001]                     }
[10:26:40.001]                     else if (inherits(cond, "warning")) {
[10:26:40.001]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:40.001]                       if (muffled) 
[10:26:40.001]                         invokeRestart("muffleWarning")
[10:26:40.001]                     }
[10:26:40.001]                     else if (inherits(cond, "condition")) {
[10:26:40.001]                       if (!is.null(pattern)) {
[10:26:40.001]                         computeRestarts <- base::computeRestarts
[10:26:40.001]                         grepl <- base::grepl
[10:26:40.001]                         restarts <- computeRestarts(cond)
[10:26:40.001]                         for (restart in restarts) {
[10:26:40.001]                           name <- restart$name
[10:26:40.001]                           if (is.null(name)) 
[10:26:40.001]                             next
[10:26:40.001]                           if (!grepl(pattern, name)) 
[10:26:40.001]                             next
[10:26:40.001]                           invokeRestart(restart)
[10:26:40.001]                           muffled <- TRUE
[10:26:40.001]                           break
[10:26:40.001]                         }
[10:26:40.001]                       }
[10:26:40.001]                     }
[10:26:40.001]                     invisible(muffled)
[10:26:40.001]                   }
[10:26:40.001]                   muffleCondition(cond)
[10:26:40.001]                 })
[10:26:40.001]             }))
[10:26:40.001]             future::FutureResult(value = ...future.value$value, 
[10:26:40.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:40.001]                   ...future.rng), globalenv = if (FALSE) 
[10:26:40.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:40.001]                     ...future.globalenv.names))
[10:26:40.001]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:40.001]         }, condition = base::local({
[10:26:40.001]             c <- base::c
[10:26:40.001]             inherits <- base::inherits
[10:26:40.001]             invokeRestart <- base::invokeRestart
[10:26:40.001]             length <- base::length
[10:26:40.001]             list <- base::list
[10:26:40.001]             seq.int <- base::seq.int
[10:26:40.001]             signalCondition <- base::signalCondition
[10:26:40.001]             sys.calls <- base::sys.calls
[10:26:40.001]             `[[` <- base::`[[`
[10:26:40.001]             `+` <- base::`+`
[10:26:40.001]             `<<-` <- base::`<<-`
[10:26:40.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:40.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:40.001]                   3L)]
[10:26:40.001]             }
[10:26:40.001]             function(cond) {
[10:26:40.001]                 is_error <- inherits(cond, "error")
[10:26:40.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:40.001]                   NULL)
[10:26:40.001]                 if (is_error) {
[10:26:40.001]                   sessionInformation <- function() {
[10:26:40.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:40.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:40.001]                       search = base::search(), system = base::Sys.info())
[10:26:40.001]                   }
[10:26:40.001]                   ...future.conditions[[length(...future.conditions) + 
[10:26:40.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:40.001]                     cond$call), session = sessionInformation(), 
[10:26:40.001]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:40.001]                   signalCondition(cond)
[10:26:40.001]                 }
[10:26:40.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:40.001]                 "immediateCondition"))) {
[10:26:40.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:40.001]                   ...future.conditions[[length(...future.conditions) + 
[10:26:40.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:40.001]                   if (TRUE && !signal) {
[10:26:40.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.001]                     {
[10:26:40.001]                       inherits <- base::inherits
[10:26:40.001]                       invokeRestart <- base::invokeRestart
[10:26:40.001]                       is.null <- base::is.null
[10:26:40.001]                       muffled <- FALSE
[10:26:40.001]                       if (inherits(cond, "message")) {
[10:26:40.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:40.001]                         if (muffled) 
[10:26:40.001]                           invokeRestart("muffleMessage")
[10:26:40.001]                       }
[10:26:40.001]                       else if (inherits(cond, "warning")) {
[10:26:40.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:40.001]                         if (muffled) 
[10:26:40.001]                           invokeRestart("muffleWarning")
[10:26:40.001]                       }
[10:26:40.001]                       else if (inherits(cond, "condition")) {
[10:26:40.001]                         if (!is.null(pattern)) {
[10:26:40.001]                           computeRestarts <- base::computeRestarts
[10:26:40.001]                           grepl <- base::grepl
[10:26:40.001]                           restarts <- computeRestarts(cond)
[10:26:40.001]                           for (restart in restarts) {
[10:26:40.001]                             name <- restart$name
[10:26:40.001]                             if (is.null(name)) 
[10:26:40.001]                               next
[10:26:40.001]                             if (!grepl(pattern, name)) 
[10:26:40.001]                               next
[10:26:40.001]                             invokeRestart(restart)
[10:26:40.001]                             muffled <- TRUE
[10:26:40.001]                             break
[10:26:40.001]                           }
[10:26:40.001]                         }
[10:26:40.001]                       }
[10:26:40.001]                       invisible(muffled)
[10:26:40.001]                     }
[10:26:40.001]                     muffleCondition(cond, pattern = "^muffle")
[10:26:40.001]                   }
[10:26:40.001]                 }
[10:26:40.001]                 else {
[10:26:40.001]                   if (TRUE) {
[10:26:40.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.001]                     {
[10:26:40.001]                       inherits <- base::inherits
[10:26:40.001]                       invokeRestart <- base::invokeRestart
[10:26:40.001]                       is.null <- base::is.null
[10:26:40.001]                       muffled <- FALSE
[10:26:40.001]                       if (inherits(cond, "message")) {
[10:26:40.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:40.001]                         if (muffled) 
[10:26:40.001]                           invokeRestart("muffleMessage")
[10:26:40.001]                       }
[10:26:40.001]                       else if (inherits(cond, "warning")) {
[10:26:40.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:40.001]                         if (muffled) 
[10:26:40.001]                           invokeRestart("muffleWarning")
[10:26:40.001]                       }
[10:26:40.001]                       else if (inherits(cond, "condition")) {
[10:26:40.001]                         if (!is.null(pattern)) {
[10:26:40.001]                           computeRestarts <- base::computeRestarts
[10:26:40.001]                           grepl <- base::grepl
[10:26:40.001]                           restarts <- computeRestarts(cond)
[10:26:40.001]                           for (restart in restarts) {
[10:26:40.001]                             name <- restart$name
[10:26:40.001]                             if (is.null(name)) 
[10:26:40.001]                               next
[10:26:40.001]                             if (!grepl(pattern, name)) 
[10:26:40.001]                               next
[10:26:40.001]                             invokeRestart(restart)
[10:26:40.001]                             muffled <- TRUE
[10:26:40.001]                             break
[10:26:40.001]                           }
[10:26:40.001]                         }
[10:26:40.001]                       }
[10:26:40.001]                       invisible(muffled)
[10:26:40.001]                     }
[10:26:40.001]                     muffleCondition(cond, pattern = "^muffle")
[10:26:40.001]                   }
[10:26:40.001]                 }
[10:26:40.001]             }
[10:26:40.001]         }))
[10:26:40.001]     }, error = function(ex) {
[10:26:40.001]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:40.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:40.001]                 ...future.rng), started = ...future.startTime, 
[10:26:40.001]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:40.001]             version = "1.8"), class = "FutureResult")
[10:26:40.001]     }, finally = {
[10:26:40.001]         if (!identical(...future.workdir, getwd())) 
[10:26:40.001]             setwd(...future.workdir)
[10:26:40.001]         {
[10:26:40.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:40.001]                 ...future.oldOptions$nwarnings <- NULL
[10:26:40.001]             }
[10:26:40.001]             base::options(...future.oldOptions)
[10:26:40.001]             if (.Platform$OS.type == "windows") {
[10:26:40.001]                 old_names <- names(...future.oldEnvVars)
[10:26:40.001]                 envs <- base::Sys.getenv()
[10:26:40.001]                 names <- names(envs)
[10:26:40.001]                 common <- intersect(names, old_names)
[10:26:40.001]                 added <- setdiff(names, old_names)
[10:26:40.001]                 removed <- setdiff(old_names, names)
[10:26:40.001]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:40.001]                   envs[common]]
[10:26:40.001]                 NAMES <- toupper(changed)
[10:26:40.001]                 args <- list()
[10:26:40.001]                 for (kk in seq_along(NAMES)) {
[10:26:40.001]                   name <- changed[[kk]]
[10:26:40.001]                   NAME <- NAMES[[kk]]
[10:26:40.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.001]                     next
[10:26:40.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:40.001]                 }
[10:26:40.001]                 NAMES <- toupper(added)
[10:26:40.001]                 for (kk in seq_along(NAMES)) {
[10:26:40.001]                   name <- added[[kk]]
[10:26:40.001]                   NAME <- NAMES[[kk]]
[10:26:40.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.001]                     next
[10:26:40.001]                   args[[name]] <- ""
[10:26:40.001]                 }
[10:26:40.001]                 NAMES <- toupper(removed)
[10:26:40.001]                 for (kk in seq_along(NAMES)) {
[10:26:40.001]                   name <- removed[[kk]]
[10:26:40.001]                   NAME <- NAMES[[kk]]
[10:26:40.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.001]                     next
[10:26:40.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:40.001]                 }
[10:26:40.001]                 if (length(args) > 0) 
[10:26:40.001]                   base::do.call(base::Sys.setenv, args = args)
[10:26:40.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:40.001]             }
[10:26:40.001]             else {
[10:26:40.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:40.001]             }
[10:26:40.001]             {
[10:26:40.001]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:40.001]                   0L) {
[10:26:40.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:40.001]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:40.001]                   base::options(opts)
[10:26:40.001]                 }
[10:26:40.001]                 {
[10:26:40.001]                   {
[10:26:40.001]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:40.001]                     NULL
[10:26:40.001]                   }
[10:26:40.001]                   options(future.plan = NULL)
[10:26:40.001]                   if (is.na(NA_character_)) 
[10:26:40.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:40.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:40.001]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:40.001]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.001]                     envir = parent.frame()) 
[10:26:40.001]                   {
[10:26:40.001]                     if (is.function(workers)) 
[10:26:40.001]                       workers <- workers()
[10:26:40.001]                     workers <- structure(as.integer(workers), 
[10:26:40.001]                       class = class(workers))
[10:26:40.001]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.001]                       workers >= 1)
[10:26:40.001]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.001]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.001]                     }
[10:26:40.001]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.001]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.001]                       envir = envir)
[10:26:40.001]                     if (!future$lazy) 
[10:26:40.001]                       future <- run(future)
[10:26:40.001]                     invisible(future)
[10:26:40.001]                   }, b = function (..., workers = availableCores(), 
[10:26:40.001]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.001]                     envir = parent.frame()) 
[10:26:40.001]                   {
[10:26:40.001]                     if (is.function(workers)) 
[10:26:40.001]                       workers <- workers()
[10:26:40.001]                     workers <- structure(as.integer(workers), 
[10:26:40.001]                       class = class(workers))
[10:26:40.001]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.001]                       workers >= 1)
[10:26:40.001]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.001]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.001]                     }
[10:26:40.001]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.001]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.001]                       envir = envir)
[10:26:40.001]                     if (!future$lazy) 
[10:26:40.001]                       future <- run(future)
[10:26:40.001]                     invisible(future)
[10:26:40.001]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:40.001]                 }
[10:26:40.001]             }
[10:26:40.001]         }
[10:26:40.001]     })
[10:26:40.001]     if (TRUE) {
[10:26:40.001]         base::sink(type = "output", split = FALSE)
[10:26:40.001]         if (TRUE) {
[10:26:40.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:40.001]         }
[10:26:40.001]         else {
[10:26:40.001]             ...future.result["stdout"] <- base::list(NULL)
[10:26:40.001]         }
[10:26:40.001]         base::close(...future.stdout)
[10:26:40.001]         ...future.stdout <- NULL
[10:26:40.001]     }
[10:26:40.001]     ...future.result$conditions <- ...future.conditions
[10:26:40.001]     ...future.result$finished <- base::Sys.time()
[10:26:40.001]     ...future.result
[10:26:40.001] }
[10:26:40.056] MultisessionFuture started
[10:26:40.056] result() for ClusterFuture ...
[10:26:40.056] receiveMessageFromWorker() for ClusterFuture ...
[10:26:40.056] - Validating connection of MultisessionFuture
[10:26:40.108] - received message: FutureResult
[10:26:40.108] - Received FutureResult
[10:26:40.108] - Erased future from FutureRegistry
[10:26:40.108] result() for ClusterFuture ...
[10:26:40.108] - result already collected: FutureResult
[10:26:40.108] result() for ClusterFuture ... done
[10:26:40.108] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:40.109] result() for ClusterFuture ... done
[10:26:40.109] result() for ClusterFuture ...
[10:26:40.109] - result already collected: FutureResult
[10:26:40.109] result() for ClusterFuture ... done
[10:26:40.109] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:26:40.112] plan(): nbrOfWorkers() = 2
[10:26:40.113] getGlobalsAndPackages() ...
[10:26:40.113] Searching for globals...
[10:26:40.129] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:26:40.130] Searching for globals ... DONE
[10:26:40.130] Resolving globals: FALSE
[10:26:40.131] The total size of the 2 globals is 88.27 KiB (90384 bytes)
[10:26:40.131] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 88.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (88.15 KiB of class ‘list’) and ‘strategy2’ (120 bytes of class ‘character’)
[10:26:40.131] - globals: [2] ‘nested’, ‘strategy2’
[10:26:40.131] - packages: [1] ‘future’
[10:26:40.132] getGlobalsAndPackages() ... DONE
[10:26:40.132] run() for ‘Future’ ...
[10:26:40.132] - state: ‘created’
[10:26:40.132] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:40.146] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:40.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:40.147]   - Field: ‘node’
[10:26:40.147]   - Field: ‘label’
[10:26:40.147]   - Field: ‘local’
[10:26:40.147]   - Field: ‘owner’
[10:26:40.147]   - Field: ‘envir’
[10:26:40.147]   - Field: ‘workers’
[10:26:40.147]   - Field: ‘packages’
[10:26:40.147]   - Field: ‘gc’
[10:26:40.148]   - Field: ‘conditions’
[10:26:40.148]   - Field: ‘persistent’
[10:26:40.148]   - Field: ‘expr’
[10:26:40.148]   - Field: ‘uuid’
[10:26:40.148]   - Field: ‘seed’
[10:26:40.148]   - Field: ‘version’
[10:26:40.148]   - Field: ‘result’
[10:26:40.148]   - Field: ‘asynchronous’
[10:26:40.148]   - Field: ‘calls’
[10:26:40.148]   - Field: ‘globals’
[10:26:40.148]   - Field: ‘stdout’
[10:26:40.149]   - Field: ‘earlySignal’
[10:26:40.149]   - Field: ‘lazy’
[10:26:40.149]   - Field: ‘state’
[10:26:40.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:40.149] - Launch lazy future ...
[10:26:40.149] Packages needed by the future expression (n = 1): ‘future’
[10:26:40.150] Packages needed by future strategies (n = 1): ‘future’
[10:26:40.150] {
[10:26:40.150]     {
[10:26:40.150]         {
[10:26:40.150]             ...future.startTime <- base::Sys.time()
[10:26:40.150]             {
[10:26:40.150]                 {
[10:26:40.150]                   {
[10:26:40.150]                     {
[10:26:40.150]                       {
[10:26:40.150]                         base::local({
[10:26:40.150]                           has_future <- base::requireNamespace("future", 
[10:26:40.150]                             quietly = TRUE)
[10:26:40.150]                           if (has_future) {
[10:26:40.150]                             ns <- base::getNamespace("future")
[10:26:40.150]                             version <- ns[[".package"]][["version"]]
[10:26:40.150]                             if (is.null(version)) 
[10:26:40.150]                               version <- utils::packageVersion("future")
[10:26:40.150]                           }
[10:26:40.150]                           else {
[10:26:40.150]                             version <- NULL
[10:26:40.150]                           }
[10:26:40.150]                           if (!has_future || version < "1.8.0") {
[10:26:40.150]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:40.150]                               "", base::R.version$version.string), 
[10:26:40.150]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:40.150]                                 base::R.version$platform, 8 * 
[10:26:40.150]                                   base::.Machine$sizeof.pointer), 
[10:26:40.150]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:40.150]                                 "release", "version")], collapse = " "), 
[10:26:40.150]                               hostname = base::Sys.info()[["nodename"]])
[10:26:40.150]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:40.150]                               info)
[10:26:40.150]                             info <- base::paste(info, collapse = "; ")
[10:26:40.150]                             if (!has_future) {
[10:26:40.150]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:40.150]                                 info)
[10:26:40.150]                             }
[10:26:40.150]                             else {
[10:26:40.150]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:40.150]                                 info, version)
[10:26:40.150]                             }
[10:26:40.150]                             base::stop(msg)
[10:26:40.150]                           }
[10:26:40.150]                         })
[10:26:40.150]                       }
[10:26:40.150]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:40.150]                       base::options(mc.cores = 1L)
[10:26:40.150]                     }
[10:26:40.150]                     base::local({
[10:26:40.150]                       for (pkg in "future") {
[10:26:40.150]                         base::loadNamespace(pkg)
[10:26:40.150]                         base::library(pkg, character.only = TRUE)
[10:26:40.150]                       }
[10:26:40.150]                     })
[10:26:40.150]                   }
[10:26:40.150]                   options(future.plan = NULL)
[10:26:40.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:40.150]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:40.150]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.150]                     envir = parent.frame()) 
[10:26:40.150]                   {
[10:26:40.150]                     if (is.function(workers)) 
[10:26:40.150]                       workers <- workers()
[10:26:40.150]                     workers <- structure(as.integer(workers), 
[10:26:40.150]                       class = class(workers))
[10:26:40.150]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.150]                       workers >= 1)
[10:26:40.150]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.150]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.150]                     }
[10:26:40.150]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.150]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.150]                       envir = envir)
[10:26:40.150]                     if (!future$lazy) 
[10:26:40.150]                       future <- run(future)
[10:26:40.150]                     invisible(future)
[10:26:40.150]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:40.150]                 }
[10:26:40.150]                 ...future.workdir <- getwd()
[10:26:40.150]             }
[10:26:40.150]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:40.150]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:40.150]         }
[10:26:40.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:40.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:40.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:40.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:40.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:40.150]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:40.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:40.150]             base::names(...future.oldOptions))
[10:26:40.150]     }
[10:26:40.150]     if (FALSE) {
[10:26:40.150]     }
[10:26:40.150]     else {
[10:26:40.150]         if (TRUE) {
[10:26:40.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:40.150]                 open = "w")
[10:26:40.150]         }
[10:26:40.150]         else {
[10:26:40.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:40.150]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:40.150]         }
[10:26:40.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:40.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:40.150]             base::sink(type = "output", split = FALSE)
[10:26:40.150]             base::close(...future.stdout)
[10:26:40.150]         }, add = TRUE)
[10:26:40.150]     }
[10:26:40.150]     ...future.frame <- base::sys.nframe()
[10:26:40.150]     ...future.conditions <- base::list()
[10:26:40.150]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:40.150]     if (FALSE) {
[10:26:40.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:40.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:40.150]     }
[10:26:40.150]     ...future.result <- base::tryCatch({
[10:26:40.150]         base::withCallingHandlers({
[10:26:40.150]             ...future.value <- base::withVisible(base::local({
[10:26:40.150]                 ...future.makeSendCondition <- base::local({
[10:26:40.150]                   sendCondition <- NULL
[10:26:40.150]                   function(frame = 1L) {
[10:26:40.150]                     if (is.function(sendCondition)) 
[10:26:40.150]                       return(sendCondition)
[10:26:40.150]                     ns <- getNamespace("parallel")
[10:26:40.150]                     if (exists("sendData", mode = "function", 
[10:26:40.150]                       envir = ns)) {
[10:26:40.150]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:40.150]                         envir = ns)
[10:26:40.150]                       envir <- sys.frame(frame)
[10:26:40.150]                       master <- NULL
[10:26:40.150]                       while (!identical(envir, .GlobalEnv) && 
[10:26:40.150]                         !identical(envir, emptyenv())) {
[10:26:40.150]                         if (exists("master", mode = "list", envir = envir, 
[10:26:40.150]                           inherits = FALSE)) {
[10:26:40.150]                           master <- get("master", mode = "list", 
[10:26:40.150]                             envir = envir, inherits = FALSE)
[10:26:40.150]                           if (inherits(master, c("SOCKnode", 
[10:26:40.150]                             "SOCK0node"))) {
[10:26:40.150]                             sendCondition <<- function(cond) {
[10:26:40.150]                               data <- list(type = "VALUE", value = cond, 
[10:26:40.150]                                 success = TRUE)
[10:26:40.150]                               parallel_sendData(master, data)
[10:26:40.150]                             }
[10:26:40.150]                             return(sendCondition)
[10:26:40.150]                           }
[10:26:40.150]                         }
[10:26:40.150]                         frame <- frame + 1L
[10:26:40.150]                         envir <- sys.frame(frame)
[10:26:40.150]                       }
[10:26:40.150]                     }
[10:26:40.150]                     sendCondition <<- function(cond) NULL
[10:26:40.150]                   }
[10:26:40.150]                 })
[10:26:40.150]                 withCallingHandlers({
[10:26:40.150]                   {
[10:26:40.150]                     a <- 1L
[10:26:40.150]                     plan_a <- unclass(future::plan("list"))
[10:26:40.150]                     nested_a <- nested[-1]
[10:26:40.150]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:26:40.150]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:26:40.150]                       strategy2))
[10:26:40.150]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:26:40.150]                       "init") <- NULL
[10:26:40.150]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:26:40.150]                       "init") <- NULL
[10:26:40.150]                     stopifnot(all.equal(plan_a, nested_a))
[10:26:40.150]                     y %<-% {
[10:26:40.150]                       b <- 2L
[10:26:40.150]                       plan_b <- future::plan("list")
[10:26:40.150]                       nested_b <- nested_a[-1]
[10:26:40.150]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:26:40.150]                         1L, inherits(plan_b[[1]], "future"), 
[10:26:40.150]                         inherits(future::plan("next"), "sequential"))
[10:26:40.150]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:26:40.150]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:26:40.150]                     }
[10:26:40.150]                     y
[10:26:40.150]                   }
[10:26:40.150]                 }, immediateCondition = function(cond) {
[10:26:40.150]                   sendCondition <- ...future.makeSendCondition()
[10:26:40.150]                   sendCondition(cond)
[10:26:40.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.150]                   {
[10:26:40.150]                     inherits <- base::inherits
[10:26:40.150]                     invokeRestart <- base::invokeRestart
[10:26:40.150]                     is.null <- base::is.null
[10:26:40.150]                     muffled <- FALSE
[10:26:40.150]                     if (inherits(cond, "message")) {
[10:26:40.150]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:40.150]                       if (muffled) 
[10:26:40.150]                         invokeRestart("muffleMessage")
[10:26:40.150]                     }
[10:26:40.150]                     else if (inherits(cond, "warning")) {
[10:26:40.150]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:40.150]                       if (muffled) 
[10:26:40.150]                         invokeRestart("muffleWarning")
[10:26:40.150]                     }
[10:26:40.150]                     else if (inherits(cond, "condition")) {
[10:26:40.150]                       if (!is.null(pattern)) {
[10:26:40.150]                         computeRestarts <- base::computeRestarts
[10:26:40.150]                         grepl <- base::grepl
[10:26:40.150]                         restarts <- computeRestarts(cond)
[10:26:40.150]                         for (restart in restarts) {
[10:26:40.150]                           name <- restart$name
[10:26:40.150]                           if (is.null(name)) 
[10:26:40.150]                             next
[10:26:40.150]                           if (!grepl(pattern, name)) 
[10:26:40.150]                             next
[10:26:40.150]                           invokeRestart(restart)
[10:26:40.150]                           muffled <- TRUE
[10:26:40.150]                           break
[10:26:40.150]                         }
[10:26:40.150]                       }
[10:26:40.150]                     }
[10:26:40.150]                     invisible(muffled)
[10:26:40.150]                   }
[10:26:40.150]                   muffleCondition(cond)
[10:26:40.150]                 })
[10:26:40.150]             }))
[10:26:40.150]             future::FutureResult(value = ...future.value$value, 
[10:26:40.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:40.150]                   ...future.rng), globalenv = if (FALSE) 
[10:26:40.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:40.150]                     ...future.globalenv.names))
[10:26:40.150]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:40.150]         }, condition = base::local({
[10:26:40.150]             c <- base::c
[10:26:40.150]             inherits <- base::inherits
[10:26:40.150]             invokeRestart <- base::invokeRestart
[10:26:40.150]             length <- base::length
[10:26:40.150]             list <- base::list
[10:26:40.150]             seq.int <- base::seq.int
[10:26:40.150]             signalCondition <- base::signalCondition
[10:26:40.150]             sys.calls <- base::sys.calls
[10:26:40.150]             `[[` <- base::`[[`
[10:26:40.150]             `+` <- base::`+`
[10:26:40.150]             `<<-` <- base::`<<-`
[10:26:40.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:40.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:40.150]                   3L)]
[10:26:40.150]             }
[10:26:40.150]             function(cond) {
[10:26:40.150]                 is_error <- inherits(cond, "error")
[10:26:40.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:40.150]                   NULL)
[10:26:40.150]                 if (is_error) {
[10:26:40.150]                   sessionInformation <- function() {
[10:26:40.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:40.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:40.150]                       search = base::search(), system = base::Sys.info())
[10:26:40.150]                   }
[10:26:40.150]                   ...future.conditions[[length(...future.conditions) + 
[10:26:40.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:40.150]                     cond$call), session = sessionInformation(), 
[10:26:40.150]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:40.150]                   signalCondition(cond)
[10:26:40.150]                 }
[10:26:40.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:40.150]                 "immediateCondition"))) {
[10:26:40.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:40.150]                   ...future.conditions[[length(...future.conditions) + 
[10:26:40.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:40.150]                   if (TRUE && !signal) {
[10:26:40.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.150]                     {
[10:26:40.150]                       inherits <- base::inherits
[10:26:40.150]                       invokeRestart <- base::invokeRestart
[10:26:40.150]                       is.null <- base::is.null
[10:26:40.150]                       muffled <- FALSE
[10:26:40.150]                       if (inherits(cond, "message")) {
[10:26:40.150]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:40.150]                         if (muffled) 
[10:26:40.150]                           invokeRestart("muffleMessage")
[10:26:40.150]                       }
[10:26:40.150]                       else if (inherits(cond, "warning")) {
[10:26:40.150]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:40.150]                         if (muffled) 
[10:26:40.150]                           invokeRestart("muffleWarning")
[10:26:40.150]                       }
[10:26:40.150]                       else if (inherits(cond, "condition")) {
[10:26:40.150]                         if (!is.null(pattern)) {
[10:26:40.150]                           computeRestarts <- base::computeRestarts
[10:26:40.150]                           grepl <- base::grepl
[10:26:40.150]                           restarts <- computeRestarts(cond)
[10:26:40.150]                           for (restart in restarts) {
[10:26:40.150]                             name <- restart$name
[10:26:40.150]                             if (is.null(name)) 
[10:26:40.150]                               next
[10:26:40.150]                             if (!grepl(pattern, name)) 
[10:26:40.150]                               next
[10:26:40.150]                             invokeRestart(restart)
[10:26:40.150]                             muffled <- TRUE
[10:26:40.150]                             break
[10:26:40.150]                           }
[10:26:40.150]                         }
[10:26:40.150]                       }
[10:26:40.150]                       invisible(muffled)
[10:26:40.150]                     }
[10:26:40.150]                     muffleCondition(cond, pattern = "^muffle")
[10:26:40.150]                   }
[10:26:40.150]                 }
[10:26:40.150]                 else {
[10:26:40.150]                   if (TRUE) {
[10:26:40.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.150]                     {
[10:26:40.150]                       inherits <- base::inherits
[10:26:40.150]                       invokeRestart <- base::invokeRestart
[10:26:40.150]                       is.null <- base::is.null
[10:26:40.150]                       muffled <- FALSE
[10:26:40.150]                       if (inherits(cond, "message")) {
[10:26:40.150]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:40.150]                         if (muffled) 
[10:26:40.150]                           invokeRestart("muffleMessage")
[10:26:40.150]                       }
[10:26:40.150]                       else if (inherits(cond, "warning")) {
[10:26:40.150]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:40.150]                         if (muffled) 
[10:26:40.150]                           invokeRestart("muffleWarning")
[10:26:40.150]                       }
[10:26:40.150]                       else if (inherits(cond, "condition")) {
[10:26:40.150]                         if (!is.null(pattern)) {
[10:26:40.150]                           computeRestarts <- base::computeRestarts
[10:26:40.150]                           grepl <- base::grepl
[10:26:40.150]                           restarts <- computeRestarts(cond)
[10:26:40.150]                           for (restart in restarts) {
[10:26:40.150]                             name <- restart$name
[10:26:40.150]                             if (is.null(name)) 
[10:26:40.150]                               next
[10:26:40.150]                             if (!grepl(pattern, name)) 
[10:26:40.150]                               next
[10:26:40.150]                             invokeRestart(restart)
[10:26:40.150]                             muffled <- TRUE
[10:26:40.150]                             break
[10:26:40.150]                           }
[10:26:40.150]                         }
[10:26:40.150]                       }
[10:26:40.150]                       invisible(muffled)
[10:26:40.150]                     }
[10:26:40.150]                     muffleCondition(cond, pattern = "^muffle")
[10:26:40.150]                   }
[10:26:40.150]                 }
[10:26:40.150]             }
[10:26:40.150]         }))
[10:26:40.150]     }, error = function(ex) {
[10:26:40.150]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:40.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:40.150]                 ...future.rng), started = ...future.startTime, 
[10:26:40.150]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:40.150]             version = "1.8"), class = "FutureResult")
[10:26:40.150]     }, finally = {
[10:26:40.150]         if (!identical(...future.workdir, getwd())) 
[10:26:40.150]             setwd(...future.workdir)
[10:26:40.150]         {
[10:26:40.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:40.150]                 ...future.oldOptions$nwarnings <- NULL
[10:26:40.150]             }
[10:26:40.150]             base::options(...future.oldOptions)
[10:26:40.150]             if (.Platform$OS.type == "windows") {
[10:26:40.150]                 old_names <- names(...future.oldEnvVars)
[10:26:40.150]                 envs <- base::Sys.getenv()
[10:26:40.150]                 names <- names(envs)
[10:26:40.150]                 common <- intersect(names, old_names)
[10:26:40.150]                 added <- setdiff(names, old_names)
[10:26:40.150]                 removed <- setdiff(old_names, names)
[10:26:40.150]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:40.150]                   envs[common]]
[10:26:40.150]                 NAMES <- toupper(changed)
[10:26:40.150]                 args <- list()
[10:26:40.150]                 for (kk in seq_along(NAMES)) {
[10:26:40.150]                   name <- changed[[kk]]
[10:26:40.150]                   NAME <- NAMES[[kk]]
[10:26:40.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.150]                     next
[10:26:40.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:40.150]                 }
[10:26:40.150]                 NAMES <- toupper(added)
[10:26:40.150]                 for (kk in seq_along(NAMES)) {
[10:26:40.150]                   name <- added[[kk]]
[10:26:40.150]                   NAME <- NAMES[[kk]]
[10:26:40.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.150]                     next
[10:26:40.150]                   args[[name]] <- ""
[10:26:40.150]                 }
[10:26:40.150]                 NAMES <- toupper(removed)
[10:26:40.150]                 for (kk in seq_along(NAMES)) {
[10:26:40.150]                   name <- removed[[kk]]
[10:26:40.150]                   NAME <- NAMES[[kk]]
[10:26:40.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.150]                     next
[10:26:40.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:40.150]                 }
[10:26:40.150]                 if (length(args) > 0) 
[10:26:40.150]                   base::do.call(base::Sys.setenv, args = args)
[10:26:40.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:40.150]             }
[10:26:40.150]             else {
[10:26:40.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:40.150]             }
[10:26:40.150]             {
[10:26:40.150]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:40.150]                   0L) {
[10:26:40.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:40.150]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:40.150]                   base::options(opts)
[10:26:40.150]                 }
[10:26:40.150]                 {
[10:26:40.150]                   {
[10:26:40.150]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:40.150]                     NULL
[10:26:40.150]                   }
[10:26:40.150]                   options(future.plan = NULL)
[10:26:40.150]                   if (is.na(NA_character_)) 
[10:26:40.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:40.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:40.150]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:40.150]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.150]                     envir = parent.frame()) 
[10:26:40.150]                   {
[10:26:40.150]                     if (is.function(workers)) 
[10:26:40.150]                       workers <- workers()
[10:26:40.150]                     workers <- structure(as.integer(workers), 
[10:26:40.150]                       class = class(workers))
[10:26:40.150]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.150]                       workers >= 1)
[10:26:40.150]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.150]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.150]                     }
[10:26:40.150]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.150]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.150]                       envir = envir)
[10:26:40.150]                     if (!future$lazy) 
[10:26:40.150]                       future <- run(future)
[10:26:40.150]                     invisible(future)
[10:26:40.150]                   }, b = function (..., workers = availableCores(), 
[10:26:40.150]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.150]                     envir = parent.frame()) 
[10:26:40.150]                   {
[10:26:40.150]                     if (is.function(workers)) 
[10:26:40.150]                       workers <- workers()
[10:26:40.150]                     workers <- structure(as.integer(workers), 
[10:26:40.150]                       class = class(workers))
[10:26:40.150]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.150]                       workers >= 1)
[10:26:40.150]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.150]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.150]                     }
[10:26:40.150]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.150]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.150]                       envir = envir)
[10:26:40.150]                     if (!future$lazy) 
[10:26:40.150]                       future <- run(future)
[10:26:40.150]                     invisible(future)
[10:26:40.150]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:40.150]                 }
[10:26:40.150]             }
[10:26:40.150]         }
[10:26:40.150]     })
[10:26:40.150]     if (TRUE) {
[10:26:40.150]         base::sink(type = "output", split = FALSE)
[10:26:40.150]         if (TRUE) {
[10:26:40.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:40.150]         }
[10:26:40.150]         else {
[10:26:40.150]             ...future.result["stdout"] <- base::list(NULL)
[10:26:40.150]         }
[10:26:40.150]         base::close(...future.stdout)
[10:26:40.150]         ...future.stdout <- NULL
[10:26:40.150]     }
[10:26:40.150]     ...future.result$conditions <- ...future.conditions
[10:26:40.150]     ...future.result$finished <- base::Sys.time()
[10:26:40.150]     ...future.result
[10:26:40.150] }
[10:26:40.153] Exporting 2 global objects (88.27 KiB) to cluster node #1 ...
[10:26:40.154] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ...
[10:26:40.198] Exporting ‘nested’ (88.15 KiB) to cluster node #1 ... DONE
[10:26:40.198] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ...
[10:26:40.199] Exporting ‘strategy2’ (120 bytes) to cluster node #1 ... DONE
[10:26:40.199] Exporting 2 global objects (88.27 KiB) to cluster node #1 ... DONE
[10:26:40.199] MultisessionFuture started
[10:26:40.200] - Launch lazy future ... done
[10:26:40.200] run() for ‘MultisessionFuture’ ... done
[10:26:40.200] result() for ClusterFuture ...
[10:26:40.200] receiveMessageFromWorker() for ClusterFuture ...
[10:26:40.200] - Validating connection of MultisessionFuture
[10:26:40.275] - received message: FutureResult
[10:26:40.276] - Received FutureResult
[10:26:40.276] - Erased future from FutureRegistry
[10:26:40.276] result() for ClusterFuture ...
[10:26:40.276] - result already collected: FutureResult
[10:26:40.276] result() for ClusterFuture ... done
[10:26:40.276] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:40.276] result() for ClusterFuture ... done
[10:26:40.276] result() for ClusterFuture ...
[10:26:40.277] - result already collected: FutureResult
[10:26:40.277] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:26:40.283] getGlobalsAndPackages() ...
[10:26:40.283] Searching for globals...
[10:26:40.284] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:26:40.284] Searching for globals ... DONE
[10:26:40.284] Resolving globals: FALSE
[10:26:40.285] The total size of the 1 globals is 128 bytes (128 bytes)
[10:26:40.285] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 128 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (128 bytes of class ‘list’)
[10:26:40.285] - globals: [1] ‘data’
[10:26:40.285] - packages: [1] ‘future’
[10:26:40.286] getGlobalsAndPackages() ... DONE
[10:26:40.286] run() for ‘Future’ ...
[10:26:40.286] - state: ‘created’
[10:26:40.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:26:40.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:26:40.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:26:40.300]   - Field: ‘node’
[10:26:40.300]   - Field: ‘label’
[10:26:40.301]   - Field: ‘local’
[10:26:40.301]   - Field: ‘owner’
[10:26:40.301]   - Field: ‘envir’
[10:26:40.301]   - Field: ‘workers’
[10:26:40.301]   - Field: ‘packages’
[10:26:40.303]   - Field: ‘gc’
[10:26:40.303]   - Field: ‘conditions’
[10:26:40.303]   - Field: ‘persistent’
[10:26:40.303]   - Field: ‘expr’
[10:26:40.304]   - Field: ‘uuid’
[10:26:40.304]   - Field: ‘seed’
[10:26:40.304]   - Field: ‘version’
[10:26:40.304]   - Field: ‘result’
[10:26:40.304]   - Field: ‘asynchronous’
[10:26:40.304]   - Field: ‘calls’
[10:26:40.304]   - Field: ‘globals’
[10:26:40.304]   - Field: ‘stdout’
[10:26:40.304]   - Field: ‘earlySignal’
[10:26:40.304]   - Field: ‘lazy’
[10:26:40.304]   - Field: ‘state’
[10:26:40.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:26:40.305] - Launch lazy future ...
[10:26:40.305] Packages needed by the future expression (n = 1): ‘future’
[10:26:40.305] Packages needed by future strategies (n = 1): ‘future’
[10:26:40.306] {
[10:26:40.306]     {
[10:26:40.306]         {
[10:26:40.306]             ...future.startTime <- base::Sys.time()
[10:26:40.306]             {
[10:26:40.306]                 {
[10:26:40.306]                   {
[10:26:40.306]                     {
[10:26:40.306]                       {
[10:26:40.306]                         base::local({
[10:26:40.306]                           has_future <- base::requireNamespace("future", 
[10:26:40.306]                             quietly = TRUE)
[10:26:40.306]                           if (has_future) {
[10:26:40.306]                             ns <- base::getNamespace("future")
[10:26:40.306]                             version <- ns[[".package"]][["version"]]
[10:26:40.306]                             if (is.null(version)) 
[10:26:40.306]                               version <- utils::packageVersion("future")
[10:26:40.306]                           }
[10:26:40.306]                           else {
[10:26:40.306]                             version <- NULL
[10:26:40.306]                           }
[10:26:40.306]                           if (!has_future || version < "1.8.0") {
[10:26:40.306]                             info <- base::c(r_version = base::gsub("R version ", 
[10:26:40.306]                               "", base::R.version$version.string), 
[10:26:40.306]                               platform = base::sprintf("%s (%s-bit)", 
[10:26:40.306]                                 base::R.version$platform, 8 * 
[10:26:40.306]                                   base::.Machine$sizeof.pointer), 
[10:26:40.306]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:26:40.306]                                 "release", "version")], collapse = " "), 
[10:26:40.306]                               hostname = base::Sys.info()[["nodename"]])
[10:26:40.306]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:26:40.306]                               info)
[10:26:40.306]                             info <- base::paste(info, collapse = "; ")
[10:26:40.306]                             if (!has_future) {
[10:26:40.306]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:26:40.306]                                 info)
[10:26:40.306]                             }
[10:26:40.306]                             else {
[10:26:40.306]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:26:40.306]                                 info, version)
[10:26:40.306]                             }
[10:26:40.306]                             base::stop(msg)
[10:26:40.306]                           }
[10:26:40.306]                         })
[10:26:40.306]                       }
[10:26:40.306]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:26:40.306]                       base::options(mc.cores = 1L)
[10:26:40.306]                     }
[10:26:40.306]                     base::local({
[10:26:40.306]                       for (pkg in "future") {
[10:26:40.306]                         base::loadNamespace(pkg)
[10:26:40.306]                         base::library(pkg, character.only = TRUE)
[10:26:40.306]                       }
[10:26:40.306]                     })
[10:26:40.306]                   }
[10:26:40.306]                   options(future.plan = NULL)
[10:26:40.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:26:40.306]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:26:40.306]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.306]                     envir = parent.frame()) 
[10:26:40.306]                   {
[10:26:40.306]                     if (is.function(workers)) 
[10:26:40.306]                       workers <- workers()
[10:26:40.306]                     workers <- structure(as.integer(workers), 
[10:26:40.306]                       class = class(workers))
[10:26:40.306]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.306]                       workers >= 1)
[10:26:40.306]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.306]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.306]                     }
[10:26:40.306]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.306]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.306]                       envir = envir)
[10:26:40.306]                     if (!future$lazy) 
[10:26:40.306]                       future <- run(future)
[10:26:40.306]                     invisible(future)
[10:26:40.306]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:40.306]                 }
[10:26:40.306]                 ...future.workdir <- getwd()
[10:26:40.306]             }
[10:26:40.306]             ...future.oldOptions <- base::as.list(base::.Options)
[10:26:40.306]             ...future.oldEnvVars <- base::Sys.getenv()
[10:26:40.306]         }
[10:26:40.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:26:40.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:26:40.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:26:40.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:26:40.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:26:40.306]             future.stdout.windows.reencode = NULL, width = 80L)
[10:26:40.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:26:40.306]             base::names(...future.oldOptions))
[10:26:40.306]     }
[10:26:40.306]     if (FALSE) {
[10:26:40.306]     }
[10:26:40.306]     else {
[10:26:40.306]         if (TRUE) {
[10:26:40.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:26:40.306]                 open = "w")
[10:26:40.306]         }
[10:26:40.306]         else {
[10:26:40.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:26:40.306]                 windows = "NUL", "/dev/null"), open = "w")
[10:26:40.306]         }
[10:26:40.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:26:40.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:26:40.306]             base::sink(type = "output", split = FALSE)
[10:26:40.306]             base::close(...future.stdout)
[10:26:40.306]         }, add = TRUE)
[10:26:40.306]     }
[10:26:40.306]     ...future.frame <- base::sys.nframe()
[10:26:40.306]     ...future.conditions <- base::list()
[10:26:40.306]     ...future.rng <- base::globalenv()$.Random.seed
[10:26:40.306]     if (FALSE) {
[10:26:40.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:26:40.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:26:40.306]     }
[10:26:40.306]     ...future.result <- base::tryCatch({
[10:26:40.306]         base::withCallingHandlers({
[10:26:40.306]             ...future.value <- base::withVisible(base::local({
[10:26:40.306]                 ...future.makeSendCondition <- base::local({
[10:26:40.306]                   sendCondition <- NULL
[10:26:40.306]                   function(frame = 1L) {
[10:26:40.306]                     if (is.function(sendCondition)) 
[10:26:40.306]                       return(sendCondition)
[10:26:40.306]                     ns <- getNamespace("parallel")
[10:26:40.306]                     if (exists("sendData", mode = "function", 
[10:26:40.306]                       envir = ns)) {
[10:26:40.306]                       parallel_sendData <- get("sendData", mode = "function", 
[10:26:40.306]                         envir = ns)
[10:26:40.306]                       envir <- sys.frame(frame)
[10:26:40.306]                       master <- NULL
[10:26:40.306]                       while (!identical(envir, .GlobalEnv) && 
[10:26:40.306]                         !identical(envir, emptyenv())) {
[10:26:40.306]                         if (exists("master", mode = "list", envir = envir, 
[10:26:40.306]                           inherits = FALSE)) {
[10:26:40.306]                           master <- get("master", mode = "list", 
[10:26:40.306]                             envir = envir, inherits = FALSE)
[10:26:40.306]                           if (inherits(master, c("SOCKnode", 
[10:26:40.306]                             "SOCK0node"))) {
[10:26:40.306]                             sendCondition <<- function(cond) {
[10:26:40.306]                               data <- list(type = "VALUE", value = cond, 
[10:26:40.306]                                 success = TRUE)
[10:26:40.306]                               parallel_sendData(master, data)
[10:26:40.306]                             }
[10:26:40.306]                             return(sendCondition)
[10:26:40.306]                           }
[10:26:40.306]                         }
[10:26:40.306]                         frame <- frame + 1L
[10:26:40.306]                         envir <- sys.frame(frame)
[10:26:40.306]                       }
[10:26:40.306]                     }
[10:26:40.306]                     sendCondition <<- function(cond) NULL
[10:26:40.306]                   }
[10:26:40.306]                 })
[10:26:40.306]                 withCallingHandlers({
[10:26:40.306]                   {
[10:26:40.306]                     value(future(subset(data, a == 2)))
[10:26:40.306]                   }
[10:26:40.306]                 }, immediateCondition = function(cond) {
[10:26:40.306]                   sendCondition <- ...future.makeSendCondition()
[10:26:40.306]                   sendCondition(cond)
[10:26:40.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.306]                   {
[10:26:40.306]                     inherits <- base::inherits
[10:26:40.306]                     invokeRestart <- base::invokeRestart
[10:26:40.306]                     is.null <- base::is.null
[10:26:40.306]                     muffled <- FALSE
[10:26:40.306]                     if (inherits(cond, "message")) {
[10:26:40.306]                       muffled <- grepl(pattern, "muffleMessage")
[10:26:40.306]                       if (muffled) 
[10:26:40.306]                         invokeRestart("muffleMessage")
[10:26:40.306]                     }
[10:26:40.306]                     else if (inherits(cond, "warning")) {
[10:26:40.306]                       muffled <- grepl(pattern, "muffleWarning")
[10:26:40.306]                       if (muffled) 
[10:26:40.306]                         invokeRestart("muffleWarning")
[10:26:40.306]                     }
[10:26:40.306]                     else if (inherits(cond, "condition")) {
[10:26:40.306]                       if (!is.null(pattern)) {
[10:26:40.306]                         computeRestarts <- base::computeRestarts
[10:26:40.306]                         grepl <- base::grepl
[10:26:40.306]                         restarts <- computeRestarts(cond)
[10:26:40.306]                         for (restart in restarts) {
[10:26:40.306]                           name <- restart$name
[10:26:40.306]                           if (is.null(name)) 
[10:26:40.306]                             next
[10:26:40.306]                           if (!grepl(pattern, name)) 
[10:26:40.306]                             next
[10:26:40.306]                           invokeRestart(restart)
[10:26:40.306]                           muffled <- TRUE
[10:26:40.306]                           break
[10:26:40.306]                         }
[10:26:40.306]                       }
[10:26:40.306]                     }
[10:26:40.306]                     invisible(muffled)
[10:26:40.306]                   }
[10:26:40.306]                   muffleCondition(cond)
[10:26:40.306]                 })
[10:26:40.306]             }))
[10:26:40.306]             future::FutureResult(value = ...future.value$value, 
[10:26:40.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:40.306]                   ...future.rng), globalenv = if (FALSE) 
[10:26:40.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:26:40.306]                     ...future.globalenv.names))
[10:26:40.306]                 else NULL, started = ...future.startTime, version = "1.8")
[10:26:40.306]         }, condition = base::local({
[10:26:40.306]             c <- base::c
[10:26:40.306]             inherits <- base::inherits
[10:26:40.306]             invokeRestart <- base::invokeRestart
[10:26:40.306]             length <- base::length
[10:26:40.306]             list <- base::list
[10:26:40.306]             seq.int <- base::seq.int
[10:26:40.306]             signalCondition <- base::signalCondition
[10:26:40.306]             sys.calls <- base::sys.calls
[10:26:40.306]             `[[` <- base::`[[`
[10:26:40.306]             `+` <- base::`+`
[10:26:40.306]             `<<-` <- base::`<<-`
[10:26:40.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:26:40.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:26:40.306]                   3L)]
[10:26:40.306]             }
[10:26:40.306]             function(cond) {
[10:26:40.306]                 is_error <- inherits(cond, "error")
[10:26:40.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:26:40.306]                   NULL)
[10:26:40.306]                 if (is_error) {
[10:26:40.306]                   sessionInformation <- function() {
[10:26:40.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:26:40.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:26:40.306]                       search = base::search(), system = base::Sys.info())
[10:26:40.306]                   }
[10:26:40.306]                   ...future.conditions[[length(...future.conditions) + 
[10:26:40.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:26:40.306]                     cond$call), session = sessionInformation(), 
[10:26:40.306]                     timestamp = base::Sys.time(), signaled = 0L)
[10:26:40.306]                   signalCondition(cond)
[10:26:40.306]                 }
[10:26:40.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:26:40.306]                 "immediateCondition"))) {
[10:26:40.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:26:40.306]                   ...future.conditions[[length(...future.conditions) + 
[10:26:40.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:26:40.306]                   if (TRUE && !signal) {
[10:26:40.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.306]                     {
[10:26:40.306]                       inherits <- base::inherits
[10:26:40.306]                       invokeRestart <- base::invokeRestart
[10:26:40.306]                       is.null <- base::is.null
[10:26:40.306]                       muffled <- FALSE
[10:26:40.306]                       if (inherits(cond, "message")) {
[10:26:40.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:40.306]                         if (muffled) 
[10:26:40.306]                           invokeRestart("muffleMessage")
[10:26:40.306]                       }
[10:26:40.306]                       else if (inherits(cond, "warning")) {
[10:26:40.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:40.306]                         if (muffled) 
[10:26:40.306]                           invokeRestart("muffleWarning")
[10:26:40.306]                       }
[10:26:40.306]                       else if (inherits(cond, "condition")) {
[10:26:40.306]                         if (!is.null(pattern)) {
[10:26:40.306]                           computeRestarts <- base::computeRestarts
[10:26:40.306]                           grepl <- base::grepl
[10:26:40.306]                           restarts <- computeRestarts(cond)
[10:26:40.306]                           for (restart in restarts) {
[10:26:40.306]                             name <- restart$name
[10:26:40.306]                             if (is.null(name)) 
[10:26:40.306]                               next
[10:26:40.306]                             if (!grepl(pattern, name)) 
[10:26:40.306]                               next
[10:26:40.306]                             invokeRestart(restart)
[10:26:40.306]                             muffled <- TRUE
[10:26:40.306]                             break
[10:26:40.306]                           }
[10:26:40.306]                         }
[10:26:40.306]                       }
[10:26:40.306]                       invisible(muffled)
[10:26:40.306]                     }
[10:26:40.306]                     muffleCondition(cond, pattern = "^muffle")
[10:26:40.306]                   }
[10:26:40.306]                 }
[10:26:40.306]                 else {
[10:26:40.306]                   if (TRUE) {
[10:26:40.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:26:40.306]                     {
[10:26:40.306]                       inherits <- base::inherits
[10:26:40.306]                       invokeRestart <- base::invokeRestart
[10:26:40.306]                       is.null <- base::is.null
[10:26:40.306]                       muffled <- FALSE
[10:26:40.306]                       if (inherits(cond, "message")) {
[10:26:40.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:26:40.306]                         if (muffled) 
[10:26:40.306]                           invokeRestart("muffleMessage")
[10:26:40.306]                       }
[10:26:40.306]                       else if (inherits(cond, "warning")) {
[10:26:40.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:26:40.306]                         if (muffled) 
[10:26:40.306]                           invokeRestart("muffleWarning")
[10:26:40.306]                       }
[10:26:40.306]                       else if (inherits(cond, "condition")) {
[10:26:40.306]                         if (!is.null(pattern)) {
[10:26:40.306]                           computeRestarts <- base::computeRestarts
[10:26:40.306]                           grepl <- base::grepl
[10:26:40.306]                           restarts <- computeRestarts(cond)
[10:26:40.306]                           for (restart in restarts) {
[10:26:40.306]                             name <- restart$name
[10:26:40.306]                             if (is.null(name)) 
[10:26:40.306]                               next
[10:26:40.306]                             if (!grepl(pattern, name)) 
[10:26:40.306]                               next
[10:26:40.306]                             invokeRestart(restart)
[10:26:40.306]                             muffled <- TRUE
[10:26:40.306]                             break
[10:26:40.306]                           }
[10:26:40.306]                         }
[10:26:40.306]                       }
[10:26:40.306]                       invisible(muffled)
[10:26:40.306]                     }
[10:26:40.306]                     muffleCondition(cond, pattern = "^muffle")
[10:26:40.306]                   }
[10:26:40.306]                 }
[10:26:40.306]             }
[10:26:40.306]         }))
[10:26:40.306]     }, error = function(ex) {
[10:26:40.306]         base::structure(base::list(value = NULL, visible = NULL, 
[10:26:40.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:26:40.306]                 ...future.rng), started = ...future.startTime, 
[10:26:40.306]             finished = Sys.time(), session_uuid = NA_character_, 
[10:26:40.306]             version = "1.8"), class = "FutureResult")
[10:26:40.306]     }, finally = {
[10:26:40.306]         if (!identical(...future.workdir, getwd())) 
[10:26:40.306]             setwd(...future.workdir)
[10:26:40.306]         {
[10:26:40.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:26:40.306]                 ...future.oldOptions$nwarnings <- NULL
[10:26:40.306]             }
[10:26:40.306]             base::options(...future.oldOptions)
[10:26:40.306]             if (.Platform$OS.type == "windows") {
[10:26:40.306]                 old_names <- names(...future.oldEnvVars)
[10:26:40.306]                 envs <- base::Sys.getenv()
[10:26:40.306]                 names <- names(envs)
[10:26:40.306]                 common <- intersect(names, old_names)
[10:26:40.306]                 added <- setdiff(names, old_names)
[10:26:40.306]                 removed <- setdiff(old_names, names)
[10:26:40.306]                 changed <- common[...future.oldEnvVars[common] != 
[10:26:40.306]                   envs[common]]
[10:26:40.306]                 NAMES <- toupper(changed)
[10:26:40.306]                 args <- list()
[10:26:40.306]                 for (kk in seq_along(NAMES)) {
[10:26:40.306]                   name <- changed[[kk]]
[10:26:40.306]                   NAME <- NAMES[[kk]]
[10:26:40.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.306]                     next
[10:26:40.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:40.306]                 }
[10:26:40.306]                 NAMES <- toupper(added)
[10:26:40.306]                 for (kk in seq_along(NAMES)) {
[10:26:40.306]                   name <- added[[kk]]
[10:26:40.306]                   NAME <- NAMES[[kk]]
[10:26:40.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.306]                     next
[10:26:40.306]                   args[[name]] <- ""
[10:26:40.306]                 }
[10:26:40.306]                 NAMES <- toupper(removed)
[10:26:40.306]                 for (kk in seq_along(NAMES)) {
[10:26:40.306]                   name <- removed[[kk]]
[10:26:40.306]                   NAME <- NAMES[[kk]]
[10:26:40.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:26:40.306]                     next
[10:26:40.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:26:40.306]                 }
[10:26:40.306]                 if (length(args) > 0) 
[10:26:40.306]                   base::do.call(base::Sys.setenv, args = args)
[10:26:40.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:26:40.306]             }
[10:26:40.306]             else {
[10:26:40.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:26:40.306]             }
[10:26:40.306]             {
[10:26:40.306]                 if (base::length(...future.futureOptionsAdded) > 
[10:26:40.306]                   0L) {
[10:26:40.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:26:40.306]                   base::names(opts) <- ...future.futureOptionsAdded
[10:26:40.306]                   base::options(opts)
[10:26:40.306]                 }
[10:26:40.306]                 {
[10:26:40.306]                   {
[10:26:40.306]                     base::options(mc.cores = ...future.mc.cores.old)
[10:26:40.306]                     NULL
[10:26:40.306]                   }
[10:26:40.306]                   options(future.plan = NULL)
[10:26:40.306]                   if (is.na(NA_character_)) 
[10:26:40.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:26:40.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:26:40.306]                   future::plan(list(a = function (..., workers = availableCores(), 
[10:26:40.306]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.306]                     envir = parent.frame()) 
[10:26:40.306]                   {
[10:26:40.306]                     if (is.function(workers)) 
[10:26:40.306]                       workers <- workers()
[10:26:40.306]                     workers <- structure(as.integer(workers), 
[10:26:40.306]                       class = class(workers))
[10:26:40.306]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.306]                       workers >= 1)
[10:26:40.306]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.306]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.306]                     }
[10:26:40.306]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.306]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.306]                       envir = envir)
[10:26:40.306]                     if (!future$lazy) 
[10:26:40.306]                       future <- run(future)
[10:26:40.306]                     invisible(future)
[10:26:40.306]                   }, b = function (..., workers = availableCores(), 
[10:26:40.306]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:26:40.306]                     envir = parent.frame()) 
[10:26:40.306]                   {
[10:26:40.306]                     if (is.function(workers)) 
[10:26:40.306]                       workers <- workers()
[10:26:40.306]                     workers <- structure(as.integer(workers), 
[10:26:40.306]                       class = class(workers))
[10:26:40.306]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:26:40.306]                       workers >= 1)
[10:26:40.306]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:26:40.306]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:26:40.306]                     }
[10:26:40.306]                     future <- MultisessionFuture(..., workers = workers, 
[10:26:40.306]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:26:40.306]                       envir = envir)
[10:26:40.306]                     if (!future$lazy) 
[10:26:40.306]                       future <- run(future)
[10:26:40.306]                     invisible(future)
[10:26:40.306]                   }), .cleanup = FALSE, .init = FALSE)
[10:26:40.306]                 }
[10:26:40.306]             }
[10:26:40.306]         }
[10:26:40.306]     })
[10:26:40.306]     if (TRUE) {
[10:26:40.306]         base::sink(type = "output", split = FALSE)
[10:26:40.306]         if (TRUE) {
[10:26:40.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:26:40.306]         }
[10:26:40.306]         else {
[10:26:40.306]             ...future.result["stdout"] <- base::list(NULL)
[10:26:40.306]         }
[10:26:40.306]         base::close(...future.stdout)
[10:26:40.306]         ...future.stdout <- NULL
[10:26:40.306]     }
[10:26:40.306]     ...future.result$conditions <- ...future.conditions
[10:26:40.306]     ...future.result$finished <- base::Sys.time()
[10:26:40.306]     ...future.result
[10:26:40.306] }
[10:26:40.309] Exporting 1 global objects (128 bytes) to cluster node #1 ...
[10:26:40.309] Exporting ‘data’ (128 bytes) to cluster node #1 ...
[10:26:40.309] Exporting ‘data’ (128 bytes) to cluster node #1 ... DONE
[10:26:40.309] Exporting 1 global objects (128 bytes) to cluster node #1 ... DONE
[10:26:40.310] MultisessionFuture started
[10:26:40.310] - Launch lazy future ... done
[10:26:40.310] run() for ‘MultisessionFuture’ ... done
[10:26:40.310] result() for ClusterFuture ...
[10:26:40.310] receiveMessageFromWorker() for ClusterFuture ...
[10:26:40.311] - Validating connection of MultisessionFuture
[10:26:40.379] - received message: FutureResult
[10:26:40.379] - Received FutureResult
[10:26:40.379] - Erased future from FutureRegistry
[10:26:40.379] result() for ClusterFuture ...
[10:26:40.379] - result already collected: FutureResult
[10:26:40.380] result() for ClusterFuture ... done
[10:26:40.380] receiveMessageFromWorker() for ClusterFuture ... done
[10:26:40.380] result() for ClusterFuture ... done
[10:26:40.380] result() for ClusterFuture ...
[10:26:40.380] - result already collected: FutureResult
[10:26:40.380] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[10:26:40.381] plan(): Setting new future strategy stack:
[10:26:40.381] List of future strategies:
[10:26:40.381] 1. FutureStrategy:
[10:26:40.381]    - args: function (..., envir = parent.frame())
[10:26:40.381]    - tweaked: FALSE
[10:26:40.381]    - call: future::plan(oplan)
[10:26:40.382] plan(): nbrOfWorkers() = 1
> 
