
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[16:05:53.324] plan(): Setting new future strategy stack:
[16:05:53.325] List of future strategies:
[16:05:53.325] 1. sequential:
[16:05:53.325]    - args: function (..., envir = parent.frame())
[16:05:53.325]    - tweaked: FALSE
[16:05:53.325]    - call: future::plan("sequential")
[16:05:53.338] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[16:05:53.518] plan(): Setting new future strategy stack:
[16:05:53.518] List of future strategies:
[16:05:53.518] 1. sequential:
[16:05:53.518]    - args: function (..., envir = parent.frame())
[16:05:53.518]    - tweaked: FALSE
[16:05:53.518]    - call: plan(strategy)
[16:05:53.529] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[16:05:53.530] resolve() on list ...
[16:05:53.530]  recursive: 0
[16:05:53.530]  length: 2
[16:05:53.530]  elements: ‘a’, ‘b’
[16:05:53.530]  length: 1 (resolved future 1)
[16:05:53.530]  length: 0 (resolved future 2)
[16:05:53.530] resolve() on list ... DONE
[16:05:53.531] getGlobalsAndPackages() ...
[16:05:53.531] Searching for globals...
[16:05:53.533] 
[16:05:53.533] Searching for globals ... DONE
[16:05:53.533] - globals: [0] <none>
[16:05:53.534] getGlobalsAndPackages() ... DONE
[16:05:53.534] run() for ‘Future’ ...
[16:05:53.534] - state: ‘created’
[16:05:53.535] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.535] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.535]   - Field: ‘label’
[16:05:53.535]   - Field: ‘local’
[16:05:53.535]   - Field: ‘owner’
[16:05:53.535]   - Field: ‘envir’
[16:05:53.536]   - Field: ‘packages’
[16:05:53.536]   - Field: ‘gc’
[16:05:53.536]   - Field: ‘conditions’
[16:05:53.536]   - Field: ‘expr’
[16:05:53.536]   - Field: ‘uuid’
[16:05:53.536]   - Field: ‘seed’
[16:05:53.536]   - Field: ‘version’
[16:05:53.536]   - Field: ‘result’
[16:05:53.536]   - Field: ‘asynchronous’
[16:05:53.536]   - Field: ‘calls’
[16:05:53.536]   - Field: ‘globals’
[16:05:53.536]   - Field: ‘stdout’
[16:05:53.537]   - Field: ‘earlySignal’
[16:05:53.537]   - Field: ‘lazy’
[16:05:53.537]   - Field: ‘state’
[16:05:53.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.537] - Launch lazy future ...
[16:05:53.538] Packages needed by the future expression (n = 0): <none>
[16:05:53.538] Packages needed by future strategies (n = 0): <none>
[16:05:53.539] {
[16:05:53.539]     {
[16:05:53.539]         {
[16:05:53.539]             ...future.startTime <- base::Sys.time()
[16:05:53.539]             {
[16:05:53.539]                 {
[16:05:53.539]                   {
[16:05:53.539]                     base::local({
[16:05:53.539]                       has_future <- base::requireNamespace("future", 
[16:05:53.539]                         quietly = TRUE)
[16:05:53.539]                       if (has_future) {
[16:05:53.539]                         ns <- base::getNamespace("future")
[16:05:53.539]                         version <- ns[[".package"]][["version"]]
[16:05:53.539]                         if (is.null(version)) 
[16:05:53.539]                           version <- utils::packageVersion("future")
[16:05:53.539]                       }
[16:05:53.539]                       else {
[16:05:53.539]                         version <- NULL
[16:05:53.539]                       }
[16:05:53.539]                       if (!has_future || version < "1.8.0") {
[16:05:53.539]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.539]                           "", base::R.version$version.string), 
[16:05:53.539]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.539]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.539]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.539]                             "release", "version")], collapse = " "), 
[16:05:53.539]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.539]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.539]                           info)
[16:05:53.539]                         info <- base::paste(info, collapse = "; ")
[16:05:53.539]                         if (!has_future) {
[16:05:53.539]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.539]                             info)
[16:05:53.539]                         }
[16:05:53.539]                         else {
[16:05:53.539]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.539]                             info, version)
[16:05:53.539]                         }
[16:05:53.539]                         base::stop(msg)
[16:05:53.539]                       }
[16:05:53.539]                     })
[16:05:53.539]                   }
[16:05:53.539]                   options(future.plan = NULL)
[16:05:53.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.539]                 }
[16:05:53.539]                 ...future.workdir <- getwd()
[16:05:53.539]             }
[16:05:53.539]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.539]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.539]         }
[16:05:53.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.539]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.539]             base::names(...future.oldOptions))
[16:05:53.539]     }
[16:05:53.539]     if (FALSE) {
[16:05:53.539]     }
[16:05:53.539]     else {
[16:05:53.539]         if (TRUE) {
[16:05:53.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.539]                 open = "w")
[16:05:53.539]         }
[16:05:53.539]         else {
[16:05:53.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.539]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.539]         }
[16:05:53.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.539]             base::sink(type = "output", split = FALSE)
[16:05:53.539]             base::close(...future.stdout)
[16:05:53.539]         }, add = TRUE)
[16:05:53.539]     }
[16:05:53.539]     ...future.frame <- base::sys.nframe()
[16:05:53.539]     ...future.conditions <- base::list()
[16:05:53.539]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.539]     if (FALSE) {
[16:05:53.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.539]     }
[16:05:53.539]     ...future.result <- base::tryCatch({
[16:05:53.539]         base::withCallingHandlers({
[16:05:53.539]             ...future.value <- base::withVisible(base::local(1))
[16:05:53.539]             future::FutureResult(value = ...future.value$value, 
[16:05:53.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.539]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.539]                     ...future.globalenv.names))
[16:05:53.539]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.539]         }, condition = base::local({
[16:05:53.539]             c <- base::c
[16:05:53.539]             inherits <- base::inherits
[16:05:53.539]             invokeRestart <- base::invokeRestart
[16:05:53.539]             length <- base::length
[16:05:53.539]             list <- base::list
[16:05:53.539]             seq.int <- base::seq.int
[16:05:53.539]             signalCondition <- base::signalCondition
[16:05:53.539]             sys.calls <- base::sys.calls
[16:05:53.539]             `[[` <- base::`[[`
[16:05:53.539]             `+` <- base::`+`
[16:05:53.539]             `<<-` <- base::`<<-`
[16:05:53.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.539]                   3L)]
[16:05:53.539]             }
[16:05:53.539]             function(cond) {
[16:05:53.539]                 is_error <- inherits(cond, "error")
[16:05:53.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.539]                   NULL)
[16:05:53.539]                 if (is_error) {
[16:05:53.539]                   sessionInformation <- function() {
[16:05:53.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.539]                       search = base::search(), system = base::Sys.info())
[16:05:53.539]                   }
[16:05:53.539]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.539]                     cond$call), session = sessionInformation(), 
[16:05:53.539]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.539]                   signalCondition(cond)
[16:05:53.539]                 }
[16:05:53.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.539]                 "immediateCondition"))) {
[16:05:53.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.539]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.539]                   if (TRUE && !signal) {
[16:05:53.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.539]                     {
[16:05:53.539]                       inherits <- base::inherits
[16:05:53.539]                       invokeRestart <- base::invokeRestart
[16:05:53.539]                       is.null <- base::is.null
[16:05:53.539]                       muffled <- FALSE
[16:05:53.539]                       if (inherits(cond, "message")) {
[16:05:53.539]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.539]                         if (muffled) 
[16:05:53.539]                           invokeRestart("muffleMessage")
[16:05:53.539]                       }
[16:05:53.539]                       else if (inherits(cond, "warning")) {
[16:05:53.539]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.539]                         if (muffled) 
[16:05:53.539]                           invokeRestart("muffleWarning")
[16:05:53.539]                       }
[16:05:53.539]                       else if (inherits(cond, "condition")) {
[16:05:53.539]                         if (!is.null(pattern)) {
[16:05:53.539]                           computeRestarts <- base::computeRestarts
[16:05:53.539]                           grepl <- base::grepl
[16:05:53.539]                           restarts <- computeRestarts(cond)
[16:05:53.539]                           for (restart in restarts) {
[16:05:53.539]                             name <- restart$name
[16:05:53.539]                             if (is.null(name)) 
[16:05:53.539]                               next
[16:05:53.539]                             if (!grepl(pattern, name)) 
[16:05:53.539]                               next
[16:05:53.539]                             invokeRestart(restart)
[16:05:53.539]                             muffled <- TRUE
[16:05:53.539]                             break
[16:05:53.539]                           }
[16:05:53.539]                         }
[16:05:53.539]                       }
[16:05:53.539]                       invisible(muffled)
[16:05:53.539]                     }
[16:05:53.539]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.539]                   }
[16:05:53.539]                 }
[16:05:53.539]                 else {
[16:05:53.539]                   if (TRUE) {
[16:05:53.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.539]                     {
[16:05:53.539]                       inherits <- base::inherits
[16:05:53.539]                       invokeRestart <- base::invokeRestart
[16:05:53.539]                       is.null <- base::is.null
[16:05:53.539]                       muffled <- FALSE
[16:05:53.539]                       if (inherits(cond, "message")) {
[16:05:53.539]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.539]                         if (muffled) 
[16:05:53.539]                           invokeRestart("muffleMessage")
[16:05:53.539]                       }
[16:05:53.539]                       else if (inherits(cond, "warning")) {
[16:05:53.539]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.539]                         if (muffled) 
[16:05:53.539]                           invokeRestart("muffleWarning")
[16:05:53.539]                       }
[16:05:53.539]                       else if (inherits(cond, "condition")) {
[16:05:53.539]                         if (!is.null(pattern)) {
[16:05:53.539]                           computeRestarts <- base::computeRestarts
[16:05:53.539]                           grepl <- base::grepl
[16:05:53.539]                           restarts <- computeRestarts(cond)
[16:05:53.539]                           for (restart in restarts) {
[16:05:53.539]                             name <- restart$name
[16:05:53.539]                             if (is.null(name)) 
[16:05:53.539]                               next
[16:05:53.539]                             if (!grepl(pattern, name)) 
[16:05:53.539]                               next
[16:05:53.539]                             invokeRestart(restart)
[16:05:53.539]                             muffled <- TRUE
[16:05:53.539]                             break
[16:05:53.539]                           }
[16:05:53.539]                         }
[16:05:53.539]                       }
[16:05:53.539]                       invisible(muffled)
[16:05:53.539]                     }
[16:05:53.539]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.539]                   }
[16:05:53.539]                 }
[16:05:53.539]             }
[16:05:53.539]         }))
[16:05:53.539]     }, error = function(ex) {
[16:05:53.539]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.539]                 ...future.rng), started = ...future.startTime, 
[16:05:53.539]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.539]             version = "1.8"), class = "FutureResult")
[16:05:53.539]     }, finally = {
[16:05:53.539]         if (!identical(...future.workdir, getwd())) 
[16:05:53.539]             setwd(...future.workdir)
[16:05:53.539]         {
[16:05:53.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.539]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.539]             }
[16:05:53.539]             base::options(...future.oldOptions)
[16:05:53.539]             if (.Platform$OS.type == "windows") {
[16:05:53.539]                 old_names <- names(...future.oldEnvVars)
[16:05:53.539]                 envs <- base::Sys.getenv()
[16:05:53.539]                 names <- names(envs)
[16:05:53.539]                 common <- intersect(names, old_names)
[16:05:53.539]                 added <- setdiff(names, old_names)
[16:05:53.539]                 removed <- setdiff(old_names, names)
[16:05:53.539]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.539]                   envs[common]]
[16:05:53.539]                 NAMES <- toupper(changed)
[16:05:53.539]                 args <- list()
[16:05:53.539]                 for (kk in seq_along(NAMES)) {
[16:05:53.539]                   name <- changed[[kk]]
[16:05:53.539]                   NAME <- NAMES[[kk]]
[16:05:53.539]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.539]                     next
[16:05:53.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.539]                 }
[16:05:53.539]                 NAMES <- toupper(added)
[16:05:53.539]                 for (kk in seq_along(NAMES)) {
[16:05:53.539]                   name <- added[[kk]]
[16:05:53.539]                   NAME <- NAMES[[kk]]
[16:05:53.539]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.539]                     next
[16:05:53.539]                   args[[name]] <- ""
[16:05:53.539]                 }
[16:05:53.539]                 NAMES <- toupper(removed)
[16:05:53.539]                 for (kk in seq_along(NAMES)) {
[16:05:53.539]                   name <- removed[[kk]]
[16:05:53.539]                   NAME <- NAMES[[kk]]
[16:05:53.539]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.539]                     next
[16:05:53.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.539]                 }
[16:05:53.539]                 if (length(args) > 0) 
[16:05:53.539]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.539]             }
[16:05:53.539]             else {
[16:05:53.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.539]             }
[16:05:53.539]             {
[16:05:53.539]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.539]                   0L) {
[16:05:53.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.539]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.539]                   base::options(opts)
[16:05:53.539]                 }
[16:05:53.539]                 {
[16:05:53.539]                   {
[16:05:53.539]                     NULL
[16:05:53.539]                     RNGkind("Mersenne-Twister")
[16:05:53.539]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.539]                       inherits = FALSE)
[16:05:53.539]                   }
[16:05:53.539]                   options(future.plan = NULL)
[16:05:53.539]                   if (is.na(NA_character_)) 
[16:05:53.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.539]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.539]                   {
[16:05:53.539]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.539]                     if (!future$lazy) 
[16:05:53.539]                       future <- run(future)
[16:05:53.539]                     invisible(future)
[16:05:53.539]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.539]                 }
[16:05:53.539]             }
[16:05:53.539]         }
[16:05:53.539]     })
[16:05:53.539]     if (TRUE) {
[16:05:53.539]         base::sink(type = "output", split = FALSE)
[16:05:53.539]         if (TRUE) {
[16:05:53.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.539]         }
[16:05:53.539]         else {
[16:05:53.539]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.539]         }
[16:05:53.539]         base::close(...future.stdout)
[16:05:53.539]         ...future.stdout <- NULL
[16:05:53.539]     }
[16:05:53.539]     ...future.result$conditions <- ...future.conditions
[16:05:53.539]     ...future.result$finished <- base::Sys.time()
[16:05:53.539]     ...future.result
[16:05:53.539] }
[16:05:53.540] plan(): Setting new future strategy stack:
[16:05:53.541] List of future strategies:
[16:05:53.541] 1. sequential:
[16:05:53.541]    - args: function (..., envir = parent.frame())
[16:05:53.541]    - tweaked: FALSE
[16:05:53.541]    - call: NULL
[16:05:53.541] plan(): nbrOfWorkers() = 1
[16:05:53.542] plan(): Setting new future strategy stack:
[16:05:53.542] List of future strategies:
[16:05:53.542] 1. sequential:
[16:05:53.542]    - args: function (..., envir = parent.frame())
[16:05:53.542]    - tweaked: FALSE
[16:05:53.542]    - call: plan(strategy)
[16:05:53.542] plan(): nbrOfWorkers() = 1
[16:05:53.543] SequentialFuture started (and completed)
[16:05:53.543] - Launch lazy future ... done
[16:05:53.543] run() for ‘SequentialFuture’ ... done
[16:05:53.543] getGlobalsAndPackages() ...
[16:05:53.543] Searching for globals...
[16:05:53.544] 
[16:05:53.544] Searching for globals ... DONE
[16:05:53.544] - globals: [0] <none>
[16:05:53.544] getGlobalsAndPackages() ... DONE
[16:05:53.544] run() for ‘Future’ ...
[16:05:53.544] - state: ‘created’
[16:05:53.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.545]   - Field: ‘label’
[16:05:53.545]   - Field: ‘local’
[16:05:53.545]   - Field: ‘owner’
[16:05:53.545]   - Field: ‘envir’
[16:05:53.545]   - Field: ‘packages’
[16:05:53.545]   - Field: ‘gc’
[16:05:53.545]   - Field: ‘conditions’
[16:05:53.545]   - Field: ‘expr’
[16:05:53.545]   - Field: ‘uuid’
[16:05:53.546]   - Field: ‘seed’
[16:05:53.546]   - Field: ‘version’
[16:05:53.546]   - Field: ‘result’
[16:05:53.546]   - Field: ‘asynchronous’
[16:05:53.546]   - Field: ‘calls’
[16:05:53.546]   - Field: ‘globals’
[16:05:53.546]   - Field: ‘stdout’
[16:05:53.546]   - Field: ‘earlySignal’
[16:05:53.546]   - Field: ‘lazy’
[16:05:53.546]   - Field: ‘state’
[16:05:53.546] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.546] - Launch lazy future ...
[16:05:53.547] Packages needed by the future expression (n = 0): <none>
[16:05:53.547] Packages needed by future strategies (n = 0): <none>
[16:05:53.547] {
[16:05:53.547]     {
[16:05:53.547]         {
[16:05:53.547]             ...future.startTime <- base::Sys.time()
[16:05:53.547]             {
[16:05:53.547]                 {
[16:05:53.547]                   {
[16:05:53.547]                     base::local({
[16:05:53.547]                       has_future <- base::requireNamespace("future", 
[16:05:53.547]                         quietly = TRUE)
[16:05:53.547]                       if (has_future) {
[16:05:53.547]                         ns <- base::getNamespace("future")
[16:05:53.547]                         version <- ns[[".package"]][["version"]]
[16:05:53.547]                         if (is.null(version)) 
[16:05:53.547]                           version <- utils::packageVersion("future")
[16:05:53.547]                       }
[16:05:53.547]                       else {
[16:05:53.547]                         version <- NULL
[16:05:53.547]                       }
[16:05:53.547]                       if (!has_future || version < "1.8.0") {
[16:05:53.547]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.547]                           "", base::R.version$version.string), 
[16:05:53.547]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.547]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.547]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.547]                             "release", "version")], collapse = " "), 
[16:05:53.547]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.547]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.547]                           info)
[16:05:53.547]                         info <- base::paste(info, collapse = "; ")
[16:05:53.547]                         if (!has_future) {
[16:05:53.547]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.547]                             info)
[16:05:53.547]                         }
[16:05:53.547]                         else {
[16:05:53.547]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.547]                             info, version)
[16:05:53.547]                         }
[16:05:53.547]                         base::stop(msg)
[16:05:53.547]                       }
[16:05:53.547]                     })
[16:05:53.547]                   }
[16:05:53.547]                   options(future.plan = NULL)
[16:05:53.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.547]                 }
[16:05:53.547]                 ...future.workdir <- getwd()
[16:05:53.547]             }
[16:05:53.547]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.547]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.547]         }
[16:05:53.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.547]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.547]             base::names(...future.oldOptions))
[16:05:53.547]     }
[16:05:53.547]     if (FALSE) {
[16:05:53.547]     }
[16:05:53.547]     else {
[16:05:53.547]         if (TRUE) {
[16:05:53.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.547]                 open = "w")
[16:05:53.547]         }
[16:05:53.547]         else {
[16:05:53.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.547]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.547]         }
[16:05:53.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.547]             base::sink(type = "output", split = FALSE)
[16:05:53.547]             base::close(...future.stdout)
[16:05:53.547]         }, add = TRUE)
[16:05:53.547]     }
[16:05:53.547]     ...future.frame <- base::sys.nframe()
[16:05:53.547]     ...future.conditions <- base::list()
[16:05:53.547]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.547]     if (FALSE) {
[16:05:53.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.547]     }
[16:05:53.547]     ...future.result <- base::tryCatch({
[16:05:53.547]         base::withCallingHandlers({
[16:05:53.547]             ...future.value <- base::withVisible(base::local(2))
[16:05:53.547]             future::FutureResult(value = ...future.value$value, 
[16:05:53.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.547]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.547]                     ...future.globalenv.names))
[16:05:53.547]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.547]         }, condition = base::local({
[16:05:53.547]             c <- base::c
[16:05:53.547]             inherits <- base::inherits
[16:05:53.547]             invokeRestart <- base::invokeRestart
[16:05:53.547]             length <- base::length
[16:05:53.547]             list <- base::list
[16:05:53.547]             seq.int <- base::seq.int
[16:05:53.547]             signalCondition <- base::signalCondition
[16:05:53.547]             sys.calls <- base::sys.calls
[16:05:53.547]             `[[` <- base::`[[`
[16:05:53.547]             `+` <- base::`+`
[16:05:53.547]             `<<-` <- base::`<<-`
[16:05:53.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.547]                   3L)]
[16:05:53.547]             }
[16:05:53.547]             function(cond) {
[16:05:53.547]                 is_error <- inherits(cond, "error")
[16:05:53.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.547]                   NULL)
[16:05:53.547]                 if (is_error) {
[16:05:53.547]                   sessionInformation <- function() {
[16:05:53.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.547]                       search = base::search(), system = base::Sys.info())
[16:05:53.547]                   }
[16:05:53.547]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.547]                     cond$call), session = sessionInformation(), 
[16:05:53.547]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.547]                   signalCondition(cond)
[16:05:53.547]                 }
[16:05:53.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.547]                 "immediateCondition"))) {
[16:05:53.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.547]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.547]                   if (TRUE && !signal) {
[16:05:53.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.547]                     {
[16:05:53.547]                       inherits <- base::inherits
[16:05:53.547]                       invokeRestart <- base::invokeRestart
[16:05:53.547]                       is.null <- base::is.null
[16:05:53.547]                       muffled <- FALSE
[16:05:53.547]                       if (inherits(cond, "message")) {
[16:05:53.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.547]                         if (muffled) 
[16:05:53.547]                           invokeRestart("muffleMessage")
[16:05:53.547]                       }
[16:05:53.547]                       else if (inherits(cond, "warning")) {
[16:05:53.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.547]                         if (muffled) 
[16:05:53.547]                           invokeRestart("muffleWarning")
[16:05:53.547]                       }
[16:05:53.547]                       else if (inherits(cond, "condition")) {
[16:05:53.547]                         if (!is.null(pattern)) {
[16:05:53.547]                           computeRestarts <- base::computeRestarts
[16:05:53.547]                           grepl <- base::grepl
[16:05:53.547]                           restarts <- computeRestarts(cond)
[16:05:53.547]                           for (restart in restarts) {
[16:05:53.547]                             name <- restart$name
[16:05:53.547]                             if (is.null(name)) 
[16:05:53.547]                               next
[16:05:53.547]                             if (!grepl(pattern, name)) 
[16:05:53.547]                               next
[16:05:53.547]                             invokeRestart(restart)
[16:05:53.547]                             muffled <- TRUE
[16:05:53.547]                             break
[16:05:53.547]                           }
[16:05:53.547]                         }
[16:05:53.547]                       }
[16:05:53.547]                       invisible(muffled)
[16:05:53.547]                     }
[16:05:53.547]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.547]                   }
[16:05:53.547]                 }
[16:05:53.547]                 else {
[16:05:53.547]                   if (TRUE) {
[16:05:53.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.547]                     {
[16:05:53.547]                       inherits <- base::inherits
[16:05:53.547]                       invokeRestart <- base::invokeRestart
[16:05:53.547]                       is.null <- base::is.null
[16:05:53.547]                       muffled <- FALSE
[16:05:53.547]                       if (inherits(cond, "message")) {
[16:05:53.547]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.547]                         if (muffled) 
[16:05:53.547]                           invokeRestart("muffleMessage")
[16:05:53.547]                       }
[16:05:53.547]                       else if (inherits(cond, "warning")) {
[16:05:53.547]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.547]                         if (muffled) 
[16:05:53.547]                           invokeRestart("muffleWarning")
[16:05:53.547]                       }
[16:05:53.547]                       else if (inherits(cond, "condition")) {
[16:05:53.547]                         if (!is.null(pattern)) {
[16:05:53.547]                           computeRestarts <- base::computeRestarts
[16:05:53.547]                           grepl <- base::grepl
[16:05:53.547]                           restarts <- computeRestarts(cond)
[16:05:53.547]                           for (restart in restarts) {
[16:05:53.547]                             name <- restart$name
[16:05:53.547]                             if (is.null(name)) 
[16:05:53.547]                               next
[16:05:53.547]                             if (!grepl(pattern, name)) 
[16:05:53.547]                               next
[16:05:53.547]                             invokeRestart(restart)
[16:05:53.547]                             muffled <- TRUE
[16:05:53.547]                             break
[16:05:53.547]                           }
[16:05:53.547]                         }
[16:05:53.547]                       }
[16:05:53.547]                       invisible(muffled)
[16:05:53.547]                     }
[16:05:53.547]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.547]                   }
[16:05:53.547]                 }
[16:05:53.547]             }
[16:05:53.547]         }))
[16:05:53.547]     }, error = function(ex) {
[16:05:53.547]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.547]                 ...future.rng), started = ...future.startTime, 
[16:05:53.547]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.547]             version = "1.8"), class = "FutureResult")
[16:05:53.547]     }, finally = {
[16:05:53.547]         if (!identical(...future.workdir, getwd())) 
[16:05:53.547]             setwd(...future.workdir)
[16:05:53.547]         {
[16:05:53.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.547]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.547]             }
[16:05:53.547]             base::options(...future.oldOptions)
[16:05:53.547]             if (.Platform$OS.type == "windows") {
[16:05:53.547]                 old_names <- names(...future.oldEnvVars)
[16:05:53.547]                 envs <- base::Sys.getenv()
[16:05:53.547]                 names <- names(envs)
[16:05:53.547]                 common <- intersect(names, old_names)
[16:05:53.547]                 added <- setdiff(names, old_names)
[16:05:53.547]                 removed <- setdiff(old_names, names)
[16:05:53.547]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.547]                   envs[common]]
[16:05:53.547]                 NAMES <- toupper(changed)
[16:05:53.547]                 args <- list()
[16:05:53.547]                 for (kk in seq_along(NAMES)) {
[16:05:53.547]                   name <- changed[[kk]]
[16:05:53.547]                   NAME <- NAMES[[kk]]
[16:05:53.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.547]                     next
[16:05:53.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.547]                 }
[16:05:53.547]                 NAMES <- toupper(added)
[16:05:53.547]                 for (kk in seq_along(NAMES)) {
[16:05:53.547]                   name <- added[[kk]]
[16:05:53.547]                   NAME <- NAMES[[kk]]
[16:05:53.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.547]                     next
[16:05:53.547]                   args[[name]] <- ""
[16:05:53.547]                 }
[16:05:53.547]                 NAMES <- toupper(removed)
[16:05:53.547]                 for (kk in seq_along(NAMES)) {
[16:05:53.547]                   name <- removed[[kk]]
[16:05:53.547]                   NAME <- NAMES[[kk]]
[16:05:53.547]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.547]                     next
[16:05:53.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.547]                 }
[16:05:53.547]                 if (length(args) > 0) 
[16:05:53.547]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.547]             }
[16:05:53.547]             else {
[16:05:53.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.547]             }
[16:05:53.547]             {
[16:05:53.547]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.547]                   0L) {
[16:05:53.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.547]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.547]                   base::options(opts)
[16:05:53.547]                 }
[16:05:53.547]                 {
[16:05:53.547]                   {
[16:05:53.547]                     NULL
[16:05:53.547]                     RNGkind("Mersenne-Twister")
[16:05:53.547]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.547]                       inherits = FALSE)
[16:05:53.547]                   }
[16:05:53.547]                   options(future.plan = NULL)
[16:05:53.547]                   if (is.na(NA_character_)) 
[16:05:53.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.547]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.547]                   {
[16:05:53.547]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.547]                     if (!future$lazy) 
[16:05:53.547]                       future <- run(future)
[16:05:53.547]                     invisible(future)
[16:05:53.547]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.547]                 }
[16:05:53.547]             }
[16:05:53.547]         }
[16:05:53.547]     })
[16:05:53.547]     if (TRUE) {
[16:05:53.547]         base::sink(type = "output", split = FALSE)
[16:05:53.547]         if (TRUE) {
[16:05:53.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.547]         }
[16:05:53.547]         else {
[16:05:53.547]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.547]         }
[16:05:53.547]         base::close(...future.stdout)
[16:05:53.547]         ...future.stdout <- NULL
[16:05:53.547]     }
[16:05:53.547]     ...future.result$conditions <- ...future.conditions
[16:05:53.547]     ...future.result$finished <- base::Sys.time()
[16:05:53.547]     ...future.result
[16:05:53.547] }
[16:05:53.549] plan(): Setting new future strategy stack:
[16:05:53.549] List of future strategies:
[16:05:53.549] 1. sequential:
[16:05:53.549]    - args: function (..., envir = parent.frame())
[16:05:53.549]    - tweaked: FALSE
[16:05:53.549]    - call: NULL
[16:05:53.549] plan(): nbrOfWorkers() = 1
[16:05:53.550] plan(): Setting new future strategy stack:
[16:05:53.550] List of future strategies:
[16:05:53.550] 1. sequential:
[16:05:53.550]    - args: function (..., envir = parent.frame())
[16:05:53.550]    - tweaked: FALSE
[16:05:53.550]    - call: plan(strategy)
[16:05:53.550] plan(): nbrOfWorkers() = 1
[16:05:53.550] SequentialFuture started (and completed)
[16:05:53.551] - Launch lazy future ... done
[16:05:53.551] run() for ‘SequentialFuture’ ... done
[16:05:53.551] resolve() on list ...
[16:05:53.551]  recursive: 0
[16:05:53.551]  length: 3
[16:05:53.551]  elements: ‘a’, ‘b’, ‘’
[16:05:53.551] resolved() for ‘SequentialFuture’ ...
[16:05:53.551] - state: ‘finished’
[16:05:53.551] - run: TRUE
[16:05:53.552] - result: ‘FutureResult’
[16:05:53.552] resolved() for ‘SequentialFuture’ ... done
[16:05:53.552] Future #1
[16:05:53.552]  length: 2 (resolved future 1)
[16:05:53.552] resolved() for ‘SequentialFuture’ ...
[16:05:53.552] - state: ‘finished’
[16:05:53.552] - run: TRUE
[16:05:53.552] - result: ‘FutureResult’
[16:05:53.552] resolved() for ‘SequentialFuture’ ... done
[16:05:53.553] Future #2
[16:05:53.553]  length: 1 (resolved future 2)
[16:05:53.553]  length: 0 (resolved future 3)
[16:05:53.553] resolve() on list ... DONE
[16:05:53.553] resolved() for ‘SequentialFuture’ ...
[16:05:53.553] - state: ‘finished’
[16:05:53.553] - run: TRUE
[16:05:53.553] - result: ‘FutureResult’
[16:05:53.553] resolved() for ‘SequentialFuture’ ... done
[16:05:53.553] resolved() for ‘SequentialFuture’ ...
[16:05:53.553] - state: ‘finished’
[16:05:53.554] - run: TRUE
[16:05:53.554] - result: ‘FutureResult’
[16:05:53.554] resolved() for ‘SequentialFuture’ ... done
[16:05:53.554] getGlobalsAndPackages() ...
[16:05:53.554] Searching for globals...
[16:05:53.555] 
[16:05:53.556] Searching for globals ... DONE
[16:05:53.556] - globals: [0] <none>
[16:05:53.556] getGlobalsAndPackages() ... DONE
[16:05:53.556] getGlobalsAndPackages() ...
[16:05:53.556] Searching for globals...
[16:05:53.556] 
[16:05:53.556] Searching for globals ... DONE
[16:05:53.556] - globals: [0] <none>
[16:05:53.557] getGlobalsAndPackages() ... DONE
[16:05:53.557] run() for ‘Future’ ...
[16:05:53.557] - state: ‘created’
[16:05:53.557] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.557] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.557]   - Field: ‘label’
[16:05:53.557]   - Field: ‘local’
[16:05:53.558]   - Field: ‘owner’
[16:05:53.558]   - Field: ‘envir’
[16:05:53.558]   - Field: ‘packages’
[16:05:53.558]   - Field: ‘gc’
[16:05:53.558]   - Field: ‘conditions’
[16:05:53.558]   - Field: ‘expr’
[16:05:53.558]   - Field: ‘uuid’
[16:05:53.558]   - Field: ‘seed’
[16:05:53.558]   - Field: ‘version’
[16:05:53.558]   - Field: ‘result’
[16:05:53.558]   - Field: ‘asynchronous’
[16:05:53.559]   - Field: ‘calls’
[16:05:53.559]   - Field: ‘globals’
[16:05:53.559]   - Field: ‘stdout’
[16:05:53.559]   - Field: ‘earlySignal’
[16:05:53.559]   - Field: ‘lazy’
[16:05:53.559]   - Field: ‘state’
[16:05:53.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.559] - Launch lazy future ...
[16:05:53.559] Packages needed by the future expression (n = 0): <none>
[16:05:53.559] Packages needed by future strategies (n = 0): <none>
[16:05:53.560] {
[16:05:53.560]     {
[16:05:53.560]         {
[16:05:53.560]             ...future.startTime <- base::Sys.time()
[16:05:53.560]             {
[16:05:53.560]                 {
[16:05:53.560]                   {
[16:05:53.560]                     base::local({
[16:05:53.560]                       has_future <- base::requireNamespace("future", 
[16:05:53.560]                         quietly = TRUE)
[16:05:53.560]                       if (has_future) {
[16:05:53.560]                         ns <- base::getNamespace("future")
[16:05:53.560]                         version <- ns[[".package"]][["version"]]
[16:05:53.560]                         if (is.null(version)) 
[16:05:53.560]                           version <- utils::packageVersion("future")
[16:05:53.560]                       }
[16:05:53.560]                       else {
[16:05:53.560]                         version <- NULL
[16:05:53.560]                       }
[16:05:53.560]                       if (!has_future || version < "1.8.0") {
[16:05:53.560]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.560]                           "", base::R.version$version.string), 
[16:05:53.560]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.560]                             "release", "version")], collapse = " "), 
[16:05:53.560]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.560]                           info)
[16:05:53.560]                         info <- base::paste(info, collapse = "; ")
[16:05:53.560]                         if (!has_future) {
[16:05:53.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.560]                             info)
[16:05:53.560]                         }
[16:05:53.560]                         else {
[16:05:53.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.560]                             info, version)
[16:05:53.560]                         }
[16:05:53.560]                         base::stop(msg)
[16:05:53.560]                       }
[16:05:53.560]                     })
[16:05:53.560]                   }
[16:05:53.560]                   options(future.plan = NULL)
[16:05:53.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.560]                 }
[16:05:53.560]                 ...future.workdir <- getwd()
[16:05:53.560]             }
[16:05:53.560]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.560]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.560]         }
[16:05:53.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.560]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.560]             base::names(...future.oldOptions))
[16:05:53.560]     }
[16:05:53.560]     if (FALSE) {
[16:05:53.560]     }
[16:05:53.560]     else {
[16:05:53.560]         if (TRUE) {
[16:05:53.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.560]                 open = "w")
[16:05:53.560]         }
[16:05:53.560]         else {
[16:05:53.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.560]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.560]         }
[16:05:53.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.560]             base::sink(type = "output", split = FALSE)
[16:05:53.560]             base::close(...future.stdout)
[16:05:53.560]         }, add = TRUE)
[16:05:53.560]     }
[16:05:53.560]     ...future.frame <- base::sys.nframe()
[16:05:53.560]     ...future.conditions <- base::list()
[16:05:53.560]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.560]     if (FALSE) {
[16:05:53.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.560]     }
[16:05:53.560]     ...future.result <- base::tryCatch({
[16:05:53.560]         base::withCallingHandlers({
[16:05:53.560]             ...future.value <- base::withVisible(base::local(2))
[16:05:53.560]             future::FutureResult(value = ...future.value$value, 
[16:05:53.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.560]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.560]                     ...future.globalenv.names))
[16:05:53.560]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.560]         }, condition = base::local({
[16:05:53.560]             c <- base::c
[16:05:53.560]             inherits <- base::inherits
[16:05:53.560]             invokeRestart <- base::invokeRestart
[16:05:53.560]             length <- base::length
[16:05:53.560]             list <- base::list
[16:05:53.560]             seq.int <- base::seq.int
[16:05:53.560]             signalCondition <- base::signalCondition
[16:05:53.560]             sys.calls <- base::sys.calls
[16:05:53.560]             `[[` <- base::`[[`
[16:05:53.560]             `+` <- base::`+`
[16:05:53.560]             `<<-` <- base::`<<-`
[16:05:53.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.560]                   3L)]
[16:05:53.560]             }
[16:05:53.560]             function(cond) {
[16:05:53.560]                 is_error <- inherits(cond, "error")
[16:05:53.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.560]                   NULL)
[16:05:53.560]                 if (is_error) {
[16:05:53.560]                   sessionInformation <- function() {
[16:05:53.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.560]                       search = base::search(), system = base::Sys.info())
[16:05:53.560]                   }
[16:05:53.560]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.560]                     cond$call), session = sessionInformation(), 
[16:05:53.560]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.560]                   signalCondition(cond)
[16:05:53.560]                 }
[16:05:53.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.560]                 "immediateCondition"))) {
[16:05:53.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.560]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.560]                   if (TRUE && !signal) {
[16:05:53.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.560]                     {
[16:05:53.560]                       inherits <- base::inherits
[16:05:53.560]                       invokeRestart <- base::invokeRestart
[16:05:53.560]                       is.null <- base::is.null
[16:05:53.560]                       muffled <- FALSE
[16:05:53.560]                       if (inherits(cond, "message")) {
[16:05:53.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.560]                         if (muffled) 
[16:05:53.560]                           invokeRestart("muffleMessage")
[16:05:53.560]                       }
[16:05:53.560]                       else if (inherits(cond, "warning")) {
[16:05:53.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.560]                         if (muffled) 
[16:05:53.560]                           invokeRestart("muffleWarning")
[16:05:53.560]                       }
[16:05:53.560]                       else if (inherits(cond, "condition")) {
[16:05:53.560]                         if (!is.null(pattern)) {
[16:05:53.560]                           computeRestarts <- base::computeRestarts
[16:05:53.560]                           grepl <- base::grepl
[16:05:53.560]                           restarts <- computeRestarts(cond)
[16:05:53.560]                           for (restart in restarts) {
[16:05:53.560]                             name <- restart$name
[16:05:53.560]                             if (is.null(name)) 
[16:05:53.560]                               next
[16:05:53.560]                             if (!grepl(pattern, name)) 
[16:05:53.560]                               next
[16:05:53.560]                             invokeRestart(restart)
[16:05:53.560]                             muffled <- TRUE
[16:05:53.560]                             break
[16:05:53.560]                           }
[16:05:53.560]                         }
[16:05:53.560]                       }
[16:05:53.560]                       invisible(muffled)
[16:05:53.560]                     }
[16:05:53.560]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.560]                   }
[16:05:53.560]                 }
[16:05:53.560]                 else {
[16:05:53.560]                   if (TRUE) {
[16:05:53.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.560]                     {
[16:05:53.560]                       inherits <- base::inherits
[16:05:53.560]                       invokeRestart <- base::invokeRestart
[16:05:53.560]                       is.null <- base::is.null
[16:05:53.560]                       muffled <- FALSE
[16:05:53.560]                       if (inherits(cond, "message")) {
[16:05:53.560]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.560]                         if (muffled) 
[16:05:53.560]                           invokeRestart("muffleMessage")
[16:05:53.560]                       }
[16:05:53.560]                       else if (inherits(cond, "warning")) {
[16:05:53.560]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.560]                         if (muffled) 
[16:05:53.560]                           invokeRestart("muffleWarning")
[16:05:53.560]                       }
[16:05:53.560]                       else if (inherits(cond, "condition")) {
[16:05:53.560]                         if (!is.null(pattern)) {
[16:05:53.560]                           computeRestarts <- base::computeRestarts
[16:05:53.560]                           grepl <- base::grepl
[16:05:53.560]                           restarts <- computeRestarts(cond)
[16:05:53.560]                           for (restart in restarts) {
[16:05:53.560]                             name <- restart$name
[16:05:53.560]                             if (is.null(name)) 
[16:05:53.560]                               next
[16:05:53.560]                             if (!grepl(pattern, name)) 
[16:05:53.560]                               next
[16:05:53.560]                             invokeRestart(restart)
[16:05:53.560]                             muffled <- TRUE
[16:05:53.560]                             break
[16:05:53.560]                           }
[16:05:53.560]                         }
[16:05:53.560]                       }
[16:05:53.560]                       invisible(muffled)
[16:05:53.560]                     }
[16:05:53.560]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.560]                   }
[16:05:53.560]                 }
[16:05:53.560]             }
[16:05:53.560]         }))
[16:05:53.560]     }, error = function(ex) {
[16:05:53.560]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.560]                 ...future.rng), started = ...future.startTime, 
[16:05:53.560]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.560]             version = "1.8"), class = "FutureResult")
[16:05:53.560]     }, finally = {
[16:05:53.560]         if (!identical(...future.workdir, getwd())) 
[16:05:53.560]             setwd(...future.workdir)
[16:05:53.560]         {
[16:05:53.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.560]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.560]             }
[16:05:53.560]             base::options(...future.oldOptions)
[16:05:53.560]             if (.Platform$OS.type == "windows") {
[16:05:53.560]                 old_names <- names(...future.oldEnvVars)
[16:05:53.560]                 envs <- base::Sys.getenv()
[16:05:53.560]                 names <- names(envs)
[16:05:53.560]                 common <- intersect(names, old_names)
[16:05:53.560]                 added <- setdiff(names, old_names)
[16:05:53.560]                 removed <- setdiff(old_names, names)
[16:05:53.560]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.560]                   envs[common]]
[16:05:53.560]                 NAMES <- toupper(changed)
[16:05:53.560]                 args <- list()
[16:05:53.560]                 for (kk in seq_along(NAMES)) {
[16:05:53.560]                   name <- changed[[kk]]
[16:05:53.560]                   NAME <- NAMES[[kk]]
[16:05:53.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.560]                     next
[16:05:53.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.560]                 }
[16:05:53.560]                 NAMES <- toupper(added)
[16:05:53.560]                 for (kk in seq_along(NAMES)) {
[16:05:53.560]                   name <- added[[kk]]
[16:05:53.560]                   NAME <- NAMES[[kk]]
[16:05:53.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.560]                     next
[16:05:53.560]                   args[[name]] <- ""
[16:05:53.560]                 }
[16:05:53.560]                 NAMES <- toupper(removed)
[16:05:53.560]                 for (kk in seq_along(NAMES)) {
[16:05:53.560]                   name <- removed[[kk]]
[16:05:53.560]                   NAME <- NAMES[[kk]]
[16:05:53.560]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.560]                     next
[16:05:53.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.560]                 }
[16:05:53.560]                 if (length(args) > 0) 
[16:05:53.560]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.560]             }
[16:05:53.560]             else {
[16:05:53.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.560]             }
[16:05:53.560]             {
[16:05:53.560]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.560]                   0L) {
[16:05:53.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.560]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.560]                   base::options(opts)
[16:05:53.560]                 }
[16:05:53.560]                 {
[16:05:53.560]                   {
[16:05:53.560]                     NULL
[16:05:53.560]                     RNGkind("Mersenne-Twister")
[16:05:53.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.560]                       inherits = FALSE)
[16:05:53.560]                   }
[16:05:53.560]                   options(future.plan = NULL)
[16:05:53.560]                   if (is.na(NA_character_)) 
[16:05:53.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.560]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.560]                   {
[16:05:53.560]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.560]                     if (!future$lazy) 
[16:05:53.560]                       future <- run(future)
[16:05:53.560]                     invisible(future)
[16:05:53.560]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.560]                 }
[16:05:53.560]             }
[16:05:53.560]         }
[16:05:53.560]     })
[16:05:53.560]     if (TRUE) {
[16:05:53.560]         base::sink(type = "output", split = FALSE)
[16:05:53.560]         if (TRUE) {
[16:05:53.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.560]         }
[16:05:53.560]         else {
[16:05:53.560]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.560]         }
[16:05:53.560]         base::close(...future.stdout)
[16:05:53.560]         ...future.stdout <- NULL
[16:05:53.560]     }
[16:05:53.560]     ...future.result$conditions <- ...future.conditions
[16:05:53.560]     ...future.result$finished <- base::Sys.time()
[16:05:53.560]     ...future.result
[16:05:53.560] }
[16:05:53.561] plan(): Setting new future strategy stack:
[16:05:53.562] List of future strategies:
[16:05:53.562] 1. sequential:
[16:05:53.562]    - args: function (..., envir = parent.frame())
[16:05:53.562]    - tweaked: FALSE
[16:05:53.562]    - call: NULL
[16:05:53.562] plan(): nbrOfWorkers() = 1
[16:05:53.562] plan(): Setting new future strategy stack:
[16:05:53.563] List of future strategies:
[16:05:53.563] 1. sequential:
[16:05:53.563]    - args: function (..., envir = parent.frame())
[16:05:53.563]    - tweaked: FALSE
[16:05:53.563]    - call: plan(strategy)
[16:05:53.563] plan(): nbrOfWorkers() = 1
[16:05:53.563] SequentialFuture started (and completed)
[16:05:53.563] - Launch lazy future ... done
[16:05:53.563] run() for ‘SequentialFuture’ ... done
[16:05:53.563] resolve() on list ...
[16:05:53.563]  recursive: 0
[16:05:53.564]  length: 3
[16:05:53.564]  elements: ‘a’, ‘b’, ‘’
[16:05:53.564] run() for ‘Future’ ...
[16:05:53.564] - state: ‘created’
[16:05:53.564] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.564] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.564]   - Field: ‘label’
[16:05:53.564]   - Field: ‘local’
[16:05:53.565]   - Field: ‘owner’
[16:05:53.565]   - Field: ‘envir’
[16:05:53.565]   - Field: ‘packages’
[16:05:53.565]   - Field: ‘gc’
[16:05:53.565]   - Field: ‘conditions’
[16:05:53.565]   - Field: ‘expr’
[16:05:53.565]   - Field: ‘uuid’
[16:05:53.565]   - Field: ‘seed’
[16:05:53.565]   - Field: ‘version’
[16:05:53.565]   - Field: ‘result’
[16:05:53.565]   - Field: ‘asynchronous’
[16:05:53.566]   - Field: ‘calls’
[16:05:53.566]   - Field: ‘globals’
[16:05:53.566]   - Field: ‘stdout’
[16:05:53.566]   - Field: ‘earlySignal’
[16:05:53.566]   - Field: ‘lazy’
[16:05:53.566]   - Field: ‘state’
[16:05:53.566] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.566] - Launch lazy future ...
[16:05:53.566] Packages needed by the future expression (n = 0): <none>
[16:05:53.566] Packages needed by future strategies (n = 0): <none>
[16:05:53.567] {
[16:05:53.567]     {
[16:05:53.567]         {
[16:05:53.567]             ...future.startTime <- base::Sys.time()
[16:05:53.567]             {
[16:05:53.567]                 {
[16:05:53.567]                   {
[16:05:53.567]                     base::local({
[16:05:53.567]                       has_future <- base::requireNamespace("future", 
[16:05:53.567]                         quietly = TRUE)
[16:05:53.567]                       if (has_future) {
[16:05:53.567]                         ns <- base::getNamespace("future")
[16:05:53.567]                         version <- ns[[".package"]][["version"]]
[16:05:53.567]                         if (is.null(version)) 
[16:05:53.567]                           version <- utils::packageVersion("future")
[16:05:53.567]                       }
[16:05:53.567]                       else {
[16:05:53.567]                         version <- NULL
[16:05:53.567]                       }
[16:05:53.567]                       if (!has_future || version < "1.8.0") {
[16:05:53.567]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.567]                           "", base::R.version$version.string), 
[16:05:53.567]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.567]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.567]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.567]                             "release", "version")], collapse = " "), 
[16:05:53.567]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.567]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.567]                           info)
[16:05:53.567]                         info <- base::paste(info, collapse = "; ")
[16:05:53.567]                         if (!has_future) {
[16:05:53.567]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.567]                             info)
[16:05:53.567]                         }
[16:05:53.567]                         else {
[16:05:53.567]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.567]                             info, version)
[16:05:53.567]                         }
[16:05:53.567]                         base::stop(msg)
[16:05:53.567]                       }
[16:05:53.567]                     })
[16:05:53.567]                   }
[16:05:53.567]                   options(future.plan = NULL)
[16:05:53.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.567]                 }
[16:05:53.567]                 ...future.workdir <- getwd()
[16:05:53.567]             }
[16:05:53.567]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.567]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.567]         }
[16:05:53.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.567]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.567]             base::names(...future.oldOptions))
[16:05:53.567]     }
[16:05:53.567]     if (FALSE) {
[16:05:53.567]     }
[16:05:53.567]     else {
[16:05:53.567]         if (TRUE) {
[16:05:53.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.567]                 open = "w")
[16:05:53.567]         }
[16:05:53.567]         else {
[16:05:53.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.567]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.567]         }
[16:05:53.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.567]             base::sink(type = "output", split = FALSE)
[16:05:53.567]             base::close(...future.stdout)
[16:05:53.567]         }, add = TRUE)
[16:05:53.567]     }
[16:05:53.567]     ...future.frame <- base::sys.nframe()
[16:05:53.567]     ...future.conditions <- base::list()
[16:05:53.567]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.567]     if (FALSE) {
[16:05:53.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.567]     }
[16:05:53.567]     ...future.result <- base::tryCatch({
[16:05:53.567]         base::withCallingHandlers({
[16:05:53.567]             ...future.value <- base::withVisible(base::local(1))
[16:05:53.567]             future::FutureResult(value = ...future.value$value, 
[16:05:53.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.567]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.567]                     ...future.globalenv.names))
[16:05:53.567]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.567]         }, condition = base::local({
[16:05:53.567]             c <- base::c
[16:05:53.567]             inherits <- base::inherits
[16:05:53.567]             invokeRestart <- base::invokeRestart
[16:05:53.567]             length <- base::length
[16:05:53.567]             list <- base::list
[16:05:53.567]             seq.int <- base::seq.int
[16:05:53.567]             signalCondition <- base::signalCondition
[16:05:53.567]             sys.calls <- base::sys.calls
[16:05:53.567]             `[[` <- base::`[[`
[16:05:53.567]             `+` <- base::`+`
[16:05:53.567]             `<<-` <- base::`<<-`
[16:05:53.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.567]                   3L)]
[16:05:53.567]             }
[16:05:53.567]             function(cond) {
[16:05:53.567]                 is_error <- inherits(cond, "error")
[16:05:53.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.567]                   NULL)
[16:05:53.567]                 if (is_error) {
[16:05:53.567]                   sessionInformation <- function() {
[16:05:53.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.567]                       search = base::search(), system = base::Sys.info())
[16:05:53.567]                   }
[16:05:53.567]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.567]                     cond$call), session = sessionInformation(), 
[16:05:53.567]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.567]                   signalCondition(cond)
[16:05:53.567]                 }
[16:05:53.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.567]                 "immediateCondition"))) {
[16:05:53.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.567]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.567]                   if (TRUE && !signal) {
[16:05:53.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.567]                     {
[16:05:53.567]                       inherits <- base::inherits
[16:05:53.567]                       invokeRestart <- base::invokeRestart
[16:05:53.567]                       is.null <- base::is.null
[16:05:53.567]                       muffled <- FALSE
[16:05:53.567]                       if (inherits(cond, "message")) {
[16:05:53.567]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.567]                         if (muffled) 
[16:05:53.567]                           invokeRestart("muffleMessage")
[16:05:53.567]                       }
[16:05:53.567]                       else if (inherits(cond, "warning")) {
[16:05:53.567]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.567]                         if (muffled) 
[16:05:53.567]                           invokeRestart("muffleWarning")
[16:05:53.567]                       }
[16:05:53.567]                       else if (inherits(cond, "condition")) {
[16:05:53.567]                         if (!is.null(pattern)) {
[16:05:53.567]                           computeRestarts <- base::computeRestarts
[16:05:53.567]                           grepl <- base::grepl
[16:05:53.567]                           restarts <- computeRestarts(cond)
[16:05:53.567]                           for (restart in restarts) {
[16:05:53.567]                             name <- restart$name
[16:05:53.567]                             if (is.null(name)) 
[16:05:53.567]                               next
[16:05:53.567]                             if (!grepl(pattern, name)) 
[16:05:53.567]                               next
[16:05:53.567]                             invokeRestart(restart)
[16:05:53.567]                             muffled <- TRUE
[16:05:53.567]                             break
[16:05:53.567]                           }
[16:05:53.567]                         }
[16:05:53.567]                       }
[16:05:53.567]                       invisible(muffled)
[16:05:53.567]                     }
[16:05:53.567]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.567]                   }
[16:05:53.567]                 }
[16:05:53.567]                 else {
[16:05:53.567]                   if (TRUE) {
[16:05:53.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.567]                     {
[16:05:53.567]                       inherits <- base::inherits
[16:05:53.567]                       invokeRestart <- base::invokeRestart
[16:05:53.567]                       is.null <- base::is.null
[16:05:53.567]                       muffled <- FALSE
[16:05:53.567]                       if (inherits(cond, "message")) {
[16:05:53.567]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.567]                         if (muffled) 
[16:05:53.567]                           invokeRestart("muffleMessage")
[16:05:53.567]                       }
[16:05:53.567]                       else if (inherits(cond, "warning")) {
[16:05:53.567]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.567]                         if (muffled) 
[16:05:53.567]                           invokeRestart("muffleWarning")
[16:05:53.567]                       }
[16:05:53.567]                       else if (inherits(cond, "condition")) {
[16:05:53.567]                         if (!is.null(pattern)) {
[16:05:53.567]                           computeRestarts <- base::computeRestarts
[16:05:53.567]                           grepl <- base::grepl
[16:05:53.567]                           restarts <- computeRestarts(cond)
[16:05:53.567]                           for (restart in restarts) {
[16:05:53.567]                             name <- restart$name
[16:05:53.567]                             if (is.null(name)) 
[16:05:53.567]                               next
[16:05:53.567]                             if (!grepl(pattern, name)) 
[16:05:53.567]                               next
[16:05:53.567]                             invokeRestart(restart)
[16:05:53.567]                             muffled <- TRUE
[16:05:53.567]                             break
[16:05:53.567]                           }
[16:05:53.567]                         }
[16:05:53.567]                       }
[16:05:53.567]                       invisible(muffled)
[16:05:53.567]                     }
[16:05:53.567]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.567]                   }
[16:05:53.567]                 }
[16:05:53.567]             }
[16:05:53.567]         }))
[16:05:53.567]     }, error = function(ex) {
[16:05:53.567]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.567]                 ...future.rng), started = ...future.startTime, 
[16:05:53.567]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.567]             version = "1.8"), class = "FutureResult")
[16:05:53.567]     }, finally = {
[16:05:53.567]         if (!identical(...future.workdir, getwd())) 
[16:05:53.567]             setwd(...future.workdir)
[16:05:53.567]         {
[16:05:53.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.567]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.567]             }
[16:05:53.567]             base::options(...future.oldOptions)
[16:05:53.567]             if (.Platform$OS.type == "windows") {
[16:05:53.567]                 old_names <- names(...future.oldEnvVars)
[16:05:53.567]                 envs <- base::Sys.getenv()
[16:05:53.567]                 names <- names(envs)
[16:05:53.567]                 common <- intersect(names, old_names)
[16:05:53.567]                 added <- setdiff(names, old_names)
[16:05:53.567]                 removed <- setdiff(old_names, names)
[16:05:53.567]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.567]                   envs[common]]
[16:05:53.567]                 NAMES <- toupper(changed)
[16:05:53.567]                 args <- list()
[16:05:53.567]                 for (kk in seq_along(NAMES)) {
[16:05:53.567]                   name <- changed[[kk]]
[16:05:53.567]                   NAME <- NAMES[[kk]]
[16:05:53.567]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.567]                     next
[16:05:53.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.567]                 }
[16:05:53.567]                 NAMES <- toupper(added)
[16:05:53.567]                 for (kk in seq_along(NAMES)) {
[16:05:53.567]                   name <- added[[kk]]
[16:05:53.567]                   NAME <- NAMES[[kk]]
[16:05:53.567]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.567]                     next
[16:05:53.567]                   args[[name]] <- ""
[16:05:53.567]                 }
[16:05:53.567]                 NAMES <- toupper(removed)
[16:05:53.567]                 for (kk in seq_along(NAMES)) {
[16:05:53.567]                   name <- removed[[kk]]
[16:05:53.567]                   NAME <- NAMES[[kk]]
[16:05:53.567]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.567]                     next
[16:05:53.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.567]                 }
[16:05:53.567]                 if (length(args) > 0) 
[16:05:53.567]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.567]             }
[16:05:53.567]             else {
[16:05:53.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.567]             }
[16:05:53.567]             {
[16:05:53.567]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.567]                   0L) {
[16:05:53.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.567]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.567]                   base::options(opts)
[16:05:53.567]                 }
[16:05:53.567]                 {
[16:05:53.567]                   {
[16:05:53.567]                     NULL
[16:05:53.567]                     RNGkind("Mersenne-Twister")
[16:05:53.567]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.567]                       inherits = FALSE)
[16:05:53.567]                   }
[16:05:53.567]                   options(future.plan = NULL)
[16:05:53.567]                   if (is.na(NA_character_)) 
[16:05:53.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.567]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.567]                   {
[16:05:53.567]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.567]                     if (!future$lazy) 
[16:05:53.567]                       future <- run(future)
[16:05:53.567]                     invisible(future)
[16:05:53.567]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.567]                 }
[16:05:53.567]             }
[16:05:53.567]         }
[16:05:53.567]     })
[16:05:53.567]     if (TRUE) {
[16:05:53.567]         base::sink(type = "output", split = FALSE)
[16:05:53.567]         if (TRUE) {
[16:05:53.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.567]         }
[16:05:53.567]         else {
[16:05:53.567]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.567]         }
[16:05:53.567]         base::close(...future.stdout)
[16:05:53.567]         ...future.stdout <- NULL
[16:05:53.567]     }
[16:05:53.567]     ...future.result$conditions <- ...future.conditions
[16:05:53.567]     ...future.result$finished <- base::Sys.time()
[16:05:53.567]     ...future.result
[16:05:53.567] }
[16:05:53.568] plan(): Setting new future strategy stack:
[16:05:53.569] List of future strategies:
[16:05:53.569] 1. sequential:
[16:05:53.569]    - args: function (..., envir = parent.frame())
[16:05:53.569]    - tweaked: FALSE
[16:05:53.569]    - call: NULL
[16:05:53.569] plan(): nbrOfWorkers() = 1
[16:05:53.570] plan(): Setting new future strategy stack:
[16:05:53.570] List of future strategies:
[16:05:53.570] 1. sequential:
[16:05:53.570]    - args: function (..., envir = parent.frame())
[16:05:53.570]    - tweaked: FALSE
[16:05:53.570]    - call: plan(strategy)
[16:05:53.570] plan(): nbrOfWorkers() = 1
[16:05:53.570] SequentialFuture started (and completed)
[16:05:53.570] - Launch lazy future ... done
[16:05:53.570] run() for ‘SequentialFuture’ ... done
[16:05:53.570] resolved() for ‘SequentialFuture’ ...
[16:05:53.570] - state: ‘finished’
[16:05:53.571] - run: TRUE
[16:05:53.571] - result: ‘FutureResult’
[16:05:53.571] resolved() for ‘SequentialFuture’ ... done
[16:05:53.571] Future #1
[16:05:53.571]  length: 2 (resolved future 1)
[16:05:53.571] resolved() for ‘SequentialFuture’ ...
[16:05:53.571] - state: ‘finished’
[16:05:53.571] - run: TRUE
[16:05:53.571] - result: ‘FutureResult’
[16:05:53.571] resolved() for ‘SequentialFuture’ ... done
[16:05:53.572] Future #2
[16:05:53.572]  length: 1 (resolved future 2)
[16:05:53.572]  length: 0 (resolved future 3)
[16:05:53.572] resolve() on list ... DONE
[16:05:53.572] resolved() for ‘SequentialFuture’ ...
[16:05:53.572] - state: ‘finished’
[16:05:53.572] - run: TRUE
[16:05:53.572] - result: ‘FutureResult’
[16:05:53.572] resolved() for ‘SequentialFuture’ ... done
[16:05:53.572] resolved() for ‘SequentialFuture’ ...
[16:05:53.572] - state: ‘finished’
[16:05:53.572] - run: TRUE
[16:05:53.573] - result: ‘FutureResult’
[16:05:53.573] resolved() for ‘SequentialFuture’ ... done
[16:05:53.573] getGlobalsAndPackages() ...
[16:05:53.573] Searching for globals...
[16:05:53.573] 
[16:05:53.573] Searching for globals ... DONE
[16:05:53.573] - globals: [0] <none>
[16:05:53.573] getGlobalsAndPackages() ... DONE
[16:05:53.574] getGlobalsAndPackages() ...
[16:05:53.574] Searching for globals...
[16:05:53.574] 
[16:05:53.574] Searching for globals ... DONE
[16:05:53.574] - globals: [0] <none>
[16:05:53.574] getGlobalsAndPackages() ... DONE
[16:05:53.574] resolve() on list ...
[16:05:53.574]  recursive: 0
[16:05:53.575]  length: 3
[16:05:53.575]  elements: ‘a’, ‘b’, ‘’
[16:05:53.575] run() for ‘Future’ ...
[16:05:53.575] - state: ‘created’
[16:05:53.575] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.575]   - Field: ‘label’
[16:05:53.575]   - Field: ‘local’
[16:05:53.576]   - Field: ‘owner’
[16:05:53.576]   - Field: ‘envir’
[16:05:53.576]   - Field: ‘packages’
[16:05:53.576]   - Field: ‘gc’
[16:05:53.576]   - Field: ‘conditions’
[16:05:53.576]   - Field: ‘expr’
[16:05:53.576]   - Field: ‘uuid’
[16:05:53.576]   - Field: ‘seed’
[16:05:53.576]   - Field: ‘version’
[16:05:53.576]   - Field: ‘result’
[16:05:53.576]   - Field: ‘asynchronous’
[16:05:53.576]   - Field: ‘calls’
[16:05:53.577]   - Field: ‘globals’
[16:05:53.577]   - Field: ‘stdout’
[16:05:53.577]   - Field: ‘earlySignal’
[16:05:53.577]   - Field: ‘lazy’
[16:05:53.577]   - Field: ‘state’
[16:05:53.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.577] - Launch lazy future ...
[16:05:53.577] Packages needed by the future expression (n = 0): <none>
[16:05:53.577] Packages needed by future strategies (n = 0): <none>
[16:05:53.578] {
[16:05:53.578]     {
[16:05:53.578]         {
[16:05:53.578]             ...future.startTime <- base::Sys.time()
[16:05:53.578]             {
[16:05:53.578]                 {
[16:05:53.578]                   {
[16:05:53.578]                     base::local({
[16:05:53.578]                       has_future <- base::requireNamespace("future", 
[16:05:53.578]                         quietly = TRUE)
[16:05:53.578]                       if (has_future) {
[16:05:53.578]                         ns <- base::getNamespace("future")
[16:05:53.578]                         version <- ns[[".package"]][["version"]]
[16:05:53.578]                         if (is.null(version)) 
[16:05:53.578]                           version <- utils::packageVersion("future")
[16:05:53.578]                       }
[16:05:53.578]                       else {
[16:05:53.578]                         version <- NULL
[16:05:53.578]                       }
[16:05:53.578]                       if (!has_future || version < "1.8.0") {
[16:05:53.578]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.578]                           "", base::R.version$version.string), 
[16:05:53.578]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.578]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.578]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.578]                             "release", "version")], collapse = " "), 
[16:05:53.578]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.578]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.578]                           info)
[16:05:53.578]                         info <- base::paste(info, collapse = "; ")
[16:05:53.578]                         if (!has_future) {
[16:05:53.578]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.578]                             info)
[16:05:53.578]                         }
[16:05:53.578]                         else {
[16:05:53.578]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.578]                             info, version)
[16:05:53.578]                         }
[16:05:53.578]                         base::stop(msg)
[16:05:53.578]                       }
[16:05:53.578]                     })
[16:05:53.578]                   }
[16:05:53.578]                   options(future.plan = NULL)
[16:05:53.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.578]                 }
[16:05:53.578]                 ...future.workdir <- getwd()
[16:05:53.578]             }
[16:05:53.578]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.578]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.578]         }
[16:05:53.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.578]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.578]             base::names(...future.oldOptions))
[16:05:53.578]     }
[16:05:53.578]     if (FALSE) {
[16:05:53.578]     }
[16:05:53.578]     else {
[16:05:53.578]         if (TRUE) {
[16:05:53.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.578]                 open = "w")
[16:05:53.578]         }
[16:05:53.578]         else {
[16:05:53.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.578]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.578]         }
[16:05:53.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.578]             base::sink(type = "output", split = FALSE)
[16:05:53.578]             base::close(...future.stdout)
[16:05:53.578]         }, add = TRUE)
[16:05:53.578]     }
[16:05:53.578]     ...future.frame <- base::sys.nframe()
[16:05:53.578]     ...future.conditions <- base::list()
[16:05:53.578]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.578]     if (FALSE) {
[16:05:53.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.578]     }
[16:05:53.578]     ...future.result <- base::tryCatch({
[16:05:53.578]         base::withCallingHandlers({
[16:05:53.578]             ...future.value <- base::withVisible(base::local(1))
[16:05:53.578]             future::FutureResult(value = ...future.value$value, 
[16:05:53.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.578]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.578]                     ...future.globalenv.names))
[16:05:53.578]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.578]         }, condition = base::local({
[16:05:53.578]             c <- base::c
[16:05:53.578]             inherits <- base::inherits
[16:05:53.578]             invokeRestart <- base::invokeRestart
[16:05:53.578]             length <- base::length
[16:05:53.578]             list <- base::list
[16:05:53.578]             seq.int <- base::seq.int
[16:05:53.578]             signalCondition <- base::signalCondition
[16:05:53.578]             sys.calls <- base::sys.calls
[16:05:53.578]             `[[` <- base::`[[`
[16:05:53.578]             `+` <- base::`+`
[16:05:53.578]             `<<-` <- base::`<<-`
[16:05:53.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.578]                   3L)]
[16:05:53.578]             }
[16:05:53.578]             function(cond) {
[16:05:53.578]                 is_error <- inherits(cond, "error")
[16:05:53.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.578]                   NULL)
[16:05:53.578]                 if (is_error) {
[16:05:53.578]                   sessionInformation <- function() {
[16:05:53.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.578]                       search = base::search(), system = base::Sys.info())
[16:05:53.578]                   }
[16:05:53.578]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.578]                     cond$call), session = sessionInformation(), 
[16:05:53.578]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.578]                   signalCondition(cond)
[16:05:53.578]                 }
[16:05:53.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.578]                 "immediateCondition"))) {
[16:05:53.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.578]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.578]                   if (TRUE && !signal) {
[16:05:53.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.578]                     {
[16:05:53.578]                       inherits <- base::inherits
[16:05:53.578]                       invokeRestart <- base::invokeRestart
[16:05:53.578]                       is.null <- base::is.null
[16:05:53.578]                       muffled <- FALSE
[16:05:53.578]                       if (inherits(cond, "message")) {
[16:05:53.578]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.578]                         if (muffled) 
[16:05:53.578]                           invokeRestart("muffleMessage")
[16:05:53.578]                       }
[16:05:53.578]                       else if (inherits(cond, "warning")) {
[16:05:53.578]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.578]                         if (muffled) 
[16:05:53.578]                           invokeRestart("muffleWarning")
[16:05:53.578]                       }
[16:05:53.578]                       else if (inherits(cond, "condition")) {
[16:05:53.578]                         if (!is.null(pattern)) {
[16:05:53.578]                           computeRestarts <- base::computeRestarts
[16:05:53.578]                           grepl <- base::grepl
[16:05:53.578]                           restarts <- computeRestarts(cond)
[16:05:53.578]                           for (restart in restarts) {
[16:05:53.578]                             name <- restart$name
[16:05:53.578]                             if (is.null(name)) 
[16:05:53.578]                               next
[16:05:53.578]                             if (!grepl(pattern, name)) 
[16:05:53.578]                               next
[16:05:53.578]                             invokeRestart(restart)
[16:05:53.578]                             muffled <- TRUE
[16:05:53.578]                             break
[16:05:53.578]                           }
[16:05:53.578]                         }
[16:05:53.578]                       }
[16:05:53.578]                       invisible(muffled)
[16:05:53.578]                     }
[16:05:53.578]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.578]                   }
[16:05:53.578]                 }
[16:05:53.578]                 else {
[16:05:53.578]                   if (TRUE) {
[16:05:53.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.578]                     {
[16:05:53.578]                       inherits <- base::inherits
[16:05:53.578]                       invokeRestart <- base::invokeRestart
[16:05:53.578]                       is.null <- base::is.null
[16:05:53.578]                       muffled <- FALSE
[16:05:53.578]                       if (inherits(cond, "message")) {
[16:05:53.578]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.578]                         if (muffled) 
[16:05:53.578]                           invokeRestart("muffleMessage")
[16:05:53.578]                       }
[16:05:53.578]                       else if (inherits(cond, "warning")) {
[16:05:53.578]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.578]                         if (muffled) 
[16:05:53.578]                           invokeRestart("muffleWarning")
[16:05:53.578]                       }
[16:05:53.578]                       else if (inherits(cond, "condition")) {
[16:05:53.578]                         if (!is.null(pattern)) {
[16:05:53.578]                           computeRestarts <- base::computeRestarts
[16:05:53.578]                           grepl <- base::grepl
[16:05:53.578]                           restarts <- computeRestarts(cond)
[16:05:53.578]                           for (restart in restarts) {
[16:05:53.578]                             name <- restart$name
[16:05:53.578]                             if (is.null(name)) 
[16:05:53.578]                               next
[16:05:53.578]                             if (!grepl(pattern, name)) 
[16:05:53.578]                               next
[16:05:53.578]                             invokeRestart(restart)
[16:05:53.578]                             muffled <- TRUE
[16:05:53.578]                             break
[16:05:53.578]                           }
[16:05:53.578]                         }
[16:05:53.578]                       }
[16:05:53.578]                       invisible(muffled)
[16:05:53.578]                     }
[16:05:53.578]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.578]                   }
[16:05:53.578]                 }
[16:05:53.578]             }
[16:05:53.578]         }))
[16:05:53.578]     }, error = function(ex) {
[16:05:53.578]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.578]                 ...future.rng), started = ...future.startTime, 
[16:05:53.578]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.578]             version = "1.8"), class = "FutureResult")
[16:05:53.578]     }, finally = {
[16:05:53.578]         if (!identical(...future.workdir, getwd())) 
[16:05:53.578]             setwd(...future.workdir)
[16:05:53.578]         {
[16:05:53.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.578]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.578]             }
[16:05:53.578]             base::options(...future.oldOptions)
[16:05:53.578]             if (.Platform$OS.type == "windows") {
[16:05:53.578]                 old_names <- names(...future.oldEnvVars)
[16:05:53.578]                 envs <- base::Sys.getenv()
[16:05:53.578]                 names <- names(envs)
[16:05:53.578]                 common <- intersect(names, old_names)
[16:05:53.578]                 added <- setdiff(names, old_names)
[16:05:53.578]                 removed <- setdiff(old_names, names)
[16:05:53.578]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.578]                   envs[common]]
[16:05:53.578]                 NAMES <- toupper(changed)
[16:05:53.578]                 args <- list()
[16:05:53.578]                 for (kk in seq_along(NAMES)) {
[16:05:53.578]                   name <- changed[[kk]]
[16:05:53.578]                   NAME <- NAMES[[kk]]
[16:05:53.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.578]                     next
[16:05:53.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.578]                 }
[16:05:53.578]                 NAMES <- toupper(added)
[16:05:53.578]                 for (kk in seq_along(NAMES)) {
[16:05:53.578]                   name <- added[[kk]]
[16:05:53.578]                   NAME <- NAMES[[kk]]
[16:05:53.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.578]                     next
[16:05:53.578]                   args[[name]] <- ""
[16:05:53.578]                 }
[16:05:53.578]                 NAMES <- toupper(removed)
[16:05:53.578]                 for (kk in seq_along(NAMES)) {
[16:05:53.578]                   name <- removed[[kk]]
[16:05:53.578]                   NAME <- NAMES[[kk]]
[16:05:53.578]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.578]                     next
[16:05:53.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.578]                 }
[16:05:53.578]                 if (length(args) > 0) 
[16:05:53.578]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.578]             }
[16:05:53.578]             else {
[16:05:53.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.578]             }
[16:05:53.578]             {
[16:05:53.578]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.578]                   0L) {
[16:05:53.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.578]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.578]                   base::options(opts)
[16:05:53.578]                 }
[16:05:53.578]                 {
[16:05:53.578]                   {
[16:05:53.578]                     NULL
[16:05:53.578]                     RNGkind("Mersenne-Twister")
[16:05:53.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.578]                       inherits = FALSE)
[16:05:53.578]                   }
[16:05:53.578]                   options(future.plan = NULL)
[16:05:53.578]                   if (is.na(NA_character_)) 
[16:05:53.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.578]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.578]                   {
[16:05:53.578]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.578]                     if (!future$lazy) 
[16:05:53.578]                       future <- run(future)
[16:05:53.578]                     invisible(future)
[16:05:53.578]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.578]                 }
[16:05:53.578]             }
[16:05:53.578]         }
[16:05:53.578]     })
[16:05:53.578]     if (TRUE) {
[16:05:53.578]         base::sink(type = "output", split = FALSE)
[16:05:53.578]         if (TRUE) {
[16:05:53.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.578]         }
[16:05:53.578]         else {
[16:05:53.578]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.578]         }
[16:05:53.578]         base::close(...future.stdout)
[16:05:53.578]         ...future.stdout <- NULL
[16:05:53.578]     }
[16:05:53.578]     ...future.result$conditions <- ...future.conditions
[16:05:53.578]     ...future.result$finished <- base::Sys.time()
[16:05:53.578]     ...future.result
[16:05:53.578] }
[16:05:53.579] plan(): Setting new future strategy stack:
[16:05:53.579] List of future strategies:
[16:05:53.579] 1. sequential:
[16:05:53.579]    - args: function (..., envir = parent.frame())
[16:05:53.579]    - tweaked: FALSE
[16:05:53.579]    - call: NULL
[16:05:53.580] plan(): nbrOfWorkers() = 1
[16:05:53.580] plan(): Setting new future strategy stack:
[16:05:53.581] List of future strategies:
[16:05:53.581] 1. sequential:
[16:05:53.581]    - args: function (..., envir = parent.frame())
[16:05:53.581]    - tweaked: FALSE
[16:05:53.581]    - call: plan(strategy)
[16:05:53.581] plan(): nbrOfWorkers() = 1
[16:05:53.581] SequentialFuture started (and completed)
[16:05:53.581] - Launch lazy future ... done
[16:05:53.581] run() for ‘SequentialFuture’ ... done
[16:05:53.581] resolved() for ‘SequentialFuture’ ...
[16:05:53.581] - state: ‘finished’
[16:05:53.582] - run: TRUE
[16:05:53.582] - result: ‘FutureResult’
[16:05:53.582] resolved() for ‘SequentialFuture’ ... done
[16:05:53.582] Future #1
[16:05:53.582]  length: 2 (resolved future 1)
[16:05:53.582] run() for ‘Future’ ...
[16:05:53.582] - state: ‘created’
[16:05:53.582] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.582] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.583]   - Field: ‘label’
[16:05:53.583]   - Field: ‘local’
[16:05:53.583]   - Field: ‘owner’
[16:05:53.583]   - Field: ‘envir’
[16:05:53.583]   - Field: ‘packages’
[16:05:53.583]   - Field: ‘gc’
[16:05:53.583]   - Field: ‘conditions’
[16:05:53.583]   - Field: ‘expr’
[16:05:53.583]   - Field: ‘uuid’
[16:05:53.583]   - Field: ‘seed’
[16:05:53.584]   - Field: ‘version’
[16:05:53.584]   - Field: ‘result’
[16:05:53.584]   - Field: ‘asynchronous’
[16:05:53.584]   - Field: ‘calls’
[16:05:53.584]   - Field: ‘globals’
[16:05:53.584]   - Field: ‘stdout’
[16:05:53.584]   - Field: ‘earlySignal’
[16:05:53.584]   - Field: ‘lazy’
[16:05:53.584]   - Field: ‘state’
[16:05:53.584] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.584] - Launch lazy future ...
[16:05:53.585] Packages needed by the future expression (n = 0): <none>
[16:05:53.585] Packages needed by future strategies (n = 0): <none>
[16:05:53.586] {
[16:05:53.586]     {
[16:05:53.586]         {
[16:05:53.586]             ...future.startTime <- base::Sys.time()
[16:05:53.586]             {
[16:05:53.586]                 {
[16:05:53.586]                   {
[16:05:53.586]                     base::local({
[16:05:53.586]                       has_future <- base::requireNamespace("future", 
[16:05:53.586]                         quietly = TRUE)
[16:05:53.586]                       if (has_future) {
[16:05:53.586]                         ns <- base::getNamespace("future")
[16:05:53.586]                         version <- ns[[".package"]][["version"]]
[16:05:53.586]                         if (is.null(version)) 
[16:05:53.586]                           version <- utils::packageVersion("future")
[16:05:53.586]                       }
[16:05:53.586]                       else {
[16:05:53.586]                         version <- NULL
[16:05:53.586]                       }
[16:05:53.586]                       if (!has_future || version < "1.8.0") {
[16:05:53.586]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.586]                           "", base::R.version$version.string), 
[16:05:53.586]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.586]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.586]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.586]                             "release", "version")], collapse = " "), 
[16:05:53.586]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.586]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.586]                           info)
[16:05:53.586]                         info <- base::paste(info, collapse = "; ")
[16:05:53.586]                         if (!has_future) {
[16:05:53.586]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.586]                             info)
[16:05:53.586]                         }
[16:05:53.586]                         else {
[16:05:53.586]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.586]                             info, version)
[16:05:53.586]                         }
[16:05:53.586]                         base::stop(msg)
[16:05:53.586]                       }
[16:05:53.586]                     })
[16:05:53.586]                   }
[16:05:53.586]                   options(future.plan = NULL)
[16:05:53.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.586]                 }
[16:05:53.586]                 ...future.workdir <- getwd()
[16:05:53.586]             }
[16:05:53.586]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.586]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.586]         }
[16:05:53.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.586]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.586]             base::names(...future.oldOptions))
[16:05:53.586]     }
[16:05:53.586]     if (FALSE) {
[16:05:53.586]     }
[16:05:53.586]     else {
[16:05:53.586]         if (TRUE) {
[16:05:53.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.586]                 open = "w")
[16:05:53.586]         }
[16:05:53.586]         else {
[16:05:53.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.586]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.586]         }
[16:05:53.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.586]             base::sink(type = "output", split = FALSE)
[16:05:53.586]             base::close(...future.stdout)
[16:05:53.586]         }, add = TRUE)
[16:05:53.586]     }
[16:05:53.586]     ...future.frame <- base::sys.nframe()
[16:05:53.586]     ...future.conditions <- base::list()
[16:05:53.586]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.586]     if (FALSE) {
[16:05:53.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.586]     }
[16:05:53.586]     ...future.result <- base::tryCatch({
[16:05:53.586]         base::withCallingHandlers({
[16:05:53.586]             ...future.value <- base::withVisible(base::local(2))
[16:05:53.586]             future::FutureResult(value = ...future.value$value, 
[16:05:53.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.586]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.586]                     ...future.globalenv.names))
[16:05:53.586]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.586]         }, condition = base::local({
[16:05:53.586]             c <- base::c
[16:05:53.586]             inherits <- base::inherits
[16:05:53.586]             invokeRestart <- base::invokeRestart
[16:05:53.586]             length <- base::length
[16:05:53.586]             list <- base::list
[16:05:53.586]             seq.int <- base::seq.int
[16:05:53.586]             signalCondition <- base::signalCondition
[16:05:53.586]             sys.calls <- base::sys.calls
[16:05:53.586]             `[[` <- base::`[[`
[16:05:53.586]             `+` <- base::`+`
[16:05:53.586]             `<<-` <- base::`<<-`
[16:05:53.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.586]                   3L)]
[16:05:53.586]             }
[16:05:53.586]             function(cond) {
[16:05:53.586]                 is_error <- inherits(cond, "error")
[16:05:53.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.586]                   NULL)
[16:05:53.586]                 if (is_error) {
[16:05:53.586]                   sessionInformation <- function() {
[16:05:53.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.586]                       search = base::search(), system = base::Sys.info())
[16:05:53.586]                   }
[16:05:53.586]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.586]                     cond$call), session = sessionInformation(), 
[16:05:53.586]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.586]                   signalCondition(cond)
[16:05:53.586]                 }
[16:05:53.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.586]                 "immediateCondition"))) {
[16:05:53.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.586]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.586]                   if (TRUE && !signal) {
[16:05:53.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.586]                     {
[16:05:53.586]                       inherits <- base::inherits
[16:05:53.586]                       invokeRestart <- base::invokeRestart
[16:05:53.586]                       is.null <- base::is.null
[16:05:53.586]                       muffled <- FALSE
[16:05:53.586]                       if (inherits(cond, "message")) {
[16:05:53.586]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.586]                         if (muffled) 
[16:05:53.586]                           invokeRestart("muffleMessage")
[16:05:53.586]                       }
[16:05:53.586]                       else if (inherits(cond, "warning")) {
[16:05:53.586]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.586]                         if (muffled) 
[16:05:53.586]                           invokeRestart("muffleWarning")
[16:05:53.586]                       }
[16:05:53.586]                       else if (inherits(cond, "condition")) {
[16:05:53.586]                         if (!is.null(pattern)) {
[16:05:53.586]                           computeRestarts <- base::computeRestarts
[16:05:53.586]                           grepl <- base::grepl
[16:05:53.586]                           restarts <- computeRestarts(cond)
[16:05:53.586]                           for (restart in restarts) {
[16:05:53.586]                             name <- restart$name
[16:05:53.586]                             if (is.null(name)) 
[16:05:53.586]                               next
[16:05:53.586]                             if (!grepl(pattern, name)) 
[16:05:53.586]                               next
[16:05:53.586]                             invokeRestart(restart)
[16:05:53.586]                             muffled <- TRUE
[16:05:53.586]                             break
[16:05:53.586]                           }
[16:05:53.586]                         }
[16:05:53.586]                       }
[16:05:53.586]                       invisible(muffled)
[16:05:53.586]                     }
[16:05:53.586]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.586]                   }
[16:05:53.586]                 }
[16:05:53.586]                 else {
[16:05:53.586]                   if (TRUE) {
[16:05:53.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.586]                     {
[16:05:53.586]                       inherits <- base::inherits
[16:05:53.586]                       invokeRestart <- base::invokeRestart
[16:05:53.586]                       is.null <- base::is.null
[16:05:53.586]                       muffled <- FALSE
[16:05:53.586]                       if (inherits(cond, "message")) {
[16:05:53.586]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.586]                         if (muffled) 
[16:05:53.586]                           invokeRestart("muffleMessage")
[16:05:53.586]                       }
[16:05:53.586]                       else if (inherits(cond, "warning")) {
[16:05:53.586]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.586]                         if (muffled) 
[16:05:53.586]                           invokeRestart("muffleWarning")
[16:05:53.586]                       }
[16:05:53.586]                       else if (inherits(cond, "condition")) {
[16:05:53.586]                         if (!is.null(pattern)) {
[16:05:53.586]                           computeRestarts <- base::computeRestarts
[16:05:53.586]                           grepl <- base::grepl
[16:05:53.586]                           restarts <- computeRestarts(cond)
[16:05:53.586]                           for (restart in restarts) {
[16:05:53.586]                             name <- restart$name
[16:05:53.586]                             if (is.null(name)) 
[16:05:53.586]                               next
[16:05:53.586]                             if (!grepl(pattern, name)) 
[16:05:53.586]                               next
[16:05:53.586]                             invokeRestart(restart)
[16:05:53.586]                             muffled <- TRUE
[16:05:53.586]                             break
[16:05:53.586]                           }
[16:05:53.586]                         }
[16:05:53.586]                       }
[16:05:53.586]                       invisible(muffled)
[16:05:53.586]                     }
[16:05:53.586]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.586]                   }
[16:05:53.586]                 }
[16:05:53.586]             }
[16:05:53.586]         }))
[16:05:53.586]     }, error = function(ex) {
[16:05:53.586]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.586]                 ...future.rng), started = ...future.startTime, 
[16:05:53.586]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.586]             version = "1.8"), class = "FutureResult")
[16:05:53.586]     }, finally = {
[16:05:53.586]         if (!identical(...future.workdir, getwd())) 
[16:05:53.586]             setwd(...future.workdir)
[16:05:53.586]         {
[16:05:53.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.586]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.586]             }
[16:05:53.586]             base::options(...future.oldOptions)
[16:05:53.586]             if (.Platform$OS.type == "windows") {
[16:05:53.586]                 old_names <- names(...future.oldEnvVars)
[16:05:53.586]                 envs <- base::Sys.getenv()
[16:05:53.586]                 names <- names(envs)
[16:05:53.586]                 common <- intersect(names, old_names)
[16:05:53.586]                 added <- setdiff(names, old_names)
[16:05:53.586]                 removed <- setdiff(old_names, names)
[16:05:53.586]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.586]                   envs[common]]
[16:05:53.586]                 NAMES <- toupper(changed)
[16:05:53.586]                 args <- list()
[16:05:53.586]                 for (kk in seq_along(NAMES)) {
[16:05:53.586]                   name <- changed[[kk]]
[16:05:53.586]                   NAME <- NAMES[[kk]]
[16:05:53.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.586]                     next
[16:05:53.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.586]                 }
[16:05:53.586]                 NAMES <- toupper(added)
[16:05:53.586]                 for (kk in seq_along(NAMES)) {
[16:05:53.586]                   name <- added[[kk]]
[16:05:53.586]                   NAME <- NAMES[[kk]]
[16:05:53.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.586]                     next
[16:05:53.586]                   args[[name]] <- ""
[16:05:53.586]                 }
[16:05:53.586]                 NAMES <- toupper(removed)
[16:05:53.586]                 for (kk in seq_along(NAMES)) {
[16:05:53.586]                   name <- removed[[kk]]
[16:05:53.586]                   NAME <- NAMES[[kk]]
[16:05:53.586]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.586]                     next
[16:05:53.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.586]                 }
[16:05:53.586]                 if (length(args) > 0) 
[16:05:53.586]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.586]             }
[16:05:53.586]             else {
[16:05:53.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.586]             }
[16:05:53.586]             {
[16:05:53.586]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.586]                   0L) {
[16:05:53.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.586]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.586]                   base::options(opts)
[16:05:53.586]                 }
[16:05:53.586]                 {
[16:05:53.586]                   {
[16:05:53.586]                     NULL
[16:05:53.586]                     RNGkind("Mersenne-Twister")
[16:05:53.586]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.586]                       inherits = FALSE)
[16:05:53.586]                   }
[16:05:53.586]                   options(future.plan = NULL)
[16:05:53.586]                   if (is.na(NA_character_)) 
[16:05:53.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.586]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.586]                   {
[16:05:53.586]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.586]                     if (!future$lazy) 
[16:05:53.586]                       future <- run(future)
[16:05:53.586]                     invisible(future)
[16:05:53.586]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.586]                 }
[16:05:53.586]             }
[16:05:53.586]         }
[16:05:53.586]     })
[16:05:53.586]     if (TRUE) {
[16:05:53.586]         base::sink(type = "output", split = FALSE)
[16:05:53.586]         if (TRUE) {
[16:05:53.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.586]         }
[16:05:53.586]         else {
[16:05:53.586]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.586]         }
[16:05:53.586]         base::close(...future.stdout)
[16:05:53.586]         ...future.stdout <- NULL
[16:05:53.586]     }
[16:05:53.586]     ...future.result$conditions <- ...future.conditions
[16:05:53.586]     ...future.result$finished <- base::Sys.time()
[16:05:53.586]     ...future.result
[16:05:53.586] }
[16:05:53.588] plan(): Setting new future strategy stack:
[16:05:53.588] List of future strategies:
[16:05:53.588] 1. sequential:
[16:05:53.588]    - args: function (..., envir = parent.frame())
[16:05:53.588]    - tweaked: FALSE
[16:05:53.588]    - call: NULL
[16:05:53.588] plan(): nbrOfWorkers() = 1
[16:05:53.589] plan(): Setting new future strategy stack:
[16:05:53.589] List of future strategies:
[16:05:53.589] 1. sequential:
[16:05:53.589]    - args: function (..., envir = parent.frame())
[16:05:53.589]    - tweaked: FALSE
[16:05:53.589]    - call: plan(strategy)
[16:05:53.589] plan(): nbrOfWorkers() = 1
[16:05:53.589] SequentialFuture started (and completed)
[16:05:53.589] - Launch lazy future ... done
[16:05:53.589] run() for ‘SequentialFuture’ ... done
[16:05:53.589] resolved() for ‘SequentialFuture’ ...
[16:05:53.590] - state: ‘finished’
[16:05:53.590] - run: TRUE
[16:05:53.590] - result: ‘FutureResult’
[16:05:53.590] resolved() for ‘SequentialFuture’ ... done
[16:05:53.590] Future #2
[16:05:53.590]  length: 1 (resolved future 2)
[16:05:53.590]  length: 0 (resolved future 3)
[16:05:53.590] resolve() on list ... DONE
[16:05:53.590] resolved() for ‘SequentialFuture’ ...
[16:05:53.590] - state: ‘finished’
[16:05:53.590] - run: TRUE
[16:05:53.591] - result: ‘FutureResult’
[16:05:53.591] resolved() for ‘SequentialFuture’ ... done
[16:05:53.591] resolved() for ‘SequentialFuture’ ...
[16:05:53.591] - state: ‘finished’
[16:05:53.591] - run: TRUE
[16:05:53.591] - result: ‘FutureResult’
[16:05:53.591] resolved() for ‘SequentialFuture’ ... done
[16:05:53.591] getGlobalsAndPackages() ...
[16:05:53.591] Searching for globals...
[16:05:53.592] 
[16:05:53.592] Searching for globals ... DONE
[16:05:53.592] - globals: [0] <none>
[16:05:53.592] getGlobalsAndPackages() ... DONE
[16:05:53.592] run() for ‘Future’ ...
[16:05:53.592] - state: ‘created’
[16:05:53.592] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.593]   - Field: ‘label’
[16:05:53.593]   - Field: ‘local’
[16:05:53.593]   - Field: ‘owner’
[16:05:53.593]   - Field: ‘envir’
[16:05:53.593]   - Field: ‘packages’
[16:05:53.593]   - Field: ‘gc’
[16:05:53.593]   - Field: ‘conditions’
[16:05:53.593]   - Field: ‘expr’
[16:05:53.593]   - Field: ‘uuid’
[16:05:53.593]   - Field: ‘seed’
[16:05:53.593]   - Field: ‘version’
[16:05:53.594]   - Field: ‘result’
[16:05:53.594]   - Field: ‘asynchronous’
[16:05:53.594]   - Field: ‘calls’
[16:05:53.594]   - Field: ‘globals’
[16:05:53.594]   - Field: ‘stdout’
[16:05:53.594]   - Field: ‘earlySignal’
[16:05:53.594]   - Field: ‘lazy’
[16:05:53.594]   - Field: ‘state’
[16:05:53.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.594] - Launch lazy future ...
[16:05:53.594] Packages needed by the future expression (n = 0): <none>
[16:05:53.595] Packages needed by future strategies (n = 0): <none>
[16:05:53.595] {
[16:05:53.595]     {
[16:05:53.595]         {
[16:05:53.595]             ...future.startTime <- base::Sys.time()
[16:05:53.595]             {
[16:05:53.595]                 {
[16:05:53.595]                   {
[16:05:53.595]                     base::local({
[16:05:53.595]                       has_future <- base::requireNamespace("future", 
[16:05:53.595]                         quietly = TRUE)
[16:05:53.595]                       if (has_future) {
[16:05:53.595]                         ns <- base::getNamespace("future")
[16:05:53.595]                         version <- ns[[".package"]][["version"]]
[16:05:53.595]                         if (is.null(version)) 
[16:05:53.595]                           version <- utils::packageVersion("future")
[16:05:53.595]                       }
[16:05:53.595]                       else {
[16:05:53.595]                         version <- NULL
[16:05:53.595]                       }
[16:05:53.595]                       if (!has_future || version < "1.8.0") {
[16:05:53.595]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.595]                           "", base::R.version$version.string), 
[16:05:53.595]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.595]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.595]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.595]                             "release", "version")], collapse = " "), 
[16:05:53.595]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.595]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.595]                           info)
[16:05:53.595]                         info <- base::paste(info, collapse = "; ")
[16:05:53.595]                         if (!has_future) {
[16:05:53.595]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.595]                             info)
[16:05:53.595]                         }
[16:05:53.595]                         else {
[16:05:53.595]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.595]                             info, version)
[16:05:53.595]                         }
[16:05:53.595]                         base::stop(msg)
[16:05:53.595]                       }
[16:05:53.595]                     })
[16:05:53.595]                   }
[16:05:53.595]                   options(future.plan = NULL)
[16:05:53.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.595]                 }
[16:05:53.595]                 ...future.workdir <- getwd()
[16:05:53.595]             }
[16:05:53.595]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.595]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.595]         }
[16:05:53.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.595]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.595]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.595]             base::names(...future.oldOptions))
[16:05:53.595]     }
[16:05:53.595]     if (FALSE) {
[16:05:53.595]     }
[16:05:53.595]     else {
[16:05:53.595]         if (TRUE) {
[16:05:53.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.595]                 open = "w")
[16:05:53.595]         }
[16:05:53.595]         else {
[16:05:53.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.595]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.595]         }
[16:05:53.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.595]             base::sink(type = "output", split = FALSE)
[16:05:53.595]             base::close(...future.stdout)
[16:05:53.595]         }, add = TRUE)
[16:05:53.595]     }
[16:05:53.595]     ...future.frame <- base::sys.nframe()
[16:05:53.595]     ...future.conditions <- base::list()
[16:05:53.595]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.595]     if (FALSE) {
[16:05:53.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.595]     }
[16:05:53.595]     ...future.result <- base::tryCatch({
[16:05:53.595]         base::withCallingHandlers({
[16:05:53.595]             ...future.value <- base::withVisible(base::local(1))
[16:05:53.595]             future::FutureResult(value = ...future.value$value, 
[16:05:53.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.595]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.595]                     ...future.globalenv.names))
[16:05:53.595]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.595]         }, condition = base::local({
[16:05:53.595]             c <- base::c
[16:05:53.595]             inherits <- base::inherits
[16:05:53.595]             invokeRestart <- base::invokeRestart
[16:05:53.595]             length <- base::length
[16:05:53.595]             list <- base::list
[16:05:53.595]             seq.int <- base::seq.int
[16:05:53.595]             signalCondition <- base::signalCondition
[16:05:53.595]             sys.calls <- base::sys.calls
[16:05:53.595]             `[[` <- base::`[[`
[16:05:53.595]             `+` <- base::`+`
[16:05:53.595]             `<<-` <- base::`<<-`
[16:05:53.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.595]                   3L)]
[16:05:53.595]             }
[16:05:53.595]             function(cond) {
[16:05:53.595]                 is_error <- inherits(cond, "error")
[16:05:53.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.595]                   NULL)
[16:05:53.595]                 if (is_error) {
[16:05:53.595]                   sessionInformation <- function() {
[16:05:53.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.595]                       search = base::search(), system = base::Sys.info())
[16:05:53.595]                   }
[16:05:53.595]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.595]                     cond$call), session = sessionInformation(), 
[16:05:53.595]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.595]                   signalCondition(cond)
[16:05:53.595]                 }
[16:05:53.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.595]                 "immediateCondition"))) {
[16:05:53.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.595]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.595]                   if (TRUE && !signal) {
[16:05:53.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.595]                     {
[16:05:53.595]                       inherits <- base::inherits
[16:05:53.595]                       invokeRestart <- base::invokeRestart
[16:05:53.595]                       is.null <- base::is.null
[16:05:53.595]                       muffled <- FALSE
[16:05:53.595]                       if (inherits(cond, "message")) {
[16:05:53.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.595]                         if (muffled) 
[16:05:53.595]                           invokeRestart("muffleMessage")
[16:05:53.595]                       }
[16:05:53.595]                       else if (inherits(cond, "warning")) {
[16:05:53.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.595]                         if (muffled) 
[16:05:53.595]                           invokeRestart("muffleWarning")
[16:05:53.595]                       }
[16:05:53.595]                       else if (inherits(cond, "condition")) {
[16:05:53.595]                         if (!is.null(pattern)) {
[16:05:53.595]                           computeRestarts <- base::computeRestarts
[16:05:53.595]                           grepl <- base::grepl
[16:05:53.595]                           restarts <- computeRestarts(cond)
[16:05:53.595]                           for (restart in restarts) {
[16:05:53.595]                             name <- restart$name
[16:05:53.595]                             if (is.null(name)) 
[16:05:53.595]                               next
[16:05:53.595]                             if (!grepl(pattern, name)) 
[16:05:53.595]                               next
[16:05:53.595]                             invokeRestart(restart)
[16:05:53.595]                             muffled <- TRUE
[16:05:53.595]                             break
[16:05:53.595]                           }
[16:05:53.595]                         }
[16:05:53.595]                       }
[16:05:53.595]                       invisible(muffled)
[16:05:53.595]                     }
[16:05:53.595]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.595]                   }
[16:05:53.595]                 }
[16:05:53.595]                 else {
[16:05:53.595]                   if (TRUE) {
[16:05:53.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.595]                     {
[16:05:53.595]                       inherits <- base::inherits
[16:05:53.595]                       invokeRestart <- base::invokeRestart
[16:05:53.595]                       is.null <- base::is.null
[16:05:53.595]                       muffled <- FALSE
[16:05:53.595]                       if (inherits(cond, "message")) {
[16:05:53.595]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.595]                         if (muffled) 
[16:05:53.595]                           invokeRestart("muffleMessage")
[16:05:53.595]                       }
[16:05:53.595]                       else if (inherits(cond, "warning")) {
[16:05:53.595]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.595]                         if (muffled) 
[16:05:53.595]                           invokeRestart("muffleWarning")
[16:05:53.595]                       }
[16:05:53.595]                       else if (inherits(cond, "condition")) {
[16:05:53.595]                         if (!is.null(pattern)) {
[16:05:53.595]                           computeRestarts <- base::computeRestarts
[16:05:53.595]                           grepl <- base::grepl
[16:05:53.595]                           restarts <- computeRestarts(cond)
[16:05:53.595]                           for (restart in restarts) {
[16:05:53.595]                             name <- restart$name
[16:05:53.595]                             if (is.null(name)) 
[16:05:53.595]                               next
[16:05:53.595]                             if (!grepl(pattern, name)) 
[16:05:53.595]                               next
[16:05:53.595]                             invokeRestart(restart)
[16:05:53.595]                             muffled <- TRUE
[16:05:53.595]                             break
[16:05:53.595]                           }
[16:05:53.595]                         }
[16:05:53.595]                       }
[16:05:53.595]                       invisible(muffled)
[16:05:53.595]                     }
[16:05:53.595]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.595]                   }
[16:05:53.595]                 }
[16:05:53.595]             }
[16:05:53.595]         }))
[16:05:53.595]     }, error = function(ex) {
[16:05:53.595]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.595]                 ...future.rng), started = ...future.startTime, 
[16:05:53.595]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.595]             version = "1.8"), class = "FutureResult")
[16:05:53.595]     }, finally = {
[16:05:53.595]         if (!identical(...future.workdir, getwd())) 
[16:05:53.595]             setwd(...future.workdir)
[16:05:53.595]         {
[16:05:53.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.595]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.595]             }
[16:05:53.595]             base::options(...future.oldOptions)
[16:05:53.595]             if (.Platform$OS.type == "windows") {
[16:05:53.595]                 old_names <- names(...future.oldEnvVars)
[16:05:53.595]                 envs <- base::Sys.getenv()
[16:05:53.595]                 names <- names(envs)
[16:05:53.595]                 common <- intersect(names, old_names)
[16:05:53.595]                 added <- setdiff(names, old_names)
[16:05:53.595]                 removed <- setdiff(old_names, names)
[16:05:53.595]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.595]                   envs[common]]
[16:05:53.595]                 NAMES <- toupper(changed)
[16:05:53.595]                 args <- list()
[16:05:53.595]                 for (kk in seq_along(NAMES)) {
[16:05:53.595]                   name <- changed[[kk]]
[16:05:53.595]                   NAME <- NAMES[[kk]]
[16:05:53.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.595]                     next
[16:05:53.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.595]                 }
[16:05:53.595]                 NAMES <- toupper(added)
[16:05:53.595]                 for (kk in seq_along(NAMES)) {
[16:05:53.595]                   name <- added[[kk]]
[16:05:53.595]                   NAME <- NAMES[[kk]]
[16:05:53.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.595]                     next
[16:05:53.595]                   args[[name]] <- ""
[16:05:53.595]                 }
[16:05:53.595]                 NAMES <- toupper(removed)
[16:05:53.595]                 for (kk in seq_along(NAMES)) {
[16:05:53.595]                   name <- removed[[kk]]
[16:05:53.595]                   NAME <- NAMES[[kk]]
[16:05:53.595]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.595]                     next
[16:05:53.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.595]                 }
[16:05:53.595]                 if (length(args) > 0) 
[16:05:53.595]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.595]             }
[16:05:53.595]             else {
[16:05:53.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.595]             }
[16:05:53.595]             {
[16:05:53.595]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.595]                   0L) {
[16:05:53.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.595]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.595]                   base::options(opts)
[16:05:53.595]                 }
[16:05:53.595]                 {
[16:05:53.595]                   {
[16:05:53.595]                     NULL
[16:05:53.595]                     RNGkind("Mersenne-Twister")
[16:05:53.595]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.595]                       inherits = FALSE)
[16:05:53.595]                   }
[16:05:53.595]                   options(future.plan = NULL)
[16:05:53.595]                   if (is.na(NA_character_)) 
[16:05:53.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.595]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.595]                   {
[16:05:53.595]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.595]                     if (!future$lazy) 
[16:05:53.595]                       future <- run(future)
[16:05:53.595]                     invisible(future)
[16:05:53.595]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.595]                 }
[16:05:53.595]             }
[16:05:53.595]         }
[16:05:53.595]     })
[16:05:53.595]     if (TRUE) {
[16:05:53.595]         base::sink(type = "output", split = FALSE)
[16:05:53.595]         if (TRUE) {
[16:05:53.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.595]         }
[16:05:53.595]         else {
[16:05:53.595]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.595]         }
[16:05:53.595]         base::close(...future.stdout)
[16:05:53.595]         ...future.stdout <- NULL
[16:05:53.595]     }
[16:05:53.595]     ...future.result$conditions <- ...future.conditions
[16:05:53.595]     ...future.result$finished <- base::Sys.time()
[16:05:53.595]     ...future.result
[16:05:53.595] }
[16:05:53.597] plan(): Setting new future strategy stack:
[16:05:53.597] List of future strategies:
[16:05:53.597] 1. sequential:
[16:05:53.597]    - args: function (..., envir = parent.frame())
[16:05:53.597]    - tweaked: FALSE
[16:05:53.597]    - call: NULL
[16:05:53.597] plan(): nbrOfWorkers() = 1
[16:05:53.598] plan(): Setting new future strategy stack:
[16:05:53.598] List of future strategies:
[16:05:53.598] 1. sequential:
[16:05:53.598]    - args: function (..., envir = parent.frame())
[16:05:53.598]    - tweaked: FALSE
[16:05:53.598]    - call: plan(strategy)
[16:05:53.598] plan(): nbrOfWorkers() = 1
[16:05:53.598] SequentialFuture started (and completed)
[16:05:53.598] - Launch lazy future ... done
[16:05:53.598] run() for ‘SequentialFuture’ ... done
[16:05:53.599] getGlobalsAndPackages() ...
[16:05:53.599] Searching for globals...
[16:05:53.603] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:05:53.603] Searching for globals ... DONE
[16:05:53.603] Resolving globals: FALSE
[16:05:53.604] 
[16:05:53.604] 
[16:05:53.604] getGlobalsAndPackages() ... DONE
[16:05:53.604] run() for ‘Future’ ...
[16:05:53.604] - state: ‘created’
[16:05:53.604] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:53.605] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:53.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:53.605]   - Field: ‘label’
[16:05:53.605]   - Field: ‘local’
[16:05:53.605]   - Field: ‘owner’
[16:05:53.605]   - Field: ‘envir’
[16:05:53.605]   - Field: ‘packages’
[16:05:53.605]   - Field: ‘gc’
[16:05:53.605]   - Field: ‘conditions’
[16:05:53.605]   - Field: ‘expr’
[16:05:53.605]   - Field: ‘uuid’
[16:05:53.605]   - Field: ‘seed’
[16:05:53.606]   - Field: ‘version’
[16:05:53.606]   - Field: ‘result’
[16:05:53.606]   - Field: ‘asynchronous’
[16:05:53.606]   - Field: ‘calls’
[16:05:53.606]   - Field: ‘globals’
[16:05:53.606]   - Field: ‘stdout’
[16:05:53.606]   - Field: ‘earlySignal’
[16:05:53.606]   - Field: ‘lazy’
[16:05:53.606]   - Field: ‘state’
[16:05:53.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:53.606] - Launch lazy future ...
[16:05:53.607] Packages needed by the future expression (n = 0): <none>
[16:05:53.607] Packages needed by future strategies (n = 0): <none>
[16:05:53.607] {
[16:05:53.607]     {
[16:05:53.607]         {
[16:05:53.607]             ...future.startTime <- base::Sys.time()
[16:05:53.607]             {
[16:05:53.607]                 {
[16:05:53.607]                   {
[16:05:53.607]                     base::local({
[16:05:53.607]                       has_future <- base::requireNamespace("future", 
[16:05:53.607]                         quietly = TRUE)
[16:05:53.607]                       if (has_future) {
[16:05:53.607]                         ns <- base::getNamespace("future")
[16:05:53.607]                         version <- ns[[".package"]][["version"]]
[16:05:53.607]                         if (is.null(version)) 
[16:05:53.607]                           version <- utils::packageVersion("future")
[16:05:53.607]                       }
[16:05:53.607]                       else {
[16:05:53.607]                         version <- NULL
[16:05:53.607]                       }
[16:05:53.607]                       if (!has_future || version < "1.8.0") {
[16:05:53.607]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:53.607]                           "", base::R.version$version.string), 
[16:05:53.607]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:53.607]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:53.607]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:53.607]                             "release", "version")], collapse = " "), 
[16:05:53.607]                           hostname = base::Sys.info()[["nodename"]])
[16:05:53.607]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:53.607]                           info)
[16:05:53.607]                         info <- base::paste(info, collapse = "; ")
[16:05:53.607]                         if (!has_future) {
[16:05:53.607]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:53.607]                             info)
[16:05:53.607]                         }
[16:05:53.607]                         else {
[16:05:53.607]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:53.607]                             info, version)
[16:05:53.607]                         }
[16:05:53.607]                         base::stop(msg)
[16:05:53.607]                       }
[16:05:53.607]                     })
[16:05:53.607]                   }
[16:05:53.607]                   options(future.plan = NULL)
[16:05:53.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:53.607]                 }
[16:05:53.607]                 ...future.workdir <- getwd()
[16:05:53.607]             }
[16:05:53.607]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:53.607]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:53.607]         }
[16:05:53.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:53.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:53.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:53.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:53.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:53.607]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:53.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:53.607]             base::names(...future.oldOptions))
[16:05:53.607]     }
[16:05:53.607]     if (FALSE) {
[16:05:53.607]     }
[16:05:53.607]     else {
[16:05:53.607]         if (TRUE) {
[16:05:53.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:53.607]                 open = "w")
[16:05:53.607]         }
[16:05:53.607]         else {
[16:05:53.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:53.607]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:53.607]         }
[16:05:53.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:53.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:53.607]             base::sink(type = "output", split = FALSE)
[16:05:53.607]             base::close(...future.stdout)
[16:05:53.607]         }, add = TRUE)
[16:05:53.607]     }
[16:05:53.607]     ...future.frame <- base::sys.nframe()
[16:05:53.607]     ...future.conditions <- base::list()
[16:05:53.607]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:53.607]     if (FALSE) {
[16:05:53.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:53.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:53.607]     }
[16:05:53.607]     ...future.result <- base::tryCatch({
[16:05:53.607]         base::withCallingHandlers({
[16:05:53.607]             ...future.value <- base::withVisible(base::local({
[16:05:53.607]                 Sys.sleep(0.5)
[16:05:53.607]                 2
[16:05:53.607]             }))
[16:05:53.607]             future::FutureResult(value = ...future.value$value, 
[16:05:53.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.607]                   ...future.rng), globalenv = if (FALSE) 
[16:05:53.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:53.607]                     ...future.globalenv.names))
[16:05:53.607]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:53.607]         }, condition = base::local({
[16:05:53.607]             c <- base::c
[16:05:53.607]             inherits <- base::inherits
[16:05:53.607]             invokeRestart <- base::invokeRestart
[16:05:53.607]             length <- base::length
[16:05:53.607]             list <- base::list
[16:05:53.607]             seq.int <- base::seq.int
[16:05:53.607]             signalCondition <- base::signalCondition
[16:05:53.607]             sys.calls <- base::sys.calls
[16:05:53.607]             `[[` <- base::`[[`
[16:05:53.607]             `+` <- base::`+`
[16:05:53.607]             `<<-` <- base::`<<-`
[16:05:53.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:53.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:53.607]                   3L)]
[16:05:53.607]             }
[16:05:53.607]             function(cond) {
[16:05:53.607]                 is_error <- inherits(cond, "error")
[16:05:53.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:53.607]                   NULL)
[16:05:53.607]                 if (is_error) {
[16:05:53.607]                   sessionInformation <- function() {
[16:05:53.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:53.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:53.607]                       search = base::search(), system = base::Sys.info())
[16:05:53.607]                   }
[16:05:53.607]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:53.607]                     cond$call), session = sessionInformation(), 
[16:05:53.607]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:53.607]                   signalCondition(cond)
[16:05:53.607]                 }
[16:05:53.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:53.607]                 "immediateCondition"))) {
[16:05:53.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:53.607]                   ...future.conditions[[length(...future.conditions) + 
[16:05:53.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:53.607]                   if (TRUE && !signal) {
[16:05:53.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.607]                     {
[16:05:53.607]                       inherits <- base::inherits
[16:05:53.607]                       invokeRestart <- base::invokeRestart
[16:05:53.607]                       is.null <- base::is.null
[16:05:53.607]                       muffled <- FALSE
[16:05:53.607]                       if (inherits(cond, "message")) {
[16:05:53.607]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.607]                         if (muffled) 
[16:05:53.607]                           invokeRestart("muffleMessage")
[16:05:53.607]                       }
[16:05:53.607]                       else if (inherits(cond, "warning")) {
[16:05:53.607]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.607]                         if (muffled) 
[16:05:53.607]                           invokeRestart("muffleWarning")
[16:05:53.607]                       }
[16:05:53.607]                       else if (inherits(cond, "condition")) {
[16:05:53.607]                         if (!is.null(pattern)) {
[16:05:53.607]                           computeRestarts <- base::computeRestarts
[16:05:53.607]                           grepl <- base::grepl
[16:05:53.607]                           restarts <- computeRestarts(cond)
[16:05:53.607]                           for (restart in restarts) {
[16:05:53.607]                             name <- restart$name
[16:05:53.607]                             if (is.null(name)) 
[16:05:53.607]                               next
[16:05:53.607]                             if (!grepl(pattern, name)) 
[16:05:53.607]                               next
[16:05:53.607]                             invokeRestart(restart)
[16:05:53.607]                             muffled <- TRUE
[16:05:53.607]                             break
[16:05:53.607]                           }
[16:05:53.607]                         }
[16:05:53.607]                       }
[16:05:53.607]                       invisible(muffled)
[16:05:53.607]                     }
[16:05:53.607]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.607]                   }
[16:05:53.607]                 }
[16:05:53.607]                 else {
[16:05:53.607]                   if (TRUE) {
[16:05:53.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:53.607]                     {
[16:05:53.607]                       inherits <- base::inherits
[16:05:53.607]                       invokeRestart <- base::invokeRestart
[16:05:53.607]                       is.null <- base::is.null
[16:05:53.607]                       muffled <- FALSE
[16:05:53.607]                       if (inherits(cond, "message")) {
[16:05:53.607]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:53.607]                         if (muffled) 
[16:05:53.607]                           invokeRestart("muffleMessage")
[16:05:53.607]                       }
[16:05:53.607]                       else if (inherits(cond, "warning")) {
[16:05:53.607]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:53.607]                         if (muffled) 
[16:05:53.607]                           invokeRestart("muffleWarning")
[16:05:53.607]                       }
[16:05:53.607]                       else if (inherits(cond, "condition")) {
[16:05:53.607]                         if (!is.null(pattern)) {
[16:05:53.607]                           computeRestarts <- base::computeRestarts
[16:05:53.607]                           grepl <- base::grepl
[16:05:53.607]                           restarts <- computeRestarts(cond)
[16:05:53.607]                           for (restart in restarts) {
[16:05:53.607]                             name <- restart$name
[16:05:53.607]                             if (is.null(name)) 
[16:05:53.607]                               next
[16:05:53.607]                             if (!grepl(pattern, name)) 
[16:05:53.607]                               next
[16:05:53.607]                             invokeRestart(restart)
[16:05:53.607]                             muffled <- TRUE
[16:05:53.607]                             break
[16:05:53.607]                           }
[16:05:53.607]                         }
[16:05:53.607]                       }
[16:05:53.607]                       invisible(muffled)
[16:05:53.607]                     }
[16:05:53.607]                     muffleCondition(cond, pattern = "^muffle")
[16:05:53.607]                   }
[16:05:53.607]                 }
[16:05:53.607]             }
[16:05:53.607]         }))
[16:05:53.607]     }, error = function(ex) {
[16:05:53.607]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:53.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:53.607]                 ...future.rng), started = ...future.startTime, 
[16:05:53.607]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:53.607]             version = "1.8"), class = "FutureResult")
[16:05:53.607]     }, finally = {
[16:05:53.607]         if (!identical(...future.workdir, getwd())) 
[16:05:53.607]             setwd(...future.workdir)
[16:05:53.607]         {
[16:05:53.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:53.607]                 ...future.oldOptions$nwarnings <- NULL
[16:05:53.607]             }
[16:05:53.607]             base::options(...future.oldOptions)
[16:05:53.607]             if (.Platform$OS.type == "windows") {
[16:05:53.607]                 old_names <- names(...future.oldEnvVars)
[16:05:53.607]                 envs <- base::Sys.getenv()
[16:05:53.607]                 names <- names(envs)
[16:05:53.607]                 common <- intersect(names, old_names)
[16:05:53.607]                 added <- setdiff(names, old_names)
[16:05:53.607]                 removed <- setdiff(old_names, names)
[16:05:53.607]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:53.607]                   envs[common]]
[16:05:53.607]                 NAMES <- toupper(changed)
[16:05:53.607]                 args <- list()
[16:05:53.607]                 for (kk in seq_along(NAMES)) {
[16:05:53.607]                   name <- changed[[kk]]
[16:05:53.607]                   NAME <- NAMES[[kk]]
[16:05:53.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.607]                     next
[16:05:53.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.607]                 }
[16:05:53.607]                 NAMES <- toupper(added)
[16:05:53.607]                 for (kk in seq_along(NAMES)) {
[16:05:53.607]                   name <- added[[kk]]
[16:05:53.607]                   NAME <- NAMES[[kk]]
[16:05:53.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.607]                     next
[16:05:53.607]                   args[[name]] <- ""
[16:05:53.607]                 }
[16:05:53.607]                 NAMES <- toupper(removed)
[16:05:53.607]                 for (kk in seq_along(NAMES)) {
[16:05:53.607]                   name <- removed[[kk]]
[16:05:53.607]                   NAME <- NAMES[[kk]]
[16:05:53.607]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:53.607]                     next
[16:05:53.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:53.607]                 }
[16:05:53.607]                 if (length(args) > 0) 
[16:05:53.607]                   base::do.call(base::Sys.setenv, args = args)
[16:05:53.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:53.607]             }
[16:05:53.607]             else {
[16:05:53.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:53.607]             }
[16:05:53.607]             {
[16:05:53.607]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:53.607]                   0L) {
[16:05:53.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:53.607]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:53.607]                   base::options(opts)
[16:05:53.607]                 }
[16:05:53.607]                 {
[16:05:53.607]                   {
[16:05:53.607]                     NULL
[16:05:53.607]                     RNGkind("Mersenne-Twister")
[16:05:53.607]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:53.607]                       inherits = FALSE)
[16:05:53.607]                   }
[16:05:53.607]                   options(future.plan = NULL)
[16:05:53.607]                   if (is.na(NA_character_)) 
[16:05:53.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:53.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:53.607]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:53.607]                   {
[16:05:53.607]                     future <- SequentialFuture(..., envir = envir)
[16:05:53.607]                     if (!future$lazy) 
[16:05:53.607]                       future <- run(future)
[16:05:53.607]                     invisible(future)
[16:05:53.607]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:53.607]                 }
[16:05:53.607]             }
[16:05:53.607]         }
[16:05:53.607]     })
[16:05:53.607]     if (TRUE) {
[16:05:53.607]         base::sink(type = "output", split = FALSE)
[16:05:53.607]         if (TRUE) {
[16:05:53.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:53.607]         }
[16:05:53.607]         else {
[16:05:53.607]             ...future.result["stdout"] <- base::list(NULL)
[16:05:53.607]         }
[16:05:53.607]         base::close(...future.stdout)
[16:05:53.607]         ...future.stdout <- NULL
[16:05:53.607]     }
[16:05:53.607]     ...future.result$conditions <- ...future.conditions
[16:05:53.607]     ...future.result$finished <- base::Sys.time()
[16:05:53.607]     ...future.result
[16:05:53.607] }
[16:05:53.609] plan(): Setting new future strategy stack:
[16:05:53.609] List of future strategies:
[16:05:53.609] 1. sequential:
[16:05:53.609]    - args: function (..., envir = parent.frame())
[16:05:53.609]    - tweaked: FALSE
[16:05:53.609]    - call: NULL
[16:05:53.609] plan(): nbrOfWorkers() = 1
[16:05:54.111] plan(): Setting new future strategy stack:
[16:05:54.111] List of future strategies:
[16:05:54.111] 1. sequential:
[16:05:54.111]    - args: function (..., envir = parent.frame())
[16:05:54.111]    - tweaked: FALSE
[16:05:54.111]    - call: plan(strategy)
[16:05:54.111] plan(): nbrOfWorkers() = 1
[16:05:54.111] SequentialFuture started (and completed)
[16:05:54.111] - Launch lazy future ... done
[16:05:54.112] run() for ‘SequentialFuture’ ... done
[16:05:54.112] resolve() on list ...
[16:05:54.112]  recursive: 0
[16:05:54.112]  length: 1
[16:05:54.112] 
[16:05:54.112] resolved() for ‘SequentialFuture’ ...
[16:05:54.112] - state: ‘finished’
[16:05:54.113] - run: TRUE
[16:05:54.113] - result: ‘FutureResult’
[16:05:54.113] resolved() for ‘SequentialFuture’ ... done
[16:05:54.113] Future #1
[16:05:54.113]  length: 0 (resolved future 1)
[16:05:54.113] resolve() on list ... DONE
[16:05:54.113] resolved() for ‘SequentialFuture’ ...
[16:05:54.113] - state: ‘finished’
[16:05:54.113] - run: TRUE
[16:05:54.113] - result: ‘FutureResult’
[16:05:54.113] resolved() for ‘SequentialFuture’ ... done
[16:05:54.114] resolve() on list ...
[16:05:54.114]  recursive: 0
[16:05:54.114]  length: 1
[16:05:54.114] 
[16:05:54.114] resolved() for ‘SequentialFuture’ ...
[16:05:54.114] - state: ‘finished’
[16:05:54.114] - run: TRUE
[16:05:54.114] - result: ‘FutureResult’
[16:05:54.114] resolved() for ‘SequentialFuture’ ... done
[16:05:54.114] Future #1
[16:05:54.115]  length: 0 (resolved future 1)
[16:05:54.115] resolve() on list ... DONE
[16:05:54.115] resolved() for ‘SequentialFuture’ ...
[16:05:54.115] - state: ‘finished’
[16:05:54.115] - run: TRUE
[16:05:54.115] - result: ‘FutureResult’
[16:05:54.115] resolved() for ‘SequentialFuture’ ... done
[16:05:54.115] resolve() on list ...
[16:05:54.115]  recursive: 0
[16:05:54.115]  length: 1
[16:05:54.116] 
[16:05:54.116]  length: 0 (resolved future 1)
[16:05:54.116] resolve() on list ... DONE
[16:05:54.116] resolve() on list ...
[16:05:54.116]  recursive: 0
[16:05:54.116]  length: 4
[16:05:54.116] 
[16:05:54.116] resolved() for ‘SequentialFuture’ ...
[16:05:54.116] - state: ‘finished’
[16:05:54.116] - run: TRUE
[16:05:54.116] - result: ‘FutureResult’
[16:05:54.117] resolved() for ‘SequentialFuture’ ... done
[16:05:54.117] Future #1
[16:05:54.118]  length: 3 (resolved future 1)
[16:05:54.118] resolved() for ‘SequentialFuture’ ...
[16:05:54.118] - state: ‘finished’
[16:05:54.118] - run: TRUE
[16:05:54.119] - result: ‘FutureResult’
[16:05:54.119] resolved() for ‘SequentialFuture’ ... done
[16:05:54.119] Future #2
[16:05:54.119]  length: 2 (resolved future 2)
[16:05:54.119]  length: 1 (resolved future 3)
[16:05:54.119]  length: 0 (resolved future 4)
[16:05:54.119] resolve() on list ... DONE
[16:05:54.119] resolve() on list ...
[16:05:54.119]  recursive: 0
[16:05:54.119]  length: 4
[16:05:54.120] 
[16:05:54.120] resolved() for ‘SequentialFuture’ ...
[16:05:54.120] - state: ‘finished’
[16:05:54.120] - run: TRUE
[16:05:54.120] - result: ‘FutureResult’
[16:05:54.120] resolved() for ‘SequentialFuture’ ... done
[16:05:54.120] Future #1
[16:05:54.120]  length: 3 (resolved future 1)
[16:05:54.120] resolved() for ‘SequentialFuture’ ...
[16:05:54.120] - state: ‘finished’
[16:05:54.120] - run: TRUE
[16:05:54.121] - result: ‘FutureResult’
[16:05:54.121] resolved() for ‘SequentialFuture’ ... done
[16:05:54.121] Future #2
[16:05:54.121]  length: 2 (resolved future 2)
[16:05:54.121]  length: 1 (resolved future 3)
[16:05:54.121]  length: 0 (resolved future 4)
[16:05:54.121] resolve() on list ... DONE
[16:05:54.121] resolve() on list ...
[16:05:54.121]  recursive: 0
[16:05:54.122]  length: 1
[16:05:54.122] 
[16:05:54.122]  length: 0 (resolved future 1)
[16:05:54.122] resolve() on list ... DONE
[16:05:54.122] getGlobalsAndPackages() ...
[16:05:54.122] Searching for globals...
[16:05:54.123] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:54.123] Searching for globals ... DONE
[16:05:54.123] Resolving globals: FALSE
[16:05:54.124] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:54.124] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:54.124] - globals: [1] ‘kk’
[16:05:54.125] 
[16:05:54.125] getGlobalsAndPackages() ... DONE
[16:05:54.125] run() for ‘Future’ ...
[16:05:54.125] - state: ‘created’
[16:05:54.125] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.125] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.125] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.125]   - Field: ‘label’
[16:05:54.126]   - Field: ‘local’
[16:05:54.126]   - Field: ‘owner’
[16:05:54.126]   - Field: ‘envir’
[16:05:54.126]   - Field: ‘packages’
[16:05:54.126]   - Field: ‘gc’
[16:05:54.126]   - Field: ‘conditions’
[16:05:54.126]   - Field: ‘expr’
[16:05:54.126]   - Field: ‘uuid’
[16:05:54.126]   - Field: ‘seed’
[16:05:54.126]   - Field: ‘version’
[16:05:54.126]   - Field: ‘result’
[16:05:54.127]   - Field: ‘asynchronous’
[16:05:54.127]   - Field: ‘calls’
[16:05:54.127]   - Field: ‘globals’
[16:05:54.127]   - Field: ‘stdout’
[16:05:54.127]   - Field: ‘earlySignal’
[16:05:54.127]   - Field: ‘lazy’
[16:05:54.127]   - Field: ‘state’
[16:05:54.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.127] - Launch lazy future ...
[16:05:54.127] Packages needed by the future expression (n = 0): <none>
[16:05:54.128] Packages needed by future strategies (n = 0): <none>
[16:05:54.128] {
[16:05:54.128]     {
[16:05:54.128]         {
[16:05:54.128]             ...future.startTime <- base::Sys.time()
[16:05:54.128]             {
[16:05:54.128]                 {
[16:05:54.128]                   {
[16:05:54.128]                     base::local({
[16:05:54.128]                       has_future <- base::requireNamespace("future", 
[16:05:54.128]                         quietly = TRUE)
[16:05:54.128]                       if (has_future) {
[16:05:54.128]                         ns <- base::getNamespace("future")
[16:05:54.128]                         version <- ns[[".package"]][["version"]]
[16:05:54.128]                         if (is.null(version)) 
[16:05:54.128]                           version <- utils::packageVersion("future")
[16:05:54.128]                       }
[16:05:54.128]                       else {
[16:05:54.128]                         version <- NULL
[16:05:54.128]                       }
[16:05:54.128]                       if (!has_future || version < "1.8.0") {
[16:05:54.128]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.128]                           "", base::R.version$version.string), 
[16:05:54.128]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.128]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.128]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.128]                             "release", "version")], collapse = " "), 
[16:05:54.128]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.128]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.128]                           info)
[16:05:54.128]                         info <- base::paste(info, collapse = "; ")
[16:05:54.128]                         if (!has_future) {
[16:05:54.128]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.128]                             info)
[16:05:54.128]                         }
[16:05:54.128]                         else {
[16:05:54.128]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.128]                             info, version)
[16:05:54.128]                         }
[16:05:54.128]                         base::stop(msg)
[16:05:54.128]                       }
[16:05:54.128]                     })
[16:05:54.128]                   }
[16:05:54.128]                   options(future.plan = NULL)
[16:05:54.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.128]                 }
[16:05:54.128]                 ...future.workdir <- getwd()
[16:05:54.128]             }
[16:05:54.128]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.128]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.128]         }
[16:05:54.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.128]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.128]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.128]             base::names(...future.oldOptions))
[16:05:54.128]     }
[16:05:54.128]     if (FALSE) {
[16:05:54.128]     }
[16:05:54.128]     else {
[16:05:54.128]         if (TRUE) {
[16:05:54.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.128]                 open = "w")
[16:05:54.128]         }
[16:05:54.128]         else {
[16:05:54.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.128]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.128]         }
[16:05:54.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.128]             base::sink(type = "output", split = FALSE)
[16:05:54.128]             base::close(...future.stdout)
[16:05:54.128]         }, add = TRUE)
[16:05:54.128]     }
[16:05:54.128]     ...future.frame <- base::sys.nframe()
[16:05:54.128]     ...future.conditions <- base::list()
[16:05:54.128]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.128]     if (FALSE) {
[16:05:54.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.128]     }
[16:05:54.128]     ...future.result <- base::tryCatch({
[16:05:54.128]         base::withCallingHandlers({
[16:05:54.128]             ...future.value <- base::withVisible(base::local({
[16:05:54.128]                 Sys.sleep(0.1)
[16:05:54.128]                 kk
[16:05:54.128]             }))
[16:05:54.128]             future::FutureResult(value = ...future.value$value, 
[16:05:54.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.128]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.128]                     ...future.globalenv.names))
[16:05:54.128]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.128]         }, condition = base::local({
[16:05:54.128]             c <- base::c
[16:05:54.128]             inherits <- base::inherits
[16:05:54.128]             invokeRestart <- base::invokeRestart
[16:05:54.128]             length <- base::length
[16:05:54.128]             list <- base::list
[16:05:54.128]             seq.int <- base::seq.int
[16:05:54.128]             signalCondition <- base::signalCondition
[16:05:54.128]             sys.calls <- base::sys.calls
[16:05:54.128]             `[[` <- base::`[[`
[16:05:54.128]             `+` <- base::`+`
[16:05:54.128]             `<<-` <- base::`<<-`
[16:05:54.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.128]                   3L)]
[16:05:54.128]             }
[16:05:54.128]             function(cond) {
[16:05:54.128]                 is_error <- inherits(cond, "error")
[16:05:54.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.128]                   NULL)
[16:05:54.128]                 if (is_error) {
[16:05:54.128]                   sessionInformation <- function() {
[16:05:54.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.128]                       search = base::search(), system = base::Sys.info())
[16:05:54.128]                   }
[16:05:54.128]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.128]                     cond$call), session = sessionInformation(), 
[16:05:54.128]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.128]                   signalCondition(cond)
[16:05:54.128]                 }
[16:05:54.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.128]                 "immediateCondition"))) {
[16:05:54.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.128]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.128]                   if (TRUE && !signal) {
[16:05:54.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.128]                     {
[16:05:54.128]                       inherits <- base::inherits
[16:05:54.128]                       invokeRestart <- base::invokeRestart
[16:05:54.128]                       is.null <- base::is.null
[16:05:54.128]                       muffled <- FALSE
[16:05:54.128]                       if (inherits(cond, "message")) {
[16:05:54.128]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.128]                         if (muffled) 
[16:05:54.128]                           invokeRestart("muffleMessage")
[16:05:54.128]                       }
[16:05:54.128]                       else if (inherits(cond, "warning")) {
[16:05:54.128]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.128]                         if (muffled) 
[16:05:54.128]                           invokeRestart("muffleWarning")
[16:05:54.128]                       }
[16:05:54.128]                       else if (inherits(cond, "condition")) {
[16:05:54.128]                         if (!is.null(pattern)) {
[16:05:54.128]                           computeRestarts <- base::computeRestarts
[16:05:54.128]                           grepl <- base::grepl
[16:05:54.128]                           restarts <- computeRestarts(cond)
[16:05:54.128]                           for (restart in restarts) {
[16:05:54.128]                             name <- restart$name
[16:05:54.128]                             if (is.null(name)) 
[16:05:54.128]                               next
[16:05:54.128]                             if (!grepl(pattern, name)) 
[16:05:54.128]                               next
[16:05:54.128]                             invokeRestart(restart)
[16:05:54.128]                             muffled <- TRUE
[16:05:54.128]                             break
[16:05:54.128]                           }
[16:05:54.128]                         }
[16:05:54.128]                       }
[16:05:54.128]                       invisible(muffled)
[16:05:54.128]                     }
[16:05:54.128]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.128]                   }
[16:05:54.128]                 }
[16:05:54.128]                 else {
[16:05:54.128]                   if (TRUE) {
[16:05:54.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.128]                     {
[16:05:54.128]                       inherits <- base::inherits
[16:05:54.128]                       invokeRestart <- base::invokeRestart
[16:05:54.128]                       is.null <- base::is.null
[16:05:54.128]                       muffled <- FALSE
[16:05:54.128]                       if (inherits(cond, "message")) {
[16:05:54.128]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.128]                         if (muffled) 
[16:05:54.128]                           invokeRestart("muffleMessage")
[16:05:54.128]                       }
[16:05:54.128]                       else if (inherits(cond, "warning")) {
[16:05:54.128]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.128]                         if (muffled) 
[16:05:54.128]                           invokeRestart("muffleWarning")
[16:05:54.128]                       }
[16:05:54.128]                       else if (inherits(cond, "condition")) {
[16:05:54.128]                         if (!is.null(pattern)) {
[16:05:54.128]                           computeRestarts <- base::computeRestarts
[16:05:54.128]                           grepl <- base::grepl
[16:05:54.128]                           restarts <- computeRestarts(cond)
[16:05:54.128]                           for (restart in restarts) {
[16:05:54.128]                             name <- restart$name
[16:05:54.128]                             if (is.null(name)) 
[16:05:54.128]                               next
[16:05:54.128]                             if (!grepl(pattern, name)) 
[16:05:54.128]                               next
[16:05:54.128]                             invokeRestart(restart)
[16:05:54.128]                             muffled <- TRUE
[16:05:54.128]                             break
[16:05:54.128]                           }
[16:05:54.128]                         }
[16:05:54.128]                       }
[16:05:54.128]                       invisible(muffled)
[16:05:54.128]                     }
[16:05:54.128]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.128]                   }
[16:05:54.128]                 }
[16:05:54.128]             }
[16:05:54.128]         }))
[16:05:54.128]     }, error = function(ex) {
[16:05:54.128]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.128]                 ...future.rng), started = ...future.startTime, 
[16:05:54.128]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.128]             version = "1.8"), class = "FutureResult")
[16:05:54.128]     }, finally = {
[16:05:54.128]         if (!identical(...future.workdir, getwd())) 
[16:05:54.128]             setwd(...future.workdir)
[16:05:54.128]         {
[16:05:54.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.128]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.128]             }
[16:05:54.128]             base::options(...future.oldOptions)
[16:05:54.128]             if (.Platform$OS.type == "windows") {
[16:05:54.128]                 old_names <- names(...future.oldEnvVars)
[16:05:54.128]                 envs <- base::Sys.getenv()
[16:05:54.128]                 names <- names(envs)
[16:05:54.128]                 common <- intersect(names, old_names)
[16:05:54.128]                 added <- setdiff(names, old_names)
[16:05:54.128]                 removed <- setdiff(old_names, names)
[16:05:54.128]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.128]                   envs[common]]
[16:05:54.128]                 NAMES <- toupper(changed)
[16:05:54.128]                 args <- list()
[16:05:54.128]                 for (kk in seq_along(NAMES)) {
[16:05:54.128]                   name <- changed[[kk]]
[16:05:54.128]                   NAME <- NAMES[[kk]]
[16:05:54.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.128]                     next
[16:05:54.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.128]                 }
[16:05:54.128]                 NAMES <- toupper(added)
[16:05:54.128]                 for (kk in seq_along(NAMES)) {
[16:05:54.128]                   name <- added[[kk]]
[16:05:54.128]                   NAME <- NAMES[[kk]]
[16:05:54.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.128]                     next
[16:05:54.128]                   args[[name]] <- ""
[16:05:54.128]                 }
[16:05:54.128]                 NAMES <- toupper(removed)
[16:05:54.128]                 for (kk in seq_along(NAMES)) {
[16:05:54.128]                   name <- removed[[kk]]
[16:05:54.128]                   NAME <- NAMES[[kk]]
[16:05:54.128]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.128]                     next
[16:05:54.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.128]                 }
[16:05:54.128]                 if (length(args) > 0) 
[16:05:54.128]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.128]             }
[16:05:54.128]             else {
[16:05:54.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.128]             }
[16:05:54.128]             {
[16:05:54.128]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.128]                   0L) {
[16:05:54.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.128]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.128]                   base::options(opts)
[16:05:54.128]                 }
[16:05:54.128]                 {
[16:05:54.128]                   {
[16:05:54.128]                     NULL
[16:05:54.128]                     RNGkind("Mersenne-Twister")
[16:05:54.128]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.128]                       inherits = FALSE)
[16:05:54.128]                   }
[16:05:54.128]                   options(future.plan = NULL)
[16:05:54.128]                   if (is.na(NA_character_)) 
[16:05:54.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.128]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.128]                   {
[16:05:54.128]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.128]                     if (!future$lazy) 
[16:05:54.128]                       future <- run(future)
[16:05:54.128]                     invisible(future)
[16:05:54.128]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.128]                 }
[16:05:54.128]             }
[16:05:54.128]         }
[16:05:54.128]     })
[16:05:54.128]     if (TRUE) {
[16:05:54.128]         base::sink(type = "output", split = FALSE)
[16:05:54.128]         if (TRUE) {
[16:05:54.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.128]         }
[16:05:54.128]         else {
[16:05:54.128]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.128]         }
[16:05:54.128]         base::close(...future.stdout)
[16:05:54.128]         ...future.stdout <- NULL
[16:05:54.128]     }
[16:05:54.128]     ...future.result$conditions <- ...future.conditions
[16:05:54.128]     ...future.result$finished <- base::Sys.time()
[16:05:54.128]     ...future.result
[16:05:54.128] }
[16:05:54.130] assign_globals() ...
[16:05:54.130] List of 1
[16:05:54.130]  $ kk: int 1
[16:05:54.130]  - attr(*, "where")=List of 1
[16:05:54.130]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:54.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:54.130]  - attr(*, "resolved")= logi FALSE
[16:05:54.130]  - attr(*, "total_size")= num 56
[16:05:54.130]  - attr(*, "already-done")= logi TRUE
[16:05:54.134] - copied ‘kk’ to environment
[16:05:54.134] assign_globals() ... done
[16:05:54.135] plan(): Setting new future strategy stack:
[16:05:54.135] List of future strategies:
[16:05:54.135] 1. sequential:
[16:05:54.135]    - args: function (..., envir = parent.frame())
[16:05:54.135]    - tweaked: FALSE
[16:05:54.135]    - call: NULL
[16:05:54.135] plan(): nbrOfWorkers() = 1
[16:05:54.236] plan(): Setting new future strategy stack:
[16:05:54.236] List of future strategies:
[16:05:54.236] 1. sequential:
[16:05:54.236]    - args: function (..., envir = parent.frame())
[16:05:54.236]    - tweaked: FALSE
[16:05:54.236]    - call: plan(strategy)
[16:05:54.237] plan(): nbrOfWorkers() = 1
[16:05:54.237] SequentialFuture started (and completed)
[16:05:54.237] - Launch lazy future ... done
[16:05:54.237] run() for ‘SequentialFuture’ ... done
[16:05:54.237] getGlobalsAndPackages() ...
[16:05:54.237] Searching for globals...
[16:05:54.238] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:54.238] Searching for globals ... DONE
[16:05:54.238] Resolving globals: FALSE
[16:05:54.239] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:54.239] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:54.239] - globals: [1] ‘kk’
[16:05:54.239] 
[16:05:54.239] getGlobalsAndPackages() ... DONE
[16:05:54.239] run() for ‘Future’ ...
[16:05:54.239] - state: ‘created’
[16:05:54.240] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.240] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.240]   - Field: ‘label’
[16:05:54.240]   - Field: ‘local’
[16:05:54.240]   - Field: ‘owner’
[16:05:54.240]   - Field: ‘envir’
[16:05:54.240]   - Field: ‘packages’
[16:05:54.240]   - Field: ‘gc’
[16:05:54.241]   - Field: ‘conditions’
[16:05:54.241]   - Field: ‘expr’
[16:05:54.241]   - Field: ‘uuid’
[16:05:54.241]   - Field: ‘seed’
[16:05:54.241]   - Field: ‘version’
[16:05:54.241]   - Field: ‘result’
[16:05:54.241]   - Field: ‘asynchronous’
[16:05:54.241]   - Field: ‘calls’
[16:05:54.241]   - Field: ‘globals’
[16:05:54.241]   - Field: ‘stdout’
[16:05:54.241]   - Field: ‘earlySignal’
[16:05:54.241]   - Field: ‘lazy’
[16:05:54.242]   - Field: ‘state’
[16:05:54.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.242] - Launch lazy future ...
[16:05:54.242] Packages needed by the future expression (n = 0): <none>
[16:05:54.242] Packages needed by future strategies (n = 0): <none>
[16:05:54.242] {
[16:05:54.242]     {
[16:05:54.242]         {
[16:05:54.242]             ...future.startTime <- base::Sys.time()
[16:05:54.242]             {
[16:05:54.242]                 {
[16:05:54.242]                   {
[16:05:54.242]                     base::local({
[16:05:54.242]                       has_future <- base::requireNamespace("future", 
[16:05:54.242]                         quietly = TRUE)
[16:05:54.242]                       if (has_future) {
[16:05:54.242]                         ns <- base::getNamespace("future")
[16:05:54.242]                         version <- ns[[".package"]][["version"]]
[16:05:54.242]                         if (is.null(version)) 
[16:05:54.242]                           version <- utils::packageVersion("future")
[16:05:54.242]                       }
[16:05:54.242]                       else {
[16:05:54.242]                         version <- NULL
[16:05:54.242]                       }
[16:05:54.242]                       if (!has_future || version < "1.8.0") {
[16:05:54.242]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.242]                           "", base::R.version$version.string), 
[16:05:54.242]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.242]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.242]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.242]                             "release", "version")], collapse = " "), 
[16:05:54.242]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.242]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.242]                           info)
[16:05:54.242]                         info <- base::paste(info, collapse = "; ")
[16:05:54.242]                         if (!has_future) {
[16:05:54.242]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.242]                             info)
[16:05:54.242]                         }
[16:05:54.242]                         else {
[16:05:54.242]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.242]                             info, version)
[16:05:54.242]                         }
[16:05:54.242]                         base::stop(msg)
[16:05:54.242]                       }
[16:05:54.242]                     })
[16:05:54.242]                   }
[16:05:54.242]                   options(future.plan = NULL)
[16:05:54.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.242]                 }
[16:05:54.242]                 ...future.workdir <- getwd()
[16:05:54.242]             }
[16:05:54.242]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.242]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.242]         }
[16:05:54.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.242]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.242]             base::names(...future.oldOptions))
[16:05:54.242]     }
[16:05:54.242]     if (FALSE) {
[16:05:54.242]     }
[16:05:54.242]     else {
[16:05:54.242]         if (TRUE) {
[16:05:54.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.242]                 open = "w")
[16:05:54.242]         }
[16:05:54.242]         else {
[16:05:54.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.242]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.242]         }
[16:05:54.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.242]             base::sink(type = "output", split = FALSE)
[16:05:54.242]             base::close(...future.stdout)
[16:05:54.242]         }, add = TRUE)
[16:05:54.242]     }
[16:05:54.242]     ...future.frame <- base::sys.nframe()
[16:05:54.242]     ...future.conditions <- base::list()
[16:05:54.242]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.242]     if (FALSE) {
[16:05:54.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.242]     }
[16:05:54.242]     ...future.result <- base::tryCatch({
[16:05:54.242]         base::withCallingHandlers({
[16:05:54.242]             ...future.value <- base::withVisible(base::local({
[16:05:54.242]                 Sys.sleep(0.1)
[16:05:54.242]                 kk
[16:05:54.242]             }))
[16:05:54.242]             future::FutureResult(value = ...future.value$value, 
[16:05:54.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.242]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.242]                     ...future.globalenv.names))
[16:05:54.242]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.242]         }, condition = base::local({
[16:05:54.242]             c <- base::c
[16:05:54.242]             inherits <- base::inherits
[16:05:54.242]             invokeRestart <- base::invokeRestart
[16:05:54.242]             length <- base::length
[16:05:54.242]             list <- base::list
[16:05:54.242]             seq.int <- base::seq.int
[16:05:54.242]             signalCondition <- base::signalCondition
[16:05:54.242]             sys.calls <- base::sys.calls
[16:05:54.242]             `[[` <- base::`[[`
[16:05:54.242]             `+` <- base::`+`
[16:05:54.242]             `<<-` <- base::`<<-`
[16:05:54.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.242]                   3L)]
[16:05:54.242]             }
[16:05:54.242]             function(cond) {
[16:05:54.242]                 is_error <- inherits(cond, "error")
[16:05:54.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.242]                   NULL)
[16:05:54.242]                 if (is_error) {
[16:05:54.242]                   sessionInformation <- function() {
[16:05:54.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.242]                       search = base::search(), system = base::Sys.info())
[16:05:54.242]                   }
[16:05:54.242]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.242]                     cond$call), session = sessionInformation(), 
[16:05:54.242]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.242]                   signalCondition(cond)
[16:05:54.242]                 }
[16:05:54.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.242]                 "immediateCondition"))) {
[16:05:54.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.242]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.242]                   if (TRUE && !signal) {
[16:05:54.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.242]                     {
[16:05:54.242]                       inherits <- base::inherits
[16:05:54.242]                       invokeRestart <- base::invokeRestart
[16:05:54.242]                       is.null <- base::is.null
[16:05:54.242]                       muffled <- FALSE
[16:05:54.242]                       if (inherits(cond, "message")) {
[16:05:54.242]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.242]                         if (muffled) 
[16:05:54.242]                           invokeRestart("muffleMessage")
[16:05:54.242]                       }
[16:05:54.242]                       else if (inherits(cond, "warning")) {
[16:05:54.242]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.242]                         if (muffled) 
[16:05:54.242]                           invokeRestart("muffleWarning")
[16:05:54.242]                       }
[16:05:54.242]                       else if (inherits(cond, "condition")) {
[16:05:54.242]                         if (!is.null(pattern)) {
[16:05:54.242]                           computeRestarts <- base::computeRestarts
[16:05:54.242]                           grepl <- base::grepl
[16:05:54.242]                           restarts <- computeRestarts(cond)
[16:05:54.242]                           for (restart in restarts) {
[16:05:54.242]                             name <- restart$name
[16:05:54.242]                             if (is.null(name)) 
[16:05:54.242]                               next
[16:05:54.242]                             if (!grepl(pattern, name)) 
[16:05:54.242]                               next
[16:05:54.242]                             invokeRestart(restart)
[16:05:54.242]                             muffled <- TRUE
[16:05:54.242]                             break
[16:05:54.242]                           }
[16:05:54.242]                         }
[16:05:54.242]                       }
[16:05:54.242]                       invisible(muffled)
[16:05:54.242]                     }
[16:05:54.242]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.242]                   }
[16:05:54.242]                 }
[16:05:54.242]                 else {
[16:05:54.242]                   if (TRUE) {
[16:05:54.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.242]                     {
[16:05:54.242]                       inherits <- base::inherits
[16:05:54.242]                       invokeRestart <- base::invokeRestart
[16:05:54.242]                       is.null <- base::is.null
[16:05:54.242]                       muffled <- FALSE
[16:05:54.242]                       if (inherits(cond, "message")) {
[16:05:54.242]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.242]                         if (muffled) 
[16:05:54.242]                           invokeRestart("muffleMessage")
[16:05:54.242]                       }
[16:05:54.242]                       else if (inherits(cond, "warning")) {
[16:05:54.242]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.242]                         if (muffled) 
[16:05:54.242]                           invokeRestart("muffleWarning")
[16:05:54.242]                       }
[16:05:54.242]                       else if (inherits(cond, "condition")) {
[16:05:54.242]                         if (!is.null(pattern)) {
[16:05:54.242]                           computeRestarts <- base::computeRestarts
[16:05:54.242]                           grepl <- base::grepl
[16:05:54.242]                           restarts <- computeRestarts(cond)
[16:05:54.242]                           for (restart in restarts) {
[16:05:54.242]                             name <- restart$name
[16:05:54.242]                             if (is.null(name)) 
[16:05:54.242]                               next
[16:05:54.242]                             if (!grepl(pattern, name)) 
[16:05:54.242]                               next
[16:05:54.242]                             invokeRestart(restart)
[16:05:54.242]                             muffled <- TRUE
[16:05:54.242]                             break
[16:05:54.242]                           }
[16:05:54.242]                         }
[16:05:54.242]                       }
[16:05:54.242]                       invisible(muffled)
[16:05:54.242]                     }
[16:05:54.242]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.242]                   }
[16:05:54.242]                 }
[16:05:54.242]             }
[16:05:54.242]         }))
[16:05:54.242]     }, error = function(ex) {
[16:05:54.242]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.242]                 ...future.rng), started = ...future.startTime, 
[16:05:54.242]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.242]             version = "1.8"), class = "FutureResult")
[16:05:54.242]     }, finally = {
[16:05:54.242]         if (!identical(...future.workdir, getwd())) 
[16:05:54.242]             setwd(...future.workdir)
[16:05:54.242]         {
[16:05:54.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.242]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.242]             }
[16:05:54.242]             base::options(...future.oldOptions)
[16:05:54.242]             if (.Platform$OS.type == "windows") {
[16:05:54.242]                 old_names <- names(...future.oldEnvVars)
[16:05:54.242]                 envs <- base::Sys.getenv()
[16:05:54.242]                 names <- names(envs)
[16:05:54.242]                 common <- intersect(names, old_names)
[16:05:54.242]                 added <- setdiff(names, old_names)
[16:05:54.242]                 removed <- setdiff(old_names, names)
[16:05:54.242]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.242]                   envs[common]]
[16:05:54.242]                 NAMES <- toupper(changed)
[16:05:54.242]                 args <- list()
[16:05:54.242]                 for (kk in seq_along(NAMES)) {
[16:05:54.242]                   name <- changed[[kk]]
[16:05:54.242]                   NAME <- NAMES[[kk]]
[16:05:54.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.242]                     next
[16:05:54.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.242]                 }
[16:05:54.242]                 NAMES <- toupper(added)
[16:05:54.242]                 for (kk in seq_along(NAMES)) {
[16:05:54.242]                   name <- added[[kk]]
[16:05:54.242]                   NAME <- NAMES[[kk]]
[16:05:54.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.242]                     next
[16:05:54.242]                   args[[name]] <- ""
[16:05:54.242]                 }
[16:05:54.242]                 NAMES <- toupper(removed)
[16:05:54.242]                 for (kk in seq_along(NAMES)) {
[16:05:54.242]                   name <- removed[[kk]]
[16:05:54.242]                   NAME <- NAMES[[kk]]
[16:05:54.242]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.242]                     next
[16:05:54.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.242]                 }
[16:05:54.242]                 if (length(args) > 0) 
[16:05:54.242]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.242]             }
[16:05:54.242]             else {
[16:05:54.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.242]             }
[16:05:54.242]             {
[16:05:54.242]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.242]                   0L) {
[16:05:54.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.242]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.242]                   base::options(opts)
[16:05:54.242]                 }
[16:05:54.242]                 {
[16:05:54.242]                   {
[16:05:54.242]                     NULL
[16:05:54.242]                     RNGkind("Mersenne-Twister")
[16:05:54.242]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.242]                       inherits = FALSE)
[16:05:54.242]                   }
[16:05:54.242]                   options(future.plan = NULL)
[16:05:54.242]                   if (is.na(NA_character_)) 
[16:05:54.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.242]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.242]                   {
[16:05:54.242]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.242]                     if (!future$lazy) 
[16:05:54.242]                       future <- run(future)
[16:05:54.242]                     invisible(future)
[16:05:54.242]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.242]                 }
[16:05:54.242]             }
[16:05:54.242]         }
[16:05:54.242]     })
[16:05:54.242]     if (TRUE) {
[16:05:54.242]         base::sink(type = "output", split = FALSE)
[16:05:54.242]         if (TRUE) {
[16:05:54.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.242]         }
[16:05:54.242]         else {
[16:05:54.242]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.242]         }
[16:05:54.242]         base::close(...future.stdout)
[16:05:54.242]         ...future.stdout <- NULL
[16:05:54.242]     }
[16:05:54.242]     ...future.result$conditions <- ...future.conditions
[16:05:54.242]     ...future.result$finished <- base::Sys.time()
[16:05:54.242]     ...future.result
[16:05:54.242] }
[16:05:54.244] assign_globals() ...
[16:05:54.244] List of 1
[16:05:54.244]  $ kk: int 2
[16:05:54.244]  - attr(*, "where")=List of 1
[16:05:54.244]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:54.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:54.244]  - attr(*, "resolved")= logi FALSE
[16:05:54.244]  - attr(*, "total_size")= num 56
[16:05:54.244]  - attr(*, "already-done")= logi TRUE
[16:05:54.246] - copied ‘kk’ to environment
[16:05:54.248] assign_globals() ... done
[16:05:54.248] plan(): Setting new future strategy stack:
[16:05:54.248] List of future strategies:
[16:05:54.248] 1. sequential:
[16:05:54.248]    - args: function (..., envir = parent.frame())
[16:05:54.248]    - tweaked: FALSE
[16:05:54.248]    - call: NULL
[16:05:54.248] plan(): nbrOfWorkers() = 1
[16:05:54.349] plan(): Setting new future strategy stack:
[16:05:54.349] List of future strategies:
[16:05:54.349] 1. sequential:
[16:05:54.349]    - args: function (..., envir = parent.frame())
[16:05:54.349]    - tweaked: FALSE
[16:05:54.349]    - call: plan(strategy)
[16:05:54.350] plan(): nbrOfWorkers() = 1
[16:05:54.350] SequentialFuture started (and completed)
[16:05:54.350] - Launch lazy future ... done
[16:05:54.350] run() for ‘SequentialFuture’ ... done
[16:05:54.350] getGlobalsAndPackages() ...
[16:05:54.350] Searching for globals...
[16:05:54.351] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:54.352] Searching for globals ... DONE
[16:05:54.352] Resolving globals: FALSE
[16:05:54.352] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:54.352] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:54.352] - globals: [1] ‘kk’
[16:05:54.352] 
[16:05:54.353] getGlobalsAndPackages() ... DONE
[16:05:54.353] run() for ‘Future’ ...
[16:05:54.353] - state: ‘created’
[16:05:54.353] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.353] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.353] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.353]   - Field: ‘label’
[16:05:54.353]   - Field: ‘local’
[16:05:54.354]   - Field: ‘owner’
[16:05:54.354]   - Field: ‘envir’
[16:05:54.354]   - Field: ‘packages’
[16:05:54.354]   - Field: ‘gc’
[16:05:54.354]   - Field: ‘conditions’
[16:05:54.354]   - Field: ‘expr’
[16:05:54.354]   - Field: ‘uuid’
[16:05:54.354]   - Field: ‘seed’
[16:05:54.354]   - Field: ‘version’
[16:05:54.354]   - Field: ‘result’
[16:05:54.354]   - Field: ‘asynchronous’
[16:05:54.355]   - Field: ‘calls’
[16:05:54.355]   - Field: ‘globals’
[16:05:54.355]   - Field: ‘stdout’
[16:05:54.355]   - Field: ‘earlySignal’
[16:05:54.355]   - Field: ‘lazy’
[16:05:54.355]   - Field: ‘state’
[16:05:54.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.355] - Launch lazy future ...
[16:05:54.355] Packages needed by the future expression (n = 0): <none>
[16:05:54.355] Packages needed by future strategies (n = 0): <none>
[16:05:54.356] {
[16:05:54.356]     {
[16:05:54.356]         {
[16:05:54.356]             ...future.startTime <- base::Sys.time()
[16:05:54.356]             {
[16:05:54.356]                 {
[16:05:54.356]                   {
[16:05:54.356]                     base::local({
[16:05:54.356]                       has_future <- base::requireNamespace("future", 
[16:05:54.356]                         quietly = TRUE)
[16:05:54.356]                       if (has_future) {
[16:05:54.356]                         ns <- base::getNamespace("future")
[16:05:54.356]                         version <- ns[[".package"]][["version"]]
[16:05:54.356]                         if (is.null(version)) 
[16:05:54.356]                           version <- utils::packageVersion("future")
[16:05:54.356]                       }
[16:05:54.356]                       else {
[16:05:54.356]                         version <- NULL
[16:05:54.356]                       }
[16:05:54.356]                       if (!has_future || version < "1.8.0") {
[16:05:54.356]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.356]                           "", base::R.version$version.string), 
[16:05:54.356]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.356]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.356]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.356]                             "release", "version")], collapse = " "), 
[16:05:54.356]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.356]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.356]                           info)
[16:05:54.356]                         info <- base::paste(info, collapse = "; ")
[16:05:54.356]                         if (!has_future) {
[16:05:54.356]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.356]                             info)
[16:05:54.356]                         }
[16:05:54.356]                         else {
[16:05:54.356]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.356]                             info, version)
[16:05:54.356]                         }
[16:05:54.356]                         base::stop(msg)
[16:05:54.356]                       }
[16:05:54.356]                     })
[16:05:54.356]                   }
[16:05:54.356]                   options(future.plan = NULL)
[16:05:54.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.356]                 }
[16:05:54.356]                 ...future.workdir <- getwd()
[16:05:54.356]             }
[16:05:54.356]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.356]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.356]         }
[16:05:54.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.356]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.356]             base::names(...future.oldOptions))
[16:05:54.356]     }
[16:05:54.356]     if (FALSE) {
[16:05:54.356]     }
[16:05:54.356]     else {
[16:05:54.356]         if (TRUE) {
[16:05:54.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.356]                 open = "w")
[16:05:54.356]         }
[16:05:54.356]         else {
[16:05:54.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.356]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.356]         }
[16:05:54.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.356]             base::sink(type = "output", split = FALSE)
[16:05:54.356]             base::close(...future.stdout)
[16:05:54.356]         }, add = TRUE)
[16:05:54.356]     }
[16:05:54.356]     ...future.frame <- base::sys.nframe()
[16:05:54.356]     ...future.conditions <- base::list()
[16:05:54.356]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.356]     if (FALSE) {
[16:05:54.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.356]     }
[16:05:54.356]     ...future.result <- base::tryCatch({
[16:05:54.356]         base::withCallingHandlers({
[16:05:54.356]             ...future.value <- base::withVisible(base::local({
[16:05:54.356]                 Sys.sleep(0.1)
[16:05:54.356]                 kk
[16:05:54.356]             }))
[16:05:54.356]             future::FutureResult(value = ...future.value$value, 
[16:05:54.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.356]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.356]                     ...future.globalenv.names))
[16:05:54.356]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.356]         }, condition = base::local({
[16:05:54.356]             c <- base::c
[16:05:54.356]             inherits <- base::inherits
[16:05:54.356]             invokeRestart <- base::invokeRestart
[16:05:54.356]             length <- base::length
[16:05:54.356]             list <- base::list
[16:05:54.356]             seq.int <- base::seq.int
[16:05:54.356]             signalCondition <- base::signalCondition
[16:05:54.356]             sys.calls <- base::sys.calls
[16:05:54.356]             `[[` <- base::`[[`
[16:05:54.356]             `+` <- base::`+`
[16:05:54.356]             `<<-` <- base::`<<-`
[16:05:54.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.356]                   3L)]
[16:05:54.356]             }
[16:05:54.356]             function(cond) {
[16:05:54.356]                 is_error <- inherits(cond, "error")
[16:05:54.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.356]                   NULL)
[16:05:54.356]                 if (is_error) {
[16:05:54.356]                   sessionInformation <- function() {
[16:05:54.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.356]                       search = base::search(), system = base::Sys.info())
[16:05:54.356]                   }
[16:05:54.356]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.356]                     cond$call), session = sessionInformation(), 
[16:05:54.356]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.356]                   signalCondition(cond)
[16:05:54.356]                 }
[16:05:54.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.356]                 "immediateCondition"))) {
[16:05:54.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.356]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.356]                   if (TRUE && !signal) {
[16:05:54.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.356]                     {
[16:05:54.356]                       inherits <- base::inherits
[16:05:54.356]                       invokeRestart <- base::invokeRestart
[16:05:54.356]                       is.null <- base::is.null
[16:05:54.356]                       muffled <- FALSE
[16:05:54.356]                       if (inherits(cond, "message")) {
[16:05:54.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.356]                         if (muffled) 
[16:05:54.356]                           invokeRestart("muffleMessage")
[16:05:54.356]                       }
[16:05:54.356]                       else if (inherits(cond, "warning")) {
[16:05:54.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.356]                         if (muffled) 
[16:05:54.356]                           invokeRestart("muffleWarning")
[16:05:54.356]                       }
[16:05:54.356]                       else if (inherits(cond, "condition")) {
[16:05:54.356]                         if (!is.null(pattern)) {
[16:05:54.356]                           computeRestarts <- base::computeRestarts
[16:05:54.356]                           grepl <- base::grepl
[16:05:54.356]                           restarts <- computeRestarts(cond)
[16:05:54.356]                           for (restart in restarts) {
[16:05:54.356]                             name <- restart$name
[16:05:54.356]                             if (is.null(name)) 
[16:05:54.356]                               next
[16:05:54.356]                             if (!grepl(pattern, name)) 
[16:05:54.356]                               next
[16:05:54.356]                             invokeRestart(restart)
[16:05:54.356]                             muffled <- TRUE
[16:05:54.356]                             break
[16:05:54.356]                           }
[16:05:54.356]                         }
[16:05:54.356]                       }
[16:05:54.356]                       invisible(muffled)
[16:05:54.356]                     }
[16:05:54.356]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.356]                   }
[16:05:54.356]                 }
[16:05:54.356]                 else {
[16:05:54.356]                   if (TRUE) {
[16:05:54.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.356]                     {
[16:05:54.356]                       inherits <- base::inherits
[16:05:54.356]                       invokeRestart <- base::invokeRestart
[16:05:54.356]                       is.null <- base::is.null
[16:05:54.356]                       muffled <- FALSE
[16:05:54.356]                       if (inherits(cond, "message")) {
[16:05:54.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.356]                         if (muffled) 
[16:05:54.356]                           invokeRestart("muffleMessage")
[16:05:54.356]                       }
[16:05:54.356]                       else if (inherits(cond, "warning")) {
[16:05:54.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.356]                         if (muffled) 
[16:05:54.356]                           invokeRestart("muffleWarning")
[16:05:54.356]                       }
[16:05:54.356]                       else if (inherits(cond, "condition")) {
[16:05:54.356]                         if (!is.null(pattern)) {
[16:05:54.356]                           computeRestarts <- base::computeRestarts
[16:05:54.356]                           grepl <- base::grepl
[16:05:54.356]                           restarts <- computeRestarts(cond)
[16:05:54.356]                           for (restart in restarts) {
[16:05:54.356]                             name <- restart$name
[16:05:54.356]                             if (is.null(name)) 
[16:05:54.356]                               next
[16:05:54.356]                             if (!grepl(pattern, name)) 
[16:05:54.356]                               next
[16:05:54.356]                             invokeRestart(restart)
[16:05:54.356]                             muffled <- TRUE
[16:05:54.356]                             break
[16:05:54.356]                           }
[16:05:54.356]                         }
[16:05:54.356]                       }
[16:05:54.356]                       invisible(muffled)
[16:05:54.356]                     }
[16:05:54.356]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.356]                   }
[16:05:54.356]                 }
[16:05:54.356]             }
[16:05:54.356]         }))
[16:05:54.356]     }, error = function(ex) {
[16:05:54.356]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.356]                 ...future.rng), started = ...future.startTime, 
[16:05:54.356]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.356]             version = "1.8"), class = "FutureResult")
[16:05:54.356]     }, finally = {
[16:05:54.356]         if (!identical(...future.workdir, getwd())) 
[16:05:54.356]             setwd(...future.workdir)
[16:05:54.356]         {
[16:05:54.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.356]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.356]             }
[16:05:54.356]             base::options(...future.oldOptions)
[16:05:54.356]             if (.Platform$OS.type == "windows") {
[16:05:54.356]                 old_names <- names(...future.oldEnvVars)
[16:05:54.356]                 envs <- base::Sys.getenv()
[16:05:54.356]                 names <- names(envs)
[16:05:54.356]                 common <- intersect(names, old_names)
[16:05:54.356]                 added <- setdiff(names, old_names)
[16:05:54.356]                 removed <- setdiff(old_names, names)
[16:05:54.356]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.356]                   envs[common]]
[16:05:54.356]                 NAMES <- toupper(changed)
[16:05:54.356]                 args <- list()
[16:05:54.356]                 for (kk in seq_along(NAMES)) {
[16:05:54.356]                   name <- changed[[kk]]
[16:05:54.356]                   NAME <- NAMES[[kk]]
[16:05:54.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.356]                     next
[16:05:54.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.356]                 }
[16:05:54.356]                 NAMES <- toupper(added)
[16:05:54.356]                 for (kk in seq_along(NAMES)) {
[16:05:54.356]                   name <- added[[kk]]
[16:05:54.356]                   NAME <- NAMES[[kk]]
[16:05:54.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.356]                     next
[16:05:54.356]                   args[[name]] <- ""
[16:05:54.356]                 }
[16:05:54.356]                 NAMES <- toupper(removed)
[16:05:54.356]                 for (kk in seq_along(NAMES)) {
[16:05:54.356]                   name <- removed[[kk]]
[16:05:54.356]                   NAME <- NAMES[[kk]]
[16:05:54.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.356]                     next
[16:05:54.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.356]                 }
[16:05:54.356]                 if (length(args) > 0) 
[16:05:54.356]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.356]             }
[16:05:54.356]             else {
[16:05:54.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.356]             }
[16:05:54.356]             {
[16:05:54.356]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.356]                   0L) {
[16:05:54.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.356]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.356]                   base::options(opts)
[16:05:54.356]                 }
[16:05:54.356]                 {
[16:05:54.356]                   {
[16:05:54.356]                     NULL
[16:05:54.356]                     RNGkind("Mersenne-Twister")
[16:05:54.356]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.356]                       inherits = FALSE)
[16:05:54.356]                   }
[16:05:54.356]                   options(future.plan = NULL)
[16:05:54.356]                   if (is.na(NA_character_)) 
[16:05:54.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.356]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.356]                   {
[16:05:54.356]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.356]                     if (!future$lazy) 
[16:05:54.356]                       future <- run(future)
[16:05:54.356]                     invisible(future)
[16:05:54.356]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.356]                 }
[16:05:54.356]             }
[16:05:54.356]         }
[16:05:54.356]     })
[16:05:54.356]     if (TRUE) {
[16:05:54.356]         base::sink(type = "output", split = FALSE)
[16:05:54.356]         if (TRUE) {
[16:05:54.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.356]         }
[16:05:54.356]         else {
[16:05:54.356]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.356]         }
[16:05:54.356]         base::close(...future.stdout)
[16:05:54.356]         ...future.stdout <- NULL
[16:05:54.356]     }
[16:05:54.356]     ...future.result$conditions <- ...future.conditions
[16:05:54.356]     ...future.result$finished <- base::Sys.time()
[16:05:54.356]     ...future.result
[16:05:54.356] }
[16:05:54.357] assign_globals() ...
[16:05:54.357] List of 1
[16:05:54.357]  $ kk: int 3
[16:05:54.357]  - attr(*, "where")=List of 1
[16:05:54.357]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:54.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:54.357]  - attr(*, "resolved")= logi FALSE
[16:05:54.357]  - attr(*, "total_size")= num 56
[16:05:54.357]  - attr(*, "already-done")= logi TRUE
[16:05:54.360] - copied ‘kk’ to environment
[16:05:54.360] assign_globals() ... done
[16:05:54.360] plan(): Setting new future strategy stack:
[16:05:54.360] List of future strategies:
[16:05:54.360] 1. sequential:
[16:05:54.360]    - args: function (..., envir = parent.frame())
[16:05:54.360]    - tweaked: FALSE
[16:05:54.360]    - call: NULL
[16:05:54.360] plan(): nbrOfWorkers() = 1
[16:05:54.461] plan(): Setting new future strategy stack:
[16:05:54.461] List of future strategies:
[16:05:54.461] 1. sequential:
[16:05:54.461]    - args: function (..., envir = parent.frame())
[16:05:54.461]    - tweaked: FALSE
[16:05:54.461]    - call: plan(strategy)
[16:05:54.462] plan(): nbrOfWorkers() = 1
[16:05:54.462] SequentialFuture started (and completed)
[16:05:54.462] - Launch lazy future ... done
[16:05:54.462] run() for ‘SequentialFuture’ ... done
[16:05:54.462] resolve() on list ...
[16:05:54.462]  recursive: 0
[16:05:54.462]  length: 3
[16:05:54.463] 
[16:05:54.463] resolved() for ‘SequentialFuture’ ...
[16:05:54.463] - state: ‘finished’
[16:05:54.463] - run: TRUE
[16:05:54.463] - result: ‘FutureResult’
[16:05:54.463] resolved() for ‘SequentialFuture’ ... done
[16:05:54.463] Future #1
[16:05:54.463]  length: 2 (resolved future 1)
[16:05:54.463] resolved() for ‘SequentialFuture’ ...
[16:05:54.463] - state: ‘finished’
[16:05:54.464] - run: TRUE
[16:05:54.464] - result: ‘FutureResult’
[16:05:54.464] resolved() for ‘SequentialFuture’ ... done
[16:05:54.464] Future #2
[16:05:54.464]  length: 1 (resolved future 2)
[16:05:54.464] resolved() for ‘SequentialFuture’ ...
[16:05:54.464] - state: ‘finished’
[16:05:54.464] - run: TRUE
[16:05:54.464] - result: ‘FutureResult’
[16:05:54.464] resolved() for ‘SequentialFuture’ ... done
[16:05:54.464] Future #3
[16:05:54.465]  length: 0 (resolved future 3)
[16:05:54.465] resolve() on list ... DONE
[16:05:54.465] getGlobalsAndPackages() ...
[16:05:54.465] Searching for globals...
[16:05:54.466] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:54.466] Searching for globals ... DONE
[16:05:54.466] Resolving globals: FALSE
[16:05:54.466] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:54.467] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:54.467] - globals: [1] ‘kk’
[16:05:54.467] 
[16:05:54.467] getGlobalsAndPackages() ... DONE
[16:05:54.467] getGlobalsAndPackages() ...
[16:05:54.467] Searching for globals...
[16:05:54.468] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:54.468] Searching for globals ... DONE
[16:05:54.468] Resolving globals: FALSE
[16:05:54.469] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:54.469] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:54.469] - globals: [1] ‘kk’
[16:05:54.469] 
[16:05:54.469] getGlobalsAndPackages() ... DONE
[16:05:54.470] getGlobalsAndPackages() ...
[16:05:54.470] Searching for globals...
[16:05:54.470] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:54.471] Searching for globals ... DONE
[16:05:54.471] Resolving globals: FALSE
[16:05:54.471] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:54.471] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:54.471] - globals: [1] ‘kk’
[16:05:54.472] 
[16:05:54.472] getGlobalsAndPackages() ... DONE
[16:05:54.472] resolve() on list ...
[16:05:54.472]  recursive: 0
[16:05:54.472]  length: 3
[16:05:54.472] 
[16:05:54.472] run() for ‘Future’ ...
[16:05:54.472] - state: ‘created’
[16:05:54.472] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.474] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.474]   - Field: ‘label’
[16:05:54.474]   - Field: ‘local’
[16:05:54.474]   - Field: ‘owner’
[16:05:54.475]   - Field: ‘envir’
[16:05:54.475]   - Field: ‘packages’
[16:05:54.475]   - Field: ‘gc’
[16:05:54.475]   - Field: ‘conditions’
[16:05:54.475]   - Field: ‘expr’
[16:05:54.475]   - Field: ‘uuid’
[16:05:54.475]   - Field: ‘seed’
[16:05:54.475]   - Field: ‘version’
[16:05:54.475]   - Field: ‘result’
[16:05:54.475]   - Field: ‘asynchronous’
[16:05:54.476]   - Field: ‘calls’
[16:05:54.476]   - Field: ‘globals’
[16:05:54.476]   - Field: ‘stdout’
[16:05:54.476]   - Field: ‘earlySignal’
[16:05:54.476]   - Field: ‘lazy’
[16:05:54.476]   - Field: ‘state’
[16:05:54.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.476] - Launch lazy future ...
[16:05:54.476] Packages needed by the future expression (n = 0): <none>
[16:05:54.476] Packages needed by future strategies (n = 0): <none>
[16:05:54.477] {
[16:05:54.477]     {
[16:05:54.477]         {
[16:05:54.477]             ...future.startTime <- base::Sys.time()
[16:05:54.477]             {
[16:05:54.477]                 {
[16:05:54.477]                   {
[16:05:54.477]                     base::local({
[16:05:54.477]                       has_future <- base::requireNamespace("future", 
[16:05:54.477]                         quietly = TRUE)
[16:05:54.477]                       if (has_future) {
[16:05:54.477]                         ns <- base::getNamespace("future")
[16:05:54.477]                         version <- ns[[".package"]][["version"]]
[16:05:54.477]                         if (is.null(version)) 
[16:05:54.477]                           version <- utils::packageVersion("future")
[16:05:54.477]                       }
[16:05:54.477]                       else {
[16:05:54.477]                         version <- NULL
[16:05:54.477]                       }
[16:05:54.477]                       if (!has_future || version < "1.8.0") {
[16:05:54.477]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.477]                           "", base::R.version$version.string), 
[16:05:54.477]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.477]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.477]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.477]                             "release", "version")], collapse = " "), 
[16:05:54.477]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.477]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.477]                           info)
[16:05:54.477]                         info <- base::paste(info, collapse = "; ")
[16:05:54.477]                         if (!has_future) {
[16:05:54.477]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.477]                             info)
[16:05:54.477]                         }
[16:05:54.477]                         else {
[16:05:54.477]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.477]                             info, version)
[16:05:54.477]                         }
[16:05:54.477]                         base::stop(msg)
[16:05:54.477]                       }
[16:05:54.477]                     })
[16:05:54.477]                   }
[16:05:54.477]                   options(future.plan = NULL)
[16:05:54.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.477]                 }
[16:05:54.477]                 ...future.workdir <- getwd()
[16:05:54.477]             }
[16:05:54.477]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.477]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.477]         }
[16:05:54.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.477]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.477]             base::names(...future.oldOptions))
[16:05:54.477]     }
[16:05:54.477]     if (FALSE) {
[16:05:54.477]     }
[16:05:54.477]     else {
[16:05:54.477]         if (TRUE) {
[16:05:54.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.477]                 open = "w")
[16:05:54.477]         }
[16:05:54.477]         else {
[16:05:54.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.477]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.477]         }
[16:05:54.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.477]             base::sink(type = "output", split = FALSE)
[16:05:54.477]             base::close(...future.stdout)
[16:05:54.477]         }, add = TRUE)
[16:05:54.477]     }
[16:05:54.477]     ...future.frame <- base::sys.nframe()
[16:05:54.477]     ...future.conditions <- base::list()
[16:05:54.477]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.477]     if (FALSE) {
[16:05:54.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.477]     }
[16:05:54.477]     ...future.result <- base::tryCatch({
[16:05:54.477]         base::withCallingHandlers({
[16:05:54.477]             ...future.value <- base::withVisible(base::local({
[16:05:54.477]                 Sys.sleep(0.1)
[16:05:54.477]                 kk
[16:05:54.477]             }))
[16:05:54.477]             future::FutureResult(value = ...future.value$value, 
[16:05:54.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.477]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.477]                     ...future.globalenv.names))
[16:05:54.477]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.477]         }, condition = base::local({
[16:05:54.477]             c <- base::c
[16:05:54.477]             inherits <- base::inherits
[16:05:54.477]             invokeRestart <- base::invokeRestart
[16:05:54.477]             length <- base::length
[16:05:54.477]             list <- base::list
[16:05:54.477]             seq.int <- base::seq.int
[16:05:54.477]             signalCondition <- base::signalCondition
[16:05:54.477]             sys.calls <- base::sys.calls
[16:05:54.477]             `[[` <- base::`[[`
[16:05:54.477]             `+` <- base::`+`
[16:05:54.477]             `<<-` <- base::`<<-`
[16:05:54.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.477]                   3L)]
[16:05:54.477]             }
[16:05:54.477]             function(cond) {
[16:05:54.477]                 is_error <- inherits(cond, "error")
[16:05:54.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.477]                   NULL)
[16:05:54.477]                 if (is_error) {
[16:05:54.477]                   sessionInformation <- function() {
[16:05:54.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.477]                       search = base::search(), system = base::Sys.info())
[16:05:54.477]                   }
[16:05:54.477]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.477]                     cond$call), session = sessionInformation(), 
[16:05:54.477]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.477]                   signalCondition(cond)
[16:05:54.477]                 }
[16:05:54.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.477]                 "immediateCondition"))) {
[16:05:54.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.477]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.477]                   if (TRUE && !signal) {
[16:05:54.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.477]                     {
[16:05:54.477]                       inherits <- base::inherits
[16:05:54.477]                       invokeRestart <- base::invokeRestart
[16:05:54.477]                       is.null <- base::is.null
[16:05:54.477]                       muffled <- FALSE
[16:05:54.477]                       if (inherits(cond, "message")) {
[16:05:54.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.477]                         if (muffled) 
[16:05:54.477]                           invokeRestart("muffleMessage")
[16:05:54.477]                       }
[16:05:54.477]                       else if (inherits(cond, "warning")) {
[16:05:54.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.477]                         if (muffled) 
[16:05:54.477]                           invokeRestart("muffleWarning")
[16:05:54.477]                       }
[16:05:54.477]                       else if (inherits(cond, "condition")) {
[16:05:54.477]                         if (!is.null(pattern)) {
[16:05:54.477]                           computeRestarts <- base::computeRestarts
[16:05:54.477]                           grepl <- base::grepl
[16:05:54.477]                           restarts <- computeRestarts(cond)
[16:05:54.477]                           for (restart in restarts) {
[16:05:54.477]                             name <- restart$name
[16:05:54.477]                             if (is.null(name)) 
[16:05:54.477]                               next
[16:05:54.477]                             if (!grepl(pattern, name)) 
[16:05:54.477]                               next
[16:05:54.477]                             invokeRestart(restart)
[16:05:54.477]                             muffled <- TRUE
[16:05:54.477]                             break
[16:05:54.477]                           }
[16:05:54.477]                         }
[16:05:54.477]                       }
[16:05:54.477]                       invisible(muffled)
[16:05:54.477]                     }
[16:05:54.477]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.477]                   }
[16:05:54.477]                 }
[16:05:54.477]                 else {
[16:05:54.477]                   if (TRUE) {
[16:05:54.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.477]                     {
[16:05:54.477]                       inherits <- base::inherits
[16:05:54.477]                       invokeRestart <- base::invokeRestart
[16:05:54.477]                       is.null <- base::is.null
[16:05:54.477]                       muffled <- FALSE
[16:05:54.477]                       if (inherits(cond, "message")) {
[16:05:54.477]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.477]                         if (muffled) 
[16:05:54.477]                           invokeRestart("muffleMessage")
[16:05:54.477]                       }
[16:05:54.477]                       else if (inherits(cond, "warning")) {
[16:05:54.477]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.477]                         if (muffled) 
[16:05:54.477]                           invokeRestart("muffleWarning")
[16:05:54.477]                       }
[16:05:54.477]                       else if (inherits(cond, "condition")) {
[16:05:54.477]                         if (!is.null(pattern)) {
[16:05:54.477]                           computeRestarts <- base::computeRestarts
[16:05:54.477]                           grepl <- base::grepl
[16:05:54.477]                           restarts <- computeRestarts(cond)
[16:05:54.477]                           for (restart in restarts) {
[16:05:54.477]                             name <- restart$name
[16:05:54.477]                             if (is.null(name)) 
[16:05:54.477]                               next
[16:05:54.477]                             if (!grepl(pattern, name)) 
[16:05:54.477]                               next
[16:05:54.477]                             invokeRestart(restart)
[16:05:54.477]                             muffled <- TRUE
[16:05:54.477]                             break
[16:05:54.477]                           }
[16:05:54.477]                         }
[16:05:54.477]                       }
[16:05:54.477]                       invisible(muffled)
[16:05:54.477]                     }
[16:05:54.477]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.477]                   }
[16:05:54.477]                 }
[16:05:54.477]             }
[16:05:54.477]         }))
[16:05:54.477]     }, error = function(ex) {
[16:05:54.477]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.477]                 ...future.rng), started = ...future.startTime, 
[16:05:54.477]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.477]             version = "1.8"), class = "FutureResult")
[16:05:54.477]     }, finally = {
[16:05:54.477]         if (!identical(...future.workdir, getwd())) 
[16:05:54.477]             setwd(...future.workdir)
[16:05:54.477]         {
[16:05:54.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.477]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.477]             }
[16:05:54.477]             base::options(...future.oldOptions)
[16:05:54.477]             if (.Platform$OS.type == "windows") {
[16:05:54.477]                 old_names <- names(...future.oldEnvVars)
[16:05:54.477]                 envs <- base::Sys.getenv()
[16:05:54.477]                 names <- names(envs)
[16:05:54.477]                 common <- intersect(names, old_names)
[16:05:54.477]                 added <- setdiff(names, old_names)
[16:05:54.477]                 removed <- setdiff(old_names, names)
[16:05:54.477]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.477]                   envs[common]]
[16:05:54.477]                 NAMES <- toupper(changed)
[16:05:54.477]                 args <- list()
[16:05:54.477]                 for (kk in seq_along(NAMES)) {
[16:05:54.477]                   name <- changed[[kk]]
[16:05:54.477]                   NAME <- NAMES[[kk]]
[16:05:54.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.477]                     next
[16:05:54.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.477]                 }
[16:05:54.477]                 NAMES <- toupper(added)
[16:05:54.477]                 for (kk in seq_along(NAMES)) {
[16:05:54.477]                   name <- added[[kk]]
[16:05:54.477]                   NAME <- NAMES[[kk]]
[16:05:54.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.477]                     next
[16:05:54.477]                   args[[name]] <- ""
[16:05:54.477]                 }
[16:05:54.477]                 NAMES <- toupper(removed)
[16:05:54.477]                 for (kk in seq_along(NAMES)) {
[16:05:54.477]                   name <- removed[[kk]]
[16:05:54.477]                   NAME <- NAMES[[kk]]
[16:05:54.477]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.477]                     next
[16:05:54.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.477]                 }
[16:05:54.477]                 if (length(args) > 0) 
[16:05:54.477]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.477]             }
[16:05:54.477]             else {
[16:05:54.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.477]             }
[16:05:54.477]             {
[16:05:54.477]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.477]                   0L) {
[16:05:54.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.477]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.477]                   base::options(opts)
[16:05:54.477]                 }
[16:05:54.477]                 {
[16:05:54.477]                   {
[16:05:54.477]                     NULL
[16:05:54.477]                     RNGkind("Mersenne-Twister")
[16:05:54.477]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.477]                       inherits = FALSE)
[16:05:54.477]                   }
[16:05:54.477]                   options(future.plan = NULL)
[16:05:54.477]                   if (is.na(NA_character_)) 
[16:05:54.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.477]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.477]                   {
[16:05:54.477]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.477]                     if (!future$lazy) 
[16:05:54.477]                       future <- run(future)
[16:05:54.477]                     invisible(future)
[16:05:54.477]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.477]                 }
[16:05:54.477]             }
[16:05:54.477]         }
[16:05:54.477]     })
[16:05:54.477]     if (TRUE) {
[16:05:54.477]         base::sink(type = "output", split = FALSE)
[16:05:54.477]         if (TRUE) {
[16:05:54.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.477]         }
[16:05:54.477]         else {
[16:05:54.477]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.477]         }
[16:05:54.477]         base::close(...future.stdout)
[16:05:54.477]         ...future.stdout <- NULL
[16:05:54.477]     }
[16:05:54.477]     ...future.result$conditions <- ...future.conditions
[16:05:54.477]     ...future.result$finished <- base::Sys.time()
[16:05:54.477]     ...future.result
[16:05:54.477] }
[16:05:54.478] assign_globals() ...
[16:05:54.479] List of 1
[16:05:54.479]  $ kk: int 1
[16:05:54.479]  - attr(*, "where")=List of 1
[16:05:54.479]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:54.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:54.479]  - attr(*, "resolved")= logi FALSE
[16:05:54.479]  - attr(*, "total_size")= num 56
[16:05:54.479]  - attr(*, "already-done")= logi TRUE
[16:05:54.481] - copied ‘kk’ to environment
[16:05:54.481] assign_globals() ... done
[16:05:54.481] plan(): Setting new future strategy stack:
[16:05:54.481] List of future strategies:
[16:05:54.481] 1. sequential:
[16:05:54.481]    - args: function (..., envir = parent.frame())
[16:05:54.481]    - tweaked: FALSE
[16:05:54.481]    - call: NULL
[16:05:54.482] plan(): nbrOfWorkers() = 1
[16:05:54.583] plan(): Setting new future strategy stack:
[16:05:54.583] List of future strategies:
[16:05:54.583] 1. sequential:
[16:05:54.583]    - args: function (..., envir = parent.frame())
[16:05:54.583]    - tweaked: FALSE
[16:05:54.583]    - call: plan(strategy)
[16:05:54.583] plan(): nbrOfWorkers() = 1
[16:05:54.583] SequentialFuture started (and completed)
[16:05:54.583] - Launch lazy future ... done
[16:05:54.584] run() for ‘SequentialFuture’ ... done
[16:05:54.584] resolved() for ‘SequentialFuture’ ...
[16:05:54.584] - state: ‘finished’
[16:05:54.584] - run: TRUE
[16:05:54.584] - result: ‘FutureResult’
[16:05:54.584] resolved() for ‘SequentialFuture’ ... done
[16:05:54.584] Future #1
[16:05:54.584]  length: 2 (resolved future 1)
[16:05:54.584] run() for ‘Future’ ...
[16:05:54.584] - state: ‘created’
[16:05:54.585] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.585] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.585] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.585]   - Field: ‘label’
[16:05:54.585]   - Field: ‘local’
[16:05:54.585]   - Field: ‘owner’
[16:05:54.585]   - Field: ‘envir’
[16:05:54.585]   - Field: ‘packages’
[16:05:54.585]   - Field: ‘gc’
[16:05:54.586]   - Field: ‘conditions’
[16:05:54.586]   - Field: ‘expr’
[16:05:54.586]   - Field: ‘uuid’
[16:05:54.586]   - Field: ‘seed’
[16:05:54.586]   - Field: ‘version’
[16:05:54.586]   - Field: ‘result’
[16:05:54.586]   - Field: ‘asynchronous’
[16:05:54.586]   - Field: ‘calls’
[16:05:54.586]   - Field: ‘globals’
[16:05:54.586]   - Field: ‘stdout’
[16:05:54.586]   - Field: ‘earlySignal’
[16:05:54.587]   - Field: ‘lazy’
[16:05:54.587]   - Field: ‘state’
[16:05:54.587] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.587] - Launch lazy future ...
[16:05:54.587] Packages needed by the future expression (n = 0): <none>
[16:05:54.587] Packages needed by future strategies (n = 0): <none>
[16:05:54.587] {
[16:05:54.587]     {
[16:05:54.587]         {
[16:05:54.587]             ...future.startTime <- base::Sys.time()
[16:05:54.587]             {
[16:05:54.587]                 {
[16:05:54.587]                   {
[16:05:54.587]                     base::local({
[16:05:54.587]                       has_future <- base::requireNamespace("future", 
[16:05:54.587]                         quietly = TRUE)
[16:05:54.587]                       if (has_future) {
[16:05:54.587]                         ns <- base::getNamespace("future")
[16:05:54.587]                         version <- ns[[".package"]][["version"]]
[16:05:54.587]                         if (is.null(version)) 
[16:05:54.587]                           version <- utils::packageVersion("future")
[16:05:54.587]                       }
[16:05:54.587]                       else {
[16:05:54.587]                         version <- NULL
[16:05:54.587]                       }
[16:05:54.587]                       if (!has_future || version < "1.8.0") {
[16:05:54.587]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.587]                           "", base::R.version$version.string), 
[16:05:54.587]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.587]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.587]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.587]                             "release", "version")], collapse = " "), 
[16:05:54.587]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.587]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.587]                           info)
[16:05:54.587]                         info <- base::paste(info, collapse = "; ")
[16:05:54.587]                         if (!has_future) {
[16:05:54.587]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.587]                             info)
[16:05:54.587]                         }
[16:05:54.587]                         else {
[16:05:54.587]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.587]                             info, version)
[16:05:54.587]                         }
[16:05:54.587]                         base::stop(msg)
[16:05:54.587]                       }
[16:05:54.587]                     })
[16:05:54.587]                   }
[16:05:54.587]                   options(future.plan = NULL)
[16:05:54.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.587]                 }
[16:05:54.587]                 ...future.workdir <- getwd()
[16:05:54.587]             }
[16:05:54.587]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.587]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.587]         }
[16:05:54.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.587]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.587]             base::names(...future.oldOptions))
[16:05:54.587]     }
[16:05:54.587]     if (FALSE) {
[16:05:54.587]     }
[16:05:54.587]     else {
[16:05:54.587]         if (TRUE) {
[16:05:54.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.587]                 open = "w")
[16:05:54.587]         }
[16:05:54.587]         else {
[16:05:54.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.587]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.587]         }
[16:05:54.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.587]             base::sink(type = "output", split = FALSE)
[16:05:54.587]             base::close(...future.stdout)
[16:05:54.587]         }, add = TRUE)
[16:05:54.587]     }
[16:05:54.587]     ...future.frame <- base::sys.nframe()
[16:05:54.587]     ...future.conditions <- base::list()
[16:05:54.587]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.587]     if (FALSE) {
[16:05:54.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.587]     }
[16:05:54.587]     ...future.result <- base::tryCatch({
[16:05:54.587]         base::withCallingHandlers({
[16:05:54.587]             ...future.value <- base::withVisible(base::local({
[16:05:54.587]                 Sys.sleep(0.1)
[16:05:54.587]                 kk
[16:05:54.587]             }))
[16:05:54.587]             future::FutureResult(value = ...future.value$value, 
[16:05:54.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.587]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.587]                     ...future.globalenv.names))
[16:05:54.587]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.587]         }, condition = base::local({
[16:05:54.587]             c <- base::c
[16:05:54.587]             inherits <- base::inherits
[16:05:54.587]             invokeRestart <- base::invokeRestart
[16:05:54.587]             length <- base::length
[16:05:54.587]             list <- base::list
[16:05:54.587]             seq.int <- base::seq.int
[16:05:54.587]             signalCondition <- base::signalCondition
[16:05:54.587]             sys.calls <- base::sys.calls
[16:05:54.587]             `[[` <- base::`[[`
[16:05:54.587]             `+` <- base::`+`
[16:05:54.587]             `<<-` <- base::`<<-`
[16:05:54.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.587]                   3L)]
[16:05:54.587]             }
[16:05:54.587]             function(cond) {
[16:05:54.587]                 is_error <- inherits(cond, "error")
[16:05:54.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.587]                   NULL)
[16:05:54.587]                 if (is_error) {
[16:05:54.587]                   sessionInformation <- function() {
[16:05:54.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.587]                       search = base::search(), system = base::Sys.info())
[16:05:54.587]                   }
[16:05:54.587]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.587]                     cond$call), session = sessionInformation(), 
[16:05:54.587]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.587]                   signalCondition(cond)
[16:05:54.587]                 }
[16:05:54.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.587]                 "immediateCondition"))) {
[16:05:54.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.587]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.587]                   if (TRUE && !signal) {
[16:05:54.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.587]                     {
[16:05:54.587]                       inherits <- base::inherits
[16:05:54.587]                       invokeRestart <- base::invokeRestart
[16:05:54.587]                       is.null <- base::is.null
[16:05:54.587]                       muffled <- FALSE
[16:05:54.587]                       if (inherits(cond, "message")) {
[16:05:54.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.587]                         if (muffled) 
[16:05:54.587]                           invokeRestart("muffleMessage")
[16:05:54.587]                       }
[16:05:54.587]                       else if (inherits(cond, "warning")) {
[16:05:54.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.587]                         if (muffled) 
[16:05:54.587]                           invokeRestart("muffleWarning")
[16:05:54.587]                       }
[16:05:54.587]                       else if (inherits(cond, "condition")) {
[16:05:54.587]                         if (!is.null(pattern)) {
[16:05:54.587]                           computeRestarts <- base::computeRestarts
[16:05:54.587]                           grepl <- base::grepl
[16:05:54.587]                           restarts <- computeRestarts(cond)
[16:05:54.587]                           for (restart in restarts) {
[16:05:54.587]                             name <- restart$name
[16:05:54.587]                             if (is.null(name)) 
[16:05:54.587]                               next
[16:05:54.587]                             if (!grepl(pattern, name)) 
[16:05:54.587]                               next
[16:05:54.587]                             invokeRestart(restart)
[16:05:54.587]                             muffled <- TRUE
[16:05:54.587]                             break
[16:05:54.587]                           }
[16:05:54.587]                         }
[16:05:54.587]                       }
[16:05:54.587]                       invisible(muffled)
[16:05:54.587]                     }
[16:05:54.587]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.587]                   }
[16:05:54.587]                 }
[16:05:54.587]                 else {
[16:05:54.587]                   if (TRUE) {
[16:05:54.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.587]                     {
[16:05:54.587]                       inherits <- base::inherits
[16:05:54.587]                       invokeRestart <- base::invokeRestart
[16:05:54.587]                       is.null <- base::is.null
[16:05:54.587]                       muffled <- FALSE
[16:05:54.587]                       if (inherits(cond, "message")) {
[16:05:54.587]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.587]                         if (muffled) 
[16:05:54.587]                           invokeRestart("muffleMessage")
[16:05:54.587]                       }
[16:05:54.587]                       else if (inherits(cond, "warning")) {
[16:05:54.587]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.587]                         if (muffled) 
[16:05:54.587]                           invokeRestart("muffleWarning")
[16:05:54.587]                       }
[16:05:54.587]                       else if (inherits(cond, "condition")) {
[16:05:54.587]                         if (!is.null(pattern)) {
[16:05:54.587]                           computeRestarts <- base::computeRestarts
[16:05:54.587]                           grepl <- base::grepl
[16:05:54.587]                           restarts <- computeRestarts(cond)
[16:05:54.587]                           for (restart in restarts) {
[16:05:54.587]                             name <- restart$name
[16:05:54.587]                             if (is.null(name)) 
[16:05:54.587]                               next
[16:05:54.587]                             if (!grepl(pattern, name)) 
[16:05:54.587]                               next
[16:05:54.587]                             invokeRestart(restart)
[16:05:54.587]                             muffled <- TRUE
[16:05:54.587]                             break
[16:05:54.587]                           }
[16:05:54.587]                         }
[16:05:54.587]                       }
[16:05:54.587]                       invisible(muffled)
[16:05:54.587]                     }
[16:05:54.587]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.587]                   }
[16:05:54.587]                 }
[16:05:54.587]             }
[16:05:54.587]         }))
[16:05:54.587]     }, error = function(ex) {
[16:05:54.587]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.587]                 ...future.rng), started = ...future.startTime, 
[16:05:54.587]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.587]             version = "1.8"), class = "FutureResult")
[16:05:54.587]     }, finally = {
[16:05:54.587]         if (!identical(...future.workdir, getwd())) 
[16:05:54.587]             setwd(...future.workdir)
[16:05:54.587]         {
[16:05:54.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.587]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.587]             }
[16:05:54.587]             base::options(...future.oldOptions)
[16:05:54.587]             if (.Platform$OS.type == "windows") {
[16:05:54.587]                 old_names <- names(...future.oldEnvVars)
[16:05:54.587]                 envs <- base::Sys.getenv()
[16:05:54.587]                 names <- names(envs)
[16:05:54.587]                 common <- intersect(names, old_names)
[16:05:54.587]                 added <- setdiff(names, old_names)
[16:05:54.587]                 removed <- setdiff(old_names, names)
[16:05:54.587]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.587]                   envs[common]]
[16:05:54.587]                 NAMES <- toupper(changed)
[16:05:54.587]                 args <- list()
[16:05:54.587]                 for (kk in seq_along(NAMES)) {
[16:05:54.587]                   name <- changed[[kk]]
[16:05:54.587]                   NAME <- NAMES[[kk]]
[16:05:54.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.587]                     next
[16:05:54.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.587]                 }
[16:05:54.587]                 NAMES <- toupper(added)
[16:05:54.587]                 for (kk in seq_along(NAMES)) {
[16:05:54.587]                   name <- added[[kk]]
[16:05:54.587]                   NAME <- NAMES[[kk]]
[16:05:54.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.587]                     next
[16:05:54.587]                   args[[name]] <- ""
[16:05:54.587]                 }
[16:05:54.587]                 NAMES <- toupper(removed)
[16:05:54.587]                 for (kk in seq_along(NAMES)) {
[16:05:54.587]                   name <- removed[[kk]]
[16:05:54.587]                   NAME <- NAMES[[kk]]
[16:05:54.587]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.587]                     next
[16:05:54.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.587]                 }
[16:05:54.587]                 if (length(args) > 0) 
[16:05:54.587]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.587]             }
[16:05:54.587]             else {
[16:05:54.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.587]             }
[16:05:54.587]             {
[16:05:54.587]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.587]                   0L) {
[16:05:54.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.587]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.587]                   base::options(opts)
[16:05:54.587]                 }
[16:05:54.587]                 {
[16:05:54.587]                   {
[16:05:54.587]                     NULL
[16:05:54.587]                     RNGkind("Mersenne-Twister")
[16:05:54.587]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.587]                       inherits = FALSE)
[16:05:54.587]                   }
[16:05:54.587]                   options(future.plan = NULL)
[16:05:54.587]                   if (is.na(NA_character_)) 
[16:05:54.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.587]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.587]                   {
[16:05:54.587]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.587]                     if (!future$lazy) 
[16:05:54.587]                       future <- run(future)
[16:05:54.587]                     invisible(future)
[16:05:54.587]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.587]                 }
[16:05:54.587]             }
[16:05:54.587]         }
[16:05:54.587]     })
[16:05:54.587]     if (TRUE) {
[16:05:54.587]         base::sink(type = "output", split = FALSE)
[16:05:54.587]         if (TRUE) {
[16:05:54.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.587]         }
[16:05:54.587]         else {
[16:05:54.587]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.587]         }
[16:05:54.587]         base::close(...future.stdout)
[16:05:54.587]         ...future.stdout <- NULL
[16:05:54.587]     }
[16:05:54.587]     ...future.result$conditions <- ...future.conditions
[16:05:54.587]     ...future.result$finished <- base::Sys.time()
[16:05:54.587]     ...future.result
[16:05:54.587] }
[16:05:54.589] assign_globals() ...
[16:05:54.589] List of 1
[16:05:54.589]  $ kk: int 2
[16:05:54.589]  - attr(*, "where")=List of 1
[16:05:54.589]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:54.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:54.589]  - attr(*, "resolved")= logi FALSE
[16:05:54.589]  - attr(*, "total_size")= num 56
[16:05:54.589]  - attr(*, "already-done")= logi TRUE
[16:05:54.591] - copied ‘kk’ to environment
[16:05:54.592] assign_globals() ... done
[16:05:54.592] plan(): Setting new future strategy stack:
[16:05:54.592] List of future strategies:
[16:05:54.592] 1. sequential:
[16:05:54.592]    - args: function (..., envir = parent.frame())
[16:05:54.592]    - tweaked: FALSE
[16:05:54.592]    - call: NULL
[16:05:54.592] plan(): nbrOfWorkers() = 1
[16:05:54.693] plan(): Setting new future strategy stack:
[16:05:54.693] List of future strategies:
[16:05:54.693] 1. sequential:
[16:05:54.693]    - args: function (..., envir = parent.frame())
[16:05:54.693]    - tweaked: FALSE
[16:05:54.693]    - call: plan(strategy)
[16:05:54.694] plan(): nbrOfWorkers() = 1
[16:05:54.694] SequentialFuture started (and completed)
[16:05:54.694] - Launch lazy future ... done
[16:05:54.694] run() for ‘SequentialFuture’ ... done
[16:05:54.694] resolved() for ‘SequentialFuture’ ...
[16:05:54.694] - state: ‘finished’
[16:05:54.694] - run: TRUE
[16:05:54.695] - result: ‘FutureResult’
[16:05:54.695] resolved() for ‘SequentialFuture’ ... done
[16:05:54.695] Future #2
[16:05:54.695]  length: 1 (resolved future 2)
[16:05:54.695] run() for ‘Future’ ...
[16:05:54.695] - state: ‘created’
[16:05:54.695] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.695] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.696]   - Field: ‘label’
[16:05:54.696]   - Field: ‘local’
[16:05:54.696]   - Field: ‘owner’
[16:05:54.696]   - Field: ‘envir’
[16:05:54.696]   - Field: ‘packages’
[16:05:54.696]   - Field: ‘gc’
[16:05:54.696]   - Field: ‘conditions’
[16:05:54.696]   - Field: ‘expr’
[16:05:54.696]   - Field: ‘uuid’
[16:05:54.696]   - Field: ‘seed’
[16:05:54.696]   - Field: ‘version’
[16:05:54.697]   - Field: ‘result’
[16:05:54.697]   - Field: ‘asynchronous’
[16:05:54.697]   - Field: ‘calls’
[16:05:54.697]   - Field: ‘globals’
[16:05:54.697]   - Field: ‘stdout’
[16:05:54.697]   - Field: ‘earlySignal’
[16:05:54.697]   - Field: ‘lazy’
[16:05:54.697]   - Field: ‘state’
[16:05:54.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.697] - Launch lazy future ...
[16:05:54.698] Packages needed by the future expression (n = 0): <none>
[16:05:54.698] Packages needed by future strategies (n = 0): <none>
[16:05:54.698] {
[16:05:54.698]     {
[16:05:54.698]         {
[16:05:54.698]             ...future.startTime <- base::Sys.time()
[16:05:54.698]             {
[16:05:54.698]                 {
[16:05:54.698]                   {
[16:05:54.698]                     base::local({
[16:05:54.698]                       has_future <- base::requireNamespace("future", 
[16:05:54.698]                         quietly = TRUE)
[16:05:54.698]                       if (has_future) {
[16:05:54.698]                         ns <- base::getNamespace("future")
[16:05:54.698]                         version <- ns[[".package"]][["version"]]
[16:05:54.698]                         if (is.null(version)) 
[16:05:54.698]                           version <- utils::packageVersion("future")
[16:05:54.698]                       }
[16:05:54.698]                       else {
[16:05:54.698]                         version <- NULL
[16:05:54.698]                       }
[16:05:54.698]                       if (!has_future || version < "1.8.0") {
[16:05:54.698]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.698]                           "", base::R.version$version.string), 
[16:05:54.698]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.698]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.698]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.698]                             "release", "version")], collapse = " "), 
[16:05:54.698]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.698]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.698]                           info)
[16:05:54.698]                         info <- base::paste(info, collapse = "; ")
[16:05:54.698]                         if (!has_future) {
[16:05:54.698]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.698]                             info)
[16:05:54.698]                         }
[16:05:54.698]                         else {
[16:05:54.698]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.698]                             info, version)
[16:05:54.698]                         }
[16:05:54.698]                         base::stop(msg)
[16:05:54.698]                       }
[16:05:54.698]                     })
[16:05:54.698]                   }
[16:05:54.698]                   options(future.plan = NULL)
[16:05:54.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.698]                 }
[16:05:54.698]                 ...future.workdir <- getwd()
[16:05:54.698]             }
[16:05:54.698]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.698]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.698]         }
[16:05:54.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.698]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.698]             base::names(...future.oldOptions))
[16:05:54.698]     }
[16:05:54.698]     if (FALSE) {
[16:05:54.698]     }
[16:05:54.698]     else {
[16:05:54.698]         if (TRUE) {
[16:05:54.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.698]                 open = "w")
[16:05:54.698]         }
[16:05:54.698]         else {
[16:05:54.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.698]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.698]         }
[16:05:54.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.698]             base::sink(type = "output", split = FALSE)
[16:05:54.698]             base::close(...future.stdout)
[16:05:54.698]         }, add = TRUE)
[16:05:54.698]     }
[16:05:54.698]     ...future.frame <- base::sys.nframe()
[16:05:54.698]     ...future.conditions <- base::list()
[16:05:54.698]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.698]     if (FALSE) {
[16:05:54.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.698]     }
[16:05:54.698]     ...future.result <- base::tryCatch({
[16:05:54.698]         base::withCallingHandlers({
[16:05:54.698]             ...future.value <- base::withVisible(base::local({
[16:05:54.698]                 Sys.sleep(0.1)
[16:05:54.698]                 kk
[16:05:54.698]             }))
[16:05:54.698]             future::FutureResult(value = ...future.value$value, 
[16:05:54.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.698]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.698]                     ...future.globalenv.names))
[16:05:54.698]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.698]         }, condition = base::local({
[16:05:54.698]             c <- base::c
[16:05:54.698]             inherits <- base::inherits
[16:05:54.698]             invokeRestart <- base::invokeRestart
[16:05:54.698]             length <- base::length
[16:05:54.698]             list <- base::list
[16:05:54.698]             seq.int <- base::seq.int
[16:05:54.698]             signalCondition <- base::signalCondition
[16:05:54.698]             sys.calls <- base::sys.calls
[16:05:54.698]             `[[` <- base::`[[`
[16:05:54.698]             `+` <- base::`+`
[16:05:54.698]             `<<-` <- base::`<<-`
[16:05:54.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.698]                   3L)]
[16:05:54.698]             }
[16:05:54.698]             function(cond) {
[16:05:54.698]                 is_error <- inherits(cond, "error")
[16:05:54.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.698]                   NULL)
[16:05:54.698]                 if (is_error) {
[16:05:54.698]                   sessionInformation <- function() {
[16:05:54.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.698]                       search = base::search(), system = base::Sys.info())
[16:05:54.698]                   }
[16:05:54.698]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.698]                     cond$call), session = sessionInformation(), 
[16:05:54.698]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.698]                   signalCondition(cond)
[16:05:54.698]                 }
[16:05:54.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.698]                 "immediateCondition"))) {
[16:05:54.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.698]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.698]                   if (TRUE && !signal) {
[16:05:54.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.698]                     {
[16:05:54.698]                       inherits <- base::inherits
[16:05:54.698]                       invokeRestart <- base::invokeRestart
[16:05:54.698]                       is.null <- base::is.null
[16:05:54.698]                       muffled <- FALSE
[16:05:54.698]                       if (inherits(cond, "message")) {
[16:05:54.698]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.698]                         if (muffled) 
[16:05:54.698]                           invokeRestart("muffleMessage")
[16:05:54.698]                       }
[16:05:54.698]                       else if (inherits(cond, "warning")) {
[16:05:54.698]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.698]                         if (muffled) 
[16:05:54.698]                           invokeRestart("muffleWarning")
[16:05:54.698]                       }
[16:05:54.698]                       else if (inherits(cond, "condition")) {
[16:05:54.698]                         if (!is.null(pattern)) {
[16:05:54.698]                           computeRestarts <- base::computeRestarts
[16:05:54.698]                           grepl <- base::grepl
[16:05:54.698]                           restarts <- computeRestarts(cond)
[16:05:54.698]                           for (restart in restarts) {
[16:05:54.698]                             name <- restart$name
[16:05:54.698]                             if (is.null(name)) 
[16:05:54.698]                               next
[16:05:54.698]                             if (!grepl(pattern, name)) 
[16:05:54.698]                               next
[16:05:54.698]                             invokeRestart(restart)
[16:05:54.698]                             muffled <- TRUE
[16:05:54.698]                             break
[16:05:54.698]                           }
[16:05:54.698]                         }
[16:05:54.698]                       }
[16:05:54.698]                       invisible(muffled)
[16:05:54.698]                     }
[16:05:54.698]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.698]                   }
[16:05:54.698]                 }
[16:05:54.698]                 else {
[16:05:54.698]                   if (TRUE) {
[16:05:54.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.698]                     {
[16:05:54.698]                       inherits <- base::inherits
[16:05:54.698]                       invokeRestart <- base::invokeRestart
[16:05:54.698]                       is.null <- base::is.null
[16:05:54.698]                       muffled <- FALSE
[16:05:54.698]                       if (inherits(cond, "message")) {
[16:05:54.698]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.698]                         if (muffled) 
[16:05:54.698]                           invokeRestart("muffleMessage")
[16:05:54.698]                       }
[16:05:54.698]                       else if (inherits(cond, "warning")) {
[16:05:54.698]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.698]                         if (muffled) 
[16:05:54.698]                           invokeRestart("muffleWarning")
[16:05:54.698]                       }
[16:05:54.698]                       else if (inherits(cond, "condition")) {
[16:05:54.698]                         if (!is.null(pattern)) {
[16:05:54.698]                           computeRestarts <- base::computeRestarts
[16:05:54.698]                           grepl <- base::grepl
[16:05:54.698]                           restarts <- computeRestarts(cond)
[16:05:54.698]                           for (restart in restarts) {
[16:05:54.698]                             name <- restart$name
[16:05:54.698]                             if (is.null(name)) 
[16:05:54.698]                               next
[16:05:54.698]                             if (!grepl(pattern, name)) 
[16:05:54.698]                               next
[16:05:54.698]                             invokeRestart(restart)
[16:05:54.698]                             muffled <- TRUE
[16:05:54.698]                             break
[16:05:54.698]                           }
[16:05:54.698]                         }
[16:05:54.698]                       }
[16:05:54.698]                       invisible(muffled)
[16:05:54.698]                     }
[16:05:54.698]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.698]                   }
[16:05:54.698]                 }
[16:05:54.698]             }
[16:05:54.698]         }))
[16:05:54.698]     }, error = function(ex) {
[16:05:54.698]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.698]                 ...future.rng), started = ...future.startTime, 
[16:05:54.698]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.698]             version = "1.8"), class = "FutureResult")
[16:05:54.698]     }, finally = {
[16:05:54.698]         if (!identical(...future.workdir, getwd())) 
[16:05:54.698]             setwd(...future.workdir)
[16:05:54.698]         {
[16:05:54.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.698]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.698]             }
[16:05:54.698]             base::options(...future.oldOptions)
[16:05:54.698]             if (.Platform$OS.type == "windows") {
[16:05:54.698]                 old_names <- names(...future.oldEnvVars)
[16:05:54.698]                 envs <- base::Sys.getenv()
[16:05:54.698]                 names <- names(envs)
[16:05:54.698]                 common <- intersect(names, old_names)
[16:05:54.698]                 added <- setdiff(names, old_names)
[16:05:54.698]                 removed <- setdiff(old_names, names)
[16:05:54.698]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.698]                   envs[common]]
[16:05:54.698]                 NAMES <- toupper(changed)
[16:05:54.698]                 args <- list()
[16:05:54.698]                 for (kk in seq_along(NAMES)) {
[16:05:54.698]                   name <- changed[[kk]]
[16:05:54.698]                   NAME <- NAMES[[kk]]
[16:05:54.698]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.698]                     next
[16:05:54.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.698]                 }
[16:05:54.698]                 NAMES <- toupper(added)
[16:05:54.698]                 for (kk in seq_along(NAMES)) {
[16:05:54.698]                   name <- added[[kk]]
[16:05:54.698]                   NAME <- NAMES[[kk]]
[16:05:54.698]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.698]                     next
[16:05:54.698]                   args[[name]] <- ""
[16:05:54.698]                 }
[16:05:54.698]                 NAMES <- toupper(removed)
[16:05:54.698]                 for (kk in seq_along(NAMES)) {
[16:05:54.698]                   name <- removed[[kk]]
[16:05:54.698]                   NAME <- NAMES[[kk]]
[16:05:54.698]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.698]                     next
[16:05:54.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.698]                 }
[16:05:54.698]                 if (length(args) > 0) 
[16:05:54.698]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.698]             }
[16:05:54.698]             else {
[16:05:54.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.698]             }
[16:05:54.698]             {
[16:05:54.698]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.698]                   0L) {
[16:05:54.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.698]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.698]                   base::options(opts)
[16:05:54.698]                 }
[16:05:54.698]                 {
[16:05:54.698]                   {
[16:05:54.698]                     NULL
[16:05:54.698]                     RNGkind("Mersenne-Twister")
[16:05:54.698]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.698]                       inherits = FALSE)
[16:05:54.698]                   }
[16:05:54.698]                   options(future.plan = NULL)
[16:05:54.698]                   if (is.na(NA_character_)) 
[16:05:54.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.698]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.698]                   {
[16:05:54.698]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.698]                     if (!future$lazy) 
[16:05:54.698]                       future <- run(future)
[16:05:54.698]                     invisible(future)
[16:05:54.698]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.698]                 }
[16:05:54.698]             }
[16:05:54.698]         }
[16:05:54.698]     })
[16:05:54.698]     if (TRUE) {
[16:05:54.698]         base::sink(type = "output", split = FALSE)
[16:05:54.698]         if (TRUE) {
[16:05:54.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.698]         }
[16:05:54.698]         else {
[16:05:54.698]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.698]         }
[16:05:54.698]         base::close(...future.stdout)
[16:05:54.698]         ...future.stdout <- NULL
[16:05:54.698]     }
[16:05:54.698]     ...future.result$conditions <- ...future.conditions
[16:05:54.698]     ...future.result$finished <- base::Sys.time()
[16:05:54.698]     ...future.result
[16:05:54.698] }
[16:05:54.700] assign_globals() ...
[16:05:54.700] List of 1
[16:05:54.700]  $ kk: int 3
[16:05:54.700]  - attr(*, "where")=List of 1
[16:05:54.700]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:54.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:54.700]  - attr(*, "resolved")= logi FALSE
[16:05:54.700]  - attr(*, "total_size")= num 56
[16:05:54.700]  - attr(*, "already-done")= logi TRUE
[16:05:54.703] - copied ‘kk’ to environment
[16:05:54.703] assign_globals() ... done
[16:05:54.703] plan(): Setting new future strategy stack:
[16:05:54.703] List of future strategies:
[16:05:54.703] 1. sequential:
[16:05:54.703]    - args: function (..., envir = parent.frame())
[16:05:54.703]    - tweaked: FALSE
[16:05:54.703]    - call: NULL
[16:05:54.704] plan(): nbrOfWorkers() = 1
[16:05:54.805] plan(): Setting new future strategy stack:
[16:05:54.805] List of future strategies:
[16:05:54.805] 1. sequential:
[16:05:54.805]    - args: function (..., envir = parent.frame())
[16:05:54.805]    - tweaked: FALSE
[16:05:54.805]    - call: plan(strategy)
[16:05:54.805] plan(): nbrOfWorkers() = 1
[16:05:54.805] SequentialFuture started (and completed)
[16:05:54.806] - Launch lazy future ... done
[16:05:54.806] run() for ‘SequentialFuture’ ... done
[16:05:54.806] resolved() for ‘SequentialFuture’ ...
[16:05:54.806] - state: ‘finished’
[16:05:54.806] - run: TRUE
[16:05:54.806] - result: ‘FutureResult’
[16:05:54.806] resolved() for ‘SequentialFuture’ ... done
[16:05:54.806] Future #3
[16:05:54.806]  length: 0 (resolved future 3)
[16:05:54.806] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:05:54.807] resolve() on environment ...
[16:05:54.807]  recursive: 0
[16:05:54.808]  elements: [2] ‘a’, ‘b’
[16:05:54.809]  length: 1 (resolved future 1)
[16:05:54.809]  length: 0 (resolved future 2)
[16:05:54.809] resolve() on environment ... DONE
[16:05:54.809] getGlobalsAndPackages() ...
[16:05:54.809] Searching for globals...
[16:05:54.809] 
[16:05:54.810] Searching for globals ... DONE
[16:05:54.810] - globals: [0] <none>
[16:05:54.810] getGlobalsAndPackages() ... DONE
[16:05:54.810] run() for ‘Future’ ...
[16:05:54.810] - state: ‘created’
[16:05:54.810] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.810] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.811] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.811]   - Field: ‘label’
[16:05:54.811]   - Field: ‘local’
[16:05:54.811]   - Field: ‘owner’
[16:05:54.811]   - Field: ‘envir’
[16:05:54.811]   - Field: ‘packages’
[16:05:54.811]   - Field: ‘gc’
[16:05:54.811]   - Field: ‘conditions’
[16:05:54.811]   - Field: ‘expr’
[16:05:54.811]   - Field: ‘uuid’
[16:05:54.811]   - Field: ‘seed’
[16:05:54.812]   - Field: ‘version’
[16:05:54.812]   - Field: ‘result’
[16:05:54.812]   - Field: ‘asynchronous’
[16:05:54.812]   - Field: ‘calls’
[16:05:54.812]   - Field: ‘globals’
[16:05:54.812]   - Field: ‘stdout’
[16:05:54.812]   - Field: ‘earlySignal’
[16:05:54.812]   - Field: ‘lazy’
[16:05:54.812]   - Field: ‘state’
[16:05:54.812] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.812] - Launch lazy future ...
[16:05:54.813] Packages needed by the future expression (n = 0): <none>
[16:05:54.813] Packages needed by future strategies (n = 0): <none>
[16:05:54.813] {
[16:05:54.813]     {
[16:05:54.813]         {
[16:05:54.813]             ...future.startTime <- base::Sys.time()
[16:05:54.813]             {
[16:05:54.813]                 {
[16:05:54.813]                   {
[16:05:54.813]                     base::local({
[16:05:54.813]                       has_future <- base::requireNamespace("future", 
[16:05:54.813]                         quietly = TRUE)
[16:05:54.813]                       if (has_future) {
[16:05:54.813]                         ns <- base::getNamespace("future")
[16:05:54.813]                         version <- ns[[".package"]][["version"]]
[16:05:54.813]                         if (is.null(version)) 
[16:05:54.813]                           version <- utils::packageVersion("future")
[16:05:54.813]                       }
[16:05:54.813]                       else {
[16:05:54.813]                         version <- NULL
[16:05:54.813]                       }
[16:05:54.813]                       if (!has_future || version < "1.8.0") {
[16:05:54.813]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.813]                           "", base::R.version$version.string), 
[16:05:54.813]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.813]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.813]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.813]                             "release", "version")], collapse = " "), 
[16:05:54.813]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.813]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.813]                           info)
[16:05:54.813]                         info <- base::paste(info, collapse = "; ")
[16:05:54.813]                         if (!has_future) {
[16:05:54.813]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.813]                             info)
[16:05:54.813]                         }
[16:05:54.813]                         else {
[16:05:54.813]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.813]                             info, version)
[16:05:54.813]                         }
[16:05:54.813]                         base::stop(msg)
[16:05:54.813]                       }
[16:05:54.813]                     })
[16:05:54.813]                   }
[16:05:54.813]                   options(future.plan = NULL)
[16:05:54.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.813]                 }
[16:05:54.813]                 ...future.workdir <- getwd()
[16:05:54.813]             }
[16:05:54.813]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.813]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.813]         }
[16:05:54.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.813]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.813]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.813]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.813]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.813]             base::names(...future.oldOptions))
[16:05:54.813]     }
[16:05:54.813]     if (FALSE) {
[16:05:54.813]     }
[16:05:54.813]     else {
[16:05:54.813]         if (TRUE) {
[16:05:54.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.813]                 open = "w")
[16:05:54.813]         }
[16:05:54.813]         else {
[16:05:54.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.813]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.813]         }
[16:05:54.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.813]             base::sink(type = "output", split = FALSE)
[16:05:54.813]             base::close(...future.stdout)
[16:05:54.813]         }, add = TRUE)
[16:05:54.813]     }
[16:05:54.813]     ...future.frame <- base::sys.nframe()
[16:05:54.813]     ...future.conditions <- base::list()
[16:05:54.813]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.813]     if (FALSE) {
[16:05:54.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.813]     }
[16:05:54.813]     ...future.result <- base::tryCatch({
[16:05:54.813]         base::withCallingHandlers({
[16:05:54.813]             ...future.value <- base::withVisible(base::local(1))
[16:05:54.813]             future::FutureResult(value = ...future.value$value, 
[16:05:54.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.813]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.813]                     ...future.globalenv.names))
[16:05:54.813]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.813]         }, condition = base::local({
[16:05:54.813]             c <- base::c
[16:05:54.813]             inherits <- base::inherits
[16:05:54.813]             invokeRestart <- base::invokeRestart
[16:05:54.813]             length <- base::length
[16:05:54.813]             list <- base::list
[16:05:54.813]             seq.int <- base::seq.int
[16:05:54.813]             signalCondition <- base::signalCondition
[16:05:54.813]             sys.calls <- base::sys.calls
[16:05:54.813]             `[[` <- base::`[[`
[16:05:54.813]             `+` <- base::`+`
[16:05:54.813]             `<<-` <- base::`<<-`
[16:05:54.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.813]                   3L)]
[16:05:54.813]             }
[16:05:54.813]             function(cond) {
[16:05:54.813]                 is_error <- inherits(cond, "error")
[16:05:54.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.813]                   NULL)
[16:05:54.813]                 if (is_error) {
[16:05:54.813]                   sessionInformation <- function() {
[16:05:54.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.813]                       search = base::search(), system = base::Sys.info())
[16:05:54.813]                   }
[16:05:54.813]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.813]                     cond$call), session = sessionInformation(), 
[16:05:54.813]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.813]                   signalCondition(cond)
[16:05:54.813]                 }
[16:05:54.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.813]                 "immediateCondition"))) {
[16:05:54.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.813]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.813]                   if (TRUE && !signal) {
[16:05:54.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.813]                     {
[16:05:54.813]                       inherits <- base::inherits
[16:05:54.813]                       invokeRestart <- base::invokeRestart
[16:05:54.813]                       is.null <- base::is.null
[16:05:54.813]                       muffled <- FALSE
[16:05:54.813]                       if (inherits(cond, "message")) {
[16:05:54.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.813]                         if (muffled) 
[16:05:54.813]                           invokeRestart("muffleMessage")
[16:05:54.813]                       }
[16:05:54.813]                       else if (inherits(cond, "warning")) {
[16:05:54.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.813]                         if (muffled) 
[16:05:54.813]                           invokeRestart("muffleWarning")
[16:05:54.813]                       }
[16:05:54.813]                       else if (inherits(cond, "condition")) {
[16:05:54.813]                         if (!is.null(pattern)) {
[16:05:54.813]                           computeRestarts <- base::computeRestarts
[16:05:54.813]                           grepl <- base::grepl
[16:05:54.813]                           restarts <- computeRestarts(cond)
[16:05:54.813]                           for (restart in restarts) {
[16:05:54.813]                             name <- restart$name
[16:05:54.813]                             if (is.null(name)) 
[16:05:54.813]                               next
[16:05:54.813]                             if (!grepl(pattern, name)) 
[16:05:54.813]                               next
[16:05:54.813]                             invokeRestart(restart)
[16:05:54.813]                             muffled <- TRUE
[16:05:54.813]                             break
[16:05:54.813]                           }
[16:05:54.813]                         }
[16:05:54.813]                       }
[16:05:54.813]                       invisible(muffled)
[16:05:54.813]                     }
[16:05:54.813]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.813]                   }
[16:05:54.813]                 }
[16:05:54.813]                 else {
[16:05:54.813]                   if (TRUE) {
[16:05:54.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.813]                     {
[16:05:54.813]                       inherits <- base::inherits
[16:05:54.813]                       invokeRestart <- base::invokeRestart
[16:05:54.813]                       is.null <- base::is.null
[16:05:54.813]                       muffled <- FALSE
[16:05:54.813]                       if (inherits(cond, "message")) {
[16:05:54.813]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.813]                         if (muffled) 
[16:05:54.813]                           invokeRestart("muffleMessage")
[16:05:54.813]                       }
[16:05:54.813]                       else if (inherits(cond, "warning")) {
[16:05:54.813]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.813]                         if (muffled) 
[16:05:54.813]                           invokeRestart("muffleWarning")
[16:05:54.813]                       }
[16:05:54.813]                       else if (inherits(cond, "condition")) {
[16:05:54.813]                         if (!is.null(pattern)) {
[16:05:54.813]                           computeRestarts <- base::computeRestarts
[16:05:54.813]                           grepl <- base::grepl
[16:05:54.813]                           restarts <- computeRestarts(cond)
[16:05:54.813]                           for (restart in restarts) {
[16:05:54.813]                             name <- restart$name
[16:05:54.813]                             if (is.null(name)) 
[16:05:54.813]                               next
[16:05:54.813]                             if (!grepl(pattern, name)) 
[16:05:54.813]                               next
[16:05:54.813]                             invokeRestart(restart)
[16:05:54.813]                             muffled <- TRUE
[16:05:54.813]                             break
[16:05:54.813]                           }
[16:05:54.813]                         }
[16:05:54.813]                       }
[16:05:54.813]                       invisible(muffled)
[16:05:54.813]                     }
[16:05:54.813]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.813]                   }
[16:05:54.813]                 }
[16:05:54.813]             }
[16:05:54.813]         }))
[16:05:54.813]     }, error = function(ex) {
[16:05:54.813]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.813]                 ...future.rng), started = ...future.startTime, 
[16:05:54.813]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.813]             version = "1.8"), class = "FutureResult")
[16:05:54.813]     }, finally = {
[16:05:54.813]         if (!identical(...future.workdir, getwd())) 
[16:05:54.813]             setwd(...future.workdir)
[16:05:54.813]         {
[16:05:54.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.813]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.813]             }
[16:05:54.813]             base::options(...future.oldOptions)
[16:05:54.813]             if (.Platform$OS.type == "windows") {
[16:05:54.813]                 old_names <- names(...future.oldEnvVars)
[16:05:54.813]                 envs <- base::Sys.getenv()
[16:05:54.813]                 names <- names(envs)
[16:05:54.813]                 common <- intersect(names, old_names)
[16:05:54.813]                 added <- setdiff(names, old_names)
[16:05:54.813]                 removed <- setdiff(old_names, names)
[16:05:54.813]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.813]                   envs[common]]
[16:05:54.813]                 NAMES <- toupper(changed)
[16:05:54.813]                 args <- list()
[16:05:54.813]                 for (kk in seq_along(NAMES)) {
[16:05:54.813]                   name <- changed[[kk]]
[16:05:54.813]                   NAME <- NAMES[[kk]]
[16:05:54.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.813]                     next
[16:05:54.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.813]                 }
[16:05:54.813]                 NAMES <- toupper(added)
[16:05:54.813]                 for (kk in seq_along(NAMES)) {
[16:05:54.813]                   name <- added[[kk]]
[16:05:54.813]                   NAME <- NAMES[[kk]]
[16:05:54.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.813]                     next
[16:05:54.813]                   args[[name]] <- ""
[16:05:54.813]                 }
[16:05:54.813]                 NAMES <- toupper(removed)
[16:05:54.813]                 for (kk in seq_along(NAMES)) {
[16:05:54.813]                   name <- removed[[kk]]
[16:05:54.813]                   NAME <- NAMES[[kk]]
[16:05:54.813]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.813]                     next
[16:05:54.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.813]                 }
[16:05:54.813]                 if (length(args) > 0) 
[16:05:54.813]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.813]             }
[16:05:54.813]             else {
[16:05:54.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.813]             }
[16:05:54.813]             {
[16:05:54.813]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.813]                   0L) {
[16:05:54.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.813]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.813]                   base::options(opts)
[16:05:54.813]                 }
[16:05:54.813]                 {
[16:05:54.813]                   {
[16:05:54.813]                     NULL
[16:05:54.813]                     RNGkind("Mersenne-Twister")
[16:05:54.813]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.813]                       inherits = FALSE)
[16:05:54.813]                   }
[16:05:54.813]                   options(future.plan = NULL)
[16:05:54.813]                   if (is.na(NA_character_)) 
[16:05:54.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.813]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.813]                   {
[16:05:54.813]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.813]                     if (!future$lazy) 
[16:05:54.813]                       future <- run(future)
[16:05:54.813]                     invisible(future)
[16:05:54.813]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.813]                 }
[16:05:54.813]             }
[16:05:54.813]         }
[16:05:54.813]     })
[16:05:54.813]     if (TRUE) {
[16:05:54.813]         base::sink(type = "output", split = FALSE)
[16:05:54.813]         if (TRUE) {
[16:05:54.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.813]         }
[16:05:54.813]         else {
[16:05:54.813]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.813]         }
[16:05:54.813]         base::close(...future.stdout)
[16:05:54.813]         ...future.stdout <- NULL
[16:05:54.813]     }
[16:05:54.813]     ...future.result$conditions <- ...future.conditions
[16:05:54.813]     ...future.result$finished <- base::Sys.time()
[16:05:54.813]     ...future.result
[16:05:54.813] }
[16:05:54.815] plan(): Setting new future strategy stack:
[16:05:54.815] List of future strategies:
[16:05:54.815] 1. sequential:
[16:05:54.815]    - args: function (..., envir = parent.frame())
[16:05:54.815]    - tweaked: FALSE
[16:05:54.815]    - call: NULL
[16:05:54.815] plan(): nbrOfWorkers() = 1
[16:05:54.816] plan(): Setting new future strategy stack:
[16:05:54.816] List of future strategies:
[16:05:54.816] 1. sequential:
[16:05:54.816]    - args: function (..., envir = parent.frame())
[16:05:54.816]    - tweaked: FALSE
[16:05:54.816]    - call: plan(strategy)
[16:05:54.816] plan(): nbrOfWorkers() = 1
[16:05:54.816] SequentialFuture started (and completed)
[16:05:54.816] - Launch lazy future ... done
[16:05:54.817] run() for ‘SequentialFuture’ ... done
[16:05:54.817] getGlobalsAndPackages() ...
[16:05:54.817] Searching for globals...
[16:05:54.817] 
[16:05:54.817] Searching for globals ... DONE
[16:05:54.817] - globals: [0] <none>
[16:05:54.817] getGlobalsAndPackages() ... DONE
[16:05:54.817] run() for ‘Future’ ...
[16:05:54.818] - state: ‘created’
[16:05:54.818] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.818] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.818] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.818]   - Field: ‘label’
[16:05:54.818]   - Field: ‘local’
[16:05:54.818]   - Field: ‘owner’
[16:05:54.818]   - Field: ‘envir’
[16:05:54.818]   - Field: ‘packages’
[16:05:54.819]   - Field: ‘gc’
[16:05:54.819]   - Field: ‘conditions’
[16:05:54.819]   - Field: ‘expr’
[16:05:54.819]   - Field: ‘uuid’
[16:05:54.819]   - Field: ‘seed’
[16:05:54.819]   - Field: ‘version’
[16:05:54.819]   - Field: ‘result’
[16:05:54.819]   - Field: ‘asynchronous’
[16:05:54.819]   - Field: ‘calls’
[16:05:54.819]   - Field: ‘globals’
[16:05:54.819]   - Field: ‘stdout’
[16:05:54.820]   - Field: ‘earlySignal’
[16:05:54.820]   - Field: ‘lazy’
[16:05:54.820]   - Field: ‘state’
[16:05:54.820] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.820] - Launch lazy future ...
[16:05:54.820] Packages needed by the future expression (n = 0): <none>
[16:05:54.820] Packages needed by future strategies (n = 0): <none>
[16:05:54.820] {
[16:05:54.820]     {
[16:05:54.820]         {
[16:05:54.820]             ...future.startTime <- base::Sys.time()
[16:05:54.820]             {
[16:05:54.820]                 {
[16:05:54.820]                   {
[16:05:54.820]                     base::local({
[16:05:54.820]                       has_future <- base::requireNamespace("future", 
[16:05:54.820]                         quietly = TRUE)
[16:05:54.820]                       if (has_future) {
[16:05:54.820]                         ns <- base::getNamespace("future")
[16:05:54.820]                         version <- ns[[".package"]][["version"]]
[16:05:54.820]                         if (is.null(version)) 
[16:05:54.820]                           version <- utils::packageVersion("future")
[16:05:54.820]                       }
[16:05:54.820]                       else {
[16:05:54.820]                         version <- NULL
[16:05:54.820]                       }
[16:05:54.820]                       if (!has_future || version < "1.8.0") {
[16:05:54.820]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.820]                           "", base::R.version$version.string), 
[16:05:54.820]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.820]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.820]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.820]                             "release", "version")], collapse = " "), 
[16:05:54.820]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.820]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.820]                           info)
[16:05:54.820]                         info <- base::paste(info, collapse = "; ")
[16:05:54.820]                         if (!has_future) {
[16:05:54.820]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.820]                             info)
[16:05:54.820]                         }
[16:05:54.820]                         else {
[16:05:54.820]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.820]                             info, version)
[16:05:54.820]                         }
[16:05:54.820]                         base::stop(msg)
[16:05:54.820]                       }
[16:05:54.820]                     })
[16:05:54.820]                   }
[16:05:54.820]                   options(future.plan = NULL)
[16:05:54.820]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.820]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.820]                 }
[16:05:54.820]                 ...future.workdir <- getwd()
[16:05:54.820]             }
[16:05:54.820]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.820]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.820]         }
[16:05:54.820]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.820]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.820]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.820]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.820]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.820]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.820]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.820]             base::names(...future.oldOptions))
[16:05:54.820]     }
[16:05:54.820]     if (FALSE) {
[16:05:54.820]     }
[16:05:54.820]     else {
[16:05:54.820]         if (TRUE) {
[16:05:54.820]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.820]                 open = "w")
[16:05:54.820]         }
[16:05:54.820]         else {
[16:05:54.820]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.820]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.820]         }
[16:05:54.820]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.820]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.820]             base::sink(type = "output", split = FALSE)
[16:05:54.820]             base::close(...future.stdout)
[16:05:54.820]         }, add = TRUE)
[16:05:54.820]     }
[16:05:54.820]     ...future.frame <- base::sys.nframe()
[16:05:54.820]     ...future.conditions <- base::list()
[16:05:54.820]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.820]     if (FALSE) {
[16:05:54.820]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.820]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.820]     }
[16:05:54.820]     ...future.result <- base::tryCatch({
[16:05:54.820]         base::withCallingHandlers({
[16:05:54.820]             ...future.value <- base::withVisible(base::local(2))
[16:05:54.820]             future::FutureResult(value = ...future.value$value, 
[16:05:54.820]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.820]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.820]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.820]                     ...future.globalenv.names))
[16:05:54.820]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.820]         }, condition = base::local({
[16:05:54.820]             c <- base::c
[16:05:54.820]             inherits <- base::inherits
[16:05:54.820]             invokeRestart <- base::invokeRestart
[16:05:54.820]             length <- base::length
[16:05:54.820]             list <- base::list
[16:05:54.820]             seq.int <- base::seq.int
[16:05:54.820]             signalCondition <- base::signalCondition
[16:05:54.820]             sys.calls <- base::sys.calls
[16:05:54.820]             `[[` <- base::`[[`
[16:05:54.820]             `+` <- base::`+`
[16:05:54.820]             `<<-` <- base::`<<-`
[16:05:54.820]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.820]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.820]                   3L)]
[16:05:54.820]             }
[16:05:54.820]             function(cond) {
[16:05:54.820]                 is_error <- inherits(cond, "error")
[16:05:54.820]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.820]                   NULL)
[16:05:54.820]                 if (is_error) {
[16:05:54.820]                   sessionInformation <- function() {
[16:05:54.820]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.820]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.820]                       search = base::search(), system = base::Sys.info())
[16:05:54.820]                   }
[16:05:54.820]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.820]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.820]                     cond$call), session = sessionInformation(), 
[16:05:54.820]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.820]                   signalCondition(cond)
[16:05:54.820]                 }
[16:05:54.820]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.820]                 "immediateCondition"))) {
[16:05:54.820]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.820]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.820]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.820]                   if (TRUE && !signal) {
[16:05:54.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.820]                     {
[16:05:54.820]                       inherits <- base::inherits
[16:05:54.820]                       invokeRestart <- base::invokeRestart
[16:05:54.820]                       is.null <- base::is.null
[16:05:54.820]                       muffled <- FALSE
[16:05:54.820]                       if (inherits(cond, "message")) {
[16:05:54.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.820]                         if (muffled) 
[16:05:54.820]                           invokeRestart("muffleMessage")
[16:05:54.820]                       }
[16:05:54.820]                       else if (inherits(cond, "warning")) {
[16:05:54.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.820]                         if (muffled) 
[16:05:54.820]                           invokeRestart("muffleWarning")
[16:05:54.820]                       }
[16:05:54.820]                       else if (inherits(cond, "condition")) {
[16:05:54.820]                         if (!is.null(pattern)) {
[16:05:54.820]                           computeRestarts <- base::computeRestarts
[16:05:54.820]                           grepl <- base::grepl
[16:05:54.820]                           restarts <- computeRestarts(cond)
[16:05:54.820]                           for (restart in restarts) {
[16:05:54.820]                             name <- restart$name
[16:05:54.820]                             if (is.null(name)) 
[16:05:54.820]                               next
[16:05:54.820]                             if (!grepl(pattern, name)) 
[16:05:54.820]                               next
[16:05:54.820]                             invokeRestart(restart)
[16:05:54.820]                             muffled <- TRUE
[16:05:54.820]                             break
[16:05:54.820]                           }
[16:05:54.820]                         }
[16:05:54.820]                       }
[16:05:54.820]                       invisible(muffled)
[16:05:54.820]                     }
[16:05:54.820]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.820]                   }
[16:05:54.820]                 }
[16:05:54.820]                 else {
[16:05:54.820]                   if (TRUE) {
[16:05:54.820]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.820]                     {
[16:05:54.820]                       inherits <- base::inherits
[16:05:54.820]                       invokeRestart <- base::invokeRestart
[16:05:54.820]                       is.null <- base::is.null
[16:05:54.820]                       muffled <- FALSE
[16:05:54.820]                       if (inherits(cond, "message")) {
[16:05:54.820]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.820]                         if (muffled) 
[16:05:54.820]                           invokeRestart("muffleMessage")
[16:05:54.820]                       }
[16:05:54.820]                       else if (inherits(cond, "warning")) {
[16:05:54.820]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.820]                         if (muffled) 
[16:05:54.820]                           invokeRestart("muffleWarning")
[16:05:54.820]                       }
[16:05:54.820]                       else if (inherits(cond, "condition")) {
[16:05:54.820]                         if (!is.null(pattern)) {
[16:05:54.820]                           computeRestarts <- base::computeRestarts
[16:05:54.820]                           grepl <- base::grepl
[16:05:54.820]                           restarts <- computeRestarts(cond)
[16:05:54.820]                           for (restart in restarts) {
[16:05:54.820]                             name <- restart$name
[16:05:54.820]                             if (is.null(name)) 
[16:05:54.820]                               next
[16:05:54.820]                             if (!grepl(pattern, name)) 
[16:05:54.820]                               next
[16:05:54.820]                             invokeRestart(restart)
[16:05:54.820]                             muffled <- TRUE
[16:05:54.820]                             break
[16:05:54.820]                           }
[16:05:54.820]                         }
[16:05:54.820]                       }
[16:05:54.820]                       invisible(muffled)
[16:05:54.820]                     }
[16:05:54.820]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.820]                   }
[16:05:54.820]                 }
[16:05:54.820]             }
[16:05:54.820]         }))
[16:05:54.820]     }, error = function(ex) {
[16:05:54.820]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.820]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.820]                 ...future.rng), started = ...future.startTime, 
[16:05:54.820]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.820]             version = "1.8"), class = "FutureResult")
[16:05:54.820]     }, finally = {
[16:05:54.820]         if (!identical(...future.workdir, getwd())) 
[16:05:54.820]             setwd(...future.workdir)
[16:05:54.820]         {
[16:05:54.820]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.820]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.820]             }
[16:05:54.820]             base::options(...future.oldOptions)
[16:05:54.820]             if (.Platform$OS.type == "windows") {
[16:05:54.820]                 old_names <- names(...future.oldEnvVars)
[16:05:54.820]                 envs <- base::Sys.getenv()
[16:05:54.820]                 names <- names(envs)
[16:05:54.820]                 common <- intersect(names, old_names)
[16:05:54.820]                 added <- setdiff(names, old_names)
[16:05:54.820]                 removed <- setdiff(old_names, names)
[16:05:54.820]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.820]                   envs[common]]
[16:05:54.820]                 NAMES <- toupper(changed)
[16:05:54.820]                 args <- list()
[16:05:54.820]                 for (kk in seq_along(NAMES)) {
[16:05:54.820]                   name <- changed[[kk]]
[16:05:54.820]                   NAME <- NAMES[[kk]]
[16:05:54.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.820]                     next
[16:05:54.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.820]                 }
[16:05:54.820]                 NAMES <- toupper(added)
[16:05:54.820]                 for (kk in seq_along(NAMES)) {
[16:05:54.820]                   name <- added[[kk]]
[16:05:54.820]                   NAME <- NAMES[[kk]]
[16:05:54.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.820]                     next
[16:05:54.820]                   args[[name]] <- ""
[16:05:54.820]                 }
[16:05:54.820]                 NAMES <- toupper(removed)
[16:05:54.820]                 for (kk in seq_along(NAMES)) {
[16:05:54.820]                   name <- removed[[kk]]
[16:05:54.820]                   NAME <- NAMES[[kk]]
[16:05:54.820]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.820]                     next
[16:05:54.820]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.820]                 }
[16:05:54.820]                 if (length(args) > 0) 
[16:05:54.820]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.820]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.820]             }
[16:05:54.820]             else {
[16:05:54.820]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.820]             }
[16:05:54.820]             {
[16:05:54.820]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.820]                   0L) {
[16:05:54.820]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.820]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.820]                   base::options(opts)
[16:05:54.820]                 }
[16:05:54.820]                 {
[16:05:54.820]                   {
[16:05:54.820]                     NULL
[16:05:54.820]                     RNGkind("Mersenne-Twister")
[16:05:54.820]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.820]                       inherits = FALSE)
[16:05:54.820]                   }
[16:05:54.820]                   options(future.plan = NULL)
[16:05:54.820]                   if (is.na(NA_character_)) 
[16:05:54.820]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.820]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.820]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.820]                   {
[16:05:54.820]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.820]                     if (!future$lazy) 
[16:05:54.820]                       future <- run(future)
[16:05:54.820]                     invisible(future)
[16:05:54.820]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.820]                 }
[16:05:54.820]             }
[16:05:54.820]         }
[16:05:54.820]     })
[16:05:54.820]     if (TRUE) {
[16:05:54.820]         base::sink(type = "output", split = FALSE)
[16:05:54.820]         if (TRUE) {
[16:05:54.820]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.820]         }
[16:05:54.820]         else {
[16:05:54.820]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.820]         }
[16:05:54.820]         base::close(...future.stdout)
[16:05:54.820]         ...future.stdout <- NULL
[16:05:54.820]     }
[16:05:54.820]     ...future.result$conditions <- ...future.conditions
[16:05:54.820]     ...future.result$finished <- base::Sys.time()
[16:05:54.820]     ...future.result
[16:05:54.820] }
[16:05:54.822] plan(): Setting new future strategy stack:
[16:05:54.822] List of future strategies:
[16:05:54.822] 1. sequential:
[16:05:54.822]    - args: function (..., envir = parent.frame())
[16:05:54.822]    - tweaked: FALSE
[16:05:54.822]    - call: NULL
[16:05:54.823] plan(): nbrOfWorkers() = 1
[16:05:54.823] plan(): Setting new future strategy stack:
[16:05:54.823] List of future strategies:
[16:05:54.823] 1. sequential:
[16:05:54.823]    - args: function (..., envir = parent.frame())
[16:05:54.823]    - tweaked: FALSE
[16:05:54.823]    - call: plan(strategy)
[16:05:54.824] plan(): nbrOfWorkers() = 1
[16:05:54.824] SequentialFuture started (and completed)
[16:05:54.824] - Launch lazy future ... done
[16:05:54.824] run() for ‘SequentialFuture’ ... done
[16:05:54.824] resolve() on environment ...
[16:05:54.825]  recursive: 0
[16:05:54.825]  elements: [3] ‘a’, ‘b’, ‘c’
[16:05:54.825] resolved() for ‘SequentialFuture’ ...
[16:05:54.825] - state: ‘finished’
[16:05:54.825] - run: TRUE
[16:05:54.825] - result: ‘FutureResult’
[16:05:54.825] resolved() for ‘SequentialFuture’ ... done
[16:05:54.826] Future #1
[16:05:54.826]  length: 2 (resolved future 1)
[16:05:54.826] resolved() for ‘SequentialFuture’ ...
[16:05:54.826] - state: ‘finished’
[16:05:54.826] - run: TRUE
[16:05:54.826] - result: ‘FutureResult’
[16:05:54.826] resolved() for ‘SequentialFuture’ ... done
[16:05:54.826] Future #2
[16:05:54.826]  length: 1 (resolved future 2)
[16:05:54.826]  length: 0 (resolved future 3)
[16:05:54.826] resolve() on environment ... DONE
[16:05:54.827] resolved() for ‘SequentialFuture’ ...
[16:05:54.827] - state: ‘finished’
[16:05:54.827] - run: TRUE
[16:05:54.827] - result: ‘FutureResult’
[16:05:54.827] resolved() for ‘SequentialFuture’ ... done
[16:05:54.827] resolved() for ‘SequentialFuture’ ...
[16:05:54.827] - state: ‘finished’
[16:05:54.827] - run: TRUE
[16:05:54.827] - result: ‘FutureResult’
[16:05:54.827] resolved() for ‘SequentialFuture’ ... done
[16:05:54.828] getGlobalsAndPackages() ...
[16:05:54.828] Searching for globals...
[16:05:54.829] - globals found: [1] ‘{’
[16:05:54.830] Searching for globals ... DONE
[16:05:54.830] Resolving globals: FALSE
[16:05:54.830] 
[16:05:54.830] 
[16:05:54.830] getGlobalsAndPackages() ... DONE
[16:05:54.831] run() for ‘Future’ ...
[16:05:54.831] - state: ‘created’
[16:05:54.831] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.831] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.831]   - Field: ‘label’
[16:05:54.831]   - Field: ‘local’
[16:05:54.831]   - Field: ‘owner’
[16:05:54.832]   - Field: ‘envir’
[16:05:54.832]   - Field: ‘packages’
[16:05:54.832]   - Field: ‘gc’
[16:05:54.832]   - Field: ‘conditions’
[16:05:54.832]   - Field: ‘expr’
[16:05:54.832]   - Field: ‘uuid’
[16:05:54.832]   - Field: ‘seed’
[16:05:54.832]   - Field: ‘version’
[16:05:54.832]   - Field: ‘result’
[16:05:54.832]   - Field: ‘asynchronous’
[16:05:54.832]   - Field: ‘calls’
[16:05:54.832]   - Field: ‘globals’
[16:05:54.833]   - Field: ‘stdout’
[16:05:54.833]   - Field: ‘earlySignal’
[16:05:54.833]   - Field: ‘lazy’
[16:05:54.833]   - Field: ‘state’
[16:05:54.833] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.833] - Launch lazy future ...
[16:05:54.833] Packages needed by the future expression (n = 0): <none>
[16:05:54.833] Packages needed by future strategies (n = 0): <none>
[16:05:54.834] {
[16:05:54.834]     {
[16:05:54.834]         {
[16:05:54.834]             ...future.startTime <- base::Sys.time()
[16:05:54.834]             {
[16:05:54.834]                 {
[16:05:54.834]                   {
[16:05:54.834]                     base::local({
[16:05:54.834]                       has_future <- base::requireNamespace("future", 
[16:05:54.834]                         quietly = TRUE)
[16:05:54.834]                       if (has_future) {
[16:05:54.834]                         ns <- base::getNamespace("future")
[16:05:54.834]                         version <- ns[[".package"]][["version"]]
[16:05:54.834]                         if (is.null(version)) 
[16:05:54.834]                           version <- utils::packageVersion("future")
[16:05:54.834]                       }
[16:05:54.834]                       else {
[16:05:54.834]                         version <- NULL
[16:05:54.834]                       }
[16:05:54.834]                       if (!has_future || version < "1.8.0") {
[16:05:54.834]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.834]                           "", base::R.version$version.string), 
[16:05:54.834]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.834]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.834]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.834]                             "release", "version")], collapse = " "), 
[16:05:54.834]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.834]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.834]                           info)
[16:05:54.834]                         info <- base::paste(info, collapse = "; ")
[16:05:54.834]                         if (!has_future) {
[16:05:54.834]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.834]                             info)
[16:05:54.834]                         }
[16:05:54.834]                         else {
[16:05:54.834]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.834]                             info, version)
[16:05:54.834]                         }
[16:05:54.834]                         base::stop(msg)
[16:05:54.834]                       }
[16:05:54.834]                     })
[16:05:54.834]                   }
[16:05:54.834]                   options(future.plan = NULL)
[16:05:54.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.834]                 }
[16:05:54.834]                 ...future.workdir <- getwd()
[16:05:54.834]             }
[16:05:54.834]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.834]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.834]         }
[16:05:54.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.834]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.834]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.834]             base::names(...future.oldOptions))
[16:05:54.834]     }
[16:05:54.834]     if (FALSE) {
[16:05:54.834]     }
[16:05:54.834]     else {
[16:05:54.834]         if (TRUE) {
[16:05:54.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.834]                 open = "w")
[16:05:54.834]         }
[16:05:54.834]         else {
[16:05:54.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.834]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.834]         }
[16:05:54.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.834]             base::sink(type = "output", split = FALSE)
[16:05:54.834]             base::close(...future.stdout)
[16:05:54.834]         }, add = TRUE)
[16:05:54.834]     }
[16:05:54.834]     ...future.frame <- base::sys.nframe()
[16:05:54.834]     ...future.conditions <- base::list()
[16:05:54.834]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.834]     if (FALSE) {
[16:05:54.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.834]     }
[16:05:54.834]     ...future.result <- base::tryCatch({
[16:05:54.834]         base::withCallingHandlers({
[16:05:54.834]             ...future.value <- base::withVisible(base::local({
[16:05:54.834]                 1
[16:05:54.834]             }))
[16:05:54.834]             future::FutureResult(value = ...future.value$value, 
[16:05:54.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.834]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.834]                     ...future.globalenv.names))
[16:05:54.834]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.834]         }, condition = base::local({
[16:05:54.834]             c <- base::c
[16:05:54.834]             inherits <- base::inherits
[16:05:54.834]             invokeRestart <- base::invokeRestart
[16:05:54.834]             length <- base::length
[16:05:54.834]             list <- base::list
[16:05:54.834]             seq.int <- base::seq.int
[16:05:54.834]             signalCondition <- base::signalCondition
[16:05:54.834]             sys.calls <- base::sys.calls
[16:05:54.834]             `[[` <- base::`[[`
[16:05:54.834]             `+` <- base::`+`
[16:05:54.834]             `<<-` <- base::`<<-`
[16:05:54.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.834]                   3L)]
[16:05:54.834]             }
[16:05:54.834]             function(cond) {
[16:05:54.834]                 is_error <- inherits(cond, "error")
[16:05:54.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.834]                   NULL)
[16:05:54.834]                 if (is_error) {
[16:05:54.834]                   sessionInformation <- function() {
[16:05:54.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.834]                       search = base::search(), system = base::Sys.info())
[16:05:54.834]                   }
[16:05:54.834]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.834]                     cond$call), session = sessionInformation(), 
[16:05:54.834]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.834]                   signalCondition(cond)
[16:05:54.834]                 }
[16:05:54.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.834]                 "immediateCondition"))) {
[16:05:54.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.834]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.834]                   if (TRUE && !signal) {
[16:05:54.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.834]                     {
[16:05:54.834]                       inherits <- base::inherits
[16:05:54.834]                       invokeRestart <- base::invokeRestart
[16:05:54.834]                       is.null <- base::is.null
[16:05:54.834]                       muffled <- FALSE
[16:05:54.834]                       if (inherits(cond, "message")) {
[16:05:54.834]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.834]                         if (muffled) 
[16:05:54.834]                           invokeRestart("muffleMessage")
[16:05:54.834]                       }
[16:05:54.834]                       else if (inherits(cond, "warning")) {
[16:05:54.834]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.834]                         if (muffled) 
[16:05:54.834]                           invokeRestart("muffleWarning")
[16:05:54.834]                       }
[16:05:54.834]                       else if (inherits(cond, "condition")) {
[16:05:54.834]                         if (!is.null(pattern)) {
[16:05:54.834]                           computeRestarts <- base::computeRestarts
[16:05:54.834]                           grepl <- base::grepl
[16:05:54.834]                           restarts <- computeRestarts(cond)
[16:05:54.834]                           for (restart in restarts) {
[16:05:54.834]                             name <- restart$name
[16:05:54.834]                             if (is.null(name)) 
[16:05:54.834]                               next
[16:05:54.834]                             if (!grepl(pattern, name)) 
[16:05:54.834]                               next
[16:05:54.834]                             invokeRestart(restart)
[16:05:54.834]                             muffled <- TRUE
[16:05:54.834]                             break
[16:05:54.834]                           }
[16:05:54.834]                         }
[16:05:54.834]                       }
[16:05:54.834]                       invisible(muffled)
[16:05:54.834]                     }
[16:05:54.834]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.834]                   }
[16:05:54.834]                 }
[16:05:54.834]                 else {
[16:05:54.834]                   if (TRUE) {
[16:05:54.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.834]                     {
[16:05:54.834]                       inherits <- base::inherits
[16:05:54.834]                       invokeRestart <- base::invokeRestart
[16:05:54.834]                       is.null <- base::is.null
[16:05:54.834]                       muffled <- FALSE
[16:05:54.834]                       if (inherits(cond, "message")) {
[16:05:54.834]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.834]                         if (muffled) 
[16:05:54.834]                           invokeRestart("muffleMessage")
[16:05:54.834]                       }
[16:05:54.834]                       else if (inherits(cond, "warning")) {
[16:05:54.834]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.834]                         if (muffled) 
[16:05:54.834]                           invokeRestart("muffleWarning")
[16:05:54.834]                       }
[16:05:54.834]                       else if (inherits(cond, "condition")) {
[16:05:54.834]                         if (!is.null(pattern)) {
[16:05:54.834]                           computeRestarts <- base::computeRestarts
[16:05:54.834]                           grepl <- base::grepl
[16:05:54.834]                           restarts <- computeRestarts(cond)
[16:05:54.834]                           for (restart in restarts) {
[16:05:54.834]                             name <- restart$name
[16:05:54.834]                             if (is.null(name)) 
[16:05:54.834]                               next
[16:05:54.834]                             if (!grepl(pattern, name)) 
[16:05:54.834]                               next
[16:05:54.834]                             invokeRestart(restart)
[16:05:54.834]                             muffled <- TRUE
[16:05:54.834]                             break
[16:05:54.834]                           }
[16:05:54.834]                         }
[16:05:54.834]                       }
[16:05:54.834]                       invisible(muffled)
[16:05:54.834]                     }
[16:05:54.834]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.834]                   }
[16:05:54.834]                 }
[16:05:54.834]             }
[16:05:54.834]         }))
[16:05:54.834]     }, error = function(ex) {
[16:05:54.834]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.834]                 ...future.rng), started = ...future.startTime, 
[16:05:54.834]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.834]             version = "1.8"), class = "FutureResult")
[16:05:54.834]     }, finally = {
[16:05:54.834]         if (!identical(...future.workdir, getwd())) 
[16:05:54.834]             setwd(...future.workdir)
[16:05:54.834]         {
[16:05:54.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.834]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.834]             }
[16:05:54.834]             base::options(...future.oldOptions)
[16:05:54.834]             if (.Platform$OS.type == "windows") {
[16:05:54.834]                 old_names <- names(...future.oldEnvVars)
[16:05:54.834]                 envs <- base::Sys.getenv()
[16:05:54.834]                 names <- names(envs)
[16:05:54.834]                 common <- intersect(names, old_names)
[16:05:54.834]                 added <- setdiff(names, old_names)
[16:05:54.834]                 removed <- setdiff(old_names, names)
[16:05:54.834]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.834]                   envs[common]]
[16:05:54.834]                 NAMES <- toupper(changed)
[16:05:54.834]                 args <- list()
[16:05:54.834]                 for (kk in seq_along(NAMES)) {
[16:05:54.834]                   name <- changed[[kk]]
[16:05:54.834]                   NAME <- NAMES[[kk]]
[16:05:54.834]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.834]                     next
[16:05:54.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.834]                 }
[16:05:54.834]                 NAMES <- toupper(added)
[16:05:54.834]                 for (kk in seq_along(NAMES)) {
[16:05:54.834]                   name <- added[[kk]]
[16:05:54.834]                   NAME <- NAMES[[kk]]
[16:05:54.834]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.834]                     next
[16:05:54.834]                   args[[name]] <- ""
[16:05:54.834]                 }
[16:05:54.834]                 NAMES <- toupper(removed)
[16:05:54.834]                 for (kk in seq_along(NAMES)) {
[16:05:54.834]                   name <- removed[[kk]]
[16:05:54.834]                   NAME <- NAMES[[kk]]
[16:05:54.834]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.834]                     next
[16:05:54.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.834]                 }
[16:05:54.834]                 if (length(args) > 0) 
[16:05:54.834]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.834]             }
[16:05:54.834]             else {
[16:05:54.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.834]             }
[16:05:54.834]             {
[16:05:54.834]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.834]                   0L) {
[16:05:54.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.834]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.834]                   base::options(opts)
[16:05:54.834]                 }
[16:05:54.834]                 {
[16:05:54.834]                   {
[16:05:54.834]                     NULL
[16:05:54.834]                     RNGkind("Mersenne-Twister")
[16:05:54.834]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.834]                       inherits = FALSE)
[16:05:54.834]                   }
[16:05:54.834]                   options(future.plan = NULL)
[16:05:54.834]                   if (is.na(NA_character_)) 
[16:05:54.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.834]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.834]                   {
[16:05:54.834]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.834]                     if (!future$lazy) 
[16:05:54.834]                       future <- run(future)
[16:05:54.834]                     invisible(future)
[16:05:54.834]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.834]                 }
[16:05:54.834]             }
[16:05:54.834]         }
[16:05:54.834]     })
[16:05:54.834]     if (TRUE) {
[16:05:54.834]         base::sink(type = "output", split = FALSE)
[16:05:54.834]         if (TRUE) {
[16:05:54.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.834]         }
[16:05:54.834]         else {
[16:05:54.834]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.834]         }
[16:05:54.834]         base::close(...future.stdout)
[16:05:54.834]         ...future.stdout <- NULL
[16:05:54.834]     }
[16:05:54.834]     ...future.result$conditions <- ...future.conditions
[16:05:54.834]     ...future.result$finished <- base::Sys.time()
[16:05:54.834]     ...future.result
[16:05:54.834] }
[16:05:54.835] plan(): Setting new future strategy stack:
[16:05:54.835] List of future strategies:
[16:05:54.835] 1. sequential:
[16:05:54.835]    - args: function (..., envir = parent.frame())
[16:05:54.835]    - tweaked: FALSE
[16:05:54.835]    - call: NULL
[16:05:54.836] plan(): nbrOfWorkers() = 1
[16:05:54.836] plan(): Setting new future strategy stack:
[16:05:54.836] List of future strategies:
[16:05:54.836] 1. sequential:
[16:05:54.836]    - args: function (..., envir = parent.frame())
[16:05:54.836]    - tweaked: FALSE
[16:05:54.836]    - call: plan(strategy)
[16:05:54.837] plan(): nbrOfWorkers() = 1
[16:05:54.837] SequentialFuture started (and completed)
[16:05:54.837] - Launch lazy future ... done
[16:05:54.837] run() for ‘SequentialFuture’ ... done
[16:05:54.837] getGlobalsAndPackages() ...
[16:05:54.837] Searching for globals...
[16:05:54.838] - globals found: [1] ‘{’
[16:05:54.838] Searching for globals ... DONE
[16:05:54.838] Resolving globals: FALSE
[16:05:54.838] 
[16:05:54.838] 
[16:05:54.839] getGlobalsAndPackages() ... DONE
[16:05:54.839] run() for ‘Future’ ...
[16:05:54.839] - state: ‘created’
[16:05:54.839] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.839] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.839]   - Field: ‘label’
[16:05:54.840]   - Field: ‘local’
[16:05:54.840]   - Field: ‘owner’
[16:05:54.840]   - Field: ‘envir’
[16:05:54.840]   - Field: ‘packages’
[16:05:54.840]   - Field: ‘gc’
[16:05:54.840]   - Field: ‘conditions’
[16:05:54.840]   - Field: ‘expr’
[16:05:54.840]   - Field: ‘uuid’
[16:05:54.840]   - Field: ‘seed’
[16:05:54.840]   - Field: ‘version’
[16:05:54.840]   - Field: ‘result’
[16:05:54.840]   - Field: ‘asynchronous’
[16:05:54.841]   - Field: ‘calls’
[16:05:54.841]   - Field: ‘globals’
[16:05:54.841]   - Field: ‘stdout’
[16:05:54.841]   - Field: ‘earlySignal’
[16:05:54.841]   - Field: ‘lazy’
[16:05:54.841]   - Field: ‘state’
[16:05:54.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.841] - Launch lazy future ...
[16:05:54.841] Packages needed by the future expression (n = 0): <none>
[16:05:54.841] Packages needed by future strategies (n = 0): <none>
[16:05:54.842] {
[16:05:54.842]     {
[16:05:54.842]         {
[16:05:54.842]             ...future.startTime <- base::Sys.time()
[16:05:54.842]             {
[16:05:54.842]                 {
[16:05:54.842]                   {
[16:05:54.842]                     base::local({
[16:05:54.842]                       has_future <- base::requireNamespace("future", 
[16:05:54.842]                         quietly = TRUE)
[16:05:54.842]                       if (has_future) {
[16:05:54.842]                         ns <- base::getNamespace("future")
[16:05:54.842]                         version <- ns[[".package"]][["version"]]
[16:05:54.842]                         if (is.null(version)) 
[16:05:54.842]                           version <- utils::packageVersion("future")
[16:05:54.842]                       }
[16:05:54.842]                       else {
[16:05:54.842]                         version <- NULL
[16:05:54.842]                       }
[16:05:54.842]                       if (!has_future || version < "1.8.0") {
[16:05:54.842]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.842]                           "", base::R.version$version.string), 
[16:05:54.842]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.842]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.842]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.842]                             "release", "version")], collapse = " "), 
[16:05:54.842]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.842]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.842]                           info)
[16:05:54.842]                         info <- base::paste(info, collapse = "; ")
[16:05:54.842]                         if (!has_future) {
[16:05:54.842]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.842]                             info)
[16:05:54.842]                         }
[16:05:54.842]                         else {
[16:05:54.842]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.842]                             info, version)
[16:05:54.842]                         }
[16:05:54.842]                         base::stop(msg)
[16:05:54.842]                       }
[16:05:54.842]                     })
[16:05:54.842]                   }
[16:05:54.842]                   options(future.plan = NULL)
[16:05:54.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.842]                 }
[16:05:54.842]                 ...future.workdir <- getwd()
[16:05:54.842]             }
[16:05:54.842]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.842]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.842]         }
[16:05:54.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.842]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.842]             base::names(...future.oldOptions))
[16:05:54.842]     }
[16:05:54.842]     if (FALSE) {
[16:05:54.842]     }
[16:05:54.842]     else {
[16:05:54.842]         if (TRUE) {
[16:05:54.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.842]                 open = "w")
[16:05:54.842]         }
[16:05:54.842]         else {
[16:05:54.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.842]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.842]         }
[16:05:54.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.842]             base::sink(type = "output", split = FALSE)
[16:05:54.842]             base::close(...future.stdout)
[16:05:54.842]         }, add = TRUE)
[16:05:54.842]     }
[16:05:54.842]     ...future.frame <- base::sys.nframe()
[16:05:54.842]     ...future.conditions <- base::list()
[16:05:54.842]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.842]     if (FALSE) {
[16:05:54.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.842]     }
[16:05:54.842]     ...future.result <- base::tryCatch({
[16:05:54.842]         base::withCallingHandlers({
[16:05:54.842]             ...future.value <- base::withVisible(base::local({
[16:05:54.842]                 2
[16:05:54.842]             }))
[16:05:54.842]             future::FutureResult(value = ...future.value$value, 
[16:05:54.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.842]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.842]                     ...future.globalenv.names))
[16:05:54.842]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.842]         }, condition = base::local({
[16:05:54.842]             c <- base::c
[16:05:54.842]             inherits <- base::inherits
[16:05:54.842]             invokeRestart <- base::invokeRestart
[16:05:54.842]             length <- base::length
[16:05:54.842]             list <- base::list
[16:05:54.842]             seq.int <- base::seq.int
[16:05:54.842]             signalCondition <- base::signalCondition
[16:05:54.842]             sys.calls <- base::sys.calls
[16:05:54.842]             `[[` <- base::`[[`
[16:05:54.842]             `+` <- base::`+`
[16:05:54.842]             `<<-` <- base::`<<-`
[16:05:54.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.842]                   3L)]
[16:05:54.842]             }
[16:05:54.842]             function(cond) {
[16:05:54.842]                 is_error <- inherits(cond, "error")
[16:05:54.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.842]                   NULL)
[16:05:54.842]                 if (is_error) {
[16:05:54.842]                   sessionInformation <- function() {
[16:05:54.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.842]                       search = base::search(), system = base::Sys.info())
[16:05:54.842]                   }
[16:05:54.842]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.842]                     cond$call), session = sessionInformation(), 
[16:05:54.842]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.842]                   signalCondition(cond)
[16:05:54.842]                 }
[16:05:54.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.842]                 "immediateCondition"))) {
[16:05:54.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.842]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.842]                   if (TRUE && !signal) {
[16:05:54.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.842]                     {
[16:05:54.842]                       inherits <- base::inherits
[16:05:54.842]                       invokeRestart <- base::invokeRestart
[16:05:54.842]                       is.null <- base::is.null
[16:05:54.842]                       muffled <- FALSE
[16:05:54.842]                       if (inherits(cond, "message")) {
[16:05:54.842]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.842]                         if (muffled) 
[16:05:54.842]                           invokeRestart("muffleMessage")
[16:05:54.842]                       }
[16:05:54.842]                       else if (inherits(cond, "warning")) {
[16:05:54.842]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.842]                         if (muffled) 
[16:05:54.842]                           invokeRestart("muffleWarning")
[16:05:54.842]                       }
[16:05:54.842]                       else if (inherits(cond, "condition")) {
[16:05:54.842]                         if (!is.null(pattern)) {
[16:05:54.842]                           computeRestarts <- base::computeRestarts
[16:05:54.842]                           grepl <- base::grepl
[16:05:54.842]                           restarts <- computeRestarts(cond)
[16:05:54.842]                           for (restart in restarts) {
[16:05:54.842]                             name <- restart$name
[16:05:54.842]                             if (is.null(name)) 
[16:05:54.842]                               next
[16:05:54.842]                             if (!grepl(pattern, name)) 
[16:05:54.842]                               next
[16:05:54.842]                             invokeRestart(restart)
[16:05:54.842]                             muffled <- TRUE
[16:05:54.842]                             break
[16:05:54.842]                           }
[16:05:54.842]                         }
[16:05:54.842]                       }
[16:05:54.842]                       invisible(muffled)
[16:05:54.842]                     }
[16:05:54.842]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.842]                   }
[16:05:54.842]                 }
[16:05:54.842]                 else {
[16:05:54.842]                   if (TRUE) {
[16:05:54.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.842]                     {
[16:05:54.842]                       inherits <- base::inherits
[16:05:54.842]                       invokeRestart <- base::invokeRestart
[16:05:54.842]                       is.null <- base::is.null
[16:05:54.842]                       muffled <- FALSE
[16:05:54.842]                       if (inherits(cond, "message")) {
[16:05:54.842]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.842]                         if (muffled) 
[16:05:54.842]                           invokeRestart("muffleMessage")
[16:05:54.842]                       }
[16:05:54.842]                       else if (inherits(cond, "warning")) {
[16:05:54.842]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.842]                         if (muffled) 
[16:05:54.842]                           invokeRestart("muffleWarning")
[16:05:54.842]                       }
[16:05:54.842]                       else if (inherits(cond, "condition")) {
[16:05:54.842]                         if (!is.null(pattern)) {
[16:05:54.842]                           computeRestarts <- base::computeRestarts
[16:05:54.842]                           grepl <- base::grepl
[16:05:54.842]                           restarts <- computeRestarts(cond)
[16:05:54.842]                           for (restart in restarts) {
[16:05:54.842]                             name <- restart$name
[16:05:54.842]                             if (is.null(name)) 
[16:05:54.842]                               next
[16:05:54.842]                             if (!grepl(pattern, name)) 
[16:05:54.842]                               next
[16:05:54.842]                             invokeRestart(restart)
[16:05:54.842]                             muffled <- TRUE
[16:05:54.842]                             break
[16:05:54.842]                           }
[16:05:54.842]                         }
[16:05:54.842]                       }
[16:05:54.842]                       invisible(muffled)
[16:05:54.842]                     }
[16:05:54.842]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.842]                   }
[16:05:54.842]                 }
[16:05:54.842]             }
[16:05:54.842]         }))
[16:05:54.842]     }, error = function(ex) {
[16:05:54.842]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.842]                 ...future.rng), started = ...future.startTime, 
[16:05:54.842]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.842]             version = "1.8"), class = "FutureResult")
[16:05:54.842]     }, finally = {
[16:05:54.842]         if (!identical(...future.workdir, getwd())) 
[16:05:54.842]             setwd(...future.workdir)
[16:05:54.842]         {
[16:05:54.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.842]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.842]             }
[16:05:54.842]             base::options(...future.oldOptions)
[16:05:54.842]             if (.Platform$OS.type == "windows") {
[16:05:54.842]                 old_names <- names(...future.oldEnvVars)
[16:05:54.842]                 envs <- base::Sys.getenv()
[16:05:54.842]                 names <- names(envs)
[16:05:54.842]                 common <- intersect(names, old_names)
[16:05:54.842]                 added <- setdiff(names, old_names)
[16:05:54.842]                 removed <- setdiff(old_names, names)
[16:05:54.842]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.842]                   envs[common]]
[16:05:54.842]                 NAMES <- toupper(changed)
[16:05:54.842]                 args <- list()
[16:05:54.842]                 for (kk in seq_along(NAMES)) {
[16:05:54.842]                   name <- changed[[kk]]
[16:05:54.842]                   NAME <- NAMES[[kk]]
[16:05:54.842]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.842]                     next
[16:05:54.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.842]                 }
[16:05:54.842]                 NAMES <- toupper(added)
[16:05:54.842]                 for (kk in seq_along(NAMES)) {
[16:05:54.842]                   name <- added[[kk]]
[16:05:54.842]                   NAME <- NAMES[[kk]]
[16:05:54.842]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.842]                     next
[16:05:54.842]                   args[[name]] <- ""
[16:05:54.842]                 }
[16:05:54.842]                 NAMES <- toupper(removed)
[16:05:54.842]                 for (kk in seq_along(NAMES)) {
[16:05:54.842]                   name <- removed[[kk]]
[16:05:54.842]                   NAME <- NAMES[[kk]]
[16:05:54.842]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.842]                     next
[16:05:54.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.842]                 }
[16:05:54.842]                 if (length(args) > 0) 
[16:05:54.842]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.842]             }
[16:05:54.842]             else {
[16:05:54.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.842]             }
[16:05:54.842]             {
[16:05:54.842]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.842]                   0L) {
[16:05:54.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.842]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.842]                   base::options(opts)
[16:05:54.842]                 }
[16:05:54.842]                 {
[16:05:54.842]                   {
[16:05:54.842]                     NULL
[16:05:54.842]                     RNGkind("Mersenne-Twister")
[16:05:54.842]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.842]                       inherits = FALSE)
[16:05:54.842]                   }
[16:05:54.842]                   options(future.plan = NULL)
[16:05:54.842]                   if (is.na(NA_character_)) 
[16:05:54.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.842]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.842]                   {
[16:05:54.842]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.842]                     if (!future$lazy) 
[16:05:54.842]                       future <- run(future)
[16:05:54.842]                     invisible(future)
[16:05:54.842]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.842]                 }
[16:05:54.842]             }
[16:05:54.842]         }
[16:05:54.842]     })
[16:05:54.842]     if (TRUE) {
[16:05:54.842]         base::sink(type = "output", split = FALSE)
[16:05:54.842]         if (TRUE) {
[16:05:54.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.842]         }
[16:05:54.842]         else {
[16:05:54.842]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.842]         }
[16:05:54.842]         base::close(...future.stdout)
[16:05:54.842]         ...future.stdout <- NULL
[16:05:54.842]     }
[16:05:54.842]     ...future.result$conditions <- ...future.conditions
[16:05:54.842]     ...future.result$finished <- base::Sys.time()
[16:05:54.842]     ...future.result
[16:05:54.842] }
[16:05:54.843] plan(): Setting new future strategy stack:
[16:05:54.844] List of future strategies:
[16:05:54.844] 1. sequential:
[16:05:54.844]    - args: function (..., envir = parent.frame())
[16:05:54.844]    - tweaked: FALSE
[16:05:54.844]    - call: NULL
[16:05:54.844] plan(): nbrOfWorkers() = 1
[16:05:54.845] plan(): Setting new future strategy stack:
[16:05:54.845] List of future strategies:
[16:05:54.845] 1. sequential:
[16:05:54.845]    - args: function (..., envir = parent.frame())
[16:05:54.845]    - tweaked: FALSE
[16:05:54.845]    - call: plan(strategy)
[16:05:54.845] plan(): nbrOfWorkers() = 1
[16:05:54.845] SequentialFuture started (and completed)
[16:05:54.845] - Launch lazy future ... done
[16:05:54.845] run() for ‘SequentialFuture’ ... done
[16:05:54.846] resolve() on environment ...
[16:05:54.846]  recursive: 0
[16:05:54.846]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:05:54.846] resolved() for ‘SequentialFuture’ ...
[16:05:54.846] - state: ‘finished’
[16:05:54.847] - run: TRUE
[16:05:54.847] - result: ‘FutureResult’
[16:05:54.847] resolved() for ‘SequentialFuture’ ... done
[16:05:54.847] Future #1
[16:05:54.847]  length: 2 (resolved future 1)
[16:05:54.847] resolved() for ‘SequentialFuture’ ...
[16:05:54.847] - state: ‘finished’
[16:05:54.847] - run: TRUE
[16:05:54.847] - result: ‘FutureResult’
[16:05:54.847] resolved() for ‘SequentialFuture’ ... done
[16:05:54.847] Future #2
[16:05:54.848]  length: 1 (resolved future 2)
[16:05:54.848]  length: 0 (resolved future 3)
[16:05:54.848] resolve() on environment ... DONE
[16:05:54.848] getGlobalsAndPackages() ...
[16:05:54.848] Searching for globals...
[16:05:54.849] - globals found: [1] ‘{’
[16:05:54.849] Searching for globals ... DONE
[16:05:54.849] Resolving globals: FALSE
[16:05:54.849] 
[16:05:54.849] 
[16:05:54.849] getGlobalsAndPackages() ... DONE
[16:05:54.849] run() for ‘Future’ ...
[16:05:54.850] - state: ‘created’
[16:05:54.850] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.850] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.850] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.850]   - Field: ‘label’
[16:05:54.850]   - Field: ‘local’
[16:05:54.850]   - Field: ‘owner’
[16:05:54.850]   - Field: ‘envir’
[16:05:54.851]   - Field: ‘packages’
[16:05:54.851]   - Field: ‘gc’
[16:05:54.851]   - Field: ‘conditions’
[16:05:54.851]   - Field: ‘expr’
[16:05:54.851]   - Field: ‘uuid’
[16:05:54.851]   - Field: ‘seed’
[16:05:54.851]   - Field: ‘version’
[16:05:54.851]   - Field: ‘result’
[16:05:54.851]   - Field: ‘asynchronous’
[16:05:54.851]   - Field: ‘calls’
[16:05:54.851]   - Field: ‘globals’
[16:05:54.851]   - Field: ‘stdout’
[16:05:54.852]   - Field: ‘earlySignal’
[16:05:54.852]   - Field: ‘lazy’
[16:05:54.852]   - Field: ‘state’
[16:05:54.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.852] - Launch lazy future ...
[16:05:54.852] Packages needed by the future expression (n = 0): <none>
[16:05:54.852] Packages needed by future strategies (n = 0): <none>
[16:05:54.853] {
[16:05:54.853]     {
[16:05:54.853]         {
[16:05:54.853]             ...future.startTime <- base::Sys.time()
[16:05:54.853]             {
[16:05:54.853]                 {
[16:05:54.853]                   {
[16:05:54.853]                     base::local({
[16:05:54.853]                       has_future <- base::requireNamespace("future", 
[16:05:54.853]                         quietly = TRUE)
[16:05:54.853]                       if (has_future) {
[16:05:54.853]                         ns <- base::getNamespace("future")
[16:05:54.853]                         version <- ns[[".package"]][["version"]]
[16:05:54.853]                         if (is.null(version)) 
[16:05:54.853]                           version <- utils::packageVersion("future")
[16:05:54.853]                       }
[16:05:54.853]                       else {
[16:05:54.853]                         version <- NULL
[16:05:54.853]                       }
[16:05:54.853]                       if (!has_future || version < "1.8.0") {
[16:05:54.853]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.853]                           "", base::R.version$version.string), 
[16:05:54.853]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.853]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.853]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.853]                             "release", "version")], collapse = " "), 
[16:05:54.853]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.853]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.853]                           info)
[16:05:54.853]                         info <- base::paste(info, collapse = "; ")
[16:05:54.853]                         if (!has_future) {
[16:05:54.853]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.853]                             info)
[16:05:54.853]                         }
[16:05:54.853]                         else {
[16:05:54.853]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.853]                             info, version)
[16:05:54.853]                         }
[16:05:54.853]                         base::stop(msg)
[16:05:54.853]                       }
[16:05:54.853]                     })
[16:05:54.853]                   }
[16:05:54.853]                   options(future.plan = NULL)
[16:05:54.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.853]                 }
[16:05:54.853]                 ...future.workdir <- getwd()
[16:05:54.853]             }
[16:05:54.853]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.853]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.853]         }
[16:05:54.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.853]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.853]             base::names(...future.oldOptions))
[16:05:54.853]     }
[16:05:54.853]     if (FALSE) {
[16:05:54.853]     }
[16:05:54.853]     else {
[16:05:54.853]         if (TRUE) {
[16:05:54.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.853]                 open = "w")
[16:05:54.853]         }
[16:05:54.853]         else {
[16:05:54.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.853]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.853]         }
[16:05:54.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.853]             base::sink(type = "output", split = FALSE)
[16:05:54.853]             base::close(...future.stdout)
[16:05:54.853]         }, add = TRUE)
[16:05:54.853]     }
[16:05:54.853]     ...future.frame <- base::sys.nframe()
[16:05:54.853]     ...future.conditions <- base::list()
[16:05:54.853]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.853]     if (FALSE) {
[16:05:54.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.853]     }
[16:05:54.853]     ...future.result <- base::tryCatch({
[16:05:54.853]         base::withCallingHandlers({
[16:05:54.853]             ...future.value <- base::withVisible(base::local({
[16:05:54.853]                 1
[16:05:54.853]             }))
[16:05:54.853]             future::FutureResult(value = ...future.value$value, 
[16:05:54.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.853]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.853]                     ...future.globalenv.names))
[16:05:54.853]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.853]         }, condition = base::local({
[16:05:54.853]             c <- base::c
[16:05:54.853]             inherits <- base::inherits
[16:05:54.853]             invokeRestart <- base::invokeRestart
[16:05:54.853]             length <- base::length
[16:05:54.853]             list <- base::list
[16:05:54.853]             seq.int <- base::seq.int
[16:05:54.853]             signalCondition <- base::signalCondition
[16:05:54.853]             sys.calls <- base::sys.calls
[16:05:54.853]             `[[` <- base::`[[`
[16:05:54.853]             `+` <- base::`+`
[16:05:54.853]             `<<-` <- base::`<<-`
[16:05:54.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.853]                   3L)]
[16:05:54.853]             }
[16:05:54.853]             function(cond) {
[16:05:54.853]                 is_error <- inherits(cond, "error")
[16:05:54.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.853]                   NULL)
[16:05:54.853]                 if (is_error) {
[16:05:54.853]                   sessionInformation <- function() {
[16:05:54.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.853]                       search = base::search(), system = base::Sys.info())
[16:05:54.853]                   }
[16:05:54.853]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.853]                     cond$call), session = sessionInformation(), 
[16:05:54.853]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.853]                   signalCondition(cond)
[16:05:54.853]                 }
[16:05:54.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.853]                 "immediateCondition"))) {
[16:05:54.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.853]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.853]                   if (TRUE && !signal) {
[16:05:54.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.853]                     {
[16:05:54.853]                       inherits <- base::inherits
[16:05:54.853]                       invokeRestart <- base::invokeRestart
[16:05:54.853]                       is.null <- base::is.null
[16:05:54.853]                       muffled <- FALSE
[16:05:54.853]                       if (inherits(cond, "message")) {
[16:05:54.853]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.853]                         if (muffled) 
[16:05:54.853]                           invokeRestart("muffleMessage")
[16:05:54.853]                       }
[16:05:54.853]                       else if (inherits(cond, "warning")) {
[16:05:54.853]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.853]                         if (muffled) 
[16:05:54.853]                           invokeRestart("muffleWarning")
[16:05:54.853]                       }
[16:05:54.853]                       else if (inherits(cond, "condition")) {
[16:05:54.853]                         if (!is.null(pattern)) {
[16:05:54.853]                           computeRestarts <- base::computeRestarts
[16:05:54.853]                           grepl <- base::grepl
[16:05:54.853]                           restarts <- computeRestarts(cond)
[16:05:54.853]                           for (restart in restarts) {
[16:05:54.853]                             name <- restart$name
[16:05:54.853]                             if (is.null(name)) 
[16:05:54.853]                               next
[16:05:54.853]                             if (!grepl(pattern, name)) 
[16:05:54.853]                               next
[16:05:54.853]                             invokeRestart(restart)
[16:05:54.853]                             muffled <- TRUE
[16:05:54.853]                             break
[16:05:54.853]                           }
[16:05:54.853]                         }
[16:05:54.853]                       }
[16:05:54.853]                       invisible(muffled)
[16:05:54.853]                     }
[16:05:54.853]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.853]                   }
[16:05:54.853]                 }
[16:05:54.853]                 else {
[16:05:54.853]                   if (TRUE) {
[16:05:54.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.853]                     {
[16:05:54.853]                       inherits <- base::inherits
[16:05:54.853]                       invokeRestart <- base::invokeRestart
[16:05:54.853]                       is.null <- base::is.null
[16:05:54.853]                       muffled <- FALSE
[16:05:54.853]                       if (inherits(cond, "message")) {
[16:05:54.853]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.853]                         if (muffled) 
[16:05:54.853]                           invokeRestart("muffleMessage")
[16:05:54.853]                       }
[16:05:54.853]                       else if (inherits(cond, "warning")) {
[16:05:54.853]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.853]                         if (muffled) 
[16:05:54.853]                           invokeRestart("muffleWarning")
[16:05:54.853]                       }
[16:05:54.853]                       else if (inherits(cond, "condition")) {
[16:05:54.853]                         if (!is.null(pattern)) {
[16:05:54.853]                           computeRestarts <- base::computeRestarts
[16:05:54.853]                           grepl <- base::grepl
[16:05:54.853]                           restarts <- computeRestarts(cond)
[16:05:54.853]                           for (restart in restarts) {
[16:05:54.853]                             name <- restart$name
[16:05:54.853]                             if (is.null(name)) 
[16:05:54.853]                               next
[16:05:54.853]                             if (!grepl(pattern, name)) 
[16:05:54.853]                               next
[16:05:54.853]                             invokeRestart(restart)
[16:05:54.853]                             muffled <- TRUE
[16:05:54.853]                             break
[16:05:54.853]                           }
[16:05:54.853]                         }
[16:05:54.853]                       }
[16:05:54.853]                       invisible(muffled)
[16:05:54.853]                     }
[16:05:54.853]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.853]                   }
[16:05:54.853]                 }
[16:05:54.853]             }
[16:05:54.853]         }))
[16:05:54.853]     }, error = function(ex) {
[16:05:54.853]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.853]                 ...future.rng), started = ...future.startTime, 
[16:05:54.853]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.853]             version = "1.8"), class = "FutureResult")
[16:05:54.853]     }, finally = {
[16:05:54.853]         if (!identical(...future.workdir, getwd())) 
[16:05:54.853]             setwd(...future.workdir)
[16:05:54.853]         {
[16:05:54.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.853]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.853]             }
[16:05:54.853]             base::options(...future.oldOptions)
[16:05:54.853]             if (.Platform$OS.type == "windows") {
[16:05:54.853]                 old_names <- names(...future.oldEnvVars)
[16:05:54.853]                 envs <- base::Sys.getenv()
[16:05:54.853]                 names <- names(envs)
[16:05:54.853]                 common <- intersect(names, old_names)
[16:05:54.853]                 added <- setdiff(names, old_names)
[16:05:54.853]                 removed <- setdiff(old_names, names)
[16:05:54.853]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.853]                   envs[common]]
[16:05:54.853]                 NAMES <- toupper(changed)
[16:05:54.853]                 args <- list()
[16:05:54.853]                 for (kk in seq_along(NAMES)) {
[16:05:54.853]                   name <- changed[[kk]]
[16:05:54.853]                   NAME <- NAMES[[kk]]
[16:05:54.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.853]                     next
[16:05:54.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.853]                 }
[16:05:54.853]                 NAMES <- toupper(added)
[16:05:54.853]                 for (kk in seq_along(NAMES)) {
[16:05:54.853]                   name <- added[[kk]]
[16:05:54.853]                   NAME <- NAMES[[kk]]
[16:05:54.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.853]                     next
[16:05:54.853]                   args[[name]] <- ""
[16:05:54.853]                 }
[16:05:54.853]                 NAMES <- toupper(removed)
[16:05:54.853]                 for (kk in seq_along(NAMES)) {
[16:05:54.853]                   name <- removed[[kk]]
[16:05:54.853]                   NAME <- NAMES[[kk]]
[16:05:54.853]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.853]                     next
[16:05:54.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.853]                 }
[16:05:54.853]                 if (length(args) > 0) 
[16:05:54.853]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.853]             }
[16:05:54.853]             else {
[16:05:54.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.853]             }
[16:05:54.853]             {
[16:05:54.853]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.853]                   0L) {
[16:05:54.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.853]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.853]                   base::options(opts)
[16:05:54.853]                 }
[16:05:54.853]                 {
[16:05:54.853]                   {
[16:05:54.853]                     NULL
[16:05:54.853]                     RNGkind("Mersenne-Twister")
[16:05:54.853]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.853]                       inherits = FALSE)
[16:05:54.853]                   }
[16:05:54.853]                   options(future.plan = NULL)
[16:05:54.853]                   if (is.na(NA_character_)) 
[16:05:54.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.853]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.853]                   {
[16:05:54.853]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.853]                     if (!future$lazy) 
[16:05:54.853]                       future <- run(future)
[16:05:54.853]                     invisible(future)
[16:05:54.853]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.853]                 }
[16:05:54.853]             }
[16:05:54.853]         }
[16:05:54.853]     })
[16:05:54.853]     if (TRUE) {
[16:05:54.853]         base::sink(type = "output", split = FALSE)
[16:05:54.853]         if (TRUE) {
[16:05:54.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.853]         }
[16:05:54.853]         else {
[16:05:54.853]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.853]         }
[16:05:54.853]         base::close(...future.stdout)
[16:05:54.853]         ...future.stdout <- NULL
[16:05:54.853]     }
[16:05:54.853]     ...future.result$conditions <- ...future.conditions
[16:05:54.853]     ...future.result$finished <- base::Sys.time()
[16:05:54.853]     ...future.result
[16:05:54.853] }
[16:05:54.854] plan(): Setting new future strategy stack:
[16:05:54.854] List of future strategies:
[16:05:54.854] 1. sequential:
[16:05:54.854]    - args: function (..., envir = parent.frame())
[16:05:54.854]    - tweaked: FALSE
[16:05:54.854]    - call: NULL
[16:05:54.855] plan(): nbrOfWorkers() = 1
[16:05:54.856] plan(): Setting new future strategy stack:
[16:05:54.856] List of future strategies:
[16:05:54.856] 1. sequential:
[16:05:54.856]    - args: function (..., envir = parent.frame())
[16:05:54.856]    - tweaked: FALSE
[16:05:54.856]    - call: plan(strategy)
[16:05:54.857] plan(): nbrOfWorkers() = 1
[16:05:54.857] SequentialFuture started (and completed)
[16:05:54.857] - Launch lazy future ... done
[16:05:54.857] run() for ‘SequentialFuture’ ... done
[16:05:54.857] getGlobalsAndPackages() ...
[16:05:54.857] Searching for globals...
[16:05:54.858] - globals found: [1] ‘{’
[16:05:54.858] Searching for globals ... DONE
[16:05:54.858] Resolving globals: FALSE
[16:05:54.858] 
[16:05:54.858] 
[16:05:54.859] getGlobalsAndPackages() ... DONE
[16:05:54.859] run() for ‘Future’ ...
[16:05:54.859] - state: ‘created’
[16:05:54.859] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.859] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.859] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.859]   - Field: ‘label’
[16:05:54.860]   - Field: ‘local’
[16:05:54.860]   - Field: ‘owner’
[16:05:54.860]   - Field: ‘envir’
[16:05:54.860]   - Field: ‘packages’
[16:05:54.860]   - Field: ‘gc’
[16:05:54.860]   - Field: ‘conditions’
[16:05:54.860]   - Field: ‘expr’
[16:05:54.861]   - Field: ‘uuid’
[16:05:54.861]   - Field: ‘seed’
[16:05:54.861]   - Field: ‘version’
[16:05:54.861]   - Field: ‘result’
[16:05:54.861]   - Field: ‘asynchronous’
[16:05:54.862]   - Field: ‘calls’
[16:05:54.862]   - Field: ‘globals’
[16:05:54.862]   - Field: ‘stdout’
[16:05:54.862]   - Field: ‘earlySignal’
[16:05:54.862]   - Field: ‘lazy’
[16:05:54.862]   - Field: ‘state’
[16:05:54.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.862] - Launch lazy future ...
[16:05:54.863] Packages needed by the future expression (n = 0): <none>
[16:05:54.863] Packages needed by future strategies (n = 0): <none>
[16:05:54.864] {
[16:05:54.864]     {
[16:05:54.864]         {
[16:05:54.864]             ...future.startTime <- base::Sys.time()
[16:05:54.864]             {
[16:05:54.864]                 {
[16:05:54.864]                   {
[16:05:54.864]                     base::local({
[16:05:54.864]                       has_future <- base::requireNamespace("future", 
[16:05:54.864]                         quietly = TRUE)
[16:05:54.864]                       if (has_future) {
[16:05:54.864]                         ns <- base::getNamespace("future")
[16:05:54.864]                         version <- ns[[".package"]][["version"]]
[16:05:54.864]                         if (is.null(version)) 
[16:05:54.864]                           version <- utils::packageVersion("future")
[16:05:54.864]                       }
[16:05:54.864]                       else {
[16:05:54.864]                         version <- NULL
[16:05:54.864]                       }
[16:05:54.864]                       if (!has_future || version < "1.8.0") {
[16:05:54.864]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.864]                           "", base::R.version$version.string), 
[16:05:54.864]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.864]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.864]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.864]                             "release", "version")], collapse = " "), 
[16:05:54.864]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.864]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.864]                           info)
[16:05:54.864]                         info <- base::paste(info, collapse = "; ")
[16:05:54.864]                         if (!has_future) {
[16:05:54.864]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.864]                             info)
[16:05:54.864]                         }
[16:05:54.864]                         else {
[16:05:54.864]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.864]                             info, version)
[16:05:54.864]                         }
[16:05:54.864]                         base::stop(msg)
[16:05:54.864]                       }
[16:05:54.864]                     })
[16:05:54.864]                   }
[16:05:54.864]                   options(future.plan = NULL)
[16:05:54.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.864]                 }
[16:05:54.864]                 ...future.workdir <- getwd()
[16:05:54.864]             }
[16:05:54.864]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.864]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.864]         }
[16:05:54.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.864]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.864]             base::names(...future.oldOptions))
[16:05:54.864]     }
[16:05:54.864]     if (FALSE) {
[16:05:54.864]     }
[16:05:54.864]     else {
[16:05:54.864]         if (TRUE) {
[16:05:54.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.864]                 open = "w")
[16:05:54.864]         }
[16:05:54.864]         else {
[16:05:54.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.864]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.864]         }
[16:05:54.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.864]             base::sink(type = "output", split = FALSE)
[16:05:54.864]             base::close(...future.stdout)
[16:05:54.864]         }, add = TRUE)
[16:05:54.864]     }
[16:05:54.864]     ...future.frame <- base::sys.nframe()
[16:05:54.864]     ...future.conditions <- base::list()
[16:05:54.864]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.864]     if (FALSE) {
[16:05:54.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.864]     }
[16:05:54.864]     ...future.result <- base::tryCatch({
[16:05:54.864]         base::withCallingHandlers({
[16:05:54.864]             ...future.value <- base::withVisible(base::local({
[16:05:54.864]                 2
[16:05:54.864]             }))
[16:05:54.864]             future::FutureResult(value = ...future.value$value, 
[16:05:54.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.864]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.864]                     ...future.globalenv.names))
[16:05:54.864]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.864]         }, condition = base::local({
[16:05:54.864]             c <- base::c
[16:05:54.864]             inherits <- base::inherits
[16:05:54.864]             invokeRestart <- base::invokeRestart
[16:05:54.864]             length <- base::length
[16:05:54.864]             list <- base::list
[16:05:54.864]             seq.int <- base::seq.int
[16:05:54.864]             signalCondition <- base::signalCondition
[16:05:54.864]             sys.calls <- base::sys.calls
[16:05:54.864]             `[[` <- base::`[[`
[16:05:54.864]             `+` <- base::`+`
[16:05:54.864]             `<<-` <- base::`<<-`
[16:05:54.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.864]                   3L)]
[16:05:54.864]             }
[16:05:54.864]             function(cond) {
[16:05:54.864]                 is_error <- inherits(cond, "error")
[16:05:54.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.864]                   NULL)
[16:05:54.864]                 if (is_error) {
[16:05:54.864]                   sessionInformation <- function() {
[16:05:54.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.864]                       search = base::search(), system = base::Sys.info())
[16:05:54.864]                   }
[16:05:54.864]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.864]                     cond$call), session = sessionInformation(), 
[16:05:54.864]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.864]                   signalCondition(cond)
[16:05:54.864]                 }
[16:05:54.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.864]                 "immediateCondition"))) {
[16:05:54.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.864]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.864]                   if (TRUE && !signal) {
[16:05:54.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.864]                     {
[16:05:54.864]                       inherits <- base::inherits
[16:05:54.864]                       invokeRestart <- base::invokeRestart
[16:05:54.864]                       is.null <- base::is.null
[16:05:54.864]                       muffled <- FALSE
[16:05:54.864]                       if (inherits(cond, "message")) {
[16:05:54.864]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.864]                         if (muffled) 
[16:05:54.864]                           invokeRestart("muffleMessage")
[16:05:54.864]                       }
[16:05:54.864]                       else if (inherits(cond, "warning")) {
[16:05:54.864]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.864]                         if (muffled) 
[16:05:54.864]                           invokeRestart("muffleWarning")
[16:05:54.864]                       }
[16:05:54.864]                       else if (inherits(cond, "condition")) {
[16:05:54.864]                         if (!is.null(pattern)) {
[16:05:54.864]                           computeRestarts <- base::computeRestarts
[16:05:54.864]                           grepl <- base::grepl
[16:05:54.864]                           restarts <- computeRestarts(cond)
[16:05:54.864]                           for (restart in restarts) {
[16:05:54.864]                             name <- restart$name
[16:05:54.864]                             if (is.null(name)) 
[16:05:54.864]                               next
[16:05:54.864]                             if (!grepl(pattern, name)) 
[16:05:54.864]                               next
[16:05:54.864]                             invokeRestart(restart)
[16:05:54.864]                             muffled <- TRUE
[16:05:54.864]                             break
[16:05:54.864]                           }
[16:05:54.864]                         }
[16:05:54.864]                       }
[16:05:54.864]                       invisible(muffled)
[16:05:54.864]                     }
[16:05:54.864]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.864]                   }
[16:05:54.864]                 }
[16:05:54.864]                 else {
[16:05:54.864]                   if (TRUE) {
[16:05:54.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.864]                     {
[16:05:54.864]                       inherits <- base::inherits
[16:05:54.864]                       invokeRestart <- base::invokeRestart
[16:05:54.864]                       is.null <- base::is.null
[16:05:54.864]                       muffled <- FALSE
[16:05:54.864]                       if (inherits(cond, "message")) {
[16:05:54.864]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.864]                         if (muffled) 
[16:05:54.864]                           invokeRestart("muffleMessage")
[16:05:54.864]                       }
[16:05:54.864]                       else if (inherits(cond, "warning")) {
[16:05:54.864]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.864]                         if (muffled) 
[16:05:54.864]                           invokeRestart("muffleWarning")
[16:05:54.864]                       }
[16:05:54.864]                       else if (inherits(cond, "condition")) {
[16:05:54.864]                         if (!is.null(pattern)) {
[16:05:54.864]                           computeRestarts <- base::computeRestarts
[16:05:54.864]                           grepl <- base::grepl
[16:05:54.864]                           restarts <- computeRestarts(cond)
[16:05:54.864]                           for (restart in restarts) {
[16:05:54.864]                             name <- restart$name
[16:05:54.864]                             if (is.null(name)) 
[16:05:54.864]                               next
[16:05:54.864]                             if (!grepl(pattern, name)) 
[16:05:54.864]                               next
[16:05:54.864]                             invokeRestart(restart)
[16:05:54.864]                             muffled <- TRUE
[16:05:54.864]                             break
[16:05:54.864]                           }
[16:05:54.864]                         }
[16:05:54.864]                       }
[16:05:54.864]                       invisible(muffled)
[16:05:54.864]                     }
[16:05:54.864]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.864]                   }
[16:05:54.864]                 }
[16:05:54.864]             }
[16:05:54.864]         }))
[16:05:54.864]     }, error = function(ex) {
[16:05:54.864]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.864]                 ...future.rng), started = ...future.startTime, 
[16:05:54.864]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.864]             version = "1.8"), class = "FutureResult")
[16:05:54.864]     }, finally = {
[16:05:54.864]         if (!identical(...future.workdir, getwd())) 
[16:05:54.864]             setwd(...future.workdir)
[16:05:54.864]         {
[16:05:54.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.864]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.864]             }
[16:05:54.864]             base::options(...future.oldOptions)
[16:05:54.864]             if (.Platform$OS.type == "windows") {
[16:05:54.864]                 old_names <- names(...future.oldEnvVars)
[16:05:54.864]                 envs <- base::Sys.getenv()
[16:05:54.864]                 names <- names(envs)
[16:05:54.864]                 common <- intersect(names, old_names)
[16:05:54.864]                 added <- setdiff(names, old_names)
[16:05:54.864]                 removed <- setdiff(old_names, names)
[16:05:54.864]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.864]                   envs[common]]
[16:05:54.864]                 NAMES <- toupper(changed)
[16:05:54.864]                 args <- list()
[16:05:54.864]                 for (kk in seq_along(NAMES)) {
[16:05:54.864]                   name <- changed[[kk]]
[16:05:54.864]                   NAME <- NAMES[[kk]]
[16:05:54.864]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.864]                     next
[16:05:54.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.864]                 }
[16:05:54.864]                 NAMES <- toupper(added)
[16:05:54.864]                 for (kk in seq_along(NAMES)) {
[16:05:54.864]                   name <- added[[kk]]
[16:05:54.864]                   NAME <- NAMES[[kk]]
[16:05:54.864]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.864]                     next
[16:05:54.864]                   args[[name]] <- ""
[16:05:54.864]                 }
[16:05:54.864]                 NAMES <- toupper(removed)
[16:05:54.864]                 for (kk in seq_along(NAMES)) {
[16:05:54.864]                   name <- removed[[kk]]
[16:05:54.864]                   NAME <- NAMES[[kk]]
[16:05:54.864]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.864]                     next
[16:05:54.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.864]                 }
[16:05:54.864]                 if (length(args) > 0) 
[16:05:54.864]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.864]             }
[16:05:54.864]             else {
[16:05:54.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.864]             }
[16:05:54.864]             {
[16:05:54.864]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.864]                   0L) {
[16:05:54.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.864]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.864]                   base::options(opts)
[16:05:54.864]                 }
[16:05:54.864]                 {
[16:05:54.864]                   {
[16:05:54.864]                     NULL
[16:05:54.864]                     RNGkind("Mersenne-Twister")
[16:05:54.864]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.864]                       inherits = FALSE)
[16:05:54.864]                   }
[16:05:54.864]                   options(future.plan = NULL)
[16:05:54.864]                   if (is.na(NA_character_)) 
[16:05:54.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.864]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.864]                   {
[16:05:54.864]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.864]                     if (!future$lazy) 
[16:05:54.864]                       future <- run(future)
[16:05:54.864]                     invisible(future)
[16:05:54.864]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.864]                 }
[16:05:54.864]             }
[16:05:54.864]         }
[16:05:54.864]     })
[16:05:54.864]     if (TRUE) {
[16:05:54.864]         base::sink(type = "output", split = FALSE)
[16:05:54.864]         if (TRUE) {
[16:05:54.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.864]         }
[16:05:54.864]         else {
[16:05:54.864]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.864]         }
[16:05:54.864]         base::close(...future.stdout)
[16:05:54.864]         ...future.stdout <- NULL
[16:05:54.864]     }
[16:05:54.864]     ...future.result$conditions <- ...future.conditions
[16:05:54.864]     ...future.result$finished <- base::Sys.time()
[16:05:54.864]     ...future.result
[16:05:54.864] }
[16:05:54.866] plan(): Setting new future strategy stack:
[16:05:54.866] List of future strategies:
[16:05:54.866] 1. sequential:
[16:05:54.866]    - args: function (..., envir = parent.frame())
[16:05:54.866]    - tweaked: FALSE
[16:05:54.866]    - call: NULL
[16:05:54.866] plan(): nbrOfWorkers() = 1
[16:05:54.867] plan(): Setting new future strategy stack:
[16:05:54.867] List of future strategies:
[16:05:54.867] 1. sequential:
[16:05:54.867]    - args: function (..., envir = parent.frame())
[16:05:54.867]    - tweaked: FALSE
[16:05:54.867]    - call: plan(strategy)
[16:05:54.867] plan(): nbrOfWorkers() = 1
[16:05:54.867] SequentialFuture started (and completed)
[16:05:54.868] - Launch lazy future ... done
[16:05:54.868] run() for ‘SequentialFuture’ ... done
[16:05:54.868] resolve() on environment ...
[16:05:54.868]  recursive: 0
[16:05:54.869]  elements: [3] ‘a’
[16:05:54.869] resolved() for ‘SequentialFuture’ ...
[16:05:54.869] - state: ‘finished’
[16:05:54.869] - run: TRUE
[16:05:54.869] - result: ‘FutureResult’
[16:05:54.869] resolved() for ‘SequentialFuture’ ... done
[16:05:54.869] Future #1
[16:05:54.869]  length: 2 (resolved future 1)
[16:05:54.869] resolved() for ‘SequentialFuture’ ...
[16:05:54.869] - state: ‘finished’
[16:05:54.870] - run: TRUE
[16:05:54.870] - result: ‘FutureResult’
[16:05:54.870] resolved() for ‘SequentialFuture’ ... done
[16:05:54.870] Future #2
[16:05:54.870]  length: 1 (resolved future 2)
[16:05:54.870]  length: 0 (resolved future 3)
[16:05:54.870] resolve() on environment ... DONE
[16:05:54.870] resolved() for ‘SequentialFuture’ ...
[16:05:54.870] - state: ‘finished’
[16:05:54.870] - run: TRUE
[16:05:54.870] - result: ‘FutureResult’
[16:05:54.870] resolved() for ‘SequentialFuture’ ... done
[16:05:54.871] resolve() on environment ...
[16:05:54.871]  recursive: 0
[16:05:54.871]  elements: [3] ‘b’
[16:05:54.872] resolved() for ‘SequentialFuture’ ...
[16:05:54.872] - state: ‘finished’
[16:05:54.872] - run: TRUE
[16:05:54.872] - result: ‘FutureResult’
[16:05:54.872] resolved() for ‘SequentialFuture’ ... done
[16:05:54.872] Future #1
[16:05:54.872]  length: 2 (resolved future 1)
[16:05:54.872] resolved() for ‘SequentialFuture’ ...
[16:05:54.872] - state: ‘finished’
[16:05:54.872] - run: TRUE
[16:05:54.872] - result: ‘FutureResult’
[16:05:54.872] resolved() for ‘SequentialFuture’ ... done
[16:05:54.873] Future #2
[16:05:54.873]  length: 1 (resolved future 2)
[16:05:54.873]  length: 0 (resolved future 3)
[16:05:54.873] resolve() on environment ... DONE
[16:05:54.873] resolve() on environment ...
[16:05:54.873]  recursive: 0
[16:05:54.874]  elements: [3] ‘c’
[16:05:54.874] resolved() for ‘SequentialFuture’ ...
[16:05:54.874] - state: ‘finished’
[16:05:54.874] - run: TRUE
[16:05:54.874] - result: ‘FutureResult’
[16:05:54.874] resolved() for ‘SequentialFuture’ ... done
[16:05:54.874] Future #1
[16:05:54.874]  length: 2 (resolved future 1)
[16:05:54.874] resolved() for ‘SequentialFuture’ ...
[16:05:54.875] - state: ‘finished’
[16:05:54.875] - run: TRUE
[16:05:54.875] - result: ‘FutureResult’
[16:05:54.875] resolved() for ‘SequentialFuture’ ... done
[16:05:54.875] Future #2
[16:05:54.875]  length: 1 (resolved future 2)
[16:05:54.875]  length: 0 (resolved future 3)
[16:05:54.875] resolve() on environment ... DONE
[16:05:54.876] resolve() on environment ...
[16:05:54.876]  recursive: 0
[16:05:54.876]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:05:54.876] resolved() for ‘SequentialFuture’ ...
[16:05:54.876] - state: ‘finished’
[16:05:54.876] - run: TRUE
[16:05:54.876] - result: ‘FutureResult’
[16:05:54.877] resolved() for ‘SequentialFuture’ ... done
[16:05:54.877] Future #1
[16:05:54.877]  length: 2 (resolved future 1)
[16:05:54.877] resolved() for ‘SequentialFuture’ ...
[16:05:54.877] - state: ‘finished’
[16:05:54.877] - run: TRUE
[16:05:54.878] - result: ‘FutureResult’
[16:05:54.878] resolved() for ‘SequentialFuture’ ... done
[16:05:54.878] Future #2
[16:05:54.878]  length: 1 (resolved future 2)
[16:05:54.878]  length: 0 (resolved future 3)
[16:05:54.878] resolve() on environment ... DONE
[16:05:54.878] resolve() on environment ...
[16:05:54.879]  recursive: 99
[16:05:54.879]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:05:54.879] resolved() for ‘SequentialFuture’ ...
[16:05:54.879] - state: ‘finished’
[16:05:54.879] - run: TRUE
[16:05:54.879] - result: ‘FutureResult’
[16:05:54.879] resolved() for ‘SequentialFuture’ ... done
[16:05:54.880] Future #1
[16:05:54.880] resolved() for ‘SequentialFuture’ ...
[16:05:54.880] - state: ‘finished’
[16:05:54.880] - run: TRUE
[16:05:54.880] - result: ‘FutureResult’
[16:05:54.880] resolved() for ‘SequentialFuture’ ... done
[16:05:54.880] A SequentialFuture was resolved
[16:05:54.880]  length: 2 (resolved future 1)
[16:05:54.880] resolved() for ‘SequentialFuture’ ...
[16:05:54.881] - state: ‘finished’
[16:05:54.881] - run: TRUE
[16:05:54.881] - result: ‘FutureResult’
[16:05:54.882] resolved() for ‘SequentialFuture’ ... done
[16:05:54.882] Future #2
[16:05:54.882] resolved() for ‘SequentialFuture’ ...
[16:05:54.882] - state: ‘finished’
[16:05:54.882] - run: TRUE
[16:05:54.882] - result: ‘FutureResult’
[16:05:54.882] resolved() for ‘SequentialFuture’ ... done
[16:05:54.882] A SequentialFuture was resolved
[16:05:54.882]  length: 1 (resolved future 2)
[16:05:54.882]  length: 0 (resolved future 3)
[16:05:54.882] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:05:54.884] resolve() on list environment ...
[16:05:54.884]  recursive: 0
[16:05:54.885]  length: 2
[16:05:54.885]  elements: ‘a’, ‘b’
[16:05:54.885]  length: 1 (resolved future 1)
[16:05:54.885]  length: 0 (resolved future 2)
[16:05:54.885] resolve() on list environment ... DONE
[16:05:54.885] getGlobalsAndPackages() ...
[16:05:54.885] Searching for globals...
[16:05:54.885] 
[16:05:54.886] Searching for globals ... DONE
[16:05:54.886] - globals: [0] <none>
[16:05:54.886] getGlobalsAndPackages() ... DONE
[16:05:54.886] run() for ‘Future’ ...
[16:05:54.886] - state: ‘created’
[16:05:54.886] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.886] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.887]   - Field: ‘label’
[16:05:54.887]   - Field: ‘local’
[16:05:54.887]   - Field: ‘owner’
[16:05:54.887]   - Field: ‘envir’
[16:05:54.887]   - Field: ‘packages’
[16:05:54.887]   - Field: ‘gc’
[16:05:54.887]   - Field: ‘conditions’
[16:05:54.887]   - Field: ‘expr’
[16:05:54.887]   - Field: ‘uuid’
[16:05:54.887]   - Field: ‘seed’
[16:05:54.887]   - Field: ‘version’
[16:05:54.888]   - Field: ‘result’
[16:05:54.888]   - Field: ‘asynchronous’
[16:05:54.888]   - Field: ‘calls’
[16:05:54.888]   - Field: ‘globals’
[16:05:54.888]   - Field: ‘stdout’
[16:05:54.888]   - Field: ‘earlySignal’
[16:05:54.888]   - Field: ‘lazy’
[16:05:54.888]   - Field: ‘state’
[16:05:54.888] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.888] - Launch lazy future ...
[16:05:54.888] Packages needed by the future expression (n = 0): <none>
[16:05:54.889] Packages needed by future strategies (n = 0): <none>
[16:05:54.889] {
[16:05:54.889]     {
[16:05:54.889]         {
[16:05:54.889]             ...future.startTime <- base::Sys.time()
[16:05:54.889]             {
[16:05:54.889]                 {
[16:05:54.889]                   {
[16:05:54.889]                     base::local({
[16:05:54.889]                       has_future <- base::requireNamespace("future", 
[16:05:54.889]                         quietly = TRUE)
[16:05:54.889]                       if (has_future) {
[16:05:54.889]                         ns <- base::getNamespace("future")
[16:05:54.889]                         version <- ns[[".package"]][["version"]]
[16:05:54.889]                         if (is.null(version)) 
[16:05:54.889]                           version <- utils::packageVersion("future")
[16:05:54.889]                       }
[16:05:54.889]                       else {
[16:05:54.889]                         version <- NULL
[16:05:54.889]                       }
[16:05:54.889]                       if (!has_future || version < "1.8.0") {
[16:05:54.889]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.889]                           "", base::R.version$version.string), 
[16:05:54.889]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.889]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.889]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.889]                             "release", "version")], collapse = " "), 
[16:05:54.889]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.889]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.889]                           info)
[16:05:54.889]                         info <- base::paste(info, collapse = "; ")
[16:05:54.889]                         if (!has_future) {
[16:05:54.889]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.889]                             info)
[16:05:54.889]                         }
[16:05:54.889]                         else {
[16:05:54.889]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.889]                             info, version)
[16:05:54.889]                         }
[16:05:54.889]                         base::stop(msg)
[16:05:54.889]                       }
[16:05:54.889]                     })
[16:05:54.889]                   }
[16:05:54.889]                   options(future.plan = NULL)
[16:05:54.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.889]                 }
[16:05:54.889]                 ...future.workdir <- getwd()
[16:05:54.889]             }
[16:05:54.889]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.889]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.889]         }
[16:05:54.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.889]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.889]             base::names(...future.oldOptions))
[16:05:54.889]     }
[16:05:54.889]     if (FALSE) {
[16:05:54.889]     }
[16:05:54.889]     else {
[16:05:54.889]         if (TRUE) {
[16:05:54.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.889]                 open = "w")
[16:05:54.889]         }
[16:05:54.889]         else {
[16:05:54.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.889]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.889]         }
[16:05:54.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.889]             base::sink(type = "output", split = FALSE)
[16:05:54.889]             base::close(...future.stdout)
[16:05:54.889]         }, add = TRUE)
[16:05:54.889]     }
[16:05:54.889]     ...future.frame <- base::sys.nframe()
[16:05:54.889]     ...future.conditions <- base::list()
[16:05:54.889]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.889]     if (FALSE) {
[16:05:54.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.889]     }
[16:05:54.889]     ...future.result <- base::tryCatch({
[16:05:54.889]         base::withCallingHandlers({
[16:05:54.889]             ...future.value <- base::withVisible(base::local(1))
[16:05:54.889]             future::FutureResult(value = ...future.value$value, 
[16:05:54.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.889]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.889]                     ...future.globalenv.names))
[16:05:54.889]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.889]         }, condition = base::local({
[16:05:54.889]             c <- base::c
[16:05:54.889]             inherits <- base::inherits
[16:05:54.889]             invokeRestart <- base::invokeRestart
[16:05:54.889]             length <- base::length
[16:05:54.889]             list <- base::list
[16:05:54.889]             seq.int <- base::seq.int
[16:05:54.889]             signalCondition <- base::signalCondition
[16:05:54.889]             sys.calls <- base::sys.calls
[16:05:54.889]             `[[` <- base::`[[`
[16:05:54.889]             `+` <- base::`+`
[16:05:54.889]             `<<-` <- base::`<<-`
[16:05:54.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.889]                   3L)]
[16:05:54.889]             }
[16:05:54.889]             function(cond) {
[16:05:54.889]                 is_error <- inherits(cond, "error")
[16:05:54.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.889]                   NULL)
[16:05:54.889]                 if (is_error) {
[16:05:54.889]                   sessionInformation <- function() {
[16:05:54.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.889]                       search = base::search(), system = base::Sys.info())
[16:05:54.889]                   }
[16:05:54.889]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.889]                     cond$call), session = sessionInformation(), 
[16:05:54.889]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.889]                   signalCondition(cond)
[16:05:54.889]                 }
[16:05:54.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.889]                 "immediateCondition"))) {
[16:05:54.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.889]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.889]                   if (TRUE && !signal) {
[16:05:54.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.889]                     {
[16:05:54.889]                       inherits <- base::inherits
[16:05:54.889]                       invokeRestart <- base::invokeRestart
[16:05:54.889]                       is.null <- base::is.null
[16:05:54.889]                       muffled <- FALSE
[16:05:54.889]                       if (inherits(cond, "message")) {
[16:05:54.889]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.889]                         if (muffled) 
[16:05:54.889]                           invokeRestart("muffleMessage")
[16:05:54.889]                       }
[16:05:54.889]                       else if (inherits(cond, "warning")) {
[16:05:54.889]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.889]                         if (muffled) 
[16:05:54.889]                           invokeRestart("muffleWarning")
[16:05:54.889]                       }
[16:05:54.889]                       else if (inherits(cond, "condition")) {
[16:05:54.889]                         if (!is.null(pattern)) {
[16:05:54.889]                           computeRestarts <- base::computeRestarts
[16:05:54.889]                           grepl <- base::grepl
[16:05:54.889]                           restarts <- computeRestarts(cond)
[16:05:54.889]                           for (restart in restarts) {
[16:05:54.889]                             name <- restart$name
[16:05:54.889]                             if (is.null(name)) 
[16:05:54.889]                               next
[16:05:54.889]                             if (!grepl(pattern, name)) 
[16:05:54.889]                               next
[16:05:54.889]                             invokeRestart(restart)
[16:05:54.889]                             muffled <- TRUE
[16:05:54.889]                             break
[16:05:54.889]                           }
[16:05:54.889]                         }
[16:05:54.889]                       }
[16:05:54.889]                       invisible(muffled)
[16:05:54.889]                     }
[16:05:54.889]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.889]                   }
[16:05:54.889]                 }
[16:05:54.889]                 else {
[16:05:54.889]                   if (TRUE) {
[16:05:54.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.889]                     {
[16:05:54.889]                       inherits <- base::inherits
[16:05:54.889]                       invokeRestart <- base::invokeRestart
[16:05:54.889]                       is.null <- base::is.null
[16:05:54.889]                       muffled <- FALSE
[16:05:54.889]                       if (inherits(cond, "message")) {
[16:05:54.889]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.889]                         if (muffled) 
[16:05:54.889]                           invokeRestart("muffleMessage")
[16:05:54.889]                       }
[16:05:54.889]                       else if (inherits(cond, "warning")) {
[16:05:54.889]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.889]                         if (muffled) 
[16:05:54.889]                           invokeRestart("muffleWarning")
[16:05:54.889]                       }
[16:05:54.889]                       else if (inherits(cond, "condition")) {
[16:05:54.889]                         if (!is.null(pattern)) {
[16:05:54.889]                           computeRestarts <- base::computeRestarts
[16:05:54.889]                           grepl <- base::grepl
[16:05:54.889]                           restarts <- computeRestarts(cond)
[16:05:54.889]                           for (restart in restarts) {
[16:05:54.889]                             name <- restart$name
[16:05:54.889]                             if (is.null(name)) 
[16:05:54.889]                               next
[16:05:54.889]                             if (!grepl(pattern, name)) 
[16:05:54.889]                               next
[16:05:54.889]                             invokeRestart(restart)
[16:05:54.889]                             muffled <- TRUE
[16:05:54.889]                             break
[16:05:54.889]                           }
[16:05:54.889]                         }
[16:05:54.889]                       }
[16:05:54.889]                       invisible(muffled)
[16:05:54.889]                     }
[16:05:54.889]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.889]                   }
[16:05:54.889]                 }
[16:05:54.889]             }
[16:05:54.889]         }))
[16:05:54.889]     }, error = function(ex) {
[16:05:54.889]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.889]                 ...future.rng), started = ...future.startTime, 
[16:05:54.889]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.889]             version = "1.8"), class = "FutureResult")
[16:05:54.889]     }, finally = {
[16:05:54.889]         if (!identical(...future.workdir, getwd())) 
[16:05:54.889]             setwd(...future.workdir)
[16:05:54.889]         {
[16:05:54.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.889]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.889]             }
[16:05:54.889]             base::options(...future.oldOptions)
[16:05:54.889]             if (.Platform$OS.type == "windows") {
[16:05:54.889]                 old_names <- names(...future.oldEnvVars)
[16:05:54.889]                 envs <- base::Sys.getenv()
[16:05:54.889]                 names <- names(envs)
[16:05:54.889]                 common <- intersect(names, old_names)
[16:05:54.889]                 added <- setdiff(names, old_names)
[16:05:54.889]                 removed <- setdiff(old_names, names)
[16:05:54.889]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.889]                   envs[common]]
[16:05:54.889]                 NAMES <- toupper(changed)
[16:05:54.889]                 args <- list()
[16:05:54.889]                 for (kk in seq_along(NAMES)) {
[16:05:54.889]                   name <- changed[[kk]]
[16:05:54.889]                   NAME <- NAMES[[kk]]
[16:05:54.889]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.889]                     next
[16:05:54.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.889]                 }
[16:05:54.889]                 NAMES <- toupper(added)
[16:05:54.889]                 for (kk in seq_along(NAMES)) {
[16:05:54.889]                   name <- added[[kk]]
[16:05:54.889]                   NAME <- NAMES[[kk]]
[16:05:54.889]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.889]                     next
[16:05:54.889]                   args[[name]] <- ""
[16:05:54.889]                 }
[16:05:54.889]                 NAMES <- toupper(removed)
[16:05:54.889]                 for (kk in seq_along(NAMES)) {
[16:05:54.889]                   name <- removed[[kk]]
[16:05:54.889]                   NAME <- NAMES[[kk]]
[16:05:54.889]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.889]                     next
[16:05:54.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.889]                 }
[16:05:54.889]                 if (length(args) > 0) 
[16:05:54.889]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.889]             }
[16:05:54.889]             else {
[16:05:54.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.889]             }
[16:05:54.889]             {
[16:05:54.889]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.889]                   0L) {
[16:05:54.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.889]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.889]                   base::options(opts)
[16:05:54.889]                 }
[16:05:54.889]                 {
[16:05:54.889]                   {
[16:05:54.889]                     NULL
[16:05:54.889]                     RNGkind("Mersenne-Twister")
[16:05:54.889]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.889]                       inherits = FALSE)
[16:05:54.889]                   }
[16:05:54.889]                   options(future.plan = NULL)
[16:05:54.889]                   if (is.na(NA_character_)) 
[16:05:54.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.889]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.889]                   {
[16:05:54.889]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.889]                     if (!future$lazy) 
[16:05:54.889]                       future <- run(future)
[16:05:54.889]                     invisible(future)
[16:05:54.889]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.889]                 }
[16:05:54.889]             }
[16:05:54.889]         }
[16:05:54.889]     })
[16:05:54.889]     if (TRUE) {
[16:05:54.889]         base::sink(type = "output", split = FALSE)
[16:05:54.889]         if (TRUE) {
[16:05:54.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.889]         }
[16:05:54.889]         else {
[16:05:54.889]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.889]         }
[16:05:54.889]         base::close(...future.stdout)
[16:05:54.889]         ...future.stdout <- NULL
[16:05:54.889]     }
[16:05:54.889]     ...future.result$conditions <- ...future.conditions
[16:05:54.889]     ...future.result$finished <- base::Sys.time()
[16:05:54.889]     ...future.result
[16:05:54.889] }
[16:05:54.891] plan(): Setting new future strategy stack:
[16:05:54.891] List of future strategies:
[16:05:54.891] 1. sequential:
[16:05:54.891]    - args: function (..., envir = parent.frame())
[16:05:54.891]    - tweaked: FALSE
[16:05:54.891]    - call: NULL
[16:05:54.891] plan(): nbrOfWorkers() = 1
[16:05:54.892] plan(): Setting new future strategy stack:
[16:05:54.892] List of future strategies:
[16:05:54.892] 1. sequential:
[16:05:54.892]    - args: function (..., envir = parent.frame())
[16:05:54.892]    - tweaked: FALSE
[16:05:54.892]    - call: plan(strategy)
[16:05:54.892] plan(): nbrOfWorkers() = 1
[16:05:54.892] SequentialFuture started (and completed)
[16:05:54.892] - Launch lazy future ... done
[16:05:54.892] run() for ‘SequentialFuture’ ... done
[16:05:54.893] getGlobalsAndPackages() ...
[16:05:54.893] Searching for globals...
[16:05:54.893] 
[16:05:54.893] Searching for globals ... DONE
[16:05:54.893] - globals: [0] <none>
[16:05:54.893] getGlobalsAndPackages() ... DONE
[16:05:54.894] run() for ‘Future’ ...
[16:05:54.894] - state: ‘created’
[16:05:54.894] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.894] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.894]   - Field: ‘label’
[16:05:54.894]   - Field: ‘local’
[16:05:54.895]   - Field: ‘owner’
[16:05:54.895]   - Field: ‘envir’
[16:05:54.895]   - Field: ‘packages’
[16:05:54.895]   - Field: ‘gc’
[16:05:54.895]   - Field: ‘conditions’
[16:05:54.895]   - Field: ‘expr’
[16:05:54.895]   - Field: ‘uuid’
[16:05:54.895]   - Field: ‘seed’
[16:05:54.895]   - Field: ‘version’
[16:05:54.895]   - Field: ‘result’
[16:05:54.895]   - Field: ‘asynchronous’
[16:05:54.895]   - Field: ‘calls’
[16:05:54.896]   - Field: ‘globals’
[16:05:54.896]   - Field: ‘stdout’
[16:05:54.896]   - Field: ‘earlySignal’
[16:05:54.896]   - Field: ‘lazy’
[16:05:54.896]   - Field: ‘state’
[16:05:54.896] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.896] - Launch lazy future ...
[16:05:54.896] Packages needed by the future expression (n = 0): <none>
[16:05:54.896] Packages needed by future strategies (n = 0): <none>
[16:05:54.897] {
[16:05:54.897]     {
[16:05:54.897]         {
[16:05:54.897]             ...future.startTime <- base::Sys.time()
[16:05:54.897]             {
[16:05:54.897]                 {
[16:05:54.897]                   {
[16:05:54.897]                     base::local({
[16:05:54.897]                       has_future <- base::requireNamespace("future", 
[16:05:54.897]                         quietly = TRUE)
[16:05:54.897]                       if (has_future) {
[16:05:54.897]                         ns <- base::getNamespace("future")
[16:05:54.897]                         version <- ns[[".package"]][["version"]]
[16:05:54.897]                         if (is.null(version)) 
[16:05:54.897]                           version <- utils::packageVersion("future")
[16:05:54.897]                       }
[16:05:54.897]                       else {
[16:05:54.897]                         version <- NULL
[16:05:54.897]                       }
[16:05:54.897]                       if (!has_future || version < "1.8.0") {
[16:05:54.897]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.897]                           "", base::R.version$version.string), 
[16:05:54.897]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.897]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.897]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.897]                             "release", "version")], collapse = " "), 
[16:05:54.897]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.897]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.897]                           info)
[16:05:54.897]                         info <- base::paste(info, collapse = "; ")
[16:05:54.897]                         if (!has_future) {
[16:05:54.897]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.897]                             info)
[16:05:54.897]                         }
[16:05:54.897]                         else {
[16:05:54.897]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.897]                             info, version)
[16:05:54.897]                         }
[16:05:54.897]                         base::stop(msg)
[16:05:54.897]                       }
[16:05:54.897]                     })
[16:05:54.897]                   }
[16:05:54.897]                   options(future.plan = NULL)
[16:05:54.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.897]                 }
[16:05:54.897]                 ...future.workdir <- getwd()
[16:05:54.897]             }
[16:05:54.897]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.897]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.897]         }
[16:05:54.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.897]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.897]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.897]             base::names(...future.oldOptions))
[16:05:54.897]     }
[16:05:54.897]     if (FALSE) {
[16:05:54.897]     }
[16:05:54.897]     else {
[16:05:54.897]         if (TRUE) {
[16:05:54.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.897]                 open = "w")
[16:05:54.897]         }
[16:05:54.897]         else {
[16:05:54.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.897]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.897]         }
[16:05:54.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.897]             base::sink(type = "output", split = FALSE)
[16:05:54.897]             base::close(...future.stdout)
[16:05:54.897]         }, add = TRUE)
[16:05:54.897]     }
[16:05:54.897]     ...future.frame <- base::sys.nframe()
[16:05:54.897]     ...future.conditions <- base::list()
[16:05:54.897]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.897]     if (FALSE) {
[16:05:54.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.897]     }
[16:05:54.897]     ...future.result <- base::tryCatch({
[16:05:54.897]         base::withCallingHandlers({
[16:05:54.897]             ...future.value <- base::withVisible(base::local(2))
[16:05:54.897]             future::FutureResult(value = ...future.value$value, 
[16:05:54.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.897]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.897]                     ...future.globalenv.names))
[16:05:54.897]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.897]         }, condition = base::local({
[16:05:54.897]             c <- base::c
[16:05:54.897]             inherits <- base::inherits
[16:05:54.897]             invokeRestart <- base::invokeRestart
[16:05:54.897]             length <- base::length
[16:05:54.897]             list <- base::list
[16:05:54.897]             seq.int <- base::seq.int
[16:05:54.897]             signalCondition <- base::signalCondition
[16:05:54.897]             sys.calls <- base::sys.calls
[16:05:54.897]             `[[` <- base::`[[`
[16:05:54.897]             `+` <- base::`+`
[16:05:54.897]             `<<-` <- base::`<<-`
[16:05:54.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.897]                   3L)]
[16:05:54.897]             }
[16:05:54.897]             function(cond) {
[16:05:54.897]                 is_error <- inherits(cond, "error")
[16:05:54.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.897]                   NULL)
[16:05:54.897]                 if (is_error) {
[16:05:54.897]                   sessionInformation <- function() {
[16:05:54.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.897]                       search = base::search(), system = base::Sys.info())
[16:05:54.897]                   }
[16:05:54.897]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.897]                     cond$call), session = sessionInformation(), 
[16:05:54.897]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.897]                   signalCondition(cond)
[16:05:54.897]                 }
[16:05:54.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.897]                 "immediateCondition"))) {
[16:05:54.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.897]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.897]                   if (TRUE && !signal) {
[16:05:54.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.897]                     {
[16:05:54.897]                       inherits <- base::inherits
[16:05:54.897]                       invokeRestart <- base::invokeRestart
[16:05:54.897]                       is.null <- base::is.null
[16:05:54.897]                       muffled <- FALSE
[16:05:54.897]                       if (inherits(cond, "message")) {
[16:05:54.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.897]                         if (muffled) 
[16:05:54.897]                           invokeRestart("muffleMessage")
[16:05:54.897]                       }
[16:05:54.897]                       else if (inherits(cond, "warning")) {
[16:05:54.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.897]                         if (muffled) 
[16:05:54.897]                           invokeRestart("muffleWarning")
[16:05:54.897]                       }
[16:05:54.897]                       else if (inherits(cond, "condition")) {
[16:05:54.897]                         if (!is.null(pattern)) {
[16:05:54.897]                           computeRestarts <- base::computeRestarts
[16:05:54.897]                           grepl <- base::grepl
[16:05:54.897]                           restarts <- computeRestarts(cond)
[16:05:54.897]                           for (restart in restarts) {
[16:05:54.897]                             name <- restart$name
[16:05:54.897]                             if (is.null(name)) 
[16:05:54.897]                               next
[16:05:54.897]                             if (!grepl(pattern, name)) 
[16:05:54.897]                               next
[16:05:54.897]                             invokeRestart(restart)
[16:05:54.897]                             muffled <- TRUE
[16:05:54.897]                             break
[16:05:54.897]                           }
[16:05:54.897]                         }
[16:05:54.897]                       }
[16:05:54.897]                       invisible(muffled)
[16:05:54.897]                     }
[16:05:54.897]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.897]                   }
[16:05:54.897]                 }
[16:05:54.897]                 else {
[16:05:54.897]                   if (TRUE) {
[16:05:54.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.897]                     {
[16:05:54.897]                       inherits <- base::inherits
[16:05:54.897]                       invokeRestart <- base::invokeRestart
[16:05:54.897]                       is.null <- base::is.null
[16:05:54.897]                       muffled <- FALSE
[16:05:54.897]                       if (inherits(cond, "message")) {
[16:05:54.897]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.897]                         if (muffled) 
[16:05:54.897]                           invokeRestart("muffleMessage")
[16:05:54.897]                       }
[16:05:54.897]                       else if (inherits(cond, "warning")) {
[16:05:54.897]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.897]                         if (muffled) 
[16:05:54.897]                           invokeRestart("muffleWarning")
[16:05:54.897]                       }
[16:05:54.897]                       else if (inherits(cond, "condition")) {
[16:05:54.897]                         if (!is.null(pattern)) {
[16:05:54.897]                           computeRestarts <- base::computeRestarts
[16:05:54.897]                           grepl <- base::grepl
[16:05:54.897]                           restarts <- computeRestarts(cond)
[16:05:54.897]                           for (restart in restarts) {
[16:05:54.897]                             name <- restart$name
[16:05:54.897]                             if (is.null(name)) 
[16:05:54.897]                               next
[16:05:54.897]                             if (!grepl(pattern, name)) 
[16:05:54.897]                               next
[16:05:54.897]                             invokeRestart(restart)
[16:05:54.897]                             muffled <- TRUE
[16:05:54.897]                             break
[16:05:54.897]                           }
[16:05:54.897]                         }
[16:05:54.897]                       }
[16:05:54.897]                       invisible(muffled)
[16:05:54.897]                     }
[16:05:54.897]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.897]                   }
[16:05:54.897]                 }
[16:05:54.897]             }
[16:05:54.897]         }))
[16:05:54.897]     }, error = function(ex) {
[16:05:54.897]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.897]                 ...future.rng), started = ...future.startTime, 
[16:05:54.897]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.897]             version = "1.8"), class = "FutureResult")
[16:05:54.897]     }, finally = {
[16:05:54.897]         if (!identical(...future.workdir, getwd())) 
[16:05:54.897]             setwd(...future.workdir)
[16:05:54.897]         {
[16:05:54.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.897]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.897]             }
[16:05:54.897]             base::options(...future.oldOptions)
[16:05:54.897]             if (.Platform$OS.type == "windows") {
[16:05:54.897]                 old_names <- names(...future.oldEnvVars)
[16:05:54.897]                 envs <- base::Sys.getenv()
[16:05:54.897]                 names <- names(envs)
[16:05:54.897]                 common <- intersect(names, old_names)
[16:05:54.897]                 added <- setdiff(names, old_names)
[16:05:54.897]                 removed <- setdiff(old_names, names)
[16:05:54.897]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.897]                   envs[common]]
[16:05:54.897]                 NAMES <- toupper(changed)
[16:05:54.897]                 args <- list()
[16:05:54.897]                 for (kk in seq_along(NAMES)) {
[16:05:54.897]                   name <- changed[[kk]]
[16:05:54.897]                   NAME <- NAMES[[kk]]
[16:05:54.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.897]                     next
[16:05:54.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.897]                 }
[16:05:54.897]                 NAMES <- toupper(added)
[16:05:54.897]                 for (kk in seq_along(NAMES)) {
[16:05:54.897]                   name <- added[[kk]]
[16:05:54.897]                   NAME <- NAMES[[kk]]
[16:05:54.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.897]                     next
[16:05:54.897]                   args[[name]] <- ""
[16:05:54.897]                 }
[16:05:54.897]                 NAMES <- toupper(removed)
[16:05:54.897]                 for (kk in seq_along(NAMES)) {
[16:05:54.897]                   name <- removed[[kk]]
[16:05:54.897]                   NAME <- NAMES[[kk]]
[16:05:54.897]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.897]                     next
[16:05:54.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.897]                 }
[16:05:54.897]                 if (length(args) > 0) 
[16:05:54.897]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.897]             }
[16:05:54.897]             else {
[16:05:54.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.897]             }
[16:05:54.897]             {
[16:05:54.897]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.897]                   0L) {
[16:05:54.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.897]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.897]                   base::options(opts)
[16:05:54.897]                 }
[16:05:54.897]                 {
[16:05:54.897]                   {
[16:05:54.897]                     NULL
[16:05:54.897]                     RNGkind("Mersenne-Twister")
[16:05:54.897]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.897]                       inherits = FALSE)
[16:05:54.897]                   }
[16:05:54.897]                   options(future.plan = NULL)
[16:05:54.897]                   if (is.na(NA_character_)) 
[16:05:54.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.897]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.897]                   {
[16:05:54.897]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.897]                     if (!future$lazy) 
[16:05:54.897]                       future <- run(future)
[16:05:54.897]                     invisible(future)
[16:05:54.897]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.897]                 }
[16:05:54.897]             }
[16:05:54.897]         }
[16:05:54.897]     })
[16:05:54.897]     if (TRUE) {
[16:05:54.897]         base::sink(type = "output", split = FALSE)
[16:05:54.897]         if (TRUE) {
[16:05:54.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.897]         }
[16:05:54.897]         else {
[16:05:54.897]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.897]         }
[16:05:54.897]         base::close(...future.stdout)
[16:05:54.897]         ...future.stdout <- NULL
[16:05:54.897]     }
[16:05:54.897]     ...future.result$conditions <- ...future.conditions
[16:05:54.897]     ...future.result$finished <- base::Sys.time()
[16:05:54.897]     ...future.result
[16:05:54.897] }
[16:05:54.898] plan(): Setting new future strategy stack:
[16:05:54.898] List of future strategies:
[16:05:54.898] 1. sequential:
[16:05:54.898]    - args: function (..., envir = parent.frame())
[16:05:54.898]    - tweaked: FALSE
[16:05:54.898]    - call: NULL
[16:05:54.899] plan(): nbrOfWorkers() = 1
[16:05:54.899] plan(): Setting new future strategy stack:
[16:05:54.900] List of future strategies:
[16:05:54.900] 1. sequential:
[16:05:54.900]    - args: function (..., envir = parent.frame())
[16:05:54.900]    - tweaked: FALSE
[16:05:54.900]    - call: plan(strategy)
[16:05:54.900] plan(): nbrOfWorkers() = 1
[16:05:54.900] SequentialFuture started (and completed)
[16:05:54.900] - Launch lazy future ... done
[16:05:54.900] run() for ‘SequentialFuture’ ... done
[16:05:54.901] resolve() on list environment ...
[16:05:54.901]  recursive: 0
[16:05:54.901]  length: 3
[16:05:54.902]  elements: ‘a’, ‘b’, ‘c’
[16:05:54.902] resolved() for ‘SequentialFuture’ ...
[16:05:54.902] - state: ‘finished’
[16:05:54.902] - run: TRUE
[16:05:54.902] - result: ‘FutureResult’
[16:05:54.902] resolved() for ‘SequentialFuture’ ... done
[16:05:54.902] Future #1
[16:05:54.902]  length: 2 (resolved future 1)
[16:05:54.902] resolved() for ‘SequentialFuture’ ...
[16:05:54.902] - state: ‘finished’
[16:05:54.903] - run: TRUE
[16:05:54.903] - result: ‘FutureResult’
[16:05:54.903] resolved() for ‘SequentialFuture’ ... done
[16:05:54.903] Future #2
[16:05:54.903]  length: 1 (resolved future 2)
[16:05:54.903]  length: 0 (resolved future 3)
[16:05:54.903] resolve() on list environment ... DONE
[16:05:54.904] getGlobalsAndPackages() ...
[16:05:54.904] Searching for globals...
[16:05:54.904] - globals found: [1] ‘{’
[16:05:54.905] Searching for globals ... DONE
[16:05:54.905] Resolving globals: FALSE
[16:05:54.905] 
[16:05:54.905] 
[16:05:54.905] getGlobalsAndPackages() ... DONE
[16:05:54.905] run() for ‘Future’ ...
[16:05:54.905] - state: ‘created’
[16:05:54.906] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.907] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.907] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.907]   - Field: ‘label’
[16:05:54.907]   - Field: ‘local’
[16:05:54.907]   - Field: ‘owner’
[16:05:54.907]   - Field: ‘envir’
[16:05:54.907]   - Field: ‘packages’
[16:05:54.907]   - Field: ‘gc’
[16:05:54.908]   - Field: ‘conditions’
[16:05:54.908]   - Field: ‘expr’
[16:05:54.908]   - Field: ‘uuid’
[16:05:54.908]   - Field: ‘seed’
[16:05:54.908]   - Field: ‘version’
[16:05:54.908]   - Field: ‘result’
[16:05:54.908]   - Field: ‘asynchronous’
[16:05:54.908]   - Field: ‘calls’
[16:05:54.908]   - Field: ‘globals’
[16:05:54.908]   - Field: ‘stdout’
[16:05:54.908]   - Field: ‘earlySignal’
[16:05:54.908]   - Field: ‘lazy’
[16:05:54.909]   - Field: ‘state’
[16:05:54.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.909] - Launch lazy future ...
[16:05:54.909] Packages needed by the future expression (n = 0): <none>
[16:05:54.909] Packages needed by future strategies (n = 0): <none>
[16:05:54.909] {
[16:05:54.909]     {
[16:05:54.909]         {
[16:05:54.909]             ...future.startTime <- base::Sys.time()
[16:05:54.909]             {
[16:05:54.909]                 {
[16:05:54.909]                   {
[16:05:54.909]                     base::local({
[16:05:54.909]                       has_future <- base::requireNamespace("future", 
[16:05:54.909]                         quietly = TRUE)
[16:05:54.909]                       if (has_future) {
[16:05:54.909]                         ns <- base::getNamespace("future")
[16:05:54.909]                         version <- ns[[".package"]][["version"]]
[16:05:54.909]                         if (is.null(version)) 
[16:05:54.909]                           version <- utils::packageVersion("future")
[16:05:54.909]                       }
[16:05:54.909]                       else {
[16:05:54.909]                         version <- NULL
[16:05:54.909]                       }
[16:05:54.909]                       if (!has_future || version < "1.8.0") {
[16:05:54.909]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.909]                           "", base::R.version$version.string), 
[16:05:54.909]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.909]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.909]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.909]                             "release", "version")], collapse = " "), 
[16:05:54.909]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.909]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.909]                           info)
[16:05:54.909]                         info <- base::paste(info, collapse = "; ")
[16:05:54.909]                         if (!has_future) {
[16:05:54.909]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.909]                             info)
[16:05:54.909]                         }
[16:05:54.909]                         else {
[16:05:54.909]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.909]                             info, version)
[16:05:54.909]                         }
[16:05:54.909]                         base::stop(msg)
[16:05:54.909]                       }
[16:05:54.909]                     })
[16:05:54.909]                   }
[16:05:54.909]                   options(future.plan = NULL)
[16:05:54.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.909]                 }
[16:05:54.909]                 ...future.workdir <- getwd()
[16:05:54.909]             }
[16:05:54.909]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.909]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.909]         }
[16:05:54.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.909]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.909]             base::names(...future.oldOptions))
[16:05:54.909]     }
[16:05:54.909]     if (FALSE) {
[16:05:54.909]     }
[16:05:54.909]     else {
[16:05:54.909]         if (TRUE) {
[16:05:54.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.909]                 open = "w")
[16:05:54.909]         }
[16:05:54.909]         else {
[16:05:54.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.909]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.909]         }
[16:05:54.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.909]             base::sink(type = "output", split = FALSE)
[16:05:54.909]             base::close(...future.stdout)
[16:05:54.909]         }, add = TRUE)
[16:05:54.909]     }
[16:05:54.909]     ...future.frame <- base::sys.nframe()
[16:05:54.909]     ...future.conditions <- base::list()
[16:05:54.909]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.909]     if (FALSE) {
[16:05:54.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.909]     }
[16:05:54.909]     ...future.result <- base::tryCatch({
[16:05:54.909]         base::withCallingHandlers({
[16:05:54.909]             ...future.value <- base::withVisible(base::local({
[16:05:54.909]                 1
[16:05:54.909]             }))
[16:05:54.909]             future::FutureResult(value = ...future.value$value, 
[16:05:54.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.909]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.909]                     ...future.globalenv.names))
[16:05:54.909]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.909]         }, condition = base::local({
[16:05:54.909]             c <- base::c
[16:05:54.909]             inherits <- base::inherits
[16:05:54.909]             invokeRestart <- base::invokeRestart
[16:05:54.909]             length <- base::length
[16:05:54.909]             list <- base::list
[16:05:54.909]             seq.int <- base::seq.int
[16:05:54.909]             signalCondition <- base::signalCondition
[16:05:54.909]             sys.calls <- base::sys.calls
[16:05:54.909]             `[[` <- base::`[[`
[16:05:54.909]             `+` <- base::`+`
[16:05:54.909]             `<<-` <- base::`<<-`
[16:05:54.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.909]                   3L)]
[16:05:54.909]             }
[16:05:54.909]             function(cond) {
[16:05:54.909]                 is_error <- inherits(cond, "error")
[16:05:54.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.909]                   NULL)
[16:05:54.909]                 if (is_error) {
[16:05:54.909]                   sessionInformation <- function() {
[16:05:54.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.909]                       search = base::search(), system = base::Sys.info())
[16:05:54.909]                   }
[16:05:54.909]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.909]                     cond$call), session = sessionInformation(), 
[16:05:54.909]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.909]                   signalCondition(cond)
[16:05:54.909]                 }
[16:05:54.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.909]                 "immediateCondition"))) {
[16:05:54.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.909]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.909]                   if (TRUE && !signal) {
[16:05:54.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.909]                     {
[16:05:54.909]                       inherits <- base::inherits
[16:05:54.909]                       invokeRestart <- base::invokeRestart
[16:05:54.909]                       is.null <- base::is.null
[16:05:54.909]                       muffled <- FALSE
[16:05:54.909]                       if (inherits(cond, "message")) {
[16:05:54.909]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.909]                         if (muffled) 
[16:05:54.909]                           invokeRestart("muffleMessage")
[16:05:54.909]                       }
[16:05:54.909]                       else if (inherits(cond, "warning")) {
[16:05:54.909]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.909]                         if (muffled) 
[16:05:54.909]                           invokeRestart("muffleWarning")
[16:05:54.909]                       }
[16:05:54.909]                       else if (inherits(cond, "condition")) {
[16:05:54.909]                         if (!is.null(pattern)) {
[16:05:54.909]                           computeRestarts <- base::computeRestarts
[16:05:54.909]                           grepl <- base::grepl
[16:05:54.909]                           restarts <- computeRestarts(cond)
[16:05:54.909]                           for (restart in restarts) {
[16:05:54.909]                             name <- restart$name
[16:05:54.909]                             if (is.null(name)) 
[16:05:54.909]                               next
[16:05:54.909]                             if (!grepl(pattern, name)) 
[16:05:54.909]                               next
[16:05:54.909]                             invokeRestart(restart)
[16:05:54.909]                             muffled <- TRUE
[16:05:54.909]                             break
[16:05:54.909]                           }
[16:05:54.909]                         }
[16:05:54.909]                       }
[16:05:54.909]                       invisible(muffled)
[16:05:54.909]                     }
[16:05:54.909]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.909]                   }
[16:05:54.909]                 }
[16:05:54.909]                 else {
[16:05:54.909]                   if (TRUE) {
[16:05:54.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.909]                     {
[16:05:54.909]                       inherits <- base::inherits
[16:05:54.909]                       invokeRestart <- base::invokeRestart
[16:05:54.909]                       is.null <- base::is.null
[16:05:54.909]                       muffled <- FALSE
[16:05:54.909]                       if (inherits(cond, "message")) {
[16:05:54.909]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.909]                         if (muffled) 
[16:05:54.909]                           invokeRestart("muffleMessage")
[16:05:54.909]                       }
[16:05:54.909]                       else if (inherits(cond, "warning")) {
[16:05:54.909]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.909]                         if (muffled) 
[16:05:54.909]                           invokeRestart("muffleWarning")
[16:05:54.909]                       }
[16:05:54.909]                       else if (inherits(cond, "condition")) {
[16:05:54.909]                         if (!is.null(pattern)) {
[16:05:54.909]                           computeRestarts <- base::computeRestarts
[16:05:54.909]                           grepl <- base::grepl
[16:05:54.909]                           restarts <- computeRestarts(cond)
[16:05:54.909]                           for (restart in restarts) {
[16:05:54.909]                             name <- restart$name
[16:05:54.909]                             if (is.null(name)) 
[16:05:54.909]                               next
[16:05:54.909]                             if (!grepl(pattern, name)) 
[16:05:54.909]                               next
[16:05:54.909]                             invokeRestart(restart)
[16:05:54.909]                             muffled <- TRUE
[16:05:54.909]                             break
[16:05:54.909]                           }
[16:05:54.909]                         }
[16:05:54.909]                       }
[16:05:54.909]                       invisible(muffled)
[16:05:54.909]                     }
[16:05:54.909]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.909]                   }
[16:05:54.909]                 }
[16:05:54.909]             }
[16:05:54.909]         }))
[16:05:54.909]     }, error = function(ex) {
[16:05:54.909]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.909]                 ...future.rng), started = ...future.startTime, 
[16:05:54.909]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.909]             version = "1.8"), class = "FutureResult")
[16:05:54.909]     }, finally = {
[16:05:54.909]         if (!identical(...future.workdir, getwd())) 
[16:05:54.909]             setwd(...future.workdir)
[16:05:54.909]         {
[16:05:54.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.909]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.909]             }
[16:05:54.909]             base::options(...future.oldOptions)
[16:05:54.909]             if (.Platform$OS.type == "windows") {
[16:05:54.909]                 old_names <- names(...future.oldEnvVars)
[16:05:54.909]                 envs <- base::Sys.getenv()
[16:05:54.909]                 names <- names(envs)
[16:05:54.909]                 common <- intersect(names, old_names)
[16:05:54.909]                 added <- setdiff(names, old_names)
[16:05:54.909]                 removed <- setdiff(old_names, names)
[16:05:54.909]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.909]                   envs[common]]
[16:05:54.909]                 NAMES <- toupper(changed)
[16:05:54.909]                 args <- list()
[16:05:54.909]                 for (kk in seq_along(NAMES)) {
[16:05:54.909]                   name <- changed[[kk]]
[16:05:54.909]                   NAME <- NAMES[[kk]]
[16:05:54.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.909]                     next
[16:05:54.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.909]                 }
[16:05:54.909]                 NAMES <- toupper(added)
[16:05:54.909]                 for (kk in seq_along(NAMES)) {
[16:05:54.909]                   name <- added[[kk]]
[16:05:54.909]                   NAME <- NAMES[[kk]]
[16:05:54.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.909]                     next
[16:05:54.909]                   args[[name]] <- ""
[16:05:54.909]                 }
[16:05:54.909]                 NAMES <- toupper(removed)
[16:05:54.909]                 for (kk in seq_along(NAMES)) {
[16:05:54.909]                   name <- removed[[kk]]
[16:05:54.909]                   NAME <- NAMES[[kk]]
[16:05:54.909]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.909]                     next
[16:05:54.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.909]                 }
[16:05:54.909]                 if (length(args) > 0) 
[16:05:54.909]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.909]             }
[16:05:54.909]             else {
[16:05:54.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.909]             }
[16:05:54.909]             {
[16:05:54.909]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.909]                   0L) {
[16:05:54.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.909]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.909]                   base::options(opts)
[16:05:54.909]                 }
[16:05:54.909]                 {
[16:05:54.909]                   {
[16:05:54.909]                     NULL
[16:05:54.909]                     RNGkind("Mersenne-Twister")
[16:05:54.909]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.909]                       inherits = FALSE)
[16:05:54.909]                   }
[16:05:54.909]                   options(future.plan = NULL)
[16:05:54.909]                   if (is.na(NA_character_)) 
[16:05:54.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.909]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.909]                   {
[16:05:54.909]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.909]                     if (!future$lazy) 
[16:05:54.909]                       future <- run(future)
[16:05:54.909]                     invisible(future)
[16:05:54.909]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.909]                 }
[16:05:54.909]             }
[16:05:54.909]         }
[16:05:54.909]     })
[16:05:54.909]     if (TRUE) {
[16:05:54.909]         base::sink(type = "output", split = FALSE)
[16:05:54.909]         if (TRUE) {
[16:05:54.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.909]         }
[16:05:54.909]         else {
[16:05:54.909]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.909]         }
[16:05:54.909]         base::close(...future.stdout)
[16:05:54.909]         ...future.stdout <- NULL
[16:05:54.909]     }
[16:05:54.909]     ...future.result$conditions <- ...future.conditions
[16:05:54.909]     ...future.result$finished <- base::Sys.time()
[16:05:54.909]     ...future.result
[16:05:54.909] }
[16:05:54.911] plan(): Setting new future strategy stack:
[16:05:54.911] List of future strategies:
[16:05:54.911] 1. sequential:
[16:05:54.911]    - args: function (..., envir = parent.frame())
[16:05:54.911]    - tweaked: FALSE
[16:05:54.911]    - call: NULL
[16:05:54.911] plan(): nbrOfWorkers() = 1
[16:05:54.912] plan(): Setting new future strategy stack:
[16:05:54.912] List of future strategies:
[16:05:54.912] 1. sequential:
[16:05:54.912]    - args: function (..., envir = parent.frame())
[16:05:54.912]    - tweaked: FALSE
[16:05:54.912]    - call: plan(strategy)
[16:05:54.912] plan(): nbrOfWorkers() = 1
[16:05:54.913] SequentialFuture started (and completed)
[16:05:54.913] - Launch lazy future ... done
[16:05:54.913] run() for ‘SequentialFuture’ ... done
[16:05:54.913] getGlobalsAndPackages() ...
[16:05:54.913] Searching for globals...
[16:05:54.914] - globals found: [1] ‘{’
[16:05:54.914] Searching for globals ... DONE
[16:05:54.914] Resolving globals: FALSE
[16:05:54.914] 
[16:05:54.914] 
[16:05:54.914] getGlobalsAndPackages() ... DONE
[16:05:54.915] run() for ‘Future’ ...
[16:05:54.915] - state: ‘created’
[16:05:54.915] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.915] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.915] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.915]   - Field: ‘label’
[16:05:54.915]   - Field: ‘local’
[16:05:54.915]   - Field: ‘owner’
[16:05:54.915]   - Field: ‘envir’
[16:05:54.916]   - Field: ‘packages’
[16:05:54.916]   - Field: ‘gc’
[16:05:54.916]   - Field: ‘conditions’
[16:05:54.916]   - Field: ‘expr’
[16:05:54.916]   - Field: ‘uuid’
[16:05:54.916]   - Field: ‘seed’
[16:05:54.916]   - Field: ‘version’
[16:05:54.916]   - Field: ‘result’
[16:05:54.916]   - Field: ‘asynchronous’
[16:05:54.916]   - Field: ‘calls’
[16:05:54.916]   - Field: ‘globals’
[16:05:54.916]   - Field: ‘stdout’
[16:05:54.917]   - Field: ‘earlySignal’
[16:05:54.917]   - Field: ‘lazy’
[16:05:54.917]   - Field: ‘state’
[16:05:54.917] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.917] - Launch lazy future ...
[16:05:54.917] Packages needed by the future expression (n = 0): <none>
[16:05:54.917] Packages needed by future strategies (n = 0): <none>
[16:05:54.918] {
[16:05:54.918]     {
[16:05:54.918]         {
[16:05:54.918]             ...future.startTime <- base::Sys.time()
[16:05:54.918]             {
[16:05:54.918]                 {
[16:05:54.918]                   {
[16:05:54.918]                     base::local({
[16:05:54.918]                       has_future <- base::requireNamespace("future", 
[16:05:54.918]                         quietly = TRUE)
[16:05:54.918]                       if (has_future) {
[16:05:54.918]                         ns <- base::getNamespace("future")
[16:05:54.918]                         version <- ns[[".package"]][["version"]]
[16:05:54.918]                         if (is.null(version)) 
[16:05:54.918]                           version <- utils::packageVersion("future")
[16:05:54.918]                       }
[16:05:54.918]                       else {
[16:05:54.918]                         version <- NULL
[16:05:54.918]                       }
[16:05:54.918]                       if (!has_future || version < "1.8.0") {
[16:05:54.918]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.918]                           "", base::R.version$version.string), 
[16:05:54.918]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.918]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.918]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.918]                             "release", "version")], collapse = " "), 
[16:05:54.918]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.918]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.918]                           info)
[16:05:54.918]                         info <- base::paste(info, collapse = "; ")
[16:05:54.918]                         if (!has_future) {
[16:05:54.918]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.918]                             info)
[16:05:54.918]                         }
[16:05:54.918]                         else {
[16:05:54.918]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.918]                             info, version)
[16:05:54.918]                         }
[16:05:54.918]                         base::stop(msg)
[16:05:54.918]                       }
[16:05:54.918]                     })
[16:05:54.918]                   }
[16:05:54.918]                   options(future.plan = NULL)
[16:05:54.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.918]                 }
[16:05:54.918]                 ...future.workdir <- getwd()
[16:05:54.918]             }
[16:05:54.918]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.918]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.918]         }
[16:05:54.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.918]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.918]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.918]             base::names(...future.oldOptions))
[16:05:54.918]     }
[16:05:54.918]     if (FALSE) {
[16:05:54.918]     }
[16:05:54.918]     else {
[16:05:54.918]         if (TRUE) {
[16:05:54.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.918]                 open = "w")
[16:05:54.918]         }
[16:05:54.918]         else {
[16:05:54.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.918]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.918]         }
[16:05:54.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.918]             base::sink(type = "output", split = FALSE)
[16:05:54.918]             base::close(...future.stdout)
[16:05:54.918]         }, add = TRUE)
[16:05:54.918]     }
[16:05:54.918]     ...future.frame <- base::sys.nframe()
[16:05:54.918]     ...future.conditions <- base::list()
[16:05:54.918]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.918]     if (FALSE) {
[16:05:54.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.918]     }
[16:05:54.918]     ...future.result <- base::tryCatch({
[16:05:54.918]         base::withCallingHandlers({
[16:05:54.918]             ...future.value <- base::withVisible(base::local({
[16:05:54.918]                 2
[16:05:54.918]             }))
[16:05:54.918]             future::FutureResult(value = ...future.value$value, 
[16:05:54.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.918]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.918]                     ...future.globalenv.names))
[16:05:54.918]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.918]         }, condition = base::local({
[16:05:54.918]             c <- base::c
[16:05:54.918]             inherits <- base::inherits
[16:05:54.918]             invokeRestart <- base::invokeRestart
[16:05:54.918]             length <- base::length
[16:05:54.918]             list <- base::list
[16:05:54.918]             seq.int <- base::seq.int
[16:05:54.918]             signalCondition <- base::signalCondition
[16:05:54.918]             sys.calls <- base::sys.calls
[16:05:54.918]             `[[` <- base::`[[`
[16:05:54.918]             `+` <- base::`+`
[16:05:54.918]             `<<-` <- base::`<<-`
[16:05:54.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.918]                   3L)]
[16:05:54.918]             }
[16:05:54.918]             function(cond) {
[16:05:54.918]                 is_error <- inherits(cond, "error")
[16:05:54.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.918]                   NULL)
[16:05:54.918]                 if (is_error) {
[16:05:54.918]                   sessionInformation <- function() {
[16:05:54.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.918]                       search = base::search(), system = base::Sys.info())
[16:05:54.918]                   }
[16:05:54.918]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.918]                     cond$call), session = sessionInformation(), 
[16:05:54.918]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.918]                   signalCondition(cond)
[16:05:54.918]                 }
[16:05:54.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.918]                 "immediateCondition"))) {
[16:05:54.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.918]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.918]                   if (TRUE && !signal) {
[16:05:54.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.918]                     {
[16:05:54.918]                       inherits <- base::inherits
[16:05:54.918]                       invokeRestart <- base::invokeRestart
[16:05:54.918]                       is.null <- base::is.null
[16:05:54.918]                       muffled <- FALSE
[16:05:54.918]                       if (inherits(cond, "message")) {
[16:05:54.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.918]                         if (muffled) 
[16:05:54.918]                           invokeRestart("muffleMessage")
[16:05:54.918]                       }
[16:05:54.918]                       else if (inherits(cond, "warning")) {
[16:05:54.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.918]                         if (muffled) 
[16:05:54.918]                           invokeRestart("muffleWarning")
[16:05:54.918]                       }
[16:05:54.918]                       else if (inherits(cond, "condition")) {
[16:05:54.918]                         if (!is.null(pattern)) {
[16:05:54.918]                           computeRestarts <- base::computeRestarts
[16:05:54.918]                           grepl <- base::grepl
[16:05:54.918]                           restarts <- computeRestarts(cond)
[16:05:54.918]                           for (restart in restarts) {
[16:05:54.918]                             name <- restart$name
[16:05:54.918]                             if (is.null(name)) 
[16:05:54.918]                               next
[16:05:54.918]                             if (!grepl(pattern, name)) 
[16:05:54.918]                               next
[16:05:54.918]                             invokeRestart(restart)
[16:05:54.918]                             muffled <- TRUE
[16:05:54.918]                             break
[16:05:54.918]                           }
[16:05:54.918]                         }
[16:05:54.918]                       }
[16:05:54.918]                       invisible(muffled)
[16:05:54.918]                     }
[16:05:54.918]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.918]                   }
[16:05:54.918]                 }
[16:05:54.918]                 else {
[16:05:54.918]                   if (TRUE) {
[16:05:54.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.918]                     {
[16:05:54.918]                       inherits <- base::inherits
[16:05:54.918]                       invokeRestart <- base::invokeRestart
[16:05:54.918]                       is.null <- base::is.null
[16:05:54.918]                       muffled <- FALSE
[16:05:54.918]                       if (inherits(cond, "message")) {
[16:05:54.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.918]                         if (muffled) 
[16:05:54.918]                           invokeRestart("muffleMessage")
[16:05:54.918]                       }
[16:05:54.918]                       else if (inherits(cond, "warning")) {
[16:05:54.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.918]                         if (muffled) 
[16:05:54.918]                           invokeRestart("muffleWarning")
[16:05:54.918]                       }
[16:05:54.918]                       else if (inherits(cond, "condition")) {
[16:05:54.918]                         if (!is.null(pattern)) {
[16:05:54.918]                           computeRestarts <- base::computeRestarts
[16:05:54.918]                           grepl <- base::grepl
[16:05:54.918]                           restarts <- computeRestarts(cond)
[16:05:54.918]                           for (restart in restarts) {
[16:05:54.918]                             name <- restart$name
[16:05:54.918]                             if (is.null(name)) 
[16:05:54.918]                               next
[16:05:54.918]                             if (!grepl(pattern, name)) 
[16:05:54.918]                               next
[16:05:54.918]                             invokeRestart(restart)
[16:05:54.918]                             muffled <- TRUE
[16:05:54.918]                             break
[16:05:54.918]                           }
[16:05:54.918]                         }
[16:05:54.918]                       }
[16:05:54.918]                       invisible(muffled)
[16:05:54.918]                     }
[16:05:54.918]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.918]                   }
[16:05:54.918]                 }
[16:05:54.918]             }
[16:05:54.918]         }))
[16:05:54.918]     }, error = function(ex) {
[16:05:54.918]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.918]                 ...future.rng), started = ...future.startTime, 
[16:05:54.918]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.918]             version = "1.8"), class = "FutureResult")
[16:05:54.918]     }, finally = {
[16:05:54.918]         if (!identical(...future.workdir, getwd())) 
[16:05:54.918]             setwd(...future.workdir)
[16:05:54.918]         {
[16:05:54.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.918]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.918]             }
[16:05:54.918]             base::options(...future.oldOptions)
[16:05:54.918]             if (.Platform$OS.type == "windows") {
[16:05:54.918]                 old_names <- names(...future.oldEnvVars)
[16:05:54.918]                 envs <- base::Sys.getenv()
[16:05:54.918]                 names <- names(envs)
[16:05:54.918]                 common <- intersect(names, old_names)
[16:05:54.918]                 added <- setdiff(names, old_names)
[16:05:54.918]                 removed <- setdiff(old_names, names)
[16:05:54.918]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.918]                   envs[common]]
[16:05:54.918]                 NAMES <- toupper(changed)
[16:05:54.918]                 args <- list()
[16:05:54.918]                 for (kk in seq_along(NAMES)) {
[16:05:54.918]                   name <- changed[[kk]]
[16:05:54.918]                   NAME <- NAMES[[kk]]
[16:05:54.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.918]                     next
[16:05:54.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.918]                 }
[16:05:54.918]                 NAMES <- toupper(added)
[16:05:54.918]                 for (kk in seq_along(NAMES)) {
[16:05:54.918]                   name <- added[[kk]]
[16:05:54.918]                   NAME <- NAMES[[kk]]
[16:05:54.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.918]                     next
[16:05:54.918]                   args[[name]] <- ""
[16:05:54.918]                 }
[16:05:54.918]                 NAMES <- toupper(removed)
[16:05:54.918]                 for (kk in seq_along(NAMES)) {
[16:05:54.918]                   name <- removed[[kk]]
[16:05:54.918]                   NAME <- NAMES[[kk]]
[16:05:54.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.918]                     next
[16:05:54.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.918]                 }
[16:05:54.918]                 if (length(args) > 0) 
[16:05:54.918]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.918]             }
[16:05:54.918]             else {
[16:05:54.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.918]             }
[16:05:54.918]             {
[16:05:54.918]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.918]                   0L) {
[16:05:54.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.918]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.918]                   base::options(opts)
[16:05:54.918]                 }
[16:05:54.918]                 {
[16:05:54.918]                   {
[16:05:54.918]                     NULL
[16:05:54.918]                     RNGkind("Mersenne-Twister")
[16:05:54.918]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.918]                       inherits = FALSE)
[16:05:54.918]                   }
[16:05:54.918]                   options(future.plan = NULL)
[16:05:54.918]                   if (is.na(NA_character_)) 
[16:05:54.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.918]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.918]                   {
[16:05:54.918]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.918]                     if (!future$lazy) 
[16:05:54.918]                       future <- run(future)
[16:05:54.918]                     invisible(future)
[16:05:54.918]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.918]                 }
[16:05:54.918]             }
[16:05:54.918]         }
[16:05:54.918]     })
[16:05:54.918]     if (TRUE) {
[16:05:54.918]         base::sink(type = "output", split = FALSE)
[16:05:54.918]         if (TRUE) {
[16:05:54.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.918]         }
[16:05:54.918]         else {
[16:05:54.918]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.918]         }
[16:05:54.918]         base::close(...future.stdout)
[16:05:54.918]         ...future.stdout <- NULL
[16:05:54.918]     }
[16:05:54.918]     ...future.result$conditions <- ...future.conditions
[16:05:54.918]     ...future.result$finished <- base::Sys.time()
[16:05:54.918]     ...future.result
[16:05:54.918] }
[16:05:54.919] plan(): Setting new future strategy stack:
[16:05:54.919] List of future strategies:
[16:05:54.919] 1. sequential:
[16:05:54.919]    - args: function (..., envir = parent.frame())
[16:05:54.919]    - tweaked: FALSE
[16:05:54.919]    - call: NULL
[16:05:54.920] plan(): nbrOfWorkers() = 1
[16:05:54.920] plan(): Setting new future strategy stack:
[16:05:54.920] List of future strategies:
[16:05:54.920] 1. sequential:
[16:05:54.920]    - args: function (..., envir = parent.frame())
[16:05:54.920]    - tweaked: FALSE
[16:05:54.920]    - call: plan(strategy)
[16:05:54.921] plan(): nbrOfWorkers() = 1
[16:05:54.921] SequentialFuture started (and completed)
[16:05:54.921] - Launch lazy future ... done
[16:05:54.921] run() for ‘SequentialFuture’ ... done
[16:05:54.922] resolve() on list environment ...
[16:05:54.922]  recursive: 0
[16:05:54.922]  length: 3
[16:05:54.922]  elements: ‘a’, ‘b’, ‘c’
[16:05:54.922] resolved() for ‘SequentialFuture’ ...
[16:05:54.922] - state: ‘finished’
[16:05:54.922] - run: TRUE
[16:05:54.923] - result: ‘FutureResult’
[16:05:54.923] resolved() for ‘SequentialFuture’ ... done
[16:05:54.923] Future #1
[16:05:54.923]  length: 2 (resolved future 1)
[16:05:54.923] resolved() for ‘SequentialFuture’ ...
[16:05:54.923] - state: ‘finished’
[16:05:54.923] - run: TRUE
[16:05:54.923] - result: ‘FutureResult’
[16:05:54.923] resolved() for ‘SequentialFuture’ ... done
[16:05:54.923] Future #2
[16:05:54.924]  length: 1 (resolved future 2)
[16:05:54.924]  length: 0 (resolved future 3)
[16:05:54.924] resolve() on list environment ... DONE
[16:05:54.924] getGlobalsAndPackages() ...
[16:05:54.924] Searching for globals...
[16:05:54.925] - globals found: [1] ‘{’
[16:05:54.925] Searching for globals ... DONE
[16:05:54.925] Resolving globals: FALSE
[16:05:54.925] 
[16:05:54.925] 
[16:05:54.925] getGlobalsAndPackages() ... DONE
[16:05:54.925] run() for ‘Future’ ...
[16:05:54.926] - state: ‘created’
[16:05:54.926] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.926] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.926] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.926]   - Field: ‘label’
[16:05:54.926]   - Field: ‘local’
[16:05:54.926]   - Field: ‘owner’
[16:05:54.926]   - Field: ‘envir’
[16:05:54.926]   - Field: ‘packages’
[16:05:54.927]   - Field: ‘gc’
[16:05:54.927]   - Field: ‘conditions’
[16:05:54.927]   - Field: ‘expr’
[16:05:54.927]   - Field: ‘uuid’
[16:05:54.927]   - Field: ‘seed’
[16:05:54.927]   - Field: ‘version’
[16:05:54.927]   - Field: ‘result’
[16:05:54.927]   - Field: ‘asynchronous’
[16:05:54.927]   - Field: ‘calls’
[16:05:54.927]   - Field: ‘globals’
[16:05:54.927]   - Field: ‘stdout’
[16:05:54.928]   - Field: ‘earlySignal’
[16:05:54.928]   - Field: ‘lazy’
[16:05:54.928]   - Field: ‘state’
[16:05:54.928] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.928] - Launch lazy future ...
[16:05:54.928] Packages needed by the future expression (n = 0): <none>
[16:05:54.928] Packages needed by future strategies (n = 0): <none>
[16:05:54.929] {
[16:05:54.929]     {
[16:05:54.929]         {
[16:05:54.929]             ...future.startTime <- base::Sys.time()
[16:05:54.929]             {
[16:05:54.929]                 {
[16:05:54.929]                   {
[16:05:54.929]                     base::local({
[16:05:54.929]                       has_future <- base::requireNamespace("future", 
[16:05:54.929]                         quietly = TRUE)
[16:05:54.929]                       if (has_future) {
[16:05:54.929]                         ns <- base::getNamespace("future")
[16:05:54.929]                         version <- ns[[".package"]][["version"]]
[16:05:54.929]                         if (is.null(version)) 
[16:05:54.929]                           version <- utils::packageVersion("future")
[16:05:54.929]                       }
[16:05:54.929]                       else {
[16:05:54.929]                         version <- NULL
[16:05:54.929]                       }
[16:05:54.929]                       if (!has_future || version < "1.8.0") {
[16:05:54.929]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.929]                           "", base::R.version$version.string), 
[16:05:54.929]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.929]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.929]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.929]                             "release", "version")], collapse = " "), 
[16:05:54.929]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.929]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.929]                           info)
[16:05:54.929]                         info <- base::paste(info, collapse = "; ")
[16:05:54.929]                         if (!has_future) {
[16:05:54.929]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.929]                             info)
[16:05:54.929]                         }
[16:05:54.929]                         else {
[16:05:54.929]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.929]                             info, version)
[16:05:54.929]                         }
[16:05:54.929]                         base::stop(msg)
[16:05:54.929]                       }
[16:05:54.929]                     })
[16:05:54.929]                   }
[16:05:54.929]                   options(future.plan = NULL)
[16:05:54.929]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.929]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.929]                 }
[16:05:54.929]                 ...future.workdir <- getwd()
[16:05:54.929]             }
[16:05:54.929]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.929]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.929]         }
[16:05:54.929]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.929]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.929]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.929]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.929]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.929]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.929]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.929]             base::names(...future.oldOptions))
[16:05:54.929]     }
[16:05:54.929]     if (FALSE) {
[16:05:54.929]     }
[16:05:54.929]     else {
[16:05:54.929]         if (TRUE) {
[16:05:54.929]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.929]                 open = "w")
[16:05:54.929]         }
[16:05:54.929]         else {
[16:05:54.929]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.929]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.929]         }
[16:05:54.929]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.929]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.929]             base::sink(type = "output", split = FALSE)
[16:05:54.929]             base::close(...future.stdout)
[16:05:54.929]         }, add = TRUE)
[16:05:54.929]     }
[16:05:54.929]     ...future.frame <- base::sys.nframe()
[16:05:54.929]     ...future.conditions <- base::list()
[16:05:54.929]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.929]     if (FALSE) {
[16:05:54.929]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.929]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.929]     }
[16:05:54.929]     ...future.result <- base::tryCatch({
[16:05:54.929]         base::withCallingHandlers({
[16:05:54.929]             ...future.value <- base::withVisible(base::local({
[16:05:54.929]                 1
[16:05:54.929]             }))
[16:05:54.929]             future::FutureResult(value = ...future.value$value, 
[16:05:54.929]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.929]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.929]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.929]                     ...future.globalenv.names))
[16:05:54.929]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.929]         }, condition = base::local({
[16:05:54.929]             c <- base::c
[16:05:54.929]             inherits <- base::inherits
[16:05:54.929]             invokeRestart <- base::invokeRestart
[16:05:54.929]             length <- base::length
[16:05:54.929]             list <- base::list
[16:05:54.929]             seq.int <- base::seq.int
[16:05:54.929]             signalCondition <- base::signalCondition
[16:05:54.929]             sys.calls <- base::sys.calls
[16:05:54.929]             `[[` <- base::`[[`
[16:05:54.929]             `+` <- base::`+`
[16:05:54.929]             `<<-` <- base::`<<-`
[16:05:54.929]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.929]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.929]                   3L)]
[16:05:54.929]             }
[16:05:54.929]             function(cond) {
[16:05:54.929]                 is_error <- inherits(cond, "error")
[16:05:54.929]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.929]                   NULL)
[16:05:54.929]                 if (is_error) {
[16:05:54.929]                   sessionInformation <- function() {
[16:05:54.929]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.929]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.929]                       search = base::search(), system = base::Sys.info())
[16:05:54.929]                   }
[16:05:54.929]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.929]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.929]                     cond$call), session = sessionInformation(), 
[16:05:54.929]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.929]                   signalCondition(cond)
[16:05:54.929]                 }
[16:05:54.929]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.929]                 "immediateCondition"))) {
[16:05:54.929]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.929]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.929]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.929]                   if (TRUE && !signal) {
[16:05:54.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.929]                     {
[16:05:54.929]                       inherits <- base::inherits
[16:05:54.929]                       invokeRestart <- base::invokeRestart
[16:05:54.929]                       is.null <- base::is.null
[16:05:54.929]                       muffled <- FALSE
[16:05:54.929]                       if (inherits(cond, "message")) {
[16:05:54.929]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.929]                         if (muffled) 
[16:05:54.929]                           invokeRestart("muffleMessage")
[16:05:54.929]                       }
[16:05:54.929]                       else if (inherits(cond, "warning")) {
[16:05:54.929]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.929]                         if (muffled) 
[16:05:54.929]                           invokeRestart("muffleWarning")
[16:05:54.929]                       }
[16:05:54.929]                       else if (inherits(cond, "condition")) {
[16:05:54.929]                         if (!is.null(pattern)) {
[16:05:54.929]                           computeRestarts <- base::computeRestarts
[16:05:54.929]                           grepl <- base::grepl
[16:05:54.929]                           restarts <- computeRestarts(cond)
[16:05:54.929]                           for (restart in restarts) {
[16:05:54.929]                             name <- restart$name
[16:05:54.929]                             if (is.null(name)) 
[16:05:54.929]                               next
[16:05:54.929]                             if (!grepl(pattern, name)) 
[16:05:54.929]                               next
[16:05:54.929]                             invokeRestart(restart)
[16:05:54.929]                             muffled <- TRUE
[16:05:54.929]                             break
[16:05:54.929]                           }
[16:05:54.929]                         }
[16:05:54.929]                       }
[16:05:54.929]                       invisible(muffled)
[16:05:54.929]                     }
[16:05:54.929]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.929]                   }
[16:05:54.929]                 }
[16:05:54.929]                 else {
[16:05:54.929]                   if (TRUE) {
[16:05:54.929]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.929]                     {
[16:05:54.929]                       inherits <- base::inherits
[16:05:54.929]                       invokeRestart <- base::invokeRestart
[16:05:54.929]                       is.null <- base::is.null
[16:05:54.929]                       muffled <- FALSE
[16:05:54.929]                       if (inherits(cond, "message")) {
[16:05:54.929]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.929]                         if (muffled) 
[16:05:54.929]                           invokeRestart("muffleMessage")
[16:05:54.929]                       }
[16:05:54.929]                       else if (inherits(cond, "warning")) {
[16:05:54.929]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.929]                         if (muffled) 
[16:05:54.929]                           invokeRestart("muffleWarning")
[16:05:54.929]                       }
[16:05:54.929]                       else if (inherits(cond, "condition")) {
[16:05:54.929]                         if (!is.null(pattern)) {
[16:05:54.929]                           computeRestarts <- base::computeRestarts
[16:05:54.929]                           grepl <- base::grepl
[16:05:54.929]                           restarts <- computeRestarts(cond)
[16:05:54.929]                           for (restart in restarts) {
[16:05:54.929]                             name <- restart$name
[16:05:54.929]                             if (is.null(name)) 
[16:05:54.929]                               next
[16:05:54.929]                             if (!grepl(pattern, name)) 
[16:05:54.929]                               next
[16:05:54.929]                             invokeRestart(restart)
[16:05:54.929]                             muffled <- TRUE
[16:05:54.929]                             break
[16:05:54.929]                           }
[16:05:54.929]                         }
[16:05:54.929]                       }
[16:05:54.929]                       invisible(muffled)
[16:05:54.929]                     }
[16:05:54.929]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.929]                   }
[16:05:54.929]                 }
[16:05:54.929]             }
[16:05:54.929]         }))
[16:05:54.929]     }, error = function(ex) {
[16:05:54.929]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.929]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.929]                 ...future.rng), started = ...future.startTime, 
[16:05:54.929]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.929]             version = "1.8"), class = "FutureResult")
[16:05:54.929]     }, finally = {
[16:05:54.929]         if (!identical(...future.workdir, getwd())) 
[16:05:54.929]             setwd(...future.workdir)
[16:05:54.929]         {
[16:05:54.929]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.929]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.929]             }
[16:05:54.929]             base::options(...future.oldOptions)
[16:05:54.929]             if (.Platform$OS.type == "windows") {
[16:05:54.929]                 old_names <- names(...future.oldEnvVars)
[16:05:54.929]                 envs <- base::Sys.getenv()
[16:05:54.929]                 names <- names(envs)
[16:05:54.929]                 common <- intersect(names, old_names)
[16:05:54.929]                 added <- setdiff(names, old_names)
[16:05:54.929]                 removed <- setdiff(old_names, names)
[16:05:54.929]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.929]                   envs[common]]
[16:05:54.929]                 NAMES <- toupper(changed)
[16:05:54.929]                 args <- list()
[16:05:54.929]                 for (kk in seq_along(NAMES)) {
[16:05:54.929]                   name <- changed[[kk]]
[16:05:54.929]                   NAME <- NAMES[[kk]]
[16:05:54.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.929]                     next
[16:05:54.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.929]                 }
[16:05:54.929]                 NAMES <- toupper(added)
[16:05:54.929]                 for (kk in seq_along(NAMES)) {
[16:05:54.929]                   name <- added[[kk]]
[16:05:54.929]                   NAME <- NAMES[[kk]]
[16:05:54.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.929]                     next
[16:05:54.929]                   args[[name]] <- ""
[16:05:54.929]                 }
[16:05:54.929]                 NAMES <- toupper(removed)
[16:05:54.929]                 for (kk in seq_along(NAMES)) {
[16:05:54.929]                   name <- removed[[kk]]
[16:05:54.929]                   NAME <- NAMES[[kk]]
[16:05:54.929]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.929]                     next
[16:05:54.929]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.929]                 }
[16:05:54.929]                 if (length(args) > 0) 
[16:05:54.929]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.929]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.929]             }
[16:05:54.929]             else {
[16:05:54.929]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.929]             }
[16:05:54.929]             {
[16:05:54.929]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.929]                   0L) {
[16:05:54.929]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.929]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.929]                   base::options(opts)
[16:05:54.929]                 }
[16:05:54.929]                 {
[16:05:54.929]                   {
[16:05:54.929]                     NULL
[16:05:54.929]                     RNGkind("Mersenne-Twister")
[16:05:54.929]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.929]                       inherits = FALSE)
[16:05:54.929]                   }
[16:05:54.929]                   options(future.plan = NULL)
[16:05:54.929]                   if (is.na(NA_character_)) 
[16:05:54.929]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.929]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.929]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.929]                   {
[16:05:54.929]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.929]                     if (!future$lazy) 
[16:05:54.929]                       future <- run(future)
[16:05:54.929]                     invisible(future)
[16:05:54.929]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.929]                 }
[16:05:54.929]             }
[16:05:54.929]         }
[16:05:54.929]     })
[16:05:54.929]     if (TRUE) {
[16:05:54.929]         base::sink(type = "output", split = FALSE)
[16:05:54.929]         if (TRUE) {
[16:05:54.929]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.929]         }
[16:05:54.929]         else {
[16:05:54.929]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.929]         }
[16:05:54.929]         base::close(...future.stdout)
[16:05:54.929]         ...future.stdout <- NULL
[16:05:54.929]     }
[16:05:54.929]     ...future.result$conditions <- ...future.conditions
[16:05:54.929]     ...future.result$finished <- base::Sys.time()
[16:05:54.929]     ...future.result
[16:05:54.929] }
[16:05:54.930] plan(): Setting new future strategy stack:
[16:05:54.930] List of future strategies:
[16:05:54.930] 1. sequential:
[16:05:54.930]    - args: function (..., envir = parent.frame())
[16:05:54.930]    - tweaked: FALSE
[16:05:54.930]    - call: NULL
[16:05:54.932] plan(): nbrOfWorkers() = 1
[16:05:54.932] plan(): Setting new future strategy stack:
[16:05:54.932] List of future strategies:
[16:05:54.932] 1. sequential:
[16:05:54.932]    - args: function (..., envir = parent.frame())
[16:05:54.932]    - tweaked: FALSE
[16:05:54.932]    - call: plan(strategy)
[16:05:54.933] plan(): nbrOfWorkers() = 1
[16:05:54.933] SequentialFuture started (and completed)
[16:05:54.933] - Launch lazy future ... done
[16:05:54.933] run() for ‘SequentialFuture’ ... done
[16:05:54.933] getGlobalsAndPackages() ...
[16:05:54.934] Searching for globals...
[16:05:54.934] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:05:54.934] Searching for globals ... DONE
[16:05:54.935] Resolving globals: FALSE
[16:05:54.935] 
[16:05:54.935] 
[16:05:54.935] getGlobalsAndPackages() ... DONE
[16:05:54.935] run() for ‘Future’ ...
[16:05:54.935] - state: ‘created’
[16:05:54.935] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:54.936] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:54.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:54.936]   - Field: ‘label’
[16:05:54.936]   - Field: ‘local’
[16:05:54.936]   - Field: ‘owner’
[16:05:54.936]   - Field: ‘envir’
[16:05:54.936]   - Field: ‘packages’
[16:05:54.936]   - Field: ‘gc’
[16:05:54.936]   - Field: ‘conditions’
[16:05:54.936]   - Field: ‘expr’
[16:05:54.937]   - Field: ‘uuid’
[16:05:54.937]   - Field: ‘seed’
[16:05:54.937]   - Field: ‘version’
[16:05:54.937]   - Field: ‘result’
[16:05:54.937]   - Field: ‘asynchronous’
[16:05:54.937]   - Field: ‘calls’
[16:05:54.937]   - Field: ‘globals’
[16:05:54.937]   - Field: ‘stdout’
[16:05:54.937]   - Field: ‘earlySignal’
[16:05:54.937]   - Field: ‘lazy’
[16:05:54.937]   - Field: ‘state’
[16:05:54.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:54.938] - Launch lazy future ...
[16:05:54.938] Packages needed by the future expression (n = 0): <none>
[16:05:54.938] Packages needed by future strategies (n = 0): <none>
[16:05:54.938] {
[16:05:54.938]     {
[16:05:54.938]         {
[16:05:54.938]             ...future.startTime <- base::Sys.time()
[16:05:54.938]             {
[16:05:54.938]                 {
[16:05:54.938]                   {
[16:05:54.938]                     base::local({
[16:05:54.938]                       has_future <- base::requireNamespace("future", 
[16:05:54.938]                         quietly = TRUE)
[16:05:54.938]                       if (has_future) {
[16:05:54.938]                         ns <- base::getNamespace("future")
[16:05:54.938]                         version <- ns[[".package"]][["version"]]
[16:05:54.938]                         if (is.null(version)) 
[16:05:54.938]                           version <- utils::packageVersion("future")
[16:05:54.938]                       }
[16:05:54.938]                       else {
[16:05:54.938]                         version <- NULL
[16:05:54.938]                       }
[16:05:54.938]                       if (!has_future || version < "1.8.0") {
[16:05:54.938]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:54.938]                           "", base::R.version$version.string), 
[16:05:54.938]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:54.938]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:54.938]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:54.938]                             "release", "version")], collapse = " "), 
[16:05:54.938]                           hostname = base::Sys.info()[["nodename"]])
[16:05:54.938]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:54.938]                           info)
[16:05:54.938]                         info <- base::paste(info, collapse = "; ")
[16:05:54.938]                         if (!has_future) {
[16:05:54.938]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:54.938]                             info)
[16:05:54.938]                         }
[16:05:54.938]                         else {
[16:05:54.938]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:54.938]                             info, version)
[16:05:54.938]                         }
[16:05:54.938]                         base::stop(msg)
[16:05:54.938]                       }
[16:05:54.938]                     })
[16:05:54.938]                   }
[16:05:54.938]                   options(future.plan = NULL)
[16:05:54.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:54.938]                 }
[16:05:54.938]                 ...future.workdir <- getwd()
[16:05:54.938]             }
[16:05:54.938]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:54.938]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:54.938]         }
[16:05:54.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:54.938]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:54.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:54.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:54.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:54.938]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:54.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:54.938]             base::names(...future.oldOptions))
[16:05:54.938]     }
[16:05:54.938]     if (FALSE) {
[16:05:54.938]     }
[16:05:54.938]     else {
[16:05:54.938]         if (TRUE) {
[16:05:54.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:54.938]                 open = "w")
[16:05:54.938]         }
[16:05:54.938]         else {
[16:05:54.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:54.938]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:54.938]         }
[16:05:54.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:54.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:54.938]             base::sink(type = "output", split = FALSE)
[16:05:54.938]             base::close(...future.stdout)
[16:05:54.938]         }, add = TRUE)
[16:05:54.938]     }
[16:05:54.938]     ...future.frame <- base::sys.nframe()
[16:05:54.938]     ...future.conditions <- base::list()
[16:05:54.938]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:54.938]     if (FALSE) {
[16:05:54.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:54.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:54.938]     }
[16:05:54.938]     ...future.result <- base::tryCatch({
[16:05:54.938]         base::withCallingHandlers({
[16:05:54.938]             ...future.value <- base::withVisible(base::local({
[16:05:54.938]                 Sys.sleep(0.5)
[16:05:54.938]                 2
[16:05:54.938]             }))
[16:05:54.938]             future::FutureResult(value = ...future.value$value, 
[16:05:54.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.938]                   ...future.rng), globalenv = if (FALSE) 
[16:05:54.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:54.938]                     ...future.globalenv.names))
[16:05:54.938]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:54.938]         }, condition = base::local({
[16:05:54.938]             c <- base::c
[16:05:54.938]             inherits <- base::inherits
[16:05:54.938]             invokeRestart <- base::invokeRestart
[16:05:54.938]             length <- base::length
[16:05:54.938]             list <- base::list
[16:05:54.938]             seq.int <- base::seq.int
[16:05:54.938]             signalCondition <- base::signalCondition
[16:05:54.938]             sys.calls <- base::sys.calls
[16:05:54.938]             `[[` <- base::`[[`
[16:05:54.938]             `+` <- base::`+`
[16:05:54.938]             `<<-` <- base::`<<-`
[16:05:54.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:54.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:54.938]                   3L)]
[16:05:54.938]             }
[16:05:54.938]             function(cond) {
[16:05:54.938]                 is_error <- inherits(cond, "error")
[16:05:54.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:54.938]                   NULL)
[16:05:54.938]                 if (is_error) {
[16:05:54.938]                   sessionInformation <- function() {
[16:05:54.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:54.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:54.938]                       search = base::search(), system = base::Sys.info())
[16:05:54.938]                   }
[16:05:54.938]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:54.938]                     cond$call), session = sessionInformation(), 
[16:05:54.938]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:54.938]                   signalCondition(cond)
[16:05:54.938]                 }
[16:05:54.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:54.938]                 "immediateCondition"))) {
[16:05:54.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:54.938]                   ...future.conditions[[length(...future.conditions) + 
[16:05:54.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:54.938]                   if (TRUE && !signal) {
[16:05:54.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.938]                     {
[16:05:54.938]                       inherits <- base::inherits
[16:05:54.938]                       invokeRestart <- base::invokeRestart
[16:05:54.938]                       is.null <- base::is.null
[16:05:54.938]                       muffled <- FALSE
[16:05:54.938]                       if (inherits(cond, "message")) {
[16:05:54.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.938]                         if (muffled) 
[16:05:54.938]                           invokeRestart("muffleMessage")
[16:05:54.938]                       }
[16:05:54.938]                       else if (inherits(cond, "warning")) {
[16:05:54.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.938]                         if (muffled) 
[16:05:54.938]                           invokeRestart("muffleWarning")
[16:05:54.938]                       }
[16:05:54.938]                       else if (inherits(cond, "condition")) {
[16:05:54.938]                         if (!is.null(pattern)) {
[16:05:54.938]                           computeRestarts <- base::computeRestarts
[16:05:54.938]                           grepl <- base::grepl
[16:05:54.938]                           restarts <- computeRestarts(cond)
[16:05:54.938]                           for (restart in restarts) {
[16:05:54.938]                             name <- restart$name
[16:05:54.938]                             if (is.null(name)) 
[16:05:54.938]                               next
[16:05:54.938]                             if (!grepl(pattern, name)) 
[16:05:54.938]                               next
[16:05:54.938]                             invokeRestart(restart)
[16:05:54.938]                             muffled <- TRUE
[16:05:54.938]                             break
[16:05:54.938]                           }
[16:05:54.938]                         }
[16:05:54.938]                       }
[16:05:54.938]                       invisible(muffled)
[16:05:54.938]                     }
[16:05:54.938]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.938]                   }
[16:05:54.938]                 }
[16:05:54.938]                 else {
[16:05:54.938]                   if (TRUE) {
[16:05:54.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:54.938]                     {
[16:05:54.938]                       inherits <- base::inherits
[16:05:54.938]                       invokeRestart <- base::invokeRestart
[16:05:54.938]                       is.null <- base::is.null
[16:05:54.938]                       muffled <- FALSE
[16:05:54.938]                       if (inherits(cond, "message")) {
[16:05:54.938]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:54.938]                         if (muffled) 
[16:05:54.938]                           invokeRestart("muffleMessage")
[16:05:54.938]                       }
[16:05:54.938]                       else if (inherits(cond, "warning")) {
[16:05:54.938]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:54.938]                         if (muffled) 
[16:05:54.938]                           invokeRestart("muffleWarning")
[16:05:54.938]                       }
[16:05:54.938]                       else if (inherits(cond, "condition")) {
[16:05:54.938]                         if (!is.null(pattern)) {
[16:05:54.938]                           computeRestarts <- base::computeRestarts
[16:05:54.938]                           grepl <- base::grepl
[16:05:54.938]                           restarts <- computeRestarts(cond)
[16:05:54.938]                           for (restart in restarts) {
[16:05:54.938]                             name <- restart$name
[16:05:54.938]                             if (is.null(name)) 
[16:05:54.938]                               next
[16:05:54.938]                             if (!grepl(pattern, name)) 
[16:05:54.938]                               next
[16:05:54.938]                             invokeRestart(restart)
[16:05:54.938]                             muffled <- TRUE
[16:05:54.938]                             break
[16:05:54.938]                           }
[16:05:54.938]                         }
[16:05:54.938]                       }
[16:05:54.938]                       invisible(muffled)
[16:05:54.938]                     }
[16:05:54.938]                     muffleCondition(cond, pattern = "^muffle")
[16:05:54.938]                   }
[16:05:54.938]                 }
[16:05:54.938]             }
[16:05:54.938]         }))
[16:05:54.938]     }, error = function(ex) {
[16:05:54.938]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:54.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:54.938]                 ...future.rng), started = ...future.startTime, 
[16:05:54.938]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:54.938]             version = "1.8"), class = "FutureResult")
[16:05:54.938]     }, finally = {
[16:05:54.938]         if (!identical(...future.workdir, getwd())) 
[16:05:54.938]             setwd(...future.workdir)
[16:05:54.938]         {
[16:05:54.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:54.938]                 ...future.oldOptions$nwarnings <- NULL
[16:05:54.938]             }
[16:05:54.938]             base::options(...future.oldOptions)
[16:05:54.938]             if (.Platform$OS.type == "windows") {
[16:05:54.938]                 old_names <- names(...future.oldEnvVars)
[16:05:54.938]                 envs <- base::Sys.getenv()
[16:05:54.938]                 names <- names(envs)
[16:05:54.938]                 common <- intersect(names, old_names)
[16:05:54.938]                 added <- setdiff(names, old_names)
[16:05:54.938]                 removed <- setdiff(old_names, names)
[16:05:54.938]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:54.938]                   envs[common]]
[16:05:54.938]                 NAMES <- toupper(changed)
[16:05:54.938]                 args <- list()
[16:05:54.938]                 for (kk in seq_along(NAMES)) {
[16:05:54.938]                   name <- changed[[kk]]
[16:05:54.938]                   NAME <- NAMES[[kk]]
[16:05:54.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.938]                     next
[16:05:54.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.938]                 }
[16:05:54.938]                 NAMES <- toupper(added)
[16:05:54.938]                 for (kk in seq_along(NAMES)) {
[16:05:54.938]                   name <- added[[kk]]
[16:05:54.938]                   NAME <- NAMES[[kk]]
[16:05:54.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.938]                     next
[16:05:54.938]                   args[[name]] <- ""
[16:05:54.938]                 }
[16:05:54.938]                 NAMES <- toupper(removed)
[16:05:54.938]                 for (kk in seq_along(NAMES)) {
[16:05:54.938]                   name <- removed[[kk]]
[16:05:54.938]                   NAME <- NAMES[[kk]]
[16:05:54.938]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:54.938]                     next
[16:05:54.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:54.938]                 }
[16:05:54.938]                 if (length(args) > 0) 
[16:05:54.938]                   base::do.call(base::Sys.setenv, args = args)
[16:05:54.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:54.938]             }
[16:05:54.938]             else {
[16:05:54.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:54.938]             }
[16:05:54.938]             {
[16:05:54.938]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:54.938]                   0L) {
[16:05:54.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:54.938]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:54.938]                   base::options(opts)
[16:05:54.938]                 }
[16:05:54.938]                 {
[16:05:54.938]                   {
[16:05:54.938]                     NULL
[16:05:54.938]                     RNGkind("Mersenne-Twister")
[16:05:54.938]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:54.938]                       inherits = FALSE)
[16:05:54.938]                   }
[16:05:54.938]                   options(future.plan = NULL)
[16:05:54.938]                   if (is.na(NA_character_)) 
[16:05:54.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:54.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:54.938]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:54.938]                   {
[16:05:54.938]                     future <- SequentialFuture(..., envir = envir)
[16:05:54.938]                     if (!future$lazy) 
[16:05:54.938]                       future <- run(future)
[16:05:54.938]                     invisible(future)
[16:05:54.938]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:54.938]                 }
[16:05:54.938]             }
[16:05:54.938]         }
[16:05:54.938]     })
[16:05:54.938]     if (TRUE) {
[16:05:54.938]         base::sink(type = "output", split = FALSE)
[16:05:54.938]         if (TRUE) {
[16:05:54.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:54.938]         }
[16:05:54.938]         else {
[16:05:54.938]             ...future.result["stdout"] <- base::list(NULL)
[16:05:54.938]         }
[16:05:54.938]         base::close(...future.stdout)
[16:05:54.938]         ...future.stdout <- NULL
[16:05:54.938]     }
[16:05:54.938]     ...future.result$conditions <- ...future.conditions
[16:05:54.938]     ...future.result$finished <- base::Sys.time()
[16:05:54.938]     ...future.result
[16:05:54.938] }
[16:05:54.940] plan(): Setting new future strategy stack:
[16:05:54.940] List of future strategies:
[16:05:54.940] 1. sequential:
[16:05:54.940]    - args: function (..., envir = parent.frame())
[16:05:54.940]    - tweaked: FALSE
[16:05:54.940]    - call: NULL
[16:05:54.940] plan(): nbrOfWorkers() = 1
[16:05:55.442] plan(): Setting new future strategy stack:
[16:05:55.442] List of future strategies:
[16:05:55.442] 1. sequential:
[16:05:55.442]    - args: function (..., envir = parent.frame())
[16:05:55.442]    - tweaked: FALSE
[16:05:55.442]    - call: plan(strategy)
[16:05:55.442] plan(): nbrOfWorkers() = 1
[16:05:55.443] SequentialFuture started (and completed)
[16:05:55.443] - Launch lazy future ... done
[16:05:55.443] run() for ‘SequentialFuture’ ... done
[16:05:55.443] getGlobalsAndPackages() ...
[16:05:55.443] Searching for globals...
[16:05:55.444] - globals found: [1] ‘{’
[16:05:55.444] Searching for globals ... DONE
[16:05:55.444] Resolving globals: FALSE
[16:05:55.444] 
[16:05:55.445] 
[16:05:55.445] getGlobalsAndPackages() ... DONE
[16:05:55.445] run() for ‘Future’ ...
[16:05:55.445] - state: ‘created’
[16:05:55.445] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:05:55.445] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:05:55.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:05:55.446]   - Field: ‘label’
[16:05:55.446]   - Field: ‘local’
[16:05:55.446]   - Field: ‘owner’
[16:05:55.446]   - Field: ‘envir’
[16:05:55.446]   - Field: ‘packages’
[16:05:55.446]   - Field: ‘gc’
[16:05:55.446]   - Field: ‘conditions’
[16:05:55.446]   - Field: ‘expr’
[16:05:55.446]   - Field: ‘uuid’
[16:05:55.446]   - Field: ‘seed’
[16:05:55.447]   - Field: ‘version’
[16:05:55.447]   - Field: ‘result’
[16:05:55.447]   - Field: ‘asynchronous’
[16:05:55.447]   - Field: ‘calls’
[16:05:55.447]   - Field: ‘globals’
[16:05:55.447]   - Field: ‘stdout’
[16:05:55.447]   - Field: ‘earlySignal’
[16:05:55.447]   - Field: ‘lazy’
[16:05:55.447]   - Field: ‘state’
[16:05:55.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:05:55.448] - Launch lazy future ...
[16:05:55.448] Packages needed by the future expression (n = 0): <none>
[16:05:55.448] Packages needed by future strategies (n = 0): <none>
[16:05:55.448] {
[16:05:55.448]     {
[16:05:55.448]         {
[16:05:55.448]             ...future.startTime <- base::Sys.time()
[16:05:55.448]             {
[16:05:55.448]                 {
[16:05:55.448]                   {
[16:05:55.448]                     base::local({
[16:05:55.448]                       has_future <- base::requireNamespace("future", 
[16:05:55.448]                         quietly = TRUE)
[16:05:55.448]                       if (has_future) {
[16:05:55.448]                         ns <- base::getNamespace("future")
[16:05:55.448]                         version <- ns[[".package"]][["version"]]
[16:05:55.448]                         if (is.null(version)) 
[16:05:55.448]                           version <- utils::packageVersion("future")
[16:05:55.448]                       }
[16:05:55.448]                       else {
[16:05:55.448]                         version <- NULL
[16:05:55.448]                       }
[16:05:55.448]                       if (!has_future || version < "1.8.0") {
[16:05:55.448]                         info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.448]                           "", base::R.version$version.string), 
[16:05:55.448]                           platform = base::sprintf("%s (%s-bit)", 
[16:05:55.448]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.448]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.448]                             "release", "version")], collapse = " "), 
[16:05:55.448]                           hostname = base::Sys.info()[["nodename"]])
[16:05:55.448]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.448]                           info)
[16:05:55.448]                         info <- base::paste(info, collapse = "; ")
[16:05:55.448]                         if (!has_future) {
[16:05:55.448]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.448]                             info)
[16:05:55.448]                         }
[16:05:55.448]                         else {
[16:05:55.448]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.448]                             info, version)
[16:05:55.448]                         }
[16:05:55.448]                         base::stop(msg)
[16:05:55.448]                       }
[16:05:55.448]                     })
[16:05:55.448]                   }
[16:05:55.448]                   options(future.plan = NULL)
[16:05:55.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.448]                 }
[16:05:55.448]                 ...future.workdir <- getwd()
[16:05:55.448]             }
[16:05:55.448]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.448]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.448]         }
[16:05:55.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.448]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.448]             base::names(...future.oldOptions))
[16:05:55.448]     }
[16:05:55.448]     if (FALSE) {
[16:05:55.448]     }
[16:05:55.448]     else {
[16:05:55.448]         if (TRUE) {
[16:05:55.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.448]                 open = "w")
[16:05:55.448]         }
[16:05:55.448]         else {
[16:05:55.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.448]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.448]         }
[16:05:55.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.448]             base::sink(type = "output", split = FALSE)
[16:05:55.448]             base::close(...future.stdout)
[16:05:55.448]         }, add = TRUE)
[16:05:55.448]     }
[16:05:55.448]     ...future.frame <- base::sys.nframe()
[16:05:55.448]     ...future.conditions <- base::list()
[16:05:55.448]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.448]     if (FALSE) {
[16:05:55.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.448]     }
[16:05:55.448]     ...future.result <- base::tryCatch({
[16:05:55.448]         base::withCallingHandlers({
[16:05:55.448]             ...future.value <- base::withVisible(base::local({
[16:05:55.448]                 3
[16:05:55.448]             }))
[16:05:55.448]             future::FutureResult(value = ...future.value$value, 
[16:05:55.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.448]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.448]                     ...future.globalenv.names))
[16:05:55.448]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.448]         }, condition = base::local({
[16:05:55.448]             c <- base::c
[16:05:55.448]             inherits <- base::inherits
[16:05:55.448]             invokeRestart <- base::invokeRestart
[16:05:55.448]             length <- base::length
[16:05:55.448]             list <- base::list
[16:05:55.448]             seq.int <- base::seq.int
[16:05:55.448]             signalCondition <- base::signalCondition
[16:05:55.448]             sys.calls <- base::sys.calls
[16:05:55.448]             `[[` <- base::`[[`
[16:05:55.448]             `+` <- base::`+`
[16:05:55.448]             `<<-` <- base::`<<-`
[16:05:55.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.448]                   3L)]
[16:05:55.448]             }
[16:05:55.448]             function(cond) {
[16:05:55.448]                 is_error <- inherits(cond, "error")
[16:05:55.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.448]                   NULL)
[16:05:55.448]                 if (is_error) {
[16:05:55.448]                   sessionInformation <- function() {
[16:05:55.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.448]                       search = base::search(), system = base::Sys.info())
[16:05:55.448]                   }
[16:05:55.448]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.448]                     cond$call), session = sessionInformation(), 
[16:05:55.448]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.448]                   signalCondition(cond)
[16:05:55.448]                 }
[16:05:55.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.448]                 "immediateCondition"))) {
[16:05:55.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.448]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.448]                   if (TRUE && !signal) {
[16:05:55.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.448]                     {
[16:05:55.448]                       inherits <- base::inherits
[16:05:55.448]                       invokeRestart <- base::invokeRestart
[16:05:55.448]                       is.null <- base::is.null
[16:05:55.448]                       muffled <- FALSE
[16:05:55.448]                       if (inherits(cond, "message")) {
[16:05:55.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.448]                         if (muffled) 
[16:05:55.448]                           invokeRestart("muffleMessage")
[16:05:55.448]                       }
[16:05:55.448]                       else if (inherits(cond, "warning")) {
[16:05:55.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.448]                         if (muffled) 
[16:05:55.448]                           invokeRestart("muffleWarning")
[16:05:55.448]                       }
[16:05:55.448]                       else if (inherits(cond, "condition")) {
[16:05:55.448]                         if (!is.null(pattern)) {
[16:05:55.448]                           computeRestarts <- base::computeRestarts
[16:05:55.448]                           grepl <- base::grepl
[16:05:55.448]                           restarts <- computeRestarts(cond)
[16:05:55.448]                           for (restart in restarts) {
[16:05:55.448]                             name <- restart$name
[16:05:55.448]                             if (is.null(name)) 
[16:05:55.448]                               next
[16:05:55.448]                             if (!grepl(pattern, name)) 
[16:05:55.448]                               next
[16:05:55.448]                             invokeRestart(restart)
[16:05:55.448]                             muffled <- TRUE
[16:05:55.448]                             break
[16:05:55.448]                           }
[16:05:55.448]                         }
[16:05:55.448]                       }
[16:05:55.448]                       invisible(muffled)
[16:05:55.448]                     }
[16:05:55.448]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.448]                   }
[16:05:55.448]                 }
[16:05:55.448]                 else {
[16:05:55.448]                   if (TRUE) {
[16:05:55.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.448]                     {
[16:05:55.448]                       inherits <- base::inherits
[16:05:55.448]                       invokeRestart <- base::invokeRestart
[16:05:55.448]                       is.null <- base::is.null
[16:05:55.448]                       muffled <- FALSE
[16:05:55.448]                       if (inherits(cond, "message")) {
[16:05:55.448]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.448]                         if (muffled) 
[16:05:55.448]                           invokeRestart("muffleMessage")
[16:05:55.448]                       }
[16:05:55.448]                       else if (inherits(cond, "warning")) {
[16:05:55.448]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.448]                         if (muffled) 
[16:05:55.448]                           invokeRestart("muffleWarning")
[16:05:55.448]                       }
[16:05:55.448]                       else if (inherits(cond, "condition")) {
[16:05:55.448]                         if (!is.null(pattern)) {
[16:05:55.448]                           computeRestarts <- base::computeRestarts
[16:05:55.448]                           grepl <- base::grepl
[16:05:55.448]                           restarts <- computeRestarts(cond)
[16:05:55.448]                           for (restart in restarts) {
[16:05:55.448]                             name <- restart$name
[16:05:55.448]                             if (is.null(name)) 
[16:05:55.448]                               next
[16:05:55.448]                             if (!grepl(pattern, name)) 
[16:05:55.448]                               next
[16:05:55.448]                             invokeRestart(restart)
[16:05:55.448]                             muffled <- TRUE
[16:05:55.448]                             break
[16:05:55.448]                           }
[16:05:55.448]                         }
[16:05:55.448]                       }
[16:05:55.448]                       invisible(muffled)
[16:05:55.448]                     }
[16:05:55.448]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.448]                   }
[16:05:55.448]                 }
[16:05:55.448]             }
[16:05:55.448]         }))
[16:05:55.448]     }, error = function(ex) {
[16:05:55.448]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.448]                 ...future.rng), started = ...future.startTime, 
[16:05:55.448]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.448]             version = "1.8"), class = "FutureResult")
[16:05:55.448]     }, finally = {
[16:05:55.448]         if (!identical(...future.workdir, getwd())) 
[16:05:55.448]             setwd(...future.workdir)
[16:05:55.448]         {
[16:05:55.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.448]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.448]             }
[16:05:55.448]             base::options(...future.oldOptions)
[16:05:55.448]             if (.Platform$OS.type == "windows") {
[16:05:55.448]                 old_names <- names(...future.oldEnvVars)
[16:05:55.448]                 envs <- base::Sys.getenv()
[16:05:55.448]                 names <- names(envs)
[16:05:55.448]                 common <- intersect(names, old_names)
[16:05:55.448]                 added <- setdiff(names, old_names)
[16:05:55.448]                 removed <- setdiff(old_names, names)
[16:05:55.448]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.448]                   envs[common]]
[16:05:55.448]                 NAMES <- toupper(changed)
[16:05:55.448]                 args <- list()
[16:05:55.448]                 for (kk in seq_along(NAMES)) {
[16:05:55.448]                   name <- changed[[kk]]
[16:05:55.448]                   NAME <- NAMES[[kk]]
[16:05:55.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.448]                     next
[16:05:55.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.448]                 }
[16:05:55.448]                 NAMES <- toupper(added)
[16:05:55.448]                 for (kk in seq_along(NAMES)) {
[16:05:55.448]                   name <- added[[kk]]
[16:05:55.448]                   NAME <- NAMES[[kk]]
[16:05:55.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.448]                     next
[16:05:55.448]                   args[[name]] <- ""
[16:05:55.448]                 }
[16:05:55.448]                 NAMES <- toupper(removed)
[16:05:55.448]                 for (kk in seq_along(NAMES)) {
[16:05:55.448]                   name <- removed[[kk]]
[16:05:55.448]                   NAME <- NAMES[[kk]]
[16:05:55.448]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.448]                     next
[16:05:55.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.448]                 }
[16:05:55.448]                 if (length(args) > 0) 
[16:05:55.448]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.448]             }
[16:05:55.448]             else {
[16:05:55.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.448]             }
[16:05:55.448]             {
[16:05:55.448]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.448]                   0L) {
[16:05:55.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.448]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.448]                   base::options(opts)
[16:05:55.448]                 }
[16:05:55.448]                 {
[16:05:55.448]                   {
[16:05:55.448]                     NULL
[16:05:55.448]                     RNGkind("Mersenne-Twister")
[16:05:55.448]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:05:55.448]                       inherits = FALSE)
[16:05:55.448]                   }
[16:05:55.448]                   options(future.plan = NULL)
[16:05:55.448]                   if (is.na(NA_character_)) 
[16:05:55.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.448]                   future::plan(list(function (..., envir = parent.frame()) 
[16:05:55.448]                   {
[16:05:55.448]                     future <- SequentialFuture(..., envir = envir)
[16:05:55.448]                     if (!future$lazy) 
[16:05:55.448]                       future <- run(future)
[16:05:55.448]                     invisible(future)
[16:05:55.448]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.448]                 }
[16:05:55.448]             }
[16:05:55.448]         }
[16:05:55.448]     })
[16:05:55.448]     if (TRUE) {
[16:05:55.448]         base::sink(type = "output", split = FALSE)
[16:05:55.448]         if (TRUE) {
[16:05:55.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.448]         }
[16:05:55.448]         else {
[16:05:55.448]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.448]         }
[16:05:55.448]         base::close(...future.stdout)
[16:05:55.448]         ...future.stdout <- NULL
[16:05:55.448]     }
[16:05:55.448]     ...future.result$conditions <- ...future.conditions
[16:05:55.448]     ...future.result$finished <- base::Sys.time()
[16:05:55.448]     ...future.result
[16:05:55.448] }
[16:05:55.450] plan(): Setting new future strategy stack:
[16:05:55.450] List of future strategies:
[16:05:55.450] 1. sequential:
[16:05:55.450]    - args: function (..., envir = parent.frame())
[16:05:55.450]    - tweaked: FALSE
[16:05:55.450]    - call: NULL
[16:05:55.450] plan(): nbrOfWorkers() = 1
[16:05:55.451] plan(): Setting new future strategy stack:
[16:05:55.451] List of future strategies:
[16:05:55.451] 1. sequential:
[16:05:55.451]    - args: function (..., envir = parent.frame())
[16:05:55.451]    - tweaked: FALSE
[16:05:55.451]    - call: plan(strategy)
[16:05:55.452] plan(): nbrOfWorkers() = 1
[16:05:55.452] SequentialFuture started (and completed)
[16:05:55.452] - Launch lazy future ... done
[16:05:55.452] run() for ‘SequentialFuture’ ... done
[16:05:55.453] resolve() on list environment ...
[16:05:55.453]  recursive: 0
[16:05:55.453]  length: 4
[16:05:55.453]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:55.454] resolved() for ‘SequentialFuture’ ...
[16:05:55.454] - state: ‘finished’
[16:05:55.454] - run: TRUE
[16:05:55.454] - result: ‘FutureResult’
[16:05:55.454] resolved() for ‘SequentialFuture’ ... done
[16:05:55.454] Future #1
[16:05:55.454]  length: 3 (resolved future 1)
[16:05:55.454] resolved() for ‘SequentialFuture’ ...
[16:05:55.454] - state: ‘finished’
[16:05:55.454] - run: TRUE
[16:05:55.455] - result: ‘FutureResult’
[16:05:55.455] resolved() for ‘SequentialFuture’ ... done
[16:05:55.455] Future #2
[16:05:55.455]  length: 2 (resolved future 2)
[16:05:55.455] resolved() for ‘SequentialFuture’ ...
[16:05:55.455] - state: ‘finished’
[16:05:55.455] - run: TRUE
[16:05:55.455] - result: ‘FutureResult’
[16:05:55.455] resolved() for ‘SequentialFuture’ ... done
[16:05:55.455] Future #3
[16:05:55.456]  length: 1 (resolved future 3)
[16:05:55.456]  length: 0 (resolved future 4)
[16:05:55.456] resolve() on list environment ... DONE
[16:05:55.456] resolved() for ‘SequentialFuture’ ...
[16:05:55.456] - state: ‘finished’
[16:05:55.456] - run: TRUE
[16:05:55.456] - result: ‘FutureResult’
[16:05:55.458] resolved() for ‘SequentialFuture’ ... done
[16:05:55.458] resolve() on list environment ...
[16:05:55.458]  recursive: 0
[16:05:55.459]  length: 4
[16:05:55.459]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:55.459] resolved() for ‘SequentialFuture’ ...
[16:05:55.460] - state: ‘finished’
[16:05:55.460] - run: TRUE
[16:05:55.460] - result: ‘FutureResult’
[16:05:55.460] resolved() for ‘SequentialFuture’ ... done
[16:05:55.460] Future #1
[16:05:55.460]  length: 3 (resolved future 1)
[16:05:55.460] resolved() for ‘SequentialFuture’ ...
[16:05:55.460] - state: ‘finished’
[16:05:55.460] - run: TRUE
[16:05:55.460] - result: ‘FutureResult’
[16:05:55.461] resolved() for ‘SequentialFuture’ ... done
[16:05:55.461] Future #2
[16:05:55.461]  length: 2 (resolved future 2)
[16:05:55.461] resolved() for ‘SequentialFuture’ ...
[16:05:55.461] - state: ‘finished’
[16:05:55.461] - run: TRUE
[16:05:55.461] - result: ‘FutureResult’
[16:05:55.461] resolved() for ‘SequentialFuture’ ... done
[16:05:55.461] Future #3
[16:05:55.461]  length: 1 (resolved future 3)
[16:05:55.462]  length: 0 (resolved future 4)
[16:05:55.462] resolve() on list environment ... DONE
[16:05:55.462] resolve() on list environment ...
[16:05:55.462]  recursive: 0
[16:05:55.463]  length: 4
[16:05:55.463]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:55.463] resolved() for ‘SequentialFuture’ ...
[16:05:55.463] - state: ‘finished’
[16:05:55.463] - run: TRUE
[16:05:55.463] - result: ‘FutureResult’
[16:05:55.463] resolved() for ‘SequentialFuture’ ... done
[16:05:55.464] Future #1
[16:05:55.464]  length: 3 (resolved future 1)
[16:05:55.464] resolved() for ‘SequentialFuture’ ...
[16:05:55.464] - state: ‘finished’
[16:05:55.464] - run: TRUE
[16:05:55.464] - result: ‘FutureResult’
[16:05:55.464] resolved() for ‘SequentialFuture’ ... done
[16:05:55.464] Future #2
[16:05:55.464]  length: 2 (resolved future 2)
[16:05:55.464] resolved() for ‘SequentialFuture’ ...
[16:05:55.465] - state: ‘finished’
[16:05:55.465] - run: TRUE
[16:05:55.465] - result: ‘FutureResult’
[16:05:55.465] resolved() for ‘SequentialFuture’ ... done
[16:05:55.465] Future #3
[16:05:55.465]  length: 1 (resolved future 3)
[16:05:55.465]  length: 0 (resolved future 4)
[16:05:55.465] resolve() on list environment ... DONE
[16:05:55.466] resolve() on list environment ...
[16:05:55.466]  recursive: 0
[16:05:55.466]  length: 4
[16:05:55.466]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:55.466] resolved() for ‘SequentialFuture’ ...
[16:05:55.467] - state: ‘finished’
[16:05:55.467] - run: TRUE
[16:05:55.467] - result: ‘FutureResult’
[16:05:55.467] resolved() for ‘SequentialFuture’ ... done
[16:05:55.467] Future #1
[16:05:55.467]  length: 3 (resolved future 1)
[16:05:55.467] resolved() for ‘SequentialFuture’ ...
[16:05:55.467] - state: ‘finished’
[16:05:55.467] - run: TRUE
[16:05:55.467] - result: ‘FutureResult’
[16:05:55.467] resolved() for ‘SequentialFuture’ ... done
[16:05:55.468] Future #2
[16:05:55.468]  length: 2 (resolved future 2)
[16:05:55.468] resolved() for ‘SequentialFuture’ ...
[16:05:55.468] - state: ‘finished’
[16:05:55.468] - run: TRUE
[16:05:55.468] - result: ‘FutureResult’
[16:05:55.468] resolved() for ‘SequentialFuture’ ... done
[16:05:55.468] Future #3
[16:05:55.468]  length: 1 (resolved future 3)
[16:05:55.468]  length: 0 (resolved future 4)
[16:05:55.468] resolve() on list environment ... DONE
[16:05:55.469] resolve() on list environment ...
[16:05:55.469]  recursive: 0
[16:05:55.470]  length: 4
[16:05:55.470]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:55.470] resolved() for ‘SequentialFuture’ ...
[16:05:55.470] - state: ‘finished’
[16:05:55.470] - run: TRUE
[16:05:55.470] - result: ‘FutureResult’
[16:05:55.470] resolved() for ‘SequentialFuture’ ... done
[16:05:55.470] Future #1
[16:05:55.470]  length: 3 (resolved future 1)
[16:05:55.471] resolved() for ‘SequentialFuture’ ...
[16:05:55.471] - state: ‘finished’
[16:05:55.471] - run: TRUE
[16:05:55.471] - result: ‘FutureResult’
[16:05:55.471] resolved() for ‘SequentialFuture’ ... done
[16:05:55.471] Future #2
[16:05:55.471]  length: 2 (resolved future 2)
[16:05:55.471] resolved() for ‘SequentialFuture’ ...
[16:05:55.471] - state: ‘finished’
[16:05:55.471] - run: TRUE
[16:05:55.472] - result: ‘FutureResult’
[16:05:55.472] resolved() for ‘SequentialFuture’ ... done
[16:05:55.472] Future #3
[16:05:55.472]  length: 1 (resolved future 3)
[16:05:55.472]  length: 0 (resolved future 4)
[16:05:55.472] resolve() on list environment ... DONE
[16:05:55.472] resolve() on list environment ...
[16:05:55.473]  recursive: 99
[16:05:55.473]  length: 4
[16:05:55.473]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:55.473] resolved() for ‘SequentialFuture’ ...
[16:05:55.473] - state: ‘finished’
[16:05:55.474] - run: TRUE
[16:05:55.474] - result: ‘FutureResult’
[16:05:55.474] resolved() for ‘SequentialFuture’ ... done
[16:05:55.474] Future #1
[16:05:55.474] resolved() for ‘SequentialFuture’ ...
[16:05:55.474] - state: ‘finished’
[16:05:55.474] - run: TRUE
[16:05:55.474] - result: ‘FutureResult’
[16:05:55.474] resolved() for ‘SequentialFuture’ ... done
[16:05:55.474] A SequentialFuture was resolved
[16:05:55.474]  length: 3 (resolved future 1)
[16:05:55.475] resolved() for ‘SequentialFuture’ ...
[16:05:55.475] - state: ‘finished’
[16:05:55.475] - run: TRUE
[16:05:55.475] - result: ‘FutureResult’
[16:05:55.475] resolved() for ‘SequentialFuture’ ... done
[16:05:55.475] Future #2
[16:05:55.475] resolved() for ‘SequentialFuture’ ...
[16:05:55.475] - state: ‘finished’
[16:05:55.475] - run: TRUE
[16:05:55.475] - result: ‘FutureResult’
[16:05:55.476] resolved() for ‘SequentialFuture’ ... done
[16:05:55.476] A SequentialFuture was resolved
[16:05:55.476]  length: 2 (resolved future 2)
[16:05:55.476] resolved() for ‘SequentialFuture’ ...
[16:05:55.476] - state: ‘finished’
[16:05:55.476] - run: TRUE
[16:05:55.476] - result: ‘FutureResult’
[16:05:55.476] resolved() for ‘SequentialFuture’ ... done
[16:05:55.476] Future #3
[16:05:55.476] resolved() for ‘SequentialFuture’ ...
[16:05:55.476] - state: ‘finished’
[16:05:55.477] - run: TRUE
[16:05:55.477] - result: ‘FutureResult’
[16:05:55.477] resolved() for ‘SequentialFuture’ ... done
[16:05:55.499] A SequentialFuture was resolved
[16:05:55.499]  length: 1 (resolved future 3)
[16:05:55.500]  length: 0 (resolved future 4)
[16:05:55.500] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[16:05:55.500] plan(): Setting new future strategy stack:
[16:05:55.501] List of future strategies:
[16:05:55.501] 1. multicore:
[16:05:55.501]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.501]    - tweaked: FALSE
[16:05:55.501]    - call: plan(strategy)
[16:05:55.505] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[16:05:55.505] resolve() on list ...
[16:05:55.505]  recursive: 0
[16:05:55.505]  length: 2
[16:05:55.505]  elements: ‘a’, ‘b’
[16:05:55.505]  length: 1 (resolved future 1)
[16:05:55.506]  length: 0 (resolved future 2)
[16:05:55.506] resolve() on list ... DONE
[16:05:55.506] getGlobalsAndPackages() ...
[16:05:55.506] Searching for globals...
[16:05:55.506] 
[16:05:55.506] Searching for globals ... DONE
[16:05:55.506] - globals: [0] <none>
[16:05:55.507] getGlobalsAndPackages() ... DONE
[16:05:55.507] run() for ‘Future’ ...
[16:05:55.507] - state: ‘created’
[16:05:55.507] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.510] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.511]   - Field: ‘label’
[16:05:55.511]   - Field: ‘local’
[16:05:55.511]   - Field: ‘owner’
[16:05:55.511]   - Field: ‘envir’
[16:05:55.511]   - Field: ‘workers’
[16:05:55.511]   - Field: ‘packages’
[16:05:55.511]   - Field: ‘gc’
[16:05:55.511]   - Field: ‘job’
[16:05:55.511]   - Field: ‘conditions’
[16:05:55.512]   - Field: ‘expr’
[16:05:55.512]   - Field: ‘uuid’
[16:05:55.512]   - Field: ‘seed’
[16:05:55.512]   - Field: ‘version’
[16:05:55.512]   - Field: ‘result’
[16:05:55.512]   - Field: ‘asynchronous’
[16:05:55.512]   - Field: ‘calls’
[16:05:55.512]   - Field: ‘globals’
[16:05:55.512]   - Field: ‘stdout’
[16:05:55.512]   - Field: ‘earlySignal’
[16:05:55.512]   - Field: ‘lazy’
[16:05:55.513]   - Field: ‘state’
[16:05:55.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.513] - Launch lazy future ...
[16:05:55.514] Packages needed by the future expression (n = 0): <none>
[16:05:55.514] Packages needed by future strategies (n = 0): <none>
[16:05:55.514] {
[16:05:55.514]     {
[16:05:55.514]         {
[16:05:55.514]             ...future.startTime <- base::Sys.time()
[16:05:55.514]             {
[16:05:55.514]                 {
[16:05:55.514]                   {
[16:05:55.514]                     {
[16:05:55.514]                       base::local({
[16:05:55.514]                         has_future <- base::requireNamespace("future", 
[16:05:55.514]                           quietly = TRUE)
[16:05:55.514]                         if (has_future) {
[16:05:55.514]                           ns <- base::getNamespace("future")
[16:05:55.514]                           version <- ns[[".package"]][["version"]]
[16:05:55.514]                           if (is.null(version)) 
[16:05:55.514]                             version <- utils::packageVersion("future")
[16:05:55.514]                         }
[16:05:55.514]                         else {
[16:05:55.514]                           version <- NULL
[16:05:55.514]                         }
[16:05:55.514]                         if (!has_future || version < "1.8.0") {
[16:05:55.514]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.514]                             "", base::R.version$version.string), 
[16:05:55.514]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.514]                               "release", "version")], collapse = " "), 
[16:05:55.514]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.514]                             info)
[16:05:55.514]                           info <- base::paste(info, collapse = "; ")
[16:05:55.514]                           if (!has_future) {
[16:05:55.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.514]                               info)
[16:05:55.514]                           }
[16:05:55.514]                           else {
[16:05:55.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.514]                               info, version)
[16:05:55.514]                           }
[16:05:55.514]                           base::stop(msg)
[16:05:55.514]                         }
[16:05:55.514]                       })
[16:05:55.514]                     }
[16:05:55.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.514]                     base::options(mc.cores = 1L)
[16:05:55.514]                   }
[16:05:55.514]                   options(future.plan = NULL)
[16:05:55.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.514]                 }
[16:05:55.514]                 ...future.workdir <- getwd()
[16:05:55.514]             }
[16:05:55.514]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.514]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.514]         }
[16:05:55.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.514]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.514]             base::names(...future.oldOptions))
[16:05:55.514]     }
[16:05:55.514]     if (FALSE) {
[16:05:55.514]     }
[16:05:55.514]     else {
[16:05:55.514]         if (TRUE) {
[16:05:55.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.514]                 open = "w")
[16:05:55.514]         }
[16:05:55.514]         else {
[16:05:55.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.514]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.514]         }
[16:05:55.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.514]             base::sink(type = "output", split = FALSE)
[16:05:55.514]             base::close(...future.stdout)
[16:05:55.514]         }, add = TRUE)
[16:05:55.514]     }
[16:05:55.514]     ...future.frame <- base::sys.nframe()
[16:05:55.514]     ...future.conditions <- base::list()
[16:05:55.514]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.514]     if (FALSE) {
[16:05:55.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.514]     }
[16:05:55.514]     ...future.result <- base::tryCatch({
[16:05:55.514]         base::withCallingHandlers({
[16:05:55.514]             ...future.value <- base::withVisible(base::local({
[16:05:55.514]                 withCallingHandlers({
[16:05:55.514]                   1
[16:05:55.514]                 }, immediateCondition = function(cond) {
[16:05:55.514]                   save_rds <- function (object, pathname, ...) 
[16:05:55.514]                   {
[16:05:55.514]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.514]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.514]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.514]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.514]                         fi_tmp[["mtime"]])
[16:05:55.514]                     }
[16:05:55.514]                     tryCatch({
[16:05:55.514]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.514]                     }, error = function(ex) {
[16:05:55.514]                       msg <- conditionMessage(ex)
[16:05:55.514]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.514]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.514]                         fi_tmp[["mtime"]], msg)
[16:05:55.514]                       ex$message <- msg
[16:05:55.514]                       stop(ex)
[16:05:55.514]                     })
[16:05:55.514]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.514]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.514]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.514]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.514]                       fi <- file.info(pathname)
[16:05:55.514]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.514]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.514]                         fi[["size"]], fi[["mtime"]])
[16:05:55.514]                       stop(msg)
[16:05:55.514]                     }
[16:05:55.514]                     invisible(pathname)
[16:05:55.514]                   }
[16:05:55.514]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.514]                     rootPath = tempdir()) 
[16:05:55.514]                   {
[16:05:55.514]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.514]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.514]                       tmpdir = path, fileext = ".rds")
[16:05:55.514]                     save_rds(obj, file)
[16:05:55.514]                   }
[16:05:55.514]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.514]                   {
[16:05:55.514]                     inherits <- base::inherits
[16:05:55.514]                     invokeRestart <- base::invokeRestart
[16:05:55.514]                     is.null <- base::is.null
[16:05:55.514]                     muffled <- FALSE
[16:05:55.514]                     if (inherits(cond, "message")) {
[16:05:55.514]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.514]                       if (muffled) 
[16:05:55.514]                         invokeRestart("muffleMessage")
[16:05:55.514]                     }
[16:05:55.514]                     else if (inherits(cond, "warning")) {
[16:05:55.514]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.514]                       if (muffled) 
[16:05:55.514]                         invokeRestart("muffleWarning")
[16:05:55.514]                     }
[16:05:55.514]                     else if (inherits(cond, "condition")) {
[16:05:55.514]                       if (!is.null(pattern)) {
[16:05:55.514]                         computeRestarts <- base::computeRestarts
[16:05:55.514]                         grepl <- base::grepl
[16:05:55.514]                         restarts <- computeRestarts(cond)
[16:05:55.514]                         for (restart in restarts) {
[16:05:55.514]                           name <- restart$name
[16:05:55.514]                           if (is.null(name)) 
[16:05:55.514]                             next
[16:05:55.514]                           if (!grepl(pattern, name)) 
[16:05:55.514]                             next
[16:05:55.514]                           invokeRestart(restart)
[16:05:55.514]                           muffled <- TRUE
[16:05:55.514]                           break
[16:05:55.514]                         }
[16:05:55.514]                       }
[16:05:55.514]                     }
[16:05:55.514]                     invisible(muffled)
[16:05:55.514]                   }
[16:05:55.514]                   muffleCondition(cond)
[16:05:55.514]                 })
[16:05:55.514]             }))
[16:05:55.514]             future::FutureResult(value = ...future.value$value, 
[16:05:55.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.514]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.514]                     ...future.globalenv.names))
[16:05:55.514]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.514]         }, condition = base::local({
[16:05:55.514]             c <- base::c
[16:05:55.514]             inherits <- base::inherits
[16:05:55.514]             invokeRestart <- base::invokeRestart
[16:05:55.514]             length <- base::length
[16:05:55.514]             list <- base::list
[16:05:55.514]             seq.int <- base::seq.int
[16:05:55.514]             signalCondition <- base::signalCondition
[16:05:55.514]             sys.calls <- base::sys.calls
[16:05:55.514]             `[[` <- base::`[[`
[16:05:55.514]             `+` <- base::`+`
[16:05:55.514]             `<<-` <- base::`<<-`
[16:05:55.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.514]                   3L)]
[16:05:55.514]             }
[16:05:55.514]             function(cond) {
[16:05:55.514]                 is_error <- inherits(cond, "error")
[16:05:55.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.514]                   NULL)
[16:05:55.514]                 if (is_error) {
[16:05:55.514]                   sessionInformation <- function() {
[16:05:55.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.514]                       search = base::search(), system = base::Sys.info())
[16:05:55.514]                   }
[16:05:55.514]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.514]                     cond$call), session = sessionInformation(), 
[16:05:55.514]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.514]                   signalCondition(cond)
[16:05:55.514]                 }
[16:05:55.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.514]                 "immediateCondition"))) {
[16:05:55.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.514]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.514]                   if (TRUE && !signal) {
[16:05:55.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.514]                     {
[16:05:55.514]                       inherits <- base::inherits
[16:05:55.514]                       invokeRestart <- base::invokeRestart
[16:05:55.514]                       is.null <- base::is.null
[16:05:55.514]                       muffled <- FALSE
[16:05:55.514]                       if (inherits(cond, "message")) {
[16:05:55.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.514]                         if (muffled) 
[16:05:55.514]                           invokeRestart("muffleMessage")
[16:05:55.514]                       }
[16:05:55.514]                       else if (inherits(cond, "warning")) {
[16:05:55.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.514]                         if (muffled) 
[16:05:55.514]                           invokeRestart("muffleWarning")
[16:05:55.514]                       }
[16:05:55.514]                       else if (inherits(cond, "condition")) {
[16:05:55.514]                         if (!is.null(pattern)) {
[16:05:55.514]                           computeRestarts <- base::computeRestarts
[16:05:55.514]                           grepl <- base::grepl
[16:05:55.514]                           restarts <- computeRestarts(cond)
[16:05:55.514]                           for (restart in restarts) {
[16:05:55.514]                             name <- restart$name
[16:05:55.514]                             if (is.null(name)) 
[16:05:55.514]                               next
[16:05:55.514]                             if (!grepl(pattern, name)) 
[16:05:55.514]                               next
[16:05:55.514]                             invokeRestart(restart)
[16:05:55.514]                             muffled <- TRUE
[16:05:55.514]                             break
[16:05:55.514]                           }
[16:05:55.514]                         }
[16:05:55.514]                       }
[16:05:55.514]                       invisible(muffled)
[16:05:55.514]                     }
[16:05:55.514]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.514]                   }
[16:05:55.514]                 }
[16:05:55.514]                 else {
[16:05:55.514]                   if (TRUE) {
[16:05:55.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.514]                     {
[16:05:55.514]                       inherits <- base::inherits
[16:05:55.514]                       invokeRestart <- base::invokeRestart
[16:05:55.514]                       is.null <- base::is.null
[16:05:55.514]                       muffled <- FALSE
[16:05:55.514]                       if (inherits(cond, "message")) {
[16:05:55.514]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.514]                         if (muffled) 
[16:05:55.514]                           invokeRestart("muffleMessage")
[16:05:55.514]                       }
[16:05:55.514]                       else if (inherits(cond, "warning")) {
[16:05:55.514]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.514]                         if (muffled) 
[16:05:55.514]                           invokeRestart("muffleWarning")
[16:05:55.514]                       }
[16:05:55.514]                       else if (inherits(cond, "condition")) {
[16:05:55.514]                         if (!is.null(pattern)) {
[16:05:55.514]                           computeRestarts <- base::computeRestarts
[16:05:55.514]                           grepl <- base::grepl
[16:05:55.514]                           restarts <- computeRestarts(cond)
[16:05:55.514]                           for (restart in restarts) {
[16:05:55.514]                             name <- restart$name
[16:05:55.514]                             if (is.null(name)) 
[16:05:55.514]                               next
[16:05:55.514]                             if (!grepl(pattern, name)) 
[16:05:55.514]                               next
[16:05:55.514]                             invokeRestart(restart)
[16:05:55.514]                             muffled <- TRUE
[16:05:55.514]                             break
[16:05:55.514]                           }
[16:05:55.514]                         }
[16:05:55.514]                       }
[16:05:55.514]                       invisible(muffled)
[16:05:55.514]                     }
[16:05:55.514]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.514]                   }
[16:05:55.514]                 }
[16:05:55.514]             }
[16:05:55.514]         }))
[16:05:55.514]     }, error = function(ex) {
[16:05:55.514]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.514]                 ...future.rng), started = ...future.startTime, 
[16:05:55.514]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.514]             version = "1.8"), class = "FutureResult")
[16:05:55.514]     }, finally = {
[16:05:55.514]         if (!identical(...future.workdir, getwd())) 
[16:05:55.514]             setwd(...future.workdir)
[16:05:55.514]         {
[16:05:55.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.514]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.514]             }
[16:05:55.514]             base::options(...future.oldOptions)
[16:05:55.514]             if (.Platform$OS.type == "windows") {
[16:05:55.514]                 old_names <- names(...future.oldEnvVars)
[16:05:55.514]                 envs <- base::Sys.getenv()
[16:05:55.514]                 names <- names(envs)
[16:05:55.514]                 common <- intersect(names, old_names)
[16:05:55.514]                 added <- setdiff(names, old_names)
[16:05:55.514]                 removed <- setdiff(old_names, names)
[16:05:55.514]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.514]                   envs[common]]
[16:05:55.514]                 NAMES <- toupper(changed)
[16:05:55.514]                 args <- list()
[16:05:55.514]                 for (kk in seq_along(NAMES)) {
[16:05:55.514]                   name <- changed[[kk]]
[16:05:55.514]                   NAME <- NAMES[[kk]]
[16:05:55.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.514]                     next
[16:05:55.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.514]                 }
[16:05:55.514]                 NAMES <- toupper(added)
[16:05:55.514]                 for (kk in seq_along(NAMES)) {
[16:05:55.514]                   name <- added[[kk]]
[16:05:55.514]                   NAME <- NAMES[[kk]]
[16:05:55.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.514]                     next
[16:05:55.514]                   args[[name]] <- ""
[16:05:55.514]                 }
[16:05:55.514]                 NAMES <- toupper(removed)
[16:05:55.514]                 for (kk in seq_along(NAMES)) {
[16:05:55.514]                   name <- removed[[kk]]
[16:05:55.514]                   NAME <- NAMES[[kk]]
[16:05:55.514]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.514]                     next
[16:05:55.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.514]                 }
[16:05:55.514]                 if (length(args) > 0) 
[16:05:55.514]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.514]             }
[16:05:55.514]             else {
[16:05:55.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.514]             }
[16:05:55.514]             {
[16:05:55.514]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.514]                   0L) {
[16:05:55.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.514]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.514]                   base::options(opts)
[16:05:55.514]                 }
[16:05:55.514]                 {
[16:05:55.514]                   {
[16:05:55.514]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.514]                     NULL
[16:05:55.514]                   }
[16:05:55.514]                   options(future.plan = NULL)
[16:05:55.514]                   if (is.na(NA_character_)) 
[16:05:55.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.514]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.514]                     envir = parent.frame()) 
[16:05:55.514]                   {
[16:05:55.514]                     default_workers <- missing(workers)
[16:05:55.514]                     if (is.function(workers)) 
[16:05:55.514]                       workers <- workers()
[16:05:55.514]                     workers <- structure(as.integer(workers), 
[16:05:55.514]                       class = class(workers))
[16:05:55.514]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.514]                       1L)
[16:05:55.514]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.514]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.514]                       if (default_workers) 
[16:05:55.514]                         supportsMulticore(warn = TRUE)
[16:05:55.514]                       return(sequential(..., envir = envir))
[16:05:55.514]                     }
[16:05:55.514]                     oopts <- options(mc.cores = workers)
[16:05:55.514]                     on.exit(options(oopts))
[16:05:55.514]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.514]                       envir = envir)
[16:05:55.514]                     if (!future$lazy) 
[16:05:55.514]                       future <- run(future)
[16:05:55.514]                     invisible(future)
[16:05:55.514]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.514]                 }
[16:05:55.514]             }
[16:05:55.514]         }
[16:05:55.514]     })
[16:05:55.514]     if (TRUE) {
[16:05:55.514]         base::sink(type = "output", split = FALSE)
[16:05:55.514]         if (TRUE) {
[16:05:55.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.514]         }
[16:05:55.514]         else {
[16:05:55.514]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.514]         }
[16:05:55.514]         base::close(...future.stdout)
[16:05:55.514]         ...future.stdout <- NULL
[16:05:55.514]     }
[16:05:55.514]     ...future.result$conditions <- ...future.conditions
[16:05:55.514]     ...future.result$finished <- base::Sys.time()
[16:05:55.514]     ...future.result
[16:05:55.514] }
[16:05:55.517] requestCore(): workers = 2
[16:05:55.519] MulticoreFuture started
[16:05:55.520] - Launch lazy future ... done
[16:05:55.520] run() for ‘MulticoreFuture’ ... done
[16:05:55.520] plan(): Setting new future strategy stack:
[16:05:55.521] getGlobalsAndPackages() ...
[16:05:55.521] Searching for globals...
[16:05:55.520] List of future strategies:
[16:05:55.520] 1. sequential:
[16:05:55.520]    - args: function (..., envir = parent.frame())
[16:05:55.520]    - tweaked: FALSE
[16:05:55.520]    - call: NULL
[16:05:55.521] plan(): nbrOfWorkers() = 1
[16:05:55.522] 
[16:05:55.522] Searching for globals ... DONE
[16:05:55.522] - globals: [0] <none>
[16:05:55.523] getGlobalsAndPackages() ... DONE
[16:05:55.523] run() for ‘Future’ ...
[16:05:55.523] plan(): Setting new future strategy stack:
[16:05:55.523] - state: ‘created’
[16:05:55.524] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.523] List of future strategies:
[16:05:55.523] 1. multicore:
[16:05:55.523]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.523]    - tweaked: FALSE
[16:05:55.523]    - call: plan(strategy)
[16:05:55.528] plan(): nbrOfWorkers() = 2
[16:05:55.528] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.529]   - Field: ‘label’
[16:05:55.529]   - Field: ‘local’
[16:05:55.529]   - Field: ‘owner’
[16:05:55.529]   - Field: ‘envir’
[16:05:55.529]   - Field: ‘workers’
[16:05:55.530]   - Field: ‘packages’
[16:05:55.530]   - Field: ‘gc’
[16:05:55.530]   - Field: ‘job’
[16:05:55.530]   - Field: ‘conditions’
[16:05:55.530]   - Field: ‘expr’
[16:05:55.530]   - Field: ‘uuid’
[16:05:55.531]   - Field: ‘seed’
[16:05:55.531]   - Field: ‘version’
[16:05:55.531]   - Field: ‘result’
[16:05:55.531]   - Field: ‘asynchronous’
[16:05:55.531]   - Field: ‘calls’
[16:05:55.531]   - Field: ‘globals’
[16:05:55.531]   - Field: ‘stdout’
[16:05:55.532]   - Field: ‘earlySignal’
[16:05:55.532]   - Field: ‘lazy’
[16:05:55.532]   - Field: ‘state’
[16:05:55.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.532] - Launch lazy future ...
[16:05:55.533] Packages needed by the future expression (n = 0): <none>
[16:05:55.533] Packages needed by future strategies (n = 0): <none>
[16:05:55.534] {
[16:05:55.534]     {
[16:05:55.534]         {
[16:05:55.534]             ...future.startTime <- base::Sys.time()
[16:05:55.534]             {
[16:05:55.534]                 {
[16:05:55.534]                   {
[16:05:55.534]                     {
[16:05:55.534]                       base::local({
[16:05:55.534]                         has_future <- base::requireNamespace("future", 
[16:05:55.534]                           quietly = TRUE)
[16:05:55.534]                         if (has_future) {
[16:05:55.534]                           ns <- base::getNamespace("future")
[16:05:55.534]                           version <- ns[[".package"]][["version"]]
[16:05:55.534]                           if (is.null(version)) 
[16:05:55.534]                             version <- utils::packageVersion("future")
[16:05:55.534]                         }
[16:05:55.534]                         else {
[16:05:55.534]                           version <- NULL
[16:05:55.534]                         }
[16:05:55.534]                         if (!has_future || version < "1.8.0") {
[16:05:55.534]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.534]                             "", base::R.version$version.string), 
[16:05:55.534]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.534]                               "release", "version")], collapse = " "), 
[16:05:55.534]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.534]                             info)
[16:05:55.534]                           info <- base::paste(info, collapse = "; ")
[16:05:55.534]                           if (!has_future) {
[16:05:55.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.534]                               info)
[16:05:55.534]                           }
[16:05:55.534]                           else {
[16:05:55.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.534]                               info, version)
[16:05:55.534]                           }
[16:05:55.534]                           base::stop(msg)
[16:05:55.534]                         }
[16:05:55.534]                       })
[16:05:55.534]                     }
[16:05:55.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.534]                     base::options(mc.cores = 1L)
[16:05:55.534]                   }
[16:05:55.534]                   options(future.plan = NULL)
[16:05:55.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.534]                 }
[16:05:55.534]                 ...future.workdir <- getwd()
[16:05:55.534]             }
[16:05:55.534]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.534]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.534]         }
[16:05:55.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.534]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.534]             base::names(...future.oldOptions))
[16:05:55.534]     }
[16:05:55.534]     if (FALSE) {
[16:05:55.534]     }
[16:05:55.534]     else {
[16:05:55.534]         if (TRUE) {
[16:05:55.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.534]                 open = "w")
[16:05:55.534]         }
[16:05:55.534]         else {
[16:05:55.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.534]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.534]         }
[16:05:55.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.534]             base::sink(type = "output", split = FALSE)
[16:05:55.534]             base::close(...future.stdout)
[16:05:55.534]         }, add = TRUE)
[16:05:55.534]     }
[16:05:55.534]     ...future.frame <- base::sys.nframe()
[16:05:55.534]     ...future.conditions <- base::list()
[16:05:55.534]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.534]     if (FALSE) {
[16:05:55.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.534]     }
[16:05:55.534]     ...future.result <- base::tryCatch({
[16:05:55.534]         base::withCallingHandlers({
[16:05:55.534]             ...future.value <- base::withVisible(base::local({
[16:05:55.534]                 withCallingHandlers({
[16:05:55.534]                   2
[16:05:55.534]                 }, immediateCondition = function(cond) {
[16:05:55.534]                   save_rds <- function (object, pathname, ...) 
[16:05:55.534]                   {
[16:05:55.534]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.534]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.534]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.534]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.534]                         fi_tmp[["mtime"]])
[16:05:55.534]                     }
[16:05:55.534]                     tryCatch({
[16:05:55.534]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.534]                     }, error = function(ex) {
[16:05:55.534]                       msg <- conditionMessage(ex)
[16:05:55.534]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.534]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.534]                         fi_tmp[["mtime"]], msg)
[16:05:55.534]                       ex$message <- msg
[16:05:55.534]                       stop(ex)
[16:05:55.534]                     })
[16:05:55.534]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.534]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.534]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.534]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.534]                       fi <- file.info(pathname)
[16:05:55.534]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.534]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.534]                         fi[["size"]], fi[["mtime"]])
[16:05:55.534]                       stop(msg)
[16:05:55.534]                     }
[16:05:55.534]                     invisible(pathname)
[16:05:55.534]                   }
[16:05:55.534]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.534]                     rootPath = tempdir()) 
[16:05:55.534]                   {
[16:05:55.534]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.534]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.534]                       tmpdir = path, fileext = ".rds")
[16:05:55.534]                     save_rds(obj, file)
[16:05:55.534]                   }
[16:05:55.534]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.534]                   {
[16:05:55.534]                     inherits <- base::inherits
[16:05:55.534]                     invokeRestart <- base::invokeRestart
[16:05:55.534]                     is.null <- base::is.null
[16:05:55.534]                     muffled <- FALSE
[16:05:55.534]                     if (inherits(cond, "message")) {
[16:05:55.534]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.534]                       if (muffled) 
[16:05:55.534]                         invokeRestart("muffleMessage")
[16:05:55.534]                     }
[16:05:55.534]                     else if (inherits(cond, "warning")) {
[16:05:55.534]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.534]                       if (muffled) 
[16:05:55.534]                         invokeRestart("muffleWarning")
[16:05:55.534]                     }
[16:05:55.534]                     else if (inherits(cond, "condition")) {
[16:05:55.534]                       if (!is.null(pattern)) {
[16:05:55.534]                         computeRestarts <- base::computeRestarts
[16:05:55.534]                         grepl <- base::grepl
[16:05:55.534]                         restarts <- computeRestarts(cond)
[16:05:55.534]                         for (restart in restarts) {
[16:05:55.534]                           name <- restart$name
[16:05:55.534]                           if (is.null(name)) 
[16:05:55.534]                             next
[16:05:55.534]                           if (!grepl(pattern, name)) 
[16:05:55.534]                             next
[16:05:55.534]                           invokeRestart(restart)
[16:05:55.534]                           muffled <- TRUE
[16:05:55.534]                           break
[16:05:55.534]                         }
[16:05:55.534]                       }
[16:05:55.534]                     }
[16:05:55.534]                     invisible(muffled)
[16:05:55.534]                   }
[16:05:55.534]                   muffleCondition(cond)
[16:05:55.534]                 })
[16:05:55.534]             }))
[16:05:55.534]             future::FutureResult(value = ...future.value$value, 
[16:05:55.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.534]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.534]                     ...future.globalenv.names))
[16:05:55.534]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.534]         }, condition = base::local({
[16:05:55.534]             c <- base::c
[16:05:55.534]             inherits <- base::inherits
[16:05:55.534]             invokeRestart <- base::invokeRestart
[16:05:55.534]             length <- base::length
[16:05:55.534]             list <- base::list
[16:05:55.534]             seq.int <- base::seq.int
[16:05:55.534]             signalCondition <- base::signalCondition
[16:05:55.534]             sys.calls <- base::sys.calls
[16:05:55.534]             `[[` <- base::`[[`
[16:05:55.534]             `+` <- base::`+`
[16:05:55.534]             `<<-` <- base::`<<-`
[16:05:55.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.534]                   3L)]
[16:05:55.534]             }
[16:05:55.534]             function(cond) {
[16:05:55.534]                 is_error <- inherits(cond, "error")
[16:05:55.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.534]                   NULL)
[16:05:55.534]                 if (is_error) {
[16:05:55.534]                   sessionInformation <- function() {
[16:05:55.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.534]                       search = base::search(), system = base::Sys.info())
[16:05:55.534]                   }
[16:05:55.534]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.534]                     cond$call), session = sessionInformation(), 
[16:05:55.534]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.534]                   signalCondition(cond)
[16:05:55.534]                 }
[16:05:55.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.534]                 "immediateCondition"))) {
[16:05:55.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.534]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.534]                   if (TRUE && !signal) {
[16:05:55.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.534]                     {
[16:05:55.534]                       inherits <- base::inherits
[16:05:55.534]                       invokeRestart <- base::invokeRestart
[16:05:55.534]                       is.null <- base::is.null
[16:05:55.534]                       muffled <- FALSE
[16:05:55.534]                       if (inherits(cond, "message")) {
[16:05:55.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.534]                         if (muffled) 
[16:05:55.534]                           invokeRestart("muffleMessage")
[16:05:55.534]                       }
[16:05:55.534]                       else if (inherits(cond, "warning")) {
[16:05:55.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.534]                         if (muffled) 
[16:05:55.534]                           invokeRestart("muffleWarning")
[16:05:55.534]                       }
[16:05:55.534]                       else if (inherits(cond, "condition")) {
[16:05:55.534]                         if (!is.null(pattern)) {
[16:05:55.534]                           computeRestarts <- base::computeRestarts
[16:05:55.534]                           grepl <- base::grepl
[16:05:55.534]                           restarts <- computeRestarts(cond)
[16:05:55.534]                           for (restart in restarts) {
[16:05:55.534]                             name <- restart$name
[16:05:55.534]                             if (is.null(name)) 
[16:05:55.534]                               next
[16:05:55.534]                             if (!grepl(pattern, name)) 
[16:05:55.534]                               next
[16:05:55.534]                             invokeRestart(restart)
[16:05:55.534]                             muffled <- TRUE
[16:05:55.534]                             break
[16:05:55.534]                           }
[16:05:55.534]                         }
[16:05:55.534]                       }
[16:05:55.534]                       invisible(muffled)
[16:05:55.534]                     }
[16:05:55.534]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.534]                   }
[16:05:55.534]                 }
[16:05:55.534]                 else {
[16:05:55.534]                   if (TRUE) {
[16:05:55.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.534]                     {
[16:05:55.534]                       inherits <- base::inherits
[16:05:55.534]                       invokeRestart <- base::invokeRestart
[16:05:55.534]                       is.null <- base::is.null
[16:05:55.534]                       muffled <- FALSE
[16:05:55.534]                       if (inherits(cond, "message")) {
[16:05:55.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.534]                         if (muffled) 
[16:05:55.534]                           invokeRestart("muffleMessage")
[16:05:55.534]                       }
[16:05:55.534]                       else if (inherits(cond, "warning")) {
[16:05:55.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.534]                         if (muffled) 
[16:05:55.534]                           invokeRestart("muffleWarning")
[16:05:55.534]                       }
[16:05:55.534]                       else if (inherits(cond, "condition")) {
[16:05:55.534]                         if (!is.null(pattern)) {
[16:05:55.534]                           computeRestarts <- base::computeRestarts
[16:05:55.534]                           grepl <- base::grepl
[16:05:55.534]                           restarts <- computeRestarts(cond)
[16:05:55.534]                           for (restart in restarts) {
[16:05:55.534]                             name <- restart$name
[16:05:55.534]                             if (is.null(name)) 
[16:05:55.534]                               next
[16:05:55.534]                             if (!grepl(pattern, name)) 
[16:05:55.534]                               next
[16:05:55.534]                             invokeRestart(restart)
[16:05:55.534]                             muffled <- TRUE
[16:05:55.534]                             break
[16:05:55.534]                           }
[16:05:55.534]                         }
[16:05:55.534]                       }
[16:05:55.534]                       invisible(muffled)
[16:05:55.534]                     }
[16:05:55.534]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.534]                   }
[16:05:55.534]                 }
[16:05:55.534]             }
[16:05:55.534]         }))
[16:05:55.534]     }, error = function(ex) {
[16:05:55.534]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.534]                 ...future.rng), started = ...future.startTime, 
[16:05:55.534]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.534]             version = "1.8"), class = "FutureResult")
[16:05:55.534]     }, finally = {
[16:05:55.534]         if (!identical(...future.workdir, getwd())) 
[16:05:55.534]             setwd(...future.workdir)
[16:05:55.534]         {
[16:05:55.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.534]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.534]             }
[16:05:55.534]             base::options(...future.oldOptions)
[16:05:55.534]             if (.Platform$OS.type == "windows") {
[16:05:55.534]                 old_names <- names(...future.oldEnvVars)
[16:05:55.534]                 envs <- base::Sys.getenv()
[16:05:55.534]                 names <- names(envs)
[16:05:55.534]                 common <- intersect(names, old_names)
[16:05:55.534]                 added <- setdiff(names, old_names)
[16:05:55.534]                 removed <- setdiff(old_names, names)
[16:05:55.534]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.534]                   envs[common]]
[16:05:55.534]                 NAMES <- toupper(changed)
[16:05:55.534]                 args <- list()
[16:05:55.534]                 for (kk in seq_along(NAMES)) {
[16:05:55.534]                   name <- changed[[kk]]
[16:05:55.534]                   NAME <- NAMES[[kk]]
[16:05:55.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.534]                     next
[16:05:55.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.534]                 }
[16:05:55.534]                 NAMES <- toupper(added)
[16:05:55.534]                 for (kk in seq_along(NAMES)) {
[16:05:55.534]                   name <- added[[kk]]
[16:05:55.534]                   NAME <- NAMES[[kk]]
[16:05:55.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.534]                     next
[16:05:55.534]                   args[[name]] <- ""
[16:05:55.534]                 }
[16:05:55.534]                 NAMES <- toupper(removed)
[16:05:55.534]                 for (kk in seq_along(NAMES)) {
[16:05:55.534]                   name <- removed[[kk]]
[16:05:55.534]                   NAME <- NAMES[[kk]]
[16:05:55.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.534]                     next
[16:05:55.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.534]                 }
[16:05:55.534]                 if (length(args) > 0) 
[16:05:55.534]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.534]             }
[16:05:55.534]             else {
[16:05:55.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.534]             }
[16:05:55.534]             {
[16:05:55.534]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.534]                   0L) {
[16:05:55.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.534]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.534]                   base::options(opts)
[16:05:55.534]                 }
[16:05:55.534]                 {
[16:05:55.534]                   {
[16:05:55.534]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.534]                     NULL
[16:05:55.534]                   }
[16:05:55.534]                   options(future.plan = NULL)
[16:05:55.534]                   if (is.na(NA_character_)) 
[16:05:55.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.534]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.534]                     envir = parent.frame()) 
[16:05:55.534]                   {
[16:05:55.534]                     default_workers <- missing(workers)
[16:05:55.534]                     if (is.function(workers)) 
[16:05:55.534]                       workers <- workers()
[16:05:55.534]                     workers <- structure(as.integer(workers), 
[16:05:55.534]                       class = class(workers))
[16:05:55.534]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.534]                       1L)
[16:05:55.534]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.534]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.534]                       if (default_workers) 
[16:05:55.534]                         supportsMulticore(warn = TRUE)
[16:05:55.534]                       return(sequential(..., envir = envir))
[16:05:55.534]                     }
[16:05:55.534]                     oopts <- options(mc.cores = workers)
[16:05:55.534]                     on.exit(options(oopts))
[16:05:55.534]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.534]                       envir = envir)
[16:05:55.534]                     if (!future$lazy) 
[16:05:55.534]                       future <- run(future)
[16:05:55.534]                     invisible(future)
[16:05:55.534]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.534]                 }
[16:05:55.534]             }
[16:05:55.534]         }
[16:05:55.534]     })
[16:05:55.534]     if (TRUE) {
[16:05:55.534]         base::sink(type = "output", split = FALSE)
[16:05:55.534]         if (TRUE) {
[16:05:55.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.534]         }
[16:05:55.534]         else {
[16:05:55.534]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.534]         }
[16:05:55.534]         base::close(...future.stdout)
[16:05:55.534]         ...future.stdout <- NULL
[16:05:55.534]     }
[16:05:55.534]     ...future.result$conditions <- ...future.conditions
[16:05:55.534]     ...future.result$finished <- base::Sys.time()
[16:05:55.534]     ...future.result
[16:05:55.534] }
[16:05:55.537] requestCore(): workers = 2
[16:05:55.543] MulticoreFuture started
[16:05:55.543] - Launch lazy future ... done
[16:05:55.543] run() for ‘MulticoreFuture’ ... done
[16:05:55.544] resolve() on list ...
[16:05:55.544]  recursive: 0
[16:05:55.544]  length: 3
[16:05:55.544] plan(): Setting new future strategy stack:
[16:05:55.544]  elements: ‘a’, ‘b’, ‘’
[16:05:55.544] List of future strategies:
[16:05:55.544] 1. sequential:
[16:05:55.544]    - args: function (..., envir = parent.frame())
[16:05:55.544]    - tweaked: FALSE
[16:05:55.544]    - call: NULL
[16:05:55.545] plan(): nbrOfWorkers() = 1
[16:05:55.546] Future #1
[16:05:55.546]  length: 2 (resolved future 1)
[16:05:55.547] plan(): Setting new future strategy stack:
[16:05:55.547] List of future strategies:
[16:05:55.547] 1. multicore:
[16:05:55.547]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.547]    - tweaked: FALSE
[16:05:55.547]    - call: plan(strategy)
[16:05:55.552] plan(): nbrOfWorkers() = 2
[16:05:55.552] Future #2
[16:05:55.553]  length: 1 (resolved future 2)
[16:05:55.553]  length: 0 (resolved future 3)
[16:05:55.553] resolve() on list ... DONE
[16:05:55.553] getGlobalsAndPackages() ...
[16:05:55.554] Searching for globals...
[16:05:55.554] 
[16:05:55.554] Searching for globals ... DONE
[16:05:55.554] - globals: [0] <none>
[16:05:55.555] getGlobalsAndPackages() ... DONE
[16:05:55.555] getGlobalsAndPackages() ...
[16:05:55.555] Searching for globals...
[16:05:55.556] 
[16:05:55.556] Searching for globals ... DONE
[16:05:55.556] - globals: [0] <none>
[16:05:55.556] getGlobalsAndPackages() ... DONE
[16:05:55.556] run() for ‘Future’ ...
[16:05:55.557] - state: ‘created’
[16:05:55.557] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.561] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.561] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.562]   - Field: ‘label’
[16:05:55.562]   - Field: ‘local’
[16:05:55.562]   - Field: ‘owner’
[16:05:55.562]   - Field: ‘envir’
[16:05:55.566]   - Field: ‘workers’
[16:05:55.567]   - Field: ‘packages’
[16:05:55.567]   - Field: ‘gc’
[16:05:55.567]   - Field: ‘job’
[16:05:55.567]   - Field: ‘conditions’
[16:05:55.568]   - Field: ‘expr’
[16:05:55.568]   - Field: ‘uuid’
[16:05:55.568]   - Field: ‘seed’
[16:05:55.569]   - Field: ‘version’
[16:05:55.569]   - Field: ‘result’
[16:05:55.569]   - Field: ‘asynchronous’
[16:05:55.569]   - Field: ‘calls’
[16:05:55.570]   - Field: ‘globals’
[16:05:55.570]   - Field: ‘stdout’
[16:05:55.570]   - Field: ‘earlySignal’
[16:05:55.570]   - Field: ‘lazy’
[16:05:55.570]   - Field: ‘state’
[16:05:55.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.571] - Launch lazy future ...
[16:05:55.571] Packages needed by the future expression (n = 0): <none>
[16:05:55.571] Packages needed by future strategies (n = 0): <none>
[16:05:55.572] {
[16:05:55.572]     {
[16:05:55.572]         {
[16:05:55.572]             ...future.startTime <- base::Sys.time()
[16:05:55.572]             {
[16:05:55.572]                 {
[16:05:55.572]                   {
[16:05:55.572]                     {
[16:05:55.572]                       base::local({
[16:05:55.572]                         has_future <- base::requireNamespace("future", 
[16:05:55.572]                           quietly = TRUE)
[16:05:55.572]                         if (has_future) {
[16:05:55.572]                           ns <- base::getNamespace("future")
[16:05:55.572]                           version <- ns[[".package"]][["version"]]
[16:05:55.572]                           if (is.null(version)) 
[16:05:55.572]                             version <- utils::packageVersion("future")
[16:05:55.572]                         }
[16:05:55.572]                         else {
[16:05:55.572]                           version <- NULL
[16:05:55.572]                         }
[16:05:55.572]                         if (!has_future || version < "1.8.0") {
[16:05:55.572]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.572]                             "", base::R.version$version.string), 
[16:05:55.572]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.572]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.572]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.572]                               "release", "version")], collapse = " "), 
[16:05:55.572]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.572]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.572]                             info)
[16:05:55.572]                           info <- base::paste(info, collapse = "; ")
[16:05:55.572]                           if (!has_future) {
[16:05:55.572]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.572]                               info)
[16:05:55.572]                           }
[16:05:55.572]                           else {
[16:05:55.572]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.572]                               info, version)
[16:05:55.572]                           }
[16:05:55.572]                           base::stop(msg)
[16:05:55.572]                         }
[16:05:55.572]                       })
[16:05:55.572]                     }
[16:05:55.572]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.572]                     base::options(mc.cores = 1L)
[16:05:55.572]                   }
[16:05:55.572]                   options(future.plan = NULL)
[16:05:55.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.572]                 }
[16:05:55.572]                 ...future.workdir <- getwd()
[16:05:55.572]             }
[16:05:55.572]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.572]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.572]         }
[16:05:55.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.572]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.572]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.572]             base::names(...future.oldOptions))
[16:05:55.572]     }
[16:05:55.572]     if (FALSE) {
[16:05:55.572]     }
[16:05:55.572]     else {
[16:05:55.572]         if (TRUE) {
[16:05:55.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.572]                 open = "w")
[16:05:55.572]         }
[16:05:55.572]         else {
[16:05:55.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.572]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.572]         }
[16:05:55.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.572]             base::sink(type = "output", split = FALSE)
[16:05:55.572]             base::close(...future.stdout)
[16:05:55.572]         }, add = TRUE)
[16:05:55.572]     }
[16:05:55.572]     ...future.frame <- base::sys.nframe()
[16:05:55.572]     ...future.conditions <- base::list()
[16:05:55.572]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.572]     if (FALSE) {
[16:05:55.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.572]     }
[16:05:55.572]     ...future.result <- base::tryCatch({
[16:05:55.572]         base::withCallingHandlers({
[16:05:55.572]             ...future.value <- base::withVisible(base::local({
[16:05:55.572]                 withCallingHandlers({
[16:05:55.572]                   2
[16:05:55.572]                 }, immediateCondition = function(cond) {
[16:05:55.572]                   save_rds <- function (object, pathname, ...) 
[16:05:55.572]                   {
[16:05:55.572]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.572]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.572]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.572]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.572]                         fi_tmp[["mtime"]])
[16:05:55.572]                     }
[16:05:55.572]                     tryCatch({
[16:05:55.572]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.572]                     }, error = function(ex) {
[16:05:55.572]                       msg <- conditionMessage(ex)
[16:05:55.572]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.572]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.572]                         fi_tmp[["mtime"]], msg)
[16:05:55.572]                       ex$message <- msg
[16:05:55.572]                       stop(ex)
[16:05:55.572]                     })
[16:05:55.572]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.572]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.572]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.572]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.572]                       fi <- file.info(pathname)
[16:05:55.572]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.572]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.572]                         fi[["size"]], fi[["mtime"]])
[16:05:55.572]                       stop(msg)
[16:05:55.572]                     }
[16:05:55.572]                     invisible(pathname)
[16:05:55.572]                   }
[16:05:55.572]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.572]                     rootPath = tempdir()) 
[16:05:55.572]                   {
[16:05:55.572]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.572]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.572]                       tmpdir = path, fileext = ".rds")
[16:05:55.572]                     save_rds(obj, file)
[16:05:55.572]                   }
[16:05:55.572]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.572]                   {
[16:05:55.572]                     inherits <- base::inherits
[16:05:55.572]                     invokeRestart <- base::invokeRestart
[16:05:55.572]                     is.null <- base::is.null
[16:05:55.572]                     muffled <- FALSE
[16:05:55.572]                     if (inherits(cond, "message")) {
[16:05:55.572]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.572]                       if (muffled) 
[16:05:55.572]                         invokeRestart("muffleMessage")
[16:05:55.572]                     }
[16:05:55.572]                     else if (inherits(cond, "warning")) {
[16:05:55.572]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.572]                       if (muffled) 
[16:05:55.572]                         invokeRestart("muffleWarning")
[16:05:55.572]                     }
[16:05:55.572]                     else if (inherits(cond, "condition")) {
[16:05:55.572]                       if (!is.null(pattern)) {
[16:05:55.572]                         computeRestarts <- base::computeRestarts
[16:05:55.572]                         grepl <- base::grepl
[16:05:55.572]                         restarts <- computeRestarts(cond)
[16:05:55.572]                         for (restart in restarts) {
[16:05:55.572]                           name <- restart$name
[16:05:55.572]                           if (is.null(name)) 
[16:05:55.572]                             next
[16:05:55.572]                           if (!grepl(pattern, name)) 
[16:05:55.572]                             next
[16:05:55.572]                           invokeRestart(restart)
[16:05:55.572]                           muffled <- TRUE
[16:05:55.572]                           break
[16:05:55.572]                         }
[16:05:55.572]                       }
[16:05:55.572]                     }
[16:05:55.572]                     invisible(muffled)
[16:05:55.572]                   }
[16:05:55.572]                   muffleCondition(cond)
[16:05:55.572]                 })
[16:05:55.572]             }))
[16:05:55.572]             future::FutureResult(value = ...future.value$value, 
[16:05:55.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.572]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.572]                     ...future.globalenv.names))
[16:05:55.572]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.572]         }, condition = base::local({
[16:05:55.572]             c <- base::c
[16:05:55.572]             inherits <- base::inherits
[16:05:55.572]             invokeRestart <- base::invokeRestart
[16:05:55.572]             length <- base::length
[16:05:55.572]             list <- base::list
[16:05:55.572]             seq.int <- base::seq.int
[16:05:55.572]             signalCondition <- base::signalCondition
[16:05:55.572]             sys.calls <- base::sys.calls
[16:05:55.572]             `[[` <- base::`[[`
[16:05:55.572]             `+` <- base::`+`
[16:05:55.572]             `<<-` <- base::`<<-`
[16:05:55.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.572]                   3L)]
[16:05:55.572]             }
[16:05:55.572]             function(cond) {
[16:05:55.572]                 is_error <- inherits(cond, "error")
[16:05:55.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.572]                   NULL)
[16:05:55.572]                 if (is_error) {
[16:05:55.572]                   sessionInformation <- function() {
[16:05:55.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.572]                       search = base::search(), system = base::Sys.info())
[16:05:55.572]                   }
[16:05:55.572]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.572]                     cond$call), session = sessionInformation(), 
[16:05:55.572]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.572]                   signalCondition(cond)
[16:05:55.572]                 }
[16:05:55.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.572]                 "immediateCondition"))) {
[16:05:55.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.572]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.572]                   if (TRUE && !signal) {
[16:05:55.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.572]                     {
[16:05:55.572]                       inherits <- base::inherits
[16:05:55.572]                       invokeRestart <- base::invokeRestart
[16:05:55.572]                       is.null <- base::is.null
[16:05:55.572]                       muffled <- FALSE
[16:05:55.572]                       if (inherits(cond, "message")) {
[16:05:55.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.572]                         if (muffled) 
[16:05:55.572]                           invokeRestart("muffleMessage")
[16:05:55.572]                       }
[16:05:55.572]                       else if (inherits(cond, "warning")) {
[16:05:55.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.572]                         if (muffled) 
[16:05:55.572]                           invokeRestart("muffleWarning")
[16:05:55.572]                       }
[16:05:55.572]                       else if (inherits(cond, "condition")) {
[16:05:55.572]                         if (!is.null(pattern)) {
[16:05:55.572]                           computeRestarts <- base::computeRestarts
[16:05:55.572]                           grepl <- base::grepl
[16:05:55.572]                           restarts <- computeRestarts(cond)
[16:05:55.572]                           for (restart in restarts) {
[16:05:55.572]                             name <- restart$name
[16:05:55.572]                             if (is.null(name)) 
[16:05:55.572]                               next
[16:05:55.572]                             if (!grepl(pattern, name)) 
[16:05:55.572]                               next
[16:05:55.572]                             invokeRestart(restart)
[16:05:55.572]                             muffled <- TRUE
[16:05:55.572]                             break
[16:05:55.572]                           }
[16:05:55.572]                         }
[16:05:55.572]                       }
[16:05:55.572]                       invisible(muffled)
[16:05:55.572]                     }
[16:05:55.572]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.572]                   }
[16:05:55.572]                 }
[16:05:55.572]                 else {
[16:05:55.572]                   if (TRUE) {
[16:05:55.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.572]                     {
[16:05:55.572]                       inherits <- base::inherits
[16:05:55.572]                       invokeRestart <- base::invokeRestart
[16:05:55.572]                       is.null <- base::is.null
[16:05:55.572]                       muffled <- FALSE
[16:05:55.572]                       if (inherits(cond, "message")) {
[16:05:55.572]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.572]                         if (muffled) 
[16:05:55.572]                           invokeRestart("muffleMessage")
[16:05:55.572]                       }
[16:05:55.572]                       else if (inherits(cond, "warning")) {
[16:05:55.572]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.572]                         if (muffled) 
[16:05:55.572]                           invokeRestart("muffleWarning")
[16:05:55.572]                       }
[16:05:55.572]                       else if (inherits(cond, "condition")) {
[16:05:55.572]                         if (!is.null(pattern)) {
[16:05:55.572]                           computeRestarts <- base::computeRestarts
[16:05:55.572]                           grepl <- base::grepl
[16:05:55.572]                           restarts <- computeRestarts(cond)
[16:05:55.572]                           for (restart in restarts) {
[16:05:55.572]                             name <- restart$name
[16:05:55.572]                             if (is.null(name)) 
[16:05:55.572]                               next
[16:05:55.572]                             if (!grepl(pattern, name)) 
[16:05:55.572]                               next
[16:05:55.572]                             invokeRestart(restart)
[16:05:55.572]                             muffled <- TRUE
[16:05:55.572]                             break
[16:05:55.572]                           }
[16:05:55.572]                         }
[16:05:55.572]                       }
[16:05:55.572]                       invisible(muffled)
[16:05:55.572]                     }
[16:05:55.572]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.572]                   }
[16:05:55.572]                 }
[16:05:55.572]             }
[16:05:55.572]         }))
[16:05:55.572]     }, error = function(ex) {
[16:05:55.572]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.572]                 ...future.rng), started = ...future.startTime, 
[16:05:55.572]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.572]             version = "1.8"), class = "FutureResult")
[16:05:55.572]     }, finally = {
[16:05:55.572]         if (!identical(...future.workdir, getwd())) 
[16:05:55.572]             setwd(...future.workdir)
[16:05:55.572]         {
[16:05:55.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.572]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.572]             }
[16:05:55.572]             base::options(...future.oldOptions)
[16:05:55.572]             if (.Platform$OS.type == "windows") {
[16:05:55.572]                 old_names <- names(...future.oldEnvVars)
[16:05:55.572]                 envs <- base::Sys.getenv()
[16:05:55.572]                 names <- names(envs)
[16:05:55.572]                 common <- intersect(names, old_names)
[16:05:55.572]                 added <- setdiff(names, old_names)
[16:05:55.572]                 removed <- setdiff(old_names, names)
[16:05:55.572]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.572]                   envs[common]]
[16:05:55.572]                 NAMES <- toupper(changed)
[16:05:55.572]                 args <- list()
[16:05:55.572]                 for (kk in seq_along(NAMES)) {
[16:05:55.572]                   name <- changed[[kk]]
[16:05:55.572]                   NAME <- NAMES[[kk]]
[16:05:55.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.572]                     next
[16:05:55.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.572]                 }
[16:05:55.572]                 NAMES <- toupper(added)
[16:05:55.572]                 for (kk in seq_along(NAMES)) {
[16:05:55.572]                   name <- added[[kk]]
[16:05:55.572]                   NAME <- NAMES[[kk]]
[16:05:55.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.572]                     next
[16:05:55.572]                   args[[name]] <- ""
[16:05:55.572]                 }
[16:05:55.572]                 NAMES <- toupper(removed)
[16:05:55.572]                 for (kk in seq_along(NAMES)) {
[16:05:55.572]                   name <- removed[[kk]]
[16:05:55.572]                   NAME <- NAMES[[kk]]
[16:05:55.572]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.572]                     next
[16:05:55.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.572]                 }
[16:05:55.572]                 if (length(args) > 0) 
[16:05:55.572]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.572]             }
[16:05:55.572]             else {
[16:05:55.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.572]             }
[16:05:55.572]             {
[16:05:55.572]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.572]                   0L) {
[16:05:55.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.572]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.572]                   base::options(opts)
[16:05:55.572]                 }
[16:05:55.572]                 {
[16:05:55.572]                   {
[16:05:55.572]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.572]                     NULL
[16:05:55.572]                   }
[16:05:55.572]                   options(future.plan = NULL)
[16:05:55.572]                   if (is.na(NA_character_)) 
[16:05:55.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.572]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.572]                     envir = parent.frame()) 
[16:05:55.572]                   {
[16:05:55.572]                     default_workers <- missing(workers)
[16:05:55.572]                     if (is.function(workers)) 
[16:05:55.572]                       workers <- workers()
[16:05:55.572]                     workers <- structure(as.integer(workers), 
[16:05:55.572]                       class = class(workers))
[16:05:55.572]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.572]                       1L)
[16:05:55.572]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.572]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.572]                       if (default_workers) 
[16:05:55.572]                         supportsMulticore(warn = TRUE)
[16:05:55.572]                       return(sequential(..., envir = envir))
[16:05:55.572]                     }
[16:05:55.572]                     oopts <- options(mc.cores = workers)
[16:05:55.572]                     on.exit(options(oopts))
[16:05:55.572]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.572]                       envir = envir)
[16:05:55.572]                     if (!future$lazy) 
[16:05:55.572]                       future <- run(future)
[16:05:55.572]                     invisible(future)
[16:05:55.572]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.572]                 }
[16:05:55.572]             }
[16:05:55.572]         }
[16:05:55.572]     })
[16:05:55.572]     if (TRUE) {
[16:05:55.572]         base::sink(type = "output", split = FALSE)
[16:05:55.572]         if (TRUE) {
[16:05:55.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.572]         }
[16:05:55.572]         else {
[16:05:55.572]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.572]         }
[16:05:55.572]         base::close(...future.stdout)
[16:05:55.572]         ...future.stdout <- NULL
[16:05:55.572]     }
[16:05:55.572]     ...future.result$conditions <- ...future.conditions
[16:05:55.572]     ...future.result$finished <- base::Sys.time()
[16:05:55.572]     ...future.result
[16:05:55.572] }
[16:05:55.575] requestCore(): workers = 2
[16:05:55.575] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:55.586] result() for MulticoreFuture ...
[16:05:55.587] result() for MulticoreFuture ...
[16:05:55.588] result() for MulticoreFuture ... done
[16:05:55.588] result() for MulticoreFuture ... done
[16:05:55.588] result() for MulticoreFuture ...
[16:05:55.588] result() for MulticoreFuture ... done
[16:05:55.591] MulticoreFuture started
[16:05:55.592] - Launch lazy future ... done
[16:05:55.592] run() for ‘MulticoreFuture’ ... done
[16:05:55.592] resolve() on list ...
[16:05:55.592] plan(): Setting new future strategy stack:
[16:05:55.592]  recursive: 0
[16:05:55.593]  length: 3
[16:05:55.593]  elements: ‘a’, ‘b’, ‘’
[16:05:55.593] run() for ‘Future’ ...
[16:05:55.593] List of future strategies:
[16:05:55.593] 1. sequential:
[16:05:55.593]    - args: function (..., envir = parent.frame())
[16:05:55.593]    - tweaked: FALSE
[16:05:55.593]    - call: NULL
[16:05:55.593] - state: ‘created’
[16:05:55.593] plan(): nbrOfWorkers() = 1
[16:05:55.593] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.595] plan(): Setting new future strategy stack:
[16:05:55.595] List of future strategies:
[16:05:55.595] 1. multicore:
[16:05:55.595]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.595]    - tweaked: FALSE
[16:05:55.595]    - call: plan(strategy)
[16:05:55.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.600]   - Field: ‘label’
[16:05:55.600]   - Field: ‘local’
[16:05:55.600]   - Field: ‘owner’
[16:05:55.600]   - Field: ‘envir’
[16:05:55.601]   - Field: ‘workers’
[16:05:55.601]   - Field: ‘packages’
[16:05:55.601] plan(): nbrOfWorkers() = 2
[16:05:55.601]   - Field: ‘gc’
[16:05:55.601]   - Field: ‘job’
[16:05:55.601]   - Field: ‘conditions’
[16:05:55.602]   - Field: ‘expr’
[16:05:55.602]   - Field: ‘uuid’
[16:05:55.602]   - Field: ‘seed’
[16:05:55.602]   - Field: ‘version’
[16:05:55.602]   - Field: ‘result’
[16:05:55.602]   - Field: ‘asynchronous’
[16:05:55.603]   - Field: ‘calls’
[16:05:55.603]   - Field: ‘globals’
[16:05:55.603]   - Field: ‘stdout’
[16:05:55.603]   - Field: ‘earlySignal’
[16:05:55.603]   - Field: ‘lazy’
[16:05:55.603]   - Field: ‘state’
[16:05:55.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.604] - Launch lazy future ...
[16:05:55.604] Packages needed by the future expression (n = 0): <none>
[16:05:55.604] Packages needed by future strategies (n = 0): <none>
[16:05:55.605] {
[16:05:55.605]     {
[16:05:55.605]         {
[16:05:55.605]             ...future.startTime <- base::Sys.time()
[16:05:55.605]             {
[16:05:55.605]                 {
[16:05:55.605]                   {
[16:05:55.605]                     {
[16:05:55.605]                       base::local({
[16:05:55.605]                         has_future <- base::requireNamespace("future", 
[16:05:55.605]                           quietly = TRUE)
[16:05:55.605]                         if (has_future) {
[16:05:55.605]                           ns <- base::getNamespace("future")
[16:05:55.605]                           version <- ns[[".package"]][["version"]]
[16:05:55.605]                           if (is.null(version)) 
[16:05:55.605]                             version <- utils::packageVersion("future")
[16:05:55.605]                         }
[16:05:55.605]                         else {
[16:05:55.605]                           version <- NULL
[16:05:55.605]                         }
[16:05:55.605]                         if (!has_future || version < "1.8.0") {
[16:05:55.605]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.605]                             "", base::R.version$version.string), 
[16:05:55.605]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.605]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.605]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.605]                               "release", "version")], collapse = " "), 
[16:05:55.605]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.605]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.605]                             info)
[16:05:55.605]                           info <- base::paste(info, collapse = "; ")
[16:05:55.605]                           if (!has_future) {
[16:05:55.605]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.605]                               info)
[16:05:55.605]                           }
[16:05:55.605]                           else {
[16:05:55.605]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.605]                               info, version)
[16:05:55.605]                           }
[16:05:55.605]                           base::stop(msg)
[16:05:55.605]                         }
[16:05:55.605]                       })
[16:05:55.605]                     }
[16:05:55.605]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.605]                     base::options(mc.cores = 1L)
[16:05:55.605]                   }
[16:05:55.605]                   options(future.plan = NULL)
[16:05:55.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.605]                 }
[16:05:55.605]                 ...future.workdir <- getwd()
[16:05:55.605]             }
[16:05:55.605]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.605]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.605]         }
[16:05:55.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.605]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.605]             base::names(...future.oldOptions))
[16:05:55.605]     }
[16:05:55.605]     if (FALSE) {
[16:05:55.605]     }
[16:05:55.605]     else {
[16:05:55.605]         if (TRUE) {
[16:05:55.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.605]                 open = "w")
[16:05:55.605]         }
[16:05:55.605]         else {
[16:05:55.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.605]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.605]         }
[16:05:55.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.605]             base::sink(type = "output", split = FALSE)
[16:05:55.605]             base::close(...future.stdout)
[16:05:55.605]         }, add = TRUE)
[16:05:55.605]     }
[16:05:55.605]     ...future.frame <- base::sys.nframe()
[16:05:55.605]     ...future.conditions <- base::list()
[16:05:55.605]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.605]     if (FALSE) {
[16:05:55.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.605]     }
[16:05:55.605]     ...future.result <- base::tryCatch({
[16:05:55.605]         base::withCallingHandlers({
[16:05:55.605]             ...future.value <- base::withVisible(base::local({
[16:05:55.605]                 withCallingHandlers({
[16:05:55.605]                   1
[16:05:55.605]                 }, immediateCondition = function(cond) {
[16:05:55.605]                   save_rds <- function (object, pathname, ...) 
[16:05:55.605]                   {
[16:05:55.605]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.605]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.605]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.605]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.605]                         fi_tmp[["mtime"]])
[16:05:55.605]                     }
[16:05:55.605]                     tryCatch({
[16:05:55.605]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.605]                     }, error = function(ex) {
[16:05:55.605]                       msg <- conditionMessage(ex)
[16:05:55.605]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.605]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.605]                         fi_tmp[["mtime"]], msg)
[16:05:55.605]                       ex$message <- msg
[16:05:55.605]                       stop(ex)
[16:05:55.605]                     })
[16:05:55.605]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.605]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.605]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.605]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.605]                       fi <- file.info(pathname)
[16:05:55.605]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.605]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.605]                         fi[["size"]], fi[["mtime"]])
[16:05:55.605]                       stop(msg)
[16:05:55.605]                     }
[16:05:55.605]                     invisible(pathname)
[16:05:55.605]                   }
[16:05:55.605]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.605]                     rootPath = tempdir()) 
[16:05:55.605]                   {
[16:05:55.605]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.605]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.605]                       tmpdir = path, fileext = ".rds")
[16:05:55.605]                     save_rds(obj, file)
[16:05:55.605]                   }
[16:05:55.605]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.605]                   {
[16:05:55.605]                     inherits <- base::inherits
[16:05:55.605]                     invokeRestart <- base::invokeRestart
[16:05:55.605]                     is.null <- base::is.null
[16:05:55.605]                     muffled <- FALSE
[16:05:55.605]                     if (inherits(cond, "message")) {
[16:05:55.605]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.605]                       if (muffled) 
[16:05:55.605]                         invokeRestart("muffleMessage")
[16:05:55.605]                     }
[16:05:55.605]                     else if (inherits(cond, "warning")) {
[16:05:55.605]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.605]                       if (muffled) 
[16:05:55.605]                         invokeRestart("muffleWarning")
[16:05:55.605]                     }
[16:05:55.605]                     else if (inherits(cond, "condition")) {
[16:05:55.605]                       if (!is.null(pattern)) {
[16:05:55.605]                         computeRestarts <- base::computeRestarts
[16:05:55.605]                         grepl <- base::grepl
[16:05:55.605]                         restarts <- computeRestarts(cond)
[16:05:55.605]                         for (restart in restarts) {
[16:05:55.605]                           name <- restart$name
[16:05:55.605]                           if (is.null(name)) 
[16:05:55.605]                             next
[16:05:55.605]                           if (!grepl(pattern, name)) 
[16:05:55.605]                             next
[16:05:55.605]                           invokeRestart(restart)
[16:05:55.605]                           muffled <- TRUE
[16:05:55.605]                           break
[16:05:55.605]                         }
[16:05:55.605]                       }
[16:05:55.605]                     }
[16:05:55.605]                     invisible(muffled)
[16:05:55.605]                   }
[16:05:55.605]                   muffleCondition(cond)
[16:05:55.605]                 })
[16:05:55.605]             }))
[16:05:55.605]             future::FutureResult(value = ...future.value$value, 
[16:05:55.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.605]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.605]                     ...future.globalenv.names))
[16:05:55.605]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.605]         }, condition = base::local({
[16:05:55.605]             c <- base::c
[16:05:55.605]             inherits <- base::inherits
[16:05:55.605]             invokeRestart <- base::invokeRestart
[16:05:55.605]             length <- base::length
[16:05:55.605]             list <- base::list
[16:05:55.605]             seq.int <- base::seq.int
[16:05:55.605]             signalCondition <- base::signalCondition
[16:05:55.605]             sys.calls <- base::sys.calls
[16:05:55.605]             `[[` <- base::`[[`
[16:05:55.605]             `+` <- base::`+`
[16:05:55.605]             `<<-` <- base::`<<-`
[16:05:55.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.605]                   3L)]
[16:05:55.605]             }
[16:05:55.605]             function(cond) {
[16:05:55.605]                 is_error <- inherits(cond, "error")
[16:05:55.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.605]                   NULL)
[16:05:55.605]                 if (is_error) {
[16:05:55.605]                   sessionInformation <- function() {
[16:05:55.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.605]                       search = base::search(), system = base::Sys.info())
[16:05:55.605]                   }
[16:05:55.605]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.605]                     cond$call), session = sessionInformation(), 
[16:05:55.605]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.605]                   signalCondition(cond)
[16:05:55.605]                 }
[16:05:55.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.605]                 "immediateCondition"))) {
[16:05:55.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.605]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.605]                   if (TRUE && !signal) {
[16:05:55.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.605]                     {
[16:05:55.605]                       inherits <- base::inherits
[16:05:55.605]                       invokeRestart <- base::invokeRestart
[16:05:55.605]                       is.null <- base::is.null
[16:05:55.605]                       muffled <- FALSE
[16:05:55.605]                       if (inherits(cond, "message")) {
[16:05:55.605]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.605]                         if (muffled) 
[16:05:55.605]                           invokeRestart("muffleMessage")
[16:05:55.605]                       }
[16:05:55.605]                       else if (inherits(cond, "warning")) {
[16:05:55.605]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.605]                         if (muffled) 
[16:05:55.605]                           invokeRestart("muffleWarning")
[16:05:55.605]                       }
[16:05:55.605]                       else if (inherits(cond, "condition")) {
[16:05:55.605]                         if (!is.null(pattern)) {
[16:05:55.605]                           computeRestarts <- base::computeRestarts
[16:05:55.605]                           grepl <- base::grepl
[16:05:55.605]                           restarts <- computeRestarts(cond)
[16:05:55.605]                           for (restart in restarts) {
[16:05:55.605]                             name <- restart$name
[16:05:55.605]                             if (is.null(name)) 
[16:05:55.605]                               next
[16:05:55.605]                             if (!grepl(pattern, name)) 
[16:05:55.605]                               next
[16:05:55.605]                             invokeRestart(restart)
[16:05:55.605]                             muffled <- TRUE
[16:05:55.605]                             break
[16:05:55.605]                           }
[16:05:55.605]                         }
[16:05:55.605]                       }
[16:05:55.605]                       invisible(muffled)
[16:05:55.605]                     }
[16:05:55.605]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.605]                   }
[16:05:55.605]                 }
[16:05:55.605]                 else {
[16:05:55.605]                   if (TRUE) {
[16:05:55.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.605]                     {
[16:05:55.605]                       inherits <- base::inherits
[16:05:55.605]                       invokeRestart <- base::invokeRestart
[16:05:55.605]                       is.null <- base::is.null
[16:05:55.605]                       muffled <- FALSE
[16:05:55.605]                       if (inherits(cond, "message")) {
[16:05:55.605]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.605]                         if (muffled) 
[16:05:55.605]                           invokeRestart("muffleMessage")
[16:05:55.605]                       }
[16:05:55.605]                       else if (inherits(cond, "warning")) {
[16:05:55.605]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.605]                         if (muffled) 
[16:05:55.605]                           invokeRestart("muffleWarning")
[16:05:55.605]                       }
[16:05:55.605]                       else if (inherits(cond, "condition")) {
[16:05:55.605]                         if (!is.null(pattern)) {
[16:05:55.605]                           computeRestarts <- base::computeRestarts
[16:05:55.605]                           grepl <- base::grepl
[16:05:55.605]                           restarts <- computeRestarts(cond)
[16:05:55.605]                           for (restart in restarts) {
[16:05:55.605]                             name <- restart$name
[16:05:55.605]                             if (is.null(name)) 
[16:05:55.605]                               next
[16:05:55.605]                             if (!grepl(pattern, name)) 
[16:05:55.605]                               next
[16:05:55.605]                             invokeRestart(restart)
[16:05:55.605]                             muffled <- TRUE
[16:05:55.605]                             break
[16:05:55.605]                           }
[16:05:55.605]                         }
[16:05:55.605]                       }
[16:05:55.605]                       invisible(muffled)
[16:05:55.605]                     }
[16:05:55.605]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.605]                   }
[16:05:55.605]                 }
[16:05:55.605]             }
[16:05:55.605]         }))
[16:05:55.605]     }, error = function(ex) {
[16:05:55.605]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.605]                 ...future.rng), started = ...future.startTime, 
[16:05:55.605]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.605]             version = "1.8"), class = "FutureResult")
[16:05:55.605]     }, finally = {
[16:05:55.605]         if (!identical(...future.workdir, getwd())) 
[16:05:55.605]             setwd(...future.workdir)
[16:05:55.605]         {
[16:05:55.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.605]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.605]             }
[16:05:55.605]             base::options(...future.oldOptions)
[16:05:55.605]             if (.Platform$OS.type == "windows") {
[16:05:55.605]                 old_names <- names(...future.oldEnvVars)
[16:05:55.605]                 envs <- base::Sys.getenv()
[16:05:55.605]                 names <- names(envs)
[16:05:55.605]                 common <- intersect(names, old_names)
[16:05:55.605]                 added <- setdiff(names, old_names)
[16:05:55.605]                 removed <- setdiff(old_names, names)
[16:05:55.605]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.605]                   envs[common]]
[16:05:55.605]                 NAMES <- toupper(changed)
[16:05:55.605]                 args <- list()
[16:05:55.605]                 for (kk in seq_along(NAMES)) {
[16:05:55.605]                   name <- changed[[kk]]
[16:05:55.605]                   NAME <- NAMES[[kk]]
[16:05:55.605]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.605]                     next
[16:05:55.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.605]                 }
[16:05:55.605]                 NAMES <- toupper(added)
[16:05:55.605]                 for (kk in seq_along(NAMES)) {
[16:05:55.605]                   name <- added[[kk]]
[16:05:55.605]                   NAME <- NAMES[[kk]]
[16:05:55.605]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.605]                     next
[16:05:55.605]                   args[[name]] <- ""
[16:05:55.605]                 }
[16:05:55.605]                 NAMES <- toupper(removed)
[16:05:55.605]                 for (kk in seq_along(NAMES)) {
[16:05:55.605]                   name <- removed[[kk]]
[16:05:55.605]                   NAME <- NAMES[[kk]]
[16:05:55.605]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.605]                     next
[16:05:55.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.605]                 }
[16:05:55.605]                 if (length(args) > 0) 
[16:05:55.605]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.605]             }
[16:05:55.605]             else {
[16:05:55.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.605]             }
[16:05:55.605]             {
[16:05:55.605]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.605]                   0L) {
[16:05:55.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.605]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.605]                   base::options(opts)
[16:05:55.605]                 }
[16:05:55.605]                 {
[16:05:55.605]                   {
[16:05:55.605]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.605]                     NULL
[16:05:55.605]                   }
[16:05:55.605]                   options(future.plan = NULL)
[16:05:55.605]                   if (is.na(NA_character_)) 
[16:05:55.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.605]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.605]                     envir = parent.frame()) 
[16:05:55.605]                   {
[16:05:55.605]                     default_workers <- missing(workers)
[16:05:55.605]                     if (is.function(workers)) 
[16:05:55.605]                       workers <- workers()
[16:05:55.605]                     workers <- structure(as.integer(workers), 
[16:05:55.605]                       class = class(workers))
[16:05:55.605]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.605]                       1L)
[16:05:55.605]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.605]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.605]                       if (default_workers) 
[16:05:55.605]                         supportsMulticore(warn = TRUE)
[16:05:55.605]                       return(sequential(..., envir = envir))
[16:05:55.605]                     }
[16:05:55.605]                     oopts <- options(mc.cores = workers)
[16:05:55.605]                     on.exit(options(oopts))
[16:05:55.605]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.605]                       envir = envir)
[16:05:55.605]                     if (!future$lazy) 
[16:05:55.605]                       future <- run(future)
[16:05:55.605]                     invisible(future)
[16:05:55.605]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.605]                 }
[16:05:55.605]             }
[16:05:55.605]         }
[16:05:55.605]     })
[16:05:55.605]     if (TRUE) {
[16:05:55.605]         base::sink(type = "output", split = FALSE)
[16:05:55.605]         if (TRUE) {
[16:05:55.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.605]         }
[16:05:55.605]         else {
[16:05:55.605]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.605]         }
[16:05:55.605]         base::close(...future.stdout)
[16:05:55.605]         ...future.stdout <- NULL
[16:05:55.605]     }
[16:05:55.605]     ...future.result$conditions <- ...future.conditions
[16:05:55.605]     ...future.result$finished <- base::Sys.time()
[16:05:55.605]     ...future.result
[16:05:55.605] }
[16:05:55.609] requestCore(): workers = 2
[16:05:55.609] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:55.632] result() for MulticoreFuture ...
[16:05:55.633] result() for MulticoreFuture ...
[16:05:55.633] result() for MulticoreFuture ... done
[16:05:55.633] result() for MulticoreFuture ... done
[16:05:55.633] result() for MulticoreFuture ...
[16:05:55.633] result() for MulticoreFuture ... done
[16:05:55.636] MulticoreFuture started
[16:05:55.636] - Launch lazy future ... done
[16:05:55.636] run() for ‘MulticoreFuture’ ... done
[16:05:55.637] plan(): Setting new future strategy stack:
[16:05:55.637] List of future strategies:
[16:05:55.637] 1. sequential:
[16:05:55.637]    - args: function (..., envir = parent.frame())
[16:05:55.637]    - tweaked: FALSE
[16:05:55.637]    - call: NULL
[16:05:55.638] plan(): nbrOfWorkers() = 1
[16:05:55.640] plan(): Setting new future strategy stack:
[16:05:55.640] List of future strategies:
[16:05:55.640] 1. multicore:
[16:05:55.640]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.640]    - tweaked: FALSE
[16:05:55.640]    - call: plan(strategy)
[16:05:55.647] Future #2
[16:05:55.648]  length: 2 (resolved future 2)
[16:05:55.648]  length: 1 (resolved future 3)
[16:05:55.652] plan(): nbrOfWorkers() = 2
[16:05:55.658] Future #1
[16:05:55.659]  length: 0 (resolved future 1)
[16:05:55.659] resolve() on list ... DONE
[16:05:55.659] getGlobalsAndPackages() ...
[16:05:55.663] Searching for globals...
[16:05:55.664] 
[16:05:55.664] Searching for globals ... DONE
[16:05:55.664] - globals: [0] <none>
[16:05:55.665] getGlobalsAndPackages() ... DONE
[16:05:55.665] getGlobalsAndPackages() ...
[16:05:55.666] Searching for globals...
[16:05:55.666] 
[16:05:55.666] Searching for globals ... DONE
[16:05:55.667] - globals: [0] <none>
[16:05:55.667] getGlobalsAndPackages() ... DONE
[16:05:55.667] resolve() on list ...
[16:05:55.668]  recursive: 0
[16:05:55.668]  length: 3
[16:05:55.668]  elements: ‘a’, ‘b’, ‘’
[16:05:55.668] run() for ‘Future’ ...
[16:05:55.668] - state: ‘created’
[16:05:55.669] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.673] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.673] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.673]   - Field: ‘label’
[16:05:55.673]   - Field: ‘local’
[16:05:55.674]   - Field: ‘owner’
[16:05:55.674]   - Field: ‘envir’
[16:05:55.674]   - Field: ‘workers’
[16:05:55.674]   - Field: ‘packages’
[16:05:55.675]   - Field: ‘gc’
[16:05:55.675]   - Field: ‘job’
[16:05:55.675]   - Field: ‘conditions’
[16:05:55.675]   - Field: ‘expr’
[16:05:55.675]   - Field: ‘uuid’
[16:05:55.675]   - Field: ‘seed’
[16:05:55.676]   - Field: ‘version’
[16:05:55.676]   - Field: ‘result’
[16:05:55.676]   - Field: ‘asynchronous’
[16:05:55.676]   - Field: ‘calls’
[16:05:55.676]   - Field: ‘globals’
[16:05:55.676]   - Field: ‘stdout’
[16:05:55.676]   - Field: ‘earlySignal’
[16:05:55.676]   - Field: ‘lazy’
[16:05:55.677]   - Field: ‘state’
[16:05:55.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.677] - Launch lazy future ...
[16:05:55.677] Packages needed by the future expression (n = 0): <none>
[16:05:55.677] Packages needed by future strategies (n = 0): <none>
[16:05:55.678] {
[16:05:55.678]     {
[16:05:55.678]         {
[16:05:55.678]             ...future.startTime <- base::Sys.time()
[16:05:55.678]             {
[16:05:55.678]                 {
[16:05:55.678]                   {
[16:05:55.678]                     {
[16:05:55.678]                       base::local({
[16:05:55.678]                         has_future <- base::requireNamespace("future", 
[16:05:55.678]                           quietly = TRUE)
[16:05:55.678]                         if (has_future) {
[16:05:55.678]                           ns <- base::getNamespace("future")
[16:05:55.678]                           version <- ns[[".package"]][["version"]]
[16:05:55.678]                           if (is.null(version)) 
[16:05:55.678]                             version <- utils::packageVersion("future")
[16:05:55.678]                         }
[16:05:55.678]                         else {
[16:05:55.678]                           version <- NULL
[16:05:55.678]                         }
[16:05:55.678]                         if (!has_future || version < "1.8.0") {
[16:05:55.678]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.678]                             "", base::R.version$version.string), 
[16:05:55.678]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.678]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.678]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.678]                               "release", "version")], collapse = " "), 
[16:05:55.678]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.678]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.678]                             info)
[16:05:55.678]                           info <- base::paste(info, collapse = "; ")
[16:05:55.678]                           if (!has_future) {
[16:05:55.678]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.678]                               info)
[16:05:55.678]                           }
[16:05:55.678]                           else {
[16:05:55.678]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.678]                               info, version)
[16:05:55.678]                           }
[16:05:55.678]                           base::stop(msg)
[16:05:55.678]                         }
[16:05:55.678]                       })
[16:05:55.678]                     }
[16:05:55.678]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.678]                     base::options(mc.cores = 1L)
[16:05:55.678]                   }
[16:05:55.678]                   options(future.plan = NULL)
[16:05:55.678]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.678]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.678]                 }
[16:05:55.678]                 ...future.workdir <- getwd()
[16:05:55.678]             }
[16:05:55.678]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.678]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.678]         }
[16:05:55.678]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.678]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.678]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.678]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.678]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.678]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.678]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.678]             base::names(...future.oldOptions))
[16:05:55.678]     }
[16:05:55.678]     if (FALSE) {
[16:05:55.678]     }
[16:05:55.678]     else {
[16:05:55.678]         if (TRUE) {
[16:05:55.678]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.678]                 open = "w")
[16:05:55.678]         }
[16:05:55.678]         else {
[16:05:55.678]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.678]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.678]         }
[16:05:55.678]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.678]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.678]             base::sink(type = "output", split = FALSE)
[16:05:55.678]             base::close(...future.stdout)
[16:05:55.678]         }, add = TRUE)
[16:05:55.678]     }
[16:05:55.678]     ...future.frame <- base::sys.nframe()
[16:05:55.678]     ...future.conditions <- base::list()
[16:05:55.678]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.678]     if (FALSE) {
[16:05:55.678]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.678]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.678]     }
[16:05:55.678]     ...future.result <- base::tryCatch({
[16:05:55.678]         base::withCallingHandlers({
[16:05:55.678]             ...future.value <- base::withVisible(base::local({
[16:05:55.678]                 withCallingHandlers({
[16:05:55.678]                   1
[16:05:55.678]                 }, immediateCondition = function(cond) {
[16:05:55.678]                   save_rds <- function (object, pathname, ...) 
[16:05:55.678]                   {
[16:05:55.678]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.678]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.678]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.678]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.678]                         fi_tmp[["mtime"]])
[16:05:55.678]                     }
[16:05:55.678]                     tryCatch({
[16:05:55.678]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.678]                     }, error = function(ex) {
[16:05:55.678]                       msg <- conditionMessage(ex)
[16:05:55.678]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.678]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.678]                         fi_tmp[["mtime"]], msg)
[16:05:55.678]                       ex$message <- msg
[16:05:55.678]                       stop(ex)
[16:05:55.678]                     })
[16:05:55.678]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.678]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.678]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.678]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.678]                       fi <- file.info(pathname)
[16:05:55.678]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.678]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.678]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.678]                         fi[["size"]], fi[["mtime"]])
[16:05:55.678]                       stop(msg)
[16:05:55.678]                     }
[16:05:55.678]                     invisible(pathname)
[16:05:55.678]                   }
[16:05:55.678]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.678]                     rootPath = tempdir()) 
[16:05:55.678]                   {
[16:05:55.678]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.678]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.678]                       tmpdir = path, fileext = ".rds")
[16:05:55.678]                     save_rds(obj, file)
[16:05:55.678]                   }
[16:05:55.678]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.678]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.678]                   {
[16:05:55.678]                     inherits <- base::inherits
[16:05:55.678]                     invokeRestart <- base::invokeRestart
[16:05:55.678]                     is.null <- base::is.null
[16:05:55.678]                     muffled <- FALSE
[16:05:55.678]                     if (inherits(cond, "message")) {
[16:05:55.678]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.678]                       if (muffled) 
[16:05:55.678]                         invokeRestart("muffleMessage")
[16:05:55.678]                     }
[16:05:55.678]                     else if (inherits(cond, "warning")) {
[16:05:55.678]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.678]                       if (muffled) 
[16:05:55.678]                         invokeRestart("muffleWarning")
[16:05:55.678]                     }
[16:05:55.678]                     else if (inherits(cond, "condition")) {
[16:05:55.678]                       if (!is.null(pattern)) {
[16:05:55.678]                         computeRestarts <- base::computeRestarts
[16:05:55.678]                         grepl <- base::grepl
[16:05:55.678]                         restarts <- computeRestarts(cond)
[16:05:55.678]                         for (restart in restarts) {
[16:05:55.678]                           name <- restart$name
[16:05:55.678]                           if (is.null(name)) 
[16:05:55.678]                             next
[16:05:55.678]                           if (!grepl(pattern, name)) 
[16:05:55.678]                             next
[16:05:55.678]                           invokeRestart(restart)
[16:05:55.678]                           muffled <- TRUE
[16:05:55.678]                           break
[16:05:55.678]                         }
[16:05:55.678]                       }
[16:05:55.678]                     }
[16:05:55.678]                     invisible(muffled)
[16:05:55.678]                   }
[16:05:55.678]                   muffleCondition(cond)
[16:05:55.678]                 })
[16:05:55.678]             }))
[16:05:55.678]             future::FutureResult(value = ...future.value$value, 
[16:05:55.678]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.678]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.678]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.678]                     ...future.globalenv.names))
[16:05:55.678]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.678]         }, condition = base::local({
[16:05:55.678]             c <- base::c
[16:05:55.678]             inherits <- base::inherits
[16:05:55.678]             invokeRestart <- base::invokeRestart
[16:05:55.678]             length <- base::length
[16:05:55.678]             list <- base::list
[16:05:55.678]             seq.int <- base::seq.int
[16:05:55.678]             signalCondition <- base::signalCondition
[16:05:55.678]             sys.calls <- base::sys.calls
[16:05:55.678]             `[[` <- base::`[[`
[16:05:55.678]             `+` <- base::`+`
[16:05:55.678]             `<<-` <- base::`<<-`
[16:05:55.678]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.678]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.678]                   3L)]
[16:05:55.678]             }
[16:05:55.678]             function(cond) {
[16:05:55.678]                 is_error <- inherits(cond, "error")
[16:05:55.678]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.678]                   NULL)
[16:05:55.678]                 if (is_error) {
[16:05:55.678]                   sessionInformation <- function() {
[16:05:55.678]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.678]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.678]                       search = base::search(), system = base::Sys.info())
[16:05:55.678]                   }
[16:05:55.678]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.678]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.678]                     cond$call), session = sessionInformation(), 
[16:05:55.678]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.678]                   signalCondition(cond)
[16:05:55.678]                 }
[16:05:55.678]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.678]                 "immediateCondition"))) {
[16:05:55.678]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.678]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.678]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.678]                   if (TRUE && !signal) {
[16:05:55.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.678]                     {
[16:05:55.678]                       inherits <- base::inherits
[16:05:55.678]                       invokeRestart <- base::invokeRestart
[16:05:55.678]                       is.null <- base::is.null
[16:05:55.678]                       muffled <- FALSE
[16:05:55.678]                       if (inherits(cond, "message")) {
[16:05:55.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.678]                         if (muffled) 
[16:05:55.678]                           invokeRestart("muffleMessage")
[16:05:55.678]                       }
[16:05:55.678]                       else if (inherits(cond, "warning")) {
[16:05:55.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.678]                         if (muffled) 
[16:05:55.678]                           invokeRestart("muffleWarning")
[16:05:55.678]                       }
[16:05:55.678]                       else if (inherits(cond, "condition")) {
[16:05:55.678]                         if (!is.null(pattern)) {
[16:05:55.678]                           computeRestarts <- base::computeRestarts
[16:05:55.678]                           grepl <- base::grepl
[16:05:55.678]                           restarts <- computeRestarts(cond)
[16:05:55.678]                           for (restart in restarts) {
[16:05:55.678]                             name <- restart$name
[16:05:55.678]                             if (is.null(name)) 
[16:05:55.678]                               next
[16:05:55.678]                             if (!grepl(pattern, name)) 
[16:05:55.678]                               next
[16:05:55.678]                             invokeRestart(restart)
[16:05:55.678]                             muffled <- TRUE
[16:05:55.678]                             break
[16:05:55.678]                           }
[16:05:55.678]                         }
[16:05:55.678]                       }
[16:05:55.678]                       invisible(muffled)
[16:05:55.678]                     }
[16:05:55.678]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.678]                   }
[16:05:55.678]                 }
[16:05:55.678]                 else {
[16:05:55.678]                   if (TRUE) {
[16:05:55.678]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.678]                     {
[16:05:55.678]                       inherits <- base::inherits
[16:05:55.678]                       invokeRestart <- base::invokeRestart
[16:05:55.678]                       is.null <- base::is.null
[16:05:55.678]                       muffled <- FALSE
[16:05:55.678]                       if (inherits(cond, "message")) {
[16:05:55.678]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.678]                         if (muffled) 
[16:05:55.678]                           invokeRestart("muffleMessage")
[16:05:55.678]                       }
[16:05:55.678]                       else if (inherits(cond, "warning")) {
[16:05:55.678]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.678]                         if (muffled) 
[16:05:55.678]                           invokeRestart("muffleWarning")
[16:05:55.678]                       }
[16:05:55.678]                       else if (inherits(cond, "condition")) {
[16:05:55.678]                         if (!is.null(pattern)) {
[16:05:55.678]                           computeRestarts <- base::computeRestarts
[16:05:55.678]                           grepl <- base::grepl
[16:05:55.678]                           restarts <- computeRestarts(cond)
[16:05:55.678]                           for (restart in restarts) {
[16:05:55.678]                             name <- restart$name
[16:05:55.678]                             if (is.null(name)) 
[16:05:55.678]                               next
[16:05:55.678]                             if (!grepl(pattern, name)) 
[16:05:55.678]                               next
[16:05:55.678]                             invokeRestart(restart)
[16:05:55.678]                             muffled <- TRUE
[16:05:55.678]                             break
[16:05:55.678]                           }
[16:05:55.678]                         }
[16:05:55.678]                       }
[16:05:55.678]                       invisible(muffled)
[16:05:55.678]                     }
[16:05:55.678]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.678]                   }
[16:05:55.678]                 }
[16:05:55.678]             }
[16:05:55.678]         }))
[16:05:55.678]     }, error = function(ex) {
[16:05:55.678]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.678]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.678]                 ...future.rng), started = ...future.startTime, 
[16:05:55.678]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.678]             version = "1.8"), class = "FutureResult")
[16:05:55.678]     }, finally = {
[16:05:55.678]         if (!identical(...future.workdir, getwd())) 
[16:05:55.678]             setwd(...future.workdir)
[16:05:55.678]         {
[16:05:55.678]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.678]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.678]             }
[16:05:55.678]             base::options(...future.oldOptions)
[16:05:55.678]             if (.Platform$OS.type == "windows") {
[16:05:55.678]                 old_names <- names(...future.oldEnvVars)
[16:05:55.678]                 envs <- base::Sys.getenv()
[16:05:55.678]                 names <- names(envs)
[16:05:55.678]                 common <- intersect(names, old_names)
[16:05:55.678]                 added <- setdiff(names, old_names)
[16:05:55.678]                 removed <- setdiff(old_names, names)
[16:05:55.678]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.678]                   envs[common]]
[16:05:55.678]                 NAMES <- toupper(changed)
[16:05:55.678]                 args <- list()
[16:05:55.678]                 for (kk in seq_along(NAMES)) {
[16:05:55.678]                   name <- changed[[kk]]
[16:05:55.678]                   NAME <- NAMES[[kk]]
[16:05:55.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.678]                     next
[16:05:55.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.678]                 }
[16:05:55.678]                 NAMES <- toupper(added)
[16:05:55.678]                 for (kk in seq_along(NAMES)) {
[16:05:55.678]                   name <- added[[kk]]
[16:05:55.678]                   NAME <- NAMES[[kk]]
[16:05:55.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.678]                     next
[16:05:55.678]                   args[[name]] <- ""
[16:05:55.678]                 }
[16:05:55.678]                 NAMES <- toupper(removed)
[16:05:55.678]                 for (kk in seq_along(NAMES)) {
[16:05:55.678]                   name <- removed[[kk]]
[16:05:55.678]                   NAME <- NAMES[[kk]]
[16:05:55.678]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.678]                     next
[16:05:55.678]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.678]                 }
[16:05:55.678]                 if (length(args) > 0) 
[16:05:55.678]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.678]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.678]             }
[16:05:55.678]             else {
[16:05:55.678]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.678]             }
[16:05:55.678]             {
[16:05:55.678]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.678]                   0L) {
[16:05:55.678]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.678]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.678]                   base::options(opts)
[16:05:55.678]                 }
[16:05:55.678]                 {
[16:05:55.678]                   {
[16:05:55.678]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.678]                     NULL
[16:05:55.678]                   }
[16:05:55.678]                   options(future.plan = NULL)
[16:05:55.678]                   if (is.na(NA_character_)) 
[16:05:55.678]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.678]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.678]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.678]                     envir = parent.frame()) 
[16:05:55.678]                   {
[16:05:55.678]                     default_workers <- missing(workers)
[16:05:55.678]                     if (is.function(workers)) 
[16:05:55.678]                       workers <- workers()
[16:05:55.678]                     workers <- structure(as.integer(workers), 
[16:05:55.678]                       class = class(workers))
[16:05:55.678]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.678]                       1L)
[16:05:55.678]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.678]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.678]                       if (default_workers) 
[16:05:55.678]                         supportsMulticore(warn = TRUE)
[16:05:55.678]                       return(sequential(..., envir = envir))
[16:05:55.678]                     }
[16:05:55.678]                     oopts <- options(mc.cores = workers)
[16:05:55.678]                     on.exit(options(oopts))
[16:05:55.678]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.678]                       envir = envir)
[16:05:55.678]                     if (!future$lazy) 
[16:05:55.678]                       future <- run(future)
[16:05:55.678]                     invisible(future)
[16:05:55.678]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.678]                 }
[16:05:55.678]             }
[16:05:55.678]         }
[16:05:55.678]     })
[16:05:55.678]     if (TRUE) {
[16:05:55.678]         base::sink(type = "output", split = FALSE)
[16:05:55.678]         if (TRUE) {
[16:05:55.678]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.678]         }
[16:05:55.678]         else {
[16:05:55.678]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.678]         }
[16:05:55.678]         base::close(...future.stdout)
[16:05:55.678]         ...future.stdout <- NULL
[16:05:55.678]     }
[16:05:55.678]     ...future.result$conditions <- ...future.conditions
[16:05:55.678]     ...future.result$finished <- base::Sys.time()
[16:05:55.678]     ...future.result
[16:05:55.678] }
[16:05:55.681] requestCore(): workers = 2
[16:05:55.681] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:55.692] result() for MulticoreFuture ...
[16:05:55.692] result() for MulticoreFuture ...
[16:05:55.693] result() for MulticoreFuture ... done
[16:05:55.693] result() for MulticoreFuture ... done
[16:05:55.693] result() for MulticoreFuture ...
[16:05:55.693] result() for MulticoreFuture ... done
[16:05:55.696] MulticoreFuture started
[16:05:55.696] - Launch lazy future ... done
[16:05:55.697] run() for ‘MulticoreFuture’ ... done
[16:05:55.697] plan(): Setting new future strategy stack:
[16:05:55.697] List of future strategies:
[16:05:55.697] 1. sequential:
[16:05:55.697]    - args: function (..., envir = parent.frame())
[16:05:55.697]    - tweaked: FALSE
[16:05:55.697]    - call: NULL
[16:05:55.698] plan(): nbrOfWorkers() = 1
[16:05:55.701] plan(): Setting new future strategy stack:
[16:05:55.701] List of future strategies:
[16:05:55.701] 1. multicore:
[16:05:55.701]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.701]    - tweaked: FALSE
[16:05:55.701]    - call: plan(strategy)
[16:05:55.706] plan(): nbrOfWorkers() = 2
[16:05:55.706] Future #1
[16:05:55.707]  length: 2 (resolved future 1)
[16:05:55.707] run() for ‘Future’ ...
[16:05:55.707] - state: ‘created’
[16:05:55.707] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.712] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.713]   - Field: ‘label’
[16:05:55.713]   - Field: ‘local’
[16:05:55.713]   - Field: ‘owner’
[16:05:55.713]   - Field: ‘envir’
[16:05:55.713]   - Field: ‘workers’
[16:05:55.713]   - Field: ‘packages’
[16:05:55.714]   - Field: ‘gc’
[16:05:55.714]   - Field: ‘job’
[16:05:55.714]   - Field: ‘conditions’
[16:05:55.714]   - Field: ‘expr’
[16:05:55.714]   - Field: ‘uuid’
[16:05:55.714]   - Field: ‘seed’
[16:05:55.714]   - Field: ‘version’
[16:05:55.715]   - Field: ‘result’
[16:05:55.715]   - Field: ‘asynchronous’
[16:05:55.715]   - Field: ‘calls’
[16:05:55.715]   - Field: ‘globals’
[16:05:55.715]   - Field: ‘stdout’
[16:05:55.715]   - Field: ‘earlySignal’
[16:05:55.715]   - Field: ‘lazy’
[16:05:55.716]   - Field: ‘state’
[16:05:55.716] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.716] - Launch lazy future ...
[16:05:55.716] Packages needed by the future expression (n = 0): <none>
[16:05:55.717] Packages needed by future strategies (n = 0): <none>
[16:05:55.717] {
[16:05:55.717]     {
[16:05:55.717]         {
[16:05:55.717]             ...future.startTime <- base::Sys.time()
[16:05:55.717]             {
[16:05:55.717]                 {
[16:05:55.717]                   {
[16:05:55.717]                     {
[16:05:55.717]                       base::local({
[16:05:55.717]                         has_future <- base::requireNamespace("future", 
[16:05:55.717]                           quietly = TRUE)
[16:05:55.717]                         if (has_future) {
[16:05:55.717]                           ns <- base::getNamespace("future")
[16:05:55.717]                           version <- ns[[".package"]][["version"]]
[16:05:55.717]                           if (is.null(version)) 
[16:05:55.717]                             version <- utils::packageVersion("future")
[16:05:55.717]                         }
[16:05:55.717]                         else {
[16:05:55.717]                           version <- NULL
[16:05:55.717]                         }
[16:05:55.717]                         if (!has_future || version < "1.8.0") {
[16:05:55.717]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.717]                             "", base::R.version$version.string), 
[16:05:55.717]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.717]                               "release", "version")], collapse = " "), 
[16:05:55.717]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.717]                             info)
[16:05:55.717]                           info <- base::paste(info, collapse = "; ")
[16:05:55.717]                           if (!has_future) {
[16:05:55.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.717]                               info)
[16:05:55.717]                           }
[16:05:55.717]                           else {
[16:05:55.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.717]                               info, version)
[16:05:55.717]                           }
[16:05:55.717]                           base::stop(msg)
[16:05:55.717]                         }
[16:05:55.717]                       })
[16:05:55.717]                     }
[16:05:55.717]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.717]                     base::options(mc.cores = 1L)
[16:05:55.717]                   }
[16:05:55.717]                   options(future.plan = NULL)
[16:05:55.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.717]                 }
[16:05:55.717]                 ...future.workdir <- getwd()
[16:05:55.717]             }
[16:05:55.717]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.717]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.717]         }
[16:05:55.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.717]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.717]             base::names(...future.oldOptions))
[16:05:55.717]     }
[16:05:55.717]     if (FALSE) {
[16:05:55.717]     }
[16:05:55.717]     else {
[16:05:55.717]         if (TRUE) {
[16:05:55.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.717]                 open = "w")
[16:05:55.717]         }
[16:05:55.717]         else {
[16:05:55.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.717]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.717]         }
[16:05:55.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.717]             base::sink(type = "output", split = FALSE)
[16:05:55.717]             base::close(...future.stdout)
[16:05:55.717]         }, add = TRUE)
[16:05:55.717]     }
[16:05:55.717]     ...future.frame <- base::sys.nframe()
[16:05:55.717]     ...future.conditions <- base::list()
[16:05:55.717]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.717]     if (FALSE) {
[16:05:55.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.717]     }
[16:05:55.717]     ...future.result <- base::tryCatch({
[16:05:55.717]         base::withCallingHandlers({
[16:05:55.717]             ...future.value <- base::withVisible(base::local({
[16:05:55.717]                 withCallingHandlers({
[16:05:55.717]                   2
[16:05:55.717]                 }, immediateCondition = function(cond) {
[16:05:55.717]                   save_rds <- function (object, pathname, ...) 
[16:05:55.717]                   {
[16:05:55.717]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.717]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.717]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.717]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.717]                         fi_tmp[["mtime"]])
[16:05:55.717]                     }
[16:05:55.717]                     tryCatch({
[16:05:55.717]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.717]                     }, error = function(ex) {
[16:05:55.717]                       msg <- conditionMessage(ex)
[16:05:55.717]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.717]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.717]                         fi_tmp[["mtime"]], msg)
[16:05:55.717]                       ex$message <- msg
[16:05:55.717]                       stop(ex)
[16:05:55.717]                     })
[16:05:55.717]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.717]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.717]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.717]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.717]                       fi <- file.info(pathname)
[16:05:55.717]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.717]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.717]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.717]                         fi[["size"]], fi[["mtime"]])
[16:05:55.717]                       stop(msg)
[16:05:55.717]                     }
[16:05:55.717]                     invisible(pathname)
[16:05:55.717]                   }
[16:05:55.717]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.717]                     rootPath = tempdir()) 
[16:05:55.717]                   {
[16:05:55.717]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.717]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.717]                       tmpdir = path, fileext = ".rds")
[16:05:55.717]                     save_rds(obj, file)
[16:05:55.717]                   }
[16:05:55.717]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.717]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.717]                   {
[16:05:55.717]                     inherits <- base::inherits
[16:05:55.717]                     invokeRestart <- base::invokeRestart
[16:05:55.717]                     is.null <- base::is.null
[16:05:55.717]                     muffled <- FALSE
[16:05:55.717]                     if (inherits(cond, "message")) {
[16:05:55.717]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.717]                       if (muffled) 
[16:05:55.717]                         invokeRestart("muffleMessage")
[16:05:55.717]                     }
[16:05:55.717]                     else if (inherits(cond, "warning")) {
[16:05:55.717]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.717]                       if (muffled) 
[16:05:55.717]                         invokeRestart("muffleWarning")
[16:05:55.717]                     }
[16:05:55.717]                     else if (inherits(cond, "condition")) {
[16:05:55.717]                       if (!is.null(pattern)) {
[16:05:55.717]                         computeRestarts <- base::computeRestarts
[16:05:55.717]                         grepl <- base::grepl
[16:05:55.717]                         restarts <- computeRestarts(cond)
[16:05:55.717]                         for (restart in restarts) {
[16:05:55.717]                           name <- restart$name
[16:05:55.717]                           if (is.null(name)) 
[16:05:55.717]                             next
[16:05:55.717]                           if (!grepl(pattern, name)) 
[16:05:55.717]                             next
[16:05:55.717]                           invokeRestart(restart)
[16:05:55.717]                           muffled <- TRUE
[16:05:55.717]                           break
[16:05:55.717]                         }
[16:05:55.717]                       }
[16:05:55.717]                     }
[16:05:55.717]                     invisible(muffled)
[16:05:55.717]                   }
[16:05:55.717]                   muffleCondition(cond)
[16:05:55.717]                 })
[16:05:55.717]             }))
[16:05:55.717]             future::FutureResult(value = ...future.value$value, 
[16:05:55.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.717]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.717]                     ...future.globalenv.names))
[16:05:55.717]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.717]         }, condition = base::local({
[16:05:55.717]             c <- base::c
[16:05:55.717]             inherits <- base::inherits
[16:05:55.717]             invokeRestart <- base::invokeRestart
[16:05:55.717]             length <- base::length
[16:05:55.717]             list <- base::list
[16:05:55.717]             seq.int <- base::seq.int
[16:05:55.717]             signalCondition <- base::signalCondition
[16:05:55.717]             sys.calls <- base::sys.calls
[16:05:55.717]             `[[` <- base::`[[`
[16:05:55.717]             `+` <- base::`+`
[16:05:55.717]             `<<-` <- base::`<<-`
[16:05:55.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.717]                   3L)]
[16:05:55.717]             }
[16:05:55.717]             function(cond) {
[16:05:55.717]                 is_error <- inherits(cond, "error")
[16:05:55.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.717]                   NULL)
[16:05:55.717]                 if (is_error) {
[16:05:55.717]                   sessionInformation <- function() {
[16:05:55.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.717]                       search = base::search(), system = base::Sys.info())
[16:05:55.717]                   }
[16:05:55.717]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.717]                     cond$call), session = sessionInformation(), 
[16:05:55.717]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.717]                   signalCondition(cond)
[16:05:55.717]                 }
[16:05:55.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.717]                 "immediateCondition"))) {
[16:05:55.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.717]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.717]                   if (TRUE && !signal) {
[16:05:55.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.717]                     {
[16:05:55.717]                       inherits <- base::inherits
[16:05:55.717]                       invokeRestart <- base::invokeRestart
[16:05:55.717]                       is.null <- base::is.null
[16:05:55.717]                       muffled <- FALSE
[16:05:55.717]                       if (inherits(cond, "message")) {
[16:05:55.717]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.717]                         if (muffled) 
[16:05:55.717]                           invokeRestart("muffleMessage")
[16:05:55.717]                       }
[16:05:55.717]                       else if (inherits(cond, "warning")) {
[16:05:55.717]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.717]                         if (muffled) 
[16:05:55.717]                           invokeRestart("muffleWarning")
[16:05:55.717]                       }
[16:05:55.717]                       else if (inherits(cond, "condition")) {
[16:05:55.717]                         if (!is.null(pattern)) {
[16:05:55.717]                           computeRestarts <- base::computeRestarts
[16:05:55.717]                           grepl <- base::grepl
[16:05:55.717]                           restarts <- computeRestarts(cond)
[16:05:55.717]                           for (restart in restarts) {
[16:05:55.717]                             name <- restart$name
[16:05:55.717]                             if (is.null(name)) 
[16:05:55.717]                               next
[16:05:55.717]                             if (!grepl(pattern, name)) 
[16:05:55.717]                               next
[16:05:55.717]                             invokeRestart(restart)
[16:05:55.717]                             muffled <- TRUE
[16:05:55.717]                             break
[16:05:55.717]                           }
[16:05:55.717]                         }
[16:05:55.717]                       }
[16:05:55.717]                       invisible(muffled)
[16:05:55.717]                     }
[16:05:55.717]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.717]                   }
[16:05:55.717]                 }
[16:05:55.717]                 else {
[16:05:55.717]                   if (TRUE) {
[16:05:55.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.717]                     {
[16:05:55.717]                       inherits <- base::inherits
[16:05:55.717]                       invokeRestart <- base::invokeRestart
[16:05:55.717]                       is.null <- base::is.null
[16:05:55.717]                       muffled <- FALSE
[16:05:55.717]                       if (inherits(cond, "message")) {
[16:05:55.717]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.717]                         if (muffled) 
[16:05:55.717]                           invokeRestart("muffleMessage")
[16:05:55.717]                       }
[16:05:55.717]                       else if (inherits(cond, "warning")) {
[16:05:55.717]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.717]                         if (muffled) 
[16:05:55.717]                           invokeRestart("muffleWarning")
[16:05:55.717]                       }
[16:05:55.717]                       else if (inherits(cond, "condition")) {
[16:05:55.717]                         if (!is.null(pattern)) {
[16:05:55.717]                           computeRestarts <- base::computeRestarts
[16:05:55.717]                           grepl <- base::grepl
[16:05:55.717]                           restarts <- computeRestarts(cond)
[16:05:55.717]                           for (restart in restarts) {
[16:05:55.717]                             name <- restart$name
[16:05:55.717]                             if (is.null(name)) 
[16:05:55.717]                               next
[16:05:55.717]                             if (!grepl(pattern, name)) 
[16:05:55.717]                               next
[16:05:55.717]                             invokeRestart(restart)
[16:05:55.717]                             muffled <- TRUE
[16:05:55.717]                             break
[16:05:55.717]                           }
[16:05:55.717]                         }
[16:05:55.717]                       }
[16:05:55.717]                       invisible(muffled)
[16:05:55.717]                     }
[16:05:55.717]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.717]                   }
[16:05:55.717]                 }
[16:05:55.717]             }
[16:05:55.717]         }))
[16:05:55.717]     }, error = function(ex) {
[16:05:55.717]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.717]                 ...future.rng), started = ...future.startTime, 
[16:05:55.717]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.717]             version = "1.8"), class = "FutureResult")
[16:05:55.717]     }, finally = {
[16:05:55.717]         if (!identical(...future.workdir, getwd())) 
[16:05:55.717]             setwd(...future.workdir)
[16:05:55.717]         {
[16:05:55.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.717]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.717]             }
[16:05:55.717]             base::options(...future.oldOptions)
[16:05:55.717]             if (.Platform$OS.type == "windows") {
[16:05:55.717]                 old_names <- names(...future.oldEnvVars)
[16:05:55.717]                 envs <- base::Sys.getenv()
[16:05:55.717]                 names <- names(envs)
[16:05:55.717]                 common <- intersect(names, old_names)
[16:05:55.717]                 added <- setdiff(names, old_names)
[16:05:55.717]                 removed <- setdiff(old_names, names)
[16:05:55.717]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.717]                   envs[common]]
[16:05:55.717]                 NAMES <- toupper(changed)
[16:05:55.717]                 args <- list()
[16:05:55.717]                 for (kk in seq_along(NAMES)) {
[16:05:55.717]                   name <- changed[[kk]]
[16:05:55.717]                   NAME <- NAMES[[kk]]
[16:05:55.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.717]                     next
[16:05:55.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.717]                 }
[16:05:55.717]                 NAMES <- toupper(added)
[16:05:55.717]                 for (kk in seq_along(NAMES)) {
[16:05:55.717]                   name <- added[[kk]]
[16:05:55.717]                   NAME <- NAMES[[kk]]
[16:05:55.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.717]                     next
[16:05:55.717]                   args[[name]] <- ""
[16:05:55.717]                 }
[16:05:55.717]                 NAMES <- toupper(removed)
[16:05:55.717]                 for (kk in seq_along(NAMES)) {
[16:05:55.717]                   name <- removed[[kk]]
[16:05:55.717]                   NAME <- NAMES[[kk]]
[16:05:55.717]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.717]                     next
[16:05:55.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.717]                 }
[16:05:55.717]                 if (length(args) > 0) 
[16:05:55.717]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.717]             }
[16:05:55.717]             else {
[16:05:55.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.717]             }
[16:05:55.717]             {
[16:05:55.717]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.717]                   0L) {
[16:05:55.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.717]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.717]                   base::options(opts)
[16:05:55.717]                 }
[16:05:55.717]                 {
[16:05:55.717]                   {
[16:05:55.717]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.717]                     NULL
[16:05:55.717]                   }
[16:05:55.717]                   options(future.plan = NULL)
[16:05:55.717]                   if (is.na(NA_character_)) 
[16:05:55.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.717]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.717]                     envir = parent.frame()) 
[16:05:55.717]                   {
[16:05:55.717]                     default_workers <- missing(workers)
[16:05:55.717]                     if (is.function(workers)) 
[16:05:55.717]                       workers <- workers()
[16:05:55.717]                     workers <- structure(as.integer(workers), 
[16:05:55.717]                       class = class(workers))
[16:05:55.717]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.717]                       1L)
[16:05:55.717]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.717]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.717]                       if (default_workers) 
[16:05:55.717]                         supportsMulticore(warn = TRUE)
[16:05:55.717]                       return(sequential(..., envir = envir))
[16:05:55.717]                     }
[16:05:55.717]                     oopts <- options(mc.cores = workers)
[16:05:55.717]                     on.exit(options(oopts))
[16:05:55.717]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.717]                       envir = envir)
[16:05:55.717]                     if (!future$lazy) 
[16:05:55.717]                       future <- run(future)
[16:05:55.717]                     invisible(future)
[16:05:55.717]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.717]                 }
[16:05:55.717]             }
[16:05:55.717]         }
[16:05:55.717]     })
[16:05:55.717]     if (TRUE) {
[16:05:55.717]         base::sink(type = "output", split = FALSE)
[16:05:55.717]         if (TRUE) {
[16:05:55.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.717]         }
[16:05:55.717]         else {
[16:05:55.717]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.717]         }
[16:05:55.717]         base::close(...future.stdout)
[16:05:55.717]         ...future.stdout <- NULL
[16:05:55.717]     }
[16:05:55.717]     ...future.result$conditions <- ...future.conditions
[16:05:55.717]     ...future.result$finished <- base::Sys.time()
[16:05:55.717]     ...future.result
[16:05:55.717] }
[16:05:55.721] requestCore(): workers = 2
[16:05:55.721] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:55.732] result() for MulticoreFuture ...
[16:05:55.733] result() for MulticoreFuture ...
[16:05:55.733] result() for MulticoreFuture ... done
[16:05:55.733] result() for MulticoreFuture ... done
[16:05:55.733] result() for MulticoreFuture ...
[16:05:55.733] result() for MulticoreFuture ... done
[16:05:55.736] MulticoreFuture started
[16:05:55.736] - Launch lazy future ... done
[16:05:55.736] run() for ‘MulticoreFuture’ ... done
[16:05:55.737] plan(): Setting new future strategy stack:
[16:05:55.737] List of future strategies:
[16:05:55.737] 1. sequential:
[16:05:55.737]    - args: function (..., envir = parent.frame())
[16:05:55.737]    - tweaked: FALSE
[16:05:55.737]    - call: NULL
[16:05:55.738] plan(): nbrOfWorkers() = 1
[16:05:55.740] plan(): Setting new future strategy stack:
[16:05:55.740] List of future strategies:
[16:05:55.740] 1. multicore:
[16:05:55.740]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.740]    - tweaked: FALSE
[16:05:55.740]    - call: plan(strategy)
[16:05:55.745] plan(): nbrOfWorkers() = 2
[16:05:55.746] Future #2
[16:05:55.746]  length: 1 (resolved future 2)
[16:05:55.746]  length: 0 (resolved future 3)
[16:05:55.747] resolve() on list ... DONE
[16:05:55.747] getGlobalsAndPackages() ...
[16:05:55.748] Searching for globals...
[16:05:55.748] 
[16:05:55.748] Searching for globals ... DONE
[16:05:55.749] - globals: [0] <none>
[16:05:55.749] getGlobalsAndPackages() ... DONE
[16:05:55.749] run() for ‘Future’ ...
[16:05:55.749] - state: ‘created’
[16:05:55.749] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.754] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.754]   - Field: ‘label’
[16:05:55.754]   - Field: ‘local’
[16:05:55.755]   - Field: ‘owner’
[16:05:55.755]   - Field: ‘envir’
[16:05:55.755]   - Field: ‘workers’
[16:05:55.755]   - Field: ‘packages’
[16:05:55.755]   - Field: ‘gc’
[16:05:55.755]   - Field: ‘job’
[16:05:55.756]   - Field: ‘conditions’
[16:05:55.756]   - Field: ‘expr’
[16:05:55.756]   - Field: ‘uuid’
[16:05:55.756]   - Field: ‘seed’
[16:05:55.756]   - Field: ‘version’
[16:05:55.756]   - Field: ‘result’
[16:05:55.756]   - Field: ‘asynchronous’
[16:05:55.757]   - Field: ‘calls’
[16:05:55.757]   - Field: ‘globals’
[16:05:55.757]   - Field: ‘stdout’
[16:05:55.757]   - Field: ‘earlySignal’
[16:05:55.757]   - Field: ‘lazy’
[16:05:55.757]   - Field: ‘state’
[16:05:55.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.758] - Launch lazy future ...
[16:05:55.758] Packages needed by the future expression (n = 0): <none>
[16:05:55.758] Packages needed by future strategies (n = 0): <none>
[16:05:55.759] {
[16:05:55.759]     {
[16:05:55.759]         {
[16:05:55.759]             ...future.startTime <- base::Sys.time()
[16:05:55.759]             {
[16:05:55.759]                 {
[16:05:55.759]                   {
[16:05:55.759]                     {
[16:05:55.759]                       base::local({
[16:05:55.759]                         has_future <- base::requireNamespace("future", 
[16:05:55.759]                           quietly = TRUE)
[16:05:55.759]                         if (has_future) {
[16:05:55.759]                           ns <- base::getNamespace("future")
[16:05:55.759]                           version <- ns[[".package"]][["version"]]
[16:05:55.759]                           if (is.null(version)) 
[16:05:55.759]                             version <- utils::packageVersion("future")
[16:05:55.759]                         }
[16:05:55.759]                         else {
[16:05:55.759]                           version <- NULL
[16:05:55.759]                         }
[16:05:55.759]                         if (!has_future || version < "1.8.0") {
[16:05:55.759]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.759]                             "", base::R.version$version.string), 
[16:05:55.759]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.759]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.759]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.759]                               "release", "version")], collapse = " "), 
[16:05:55.759]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.759]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.759]                             info)
[16:05:55.759]                           info <- base::paste(info, collapse = "; ")
[16:05:55.759]                           if (!has_future) {
[16:05:55.759]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.759]                               info)
[16:05:55.759]                           }
[16:05:55.759]                           else {
[16:05:55.759]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.759]                               info, version)
[16:05:55.759]                           }
[16:05:55.759]                           base::stop(msg)
[16:05:55.759]                         }
[16:05:55.759]                       })
[16:05:55.759]                     }
[16:05:55.759]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.759]                     base::options(mc.cores = 1L)
[16:05:55.759]                   }
[16:05:55.759]                   options(future.plan = NULL)
[16:05:55.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.759]                 }
[16:05:55.759]                 ...future.workdir <- getwd()
[16:05:55.759]             }
[16:05:55.759]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.759]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.759]         }
[16:05:55.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.759]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.759]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.759]             base::names(...future.oldOptions))
[16:05:55.759]     }
[16:05:55.759]     if (FALSE) {
[16:05:55.759]     }
[16:05:55.759]     else {
[16:05:55.759]         if (TRUE) {
[16:05:55.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.759]                 open = "w")
[16:05:55.759]         }
[16:05:55.759]         else {
[16:05:55.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.759]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.759]         }
[16:05:55.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.759]             base::sink(type = "output", split = FALSE)
[16:05:55.759]             base::close(...future.stdout)
[16:05:55.759]         }, add = TRUE)
[16:05:55.759]     }
[16:05:55.759]     ...future.frame <- base::sys.nframe()
[16:05:55.759]     ...future.conditions <- base::list()
[16:05:55.759]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.759]     if (FALSE) {
[16:05:55.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.759]     }
[16:05:55.759]     ...future.result <- base::tryCatch({
[16:05:55.759]         base::withCallingHandlers({
[16:05:55.759]             ...future.value <- base::withVisible(base::local({
[16:05:55.759]                 withCallingHandlers({
[16:05:55.759]                   1
[16:05:55.759]                 }, immediateCondition = function(cond) {
[16:05:55.759]                   save_rds <- function (object, pathname, ...) 
[16:05:55.759]                   {
[16:05:55.759]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.759]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.759]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.759]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.759]                         fi_tmp[["mtime"]])
[16:05:55.759]                     }
[16:05:55.759]                     tryCatch({
[16:05:55.759]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.759]                     }, error = function(ex) {
[16:05:55.759]                       msg <- conditionMessage(ex)
[16:05:55.759]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.759]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.759]                         fi_tmp[["mtime"]], msg)
[16:05:55.759]                       ex$message <- msg
[16:05:55.759]                       stop(ex)
[16:05:55.759]                     })
[16:05:55.759]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.759]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.759]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.759]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.759]                       fi <- file.info(pathname)
[16:05:55.759]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.759]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.759]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.759]                         fi[["size"]], fi[["mtime"]])
[16:05:55.759]                       stop(msg)
[16:05:55.759]                     }
[16:05:55.759]                     invisible(pathname)
[16:05:55.759]                   }
[16:05:55.759]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.759]                     rootPath = tempdir()) 
[16:05:55.759]                   {
[16:05:55.759]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.759]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.759]                       tmpdir = path, fileext = ".rds")
[16:05:55.759]                     save_rds(obj, file)
[16:05:55.759]                   }
[16:05:55.759]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.759]                   {
[16:05:55.759]                     inherits <- base::inherits
[16:05:55.759]                     invokeRestart <- base::invokeRestart
[16:05:55.759]                     is.null <- base::is.null
[16:05:55.759]                     muffled <- FALSE
[16:05:55.759]                     if (inherits(cond, "message")) {
[16:05:55.759]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.759]                       if (muffled) 
[16:05:55.759]                         invokeRestart("muffleMessage")
[16:05:55.759]                     }
[16:05:55.759]                     else if (inherits(cond, "warning")) {
[16:05:55.759]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.759]                       if (muffled) 
[16:05:55.759]                         invokeRestart("muffleWarning")
[16:05:55.759]                     }
[16:05:55.759]                     else if (inherits(cond, "condition")) {
[16:05:55.759]                       if (!is.null(pattern)) {
[16:05:55.759]                         computeRestarts <- base::computeRestarts
[16:05:55.759]                         grepl <- base::grepl
[16:05:55.759]                         restarts <- computeRestarts(cond)
[16:05:55.759]                         for (restart in restarts) {
[16:05:55.759]                           name <- restart$name
[16:05:55.759]                           if (is.null(name)) 
[16:05:55.759]                             next
[16:05:55.759]                           if (!grepl(pattern, name)) 
[16:05:55.759]                             next
[16:05:55.759]                           invokeRestart(restart)
[16:05:55.759]                           muffled <- TRUE
[16:05:55.759]                           break
[16:05:55.759]                         }
[16:05:55.759]                       }
[16:05:55.759]                     }
[16:05:55.759]                     invisible(muffled)
[16:05:55.759]                   }
[16:05:55.759]                   muffleCondition(cond)
[16:05:55.759]                 })
[16:05:55.759]             }))
[16:05:55.759]             future::FutureResult(value = ...future.value$value, 
[16:05:55.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.759]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.759]                     ...future.globalenv.names))
[16:05:55.759]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.759]         }, condition = base::local({
[16:05:55.759]             c <- base::c
[16:05:55.759]             inherits <- base::inherits
[16:05:55.759]             invokeRestart <- base::invokeRestart
[16:05:55.759]             length <- base::length
[16:05:55.759]             list <- base::list
[16:05:55.759]             seq.int <- base::seq.int
[16:05:55.759]             signalCondition <- base::signalCondition
[16:05:55.759]             sys.calls <- base::sys.calls
[16:05:55.759]             `[[` <- base::`[[`
[16:05:55.759]             `+` <- base::`+`
[16:05:55.759]             `<<-` <- base::`<<-`
[16:05:55.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.759]                   3L)]
[16:05:55.759]             }
[16:05:55.759]             function(cond) {
[16:05:55.759]                 is_error <- inherits(cond, "error")
[16:05:55.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.759]                   NULL)
[16:05:55.759]                 if (is_error) {
[16:05:55.759]                   sessionInformation <- function() {
[16:05:55.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.759]                       search = base::search(), system = base::Sys.info())
[16:05:55.759]                   }
[16:05:55.759]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.759]                     cond$call), session = sessionInformation(), 
[16:05:55.759]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.759]                   signalCondition(cond)
[16:05:55.759]                 }
[16:05:55.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.759]                 "immediateCondition"))) {
[16:05:55.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.759]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.759]                   if (TRUE && !signal) {
[16:05:55.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.759]                     {
[16:05:55.759]                       inherits <- base::inherits
[16:05:55.759]                       invokeRestart <- base::invokeRestart
[16:05:55.759]                       is.null <- base::is.null
[16:05:55.759]                       muffled <- FALSE
[16:05:55.759]                       if (inherits(cond, "message")) {
[16:05:55.759]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.759]                         if (muffled) 
[16:05:55.759]                           invokeRestart("muffleMessage")
[16:05:55.759]                       }
[16:05:55.759]                       else if (inherits(cond, "warning")) {
[16:05:55.759]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.759]                         if (muffled) 
[16:05:55.759]                           invokeRestart("muffleWarning")
[16:05:55.759]                       }
[16:05:55.759]                       else if (inherits(cond, "condition")) {
[16:05:55.759]                         if (!is.null(pattern)) {
[16:05:55.759]                           computeRestarts <- base::computeRestarts
[16:05:55.759]                           grepl <- base::grepl
[16:05:55.759]                           restarts <- computeRestarts(cond)
[16:05:55.759]                           for (restart in restarts) {
[16:05:55.759]                             name <- restart$name
[16:05:55.759]                             if (is.null(name)) 
[16:05:55.759]                               next
[16:05:55.759]                             if (!grepl(pattern, name)) 
[16:05:55.759]                               next
[16:05:55.759]                             invokeRestart(restart)
[16:05:55.759]                             muffled <- TRUE
[16:05:55.759]                             break
[16:05:55.759]                           }
[16:05:55.759]                         }
[16:05:55.759]                       }
[16:05:55.759]                       invisible(muffled)
[16:05:55.759]                     }
[16:05:55.759]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.759]                   }
[16:05:55.759]                 }
[16:05:55.759]                 else {
[16:05:55.759]                   if (TRUE) {
[16:05:55.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.759]                     {
[16:05:55.759]                       inherits <- base::inherits
[16:05:55.759]                       invokeRestart <- base::invokeRestart
[16:05:55.759]                       is.null <- base::is.null
[16:05:55.759]                       muffled <- FALSE
[16:05:55.759]                       if (inherits(cond, "message")) {
[16:05:55.759]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.759]                         if (muffled) 
[16:05:55.759]                           invokeRestart("muffleMessage")
[16:05:55.759]                       }
[16:05:55.759]                       else if (inherits(cond, "warning")) {
[16:05:55.759]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.759]                         if (muffled) 
[16:05:55.759]                           invokeRestart("muffleWarning")
[16:05:55.759]                       }
[16:05:55.759]                       else if (inherits(cond, "condition")) {
[16:05:55.759]                         if (!is.null(pattern)) {
[16:05:55.759]                           computeRestarts <- base::computeRestarts
[16:05:55.759]                           grepl <- base::grepl
[16:05:55.759]                           restarts <- computeRestarts(cond)
[16:05:55.759]                           for (restart in restarts) {
[16:05:55.759]                             name <- restart$name
[16:05:55.759]                             if (is.null(name)) 
[16:05:55.759]                               next
[16:05:55.759]                             if (!grepl(pattern, name)) 
[16:05:55.759]                               next
[16:05:55.759]                             invokeRestart(restart)
[16:05:55.759]                             muffled <- TRUE
[16:05:55.759]                             break
[16:05:55.759]                           }
[16:05:55.759]                         }
[16:05:55.759]                       }
[16:05:55.759]                       invisible(muffled)
[16:05:55.759]                     }
[16:05:55.759]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.759]                   }
[16:05:55.759]                 }
[16:05:55.759]             }
[16:05:55.759]         }))
[16:05:55.759]     }, error = function(ex) {
[16:05:55.759]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.759]                 ...future.rng), started = ...future.startTime, 
[16:05:55.759]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.759]             version = "1.8"), class = "FutureResult")
[16:05:55.759]     }, finally = {
[16:05:55.759]         if (!identical(...future.workdir, getwd())) 
[16:05:55.759]             setwd(...future.workdir)
[16:05:55.759]         {
[16:05:55.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.759]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.759]             }
[16:05:55.759]             base::options(...future.oldOptions)
[16:05:55.759]             if (.Platform$OS.type == "windows") {
[16:05:55.759]                 old_names <- names(...future.oldEnvVars)
[16:05:55.759]                 envs <- base::Sys.getenv()
[16:05:55.759]                 names <- names(envs)
[16:05:55.759]                 common <- intersect(names, old_names)
[16:05:55.759]                 added <- setdiff(names, old_names)
[16:05:55.759]                 removed <- setdiff(old_names, names)
[16:05:55.759]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.759]                   envs[common]]
[16:05:55.759]                 NAMES <- toupper(changed)
[16:05:55.759]                 args <- list()
[16:05:55.759]                 for (kk in seq_along(NAMES)) {
[16:05:55.759]                   name <- changed[[kk]]
[16:05:55.759]                   NAME <- NAMES[[kk]]
[16:05:55.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.759]                     next
[16:05:55.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.759]                 }
[16:05:55.759]                 NAMES <- toupper(added)
[16:05:55.759]                 for (kk in seq_along(NAMES)) {
[16:05:55.759]                   name <- added[[kk]]
[16:05:55.759]                   NAME <- NAMES[[kk]]
[16:05:55.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.759]                     next
[16:05:55.759]                   args[[name]] <- ""
[16:05:55.759]                 }
[16:05:55.759]                 NAMES <- toupper(removed)
[16:05:55.759]                 for (kk in seq_along(NAMES)) {
[16:05:55.759]                   name <- removed[[kk]]
[16:05:55.759]                   NAME <- NAMES[[kk]]
[16:05:55.759]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.759]                     next
[16:05:55.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.759]                 }
[16:05:55.759]                 if (length(args) > 0) 
[16:05:55.759]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.759]             }
[16:05:55.759]             else {
[16:05:55.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.759]             }
[16:05:55.759]             {
[16:05:55.759]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.759]                   0L) {
[16:05:55.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.759]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.759]                   base::options(opts)
[16:05:55.759]                 }
[16:05:55.759]                 {
[16:05:55.759]                   {
[16:05:55.759]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.759]                     NULL
[16:05:55.759]                   }
[16:05:55.759]                   options(future.plan = NULL)
[16:05:55.759]                   if (is.na(NA_character_)) 
[16:05:55.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.759]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.759]                     envir = parent.frame()) 
[16:05:55.759]                   {
[16:05:55.759]                     default_workers <- missing(workers)
[16:05:55.759]                     if (is.function(workers)) 
[16:05:55.759]                       workers <- workers()
[16:05:55.759]                     workers <- structure(as.integer(workers), 
[16:05:55.759]                       class = class(workers))
[16:05:55.759]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.759]                       1L)
[16:05:55.759]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.759]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.759]                       if (default_workers) 
[16:05:55.759]                         supportsMulticore(warn = TRUE)
[16:05:55.759]                       return(sequential(..., envir = envir))
[16:05:55.759]                     }
[16:05:55.759]                     oopts <- options(mc.cores = workers)
[16:05:55.759]                     on.exit(options(oopts))
[16:05:55.759]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.759]                       envir = envir)
[16:05:55.759]                     if (!future$lazy) 
[16:05:55.759]                       future <- run(future)
[16:05:55.759]                     invisible(future)
[16:05:55.759]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.759]                 }
[16:05:55.759]             }
[16:05:55.759]         }
[16:05:55.759]     })
[16:05:55.759]     if (TRUE) {
[16:05:55.759]         base::sink(type = "output", split = FALSE)
[16:05:55.759]         if (TRUE) {
[16:05:55.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.759]         }
[16:05:55.759]         else {
[16:05:55.759]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.759]         }
[16:05:55.759]         base::close(...future.stdout)
[16:05:55.759]         ...future.stdout <- NULL
[16:05:55.759]     }
[16:05:55.759]     ...future.result$conditions <- ...future.conditions
[16:05:55.759]     ...future.result$finished <- base::Sys.time()
[16:05:55.759]     ...future.result
[16:05:55.759] }
[16:05:55.762] requestCore(): workers = 2
[16:05:55.763] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:55.773] result() for MulticoreFuture ...
[16:05:55.774] result() for MulticoreFuture ...
[16:05:55.774] result() for MulticoreFuture ... done
[16:05:55.775] result() for MulticoreFuture ... done
[16:05:55.778] result() for MulticoreFuture ...
[16:05:55.778] result() for MulticoreFuture ... done
[16:05:55.781] MulticoreFuture started
[16:05:55.782] - Launch lazy future ... done
[16:05:55.782] run() for ‘MulticoreFuture’ ... done
[16:05:55.782] plan(): Setting new future strategy stack:
[16:05:55.783] getGlobalsAndPackages() ...
[16:05:55.783] Searching for globals...
[16:05:55.783] List of future strategies:
[16:05:55.783] 1. sequential:
[16:05:55.783]    - args: function (..., envir = parent.frame())
[16:05:55.783]    - tweaked: FALSE
[16:05:55.783]    - call: NULL
[16:05:55.784] plan(): nbrOfWorkers() = 1
[16:05:55.787] plan(): Setting new future strategy stack:
[16:05:55.787] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:05:55.787] Searching for globals ... DONE
[16:05:55.787] Resolving globals: FALSE
[16:05:55.787] List of future strategies:
[16:05:55.787] 1. multicore:
[16:05:55.787]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:55.787]    - tweaked: FALSE
[16:05:55.787]    - call: plan(strategy)
[16:05:55.788] 
[16:05:55.788] 
[16:05:55.788] getGlobalsAndPackages() ... DONE
[16:05:55.789] run() for ‘Future’ ...
[16:05:55.789] - state: ‘created’
[16:05:55.789] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:55.792] plan(): nbrOfWorkers() = 2
[16:05:55.794] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:55.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:55.795]   - Field: ‘label’
[16:05:55.795]   - Field: ‘local’
[16:05:55.795]   - Field: ‘owner’
[16:05:55.795]   - Field: ‘envir’
[16:05:55.795]   - Field: ‘workers’
[16:05:55.796]   - Field: ‘packages’
[16:05:55.796]   - Field: ‘gc’
[16:05:55.796]   - Field: ‘job’
[16:05:55.796]   - Field: ‘conditions’
[16:05:55.796]   - Field: ‘expr’
[16:05:55.796]   - Field: ‘uuid’
[16:05:55.796]   - Field: ‘seed’
[16:05:55.797]   - Field: ‘version’
[16:05:55.797]   - Field: ‘result’
[16:05:55.797]   - Field: ‘asynchronous’
[16:05:55.797]   - Field: ‘calls’
[16:05:55.797]   - Field: ‘globals’
[16:05:55.797]   - Field: ‘stdout’
[16:05:55.797]   - Field: ‘earlySignal’
[16:05:55.798]   - Field: ‘lazy’
[16:05:55.798]   - Field: ‘state’
[16:05:55.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:55.798] - Launch lazy future ...
[16:05:55.798] Packages needed by the future expression (n = 0): <none>
[16:05:55.799] Packages needed by future strategies (n = 0): <none>
[16:05:55.799] {
[16:05:55.799]     {
[16:05:55.799]         {
[16:05:55.799]             ...future.startTime <- base::Sys.time()
[16:05:55.799]             {
[16:05:55.799]                 {
[16:05:55.799]                   {
[16:05:55.799]                     {
[16:05:55.799]                       base::local({
[16:05:55.799]                         has_future <- base::requireNamespace("future", 
[16:05:55.799]                           quietly = TRUE)
[16:05:55.799]                         if (has_future) {
[16:05:55.799]                           ns <- base::getNamespace("future")
[16:05:55.799]                           version <- ns[[".package"]][["version"]]
[16:05:55.799]                           if (is.null(version)) 
[16:05:55.799]                             version <- utils::packageVersion("future")
[16:05:55.799]                         }
[16:05:55.799]                         else {
[16:05:55.799]                           version <- NULL
[16:05:55.799]                         }
[16:05:55.799]                         if (!has_future || version < "1.8.0") {
[16:05:55.799]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:55.799]                             "", base::R.version$version.string), 
[16:05:55.799]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:55.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:55.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:55.799]                               "release", "version")], collapse = " "), 
[16:05:55.799]                             hostname = base::Sys.info()[["nodename"]])
[16:05:55.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:55.799]                             info)
[16:05:55.799]                           info <- base::paste(info, collapse = "; ")
[16:05:55.799]                           if (!has_future) {
[16:05:55.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:55.799]                               info)
[16:05:55.799]                           }
[16:05:55.799]                           else {
[16:05:55.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:55.799]                               info, version)
[16:05:55.799]                           }
[16:05:55.799]                           base::stop(msg)
[16:05:55.799]                         }
[16:05:55.799]                       })
[16:05:55.799]                     }
[16:05:55.799]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:55.799]                     base::options(mc.cores = 1L)
[16:05:55.799]                   }
[16:05:55.799]                   options(future.plan = NULL)
[16:05:55.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:55.799]                 }
[16:05:55.799]                 ...future.workdir <- getwd()
[16:05:55.799]             }
[16:05:55.799]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:55.799]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:55.799]         }
[16:05:55.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:55.799]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:55.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:55.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:55.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:55.799]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:55.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:55.799]             base::names(...future.oldOptions))
[16:05:55.799]     }
[16:05:55.799]     if (FALSE) {
[16:05:55.799]     }
[16:05:55.799]     else {
[16:05:55.799]         if (TRUE) {
[16:05:55.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:55.799]                 open = "w")
[16:05:55.799]         }
[16:05:55.799]         else {
[16:05:55.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:55.799]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:55.799]         }
[16:05:55.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:55.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:55.799]             base::sink(type = "output", split = FALSE)
[16:05:55.799]             base::close(...future.stdout)
[16:05:55.799]         }, add = TRUE)
[16:05:55.799]     }
[16:05:55.799]     ...future.frame <- base::sys.nframe()
[16:05:55.799]     ...future.conditions <- base::list()
[16:05:55.799]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:55.799]     if (FALSE) {
[16:05:55.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:55.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:55.799]     }
[16:05:55.799]     ...future.result <- base::tryCatch({
[16:05:55.799]         base::withCallingHandlers({
[16:05:55.799]             ...future.value <- base::withVisible(base::local({
[16:05:55.799]                 withCallingHandlers({
[16:05:55.799]                   {
[16:05:55.799]                     Sys.sleep(0.5)
[16:05:55.799]                     2
[16:05:55.799]                   }
[16:05:55.799]                 }, immediateCondition = function(cond) {
[16:05:55.799]                   save_rds <- function (object, pathname, ...) 
[16:05:55.799]                   {
[16:05:55.799]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:55.799]                     if (file_test("-f", pathname_tmp)) {
[16:05:55.799]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.799]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:55.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.799]                         fi_tmp[["mtime"]])
[16:05:55.799]                     }
[16:05:55.799]                     tryCatch({
[16:05:55.799]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:55.799]                     }, error = function(ex) {
[16:05:55.799]                       msg <- conditionMessage(ex)
[16:05:55.799]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.799]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:55.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.799]                         fi_tmp[["mtime"]], msg)
[16:05:55.799]                       ex$message <- msg
[16:05:55.799]                       stop(ex)
[16:05:55.799]                     })
[16:05:55.799]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:55.799]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:55.799]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:55.799]                       fi_tmp <- file.info(pathname_tmp)
[16:05:55.799]                       fi <- file.info(pathname)
[16:05:55.799]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:55.799]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:55.799]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:55.799]                         fi[["size"]], fi[["mtime"]])
[16:05:55.799]                       stop(msg)
[16:05:55.799]                     }
[16:05:55.799]                     invisible(pathname)
[16:05:55.799]                   }
[16:05:55.799]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:55.799]                     rootPath = tempdir()) 
[16:05:55.799]                   {
[16:05:55.799]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:55.799]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:55.799]                       tmpdir = path, fileext = ".rds")
[16:05:55.799]                     save_rds(obj, file)
[16:05:55.799]                   }
[16:05:55.799]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:55.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.799]                   {
[16:05:55.799]                     inherits <- base::inherits
[16:05:55.799]                     invokeRestart <- base::invokeRestart
[16:05:55.799]                     is.null <- base::is.null
[16:05:55.799]                     muffled <- FALSE
[16:05:55.799]                     if (inherits(cond, "message")) {
[16:05:55.799]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:55.799]                       if (muffled) 
[16:05:55.799]                         invokeRestart("muffleMessage")
[16:05:55.799]                     }
[16:05:55.799]                     else if (inherits(cond, "warning")) {
[16:05:55.799]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:55.799]                       if (muffled) 
[16:05:55.799]                         invokeRestart("muffleWarning")
[16:05:55.799]                     }
[16:05:55.799]                     else if (inherits(cond, "condition")) {
[16:05:55.799]                       if (!is.null(pattern)) {
[16:05:55.799]                         computeRestarts <- base::computeRestarts
[16:05:55.799]                         grepl <- base::grepl
[16:05:55.799]                         restarts <- computeRestarts(cond)
[16:05:55.799]                         for (restart in restarts) {
[16:05:55.799]                           name <- restart$name
[16:05:55.799]                           if (is.null(name)) 
[16:05:55.799]                             next
[16:05:55.799]                           if (!grepl(pattern, name)) 
[16:05:55.799]                             next
[16:05:55.799]                           invokeRestart(restart)
[16:05:55.799]                           muffled <- TRUE
[16:05:55.799]                           break
[16:05:55.799]                         }
[16:05:55.799]                       }
[16:05:55.799]                     }
[16:05:55.799]                     invisible(muffled)
[16:05:55.799]                   }
[16:05:55.799]                   muffleCondition(cond)
[16:05:55.799]                 })
[16:05:55.799]             }))
[16:05:55.799]             future::FutureResult(value = ...future.value$value, 
[16:05:55.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.799]                   ...future.rng), globalenv = if (FALSE) 
[16:05:55.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:55.799]                     ...future.globalenv.names))
[16:05:55.799]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:55.799]         }, condition = base::local({
[16:05:55.799]             c <- base::c
[16:05:55.799]             inherits <- base::inherits
[16:05:55.799]             invokeRestart <- base::invokeRestart
[16:05:55.799]             length <- base::length
[16:05:55.799]             list <- base::list
[16:05:55.799]             seq.int <- base::seq.int
[16:05:55.799]             signalCondition <- base::signalCondition
[16:05:55.799]             sys.calls <- base::sys.calls
[16:05:55.799]             `[[` <- base::`[[`
[16:05:55.799]             `+` <- base::`+`
[16:05:55.799]             `<<-` <- base::`<<-`
[16:05:55.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:55.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:55.799]                   3L)]
[16:05:55.799]             }
[16:05:55.799]             function(cond) {
[16:05:55.799]                 is_error <- inherits(cond, "error")
[16:05:55.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:55.799]                   NULL)
[16:05:55.799]                 if (is_error) {
[16:05:55.799]                   sessionInformation <- function() {
[16:05:55.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:55.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:55.799]                       search = base::search(), system = base::Sys.info())
[16:05:55.799]                   }
[16:05:55.799]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:55.799]                     cond$call), session = sessionInformation(), 
[16:05:55.799]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:55.799]                   signalCondition(cond)
[16:05:55.799]                 }
[16:05:55.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:55.799]                 "immediateCondition"))) {
[16:05:55.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:55.799]                   ...future.conditions[[length(...future.conditions) + 
[16:05:55.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:55.799]                   if (TRUE && !signal) {
[16:05:55.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.799]                     {
[16:05:55.799]                       inherits <- base::inherits
[16:05:55.799]                       invokeRestart <- base::invokeRestart
[16:05:55.799]                       is.null <- base::is.null
[16:05:55.799]                       muffled <- FALSE
[16:05:55.799]                       if (inherits(cond, "message")) {
[16:05:55.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.799]                         if (muffled) 
[16:05:55.799]                           invokeRestart("muffleMessage")
[16:05:55.799]                       }
[16:05:55.799]                       else if (inherits(cond, "warning")) {
[16:05:55.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.799]                         if (muffled) 
[16:05:55.799]                           invokeRestart("muffleWarning")
[16:05:55.799]                       }
[16:05:55.799]                       else if (inherits(cond, "condition")) {
[16:05:55.799]                         if (!is.null(pattern)) {
[16:05:55.799]                           computeRestarts <- base::computeRestarts
[16:05:55.799]                           grepl <- base::grepl
[16:05:55.799]                           restarts <- computeRestarts(cond)
[16:05:55.799]                           for (restart in restarts) {
[16:05:55.799]                             name <- restart$name
[16:05:55.799]                             if (is.null(name)) 
[16:05:55.799]                               next
[16:05:55.799]                             if (!grepl(pattern, name)) 
[16:05:55.799]                               next
[16:05:55.799]                             invokeRestart(restart)
[16:05:55.799]                             muffled <- TRUE
[16:05:55.799]                             break
[16:05:55.799]                           }
[16:05:55.799]                         }
[16:05:55.799]                       }
[16:05:55.799]                       invisible(muffled)
[16:05:55.799]                     }
[16:05:55.799]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.799]                   }
[16:05:55.799]                 }
[16:05:55.799]                 else {
[16:05:55.799]                   if (TRUE) {
[16:05:55.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:55.799]                     {
[16:05:55.799]                       inherits <- base::inherits
[16:05:55.799]                       invokeRestart <- base::invokeRestart
[16:05:55.799]                       is.null <- base::is.null
[16:05:55.799]                       muffled <- FALSE
[16:05:55.799]                       if (inherits(cond, "message")) {
[16:05:55.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:55.799]                         if (muffled) 
[16:05:55.799]                           invokeRestart("muffleMessage")
[16:05:55.799]                       }
[16:05:55.799]                       else if (inherits(cond, "warning")) {
[16:05:55.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:55.799]                         if (muffled) 
[16:05:55.799]                           invokeRestart("muffleWarning")
[16:05:55.799]                       }
[16:05:55.799]                       else if (inherits(cond, "condition")) {
[16:05:55.799]                         if (!is.null(pattern)) {
[16:05:55.799]                           computeRestarts <- base::computeRestarts
[16:05:55.799]                           grepl <- base::grepl
[16:05:55.799]                           restarts <- computeRestarts(cond)
[16:05:55.799]                           for (restart in restarts) {
[16:05:55.799]                             name <- restart$name
[16:05:55.799]                             if (is.null(name)) 
[16:05:55.799]                               next
[16:05:55.799]                             if (!grepl(pattern, name)) 
[16:05:55.799]                               next
[16:05:55.799]                             invokeRestart(restart)
[16:05:55.799]                             muffled <- TRUE
[16:05:55.799]                             break
[16:05:55.799]                           }
[16:05:55.799]                         }
[16:05:55.799]                       }
[16:05:55.799]                       invisible(muffled)
[16:05:55.799]                     }
[16:05:55.799]                     muffleCondition(cond, pattern = "^muffle")
[16:05:55.799]                   }
[16:05:55.799]                 }
[16:05:55.799]             }
[16:05:55.799]         }))
[16:05:55.799]     }, error = function(ex) {
[16:05:55.799]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:55.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:55.799]                 ...future.rng), started = ...future.startTime, 
[16:05:55.799]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:55.799]             version = "1.8"), class = "FutureResult")
[16:05:55.799]     }, finally = {
[16:05:55.799]         if (!identical(...future.workdir, getwd())) 
[16:05:55.799]             setwd(...future.workdir)
[16:05:55.799]         {
[16:05:55.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:55.799]                 ...future.oldOptions$nwarnings <- NULL
[16:05:55.799]             }
[16:05:55.799]             base::options(...future.oldOptions)
[16:05:55.799]             if (.Platform$OS.type == "windows") {
[16:05:55.799]                 old_names <- names(...future.oldEnvVars)
[16:05:55.799]                 envs <- base::Sys.getenv()
[16:05:55.799]                 names <- names(envs)
[16:05:55.799]                 common <- intersect(names, old_names)
[16:05:55.799]                 added <- setdiff(names, old_names)
[16:05:55.799]                 removed <- setdiff(old_names, names)
[16:05:55.799]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:55.799]                   envs[common]]
[16:05:55.799]                 NAMES <- toupper(changed)
[16:05:55.799]                 args <- list()
[16:05:55.799]                 for (kk in seq_along(NAMES)) {
[16:05:55.799]                   name <- changed[[kk]]
[16:05:55.799]                   NAME <- NAMES[[kk]]
[16:05:55.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.799]                     next
[16:05:55.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.799]                 }
[16:05:55.799]                 NAMES <- toupper(added)
[16:05:55.799]                 for (kk in seq_along(NAMES)) {
[16:05:55.799]                   name <- added[[kk]]
[16:05:55.799]                   NAME <- NAMES[[kk]]
[16:05:55.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.799]                     next
[16:05:55.799]                   args[[name]] <- ""
[16:05:55.799]                 }
[16:05:55.799]                 NAMES <- toupper(removed)
[16:05:55.799]                 for (kk in seq_along(NAMES)) {
[16:05:55.799]                   name <- removed[[kk]]
[16:05:55.799]                   NAME <- NAMES[[kk]]
[16:05:55.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:55.799]                     next
[16:05:55.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:55.799]                 }
[16:05:55.799]                 if (length(args) > 0) 
[16:05:55.799]                   base::do.call(base::Sys.setenv, args = args)
[16:05:55.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:55.799]             }
[16:05:55.799]             else {
[16:05:55.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:55.799]             }
[16:05:55.799]             {
[16:05:55.799]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:55.799]                   0L) {
[16:05:55.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:55.799]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:55.799]                   base::options(opts)
[16:05:55.799]                 }
[16:05:55.799]                 {
[16:05:55.799]                   {
[16:05:55.799]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:55.799]                     NULL
[16:05:55.799]                   }
[16:05:55.799]                   options(future.plan = NULL)
[16:05:55.799]                   if (is.na(NA_character_)) 
[16:05:55.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:55.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:55.799]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:55.799]                     envir = parent.frame()) 
[16:05:55.799]                   {
[16:05:55.799]                     default_workers <- missing(workers)
[16:05:55.799]                     if (is.function(workers)) 
[16:05:55.799]                       workers <- workers()
[16:05:55.799]                     workers <- structure(as.integer(workers), 
[16:05:55.799]                       class = class(workers))
[16:05:55.799]                     stop_if_not(is.finite(workers), workers >= 
[16:05:55.799]                       1L)
[16:05:55.799]                     if ((workers == 1L && !inherits(workers, 
[16:05:55.799]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:55.799]                       if (default_workers) 
[16:05:55.799]                         supportsMulticore(warn = TRUE)
[16:05:55.799]                       return(sequential(..., envir = envir))
[16:05:55.799]                     }
[16:05:55.799]                     oopts <- options(mc.cores = workers)
[16:05:55.799]                     on.exit(options(oopts))
[16:05:55.799]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:55.799]                       envir = envir)
[16:05:55.799]                     if (!future$lazy) 
[16:05:55.799]                       future <- run(future)
[16:05:55.799]                     invisible(future)
[16:05:55.799]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:55.799]                 }
[16:05:55.799]             }
[16:05:55.799]         }
[16:05:55.799]     })
[16:05:55.799]     if (TRUE) {
[16:05:55.799]         base::sink(type = "output", split = FALSE)
[16:05:55.799]         if (TRUE) {
[16:05:55.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:55.799]         }
[16:05:55.799]         else {
[16:05:55.799]             ...future.result["stdout"] <- base::list(NULL)
[16:05:55.799]         }
[16:05:55.799]         base::close(...future.stdout)
[16:05:55.799]         ...future.stdout <- NULL
[16:05:55.799]     }
[16:05:55.799]     ...future.result$conditions <- ...future.conditions
[16:05:55.799]     ...future.result$finished <- base::Sys.time()
[16:05:55.799]     ...future.result
[16:05:55.799] }
[16:05:55.803] requestCore(): workers = 2
[16:05:55.803] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:55.814] result() for MulticoreFuture ...
[16:05:55.815] result() for MulticoreFuture ...
[16:05:55.815] result() for MulticoreFuture ... done
[16:05:55.815] result() for MulticoreFuture ... done
[16:05:55.815] result() for MulticoreFuture ...
[16:05:55.815] result() for MulticoreFuture ... done
[16:05:55.818] MulticoreFuture started
[16:05:55.818] - Launch lazy future ... done
[16:05:55.819] run() for ‘MulticoreFuture’ ... done
[16:05:55.819] plan(): Setting new future strategy stack:
[16:05:55.820] resolve() on list ...
[16:05:55.820]  recursive: 0
[16:05:55.820]  length: 1
[16:05:55.820] 
[16:05:55.819] List of future strategies:
[16:05:55.819] 1. sequential:
[16:05:55.819]    - args: function (..., envir = parent.frame())
[16:05:55.819]    - tweaked: FALSE
[16:05:55.819]    - call: NULL
[16:05:55.820] plan(): nbrOfWorkers() = 1
[16:05:55.821] Future #1
[16:05:55.821]  length: 0 (resolved future 1)
[16:05:55.821] resolve() on list ... DONE
[16:05:55.821] resolve() on list ...
[16:05:55.822]  recursive: 0
[16:05:55.822]  length: 1
[16:05:55.822] 
[16:05:56.323] plan(): Setting new future strategy stack:
[16:05:56.323] List of future strategies:
[16:05:56.323] 1. multicore:
[16:05:56.323]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.323]    - tweaked: FALSE
[16:05:56.323]    - call: plan(strategy)
[16:05:56.329] plan(): nbrOfWorkers() = 2
[16:05:56.332] Future #1
[16:05:56.332]  length: 0 (resolved future 1)
[16:05:56.332] resolve() on list ... DONE
[16:05:56.333] resolve() on list ...
[16:05:56.333]  recursive: 0
[16:05:56.333]  length: 1
[16:05:56.333] 
[16:05:56.333]  length: 0 (resolved future 1)
[16:05:56.333] resolve() on list ... DONE
[16:05:56.334] resolve() on list ...
[16:05:56.334]  recursive: 0
[16:05:56.334]  length: 4
[16:05:56.334] 
[16:05:56.334] Future #1
[16:05:56.335]  length: 3 (resolved future 1)
[16:05:56.335] Future #2
[16:05:56.335]  length: 2 (resolved future 2)
[16:05:56.335]  length: 1 (resolved future 3)
[16:05:56.335]  length: 0 (resolved future 4)
[16:05:56.336] resolve() on list ... DONE
[16:05:56.336] resolve() on list ...
[16:05:56.336]  recursive: 0
[16:05:56.336]  length: 4
[16:05:56.336] 
[16:05:56.337] Future #1
[16:05:56.337]  length: 3 (resolved future 1)
[16:05:56.337] Future #2
[16:05:56.337]  length: 2 (resolved future 2)
[16:05:56.337]  length: 1 (resolved future 3)
[16:05:56.337]  length: 0 (resolved future 4)
[16:05:56.338] resolve() on list ... DONE
[16:05:56.338] resolve() on list ...
[16:05:56.338]  recursive: 0
[16:05:56.338]  length: 1
[16:05:56.338] 
[16:05:56.338]  length: 0 (resolved future 1)
[16:05:56.339] resolve() on list ... DONE
[16:05:56.339] getGlobalsAndPackages() ...
[16:05:56.339] Searching for globals...
[16:05:56.341] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:56.341] Searching for globals ... DONE
[16:05:56.341] Resolving globals: FALSE
[16:05:56.342] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:56.342] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:56.343] - globals: [1] ‘kk’
[16:05:56.343] 
[16:05:56.343] getGlobalsAndPackages() ... DONE
[16:05:56.343] run() for ‘Future’ ...
[16:05:56.343] - state: ‘created’
[16:05:56.344] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.348] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.348]   - Field: ‘label’
[16:05:56.348]   - Field: ‘local’
[16:05:56.349]   - Field: ‘owner’
[16:05:56.349]   - Field: ‘envir’
[16:05:56.349]   - Field: ‘workers’
[16:05:56.349]   - Field: ‘packages’
[16:05:56.349]   - Field: ‘gc’
[16:05:56.349]   - Field: ‘job’
[16:05:56.349]   - Field: ‘conditions’
[16:05:56.350]   - Field: ‘expr’
[16:05:56.350]   - Field: ‘uuid’
[16:05:56.350]   - Field: ‘seed’
[16:05:56.350]   - Field: ‘version’
[16:05:56.350]   - Field: ‘result’
[16:05:56.350]   - Field: ‘asynchronous’
[16:05:56.350]   - Field: ‘calls’
[16:05:56.353]   - Field: ‘globals’
[16:05:56.353]   - Field: ‘stdout’
[16:05:56.354]   - Field: ‘earlySignal’
[16:05:56.354]   - Field: ‘lazy’
[16:05:56.354]   - Field: ‘state’
[16:05:56.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.355] - Launch lazy future ...
[16:05:56.355] Packages needed by the future expression (n = 0): <none>
[16:05:56.355] Packages needed by future strategies (n = 0): <none>
[16:05:56.356] {
[16:05:56.356]     {
[16:05:56.356]         {
[16:05:56.356]             ...future.startTime <- base::Sys.time()
[16:05:56.356]             {
[16:05:56.356]                 {
[16:05:56.356]                   {
[16:05:56.356]                     {
[16:05:56.356]                       base::local({
[16:05:56.356]                         has_future <- base::requireNamespace("future", 
[16:05:56.356]                           quietly = TRUE)
[16:05:56.356]                         if (has_future) {
[16:05:56.356]                           ns <- base::getNamespace("future")
[16:05:56.356]                           version <- ns[[".package"]][["version"]]
[16:05:56.356]                           if (is.null(version)) 
[16:05:56.356]                             version <- utils::packageVersion("future")
[16:05:56.356]                         }
[16:05:56.356]                         else {
[16:05:56.356]                           version <- NULL
[16:05:56.356]                         }
[16:05:56.356]                         if (!has_future || version < "1.8.0") {
[16:05:56.356]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.356]                             "", base::R.version$version.string), 
[16:05:56.356]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.356]                               "release", "version")], collapse = " "), 
[16:05:56.356]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.356]                             info)
[16:05:56.356]                           info <- base::paste(info, collapse = "; ")
[16:05:56.356]                           if (!has_future) {
[16:05:56.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.356]                               info)
[16:05:56.356]                           }
[16:05:56.356]                           else {
[16:05:56.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.356]                               info, version)
[16:05:56.356]                           }
[16:05:56.356]                           base::stop(msg)
[16:05:56.356]                         }
[16:05:56.356]                       })
[16:05:56.356]                     }
[16:05:56.356]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.356]                     base::options(mc.cores = 1L)
[16:05:56.356]                   }
[16:05:56.356]                   options(future.plan = NULL)
[16:05:56.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.356]                 }
[16:05:56.356]                 ...future.workdir <- getwd()
[16:05:56.356]             }
[16:05:56.356]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.356]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.356]         }
[16:05:56.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.356]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.356]             base::names(...future.oldOptions))
[16:05:56.356]     }
[16:05:56.356]     if (FALSE) {
[16:05:56.356]     }
[16:05:56.356]     else {
[16:05:56.356]         if (TRUE) {
[16:05:56.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.356]                 open = "w")
[16:05:56.356]         }
[16:05:56.356]         else {
[16:05:56.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.356]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.356]         }
[16:05:56.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.356]             base::sink(type = "output", split = FALSE)
[16:05:56.356]             base::close(...future.stdout)
[16:05:56.356]         }, add = TRUE)
[16:05:56.356]     }
[16:05:56.356]     ...future.frame <- base::sys.nframe()
[16:05:56.356]     ...future.conditions <- base::list()
[16:05:56.356]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.356]     if (FALSE) {
[16:05:56.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.356]     }
[16:05:56.356]     ...future.result <- base::tryCatch({
[16:05:56.356]         base::withCallingHandlers({
[16:05:56.356]             ...future.value <- base::withVisible(base::local({
[16:05:56.356]                 withCallingHandlers({
[16:05:56.356]                   {
[16:05:56.356]                     Sys.sleep(0.1)
[16:05:56.356]                     kk
[16:05:56.356]                   }
[16:05:56.356]                 }, immediateCondition = function(cond) {
[16:05:56.356]                   save_rds <- function (object, pathname, ...) 
[16:05:56.356]                   {
[16:05:56.356]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.356]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.356]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.356]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.356]                         fi_tmp[["mtime"]])
[16:05:56.356]                     }
[16:05:56.356]                     tryCatch({
[16:05:56.356]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.356]                     }, error = function(ex) {
[16:05:56.356]                       msg <- conditionMessage(ex)
[16:05:56.356]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.356]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.356]                         fi_tmp[["mtime"]], msg)
[16:05:56.356]                       ex$message <- msg
[16:05:56.356]                       stop(ex)
[16:05:56.356]                     })
[16:05:56.356]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.356]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.356]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.356]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.356]                       fi <- file.info(pathname)
[16:05:56.356]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.356]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.356]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.356]                         fi[["size"]], fi[["mtime"]])
[16:05:56.356]                       stop(msg)
[16:05:56.356]                     }
[16:05:56.356]                     invisible(pathname)
[16:05:56.356]                   }
[16:05:56.356]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.356]                     rootPath = tempdir()) 
[16:05:56.356]                   {
[16:05:56.356]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.356]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.356]                       tmpdir = path, fileext = ".rds")
[16:05:56.356]                     save_rds(obj, file)
[16:05:56.356]                   }
[16:05:56.356]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.356]                   {
[16:05:56.356]                     inherits <- base::inherits
[16:05:56.356]                     invokeRestart <- base::invokeRestart
[16:05:56.356]                     is.null <- base::is.null
[16:05:56.356]                     muffled <- FALSE
[16:05:56.356]                     if (inherits(cond, "message")) {
[16:05:56.356]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.356]                       if (muffled) 
[16:05:56.356]                         invokeRestart("muffleMessage")
[16:05:56.356]                     }
[16:05:56.356]                     else if (inherits(cond, "warning")) {
[16:05:56.356]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.356]                       if (muffled) 
[16:05:56.356]                         invokeRestart("muffleWarning")
[16:05:56.356]                     }
[16:05:56.356]                     else if (inherits(cond, "condition")) {
[16:05:56.356]                       if (!is.null(pattern)) {
[16:05:56.356]                         computeRestarts <- base::computeRestarts
[16:05:56.356]                         grepl <- base::grepl
[16:05:56.356]                         restarts <- computeRestarts(cond)
[16:05:56.356]                         for (restart in restarts) {
[16:05:56.356]                           name <- restart$name
[16:05:56.356]                           if (is.null(name)) 
[16:05:56.356]                             next
[16:05:56.356]                           if (!grepl(pattern, name)) 
[16:05:56.356]                             next
[16:05:56.356]                           invokeRestart(restart)
[16:05:56.356]                           muffled <- TRUE
[16:05:56.356]                           break
[16:05:56.356]                         }
[16:05:56.356]                       }
[16:05:56.356]                     }
[16:05:56.356]                     invisible(muffled)
[16:05:56.356]                   }
[16:05:56.356]                   muffleCondition(cond)
[16:05:56.356]                 })
[16:05:56.356]             }))
[16:05:56.356]             future::FutureResult(value = ...future.value$value, 
[16:05:56.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.356]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.356]                     ...future.globalenv.names))
[16:05:56.356]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.356]         }, condition = base::local({
[16:05:56.356]             c <- base::c
[16:05:56.356]             inherits <- base::inherits
[16:05:56.356]             invokeRestart <- base::invokeRestart
[16:05:56.356]             length <- base::length
[16:05:56.356]             list <- base::list
[16:05:56.356]             seq.int <- base::seq.int
[16:05:56.356]             signalCondition <- base::signalCondition
[16:05:56.356]             sys.calls <- base::sys.calls
[16:05:56.356]             `[[` <- base::`[[`
[16:05:56.356]             `+` <- base::`+`
[16:05:56.356]             `<<-` <- base::`<<-`
[16:05:56.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.356]                   3L)]
[16:05:56.356]             }
[16:05:56.356]             function(cond) {
[16:05:56.356]                 is_error <- inherits(cond, "error")
[16:05:56.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.356]                   NULL)
[16:05:56.356]                 if (is_error) {
[16:05:56.356]                   sessionInformation <- function() {
[16:05:56.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.356]                       search = base::search(), system = base::Sys.info())
[16:05:56.356]                   }
[16:05:56.356]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.356]                     cond$call), session = sessionInformation(), 
[16:05:56.356]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.356]                   signalCondition(cond)
[16:05:56.356]                 }
[16:05:56.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.356]                 "immediateCondition"))) {
[16:05:56.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.356]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.356]                   if (TRUE && !signal) {
[16:05:56.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.356]                     {
[16:05:56.356]                       inherits <- base::inherits
[16:05:56.356]                       invokeRestart <- base::invokeRestart
[16:05:56.356]                       is.null <- base::is.null
[16:05:56.356]                       muffled <- FALSE
[16:05:56.356]                       if (inherits(cond, "message")) {
[16:05:56.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.356]                         if (muffled) 
[16:05:56.356]                           invokeRestart("muffleMessage")
[16:05:56.356]                       }
[16:05:56.356]                       else if (inherits(cond, "warning")) {
[16:05:56.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.356]                         if (muffled) 
[16:05:56.356]                           invokeRestart("muffleWarning")
[16:05:56.356]                       }
[16:05:56.356]                       else if (inherits(cond, "condition")) {
[16:05:56.356]                         if (!is.null(pattern)) {
[16:05:56.356]                           computeRestarts <- base::computeRestarts
[16:05:56.356]                           grepl <- base::grepl
[16:05:56.356]                           restarts <- computeRestarts(cond)
[16:05:56.356]                           for (restart in restarts) {
[16:05:56.356]                             name <- restart$name
[16:05:56.356]                             if (is.null(name)) 
[16:05:56.356]                               next
[16:05:56.356]                             if (!grepl(pattern, name)) 
[16:05:56.356]                               next
[16:05:56.356]                             invokeRestart(restart)
[16:05:56.356]                             muffled <- TRUE
[16:05:56.356]                             break
[16:05:56.356]                           }
[16:05:56.356]                         }
[16:05:56.356]                       }
[16:05:56.356]                       invisible(muffled)
[16:05:56.356]                     }
[16:05:56.356]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.356]                   }
[16:05:56.356]                 }
[16:05:56.356]                 else {
[16:05:56.356]                   if (TRUE) {
[16:05:56.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.356]                     {
[16:05:56.356]                       inherits <- base::inherits
[16:05:56.356]                       invokeRestart <- base::invokeRestart
[16:05:56.356]                       is.null <- base::is.null
[16:05:56.356]                       muffled <- FALSE
[16:05:56.356]                       if (inherits(cond, "message")) {
[16:05:56.356]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.356]                         if (muffled) 
[16:05:56.356]                           invokeRestart("muffleMessage")
[16:05:56.356]                       }
[16:05:56.356]                       else if (inherits(cond, "warning")) {
[16:05:56.356]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.356]                         if (muffled) 
[16:05:56.356]                           invokeRestart("muffleWarning")
[16:05:56.356]                       }
[16:05:56.356]                       else if (inherits(cond, "condition")) {
[16:05:56.356]                         if (!is.null(pattern)) {
[16:05:56.356]                           computeRestarts <- base::computeRestarts
[16:05:56.356]                           grepl <- base::grepl
[16:05:56.356]                           restarts <- computeRestarts(cond)
[16:05:56.356]                           for (restart in restarts) {
[16:05:56.356]                             name <- restart$name
[16:05:56.356]                             if (is.null(name)) 
[16:05:56.356]                               next
[16:05:56.356]                             if (!grepl(pattern, name)) 
[16:05:56.356]                               next
[16:05:56.356]                             invokeRestart(restart)
[16:05:56.356]                             muffled <- TRUE
[16:05:56.356]                             break
[16:05:56.356]                           }
[16:05:56.356]                         }
[16:05:56.356]                       }
[16:05:56.356]                       invisible(muffled)
[16:05:56.356]                     }
[16:05:56.356]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.356]                   }
[16:05:56.356]                 }
[16:05:56.356]             }
[16:05:56.356]         }))
[16:05:56.356]     }, error = function(ex) {
[16:05:56.356]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.356]                 ...future.rng), started = ...future.startTime, 
[16:05:56.356]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.356]             version = "1.8"), class = "FutureResult")
[16:05:56.356]     }, finally = {
[16:05:56.356]         if (!identical(...future.workdir, getwd())) 
[16:05:56.356]             setwd(...future.workdir)
[16:05:56.356]         {
[16:05:56.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.356]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.356]             }
[16:05:56.356]             base::options(...future.oldOptions)
[16:05:56.356]             if (.Platform$OS.type == "windows") {
[16:05:56.356]                 old_names <- names(...future.oldEnvVars)
[16:05:56.356]                 envs <- base::Sys.getenv()
[16:05:56.356]                 names <- names(envs)
[16:05:56.356]                 common <- intersect(names, old_names)
[16:05:56.356]                 added <- setdiff(names, old_names)
[16:05:56.356]                 removed <- setdiff(old_names, names)
[16:05:56.356]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.356]                   envs[common]]
[16:05:56.356]                 NAMES <- toupper(changed)
[16:05:56.356]                 args <- list()
[16:05:56.356]                 for (kk in seq_along(NAMES)) {
[16:05:56.356]                   name <- changed[[kk]]
[16:05:56.356]                   NAME <- NAMES[[kk]]
[16:05:56.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.356]                     next
[16:05:56.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.356]                 }
[16:05:56.356]                 NAMES <- toupper(added)
[16:05:56.356]                 for (kk in seq_along(NAMES)) {
[16:05:56.356]                   name <- added[[kk]]
[16:05:56.356]                   NAME <- NAMES[[kk]]
[16:05:56.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.356]                     next
[16:05:56.356]                   args[[name]] <- ""
[16:05:56.356]                 }
[16:05:56.356]                 NAMES <- toupper(removed)
[16:05:56.356]                 for (kk in seq_along(NAMES)) {
[16:05:56.356]                   name <- removed[[kk]]
[16:05:56.356]                   NAME <- NAMES[[kk]]
[16:05:56.356]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.356]                     next
[16:05:56.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.356]                 }
[16:05:56.356]                 if (length(args) > 0) 
[16:05:56.356]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.356]             }
[16:05:56.356]             else {
[16:05:56.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.356]             }
[16:05:56.356]             {
[16:05:56.356]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.356]                   0L) {
[16:05:56.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.356]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.356]                   base::options(opts)
[16:05:56.356]                 }
[16:05:56.356]                 {
[16:05:56.356]                   {
[16:05:56.356]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.356]                     NULL
[16:05:56.356]                   }
[16:05:56.356]                   options(future.plan = NULL)
[16:05:56.356]                   if (is.na(NA_character_)) 
[16:05:56.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.356]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.356]                     envir = parent.frame()) 
[16:05:56.356]                   {
[16:05:56.356]                     default_workers <- missing(workers)
[16:05:56.356]                     if (is.function(workers)) 
[16:05:56.356]                       workers <- workers()
[16:05:56.356]                     workers <- structure(as.integer(workers), 
[16:05:56.356]                       class = class(workers))
[16:05:56.356]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.356]                       1L)
[16:05:56.356]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.356]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.356]                       if (default_workers) 
[16:05:56.356]                         supportsMulticore(warn = TRUE)
[16:05:56.356]                       return(sequential(..., envir = envir))
[16:05:56.356]                     }
[16:05:56.356]                     oopts <- options(mc.cores = workers)
[16:05:56.356]                     on.exit(options(oopts))
[16:05:56.356]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.356]                       envir = envir)
[16:05:56.356]                     if (!future$lazy) 
[16:05:56.356]                       future <- run(future)
[16:05:56.356]                     invisible(future)
[16:05:56.356]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.356]                 }
[16:05:56.356]             }
[16:05:56.356]         }
[16:05:56.356]     })
[16:05:56.356]     if (TRUE) {
[16:05:56.356]         base::sink(type = "output", split = FALSE)
[16:05:56.356]         if (TRUE) {
[16:05:56.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.356]         }
[16:05:56.356]         else {
[16:05:56.356]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.356]         }
[16:05:56.356]         base::close(...future.stdout)
[16:05:56.356]         ...future.stdout <- NULL
[16:05:56.356]     }
[16:05:56.356]     ...future.result$conditions <- ...future.conditions
[16:05:56.356]     ...future.result$finished <- base::Sys.time()
[16:05:56.356]     ...future.result
[16:05:56.356] }
[16:05:56.359] assign_globals() ...
[16:05:56.359] List of 1
[16:05:56.359]  $ kk: int 1
[16:05:56.359]  - attr(*, "where")=List of 1
[16:05:56.359]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:56.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:56.359]  - attr(*, "resolved")= logi FALSE
[16:05:56.359]  - attr(*, "total_size")= num 56
[16:05:56.359]  - attr(*, "already-done")= logi TRUE
[16:05:56.363] - copied ‘kk’ to environment
[16:05:56.363] assign_globals() ... done
[16:05:56.364] requestCore(): workers = 2
[16:05:56.364] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.375] result() for MulticoreFuture ...
[16:05:56.376] result() for MulticoreFuture ...
[16:05:56.376] result() for MulticoreFuture ... done
[16:05:56.376] result() for MulticoreFuture ... done
[16:05:56.376] result() for MulticoreFuture ...
[16:05:56.376] result() for MulticoreFuture ... done
[16:05:56.378] MulticoreFuture started
[16:05:56.379] - Launch lazy future ... done
[16:05:56.379] run() for ‘MulticoreFuture’ ... done
[16:05:56.380] getGlobalsAndPackages() ...
[16:05:56.380] plan(): Setting new future strategy stack:
[16:05:56.380] Searching for globals...
[16:05:56.380] List of future strategies:
[16:05:56.380] 1. sequential:
[16:05:56.380]    - args: function (..., envir = parent.frame())
[16:05:56.380]    - tweaked: FALSE
[16:05:56.380]    - call: NULL
[16:05:56.381] plan(): nbrOfWorkers() = 1
[16:05:56.383] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:56.383] Searching for globals ... DONE
[16:05:56.384] Resolving globals: FALSE
[16:05:56.384] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:56.385] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:56.385] - globals: [1] ‘kk’
[16:05:56.385] 
[16:05:56.385] getGlobalsAndPackages() ... DONE
[16:05:56.386] run() for ‘Future’ ...
[16:05:56.386] - state: ‘created’
[16:05:56.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.392] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.392]   - Field: ‘label’
[16:05:56.393]   - Field: ‘local’
[16:05:56.393]   - Field: ‘owner’
[16:05:56.393]   - Field: ‘envir’
[16:05:56.393]   - Field: ‘workers’
[16:05:56.393]   - Field: ‘packages’
[16:05:56.393]   - Field: ‘gc’
[16:05:56.393]   - Field: ‘job’
[16:05:56.394]   - Field: ‘conditions’
[16:05:56.394]   - Field: ‘expr’
[16:05:56.394]   - Field: ‘uuid’
[16:05:56.394]   - Field: ‘seed’
[16:05:56.394]   - Field: ‘version’
[16:05:56.394]   - Field: ‘result’
[16:05:56.394]   - Field: ‘asynchronous’
[16:05:56.395]   - Field: ‘calls’
[16:05:56.395]   - Field: ‘globals’
[16:05:56.395]   - Field: ‘stdout’
[16:05:56.395]   - Field: ‘earlySignal’
[16:05:56.395]   - Field: ‘lazy’
[16:05:56.395]   - Field: ‘state’
[16:05:56.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.396] - Launch lazy future ...
[16:05:56.396] Packages needed by the future expression (n = 0): <none>
[16:05:56.396] Packages needed by future strategies (n = 0): <none>
[16:05:56.397] {
[16:05:56.397]     {
[16:05:56.397]         {
[16:05:56.397]             ...future.startTime <- base::Sys.time()
[16:05:56.397]             {
[16:05:56.397]                 {
[16:05:56.397]                   {
[16:05:56.397]                     {
[16:05:56.397]                       base::local({
[16:05:56.397]                         has_future <- base::requireNamespace("future", 
[16:05:56.397]                           quietly = TRUE)
[16:05:56.397]                         if (has_future) {
[16:05:56.397]                           ns <- base::getNamespace("future")
[16:05:56.397]                           version <- ns[[".package"]][["version"]]
[16:05:56.397]                           if (is.null(version)) 
[16:05:56.397]                             version <- utils::packageVersion("future")
[16:05:56.397]                         }
[16:05:56.397]                         else {
[16:05:56.397]                           version <- NULL
[16:05:56.397]                         }
[16:05:56.397]                         if (!has_future || version < "1.8.0") {
[16:05:56.397]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.397]                             "", base::R.version$version.string), 
[16:05:56.397]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.397]                               "release", "version")], collapse = " "), 
[16:05:56.397]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.397]                             info)
[16:05:56.397]                           info <- base::paste(info, collapse = "; ")
[16:05:56.397]                           if (!has_future) {
[16:05:56.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.397]                               info)
[16:05:56.397]                           }
[16:05:56.397]                           else {
[16:05:56.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.397]                               info, version)
[16:05:56.397]                           }
[16:05:56.397]                           base::stop(msg)
[16:05:56.397]                         }
[16:05:56.397]                       })
[16:05:56.397]                     }
[16:05:56.397]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.397]                     base::options(mc.cores = 1L)
[16:05:56.397]                   }
[16:05:56.397]                   options(future.plan = NULL)
[16:05:56.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.397]                 }
[16:05:56.397]                 ...future.workdir <- getwd()
[16:05:56.397]             }
[16:05:56.397]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.397]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.397]         }
[16:05:56.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.397]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.397]             base::names(...future.oldOptions))
[16:05:56.397]     }
[16:05:56.397]     if (FALSE) {
[16:05:56.397]     }
[16:05:56.397]     else {
[16:05:56.397]         if (TRUE) {
[16:05:56.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.397]                 open = "w")
[16:05:56.397]         }
[16:05:56.397]         else {
[16:05:56.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.397]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.397]         }
[16:05:56.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.397]             base::sink(type = "output", split = FALSE)
[16:05:56.397]             base::close(...future.stdout)
[16:05:56.397]         }, add = TRUE)
[16:05:56.397]     }
[16:05:56.397]     ...future.frame <- base::sys.nframe()
[16:05:56.397]     ...future.conditions <- base::list()
[16:05:56.397]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.397]     if (FALSE) {
[16:05:56.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.397]     }
[16:05:56.397]     ...future.result <- base::tryCatch({
[16:05:56.397]         base::withCallingHandlers({
[16:05:56.397]             ...future.value <- base::withVisible(base::local({
[16:05:56.397]                 withCallingHandlers({
[16:05:56.397]                   {
[16:05:56.397]                     Sys.sleep(0.1)
[16:05:56.397]                     kk
[16:05:56.397]                   }
[16:05:56.397]                 }, immediateCondition = function(cond) {
[16:05:56.397]                   save_rds <- function (object, pathname, ...) 
[16:05:56.397]                   {
[16:05:56.397]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.397]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.397]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.397]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.397]                         fi_tmp[["mtime"]])
[16:05:56.397]                     }
[16:05:56.397]                     tryCatch({
[16:05:56.397]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.397]                     }, error = function(ex) {
[16:05:56.397]                       msg <- conditionMessage(ex)
[16:05:56.397]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.397]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.397]                         fi_tmp[["mtime"]], msg)
[16:05:56.397]                       ex$message <- msg
[16:05:56.397]                       stop(ex)
[16:05:56.397]                     })
[16:05:56.397]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.397]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.397]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.397]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.397]                       fi <- file.info(pathname)
[16:05:56.397]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.397]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.397]                         fi[["size"]], fi[["mtime"]])
[16:05:56.397]                       stop(msg)
[16:05:56.397]                     }
[16:05:56.397]                     invisible(pathname)
[16:05:56.397]                   }
[16:05:56.397]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.397]                     rootPath = tempdir()) 
[16:05:56.397]                   {
[16:05:56.397]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.397]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.397]                       tmpdir = path, fileext = ".rds")
[16:05:56.397]                     save_rds(obj, file)
[16:05:56.397]                   }
[16:05:56.397]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.397]                   {
[16:05:56.397]                     inherits <- base::inherits
[16:05:56.397]                     invokeRestart <- base::invokeRestart
[16:05:56.397]                     is.null <- base::is.null
[16:05:56.397]                     muffled <- FALSE
[16:05:56.397]                     if (inherits(cond, "message")) {
[16:05:56.397]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.397]                       if (muffled) 
[16:05:56.397]                         invokeRestart("muffleMessage")
[16:05:56.397]                     }
[16:05:56.397]                     else if (inherits(cond, "warning")) {
[16:05:56.397]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.397]                       if (muffled) 
[16:05:56.397]                         invokeRestart("muffleWarning")
[16:05:56.397]                     }
[16:05:56.397]                     else if (inherits(cond, "condition")) {
[16:05:56.397]                       if (!is.null(pattern)) {
[16:05:56.397]                         computeRestarts <- base::computeRestarts
[16:05:56.397]                         grepl <- base::grepl
[16:05:56.397]                         restarts <- computeRestarts(cond)
[16:05:56.397]                         for (restart in restarts) {
[16:05:56.397]                           name <- restart$name
[16:05:56.397]                           if (is.null(name)) 
[16:05:56.397]                             next
[16:05:56.397]                           if (!grepl(pattern, name)) 
[16:05:56.397]                             next
[16:05:56.397]                           invokeRestart(restart)
[16:05:56.397]                           muffled <- TRUE
[16:05:56.397]                           break
[16:05:56.397]                         }
[16:05:56.397]                       }
[16:05:56.397]                     }
[16:05:56.397]                     invisible(muffled)
[16:05:56.397]                   }
[16:05:56.397]                   muffleCondition(cond)
[16:05:56.397]                 })
[16:05:56.397]             }))
[16:05:56.397]             future::FutureResult(value = ...future.value$value, 
[16:05:56.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.397]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.397]                     ...future.globalenv.names))
[16:05:56.397]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.397]         }, condition = base::local({
[16:05:56.397]             c <- base::c
[16:05:56.397]             inherits <- base::inherits
[16:05:56.397]             invokeRestart <- base::invokeRestart
[16:05:56.397]             length <- base::length
[16:05:56.397]             list <- base::list
[16:05:56.397]             seq.int <- base::seq.int
[16:05:56.397]             signalCondition <- base::signalCondition
[16:05:56.397]             sys.calls <- base::sys.calls
[16:05:56.397]             `[[` <- base::`[[`
[16:05:56.397]             `+` <- base::`+`
[16:05:56.397]             `<<-` <- base::`<<-`
[16:05:56.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.397]                   3L)]
[16:05:56.397]             }
[16:05:56.397]             function(cond) {
[16:05:56.397]                 is_error <- inherits(cond, "error")
[16:05:56.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.397]                   NULL)
[16:05:56.397]                 if (is_error) {
[16:05:56.397]                   sessionInformation <- function() {
[16:05:56.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.397]                       search = base::search(), system = base::Sys.info())
[16:05:56.397]                   }
[16:05:56.397]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.397]                     cond$call), session = sessionInformation(), 
[16:05:56.397]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.397]                   signalCondition(cond)
[16:05:56.397]                 }
[16:05:56.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.397]                 "immediateCondition"))) {
[16:05:56.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.397]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.397]                   if (TRUE && !signal) {
[16:05:56.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.397]                     {
[16:05:56.397]                       inherits <- base::inherits
[16:05:56.397]                       invokeRestart <- base::invokeRestart
[16:05:56.397]                       is.null <- base::is.null
[16:05:56.397]                       muffled <- FALSE
[16:05:56.397]                       if (inherits(cond, "message")) {
[16:05:56.397]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.397]                         if (muffled) 
[16:05:56.397]                           invokeRestart("muffleMessage")
[16:05:56.397]                       }
[16:05:56.397]                       else if (inherits(cond, "warning")) {
[16:05:56.397]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.397]                         if (muffled) 
[16:05:56.397]                           invokeRestart("muffleWarning")
[16:05:56.397]                       }
[16:05:56.397]                       else if (inherits(cond, "condition")) {
[16:05:56.397]                         if (!is.null(pattern)) {
[16:05:56.397]                           computeRestarts <- base::computeRestarts
[16:05:56.397]                           grepl <- base::grepl
[16:05:56.397]                           restarts <- computeRestarts(cond)
[16:05:56.397]                           for (restart in restarts) {
[16:05:56.397]                             name <- restart$name
[16:05:56.397]                             if (is.null(name)) 
[16:05:56.397]                               next
[16:05:56.397]                             if (!grepl(pattern, name)) 
[16:05:56.397]                               next
[16:05:56.397]                             invokeRestart(restart)
[16:05:56.397]                             muffled <- TRUE
[16:05:56.397]                             break
[16:05:56.397]                           }
[16:05:56.397]                         }
[16:05:56.397]                       }
[16:05:56.397]                       invisible(muffled)
[16:05:56.397]                     }
[16:05:56.397]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.397]                   }
[16:05:56.397]                 }
[16:05:56.397]                 else {
[16:05:56.397]                   if (TRUE) {
[16:05:56.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.397]                     {
[16:05:56.397]                       inherits <- base::inherits
[16:05:56.397]                       invokeRestart <- base::invokeRestart
[16:05:56.397]                       is.null <- base::is.null
[16:05:56.397]                       muffled <- FALSE
[16:05:56.397]                       if (inherits(cond, "message")) {
[16:05:56.397]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.397]                         if (muffled) 
[16:05:56.397]                           invokeRestart("muffleMessage")
[16:05:56.397]                       }
[16:05:56.397]                       else if (inherits(cond, "warning")) {
[16:05:56.397]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.397]                         if (muffled) 
[16:05:56.397]                           invokeRestart("muffleWarning")
[16:05:56.397]                       }
[16:05:56.397]                       else if (inherits(cond, "condition")) {
[16:05:56.397]                         if (!is.null(pattern)) {
[16:05:56.397]                           computeRestarts <- base::computeRestarts
[16:05:56.397]                           grepl <- base::grepl
[16:05:56.397]                           restarts <- computeRestarts(cond)
[16:05:56.397]                           for (restart in restarts) {
[16:05:56.397]                             name <- restart$name
[16:05:56.397]                             if (is.null(name)) 
[16:05:56.397]                               next
[16:05:56.397]                             if (!grepl(pattern, name)) 
[16:05:56.397]                               next
[16:05:56.397]                             invokeRestart(restart)
[16:05:56.397]                             muffled <- TRUE
[16:05:56.397]                             break
[16:05:56.397]                           }
[16:05:56.397]                         }
[16:05:56.397]                       }
[16:05:56.397]                       invisible(muffled)
[16:05:56.397]                     }
[16:05:56.397]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.397]                   }
[16:05:56.397]                 }
[16:05:56.397]             }
[16:05:56.397]         }))
[16:05:56.397]     }, error = function(ex) {
[16:05:56.397]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.397]                 ...future.rng), started = ...future.startTime, 
[16:05:56.397]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.397]             version = "1.8"), class = "FutureResult")
[16:05:56.397]     }, finally = {
[16:05:56.397]         if (!identical(...future.workdir, getwd())) 
[16:05:56.397]             setwd(...future.workdir)
[16:05:56.397]         {
[16:05:56.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.397]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.397]             }
[16:05:56.397]             base::options(...future.oldOptions)
[16:05:56.397]             if (.Platform$OS.type == "windows") {
[16:05:56.397]                 old_names <- names(...future.oldEnvVars)
[16:05:56.397]                 envs <- base::Sys.getenv()
[16:05:56.397]                 names <- names(envs)
[16:05:56.397]                 common <- intersect(names, old_names)
[16:05:56.397]                 added <- setdiff(names, old_names)
[16:05:56.397]                 removed <- setdiff(old_names, names)
[16:05:56.397]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.397]                   envs[common]]
[16:05:56.397]                 NAMES <- toupper(changed)
[16:05:56.397]                 args <- list()
[16:05:56.397]                 for (kk in seq_along(NAMES)) {
[16:05:56.397]                   name <- changed[[kk]]
[16:05:56.397]                   NAME <- NAMES[[kk]]
[16:05:56.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.397]                     next
[16:05:56.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.397]                 }
[16:05:56.397]                 NAMES <- toupper(added)
[16:05:56.397]                 for (kk in seq_along(NAMES)) {
[16:05:56.397]                   name <- added[[kk]]
[16:05:56.397]                   NAME <- NAMES[[kk]]
[16:05:56.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.397]                     next
[16:05:56.397]                   args[[name]] <- ""
[16:05:56.397]                 }
[16:05:56.397]                 NAMES <- toupper(removed)
[16:05:56.397]                 for (kk in seq_along(NAMES)) {
[16:05:56.397]                   name <- removed[[kk]]
[16:05:56.397]                   NAME <- NAMES[[kk]]
[16:05:56.397]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.397]                     next
[16:05:56.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.397]                 }
[16:05:56.397]                 if (length(args) > 0) 
[16:05:56.397]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.397]             }
[16:05:56.397]             else {
[16:05:56.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.397]             }
[16:05:56.397]             {
[16:05:56.397]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.397]                   0L) {
[16:05:56.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.397]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.397]                   base::options(opts)
[16:05:56.397]                 }
[16:05:56.397]                 {
[16:05:56.397]                   {
[16:05:56.397]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.397]                     NULL
[16:05:56.397]                   }
[16:05:56.397]                   options(future.plan = NULL)
[16:05:56.397]                   if (is.na(NA_character_)) 
[16:05:56.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.397]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.397]                     envir = parent.frame()) 
[16:05:56.397]                   {
[16:05:56.397]                     default_workers <- missing(workers)
[16:05:56.397]                     if (is.function(workers)) 
[16:05:56.397]                       workers <- workers()
[16:05:56.397]                     workers <- structure(as.integer(workers), 
[16:05:56.397]                       class = class(workers))
[16:05:56.397]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.397]                       1L)
[16:05:56.397]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.397]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.397]                       if (default_workers) 
[16:05:56.397]                         supportsMulticore(warn = TRUE)
[16:05:56.397]                       return(sequential(..., envir = envir))
[16:05:56.397]                     }
[16:05:56.397]                     oopts <- options(mc.cores = workers)
[16:05:56.397]                     on.exit(options(oopts))
[16:05:56.397]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.397]                       envir = envir)
[16:05:56.397]                     if (!future$lazy) 
[16:05:56.397]                       future <- run(future)
[16:05:56.397]                     invisible(future)
[16:05:56.397]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.397]                 }
[16:05:56.397]             }
[16:05:56.397]         }
[16:05:56.397]     })
[16:05:56.397]     if (TRUE) {
[16:05:56.397]         base::sink(type = "output", split = FALSE)
[16:05:56.397]         if (TRUE) {
[16:05:56.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.397]         }
[16:05:56.397]         else {
[16:05:56.397]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.397]         }
[16:05:56.397]         base::close(...future.stdout)
[16:05:56.397]         ...future.stdout <- NULL
[16:05:56.397]     }
[16:05:56.397]     ...future.result$conditions <- ...future.conditions
[16:05:56.397]     ...future.result$finished <- base::Sys.time()
[16:05:56.397]     ...future.result
[16:05:56.397] }
[16:05:56.400] assign_globals() ...
[16:05:56.401] List of 1
[16:05:56.401]  $ kk: int 2
[16:05:56.401]  - attr(*, "where")=List of 1
[16:05:56.401]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:56.401]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:56.401]  - attr(*, "resolved")= logi FALSE
[16:05:56.401]  - attr(*, "total_size")= num 56
[16:05:56.401]  - attr(*, "already-done")= logi TRUE
[16:05:56.404] - copied ‘kk’ to environment
[16:05:56.405] assign_globals() ... done
[16:05:56.405] requestCore(): workers = 2
[16:05:56.405] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.416] result() for MulticoreFuture ...
[16:05:56.416] result() for MulticoreFuture ...
[16:05:56.417] result() for MulticoreFuture ... done
[16:05:56.417] result() for MulticoreFuture ... done
[16:05:56.417] result() for MulticoreFuture ...
[16:05:56.417] result() for MulticoreFuture ... done
[16:05:56.419] MulticoreFuture started
[16:05:56.420] - Launch lazy future ... done
[16:05:56.420] run() for ‘MulticoreFuture’ ... done
[16:05:56.420] getGlobalsAndPackages() ...
[16:05:56.420] plan(): Setting new future strategy stack:
[16:05:56.421] Searching for globals...
[16:05:56.421] List of future strategies:
[16:05:56.421] 1. sequential:
[16:05:56.421]    - args: function (..., envir = parent.frame())
[16:05:56.421]    - tweaked: FALSE
[16:05:56.421]    - call: NULL
[16:05:56.422] plan(): nbrOfWorkers() = 1
[16:05:56.423] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:56.424] Searching for globals ... DONE
[16:05:56.424] Resolving globals: FALSE
[16:05:56.425] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:56.425] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:56.426] - globals: [1] ‘kk’
[16:05:56.426] 
[16:05:56.426] getGlobalsAndPackages() ... DONE
[16:05:56.426] run() for ‘Future’ ...
[16:05:56.426] - state: ‘created’
[16:05:56.427] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.432] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.432]   - Field: ‘label’
[16:05:56.436]   - Field: ‘local’
[16:05:56.437]   - Field: ‘owner’
[16:05:56.437]   - Field: ‘envir’
[16:05:56.437]   - Field: ‘workers’
[16:05:56.437]   - Field: ‘packages’
[16:05:56.438]   - Field: ‘gc’
[16:05:56.438]   - Field: ‘job’
[16:05:56.438]   - Field: ‘conditions’
[16:05:56.439]   - Field: ‘expr’
[16:05:56.439]   - Field: ‘uuid’
[16:05:56.439]   - Field: ‘seed’
[16:05:56.439]   - Field: ‘version’
[16:05:56.440]   - Field: ‘result’
[16:05:56.440]   - Field: ‘asynchronous’
[16:05:56.440]   - Field: ‘calls’
[16:05:56.440]   - Field: ‘globals’
[16:05:56.441]   - Field: ‘stdout’
[16:05:56.441]   - Field: ‘earlySignal’
[16:05:56.441]   - Field: ‘lazy’
[16:05:56.441]   - Field: ‘state’
[16:05:56.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.442] - Launch lazy future ...
[16:05:56.443] Packages needed by the future expression (n = 0): <none>
[16:05:56.443] Packages needed by future strategies (n = 0): <none>
[16:05:56.444] {
[16:05:56.444]     {
[16:05:56.444]         {
[16:05:56.444]             ...future.startTime <- base::Sys.time()
[16:05:56.444]             {
[16:05:56.444]                 {
[16:05:56.444]                   {
[16:05:56.444]                     {
[16:05:56.444]                       base::local({
[16:05:56.444]                         has_future <- base::requireNamespace("future", 
[16:05:56.444]                           quietly = TRUE)
[16:05:56.444]                         if (has_future) {
[16:05:56.444]                           ns <- base::getNamespace("future")
[16:05:56.444]                           version <- ns[[".package"]][["version"]]
[16:05:56.444]                           if (is.null(version)) 
[16:05:56.444]                             version <- utils::packageVersion("future")
[16:05:56.444]                         }
[16:05:56.444]                         else {
[16:05:56.444]                           version <- NULL
[16:05:56.444]                         }
[16:05:56.444]                         if (!has_future || version < "1.8.0") {
[16:05:56.444]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.444]                             "", base::R.version$version.string), 
[16:05:56.444]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.444]                               "release", "version")], collapse = " "), 
[16:05:56.444]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.444]                             info)
[16:05:56.444]                           info <- base::paste(info, collapse = "; ")
[16:05:56.444]                           if (!has_future) {
[16:05:56.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.444]                               info)
[16:05:56.444]                           }
[16:05:56.444]                           else {
[16:05:56.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.444]                               info, version)
[16:05:56.444]                           }
[16:05:56.444]                           base::stop(msg)
[16:05:56.444]                         }
[16:05:56.444]                       })
[16:05:56.444]                     }
[16:05:56.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.444]                     base::options(mc.cores = 1L)
[16:05:56.444]                   }
[16:05:56.444]                   options(future.plan = NULL)
[16:05:56.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.444]                 }
[16:05:56.444]                 ...future.workdir <- getwd()
[16:05:56.444]             }
[16:05:56.444]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.444]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.444]         }
[16:05:56.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.444]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.444]             base::names(...future.oldOptions))
[16:05:56.444]     }
[16:05:56.444]     if (FALSE) {
[16:05:56.444]     }
[16:05:56.444]     else {
[16:05:56.444]         if (TRUE) {
[16:05:56.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.444]                 open = "w")
[16:05:56.444]         }
[16:05:56.444]         else {
[16:05:56.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.444]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.444]         }
[16:05:56.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.444]             base::sink(type = "output", split = FALSE)
[16:05:56.444]             base::close(...future.stdout)
[16:05:56.444]         }, add = TRUE)
[16:05:56.444]     }
[16:05:56.444]     ...future.frame <- base::sys.nframe()
[16:05:56.444]     ...future.conditions <- base::list()
[16:05:56.444]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.444]     if (FALSE) {
[16:05:56.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.444]     }
[16:05:56.444]     ...future.result <- base::tryCatch({
[16:05:56.444]         base::withCallingHandlers({
[16:05:56.444]             ...future.value <- base::withVisible(base::local({
[16:05:56.444]                 withCallingHandlers({
[16:05:56.444]                   {
[16:05:56.444]                     Sys.sleep(0.1)
[16:05:56.444]                     kk
[16:05:56.444]                   }
[16:05:56.444]                 }, immediateCondition = function(cond) {
[16:05:56.444]                   save_rds <- function (object, pathname, ...) 
[16:05:56.444]                   {
[16:05:56.444]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.444]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.444]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.444]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.444]                         fi_tmp[["mtime"]])
[16:05:56.444]                     }
[16:05:56.444]                     tryCatch({
[16:05:56.444]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.444]                     }, error = function(ex) {
[16:05:56.444]                       msg <- conditionMessage(ex)
[16:05:56.444]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.444]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.444]                         fi_tmp[["mtime"]], msg)
[16:05:56.444]                       ex$message <- msg
[16:05:56.444]                       stop(ex)
[16:05:56.444]                     })
[16:05:56.444]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.444]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.444]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.444]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.444]                       fi <- file.info(pathname)
[16:05:56.444]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.444]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.444]                         fi[["size"]], fi[["mtime"]])
[16:05:56.444]                       stop(msg)
[16:05:56.444]                     }
[16:05:56.444]                     invisible(pathname)
[16:05:56.444]                   }
[16:05:56.444]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.444]                     rootPath = tempdir()) 
[16:05:56.444]                   {
[16:05:56.444]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.444]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.444]                       tmpdir = path, fileext = ".rds")
[16:05:56.444]                     save_rds(obj, file)
[16:05:56.444]                   }
[16:05:56.444]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.444]                   {
[16:05:56.444]                     inherits <- base::inherits
[16:05:56.444]                     invokeRestart <- base::invokeRestart
[16:05:56.444]                     is.null <- base::is.null
[16:05:56.444]                     muffled <- FALSE
[16:05:56.444]                     if (inherits(cond, "message")) {
[16:05:56.444]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.444]                       if (muffled) 
[16:05:56.444]                         invokeRestart("muffleMessage")
[16:05:56.444]                     }
[16:05:56.444]                     else if (inherits(cond, "warning")) {
[16:05:56.444]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.444]                       if (muffled) 
[16:05:56.444]                         invokeRestart("muffleWarning")
[16:05:56.444]                     }
[16:05:56.444]                     else if (inherits(cond, "condition")) {
[16:05:56.444]                       if (!is.null(pattern)) {
[16:05:56.444]                         computeRestarts <- base::computeRestarts
[16:05:56.444]                         grepl <- base::grepl
[16:05:56.444]                         restarts <- computeRestarts(cond)
[16:05:56.444]                         for (restart in restarts) {
[16:05:56.444]                           name <- restart$name
[16:05:56.444]                           if (is.null(name)) 
[16:05:56.444]                             next
[16:05:56.444]                           if (!grepl(pattern, name)) 
[16:05:56.444]                             next
[16:05:56.444]                           invokeRestart(restart)
[16:05:56.444]                           muffled <- TRUE
[16:05:56.444]                           break
[16:05:56.444]                         }
[16:05:56.444]                       }
[16:05:56.444]                     }
[16:05:56.444]                     invisible(muffled)
[16:05:56.444]                   }
[16:05:56.444]                   muffleCondition(cond)
[16:05:56.444]                 })
[16:05:56.444]             }))
[16:05:56.444]             future::FutureResult(value = ...future.value$value, 
[16:05:56.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.444]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.444]                     ...future.globalenv.names))
[16:05:56.444]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.444]         }, condition = base::local({
[16:05:56.444]             c <- base::c
[16:05:56.444]             inherits <- base::inherits
[16:05:56.444]             invokeRestart <- base::invokeRestart
[16:05:56.444]             length <- base::length
[16:05:56.444]             list <- base::list
[16:05:56.444]             seq.int <- base::seq.int
[16:05:56.444]             signalCondition <- base::signalCondition
[16:05:56.444]             sys.calls <- base::sys.calls
[16:05:56.444]             `[[` <- base::`[[`
[16:05:56.444]             `+` <- base::`+`
[16:05:56.444]             `<<-` <- base::`<<-`
[16:05:56.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.444]                   3L)]
[16:05:56.444]             }
[16:05:56.444]             function(cond) {
[16:05:56.444]                 is_error <- inherits(cond, "error")
[16:05:56.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.444]                   NULL)
[16:05:56.444]                 if (is_error) {
[16:05:56.444]                   sessionInformation <- function() {
[16:05:56.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.444]                       search = base::search(), system = base::Sys.info())
[16:05:56.444]                   }
[16:05:56.444]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.444]                     cond$call), session = sessionInformation(), 
[16:05:56.444]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.444]                   signalCondition(cond)
[16:05:56.444]                 }
[16:05:56.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.444]                 "immediateCondition"))) {
[16:05:56.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.444]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.444]                   if (TRUE && !signal) {
[16:05:56.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.444]                     {
[16:05:56.444]                       inherits <- base::inherits
[16:05:56.444]                       invokeRestart <- base::invokeRestart
[16:05:56.444]                       is.null <- base::is.null
[16:05:56.444]                       muffled <- FALSE
[16:05:56.444]                       if (inherits(cond, "message")) {
[16:05:56.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.444]                         if (muffled) 
[16:05:56.444]                           invokeRestart("muffleMessage")
[16:05:56.444]                       }
[16:05:56.444]                       else if (inherits(cond, "warning")) {
[16:05:56.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.444]                         if (muffled) 
[16:05:56.444]                           invokeRestart("muffleWarning")
[16:05:56.444]                       }
[16:05:56.444]                       else if (inherits(cond, "condition")) {
[16:05:56.444]                         if (!is.null(pattern)) {
[16:05:56.444]                           computeRestarts <- base::computeRestarts
[16:05:56.444]                           grepl <- base::grepl
[16:05:56.444]                           restarts <- computeRestarts(cond)
[16:05:56.444]                           for (restart in restarts) {
[16:05:56.444]                             name <- restart$name
[16:05:56.444]                             if (is.null(name)) 
[16:05:56.444]                               next
[16:05:56.444]                             if (!grepl(pattern, name)) 
[16:05:56.444]                               next
[16:05:56.444]                             invokeRestart(restart)
[16:05:56.444]                             muffled <- TRUE
[16:05:56.444]                             break
[16:05:56.444]                           }
[16:05:56.444]                         }
[16:05:56.444]                       }
[16:05:56.444]                       invisible(muffled)
[16:05:56.444]                     }
[16:05:56.444]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.444]                   }
[16:05:56.444]                 }
[16:05:56.444]                 else {
[16:05:56.444]                   if (TRUE) {
[16:05:56.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.444]                     {
[16:05:56.444]                       inherits <- base::inherits
[16:05:56.444]                       invokeRestart <- base::invokeRestart
[16:05:56.444]                       is.null <- base::is.null
[16:05:56.444]                       muffled <- FALSE
[16:05:56.444]                       if (inherits(cond, "message")) {
[16:05:56.444]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.444]                         if (muffled) 
[16:05:56.444]                           invokeRestart("muffleMessage")
[16:05:56.444]                       }
[16:05:56.444]                       else if (inherits(cond, "warning")) {
[16:05:56.444]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.444]                         if (muffled) 
[16:05:56.444]                           invokeRestart("muffleWarning")
[16:05:56.444]                       }
[16:05:56.444]                       else if (inherits(cond, "condition")) {
[16:05:56.444]                         if (!is.null(pattern)) {
[16:05:56.444]                           computeRestarts <- base::computeRestarts
[16:05:56.444]                           grepl <- base::grepl
[16:05:56.444]                           restarts <- computeRestarts(cond)
[16:05:56.444]                           for (restart in restarts) {
[16:05:56.444]                             name <- restart$name
[16:05:56.444]                             if (is.null(name)) 
[16:05:56.444]                               next
[16:05:56.444]                             if (!grepl(pattern, name)) 
[16:05:56.444]                               next
[16:05:56.444]                             invokeRestart(restart)
[16:05:56.444]                             muffled <- TRUE
[16:05:56.444]                             break
[16:05:56.444]                           }
[16:05:56.444]                         }
[16:05:56.444]                       }
[16:05:56.444]                       invisible(muffled)
[16:05:56.444]                     }
[16:05:56.444]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.444]                   }
[16:05:56.444]                 }
[16:05:56.444]             }
[16:05:56.444]         }))
[16:05:56.444]     }, error = function(ex) {
[16:05:56.444]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.444]                 ...future.rng), started = ...future.startTime, 
[16:05:56.444]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.444]             version = "1.8"), class = "FutureResult")
[16:05:56.444]     }, finally = {
[16:05:56.444]         if (!identical(...future.workdir, getwd())) 
[16:05:56.444]             setwd(...future.workdir)
[16:05:56.444]         {
[16:05:56.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.444]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.444]             }
[16:05:56.444]             base::options(...future.oldOptions)
[16:05:56.444]             if (.Platform$OS.type == "windows") {
[16:05:56.444]                 old_names <- names(...future.oldEnvVars)
[16:05:56.444]                 envs <- base::Sys.getenv()
[16:05:56.444]                 names <- names(envs)
[16:05:56.444]                 common <- intersect(names, old_names)
[16:05:56.444]                 added <- setdiff(names, old_names)
[16:05:56.444]                 removed <- setdiff(old_names, names)
[16:05:56.444]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.444]                   envs[common]]
[16:05:56.444]                 NAMES <- toupper(changed)
[16:05:56.444]                 args <- list()
[16:05:56.444]                 for (kk in seq_along(NAMES)) {
[16:05:56.444]                   name <- changed[[kk]]
[16:05:56.444]                   NAME <- NAMES[[kk]]
[16:05:56.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.444]                     next
[16:05:56.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.444]                 }
[16:05:56.444]                 NAMES <- toupper(added)
[16:05:56.444]                 for (kk in seq_along(NAMES)) {
[16:05:56.444]                   name <- added[[kk]]
[16:05:56.444]                   NAME <- NAMES[[kk]]
[16:05:56.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.444]                     next
[16:05:56.444]                   args[[name]] <- ""
[16:05:56.444]                 }
[16:05:56.444]                 NAMES <- toupper(removed)
[16:05:56.444]                 for (kk in seq_along(NAMES)) {
[16:05:56.444]                   name <- removed[[kk]]
[16:05:56.444]                   NAME <- NAMES[[kk]]
[16:05:56.444]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.444]                     next
[16:05:56.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.444]                 }
[16:05:56.444]                 if (length(args) > 0) 
[16:05:56.444]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.444]             }
[16:05:56.444]             else {
[16:05:56.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.444]             }
[16:05:56.444]             {
[16:05:56.444]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.444]                   0L) {
[16:05:56.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.444]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.444]                   base::options(opts)
[16:05:56.444]                 }
[16:05:56.444]                 {
[16:05:56.444]                   {
[16:05:56.444]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.444]                     NULL
[16:05:56.444]                   }
[16:05:56.444]                   options(future.plan = NULL)
[16:05:56.444]                   if (is.na(NA_character_)) 
[16:05:56.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.444]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.444]                     envir = parent.frame()) 
[16:05:56.444]                   {
[16:05:56.444]                     default_workers <- missing(workers)
[16:05:56.444]                     if (is.function(workers)) 
[16:05:56.444]                       workers <- workers()
[16:05:56.444]                     workers <- structure(as.integer(workers), 
[16:05:56.444]                       class = class(workers))
[16:05:56.444]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.444]                       1L)
[16:05:56.444]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.444]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.444]                       if (default_workers) 
[16:05:56.444]                         supportsMulticore(warn = TRUE)
[16:05:56.444]                       return(sequential(..., envir = envir))
[16:05:56.444]                     }
[16:05:56.444]                     oopts <- options(mc.cores = workers)
[16:05:56.444]                     on.exit(options(oopts))
[16:05:56.444]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.444]                       envir = envir)
[16:05:56.444]                     if (!future$lazy) 
[16:05:56.444]                       future <- run(future)
[16:05:56.444]                     invisible(future)
[16:05:56.444]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.444]                 }
[16:05:56.444]             }
[16:05:56.444]         }
[16:05:56.444]     })
[16:05:56.444]     if (TRUE) {
[16:05:56.444]         base::sink(type = "output", split = FALSE)
[16:05:56.444]         if (TRUE) {
[16:05:56.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.444]         }
[16:05:56.444]         else {
[16:05:56.444]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.444]         }
[16:05:56.444]         base::close(...future.stdout)
[16:05:56.444]         ...future.stdout <- NULL
[16:05:56.444]     }
[16:05:56.444]     ...future.result$conditions <- ...future.conditions
[16:05:56.444]     ...future.result$finished <- base::Sys.time()
[16:05:56.444]     ...future.result
[16:05:56.444] }
[16:05:56.448] assign_globals() ...
[16:05:56.448] List of 1
[16:05:56.448]  $ kk: int 3
[16:05:56.448]  - attr(*, "where")=List of 1
[16:05:56.448]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:56.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:56.448]  - attr(*, "resolved")= logi FALSE
[16:05:56.448]  - attr(*, "total_size")= num 56
[16:05:56.448]  - attr(*, "already-done")= logi TRUE
[16:05:56.453] - copied ‘kk’ to environment
[16:05:56.453] assign_globals() ... done
[16:05:56.453] requestCore(): workers = 2
[16:05:56.453] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.484] plan(): Setting new future strategy stack:
[16:05:56.484] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[16:05:56.484] List of future strategies:
[16:05:56.484] 1. multicore:
[16:05:56.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.484]    - tweaked: FALSE
[16:05:56.484]    - call: plan(strategy)
[16:05:56.489] plan(): nbrOfWorkers() = 2
[16:05:56.495] result() for MulticoreFuture ...
[16:05:56.496] result() for MulticoreFuture ...
[16:05:56.496] result() for MulticoreFuture ... done
[16:05:56.496] result() for MulticoreFuture ... done
[16:05:56.496] result() for MulticoreFuture ...
[16:05:56.496] result() for MulticoreFuture ... done
[16:05:56.498] MulticoreFuture started
[16:05:56.499] - Launch lazy future ... done
[16:05:56.499] run() for ‘MulticoreFuture’ ... done
[16:05:56.500] resolve() on list ...
[16:05:56.500] plan(): Setting new future strategy stack:
[16:05:56.500]  recursive: 0
[16:05:56.500]  length: 3
[16:05:56.500] 
[16:05:56.501] Future #1
[16:05:56.500] List of future strategies:
[16:05:56.500] 1. sequential:
[16:05:56.500]    - args: function (..., envir = parent.frame())
[16:05:56.500]    - tweaked: FALSE
[16:05:56.500]    - call: NULL
[16:05:56.501]  length: 2 (resolved future 1)
[16:05:56.502] plan(): nbrOfWorkers() = 1
[16:05:56.525] plan(): Setting new future strategy stack:
[16:05:56.525] List of future strategies:
[16:05:56.525] 1. multicore:
[16:05:56.525]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.525]    - tweaked: FALSE
[16:05:56.525]    - call: plan(strategy)
[16:05:56.529] plan(): nbrOfWorkers() = 2
[16:05:56.532] Future #2
[16:05:56.533]  length: 1 (resolved future 2)
[16:05:56.604] plan(): Setting new future strategy stack:
[16:05:56.604] List of future strategies:
[16:05:56.604] 1. multicore:
[16:05:56.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.604]    - tweaked: FALSE
[16:05:56.604]    - call: plan(strategy)
[16:05:56.609] plan(): nbrOfWorkers() = 2
[16:05:56.614] Future #3
[16:05:56.615]  length: 0 (resolved future 3)
[16:05:56.615] resolve() on list ... DONE
[16:05:56.615] getGlobalsAndPackages() ...
[16:05:56.615] Searching for globals...
[16:05:56.617] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:56.618] Searching for globals ... DONE
[16:05:56.618] Resolving globals: FALSE
[16:05:56.618] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:56.619] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:56.619] - globals: [1] ‘kk’
[16:05:56.619] 
[16:05:56.619] getGlobalsAndPackages() ... DONE
[16:05:56.620] getGlobalsAndPackages() ...
[16:05:56.620] Searching for globals...
[16:05:56.622] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:56.622] Searching for globals ... DONE
[16:05:56.622] Resolving globals: FALSE
[16:05:56.622] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:56.623] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:56.623] - globals: [1] ‘kk’
[16:05:56.623] 
[16:05:56.623] getGlobalsAndPackages() ... DONE
[16:05:56.624] getGlobalsAndPackages() ...
[16:05:56.624] Searching for globals...
[16:05:56.625] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:05:56.625] Searching for globals ... DONE
[16:05:56.625] Resolving globals: FALSE
[16:05:56.626] The total size of the 1 globals is 56 bytes (56 bytes)
[16:05:56.626] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:05:56.627] - globals: [1] ‘kk’
[16:05:56.627] 
[16:05:56.627] getGlobalsAndPackages() ... DONE
[16:05:56.627] resolve() on list ...
[16:05:56.627]  recursive: 0
[16:05:56.627]  length: 3
[16:05:56.628] 
[16:05:56.628] run() for ‘Future’ ...
[16:05:56.628] - state: ‘created’
[16:05:56.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.632] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.633]   - Field: ‘label’
[16:05:56.633]   - Field: ‘local’
[16:05:56.633]   - Field: ‘owner’
[16:05:56.633]   - Field: ‘envir’
[16:05:56.633]   - Field: ‘workers’
[16:05:56.633]   - Field: ‘packages’
[16:05:56.634]   - Field: ‘gc’
[16:05:56.634]   - Field: ‘job’
[16:05:56.634]   - Field: ‘conditions’
[16:05:56.634]   - Field: ‘expr’
[16:05:56.634]   - Field: ‘uuid’
[16:05:56.634]   - Field: ‘seed’
[16:05:56.634]   - Field: ‘version’
[16:05:56.635]   - Field: ‘result’
[16:05:56.635]   - Field: ‘asynchronous’
[16:05:56.635]   - Field: ‘calls’
[16:05:56.635]   - Field: ‘globals’
[16:05:56.635]   - Field: ‘stdout’
[16:05:56.635]   - Field: ‘earlySignal’
[16:05:56.636]   - Field: ‘lazy’
[16:05:56.636]   - Field: ‘state’
[16:05:56.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.636] - Launch lazy future ...
[16:05:56.636] Packages needed by the future expression (n = 0): <none>
[16:05:56.637] Packages needed by future strategies (n = 0): <none>
[16:05:56.640] {
[16:05:56.640]     {
[16:05:56.640]         {
[16:05:56.640]             ...future.startTime <- base::Sys.time()
[16:05:56.640]             {
[16:05:56.640]                 {
[16:05:56.640]                   {
[16:05:56.640]                     {
[16:05:56.640]                       base::local({
[16:05:56.640]                         has_future <- base::requireNamespace("future", 
[16:05:56.640]                           quietly = TRUE)
[16:05:56.640]                         if (has_future) {
[16:05:56.640]                           ns <- base::getNamespace("future")
[16:05:56.640]                           version <- ns[[".package"]][["version"]]
[16:05:56.640]                           if (is.null(version)) 
[16:05:56.640]                             version <- utils::packageVersion("future")
[16:05:56.640]                         }
[16:05:56.640]                         else {
[16:05:56.640]                           version <- NULL
[16:05:56.640]                         }
[16:05:56.640]                         if (!has_future || version < "1.8.0") {
[16:05:56.640]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.640]                             "", base::R.version$version.string), 
[16:05:56.640]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.640]                               "release", "version")], collapse = " "), 
[16:05:56.640]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.640]                             info)
[16:05:56.640]                           info <- base::paste(info, collapse = "; ")
[16:05:56.640]                           if (!has_future) {
[16:05:56.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.640]                               info)
[16:05:56.640]                           }
[16:05:56.640]                           else {
[16:05:56.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.640]                               info, version)
[16:05:56.640]                           }
[16:05:56.640]                           base::stop(msg)
[16:05:56.640]                         }
[16:05:56.640]                       })
[16:05:56.640]                     }
[16:05:56.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.640]                     base::options(mc.cores = 1L)
[16:05:56.640]                   }
[16:05:56.640]                   options(future.plan = NULL)
[16:05:56.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.640]                 }
[16:05:56.640]                 ...future.workdir <- getwd()
[16:05:56.640]             }
[16:05:56.640]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.640]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.640]         }
[16:05:56.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.640]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.640]             base::names(...future.oldOptions))
[16:05:56.640]     }
[16:05:56.640]     if (FALSE) {
[16:05:56.640]     }
[16:05:56.640]     else {
[16:05:56.640]         if (TRUE) {
[16:05:56.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.640]                 open = "w")
[16:05:56.640]         }
[16:05:56.640]         else {
[16:05:56.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.640]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.640]         }
[16:05:56.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.640]             base::sink(type = "output", split = FALSE)
[16:05:56.640]             base::close(...future.stdout)
[16:05:56.640]         }, add = TRUE)
[16:05:56.640]     }
[16:05:56.640]     ...future.frame <- base::sys.nframe()
[16:05:56.640]     ...future.conditions <- base::list()
[16:05:56.640]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.640]     if (FALSE) {
[16:05:56.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.640]     }
[16:05:56.640]     ...future.result <- base::tryCatch({
[16:05:56.640]         base::withCallingHandlers({
[16:05:56.640]             ...future.value <- base::withVisible(base::local({
[16:05:56.640]                 withCallingHandlers({
[16:05:56.640]                   {
[16:05:56.640]                     Sys.sleep(0.1)
[16:05:56.640]                     kk
[16:05:56.640]                   }
[16:05:56.640]                 }, immediateCondition = function(cond) {
[16:05:56.640]                   save_rds <- function (object, pathname, ...) 
[16:05:56.640]                   {
[16:05:56.640]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.640]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.640]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.640]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.640]                         fi_tmp[["mtime"]])
[16:05:56.640]                     }
[16:05:56.640]                     tryCatch({
[16:05:56.640]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.640]                     }, error = function(ex) {
[16:05:56.640]                       msg <- conditionMessage(ex)
[16:05:56.640]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.640]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.640]                         fi_tmp[["mtime"]], msg)
[16:05:56.640]                       ex$message <- msg
[16:05:56.640]                       stop(ex)
[16:05:56.640]                     })
[16:05:56.640]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.640]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.640]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.640]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.640]                       fi <- file.info(pathname)
[16:05:56.640]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.640]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.640]                         fi[["size"]], fi[["mtime"]])
[16:05:56.640]                       stop(msg)
[16:05:56.640]                     }
[16:05:56.640]                     invisible(pathname)
[16:05:56.640]                   }
[16:05:56.640]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.640]                     rootPath = tempdir()) 
[16:05:56.640]                   {
[16:05:56.640]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.640]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.640]                       tmpdir = path, fileext = ".rds")
[16:05:56.640]                     save_rds(obj, file)
[16:05:56.640]                   }
[16:05:56.640]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.640]                   {
[16:05:56.640]                     inherits <- base::inherits
[16:05:56.640]                     invokeRestart <- base::invokeRestart
[16:05:56.640]                     is.null <- base::is.null
[16:05:56.640]                     muffled <- FALSE
[16:05:56.640]                     if (inherits(cond, "message")) {
[16:05:56.640]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.640]                       if (muffled) 
[16:05:56.640]                         invokeRestart("muffleMessage")
[16:05:56.640]                     }
[16:05:56.640]                     else if (inherits(cond, "warning")) {
[16:05:56.640]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.640]                       if (muffled) 
[16:05:56.640]                         invokeRestart("muffleWarning")
[16:05:56.640]                     }
[16:05:56.640]                     else if (inherits(cond, "condition")) {
[16:05:56.640]                       if (!is.null(pattern)) {
[16:05:56.640]                         computeRestarts <- base::computeRestarts
[16:05:56.640]                         grepl <- base::grepl
[16:05:56.640]                         restarts <- computeRestarts(cond)
[16:05:56.640]                         for (restart in restarts) {
[16:05:56.640]                           name <- restart$name
[16:05:56.640]                           if (is.null(name)) 
[16:05:56.640]                             next
[16:05:56.640]                           if (!grepl(pattern, name)) 
[16:05:56.640]                             next
[16:05:56.640]                           invokeRestart(restart)
[16:05:56.640]                           muffled <- TRUE
[16:05:56.640]                           break
[16:05:56.640]                         }
[16:05:56.640]                       }
[16:05:56.640]                     }
[16:05:56.640]                     invisible(muffled)
[16:05:56.640]                   }
[16:05:56.640]                   muffleCondition(cond)
[16:05:56.640]                 })
[16:05:56.640]             }))
[16:05:56.640]             future::FutureResult(value = ...future.value$value, 
[16:05:56.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.640]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.640]                     ...future.globalenv.names))
[16:05:56.640]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.640]         }, condition = base::local({
[16:05:56.640]             c <- base::c
[16:05:56.640]             inherits <- base::inherits
[16:05:56.640]             invokeRestart <- base::invokeRestart
[16:05:56.640]             length <- base::length
[16:05:56.640]             list <- base::list
[16:05:56.640]             seq.int <- base::seq.int
[16:05:56.640]             signalCondition <- base::signalCondition
[16:05:56.640]             sys.calls <- base::sys.calls
[16:05:56.640]             `[[` <- base::`[[`
[16:05:56.640]             `+` <- base::`+`
[16:05:56.640]             `<<-` <- base::`<<-`
[16:05:56.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.640]                   3L)]
[16:05:56.640]             }
[16:05:56.640]             function(cond) {
[16:05:56.640]                 is_error <- inherits(cond, "error")
[16:05:56.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.640]                   NULL)
[16:05:56.640]                 if (is_error) {
[16:05:56.640]                   sessionInformation <- function() {
[16:05:56.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.640]                       search = base::search(), system = base::Sys.info())
[16:05:56.640]                   }
[16:05:56.640]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.640]                     cond$call), session = sessionInformation(), 
[16:05:56.640]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.640]                   signalCondition(cond)
[16:05:56.640]                 }
[16:05:56.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.640]                 "immediateCondition"))) {
[16:05:56.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.640]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.640]                   if (TRUE && !signal) {
[16:05:56.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.640]                     {
[16:05:56.640]                       inherits <- base::inherits
[16:05:56.640]                       invokeRestart <- base::invokeRestart
[16:05:56.640]                       is.null <- base::is.null
[16:05:56.640]                       muffled <- FALSE
[16:05:56.640]                       if (inherits(cond, "message")) {
[16:05:56.640]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.640]                         if (muffled) 
[16:05:56.640]                           invokeRestart("muffleMessage")
[16:05:56.640]                       }
[16:05:56.640]                       else if (inherits(cond, "warning")) {
[16:05:56.640]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.640]                         if (muffled) 
[16:05:56.640]                           invokeRestart("muffleWarning")
[16:05:56.640]                       }
[16:05:56.640]                       else if (inherits(cond, "condition")) {
[16:05:56.640]                         if (!is.null(pattern)) {
[16:05:56.640]                           computeRestarts <- base::computeRestarts
[16:05:56.640]                           grepl <- base::grepl
[16:05:56.640]                           restarts <- computeRestarts(cond)
[16:05:56.640]                           for (restart in restarts) {
[16:05:56.640]                             name <- restart$name
[16:05:56.640]                             if (is.null(name)) 
[16:05:56.640]                               next
[16:05:56.640]                             if (!grepl(pattern, name)) 
[16:05:56.640]                               next
[16:05:56.640]                             invokeRestart(restart)
[16:05:56.640]                             muffled <- TRUE
[16:05:56.640]                             break
[16:05:56.640]                           }
[16:05:56.640]                         }
[16:05:56.640]                       }
[16:05:56.640]                       invisible(muffled)
[16:05:56.640]                     }
[16:05:56.640]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.640]                   }
[16:05:56.640]                 }
[16:05:56.640]                 else {
[16:05:56.640]                   if (TRUE) {
[16:05:56.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.640]                     {
[16:05:56.640]                       inherits <- base::inherits
[16:05:56.640]                       invokeRestart <- base::invokeRestart
[16:05:56.640]                       is.null <- base::is.null
[16:05:56.640]                       muffled <- FALSE
[16:05:56.640]                       if (inherits(cond, "message")) {
[16:05:56.640]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.640]                         if (muffled) 
[16:05:56.640]                           invokeRestart("muffleMessage")
[16:05:56.640]                       }
[16:05:56.640]                       else if (inherits(cond, "warning")) {
[16:05:56.640]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.640]                         if (muffled) 
[16:05:56.640]                           invokeRestart("muffleWarning")
[16:05:56.640]                       }
[16:05:56.640]                       else if (inherits(cond, "condition")) {
[16:05:56.640]                         if (!is.null(pattern)) {
[16:05:56.640]                           computeRestarts <- base::computeRestarts
[16:05:56.640]                           grepl <- base::grepl
[16:05:56.640]                           restarts <- computeRestarts(cond)
[16:05:56.640]                           for (restart in restarts) {
[16:05:56.640]                             name <- restart$name
[16:05:56.640]                             if (is.null(name)) 
[16:05:56.640]                               next
[16:05:56.640]                             if (!grepl(pattern, name)) 
[16:05:56.640]                               next
[16:05:56.640]                             invokeRestart(restart)
[16:05:56.640]                             muffled <- TRUE
[16:05:56.640]                             break
[16:05:56.640]                           }
[16:05:56.640]                         }
[16:05:56.640]                       }
[16:05:56.640]                       invisible(muffled)
[16:05:56.640]                     }
[16:05:56.640]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.640]                   }
[16:05:56.640]                 }
[16:05:56.640]             }
[16:05:56.640]         }))
[16:05:56.640]     }, error = function(ex) {
[16:05:56.640]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.640]                 ...future.rng), started = ...future.startTime, 
[16:05:56.640]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.640]             version = "1.8"), class = "FutureResult")
[16:05:56.640]     }, finally = {
[16:05:56.640]         if (!identical(...future.workdir, getwd())) 
[16:05:56.640]             setwd(...future.workdir)
[16:05:56.640]         {
[16:05:56.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.640]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.640]             }
[16:05:56.640]             base::options(...future.oldOptions)
[16:05:56.640]             if (.Platform$OS.type == "windows") {
[16:05:56.640]                 old_names <- names(...future.oldEnvVars)
[16:05:56.640]                 envs <- base::Sys.getenv()
[16:05:56.640]                 names <- names(envs)
[16:05:56.640]                 common <- intersect(names, old_names)
[16:05:56.640]                 added <- setdiff(names, old_names)
[16:05:56.640]                 removed <- setdiff(old_names, names)
[16:05:56.640]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.640]                   envs[common]]
[16:05:56.640]                 NAMES <- toupper(changed)
[16:05:56.640]                 args <- list()
[16:05:56.640]                 for (kk in seq_along(NAMES)) {
[16:05:56.640]                   name <- changed[[kk]]
[16:05:56.640]                   NAME <- NAMES[[kk]]
[16:05:56.640]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.640]                     next
[16:05:56.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.640]                 }
[16:05:56.640]                 NAMES <- toupper(added)
[16:05:56.640]                 for (kk in seq_along(NAMES)) {
[16:05:56.640]                   name <- added[[kk]]
[16:05:56.640]                   NAME <- NAMES[[kk]]
[16:05:56.640]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.640]                     next
[16:05:56.640]                   args[[name]] <- ""
[16:05:56.640]                 }
[16:05:56.640]                 NAMES <- toupper(removed)
[16:05:56.640]                 for (kk in seq_along(NAMES)) {
[16:05:56.640]                   name <- removed[[kk]]
[16:05:56.640]                   NAME <- NAMES[[kk]]
[16:05:56.640]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.640]                     next
[16:05:56.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.640]                 }
[16:05:56.640]                 if (length(args) > 0) 
[16:05:56.640]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.640]             }
[16:05:56.640]             else {
[16:05:56.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.640]             }
[16:05:56.640]             {
[16:05:56.640]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.640]                   0L) {
[16:05:56.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.640]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.640]                   base::options(opts)
[16:05:56.640]                 }
[16:05:56.640]                 {
[16:05:56.640]                   {
[16:05:56.640]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.640]                     NULL
[16:05:56.640]                   }
[16:05:56.640]                   options(future.plan = NULL)
[16:05:56.640]                   if (is.na(NA_character_)) 
[16:05:56.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.640]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.640]                     envir = parent.frame()) 
[16:05:56.640]                   {
[16:05:56.640]                     default_workers <- missing(workers)
[16:05:56.640]                     if (is.function(workers)) 
[16:05:56.640]                       workers <- workers()
[16:05:56.640]                     workers <- structure(as.integer(workers), 
[16:05:56.640]                       class = class(workers))
[16:05:56.640]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.640]                       1L)
[16:05:56.640]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.640]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.640]                       if (default_workers) 
[16:05:56.640]                         supportsMulticore(warn = TRUE)
[16:05:56.640]                       return(sequential(..., envir = envir))
[16:05:56.640]                     }
[16:05:56.640]                     oopts <- options(mc.cores = workers)
[16:05:56.640]                     on.exit(options(oopts))
[16:05:56.640]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.640]                       envir = envir)
[16:05:56.640]                     if (!future$lazy) 
[16:05:56.640]                       future <- run(future)
[16:05:56.640]                     invisible(future)
[16:05:56.640]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.640]                 }
[16:05:56.640]             }
[16:05:56.640]         }
[16:05:56.640]     })
[16:05:56.640]     if (TRUE) {
[16:05:56.640]         base::sink(type = "output", split = FALSE)
[16:05:56.640]         if (TRUE) {
[16:05:56.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.640]         }
[16:05:56.640]         else {
[16:05:56.640]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.640]         }
[16:05:56.640]         base::close(...future.stdout)
[16:05:56.640]         ...future.stdout <- NULL
[16:05:56.640]     }
[16:05:56.640]     ...future.result$conditions <- ...future.conditions
[16:05:56.640]     ...future.result$finished <- base::Sys.time()
[16:05:56.640]     ...future.result
[16:05:56.640] }
[16:05:56.643] assign_globals() ...
[16:05:56.643] List of 1
[16:05:56.643]  $ kk: int 1
[16:05:56.643]  - attr(*, "where")=List of 1
[16:05:56.643]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:56.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:56.643]  - attr(*, "resolved")= logi FALSE
[16:05:56.643]  - attr(*, "total_size")= num 56
[16:05:56.643]  - attr(*, "already-done")= logi TRUE
[16:05:56.648] - copied ‘kk’ to environment
[16:05:56.648] assign_globals() ... done
[16:05:56.648] requestCore(): workers = 2
[16:05:56.649] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.659] result() for MulticoreFuture ...
[16:05:56.660] result() for MulticoreFuture ...
[16:05:56.660] result() for MulticoreFuture ... done
[16:05:56.660] result() for MulticoreFuture ... done
[16:05:56.661] result() for MulticoreFuture ...
[16:05:56.661] result() for MulticoreFuture ... done
[16:05:56.664] MulticoreFuture started
[16:05:56.664] - Launch lazy future ... done
[16:05:56.665] run() for ‘MulticoreFuture’ ... done
[16:05:56.665] plan(): Setting new future strategy stack:
[16:05:56.665] List of future strategies:
[16:05:56.665] 1. sequential:
[16:05:56.665]    - args: function (..., envir = parent.frame())
[16:05:56.665]    - tweaked: FALSE
[16:05:56.665]    - call: NULL
[16:05:56.666] plan(): nbrOfWorkers() = 1
[16:05:56.675] run() for ‘Future’ ...
[16:05:56.676] - state: ‘created’
[16:05:56.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.682] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.682]   - Field: ‘label’
[16:05:56.682]   - Field: ‘local’
[16:05:56.683]   - Field: ‘owner’
[16:05:56.683]   - Field: ‘envir’
[16:05:56.683]   - Field: ‘workers’
[16:05:56.683]   - Field: ‘packages’
[16:05:56.683]   - Field: ‘gc’
[16:05:56.683]   - Field: ‘job’
[16:05:56.684]   - Field: ‘conditions’
[16:05:56.684]   - Field: ‘expr’
[16:05:56.684]   - Field: ‘uuid’
[16:05:56.684]   - Field: ‘seed’
[16:05:56.684]   - Field: ‘version’
[16:05:56.684]   - Field: ‘result’
[16:05:56.685]   - Field: ‘asynchronous’
[16:05:56.685]   - Field: ‘calls’
[16:05:56.685]   - Field: ‘globals’
[16:05:56.685]   - Field: ‘stdout’
[16:05:56.685]   - Field: ‘earlySignal’
[16:05:56.685]   - Field: ‘lazy’
[16:05:56.685]   - Field: ‘state’
[16:05:56.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.686] - Launch lazy future ...
[16:05:56.686] Packages needed by the future expression (n = 0): <none>
[16:05:56.686] Packages needed by future strategies (n = 0): <none>
[16:05:56.687] {
[16:05:56.687]     {
[16:05:56.687]         {
[16:05:56.687]             ...future.startTime <- base::Sys.time()
[16:05:56.687]             {
[16:05:56.687]                 {
[16:05:56.687]                   {
[16:05:56.687]                     {
[16:05:56.687]                       base::local({
[16:05:56.687]                         has_future <- base::requireNamespace("future", 
[16:05:56.687]                           quietly = TRUE)
[16:05:56.687]                         if (has_future) {
[16:05:56.687]                           ns <- base::getNamespace("future")
[16:05:56.687]                           version <- ns[[".package"]][["version"]]
[16:05:56.687]                           if (is.null(version)) 
[16:05:56.687]                             version <- utils::packageVersion("future")
[16:05:56.687]                         }
[16:05:56.687]                         else {
[16:05:56.687]                           version <- NULL
[16:05:56.687]                         }
[16:05:56.687]                         if (!has_future || version < "1.8.0") {
[16:05:56.687]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.687]                             "", base::R.version$version.string), 
[16:05:56.687]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.687]                               "release", "version")], collapse = " "), 
[16:05:56.687]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.687]                             info)
[16:05:56.687]                           info <- base::paste(info, collapse = "; ")
[16:05:56.687]                           if (!has_future) {
[16:05:56.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.687]                               info)
[16:05:56.687]                           }
[16:05:56.687]                           else {
[16:05:56.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.687]                               info, version)
[16:05:56.687]                           }
[16:05:56.687]                           base::stop(msg)
[16:05:56.687]                         }
[16:05:56.687]                       })
[16:05:56.687]                     }
[16:05:56.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.687]                     base::options(mc.cores = 1L)
[16:05:56.687]                   }
[16:05:56.687]                   options(future.plan = NULL)
[16:05:56.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.687]                 }
[16:05:56.687]                 ...future.workdir <- getwd()
[16:05:56.687]             }
[16:05:56.687]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.687]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.687]         }
[16:05:56.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.687]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.687]             base::names(...future.oldOptions))
[16:05:56.687]     }
[16:05:56.687]     if (FALSE) {
[16:05:56.687]     }
[16:05:56.687]     else {
[16:05:56.687]         if (TRUE) {
[16:05:56.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.687]                 open = "w")
[16:05:56.687]         }
[16:05:56.687]         else {
[16:05:56.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.687]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.687]         }
[16:05:56.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.687]             base::sink(type = "output", split = FALSE)
[16:05:56.687]             base::close(...future.stdout)
[16:05:56.687]         }, add = TRUE)
[16:05:56.687]     }
[16:05:56.687]     ...future.frame <- base::sys.nframe()
[16:05:56.687]     ...future.conditions <- base::list()
[16:05:56.687]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.687]     if (FALSE) {
[16:05:56.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.687]     }
[16:05:56.687]     ...future.result <- base::tryCatch({
[16:05:56.687]         base::withCallingHandlers({
[16:05:56.687]             ...future.value <- base::withVisible(base::local({
[16:05:56.687]                 withCallingHandlers({
[16:05:56.687]                   {
[16:05:56.687]                     Sys.sleep(0.1)
[16:05:56.687]                     kk
[16:05:56.687]                   }
[16:05:56.687]                 }, immediateCondition = function(cond) {
[16:05:56.687]                   save_rds <- function (object, pathname, ...) 
[16:05:56.687]                   {
[16:05:56.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.687]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.687]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.687]                         fi_tmp[["mtime"]])
[16:05:56.687]                     }
[16:05:56.687]                     tryCatch({
[16:05:56.687]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.687]                     }, error = function(ex) {
[16:05:56.687]                       msg <- conditionMessage(ex)
[16:05:56.687]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.687]                         fi_tmp[["mtime"]], msg)
[16:05:56.687]                       ex$message <- msg
[16:05:56.687]                       stop(ex)
[16:05:56.687]                     })
[16:05:56.687]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.687]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.687]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.687]                       fi <- file.info(pathname)
[16:05:56.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.687]                         fi[["size"]], fi[["mtime"]])
[16:05:56.687]                       stop(msg)
[16:05:56.687]                     }
[16:05:56.687]                     invisible(pathname)
[16:05:56.687]                   }
[16:05:56.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.687]                     rootPath = tempdir()) 
[16:05:56.687]                   {
[16:05:56.687]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.687]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.687]                       tmpdir = path, fileext = ".rds")
[16:05:56.687]                     save_rds(obj, file)
[16:05:56.687]                   }
[16:05:56.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.687]                   {
[16:05:56.687]                     inherits <- base::inherits
[16:05:56.687]                     invokeRestart <- base::invokeRestart
[16:05:56.687]                     is.null <- base::is.null
[16:05:56.687]                     muffled <- FALSE
[16:05:56.687]                     if (inherits(cond, "message")) {
[16:05:56.687]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.687]                       if (muffled) 
[16:05:56.687]                         invokeRestart("muffleMessage")
[16:05:56.687]                     }
[16:05:56.687]                     else if (inherits(cond, "warning")) {
[16:05:56.687]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.687]                       if (muffled) 
[16:05:56.687]                         invokeRestart("muffleWarning")
[16:05:56.687]                     }
[16:05:56.687]                     else if (inherits(cond, "condition")) {
[16:05:56.687]                       if (!is.null(pattern)) {
[16:05:56.687]                         computeRestarts <- base::computeRestarts
[16:05:56.687]                         grepl <- base::grepl
[16:05:56.687]                         restarts <- computeRestarts(cond)
[16:05:56.687]                         for (restart in restarts) {
[16:05:56.687]                           name <- restart$name
[16:05:56.687]                           if (is.null(name)) 
[16:05:56.687]                             next
[16:05:56.687]                           if (!grepl(pattern, name)) 
[16:05:56.687]                             next
[16:05:56.687]                           invokeRestart(restart)
[16:05:56.687]                           muffled <- TRUE
[16:05:56.687]                           break
[16:05:56.687]                         }
[16:05:56.687]                       }
[16:05:56.687]                     }
[16:05:56.687]                     invisible(muffled)
[16:05:56.687]                   }
[16:05:56.687]                   muffleCondition(cond)
[16:05:56.687]                 })
[16:05:56.687]             }))
[16:05:56.687]             future::FutureResult(value = ...future.value$value, 
[16:05:56.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.687]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.687]                     ...future.globalenv.names))
[16:05:56.687]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.687]         }, condition = base::local({
[16:05:56.687]             c <- base::c
[16:05:56.687]             inherits <- base::inherits
[16:05:56.687]             invokeRestart <- base::invokeRestart
[16:05:56.687]             length <- base::length
[16:05:56.687]             list <- base::list
[16:05:56.687]             seq.int <- base::seq.int
[16:05:56.687]             signalCondition <- base::signalCondition
[16:05:56.687]             sys.calls <- base::sys.calls
[16:05:56.687]             `[[` <- base::`[[`
[16:05:56.687]             `+` <- base::`+`
[16:05:56.687]             `<<-` <- base::`<<-`
[16:05:56.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.687]                   3L)]
[16:05:56.687]             }
[16:05:56.687]             function(cond) {
[16:05:56.687]                 is_error <- inherits(cond, "error")
[16:05:56.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.687]                   NULL)
[16:05:56.687]                 if (is_error) {
[16:05:56.687]                   sessionInformation <- function() {
[16:05:56.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.687]                       search = base::search(), system = base::Sys.info())
[16:05:56.687]                   }
[16:05:56.687]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.687]                     cond$call), session = sessionInformation(), 
[16:05:56.687]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.687]                   signalCondition(cond)
[16:05:56.687]                 }
[16:05:56.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.687]                 "immediateCondition"))) {
[16:05:56.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.687]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.687]                   if (TRUE && !signal) {
[16:05:56.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.687]                     {
[16:05:56.687]                       inherits <- base::inherits
[16:05:56.687]                       invokeRestart <- base::invokeRestart
[16:05:56.687]                       is.null <- base::is.null
[16:05:56.687]                       muffled <- FALSE
[16:05:56.687]                       if (inherits(cond, "message")) {
[16:05:56.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.687]                         if (muffled) 
[16:05:56.687]                           invokeRestart("muffleMessage")
[16:05:56.687]                       }
[16:05:56.687]                       else if (inherits(cond, "warning")) {
[16:05:56.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.687]                         if (muffled) 
[16:05:56.687]                           invokeRestart("muffleWarning")
[16:05:56.687]                       }
[16:05:56.687]                       else if (inherits(cond, "condition")) {
[16:05:56.687]                         if (!is.null(pattern)) {
[16:05:56.687]                           computeRestarts <- base::computeRestarts
[16:05:56.687]                           grepl <- base::grepl
[16:05:56.687]                           restarts <- computeRestarts(cond)
[16:05:56.687]                           for (restart in restarts) {
[16:05:56.687]                             name <- restart$name
[16:05:56.687]                             if (is.null(name)) 
[16:05:56.687]                               next
[16:05:56.687]                             if (!grepl(pattern, name)) 
[16:05:56.687]                               next
[16:05:56.687]                             invokeRestart(restart)
[16:05:56.687]                             muffled <- TRUE
[16:05:56.687]                             break
[16:05:56.687]                           }
[16:05:56.687]                         }
[16:05:56.687]                       }
[16:05:56.687]                       invisible(muffled)
[16:05:56.687]                     }
[16:05:56.687]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.687]                   }
[16:05:56.687]                 }
[16:05:56.687]                 else {
[16:05:56.687]                   if (TRUE) {
[16:05:56.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.687]                     {
[16:05:56.687]                       inherits <- base::inherits
[16:05:56.687]                       invokeRestart <- base::invokeRestart
[16:05:56.687]                       is.null <- base::is.null
[16:05:56.687]                       muffled <- FALSE
[16:05:56.687]                       if (inherits(cond, "message")) {
[16:05:56.687]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.687]                         if (muffled) 
[16:05:56.687]                           invokeRestart("muffleMessage")
[16:05:56.687]                       }
[16:05:56.687]                       else if (inherits(cond, "warning")) {
[16:05:56.687]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.687]                         if (muffled) 
[16:05:56.687]                           invokeRestart("muffleWarning")
[16:05:56.687]                       }
[16:05:56.687]                       else if (inherits(cond, "condition")) {
[16:05:56.687]                         if (!is.null(pattern)) {
[16:05:56.687]                           computeRestarts <- base::computeRestarts
[16:05:56.687]                           grepl <- base::grepl
[16:05:56.687]                           restarts <- computeRestarts(cond)
[16:05:56.687]                           for (restart in restarts) {
[16:05:56.687]                             name <- restart$name
[16:05:56.687]                             if (is.null(name)) 
[16:05:56.687]                               next
[16:05:56.687]                             if (!grepl(pattern, name)) 
[16:05:56.687]                               next
[16:05:56.687]                             invokeRestart(restart)
[16:05:56.687]                             muffled <- TRUE
[16:05:56.687]                             break
[16:05:56.687]                           }
[16:05:56.687]                         }
[16:05:56.687]                       }
[16:05:56.687]                       invisible(muffled)
[16:05:56.687]                     }
[16:05:56.687]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.687]                   }
[16:05:56.687]                 }
[16:05:56.687]             }
[16:05:56.687]         }))
[16:05:56.687]     }, error = function(ex) {
[16:05:56.687]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.687]                 ...future.rng), started = ...future.startTime, 
[16:05:56.687]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.687]             version = "1.8"), class = "FutureResult")
[16:05:56.687]     }, finally = {
[16:05:56.687]         if (!identical(...future.workdir, getwd())) 
[16:05:56.687]             setwd(...future.workdir)
[16:05:56.687]         {
[16:05:56.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.687]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.687]             }
[16:05:56.687]             base::options(...future.oldOptions)
[16:05:56.687]             if (.Platform$OS.type == "windows") {
[16:05:56.687]                 old_names <- names(...future.oldEnvVars)
[16:05:56.687]                 envs <- base::Sys.getenv()
[16:05:56.687]                 names <- names(envs)
[16:05:56.687]                 common <- intersect(names, old_names)
[16:05:56.687]                 added <- setdiff(names, old_names)
[16:05:56.687]                 removed <- setdiff(old_names, names)
[16:05:56.687]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.687]                   envs[common]]
[16:05:56.687]                 NAMES <- toupper(changed)
[16:05:56.687]                 args <- list()
[16:05:56.687]                 for (kk in seq_along(NAMES)) {
[16:05:56.687]                   name <- changed[[kk]]
[16:05:56.687]                   NAME <- NAMES[[kk]]
[16:05:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.687]                     next
[16:05:56.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.687]                 }
[16:05:56.687]                 NAMES <- toupper(added)
[16:05:56.687]                 for (kk in seq_along(NAMES)) {
[16:05:56.687]                   name <- added[[kk]]
[16:05:56.687]                   NAME <- NAMES[[kk]]
[16:05:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.687]                     next
[16:05:56.687]                   args[[name]] <- ""
[16:05:56.687]                 }
[16:05:56.687]                 NAMES <- toupper(removed)
[16:05:56.687]                 for (kk in seq_along(NAMES)) {
[16:05:56.687]                   name <- removed[[kk]]
[16:05:56.687]                   NAME <- NAMES[[kk]]
[16:05:56.687]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.687]                     next
[16:05:56.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.687]                 }
[16:05:56.687]                 if (length(args) > 0) 
[16:05:56.687]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.687]             }
[16:05:56.687]             else {
[16:05:56.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.687]             }
[16:05:56.687]             {
[16:05:56.687]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.687]                   0L) {
[16:05:56.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.687]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.687]                   base::options(opts)
[16:05:56.687]                 }
[16:05:56.687]                 {
[16:05:56.687]                   {
[16:05:56.687]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.687]                     NULL
[16:05:56.687]                   }
[16:05:56.687]                   options(future.plan = NULL)
[16:05:56.687]                   if (is.na(NA_character_)) 
[16:05:56.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.687]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.687]                     envir = parent.frame()) 
[16:05:56.687]                   {
[16:05:56.687]                     default_workers <- missing(workers)
[16:05:56.687]                     if (is.function(workers)) 
[16:05:56.687]                       workers <- workers()
[16:05:56.687]                     workers <- structure(as.integer(workers), 
[16:05:56.687]                       class = class(workers))
[16:05:56.687]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.687]                       1L)
[16:05:56.687]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.687]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.687]                       if (default_workers) 
[16:05:56.687]                         supportsMulticore(warn = TRUE)
[16:05:56.687]                       return(sequential(..., envir = envir))
[16:05:56.687]                     }
[16:05:56.687]                     oopts <- options(mc.cores = workers)
[16:05:56.687]                     on.exit(options(oopts))
[16:05:56.687]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.687]                       envir = envir)
[16:05:56.687]                     if (!future$lazy) 
[16:05:56.687]                       future <- run(future)
[16:05:56.687]                     invisible(future)
[16:05:56.687]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.687]                 }
[16:05:56.687]             }
[16:05:56.687]         }
[16:05:56.687]     })
[16:05:56.687]     if (TRUE) {
[16:05:56.687]         base::sink(type = "output", split = FALSE)
[16:05:56.687]         if (TRUE) {
[16:05:56.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.687]         }
[16:05:56.687]         else {
[16:05:56.687]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.687]         }
[16:05:56.687]         base::close(...future.stdout)
[16:05:56.687]         ...future.stdout <- NULL
[16:05:56.687]     }
[16:05:56.687]     ...future.result$conditions <- ...future.conditions
[16:05:56.687]     ...future.result$finished <- base::Sys.time()
[16:05:56.687]     ...future.result
[16:05:56.687] }
[16:05:56.691] assign_globals() ...
[16:05:56.691] List of 1
[16:05:56.691]  $ kk: int 2
[16:05:56.691]  - attr(*, "where")=List of 1
[16:05:56.691]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:56.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:56.691]  - attr(*, "resolved")= logi FALSE
[16:05:56.691]  - attr(*, "total_size")= num 56
[16:05:56.691]  - attr(*, "already-done")= logi TRUE
[16:05:56.695] - copied ‘kk’ to environment
[16:05:56.695] assign_globals() ... done
[16:05:56.695] requestCore(): workers = 2
[16:05:56.696] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.706] result() for MulticoreFuture ...
[16:05:56.707] result() for MulticoreFuture ...
[16:05:56.707] result() for MulticoreFuture ... done
[16:05:56.708] result() for MulticoreFuture ... done
[16:05:56.708] result() for MulticoreFuture ...
[16:05:56.708] result() for MulticoreFuture ... done
[16:05:56.710] MulticoreFuture started
[16:05:56.710] - Launch lazy future ... done
[16:05:56.711] run() for ‘MulticoreFuture’ ... done
[16:05:56.711] plan(): Setting new future strategy stack:
[16:05:56.712] List of future strategies:
[16:05:56.712] 1. sequential:
[16:05:56.712]    - args: function (..., envir = parent.frame())
[16:05:56.712]    - tweaked: FALSE
[16:05:56.712]    - call: NULL
[16:05:56.712] plan(): nbrOfWorkers() = 1
[16:05:56.722] run() for ‘Future’ ...
[16:05:56.722] - state: ‘created’
[16:05:56.722] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.728] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.728]   - Field: ‘label’
[16:05:56.728]   - Field: ‘local’
[16:05:56.728]   - Field: ‘owner’
[16:05:56.728]   - Field: ‘envir’
[16:05:56.729]   - Field: ‘workers’
[16:05:56.729]   - Field: ‘packages’
[16:05:56.729]   - Field: ‘gc’
[16:05:56.729]   - Field: ‘job’
[16:05:56.729]   - Field: ‘conditions’
[16:05:56.729]   - Field: ‘expr’
[16:05:56.730]   - Field: ‘uuid’
[16:05:56.730]   - Field: ‘seed’
[16:05:56.730]   - Field: ‘version’
[16:05:56.730]   - Field: ‘result’
[16:05:56.730]   - Field: ‘asynchronous’
[16:05:56.730]   - Field: ‘calls’
[16:05:56.730]   - Field: ‘globals’
[16:05:56.731]   - Field: ‘stdout’
[16:05:56.731]   - Field: ‘earlySignal’
[16:05:56.731]   - Field: ‘lazy’
[16:05:56.731]   - Field: ‘state’
[16:05:56.731] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.731] - Launch lazy future ...
[16:05:56.732] Packages needed by the future expression (n = 0): <none>
[16:05:56.732] Packages needed by future strategies (n = 0): <none>
[16:05:56.733] {
[16:05:56.733]     {
[16:05:56.733]         {
[16:05:56.733]             ...future.startTime <- base::Sys.time()
[16:05:56.733]             {
[16:05:56.733]                 {
[16:05:56.733]                   {
[16:05:56.733]                     {
[16:05:56.733]                       base::local({
[16:05:56.733]                         has_future <- base::requireNamespace("future", 
[16:05:56.733]                           quietly = TRUE)
[16:05:56.733]                         if (has_future) {
[16:05:56.733]                           ns <- base::getNamespace("future")
[16:05:56.733]                           version <- ns[[".package"]][["version"]]
[16:05:56.733]                           if (is.null(version)) 
[16:05:56.733]                             version <- utils::packageVersion("future")
[16:05:56.733]                         }
[16:05:56.733]                         else {
[16:05:56.733]                           version <- NULL
[16:05:56.733]                         }
[16:05:56.733]                         if (!has_future || version < "1.8.0") {
[16:05:56.733]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.733]                             "", base::R.version$version.string), 
[16:05:56.733]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.733]                               "release", "version")], collapse = " "), 
[16:05:56.733]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.733]                             info)
[16:05:56.733]                           info <- base::paste(info, collapse = "; ")
[16:05:56.733]                           if (!has_future) {
[16:05:56.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.733]                               info)
[16:05:56.733]                           }
[16:05:56.733]                           else {
[16:05:56.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.733]                               info, version)
[16:05:56.733]                           }
[16:05:56.733]                           base::stop(msg)
[16:05:56.733]                         }
[16:05:56.733]                       })
[16:05:56.733]                     }
[16:05:56.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.733]                     base::options(mc.cores = 1L)
[16:05:56.733]                   }
[16:05:56.733]                   options(future.plan = NULL)
[16:05:56.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.733]                 }
[16:05:56.733]                 ...future.workdir <- getwd()
[16:05:56.733]             }
[16:05:56.733]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.733]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.733]         }
[16:05:56.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.733]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.733]             base::names(...future.oldOptions))
[16:05:56.733]     }
[16:05:56.733]     if (FALSE) {
[16:05:56.733]     }
[16:05:56.733]     else {
[16:05:56.733]         if (TRUE) {
[16:05:56.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.733]                 open = "w")
[16:05:56.733]         }
[16:05:56.733]         else {
[16:05:56.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.733]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.733]         }
[16:05:56.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.733]             base::sink(type = "output", split = FALSE)
[16:05:56.733]             base::close(...future.stdout)
[16:05:56.733]         }, add = TRUE)
[16:05:56.733]     }
[16:05:56.733]     ...future.frame <- base::sys.nframe()
[16:05:56.733]     ...future.conditions <- base::list()
[16:05:56.733]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.733]     if (FALSE) {
[16:05:56.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.733]     }
[16:05:56.733]     ...future.result <- base::tryCatch({
[16:05:56.733]         base::withCallingHandlers({
[16:05:56.733]             ...future.value <- base::withVisible(base::local({
[16:05:56.733]                 withCallingHandlers({
[16:05:56.733]                   {
[16:05:56.733]                     Sys.sleep(0.1)
[16:05:56.733]                     kk
[16:05:56.733]                   }
[16:05:56.733]                 }, immediateCondition = function(cond) {
[16:05:56.733]                   save_rds <- function (object, pathname, ...) 
[16:05:56.733]                   {
[16:05:56.733]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.733]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.733]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.733]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.733]                         fi_tmp[["mtime"]])
[16:05:56.733]                     }
[16:05:56.733]                     tryCatch({
[16:05:56.733]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.733]                     }, error = function(ex) {
[16:05:56.733]                       msg <- conditionMessage(ex)
[16:05:56.733]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.733]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.733]                         fi_tmp[["mtime"]], msg)
[16:05:56.733]                       ex$message <- msg
[16:05:56.733]                       stop(ex)
[16:05:56.733]                     })
[16:05:56.733]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.733]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.733]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.733]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.733]                       fi <- file.info(pathname)
[16:05:56.733]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.733]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.733]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.733]                         fi[["size"]], fi[["mtime"]])
[16:05:56.733]                       stop(msg)
[16:05:56.733]                     }
[16:05:56.733]                     invisible(pathname)
[16:05:56.733]                   }
[16:05:56.733]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.733]                     rootPath = tempdir()) 
[16:05:56.733]                   {
[16:05:56.733]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.733]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.733]                       tmpdir = path, fileext = ".rds")
[16:05:56.733]                     save_rds(obj, file)
[16:05:56.733]                   }
[16:05:56.733]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.733]                   {
[16:05:56.733]                     inherits <- base::inherits
[16:05:56.733]                     invokeRestart <- base::invokeRestart
[16:05:56.733]                     is.null <- base::is.null
[16:05:56.733]                     muffled <- FALSE
[16:05:56.733]                     if (inherits(cond, "message")) {
[16:05:56.733]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.733]                       if (muffled) 
[16:05:56.733]                         invokeRestart("muffleMessage")
[16:05:56.733]                     }
[16:05:56.733]                     else if (inherits(cond, "warning")) {
[16:05:56.733]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.733]                       if (muffled) 
[16:05:56.733]                         invokeRestart("muffleWarning")
[16:05:56.733]                     }
[16:05:56.733]                     else if (inherits(cond, "condition")) {
[16:05:56.733]                       if (!is.null(pattern)) {
[16:05:56.733]                         computeRestarts <- base::computeRestarts
[16:05:56.733]                         grepl <- base::grepl
[16:05:56.733]                         restarts <- computeRestarts(cond)
[16:05:56.733]                         for (restart in restarts) {
[16:05:56.733]                           name <- restart$name
[16:05:56.733]                           if (is.null(name)) 
[16:05:56.733]                             next
[16:05:56.733]                           if (!grepl(pattern, name)) 
[16:05:56.733]                             next
[16:05:56.733]                           invokeRestart(restart)
[16:05:56.733]                           muffled <- TRUE
[16:05:56.733]                           break
[16:05:56.733]                         }
[16:05:56.733]                       }
[16:05:56.733]                     }
[16:05:56.733]                     invisible(muffled)
[16:05:56.733]                   }
[16:05:56.733]                   muffleCondition(cond)
[16:05:56.733]                 })
[16:05:56.733]             }))
[16:05:56.733]             future::FutureResult(value = ...future.value$value, 
[16:05:56.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.733]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.733]                     ...future.globalenv.names))
[16:05:56.733]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.733]         }, condition = base::local({
[16:05:56.733]             c <- base::c
[16:05:56.733]             inherits <- base::inherits
[16:05:56.733]             invokeRestart <- base::invokeRestart
[16:05:56.733]             length <- base::length
[16:05:56.733]             list <- base::list
[16:05:56.733]             seq.int <- base::seq.int
[16:05:56.733]             signalCondition <- base::signalCondition
[16:05:56.733]             sys.calls <- base::sys.calls
[16:05:56.733]             `[[` <- base::`[[`
[16:05:56.733]             `+` <- base::`+`
[16:05:56.733]             `<<-` <- base::`<<-`
[16:05:56.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.733]                   3L)]
[16:05:56.733]             }
[16:05:56.733]             function(cond) {
[16:05:56.733]                 is_error <- inherits(cond, "error")
[16:05:56.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.733]                   NULL)
[16:05:56.733]                 if (is_error) {
[16:05:56.733]                   sessionInformation <- function() {
[16:05:56.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.733]                       search = base::search(), system = base::Sys.info())
[16:05:56.733]                   }
[16:05:56.733]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.733]                     cond$call), session = sessionInformation(), 
[16:05:56.733]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.733]                   signalCondition(cond)
[16:05:56.733]                 }
[16:05:56.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.733]                 "immediateCondition"))) {
[16:05:56.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.733]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.733]                   if (TRUE && !signal) {
[16:05:56.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.733]                     {
[16:05:56.733]                       inherits <- base::inherits
[16:05:56.733]                       invokeRestart <- base::invokeRestart
[16:05:56.733]                       is.null <- base::is.null
[16:05:56.733]                       muffled <- FALSE
[16:05:56.733]                       if (inherits(cond, "message")) {
[16:05:56.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.733]                         if (muffled) 
[16:05:56.733]                           invokeRestart("muffleMessage")
[16:05:56.733]                       }
[16:05:56.733]                       else if (inherits(cond, "warning")) {
[16:05:56.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.733]                         if (muffled) 
[16:05:56.733]                           invokeRestart("muffleWarning")
[16:05:56.733]                       }
[16:05:56.733]                       else if (inherits(cond, "condition")) {
[16:05:56.733]                         if (!is.null(pattern)) {
[16:05:56.733]                           computeRestarts <- base::computeRestarts
[16:05:56.733]                           grepl <- base::grepl
[16:05:56.733]                           restarts <- computeRestarts(cond)
[16:05:56.733]                           for (restart in restarts) {
[16:05:56.733]                             name <- restart$name
[16:05:56.733]                             if (is.null(name)) 
[16:05:56.733]                               next
[16:05:56.733]                             if (!grepl(pattern, name)) 
[16:05:56.733]                               next
[16:05:56.733]                             invokeRestart(restart)
[16:05:56.733]                             muffled <- TRUE
[16:05:56.733]                             break
[16:05:56.733]                           }
[16:05:56.733]                         }
[16:05:56.733]                       }
[16:05:56.733]                       invisible(muffled)
[16:05:56.733]                     }
[16:05:56.733]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.733]                   }
[16:05:56.733]                 }
[16:05:56.733]                 else {
[16:05:56.733]                   if (TRUE) {
[16:05:56.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.733]                     {
[16:05:56.733]                       inherits <- base::inherits
[16:05:56.733]                       invokeRestart <- base::invokeRestart
[16:05:56.733]                       is.null <- base::is.null
[16:05:56.733]                       muffled <- FALSE
[16:05:56.733]                       if (inherits(cond, "message")) {
[16:05:56.733]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.733]                         if (muffled) 
[16:05:56.733]                           invokeRestart("muffleMessage")
[16:05:56.733]                       }
[16:05:56.733]                       else if (inherits(cond, "warning")) {
[16:05:56.733]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.733]                         if (muffled) 
[16:05:56.733]                           invokeRestart("muffleWarning")
[16:05:56.733]                       }
[16:05:56.733]                       else if (inherits(cond, "condition")) {
[16:05:56.733]                         if (!is.null(pattern)) {
[16:05:56.733]                           computeRestarts <- base::computeRestarts
[16:05:56.733]                           grepl <- base::grepl
[16:05:56.733]                           restarts <- computeRestarts(cond)
[16:05:56.733]                           for (restart in restarts) {
[16:05:56.733]                             name <- restart$name
[16:05:56.733]                             if (is.null(name)) 
[16:05:56.733]                               next
[16:05:56.733]                             if (!grepl(pattern, name)) 
[16:05:56.733]                               next
[16:05:56.733]                             invokeRestart(restart)
[16:05:56.733]                             muffled <- TRUE
[16:05:56.733]                             break
[16:05:56.733]                           }
[16:05:56.733]                         }
[16:05:56.733]                       }
[16:05:56.733]                       invisible(muffled)
[16:05:56.733]                     }
[16:05:56.733]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.733]                   }
[16:05:56.733]                 }
[16:05:56.733]             }
[16:05:56.733]         }))
[16:05:56.733]     }, error = function(ex) {
[16:05:56.733]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.733]                 ...future.rng), started = ...future.startTime, 
[16:05:56.733]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.733]             version = "1.8"), class = "FutureResult")
[16:05:56.733]     }, finally = {
[16:05:56.733]         if (!identical(...future.workdir, getwd())) 
[16:05:56.733]             setwd(...future.workdir)
[16:05:56.733]         {
[16:05:56.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.733]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.733]             }
[16:05:56.733]             base::options(...future.oldOptions)
[16:05:56.733]             if (.Platform$OS.type == "windows") {
[16:05:56.733]                 old_names <- names(...future.oldEnvVars)
[16:05:56.733]                 envs <- base::Sys.getenv()
[16:05:56.733]                 names <- names(envs)
[16:05:56.733]                 common <- intersect(names, old_names)
[16:05:56.733]                 added <- setdiff(names, old_names)
[16:05:56.733]                 removed <- setdiff(old_names, names)
[16:05:56.733]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.733]                   envs[common]]
[16:05:56.733]                 NAMES <- toupper(changed)
[16:05:56.733]                 args <- list()
[16:05:56.733]                 for (kk in seq_along(NAMES)) {
[16:05:56.733]                   name <- changed[[kk]]
[16:05:56.733]                   NAME <- NAMES[[kk]]
[16:05:56.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.733]                     next
[16:05:56.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.733]                 }
[16:05:56.733]                 NAMES <- toupper(added)
[16:05:56.733]                 for (kk in seq_along(NAMES)) {
[16:05:56.733]                   name <- added[[kk]]
[16:05:56.733]                   NAME <- NAMES[[kk]]
[16:05:56.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.733]                     next
[16:05:56.733]                   args[[name]] <- ""
[16:05:56.733]                 }
[16:05:56.733]                 NAMES <- toupper(removed)
[16:05:56.733]                 for (kk in seq_along(NAMES)) {
[16:05:56.733]                   name <- removed[[kk]]
[16:05:56.733]                   NAME <- NAMES[[kk]]
[16:05:56.733]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.733]                     next
[16:05:56.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.733]                 }
[16:05:56.733]                 if (length(args) > 0) 
[16:05:56.733]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.733]             }
[16:05:56.733]             else {
[16:05:56.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.733]             }
[16:05:56.733]             {
[16:05:56.733]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.733]                   0L) {
[16:05:56.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.733]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.733]                   base::options(opts)
[16:05:56.733]                 }
[16:05:56.733]                 {
[16:05:56.733]                   {
[16:05:56.733]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.733]                     NULL
[16:05:56.733]                   }
[16:05:56.733]                   options(future.plan = NULL)
[16:05:56.733]                   if (is.na(NA_character_)) 
[16:05:56.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.733]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.733]                     envir = parent.frame()) 
[16:05:56.733]                   {
[16:05:56.733]                     default_workers <- missing(workers)
[16:05:56.733]                     if (is.function(workers)) 
[16:05:56.733]                       workers <- workers()
[16:05:56.733]                     workers <- structure(as.integer(workers), 
[16:05:56.733]                       class = class(workers))
[16:05:56.733]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.733]                       1L)
[16:05:56.733]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.733]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.733]                       if (default_workers) 
[16:05:56.733]                         supportsMulticore(warn = TRUE)
[16:05:56.733]                       return(sequential(..., envir = envir))
[16:05:56.733]                     }
[16:05:56.733]                     oopts <- options(mc.cores = workers)
[16:05:56.733]                     on.exit(options(oopts))
[16:05:56.733]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.733]                       envir = envir)
[16:05:56.733]                     if (!future$lazy) 
[16:05:56.733]                       future <- run(future)
[16:05:56.733]                     invisible(future)
[16:05:56.733]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.733]                 }
[16:05:56.733]             }
[16:05:56.733]         }
[16:05:56.733]     })
[16:05:56.733]     if (TRUE) {
[16:05:56.733]         base::sink(type = "output", split = FALSE)
[16:05:56.733]         if (TRUE) {
[16:05:56.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.733]         }
[16:05:56.733]         else {
[16:05:56.733]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.733]         }
[16:05:56.733]         base::close(...future.stdout)
[16:05:56.733]         ...future.stdout <- NULL
[16:05:56.733]     }
[16:05:56.733]     ...future.result$conditions <- ...future.conditions
[16:05:56.733]     ...future.result$finished <- base::Sys.time()
[16:05:56.733]     ...future.result
[16:05:56.733] }
[16:05:56.736] assign_globals() ...
[16:05:56.736] List of 1
[16:05:56.736]  $ kk: int 3
[16:05:56.736]  - attr(*, "where")=List of 1
[16:05:56.736]   ..$ kk:<environment: R_EmptyEnv> 
[16:05:56.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:05:56.736]  - attr(*, "resolved")= logi FALSE
[16:05:56.736]  - attr(*, "total_size")= num 56
[16:05:56.736]  - attr(*, "already-done")= logi TRUE
[16:05:56.740] - copied ‘kk’ to environment
[16:05:56.741] assign_globals() ... done
[16:05:56.744] requestCore(): workers = 2
[16:05:56.745] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.769] plan(): Setting new future strategy stack:
[16:05:56.769] List of future strategies:
[16:05:56.769] 1. multicore:
[16:05:56.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.769]    - tweaked: FALSE
[16:05:56.769]    - call: plan(strategy)
[16:05:56.773] plan(): nbrOfWorkers() = 2
[16:05:56.777] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[16:05:56.788] result() for MulticoreFuture ...
[16:05:56.789] result() for MulticoreFuture ...
[16:05:56.789] result() for MulticoreFuture ... done
[16:05:56.789] result() for MulticoreFuture ... done
[16:05:56.790] result() for MulticoreFuture ...
[16:05:56.790] result() for MulticoreFuture ... done
[16:05:56.792] MulticoreFuture started
[16:05:56.793] - Launch lazy future ... done
[16:05:56.793] run() for ‘MulticoreFuture’ ... done
[16:05:56.794] plan(): Setting new future strategy stack:
[16:05:56.794] List of future strategies:
[16:05:56.794] 1. sequential:
[16:05:56.794]    - args: function (..., envir = parent.frame())
[16:05:56.794]    - tweaked: FALSE
[16:05:56.794]    - call: NULL
[16:05:56.795] plan(): nbrOfWorkers() = 1
[16:05:56.814] Future #1
[16:05:56.815] plan(): Setting new future strategy stack:
[16:05:56.815]  length: 2 (resolved future 1)
[16:05:56.815] List of future strategies:
[16:05:56.815] 1. multicore:
[16:05:56.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.815]    - tweaked: FALSE
[16:05:56.815]    - call: plan(strategy)
[16:05:56.819] plan(): nbrOfWorkers() = 2
[16:05:56.820] Future #2
[16:05:56.820]  length: 1 (resolved future 2)
[16:05:56.898] plan(): Setting new future strategy stack:
[16:05:56.898] List of future strategies:
[16:05:56.898] 1. multicore:
[16:05:56.898]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.898]    - tweaked: FALSE
[16:05:56.898]    - call: plan(strategy)
[16:05:56.903] plan(): nbrOfWorkers() = 2
[16:05:56.904] Future #3
[16:05:56.904]  length: 0 (resolved future 3)
[16:05:56.904] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:05:56.906] resolve() on environment ...
[16:05:56.906]  recursive: 0
[16:05:56.907]  elements: [2] ‘a’, ‘b’
[16:05:56.907]  length: 1 (resolved future 1)
[16:05:56.907]  length: 0 (resolved future 2)
[16:05:56.908] resolve() on environment ... DONE
[16:05:56.908] getGlobalsAndPackages() ...
[16:05:56.908] Searching for globals...
[16:05:56.909] 
[16:05:56.909] Searching for globals ... DONE
[16:05:56.910] - globals: [0] <none>
[16:05:56.910] getGlobalsAndPackages() ... DONE
[16:05:56.910] run() for ‘Future’ ...
[16:05:56.910] - state: ‘created’
[16:05:56.910] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.915] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.915]   - Field: ‘label’
[16:05:56.915]   - Field: ‘local’
[16:05:56.916]   - Field: ‘owner’
[16:05:56.916]   - Field: ‘envir’
[16:05:56.916]   - Field: ‘workers’
[16:05:56.916]   - Field: ‘packages’
[16:05:56.916]   - Field: ‘gc’
[16:05:56.916]   - Field: ‘job’
[16:05:56.916]   - Field: ‘conditions’
[16:05:56.917]   - Field: ‘expr’
[16:05:56.917]   - Field: ‘uuid’
[16:05:56.917]   - Field: ‘seed’
[16:05:56.917]   - Field: ‘version’
[16:05:56.917]   - Field: ‘result’
[16:05:56.917]   - Field: ‘asynchronous’
[16:05:56.918]   - Field: ‘calls’
[16:05:56.918]   - Field: ‘globals’
[16:05:56.918]   - Field: ‘stdout’
[16:05:56.918]   - Field: ‘earlySignal’
[16:05:56.918]   - Field: ‘lazy’
[16:05:56.918]   - Field: ‘state’
[16:05:56.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.919] - Launch lazy future ...
[16:05:56.919] Packages needed by the future expression (n = 0): <none>
[16:05:56.919] Packages needed by future strategies (n = 0): <none>
[16:05:56.920] {
[16:05:56.920]     {
[16:05:56.920]         {
[16:05:56.920]             ...future.startTime <- base::Sys.time()
[16:05:56.920]             {
[16:05:56.920]                 {
[16:05:56.920]                   {
[16:05:56.920]                     {
[16:05:56.920]                       base::local({
[16:05:56.920]                         has_future <- base::requireNamespace("future", 
[16:05:56.920]                           quietly = TRUE)
[16:05:56.920]                         if (has_future) {
[16:05:56.920]                           ns <- base::getNamespace("future")
[16:05:56.920]                           version <- ns[[".package"]][["version"]]
[16:05:56.920]                           if (is.null(version)) 
[16:05:56.920]                             version <- utils::packageVersion("future")
[16:05:56.920]                         }
[16:05:56.920]                         else {
[16:05:56.920]                           version <- NULL
[16:05:56.920]                         }
[16:05:56.920]                         if (!has_future || version < "1.8.0") {
[16:05:56.920]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.920]                             "", base::R.version$version.string), 
[16:05:56.920]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.920]                               "release", "version")], collapse = " "), 
[16:05:56.920]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.920]                             info)
[16:05:56.920]                           info <- base::paste(info, collapse = "; ")
[16:05:56.920]                           if (!has_future) {
[16:05:56.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.920]                               info)
[16:05:56.920]                           }
[16:05:56.920]                           else {
[16:05:56.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.920]                               info, version)
[16:05:56.920]                           }
[16:05:56.920]                           base::stop(msg)
[16:05:56.920]                         }
[16:05:56.920]                       })
[16:05:56.920]                     }
[16:05:56.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.920]                     base::options(mc.cores = 1L)
[16:05:56.920]                   }
[16:05:56.920]                   options(future.plan = NULL)
[16:05:56.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.920]                 }
[16:05:56.920]                 ...future.workdir <- getwd()
[16:05:56.920]             }
[16:05:56.920]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.920]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.920]         }
[16:05:56.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.920]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.920]             base::names(...future.oldOptions))
[16:05:56.920]     }
[16:05:56.920]     if (FALSE) {
[16:05:56.920]     }
[16:05:56.920]     else {
[16:05:56.920]         if (TRUE) {
[16:05:56.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.920]                 open = "w")
[16:05:56.920]         }
[16:05:56.920]         else {
[16:05:56.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.920]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.920]         }
[16:05:56.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.920]             base::sink(type = "output", split = FALSE)
[16:05:56.920]             base::close(...future.stdout)
[16:05:56.920]         }, add = TRUE)
[16:05:56.920]     }
[16:05:56.920]     ...future.frame <- base::sys.nframe()
[16:05:56.920]     ...future.conditions <- base::list()
[16:05:56.920]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.920]     if (FALSE) {
[16:05:56.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.920]     }
[16:05:56.920]     ...future.result <- base::tryCatch({
[16:05:56.920]         base::withCallingHandlers({
[16:05:56.920]             ...future.value <- base::withVisible(base::local({
[16:05:56.920]                 withCallingHandlers({
[16:05:56.920]                   1
[16:05:56.920]                 }, immediateCondition = function(cond) {
[16:05:56.920]                   save_rds <- function (object, pathname, ...) 
[16:05:56.920]                   {
[16:05:56.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.920]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.920]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.920]                         fi_tmp[["mtime"]])
[16:05:56.920]                     }
[16:05:56.920]                     tryCatch({
[16:05:56.920]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.920]                     }, error = function(ex) {
[16:05:56.920]                       msg <- conditionMessage(ex)
[16:05:56.920]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.920]                         fi_tmp[["mtime"]], msg)
[16:05:56.920]                       ex$message <- msg
[16:05:56.920]                       stop(ex)
[16:05:56.920]                     })
[16:05:56.920]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.920]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.920]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.920]                       fi <- file.info(pathname)
[16:05:56.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.920]                         fi[["size"]], fi[["mtime"]])
[16:05:56.920]                       stop(msg)
[16:05:56.920]                     }
[16:05:56.920]                     invisible(pathname)
[16:05:56.920]                   }
[16:05:56.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.920]                     rootPath = tempdir()) 
[16:05:56.920]                   {
[16:05:56.920]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.920]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.920]                       tmpdir = path, fileext = ".rds")
[16:05:56.920]                     save_rds(obj, file)
[16:05:56.920]                   }
[16:05:56.920]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.920]                   {
[16:05:56.920]                     inherits <- base::inherits
[16:05:56.920]                     invokeRestart <- base::invokeRestart
[16:05:56.920]                     is.null <- base::is.null
[16:05:56.920]                     muffled <- FALSE
[16:05:56.920]                     if (inherits(cond, "message")) {
[16:05:56.920]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.920]                       if (muffled) 
[16:05:56.920]                         invokeRestart("muffleMessage")
[16:05:56.920]                     }
[16:05:56.920]                     else if (inherits(cond, "warning")) {
[16:05:56.920]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.920]                       if (muffled) 
[16:05:56.920]                         invokeRestart("muffleWarning")
[16:05:56.920]                     }
[16:05:56.920]                     else if (inherits(cond, "condition")) {
[16:05:56.920]                       if (!is.null(pattern)) {
[16:05:56.920]                         computeRestarts <- base::computeRestarts
[16:05:56.920]                         grepl <- base::grepl
[16:05:56.920]                         restarts <- computeRestarts(cond)
[16:05:56.920]                         for (restart in restarts) {
[16:05:56.920]                           name <- restart$name
[16:05:56.920]                           if (is.null(name)) 
[16:05:56.920]                             next
[16:05:56.920]                           if (!grepl(pattern, name)) 
[16:05:56.920]                             next
[16:05:56.920]                           invokeRestart(restart)
[16:05:56.920]                           muffled <- TRUE
[16:05:56.920]                           break
[16:05:56.920]                         }
[16:05:56.920]                       }
[16:05:56.920]                     }
[16:05:56.920]                     invisible(muffled)
[16:05:56.920]                   }
[16:05:56.920]                   muffleCondition(cond)
[16:05:56.920]                 })
[16:05:56.920]             }))
[16:05:56.920]             future::FutureResult(value = ...future.value$value, 
[16:05:56.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.920]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.920]                     ...future.globalenv.names))
[16:05:56.920]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.920]         }, condition = base::local({
[16:05:56.920]             c <- base::c
[16:05:56.920]             inherits <- base::inherits
[16:05:56.920]             invokeRestart <- base::invokeRestart
[16:05:56.920]             length <- base::length
[16:05:56.920]             list <- base::list
[16:05:56.920]             seq.int <- base::seq.int
[16:05:56.920]             signalCondition <- base::signalCondition
[16:05:56.920]             sys.calls <- base::sys.calls
[16:05:56.920]             `[[` <- base::`[[`
[16:05:56.920]             `+` <- base::`+`
[16:05:56.920]             `<<-` <- base::`<<-`
[16:05:56.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.920]                   3L)]
[16:05:56.920]             }
[16:05:56.920]             function(cond) {
[16:05:56.920]                 is_error <- inherits(cond, "error")
[16:05:56.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.920]                   NULL)
[16:05:56.920]                 if (is_error) {
[16:05:56.920]                   sessionInformation <- function() {
[16:05:56.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.920]                       search = base::search(), system = base::Sys.info())
[16:05:56.920]                   }
[16:05:56.920]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.920]                     cond$call), session = sessionInformation(), 
[16:05:56.920]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.920]                   signalCondition(cond)
[16:05:56.920]                 }
[16:05:56.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.920]                 "immediateCondition"))) {
[16:05:56.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.920]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.920]                   if (TRUE && !signal) {
[16:05:56.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.920]                     {
[16:05:56.920]                       inherits <- base::inherits
[16:05:56.920]                       invokeRestart <- base::invokeRestart
[16:05:56.920]                       is.null <- base::is.null
[16:05:56.920]                       muffled <- FALSE
[16:05:56.920]                       if (inherits(cond, "message")) {
[16:05:56.920]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.920]                         if (muffled) 
[16:05:56.920]                           invokeRestart("muffleMessage")
[16:05:56.920]                       }
[16:05:56.920]                       else if (inherits(cond, "warning")) {
[16:05:56.920]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.920]                         if (muffled) 
[16:05:56.920]                           invokeRestart("muffleWarning")
[16:05:56.920]                       }
[16:05:56.920]                       else if (inherits(cond, "condition")) {
[16:05:56.920]                         if (!is.null(pattern)) {
[16:05:56.920]                           computeRestarts <- base::computeRestarts
[16:05:56.920]                           grepl <- base::grepl
[16:05:56.920]                           restarts <- computeRestarts(cond)
[16:05:56.920]                           for (restart in restarts) {
[16:05:56.920]                             name <- restart$name
[16:05:56.920]                             if (is.null(name)) 
[16:05:56.920]                               next
[16:05:56.920]                             if (!grepl(pattern, name)) 
[16:05:56.920]                               next
[16:05:56.920]                             invokeRestart(restart)
[16:05:56.920]                             muffled <- TRUE
[16:05:56.920]                             break
[16:05:56.920]                           }
[16:05:56.920]                         }
[16:05:56.920]                       }
[16:05:56.920]                       invisible(muffled)
[16:05:56.920]                     }
[16:05:56.920]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.920]                   }
[16:05:56.920]                 }
[16:05:56.920]                 else {
[16:05:56.920]                   if (TRUE) {
[16:05:56.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.920]                     {
[16:05:56.920]                       inherits <- base::inherits
[16:05:56.920]                       invokeRestart <- base::invokeRestart
[16:05:56.920]                       is.null <- base::is.null
[16:05:56.920]                       muffled <- FALSE
[16:05:56.920]                       if (inherits(cond, "message")) {
[16:05:56.920]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.920]                         if (muffled) 
[16:05:56.920]                           invokeRestart("muffleMessage")
[16:05:56.920]                       }
[16:05:56.920]                       else if (inherits(cond, "warning")) {
[16:05:56.920]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.920]                         if (muffled) 
[16:05:56.920]                           invokeRestart("muffleWarning")
[16:05:56.920]                       }
[16:05:56.920]                       else if (inherits(cond, "condition")) {
[16:05:56.920]                         if (!is.null(pattern)) {
[16:05:56.920]                           computeRestarts <- base::computeRestarts
[16:05:56.920]                           grepl <- base::grepl
[16:05:56.920]                           restarts <- computeRestarts(cond)
[16:05:56.920]                           for (restart in restarts) {
[16:05:56.920]                             name <- restart$name
[16:05:56.920]                             if (is.null(name)) 
[16:05:56.920]                               next
[16:05:56.920]                             if (!grepl(pattern, name)) 
[16:05:56.920]                               next
[16:05:56.920]                             invokeRestart(restart)
[16:05:56.920]                             muffled <- TRUE
[16:05:56.920]                             break
[16:05:56.920]                           }
[16:05:56.920]                         }
[16:05:56.920]                       }
[16:05:56.920]                       invisible(muffled)
[16:05:56.920]                     }
[16:05:56.920]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.920]                   }
[16:05:56.920]                 }
[16:05:56.920]             }
[16:05:56.920]         }))
[16:05:56.920]     }, error = function(ex) {
[16:05:56.920]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.920]                 ...future.rng), started = ...future.startTime, 
[16:05:56.920]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.920]             version = "1.8"), class = "FutureResult")
[16:05:56.920]     }, finally = {
[16:05:56.920]         if (!identical(...future.workdir, getwd())) 
[16:05:56.920]             setwd(...future.workdir)
[16:05:56.920]         {
[16:05:56.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.920]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.920]             }
[16:05:56.920]             base::options(...future.oldOptions)
[16:05:56.920]             if (.Platform$OS.type == "windows") {
[16:05:56.920]                 old_names <- names(...future.oldEnvVars)
[16:05:56.920]                 envs <- base::Sys.getenv()
[16:05:56.920]                 names <- names(envs)
[16:05:56.920]                 common <- intersect(names, old_names)
[16:05:56.920]                 added <- setdiff(names, old_names)
[16:05:56.920]                 removed <- setdiff(old_names, names)
[16:05:56.920]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.920]                   envs[common]]
[16:05:56.920]                 NAMES <- toupper(changed)
[16:05:56.920]                 args <- list()
[16:05:56.920]                 for (kk in seq_along(NAMES)) {
[16:05:56.920]                   name <- changed[[kk]]
[16:05:56.920]                   NAME <- NAMES[[kk]]
[16:05:56.920]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.920]                     next
[16:05:56.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.920]                 }
[16:05:56.920]                 NAMES <- toupper(added)
[16:05:56.920]                 for (kk in seq_along(NAMES)) {
[16:05:56.920]                   name <- added[[kk]]
[16:05:56.920]                   NAME <- NAMES[[kk]]
[16:05:56.920]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.920]                     next
[16:05:56.920]                   args[[name]] <- ""
[16:05:56.920]                 }
[16:05:56.920]                 NAMES <- toupper(removed)
[16:05:56.920]                 for (kk in seq_along(NAMES)) {
[16:05:56.920]                   name <- removed[[kk]]
[16:05:56.920]                   NAME <- NAMES[[kk]]
[16:05:56.920]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.920]                     next
[16:05:56.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.920]                 }
[16:05:56.920]                 if (length(args) > 0) 
[16:05:56.920]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.920]             }
[16:05:56.920]             else {
[16:05:56.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.920]             }
[16:05:56.920]             {
[16:05:56.920]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.920]                   0L) {
[16:05:56.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.920]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.920]                   base::options(opts)
[16:05:56.920]                 }
[16:05:56.920]                 {
[16:05:56.920]                   {
[16:05:56.920]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.920]                     NULL
[16:05:56.920]                   }
[16:05:56.920]                   options(future.plan = NULL)
[16:05:56.920]                   if (is.na(NA_character_)) 
[16:05:56.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.920]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.920]                     envir = parent.frame()) 
[16:05:56.920]                   {
[16:05:56.920]                     default_workers <- missing(workers)
[16:05:56.920]                     if (is.function(workers)) 
[16:05:56.920]                       workers <- workers()
[16:05:56.920]                     workers <- structure(as.integer(workers), 
[16:05:56.920]                       class = class(workers))
[16:05:56.920]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.920]                       1L)
[16:05:56.920]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.920]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.920]                       if (default_workers) 
[16:05:56.920]                         supportsMulticore(warn = TRUE)
[16:05:56.920]                       return(sequential(..., envir = envir))
[16:05:56.920]                     }
[16:05:56.920]                     oopts <- options(mc.cores = workers)
[16:05:56.920]                     on.exit(options(oopts))
[16:05:56.920]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.920]                       envir = envir)
[16:05:56.920]                     if (!future$lazy) 
[16:05:56.920]                       future <- run(future)
[16:05:56.920]                     invisible(future)
[16:05:56.920]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.920]                 }
[16:05:56.920]             }
[16:05:56.920]         }
[16:05:56.920]     })
[16:05:56.920]     if (TRUE) {
[16:05:56.920]         base::sink(type = "output", split = FALSE)
[16:05:56.920]         if (TRUE) {
[16:05:56.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.920]         }
[16:05:56.920]         else {
[16:05:56.920]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.920]         }
[16:05:56.920]         base::close(...future.stdout)
[16:05:56.920]         ...future.stdout <- NULL
[16:05:56.920]     }
[16:05:56.920]     ...future.result$conditions <- ...future.conditions
[16:05:56.920]     ...future.result$finished <- base::Sys.time()
[16:05:56.920]     ...future.result
[16:05:56.920] }
[16:05:56.924] requestCore(): workers = 2
[16:05:56.924] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.935] result() for MulticoreFuture ...
[16:05:56.936] result() for MulticoreFuture ...
[16:05:56.936] result() for MulticoreFuture ... done
[16:05:56.936] result() for MulticoreFuture ... done
[16:05:56.936] result() for MulticoreFuture ...
[16:05:56.936] result() for MulticoreFuture ... done
[16:05:56.939] MulticoreFuture started
[16:05:56.939] - Launch lazy future ... done
[16:05:56.939] run() for ‘MulticoreFuture’ ... done
[16:05:56.940] getGlobalsAndPackages() ...
[16:05:56.940] Searching for globals...
[16:05:56.940] plan(): Setting new future strategy stack:
[16:05:56.941] 
[16:05:56.941] Searching for globals ... DONE
[16:05:56.940] List of future strategies:
[16:05:56.940] 1. sequential:
[16:05:56.940]    - args: function (..., envir = parent.frame())
[16:05:56.940]    - tweaked: FALSE
[16:05:56.940]    - call: NULL
[16:05:56.941] - globals: [0] <none>
[16:05:56.941] plan(): nbrOfWorkers() = 1
[16:05:56.941] getGlobalsAndPackages() ... DONE
[16:05:56.942] run() for ‘Future’ ...
[16:05:56.942] - state: ‘created’
[16:05:56.942] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:56.943] plan(): Setting new future strategy stack:
[16:05:56.943] List of future strategies:
[16:05:56.943] 1. multicore:
[16:05:56.943]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.943]    - tweaked: FALSE
[16:05:56.943]    - call: plan(strategy)
[16:05:56.948] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:56.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:56.948] plan(): nbrOfWorkers() = 2
[16:05:56.948]   - Field: ‘label’
[16:05:56.948]   - Field: ‘local’
[16:05:56.948]   - Field: ‘owner’
[16:05:56.949]   - Field: ‘envir’
[16:05:56.949]   - Field: ‘workers’
[16:05:56.949]   - Field: ‘packages’
[16:05:56.949]   - Field: ‘gc’
[16:05:56.949]   - Field: ‘job’
[16:05:56.949]   - Field: ‘conditions’
[16:05:56.950]   - Field: ‘expr’
[16:05:56.950]   - Field: ‘uuid’
[16:05:56.950]   - Field: ‘seed’
[16:05:56.950]   - Field: ‘version’
[16:05:56.950]   - Field: ‘result’
[16:05:56.950]   - Field: ‘asynchronous’
[16:05:56.950]   - Field: ‘calls’
[16:05:56.951]   - Field: ‘globals’
[16:05:56.951]   - Field: ‘stdout’
[16:05:56.951]   - Field: ‘earlySignal’
[16:05:56.951]   - Field: ‘lazy’
[16:05:56.951]   - Field: ‘state’
[16:05:56.951] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:56.951] - Launch lazy future ...
[16:05:56.952] Packages needed by the future expression (n = 0): <none>
[16:05:56.952] Packages needed by future strategies (n = 0): <none>
[16:05:56.953] {
[16:05:56.953]     {
[16:05:56.953]         {
[16:05:56.953]             ...future.startTime <- base::Sys.time()
[16:05:56.953]             {
[16:05:56.953]                 {
[16:05:56.953]                   {
[16:05:56.953]                     {
[16:05:56.953]                       base::local({
[16:05:56.953]                         has_future <- base::requireNamespace("future", 
[16:05:56.953]                           quietly = TRUE)
[16:05:56.953]                         if (has_future) {
[16:05:56.953]                           ns <- base::getNamespace("future")
[16:05:56.953]                           version <- ns[[".package"]][["version"]]
[16:05:56.953]                           if (is.null(version)) 
[16:05:56.953]                             version <- utils::packageVersion("future")
[16:05:56.953]                         }
[16:05:56.953]                         else {
[16:05:56.953]                           version <- NULL
[16:05:56.953]                         }
[16:05:56.953]                         if (!has_future || version < "1.8.0") {
[16:05:56.953]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:56.953]                             "", base::R.version$version.string), 
[16:05:56.953]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:56.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:56.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:56.953]                               "release", "version")], collapse = " "), 
[16:05:56.953]                             hostname = base::Sys.info()[["nodename"]])
[16:05:56.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:56.953]                             info)
[16:05:56.953]                           info <- base::paste(info, collapse = "; ")
[16:05:56.953]                           if (!has_future) {
[16:05:56.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:56.953]                               info)
[16:05:56.953]                           }
[16:05:56.953]                           else {
[16:05:56.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:56.953]                               info, version)
[16:05:56.953]                           }
[16:05:56.953]                           base::stop(msg)
[16:05:56.953]                         }
[16:05:56.953]                       })
[16:05:56.953]                     }
[16:05:56.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:56.953]                     base::options(mc.cores = 1L)
[16:05:56.953]                   }
[16:05:56.953]                   options(future.plan = NULL)
[16:05:56.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:56.953]                 }
[16:05:56.953]                 ...future.workdir <- getwd()
[16:05:56.953]             }
[16:05:56.953]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:56.953]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:56.953]         }
[16:05:56.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:56.953]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:56.953]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:56.953]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:56.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:56.953]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:56.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:56.953]             base::names(...future.oldOptions))
[16:05:56.953]     }
[16:05:56.953]     if (FALSE) {
[16:05:56.953]     }
[16:05:56.953]     else {
[16:05:56.953]         if (TRUE) {
[16:05:56.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:56.953]                 open = "w")
[16:05:56.953]         }
[16:05:56.953]         else {
[16:05:56.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:56.953]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:56.953]         }
[16:05:56.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:56.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:56.953]             base::sink(type = "output", split = FALSE)
[16:05:56.953]             base::close(...future.stdout)
[16:05:56.953]         }, add = TRUE)
[16:05:56.953]     }
[16:05:56.953]     ...future.frame <- base::sys.nframe()
[16:05:56.953]     ...future.conditions <- base::list()
[16:05:56.953]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:56.953]     if (FALSE) {
[16:05:56.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:56.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:56.953]     }
[16:05:56.953]     ...future.result <- base::tryCatch({
[16:05:56.953]         base::withCallingHandlers({
[16:05:56.953]             ...future.value <- base::withVisible(base::local({
[16:05:56.953]                 withCallingHandlers({
[16:05:56.953]                   2
[16:05:56.953]                 }, immediateCondition = function(cond) {
[16:05:56.953]                   save_rds <- function (object, pathname, ...) 
[16:05:56.953]                   {
[16:05:56.953]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:56.953]                     if (file_test("-f", pathname_tmp)) {
[16:05:56.953]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.953]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:56.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.953]                         fi_tmp[["mtime"]])
[16:05:56.953]                     }
[16:05:56.953]                     tryCatch({
[16:05:56.953]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:56.953]                     }, error = function(ex) {
[16:05:56.953]                       msg <- conditionMessage(ex)
[16:05:56.953]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.953]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:56.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.953]                         fi_tmp[["mtime"]], msg)
[16:05:56.953]                       ex$message <- msg
[16:05:56.953]                       stop(ex)
[16:05:56.953]                     })
[16:05:56.953]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:56.953]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:56.953]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:56.953]                       fi_tmp <- file.info(pathname_tmp)
[16:05:56.953]                       fi <- file.info(pathname)
[16:05:56.953]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:56.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:56.953]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:56.953]                         fi[["size"]], fi[["mtime"]])
[16:05:56.953]                       stop(msg)
[16:05:56.953]                     }
[16:05:56.953]                     invisible(pathname)
[16:05:56.953]                   }
[16:05:56.953]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:56.953]                     rootPath = tempdir()) 
[16:05:56.953]                   {
[16:05:56.953]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:56.953]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:56.953]                       tmpdir = path, fileext = ".rds")
[16:05:56.953]                     save_rds(obj, file)
[16:05:56.953]                   }
[16:05:56.953]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:56.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.953]                   {
[16:05:56.953]                     inherits <- base::inherits
[16:05:56.953]                     invokeRestart <- base::invokeRestart
[16:05:56.953]                     is.null <- base::is.null
[16:05:56.953]                     muffled <- FALSE
[16:05:56.953]                     if (inherits(cond, "message")) {
[16:05:56.953]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:56.953]                       if (muffled) 
[16:05:56.953]                         invokeRestart("muffleMessage")
[16:05:56.953]                     }
[16:05:56.953]                     else if (inherits(cond, "warning")) {
[16:05:56.953]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:56.953]                       if (muffled) 
[16:05:56.953]                         invokeRestart("muffleWarning")
[16:05:56.953]                     }
[16:05:56.953]                     else if (inherits(cond, "condition")) {
[16:05:56.953]                       if (!is.null(pattern)) {
[16:05:56.953]                         computeRestarts <- base::computeRestarts
[16:05:56.953]                         grepl <- base::grepl
[16:05:56.953]                         restarts <- computeRestarts(cond)
[16:05:56.953]                         for (restart in restarts) {
[16:05:56.953]                           name <- restart$name
[16:05:56.953]                           if (is.null(name)) 
[16:05:56.953]                             next
[16:05:56.953]                           if (!grepl(pattern, name)) 
[16:05:56.953]                             next
[16:05:56.953]                           invokeRestart(restart)
[16:05:56.953]                           muffled <- TRUE
[16:05:56.953]                           break
[16:05:56.953]                         }
[16:05:56.953]                       }
[16:05:56.953]                     }
[16:05:56.953]                     invisible(muffled)
[16:05:56.953]                   }
[16:05:56.953]                   muffleCondition(cond)
[16:05:56.953]                 })
[16:05:56.953]             }))
[16:05:56.953]             future::FutureResult(value = ...future.value$value, 
[16:05:56.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.953]                   ...future.rng), globalenv = if (FALSE) 
[16:05:56.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:56.953]                     ...future.globalenv.names))
[16:05:56.953]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:56.953]         }, condition = base::local({
[16:05:56.953]             c <- base::c
[16:05:56.953]             inherits <- base::inherits
[16:05:56.953]             invokeRestart <- base::invokeRestart
[16:05:56.953]             length <- base::length
[16:05:56.953]             list <- base::list
[16:05:56.953]             seq.int <- base::seq.int
[16:05:56.953]             signalCondition <- base::signalCondition
[16:05:56.953]             sys.calls <- base::sys.calls
[16:05:56.953]             `[[` <- base::`[[`
[16:05:56.953]             `+` <- base::`+`
[16:05:56.953]             `<<-` <- base::`<<-`
[16:05:56.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:56.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:56.953]                   3L)]
[16:05:56.953]             }
[16:05:56.953]             function(cond) {
[16:05:56.953]                 is_error <- inherits(cond, "error")
[16:05:56.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:56.953]                   NULL)
[16:05:56.953]                 if (is_error) {
[16:05:56.953]                   sessionInformation <- function() {
[16:05:56.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:56.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:56.953]                       search = base::search(), system = base::Sys.info())
[16:05:56.953]                   }
[16:05:56.953]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:56.953]                     cond$call), session = sessionInformation(), 
[16:05:56.953]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:56.953]                   signalCondition(cond)
[16:05:56.953]                 }
[16:05:56.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:56.953]                 "immediateCondition"))) {
[16:05:56.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:56.953]                   ...future.conditions[[length(...future.conditions) + 
[16:05:56.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:56.953]                   if (TRUE && !signal) {
[16:05:56.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.953]                     {
[16:05:56.953]                       inherits <- base::inherits
[16:05:56.953]                       invokeRestart <- base::invokeRestart
[16:05:56.953]                       is.null <- base::is.null
[16:05:56.953]                       muffled <- FALSE
[16:05:56.953]                       if (inherits(cond, "message")) {
[16:05:56.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.953]                         if (muffled) 
[16:05:56.953]                           invokeRestart("muffleMessage")
[16:05:56.953]                       }
[16:05:56.953]                       else if (inherits(cond, "warning")) {
[16:05:56.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.953]                         if (muffled) 
[16:05:56.953]                           invokeRestart("muffleWarning")
[16:05:56.953]                       }
[16:05:56.953]                       else if (inherits(cond, "condition")) {
[16:05:56.953]                         if (!is.null(pattern)) {
[16:05:56.953]                           computeRestarts <- base::computeRestarts
[16:05:56.953]                           grepl <- base::grepl
[16:05:56.953]                           restarts <- computeRestarts(cond)
[16:05:56.953]                           for (restart in restarts) {
[16:05:56.953]                             name <- restart$name
[16:05:56.953]                             if (is.null(name)) 
[16:05:56.953]                               next
[16:05:56.953]                             if (!grepl(pattern, name)) 
[16:05:56.953]                               next
[16:05:56.953]                             invokeRestart(restart)
[16:05:56.953]                             muffled <- TRUE
[16:05:56.953]                             break
[16:05:56.953]                           }
[16:05:56.953]                         }
[16:05:56.953]                       }
[16:05:56.953]                       invisible(muffled)
[16:05:56.953]                     }
[16:05:56.953]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.953]                   }
[16:05:56.953]                 }
[16:05:56.953]                 else {
[16:05:56.953]                   if (TRUE) {
[16:05:56.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:56.953]                     {
[16:05:56.953]                       inherits <- base::inherits
[16:05:56.953]                       invokeRestart <- base::invokeRestart
[16:05:56.953]                       is.null <- base::is.null
[16:05:56.953]                       muffled <- FALSE
[16:05:56.953]                       if (inherits(cond, "message")) {
[16:05:56.953]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:56.953]                         if (muffled) 
[16:05:56.953]                           invokeRestart("muffleMessage")
[16:05:56.953]                       }
[16:05:56.953]                       else if (inherits(cond, "warning")) {
[16:05:56.953]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:56.953]                         if (muffled) 
[16:05:56.953]                           invokeRestart("muffleWarning")
[16:05:56.953]                       }
[16:05:56.953]                       else if (inherits(cond, "condition")) {
[16:05:56.953]                         if (!is.null(pattern)) {
[16:05:56.953]                           computeRestarts <- base::computeRestarts
[16:05:56.953]                           grepl <- base::grepl
[16:05:56.953]                           restarts <- computeRestarts(cond)
[16:05:56.953]                           for (restart in restarts) {
[16:05:56.953]                             name <- restart$name
[16:05:56.953]                             if (is.null(name)) 
[16:05:56.953]                               next
[16:05:56.953]                             if (!grepl(pattern, name)) 
[16:05:56.953]                               next
[16:05:56.953]                             invokeRestart(restart)
[16:05:56.953]                             muffled <- TRUE
[16:05:56.953]                             break
[16:05:56.953]                           }
[16:05:56.953]                         }
[16:05:56.953]                       }
[16:05:56.953]                       invisible(muffled)
[16:05:56.953]                     }
[16:05:56.953]                     muffleCondition(cond, pattern = "^muffle")
[16:05:56.953]                   }
[16:05:56.953]                 }
[16:05:56.953]             }
[16:05:56.953]         }))
[16:05:56.953]     }, error = function(ex) {
[16:05:56.953]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:56.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:56.953]                 ...future.rng), started = ...future.startTime, 
[16:05:56.953]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:56.953]             version = "1.8"), class = "FutureResult")
[16:05:56.953]     }, finally = {
[16:05:56.953]         if (!identical(...future.workdir, getwd())) 
[16:05:56.953]             setwd(...future.workdir)
[16:05:56.953]         {
[16:05:56.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:56.953]                 ...future.oldOptions$nwarnings <- NULL
[16:05:56.953]             }
[16:05:56.953]             base::options(...future.oldOptions)
[16:05:56.953]             if (.Platform$OS.type == "windows") {
[16:05:56.953]                 old_names <- names(...future.oldEnvVars)
[16:05:56.953]                 envs <- base::Sys.getenv()
[16:05:56.953]                 names <- names(envs)
[16:05:56.953]                 common <- intersect(names, old_names)
[16:05:56.953]                 added <- setdiff(names, old_names)
[16:05:56.953]                 removed <- setdiff(old_names, names)
[16:05:56.953]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:56.953]                   envs[common]]
[16:05:56.953]                 NAMES <- toupper(changed)
[16:05:56.953]                 args <- list()
[16:05:56.953]                 for (kk in seq_along(NAMES)) {
[16:05:56.953]                   name <- changed[[kk]]
[16:05:56.953]                   NAME <- NAMES[[kk]]
[16:05:56.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.953]                     next
[16:05:56.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.953]                 }
[16:05:56.953]                 NAMES <- toupper(added)
[16:05:56.953]                 for (kk in seq_along(NAMES)) {
[16:05:56.953]                   name <- added[[kk]]
[16:05:56.953]                   NAME <- NAMES[[kk]]
[16:05:56.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.953]                     next
[16:05:56.953]                   args[[name]] <- ""
[16:05:56.953]                 }
[16:05:56.953]                 NAMES <- toupper(removed)
[16:05:56.953]                 for (kk in seq_along(NAMES)) {
[16:05:56.953]                   name <- removed[[kk]]
[16:05:56.953]                   NAME <- NAMES[[kk]]
[16:05:56.953]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:56.953]                     next
[16:05:56.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:56.953]                 }
[16:05:56.953]                 if (length(args) > 0) 
[16:05:56.953]                   base::do.call(base::Sys.setenv, args = args)
[16:05:56.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:56.953]             }
[16:05:56.953]             else {
[16:05:56.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:56.953]             }
[16:05:56.953]             {
[16:05:56.953]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:56.953]                   0L) {
[16:05:56.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:56.953]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:56.953]                   base::options(opts)
[16:05:56.953]                 }
[16:05:56.953]                 {
[16:05:56.953]                   {
[16:05:56.953]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:56.953]                     NULL
[16:05:56.953]                   }
[16:05:56.953]                   options(future.plan = NULL)
[16:05:56.953]                   if (is.na(NA_character_)) 
[16:05:56.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:56.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:56.953]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:56.953]                     envir = parent.frame()) 
[16:05:56.953]                   {
[16:05:56.953]                     default_workers <- missing(workers)
[16:05:56.953]                     if (is.function(workers)) 
[16:05:56.953]                       workers <- workers()
[16:05:56.953]                     workers <- structure(as.integer(workers), 
[16:05:56.953]                       class = class(workers))
[16:05:56.953]                     stop_if_not(is.finite(workers), workers >= 
[16:05:56.953]                       1L)
[16:05:56.953]                     if ((workers == 1L && !inherits(workers, 
[16:05:56.953]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:56.953]                       if (default_workers) 
[16:05:56.953]                         supportsMulticore(warn = TRUE)
[16:05:56.953]                       return(sequential(..., envir = envir))
[16:05:56.953]                     }
[16:05:56.953]                     oopts <- options(mc.cores = workers)
[16:05:56.953]                     on.exit(options(oopts))
[16:05:56.953]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:56.953]                       envir = envir)
[16:05:56.953]                     if (!future$lazy) 
[16:05:56.953]                       future <- run(future)
[16:05:56.953]                     invisible(future)
[16:05:56.953]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:56.953]                 }
[16:05:56.953]             }
[16:05:56.953]         }
[16:05:56.953]     })
[16:05:56.953]     if (TRUE) {
[16:05:56.953]         base::sink(type = "output", split = FALSE)
[16:05:56.953]         if (TRUE) {
[16:05:56.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:56.953]         }
[16:05:56.953]         else {
[16:05:56.953]             ...future.result["stdout"] <- base::list(NULL)
[16:05:56.953]         }
[16:05:56.953]         base::close(...future.stdout)
[16:05:56.953]         ...future.stdout <- NULL
[16:05:56.953]     }
[16:05:56.953]     ...future.result$conditions <- ...future.conditions
[16:05:56.953]     ...future.result$finished <- base::Sys.time()
[16:05:56.953]     ...future.result
[16:05:56.953] }
[16:05:56.956] requestCore(): workers = 2
[16:05:56.957] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:56.967] result() for MulticoreFuture ...
[16:05:56.968] result() for MulticoreFuture ...
[16:05:56.968] result() for MulticoreFuture ... done
[16:05:56.969] result() for MulticoreFuture ... done
[16:05:56.969] result() for MulticoreFuture ...
[16:05:56.969] result() for MulticoreFuture ... done
[16:05:56.971] MulticoreFuture started
[16:05:56.972] - Launch lazy future ... done
[16:05:56.972] run() for ‘MulticoreFuture’ ... done
[16:05:56.972] plan(): Setting new future strategy stack:
[16:05:56.973] List of future strategies:
[16:05:56.973] 1. sequential:
[16:05:56.973]    - args: function (..., envir = parent.frame())
[16:05:56.973]    - tweaked: FALSE
[16:05:56.973]    - call: NULL
[16:05:56.974] resolve() on environment ...
[16:05:56.974] plan(): nbrOfWorkers() = 1
[16:05:56.974]  recursive: 0
[16:05:56.975]  elements: [3] ‘a’, ‘b’, ‘c’
[16:05:56.976] Future #1
[16:05:56.976]  length: 2 (resolved future 1)
[16:05:56.977] plan(): Setting new future strategy stack:
[16:05:56.977] List of future strategies:
[16:05:56.977] 1. multicore:
[16:05:56.977]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:56.977]    - tweaked: FALSE
[16:05:56.977]    - call: plan(strategy)
[16:05:56.987]  length: 1 (resolved future 3)
[16:05:56.987] plan(): nbrOfWorkers() = 2
[16:05:56.997] Future #2
[16:05:56.998]  length: 0 (resolved future 2)
[16:05:56.998] resolve() on environment ... DONE
[16:05:57.004] getGlobalsAndPackages() ...
[16:05:57.004] Searching for globals...
[16:05:57.006] - globals found: [1] ‘{’
[16:05:57.007] Searching for globals ... DONE
[16:05:57.007] Resolving globals: FALSE
[16:05:57.007] 
[16:05:57.007] 
[16:05:57.008] getGlobalsAndPackages() ... DONE
[16:05:57.008] run() for ‘Future’ ...
[16:05:57.008] - state: ‘created’
[16:05:57.008] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.013] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.013] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.014]   - Field: ‘label’
[16:05:57.014]   - Field: ‘local’
[16:05:57.014]   - Field: ‘owner’
[16:05:57.014]   - Field: ‘envir’
[16:05:57.014]   - Field: ‘workers’
[16:05:57.015]   - Field: ‘packages’
[16:05:57.015]   - Field: ‘gc’
[16:05:57.015]   - Field: ‘job’
[16:05:57.015]   - Field: ‘conditions’
[16:05:57.015]   - Field: ‘expr’
[16:05:57.015]   - Field: ‘uuid’
[16:05:57.015]   - Field: ‘seed’
[16:05:57.016]   - Field: ‘version’
[16:05:57.016]   - Field: ‘result’
[16:05:57.016]   - Field: ‘asynchronous’
[16:05:57.016]   - Field: ‘calls’
[16:05:57.016]   - Field: ‘globals’
[16:05:57.016]   - Field: ‘stdout’
[16:05:57.016]   - Field: ‘earlySignal’
[16:05:57.016]   - Field: ‘lazy’
[16:05:57.017]   - Field: ‘state’
[16:05:57.017] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.017] - Launch lazy future ...
[16:05:57.017] Packages needed by the future expression (n = 0): <none>
[16:05:57.017] Packages needed by future strategies (n = 0): <none>
[16:05:57.018] {
[16:05:57.018]     {
[16:05:57.018]         {
[16:05:57.018]             ...future.startTime <- base::Sys.time()
[16:05:57.018]             {
[16:05:57.018]                 {
[16:05:57.018]                   {
[16:05:57.018]                     {
[16:05:57.018]                       base::local({
[16:05:57.018]                         has_future <- base::requireNamespace("future", 
[16:05:57.018]                           quietly = TRUE)
[16:05:57.018]                         if (has_future) {
[16:05:57.018]                           ns <- base::getNamespace("future")
[16:05:57.018]                           version <- ns[[".package"]][["version"]]
[16:05:57.018]                           if (is.null(version)) 
[16:05:57.018]                             version <- utils::packageVersion("future")
[16:05:57.018]                         }
[16:05:57.018]                         else {
[16:05:57.018]                           version <- NULL
[16:05:57.018]                         }
[16:05:57.018]                         if (!has_future || version < "1.8.0") {
[16:05:57.018]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.018]                             "", base::R.version$version.string), 
[16:05:57.018]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.018]                               "release", "version")], collapse = " "), 
[16:05:57.018]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.018]                             info)
[16:05:57.018]                           info <- base::paste(info, collapse = "; ")
[16:05:57.018]                           if (!has_future) {
[16:05:57.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.018]                               info)
[16:05:57.018]                           }
[16:05:57.018]                           else {
[16:05:57.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.018]                               info, version)
[16:05:57.018]                           }
[16:05:57.018]                           base::stop(msg)
[16:05:57.018]                         }
[16:05:57.018]                       })
[16:05:57.018]                     }
[16:05:57.018]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.018]                     base::options(mc.cores = 1L)
[16:05:57.018]                   }
[16:05:57.018]                   options(future.plan = NULL)
[16:05:57.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.018]                 }
[16:05:57.018]                 ...future.workdir <- getwd()
[16:05:57.018]             }
[16:05:57.018]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.018]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.018]         }
[16:05:57.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.018]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.018]             base::names(...future.oldOptions))
[16:05:57.018]     }
[16:05:57.018]     if (FALSE) {
[16:05:57.018]     }
[16:05:57.018]     else {
[16:05:57.018]         if (TRUE) {
[16:05:57.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.018]                 open = "w")
[16:05:57.018]         }
[16:05:57.018]         else {
[16:05:57.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.018]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.018]         }
[16:05:57.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.018]             base::sink(type = "output", split = FALSE)
[16:05:57.018]             base::close(...future.stdout)
[16:05:57.018]         }, add = TRUE)
[16:05:57.018]     }
[16:05:57.018]     ...future.frame <- base::sys.nframe()
[16:05:57.018]     ...future.conditions <- base::list()
[16:05:57.018]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.018]     if (FALSE) {
[16:05:57.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.018]     }
[16:05:57.018]     ...future.result <- base::tryCatch({
[16:05:57.018]         base::withCallingHandlers({
[16:05:57.018]             ...future.value <- base::withVisible(base::local({
[16:05:57.018]                 withCallingHandlers({
[16:05:57.018]                   {
[16:05:57.018]                     1
[16:05:57.018]                   }
[16:05:57.018]                 }, immediateCondition = function(cond) {
[16:05:57.018]                   save_rds <- function (object, pathname, ...) 
[16:05:57.018]                   {
[16:05:57.018]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.018]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.018]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.018]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.018]                         fi_tmp[["mtime"]])
[16:05:57.018]                     }
[16:05:57.018]                     tryCatch({
[16:05:57.018]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.018]                     }, error = function(ex) {
[16:05:57.018]                       msg <- conditionMessage(ex)
[16:05:57.018]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.018]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.018]                         fi_tmp[["mtime"]], msg)
[16:05:57.018]                       ex$message <- msg
[16:05:57.018]                       stop(ex)
[16:05:57.018]                     })
[16:05:57.018]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.018]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.018]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.018]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.018]                       fi <- file.info(pathname)
[16:05:57.018]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.018]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.018]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.018]                         fi[["size"]], fi[["mtime"]])
[16:05:57.018]                       stop(msg)
[16:05:57.018]                     }
[16:05:57.018]                     invisible(pathname)
[16:05:57.018]                   }
[16:05:57.018]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.018]                     rootPath = tempdir()) 
[16:05:57.018]                   {
[16:05:57.018]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.018]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.018]                       tmpdir = path, fileext = ".rds")
[16:05:57.018]                     save_rds(obj, file)
[16:05:57.018]                   }
[16:05:57.018]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.018]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.018]                   {
[16:05:57.018]                     inherits <- base::inherits
[16:05:57.018]                     invokeRestart <- base::invokeRestart
[16:05:57.018]                     is.null <- base::is.null
[16:05:57.018]                     muffled <- FALSE
[16:05:57.018]                     if (inherits(cond, "message")) {
[16:05:57.018]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.018]                       if (muffled) 
[16:05:57.018]                         invokeRestart("muffleMessage")
[16:05:57.018]                     }
[16:05:57.018]                     else if (inherits(cond, "warning")) {
[16:05:57.018]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.018]                       if (muffled) 
[16:05:57.018]                         invokeRestart("muffleWarning")
[16:05:57.018]                     }
[16:05:57.018]                     else if (inherits(cond, "condition")) {
[16:05:57.018]                       if (!is.null(pattern)) {
[16:05:57.018]                         computeRestarts <- base::computeRestarts
[16:05:57.018]                         grepl <- base::grepl
[16:05:57.018]                         restarts <- computeRestarts(cond)
[16:05:57.018]                         for (restart in restarts) {
[16:05:57.018]                           name <- restart$name
[16:05:57.018]                           if (is.null(name)) 
[16:05:57.018]                             next
[16:05:57.018]                           if (!grepl(pattern, name)) 
[16:05:57.018]                             next
[16:05:57.018]                           invokeRestart(restart)
[16:05:57.018]                           muffled <- TRUE
[16:05:57.018]                           break
[16:05:57.018]                         }
[16:05:57.018]                       }
[16:05:57.018]                     }
[16:05:57.018]                     invisible(muffled)
[16:05:57.018]                   }
[16:05:57.018]                   muffleCondition(cond)
[16:05:57.018]                 })
[16:05:57.018]             }))
[16:05:57.018]             future::FutureResult(value = ...future.value$value, 
[16:05:57.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.018]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.018]                     ...future.globalenv.names))
[16:05:57.018]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.018]         }, condition = base::local({
[16:05:57.018]             c <- base::c
[16:05:57.018]             inherits <- base::inherits
[16:05:57.018]             invokeRestart <- base::invokeRestart
[16:05:57.018]             length <- base::length
[16:05:57.018]             list <- base::list
[16:05:57.018]             seq.int <- base::seq.int
[16:05:57.018]             signalCondition <- base::signalCondition
[16:05:57.018]             sys.calls <- base::sys.calls
[16:05:57.018]             `[[` <- base::`[[`
[16:05:57.018]             `+` <- base::`+`
[16:05:57.018]             `<<-` <- base::`<<-`
[16:05:57.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.018]                   3L)]
[16:05:57.018]             }
[16:05:57.018]             function(cond) {
[16:05:57.018]                 is_error <- inherits(cond, "error")
[16:05:57.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.018]                   NULL)
[16:05:57.018]                 if (is_error) {
[16:05:57.018]                   sessionInformation <- function() {
[16:05:57.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.018]                       search = base::search(), system = base::Sys.info())
[16:05:57.018]                   }
[16:05:57.018]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.018]                     cond$call), session = sessionInformation(), 
[16:05:57.018]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.018]                   signalCondition(cond)
[16:05:57.018]                 }
[16:05:57.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.018]                 "immediateCondition"))) {
[16:05:57.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.018]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.018]                   if (TRUE && !signal) {
[16:05:57.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.018]                     {
[16:05:57.018]                       inherits <- base::inherits
[16:05:57.018]                       invokeRestart <- base::invokeRestart
[16:05:57.018]                       is.null <- base::is.null
[16:05:57.018]                       muffled <- FALSE
[16:05:57.018]                       if (inherits(cond, "message")) {
[16:05:57.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.018]                         if (muffled) 
[16:05:57.018]                           invokeRestart("muffleMessage")
[16:05:57.018]                       }
[16:05:57.018]                       else if (inherits(cond, "warning")) {
[16:05:57.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.018]                         if (muffled) 
[16:05:57.018]                           invokeRestart("muffleWarning")
[16:05:57.018]                       }
[16:05:57.018]                       else if (inherits(cond, "condition")) {
[16:05:57.018]                         if (!is.null(pattern)) {
[16:05:57.018]                           computeRestarts <- base::computeRestarts
[16:05:57.018]                           grepl <- base::grepl
[16:05:57.018]                           restarts <- computeRestarts(cond)
[16:05:57.018]                           for (restart in restarts) {
[16:05:57.018]                             name <- restart$name
[16:05:57.018]                             if (is.null(name)) 
[16:05:57.018]                               next
[16:05:57.018]                             if (!grepl(pattern, name)) 
[16:05:57.018]                               next
[16:05:57.018]                             invokeRestart(restart)
[16:05:57.018]                             muffled <- TRUE
[16:05:57.018]                             break
[16:05:57.018]                           }
[16:05:57.018]                         }
[16:05:57.018]                       }
[16:05:57.018]                       invisible(muffled)
[16:05:57.018]                     }
[16:05:57.018]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.018]                   }
[16:05:57.018]                 }
[16:05:57.018]                 else {
[16:05:57.018]                   if (TRUE) {
[16:05:57.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.018]                     {
[16:05:57.018]                       inherits <- base::inherits
[16:05:57.018]                       invokeRestart <- base::invokeRestart
[16:05:57.018]                       is.null <- base::is.null
[16:05:57.018]                       muffled <- FALSE
[16:05:57.018]                       if (inherits(cond, "message")) {
[16:05:57.018]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.018]                         if (muffled) 
[16:05:57.018]                           invokeRestart("muffleMessage")
[16:05:57.018]                       }
[16:05:57.018]                       else if (inherits(cond, "warning")) {
[16:05:57.018]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.018]                         if (muffled) 
[16:05:57.018]                           invokeRestart("muffleWarning")
[16:05:57.018]                       }
[16:05:57.018]                       else if (inherits(cond, "condition")) {
[16:05:57.018]                         if (!is.null(pattern)) {
[16:05:57.018]                           computeRestarts <- base::computeRestarts
[16:05:57.018]                           grepl <- base::grepl
[16:05:57.018]                           restarts <- computeRestarts(cond)
[16:05:57.018]                           for (restart in restarts) {
[16:05:57.018]                             name <- restart$name
[16:05:57.018]                             if (is.null(name)) 
[16:05:57.018]                               next
[16:05:57.018]                             if (!grepl(pattern, name)) 
[16:05:57.018]                               next
[16:05:57.018]                             invokeRestart(restart)
[16:05:57.018]                             muffled <- TRUE
[16:05:57.018]                             break
[16:05:57.018]                           }
[16:05:57.018]                         }
[16:05:57.018]                       }
[16:05:57.018]                       invisible(muffled)
[16:05:57.018]                     }
[16:05:57.018]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.018]                   }
[16:05:57.018]                 }
[16:05:57.018]             }
[16:05:57.018]         }))
[16:05:57.018]     }, error = function(ex) {
[16:05:57.018]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.018]                 ...future.rng), started = ...future.startTime, 
[16:05:57.018]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.018]             version = "1.8"), class = "FutureResult")
[16:05:57.018]     }, finally = {
[16:05:57.018]         if (!identical(...future.workdir, getwd())) 
[16:05:57.018]             setwd(...future.workdir)
[16:05:57.018]         {
[16:05:57.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.018]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.018]             }
[16:05:57.018]             base::options(...future.oldOptions)
[16:05:57.018]             if (.Platform$OS.type == "windows") {
[16:05:57.018]                 old_names <- names(...future.oldEnvVars)
[16:05:57.018]                 envs <- base::Sys.getenv()
[16:05:57.018]                 names <- names(envs)
[16:05:57.018]                 common <- intersect(names, old_names)
[16:05:57.018]                 added <- setdiff(names, old_names)
[16:05:57.018]                 removed <- setdiff(old_names, names)
[16:05:57.018]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.018]                   envs[common]]
[16:05:57.018]                 NAMES <- toupper(changed)
[16:05:57.018]                 args <- list()
[16:05:57.018]                 for (kk in seq_along(NAMES)) {
[16:05:57.018]                   name <- changed[[kk]]
[16:05:57.018]                   NAME <- NAMES[[kk]]
[16:05:57.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.018]                     next
[16:05:57.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.018]                 }
[16:05:57.018]                 NAMES <- toupper(added)
[16:05:57.018]                 for (kk in seq_along(NAMES)) {
[16:05:57.018]                   name <- added[[kk]]
[16:05:57.018]                   NAME <- NAMES[[kk]]
[16:05:57.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.018]                     next
[16:05:57.018]                   args[[name]] <- ""
[16:05:57.018]                 }
[16:05:57.018]                 NAMES <- toupper(removed)
[16:05:57.018]                 for (kk in seq_along(NAMES)) {
[16:05:57.018]                   name <- removed[[kk]]
[16:05:57.018]                   NAME <- NAMES[[kk]]
[16:05:57.018]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.018]                     next
[16:05:57.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.018]                 }
[16:05:57.018]                 if (length(args) > 0) 
[16:05:57.018]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.018]             }
[16:05:57.018]             else {
[16:05:57.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.018]             }
[16:05:57.018]             {
[16:05:57.018]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.018]                   0L) {
[16:05:57.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.018]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.018]                   base::options(opts)
[16:05:57.018]                 }
[16:05:57.018]                 {
[16:05:57.018]                   {
[16:05:57.018]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.018]                     NULL
[16:05:57.018]                   }
[16:05:57.018]                   options(future.plan = NULL)
[16:05:57.018]                   if (is.na(NA_character_)) 
[16:05:57.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.018]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.018]                     envir = parent.frame()) 
[16:05:57.018]                   {
[16:05:57.018]                     default_workers <- missing(workers)
[16:05:57.018]                     if (is.function(workers)) 
[16:05:57.018]                       workers <- workers()
[16:05:57.018]                     workers <- structure(as.integer(workers), 
[16:05:57.018]                       class = class(workers))
[16:05:57.018]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.018]                       1L)
[16:05:57.018]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.018]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.018]                       if (default_workers) 
[16:05:57.018]                         supportsMulticore(warn = TRUE)
[16:05:57.018]                       return(sequential(..., envir = envir))
[16:05:57.018]                     }
[16:05:57.018]                     oopts <- options(mc.cores = workers)
[16:05:57.018]                     on.exit(options(oopts))
[16:05:57.018]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.018]                       envir = envir)
[16:05:57.018]                     if (!future$lazy) 
[16:05:57.018]                       future <- run(future)
[16:05:57.018]                     invisible(future)
[16:05:57.018]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.018]                 }
[16:05:57.018]             }
[16:05:57.018]         }
[16:05:57.018]     })
[16:05:57.018]     if (TRUE) {
[16:05:57.018]         base::sink(type = "output", split = FALSE)
[16:05:57.018]         if (TRUE) {
[16:05:57.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.018]         }
[16:05:57.018]         else {
[16:05:57.018]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.018]         }
[16:05:57.018]         base::close(...future.stdout)
[16:05:57.018]         ...future.stdout <- NULL
[16:05:57.018]     }
[16:05:57.018]     ...future.result$conditions <- ...future.conditions
[16:05:57.018]     ...future.result$finished <- base::Sys.time()
[16:05:57.018]     ...future.result
[16:05:57.018] }
[16:05:57.021] requestCore(): workers = 2
[16:05:57.021] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.032] result() for MulticoreFuture ...
[16:05:57.033] result() for MulticoreFuture ...
[16:05:57.033] result() for MulticoreFuture ... done
[16:05:57.033] result() for MulticoreFuture ... done
[16:05:57.033] result() for MulticoreFuture ...
[16:05:57.033] result() for MulticoreFuture ... done
[16:05:57.035] MulticoreFuture started
[16:05:57.036] - Launch lazy future ... done
[16:05:57.036] run() for ‘MulticoreFuture’ ... done
[16:05:57.037] plan(): Setting new future strategy stack:
[16:05:57.037] getGlobalsAndPackages() ...
[16:05:57.038] Searching for globals...
[16:05:57.037] List of future strategies:
[16:05:57.037] 1. sequential:
[16:05:57.037]    - args: function (..., envir = parent.frame())
[16:05:57.037]    - tweaked: FALSE
[16:05:57.037]    - call: NULL
[16:05:57.038] plan(): nbrOfWorkers() = 1
[16:05:57.040] - globals found: [1] ‘{’
[16:05:57.040] Searching for globals ... DONE
[16:05:57.040] Resolving globals: FALSE
[16:05:57.041] 
[16:05:57.041] plan(): Setting new future strategy stack:
[16:05:57.041] 
[16:05:57.041] getGlobalsAndPackages() ... DONE
[16:05:57.041] List of future strategies:
[16:05:57.041] 1. multicore:
[16:05:57.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.041]    - tweaked: FALSE
[16:05:57.041]    - call: plan(strategy)
[16:05:57.042] run() for ‘Future’ ...
[16:05:57.042] - state: ‘created’
[16:05:57.043] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.047] plan(): nbrOfWorkers() = 2
[16:05:57.048] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.048] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.048]   - Field: ‘label’
[16:05:57.048]   - Field: ‘local’
[16:05:57.048]   - Field: ‘owner’
[16:05:57.049]   - Field: ‘envir’
[16:05:57.049]   - Field: ‘workers’
[16:05:57.049]   - Field: ‘packages’
[16:05:57.049]   - Field: ‘gc’
[16:05:57.049]   - Field: ‘job’
[16:05:57.049]   - Field: ‘conditions’
[16:05:57.049]   - Field: ‘expr’
[16:05:57.050]   - Field: ‘uuid’
[16:05:57.050]   - Field: ‘seed’
[16:05:57.050]   - Field: ‘version’
[16:05:57.050]   - Field: ‘result’
[16:05:57.050]   - Field: ‘asynchronous’
[16:05:57.050]   - Field: ‘calls’
[16:05:57.050]   - Field: ‘globals’
[16:05:57.051]   - Field: ‘stdout’
[16:05:57.051]   - Field: ‘earlySignal’
[16:05:57.051]   - Field: ‘lazy’
[16:05:57.051]   - Field: ‘state’
[16:05:57.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.051] - Launch lazy future ...
[16:05:57.052] Packages needed by the future expression (n = 0): <none>
[16:05:57.052] Packages needed by future strategies (n = 0): <none>
[16:05:57.053] {
[16:05:57.053]     {
[16:05:57.053]         {
[16:05:57.053]             ...future.startTime <- base::Sys.time()
[16:05:57.053]             {
[16:05:57.053]                 {
[16:05:57.053]                   {
[16:05:57.053]                     {
[16:05:57.053]                       base::local({
[16:05:57.053]                         has_future <- base::requireNamespace("future", 
[16:05:57.053]                           quietly = TRUE)
[16:05:57.053]                         if (has_future) {
[16:05:57.053]                           ns <- base::getNamespace("future")
[16:05:57.053]                           version <- ns[[".package"]][["version"]]
[16:05:57.053]                           if (is.null(version)) 
[16:05:57.053]                             version <- utils::packageVersion("future")
[16:05:57.053]                         }
[16:05:57.053]                         else {
[16:05:57.053]                           version <- NULL
[16:05:57.053]                         }
[16:05:57.053]                         if (!has_future || version < "1.8.0") {
[16:05:57.053]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.053]                             "", base::R.version$version.string), 
[16:05:57.053]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.053]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.053]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.053]                               "release", "version")], collapse = " "), 
[16:05:57.053]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.053]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.053]                             info)
[16:05:57.053]                           info <- base::paste(info, collapse = "; ")
[16:05:57.053]                           if (!has_future) {
[16:05:57.053]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.053]                               info)
[16:05:57.053]                           }
[16:05:57.053]                           else {
[16:05:57.053]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.053]                               info, version)
[16:05:57.053]                           }
[16:05:57.053]                           base::stop(msg)
[16:05:57.053]                         }
[16:05:57.053]                       })
[16:05:57.053]                     }
[16:05:57.053]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.053]                     base::options(mc.cores = 1L)
[16:05:57.053]                   }
[16:05:57.053]                   options(future.plan = NULL)
[16:05:57.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.053]                 }
[16:05:57.053]                 ...future.workdir <- getwd()
[16:05:57.053]             }
[16:05:57.053]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.053]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.053]         }
[16:05:57.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.053]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.053]             base::names(...future.oldOptions))
[16:05:57.053]     }
[16:05:57.053]     if (FALSE) {
[16:05:57.053]     }
[16:05:57.053]     else {
[16:05:57.053]         if (TRUE) {
[16:05:57.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.053]                 open = "w")
[16:05:57.053]         }
[16:05:57.053]         else {
[16:05:57.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.053]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.053]         }
[16:05:57.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.053]             base::sink(type = "output", split = FALSE)
[16:05:57.053]             base::close(...future.stdout)
[16:05:57.053]         }, add = TRUE)
[16:05:57.053]     }
[16:05:57.053]     ...future.frame <- base::sys.nframe()
[16:05:57.053]     ...future.conditions <- base::list()
[16:05:57.053]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.053]     if (FALSE) {
[16:05:57.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.053]     }
[16:05:57.053]     ...future.result <- base::tryCatch({
[16:05:57.053]         base::withCallingHandlers({
[16:05:57.053]             ...future.value <- base::withVisible(base::local({
[16:05:57.053]                 withCallingHandlers({
[16:05:57.053]                   {
[16:05:57.053]                     2
[16:05:57.053]                   }
[16:05:57.053]                 }, immediateCondition = function(cond) {
[16:05:57.053]                   save_rds <- function (object, pathname, ...) 
[16:05:57.053]                   {
[16:05:57.053]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.053]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.053]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.053]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.053]                         fi_tmp[["mtime"]])
[16:05:57.053]                     }
[16:05:57.053]                     tryCatch({
[16:05:57.053]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.053]                     }, error = function(ex) {
[16:05:57.053]                       msg <- conditionMessage(ex)
[16:05:57.053]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.053]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.053]                         fi_tmp[["mtime"]], msg)
[16:05:57.053]                       ex$message <- msg
[16:05:57.053]                       stop(ex)
[16:05:57.053]                     })
[16:05:57.053]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.053]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.053]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.053]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.053]                       fi <- file.info(pathname)
[16:05:57.053]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.053]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.053]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.053]                         fi[["size"]], fi[["mtime"]])
[16:05:57.053]                       stop(msg)
[16:05:57.053]                     }
[16:05:57.053]                     invisible(pathname)
[16:05:57.053]                   }
[16:05:57.053]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.053]                     rootPath = tempdir()) 
[16:05:57.053]                   {
[16:05:57.053]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.053]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.053]                       tmpdir = path, fileext = ".rds")
[16:05:57.053]                     save_rds(obj, file)
[16:05:57.053]                   }
[16:05:57.053]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.053]                   {
[16:05:57.053]                     inherits <- base::inherits
[16:05:57.053]                     invokeRestart <- base::invokeRestart
[16:05:57.053]                     is.null <- base::is.null
[16:05:57.053]                     muffled <- FALSE
[16:05:57.053]                     if (inherits(cond, "message")) {
[16:05:57.053]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.053]                       if (muffled) 
[16:05:57.053]                         invokeRestart("muffleMessage")
[16:05:57.053]                     }
[16:05:57.053]                     else if (inherits(cond, "warning")) {
[16:05:57.053]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.053]                       if (muffled) 
[16:05:57.053]                         invokeRestart("muffleWarning")
[16:05:57.053]                     }
[16:05:57.053]                     else if (inherits(cond, "condition")) {
[16:05:57.053]                       if (!is.null(pattern)) {
[16:05:57.053]                         computeRestarts <- base::computeRestarts
[16:05:57.053]                         grepl <- base::grepl
[16:05:57.053]                         restarts <- computeRestarts(cond)
[16:05:57.053]                         for (restart in restarts) {
[16:05:57.053]                           name <- restart$name
[16:05:57.053]                           if (is.null(name)) 
[16:05:57.053]                             next
[16:05:57.053]                           if (!grepl(pattern, name)) 
[16:05:57.053]                             next
[16:05:57.053]                           invokeRestart(restart)
[16:05:57.053]                           muffled <- TRUE
[16:05:57.053]                           break
[16:05:57.053]                         }
[16:05:57.053]                       }
[16:05:57.053]                     }
[16:05:57.053]                     invisible(muffled)
[16:05:57.053]                   }
[16:05:57.053]                   muffleCondition(cond)
[16:05:57.053]                 })
[16:05:57.053]             }))
[16:05:57.053]             future::FutureResult(value = ...future.value$value, 
[16:05:57.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.053]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.053]                     ...future.globalenv.names))
[16:05:57.053]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.053]         }, condition = base::local({
[16:05:57.053]             c <- base::c
[16:05:57.053]             inherits <- base::inherits
[16:05:57.053]             invokeRestart <- base::invokeRestart
[16:05:57.053]             length <- base::length
[16:05:57.053]             list <- base::list
[16:05:57.053]             seq.int <- base::seq.int
[16:05:57.053]             signalCondition <- base::signalCondition
[16:05:57.053]             sys.calls <- base::sys.calls
[16:05:57.053]             `[[` <- base::`[[`
[16:05:57.053]             `+` <- base::`+`
[16:05:57.053]             `<<-` <- base::`<<-`
[16:05:57.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.053]                   3L)]
[16:05:57.053]             }
[16:05:57.053]             function(cond) {
[16:05:57.053]                 is_error <- inherits(cond, "error")
[16:05:57.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.053]                   NULL)
[16:05:57.053]                 if (is_error) {
[16:05:57.053]                   sessionInformation <- function() {
[16:05:57.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.053]                       search = base::search(), system = base::Sys.info())
[16:05:57.053]                   }
[16:05:57.053]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.053]                     cond$call), session = sessionInformation(), 
[16:05:57.053]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.053]                   signalCondition(cond)
[16:05:57.053]                 }
[16:05:57.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.053]                 "immediateCondition"))) {
[16:05:57.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.053]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.053]                   if (TRUE && !signal) {
[16:05:57.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.053]                     {
[16:05:57.053]                       inherits <- base::inherits
[16:05:57.053]                       invokeRestart <- base::invokeRestart
[16:05:57.053]                       is.null <- base::is.null
[16:05:57.053]                       muffled <- FALSE
[16:05:57.053]                       if (inherits(cond, "message")) {
[16:05:57.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.053]                         if (muffled) 
[16:05:57.053]                           invokeRestart("muffleMessage")
[16:05:57.053]                       }
[16:05:57.053]                       else if (inherits(cond, "warning")) {
[16:05:57.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.053]                         if (muffled) 
[16:05:57.053]                           invokeRestart("muffleWarning")
[16:05:57.053]                       }
[16:05:57.053]                       else if (inherits(cond, "condition")) {
[16:05:57.053]                         if (!is.null(pattern)) {
[16:05:57.053]                           computeRestarts <- base::computeRestarts
[16:05:57.053]                           grepl <- base::grepl
[16:05:57.053]                           restarts <- computeRestarts(cond)
[16:05:57.053]                           for (restart in restarts) {
[16:05:57.053]                             name <- restart$name
[16:05:57.053]                             if (is.null(name)) 
[16:05:57.053]                               next
[16:05:57.053]                             if (!grepl(pattern, name)) 
[16:05:57.053]                               next
[16:05:57.053]                             invokeRestart(restart)
[16:05:57.053]                             muffled <- TRUE
[16:05:57.053]                             break
[16:05:57.053]                           }
[16:05:57.053]                         }
[16:05:57.053]                       }
[16:05:57.053]                       invisible(muffled)
[16:05:57.053]                     }
[16:05:57.053]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.053]                   }
[16:05:57.053]                 }
[16:05:57.053]                 else {
[16:05:57.053]                   if (TRUE) {
[16:05:57.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.053]                     {
[16:05:57.053]                       inherits <- base::inherits
[16:05:57.053]                       invokeRestart <- base::invokeRestart
[16:05:57.053]                       is.null <- base::is.null
[16:05:57.053]                       muffled <- FALSE
[16:05:57.053]                       if (inherits(cond, "message")) {
[16:05:57.053]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.053]                         if (muffled) 
[16:05:57.053]                           invokeRestart("muffleMessage")
[16:05:57.053]                       }
[16:05:57.053]                       else if (inherits(cond, "warning")) {
[16:05:57.053]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.053]                         if (muffled) 
[16:05:57.053]                           invokeRestart("muffleWarning")
[16:05:57.053]                       }
[16:05:57.053]                       else if (inherits(cond, "condition")) {
[16:05:57.053]                         if (!is.null(pattern)) {
[16:05:57.053]                           computeRestarts <- base::computeRestarts
[16:05:57.053]                           grepl <- base::grepl
[16:05:57.053]                           restarts <- computeRestarts(cond)
[16:05:57.053]                           for (restart in restarts) {
[16:05:57.053]                             name <- restart$name
[16:05:57.053]                             if (is.null(name)) 
[16:05:57.053]                               next
[16:05:57.053]                             if (!grepl(pattern, name)) 
[16:05:57.053]                               next
[16:05:57.053]                             invokeRestart(restart)
[16:05:57.053]                             muffled <- TRUE
[16:05:57.053]                             break
[16:05:57.053]                           }
[16:05:57.053]                         }
[16:05:57.053]                       }
[16:05:57.053]                       invisible(muffled)
[16:05:57.053]                     }
[16:05:57.053]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.053]                   }
[16:05:57.053]                 }
[16:05:57.053]             }
[16:05:57.053]         }))
[16:05:57.053]     }, error = function(ex) {
[16:05:57.053]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.053]                 ...future.rng), started = ...future.startTime, 
[16:05:57.053]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.053]             version = "1.8"), class = "FutureResult")
[16:05:57.053]     }, finally = {
[16:05:57.053]         if (!identical(...future.workdir, getwd())) 
[16:05:57.053]             setwd(...future.workdir)
[16:05:57.053]         {
[16:05:57.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.053]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.053]             }
[16:05:57.053]             base::options(...future.oldOptions)
[16:05:57.053]             if (.Platform$OS.type == "windows") {
[16:05:57.053]                 old_names <- names(...future.oldEnvVars)
[16:05:57.053]                 envs <- base::Sys.getenv()
[16:05:57.053]                 names <- names(envs)
[16:05:57.053]                 common <- intersect(names, old_names)
[16:05:57.053]                 added <- setdiff(names, old_names)
[16:05:57.053]                 removed <- setdiff(old_names, names)
[16:05:57.053]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.053]                   envs[common]]
[16:05:57.053]                 NAMES <- toupper(changed)
[16:05:57.053]                 args <- list()
[16:05:57.053]                 for (kk in seq_along(NAMES)) {
[16:05:57.053]                   name <- changed[[kk]]
[16:05:57.053]                   NAME <- NAMES[[kk]]
[16:05:57.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.053]                     next
[16:05:57.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.053]                 }
[16:05:57.053]                 NAMES <- toupper(added)
[16:05:57.053]                 for (kk in seq_along(NAMES)) {
[16:05:57.053]                   name <- added[[kk]]
[16:05:57.053]                   NAME <- NAMES[[kk]]
[16:05:57.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.053]                     next
[16:05:57.053]                   args[[name]] <- ""
[16:05:57.053]                 }
[16:05:57.053]                 NAMES <- toupper(removed)
[16:05:57.053]                 for (kk in seq_along(NAMES)) {
[16:05:57.053]                   name <- removed[[kk]]
[16:05:57.053]                   NAME <- NAMES[[kk]]
[16:05:57.053]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.053]                     next
[16:05:57.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.053]                 }
[16:05:57.053]                 if (length(args) > 0) 
[16:05:57.053]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.053]             }
[16:05:57.053]             else {
[16:05:57.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.053]             }
[16:05:57.053]             {
[16:05:57.053]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.053]                   0L) {
[16:05:57.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.053]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.053]                   base::options(opts)
[16:05:57.053]                 }
[16:05:57.053]                 {
[16:05:57.053]                   {
[16:05:57.053]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.053]                     NULL
[16:05:57.053]                   }
[16:05:57.053]                   options(future.plan = NULL)
[16:05:57.053]                   if (is.na(NA_character_)) 
[16:05:57.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.053]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.053]                     envir = parent.frame()) 
[16:05:57.053]                   {
[16:05:57.053]                     default_workers <- missing(workers)
[16:05:57.053]                     if (is.function(workers)) 
[16:05:57.053]                       workers <- workers()
[16:05:57.053]                     workers <- structure(as.integer(workers), 
[16:05:57.053]                       class = class(workers))
[16:05:57.053]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.053]                       1L)
[16:05:57.053]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.053]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.053]                       if (default_workers) 
[16:05:57.053]                         supportsMulticore(warn = TRUE)
[16:05:57.053]                       return(sequential(..., envir = envir))
[16:05:57.053]                     }
[16:05:57.053]                     oopts <- options(mc.cores = workers)
[16:05:57.053]                     on.exit(options(oopts))
[16:05:57.053]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.053]                       envir = envir)
[16:05:57.053]                     if (!future$lazy) 
[16:05:57.053]                       future <- run(future)
[16:05:57.053]                     invisible(future)
[16:05:57.053]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.053]                 }
[16:05:57.053]             }
[16:05:57.053]         }
[16:05:57.053]     })
[16:05:57.053]     if (TRUE) {
[16:05:57.053]         base::sink(type = "output", split = FALSE)
[16:05:57.053]         if (TRUE) {
[16:05:57.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.053]         }
[16:05:57.053]         else {
[16:05:57.053]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.053]         }
[16:05:57.053]         base::close(...future.stdout)
[16:05:57.053]         ...future.stdout <- NULL
[16:05:57.053]     }
[16:05:57.053]     ...future.result$conditions <- ...future.conditions
[16:05:57.053]     ...future.result$finished <- base::Sys.time()
[16:05:57.053]     ...future.result
[16:05:57.053] }
[16:05:57.056] requestCore(): workers = 2
[16:05:57.057] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.067] result() for MulticoreFuture ...
[16:05:57.068] result() for MulticoreFuture ...
[16:05:57.069] result() for MulticoreFuture ... done
[16:05:57.069] result() for MulticoreFuture ... done
[16:05:57.069] result() for MulticoreFuture ...
[16:05:57.069] result() for MulticoreFuture ... done
[16:05:57.072] MulticoreFuture started
[16:05:57.072] - Launch lazy future ... done
[16:05:57.072] run() for ‘MulticoreFuture’ ... done
[16:05:57.073] plan(): Setting new future strategy stack:
[16:05:57.073] List of future strategies:
[16:05:57.073] 1. sequential:
[16:05:57.073]    - args: function (..., envir = parent.frame())
[16:05:57.073]    - tweaked: FALSE
[16:05:57.073]    - call: NULL
[16:05:57.074] resolve() on environment ...
[16:05:57.074] plan(): nbrOfWorkers() = 1
[16:05:57.074]  recursive: 0
[16:05:57.075]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:05:57.075] Future #1
[16:05:57.076]  length: 2 (resolved future 1)
[16:05:57.076] plan(): Setting new future strategy stack:
[16:05:57.076] List of future strategies:
[16:05:57.076] 1. multicore:
[16:05:57.076]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.076]    - tweaked: FALSE
[16:05:57.076]    - call: plan(strategy)
[16:05:57.081] plan(): nbrOfWorkers() = 2
[16:05:57.081] Future #2
[16:05:57.082]  length: 1 (resolved future 2)
[16:05:57.082]  length: 0 (resolved future 3)
[16:05:57.082] resolve() on environment ... DONE
[16:05:57.083] getGlobalsAndPackages() ...
[16:05:57.083] Searching for globals...
[16:05:57.084] - globals found: [1] ‘{’
[16:05:57.084] Searching for globals ... DONE
[16:05:57.084] Resolving globals: FALSE
[16:05:57.085] 
[16:05:57.085] 
[16:05:57.085] getGlobalsAndPackages() ... DONE
[16:05:57.086] run() for ‘Future’ ...
[16:05:57.086] - state: ‘created’
[16:05:57.086] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.096] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.096] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.097]   - Field: ‘label’
[16:05:57.097]   - Field: ‘local’
[16:05:57.097]   - Field: ‘owner’
[16:05:57.098]   - Field: ‘envir’
[16:05:57.098]   - Field: ‘workers’
[16:05:57.098]   - Field: ‘packages’
[16:05:57.098]   - Field: ‘gc’
[16:05:57.098]   - Field: ‘job’
[16:05:57.099]   - Field: ‘conditions’
[16:05:57.099]   - Field: ‘expr’
[16:05:57.099]   - Field: ‘uuid’
[16:05:57.099]   - Field: ‘seed’
[16:05:57.099]   - Field: ‘version’
[16:05:57.100]   - Field: ‘result’
[16:05:57.100]   - Field: ‘asynchronous’
[16:05:57.100]   - Field: ‘calls’
[16:05:57.100]   - Field: ‘globals’
[16:05:57.100]   - Field: ‘stdout’
[16:05:57.100]   - Field: ‘earlySignal’
[16:05:57.101]   - Field: ‘lazy’
[16:05:57.101]   - Field: ‘state’
[16:05:57.101] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.101] - Launch lazy future ...
[16:05:57.101] Packages needed by the future expression (n = 0): <none>
[16:05:57.102] Packages needed by future strategies (n = 0): <none>
[16:05:57.102] {
[16:05:57.102]     {
[16:05:57.102]         {
[16:05:57.102]             ...future.startTime <- base::Sys.time()
[16:05:57.102]             {
[16:05:57.102]                 {
[16:05:57.102]                   {
[16:05:57.102]                     {
[16:05:57.102]                       base::local({
[16:05:57.102]                         has_future <- base::requireNamespace("future", 
[16:05:57.102]                           quietly = TRUE)
[16:05:57.102]                         if (has_future) {
[16:05:57.102]                           ns <- base::getNamespace("future")
[16:05:57.102]                           version <- ns[[".package"]][["version"]]
[16:05:57.102]                           if (is.null(version)) 
[16:05:57.102]                             version <- utils::packageVersion("future")
[16:05:57.102]                         }
[16:05:57.102]                         else {
[16:05:57.102]                           version <- NULL
[16:05:57.102]                         }
[16:05:57.102]                         if (!has_future || version < "1.8.0") {
[16:05:57.102]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.102]                             "", base::R.version$version.string), 
[16:05:57.102]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.102]                               "release", "version")], collapse = " "), 
[16:05:57.102]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.102]                             info)
[16:05:57.102]                           info <- base::paste(info, collapse = "; ")
[16:05:57.102]                           if (!has_future) {
[16:05:57.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.102]                               info)
[16:05:57.102]                           }
[16:05:57.102]                           else {
[16:05:57.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.102]                               info, version)
[16:05:57.102]                           }
[16:05:57.102]                           base::stop(msg)
[16:05:57.102]                         }
[16:05:57.102]                       })
[16:05:57.102]                     }
[16:05:57.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.102]                     base::options(mc.cores = 1L)
[16:05:57.102]                   }
[16:05:57.102]                   options(future.plan = NULL)
[16:05:57.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.102]                 }
[16:05:57.102]                 ...future.workdir <- getwd()
[16:05:57.102]             }
[16:05:57.102]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.102]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.102]         }
[16:05:57.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.102]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.102]             base::names(...future.oldOptions))
[16:05:57.102]     }
[16:05:57.102]     if (FALSE) {
[16:05:57.102]     }
[16:05:57.102]     else {
[16:05:57.102]         if (TRUE) {
[16:05:57.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.102]                 open = "w")
[16:05:57.102]         }
[16:05:57.102]         else {
[16:05:57.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.102]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.102]         }
[16:05:57.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.102]             base::sink(type = "output", split = FALSE)
[16:05:57.102]             base::close(...future.stdout)
[16:05:57.102]         }, add = TRUE)
[16:05:57.102]     }
[16:05:57.102]     ...future.frame <- base::sys.nframe()
[16:05:57.102]     ...future.conditions <- base::list()
[16:05:57.102]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.102]     if (FALSE) {
[16:05:57.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.102]     }
[16:05:57.102]     ...future.result <- base::tryCatch({
[16:05:57.102]         base::withCallingHandlers({
[16:05:57.102]             ...future.value <- base::withVisible(base::local({
[16:05:57.102]                 withCallingHandlers({
[16:05:57.102]                   {
[16:05:57.102]                     1
[16:05:57.102]                   }
[16:05:57.102]                 }, immediateCondition = function(cond) {
[16:05:57.102]                   save_rds <- function (object, pathname, ...) 
[16:05:57.102]                   {
[16:05:57.102]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.102]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.102]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.102]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.102]                         fi_tmp[["mtime"]])
[16:05:57.102]                     }
[16:05:57.102]                     tryCatch({
[16:05:57.102]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.102]                     }, error = function(ex) {
[16:05:57.102]                       msg <- conditionMessage(ex)
[16:05:57.102]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.102]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.102]                         fi_tmp[["mtime"]], msg)
[16:05:57.102]                       ex$message <- msg
[16:05:57.102]                       stop(ex)
[16:05:57.102]                     })
[16:05:57.102]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.102]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.102]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.102]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.102]                       fi <- file.info(pathname)
[16:05:57.102]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.102]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.102]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.102]                         fi[["size"]], fi[["mtime"]])
[16:05:57.102]                       stop(msg)
[16:05:57.102]                     }
[16:05:57.102]                     invisible(pathname)
[16:05:57.102]                   }
[16:05:57.102]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.102]                     rootPath = tempdir()) 
[16:05:57.102]                   {
[16:05:57.102]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.102]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.102]                       tmpdir = path, fileext = ".rds")
[16:05:57.102]                     save_rds(obj, file)
[16:05:57.102]                   }
[16:05:57.102]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.102]                   {
[16:05:57.102]                     inherits <- base::inherits
[16:05:57.102]                     invokeRestart <- base::invokeRestart
[16:05:57.102]                     is.null <- base::is.null
[16:05:57.102]                     muffled <- FALSE
[16:05:57.102]                     if (inherits(cond, "message")) {
[16:05:57.102]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.102]                       if (muffled) 
[16:05:57.102]                         invokeRestart("muffleMessage")
[16:05:57.102]                     }
[16:05:57.102]                     else if (inherits(cond, "warning")) {
[16:05:57.102]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.102]                       if (muffled) 
[16:05:57.102]                         invokeRestart("muffleWarning")
[16:05:57.102]                     }
[16:05:57.102]                     else if (inherits(cond, "condition")) {
[16:05:57.102]                       if (!is.null(pattern)) {
[16:05:57.102]                         computeRestarts <- base::computeRestarts
[16:05:57.102]                         grepl <- base::grepl
[16:05:57.102]                         restarts <- computeRestarts(cond)
[16:05:57.102]                         for (restart in restarts) {
[16:05:57.102]                           name <- restart$name
[16:05:57.102]                           if (is.null(name)) 
[16:05:57.102]                             next
[16:05:57.102]                           if (!grepl(pattern, name)) 
[16:05:57.102]                             next
[16:05:57.102]                           invokeRestart(restart)
[16:05:57.102]                           muffled <- TRUE
[16:05:57.102]                           break
[16:05:57.102]                         }
[16:05:57.102]                       }
[16:05:57.102]                     }
[16:05:57.102]                     invisible(muffled)
[16:05:57.102]                   }
[16:05:57.102]                   muffleCondition(cond)
[16:05:57.102]                 })
[16:05:57.102]             }))
[16:05:57.102]             future::FutureResult(value = ...future.value$value, 
[16:05:57.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.102]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.102]                     ...future.globalenv.names))
[16:05:57.102]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.102]         }, condition = base::local({
[16:05:57.102]             c <- base::c
[16:05:57.102]             inherits <- base::inherits
[16:05:57.102]             invokeRestart <- base::invokeRestart
[16:05:57.102]             length <- base::length
[16:05:57.102]             list <- base::list
[16:05:57.102]             seq.int <- base::seq.int
[16:05:57.102]             signalCondition <- base::signalCondition
[16:05:57.102]             sys.calls <- base::sys.calls
[16:05:57.102]             `[[` <- base::`[[`
[16:05:57.102]             `+` <- base::`+`
[16:05:57.102]             `<<-` <- base::`<<-`
[16:05:57.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.102]                   3L)]
[16:05:57.102]             }
[16:05:57.102]             function(cond) {
[16:05:57.102]                 is_error <- inherits(cond, "error")
[16:05:57.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.102]                   NULL)
[16:05:57.102]                 if (is_error) {
[16:05:57.102]                   sessionInformation <- function() {
[16:05:57.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.102]                       search = base::search(), system = base::Sys.info())
[16:05:57.102]                   }
[16:05:57.102]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.102]                     cond$call), session = sessionInformation(), 
[16:05:57.102]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.102]                   signalCondition(cond)
[16:05:57.102]                 }
[16:05:57.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.102]                 "immediateCondition"))) {
[16:05:57.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.102]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.102]                   if (TRUE && !signal) {
[16:05:57.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.102]                     {
[16:05:57.102]                       inherits <- base::inherits
[16:05:57.102]                       invokeRestart <- base::invokeRestart
[16:05:57.102]                       is.null <- base::is.null
[16:05:57.102]                       muffled <- FALSE
[16:05:57.102]                       if (inherits(cond, "message")) {
[16:05:57.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.102]                         if (muffled) 
[16:05:57.102]                           invokeRestart("muffleMessage")
[16:05:57.102]                       }
[16:05:57.102]                       else if (inherits(cond, "warning")) {
[16:05:57.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.102]                         if (muffled) 
[16:05:57.102]                           invokeRestart("muffleWarning")
[16:05:57.102]                       }
[16:05:57.102]                       else if (inherits(cond, "condition")) {
[16:05:57.102]                         if (!is.null(pattern)) {
[16:05:57.102]                           computeRestarts <- base::computeRestarts
[16:05:57.102]                           grepl <- base::grepl
[16:05:57.102]                           restarts <- computeRestarts(cond)
[16:05:57.102]                           for (restart in restarts) {
[16:05:57.102]                             name <- restart$name
[16:05:57.102]                             if (is.null(name)) 
[16:05:57.102]                               next
[16:05:57.102]                             if (!grepl(pattern, name)) 
[16:05:57.102]                               next
[16:05:57.102]                             invokeRestart(restart)
[16:05:57.102]                             muffled <- TRUE
[16:05:57.102]                             break
[16:05:57.102]                           }
[16:05:57.102]                         }
[16:05:57.102]                       }
[16:05:57.102]                       invisible(muffled)
[16:05:57.102]                     }
[16:05:57.102]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.102]                   }
[16:05:57.102]                 }
[16:05:57.102]                 else {
[16:05:57.102]                   if (TRUE) {
[16:05:57.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.102]                     {
[16:05:57.102]                       inherits <- base::inherits
[16:05:57.102]                       invokeRestart <- base::invokeRestart
[16:05:57.102]                       is.null <- base::is.null
[16:05:57.102]                       muffled <- FALSE
[16:05:57.102]                       if (inherits(cond, "message")) {
[16:05:57.102]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.102]                         if (muffled) 
[16:05:57.102]                           invokeRestart("muffleMessage")
[16:05:57.102]                       }
[16:05:57.102]                       else if (inherits(cond, "warning")) {
[16:05:57.102]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.102]                         if (muffled) 
[16:05:57.102]                           invokeRestart("muffleWarning")
[16:05:57.102]                       }
[16:05:57.102]                       else if (inherits(cond, "condition")) {
[16:05:57.102]                         if (!is.null(pattern)) {
[16:05:57.102]                           computeRestarts <- base::computeRestarts
[16:05:57.102]                           grepl <- base::grepl
[16:05:57.102]                           restarts <- computeRestarts(cond)
[16:05:57.102]                           for (restart in restarts) {
[16:05:57.102]                             name <- restart$name
[16:05:57.102]                             if (is.null(name)) 
[16:05:57.102]                               next
[16:05:57.102]                             if (!grepl(pattern, name)) 
[16:05:57.102]                               next
[16:05:57.102]                             invokeRestart(restart)
[16:05:57.102]                             muffled <- TRUE
[16:05:57.102]                             break
[16:05:57.102]                           }
[16:05:57.102]                         }
[16:05:57.102]                       }
[16:05:57.102]                       invisible(muffled)
[16:05:57.102]                     }
[16:05:57.102]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.102]                   }
[16:05:57.102]                 }
[16:05:57.102]             }
[16:05:57.102]         }))
[16:05:57.102]     }, error = function(ex) {
[16:05:57.102]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.102]                 ...future.rng), started = ...future.startTime, 
[16:05:57.102]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.102]             version = "1.8"), class = "FutureResult")
[16:05:57.102]     }, finally = {
[16:05:57.102]         if (!identical(...future.workdir, getwd())) 
[16:05:57.102]             setwd(...future.workdir)
[16:05:57.102]         {
[16:05:57.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.102]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.102]             }
[16:05:57.102]             base::options(...future.oldOptions)
[16:05:57.102]             if (.Platform$OS.type == "windows") {
[16:05:57.102]                 old_names <- names(...future.oldEnvVars)
[16:05:57.102]                 envs <- base::Sys.getenv()
[16:05:57.102]                 names <- names(envs)
[16:05:57.102]                 common <- intersect(names, old_names)
[16:05:57.102]                 added <- setdiff(names, old_names)
[16:05:57.102]                 removed <- setdiff(old_names, names)
[16:05:57.102]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.102]                   envs[common]]
[16:05:57.102]                 NAMES <- toupper(changed)
[16:05:57.102]                 args <- list()
[16:05:57.102]                 for (kk in seq_along(NAMES)) {
[16:05:57.102]                   name <- changed[[kk]]
[16:05:57.102]                   NAME <- NAMES[[kk]]
[16:05:57.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.102]                     next
[16:05:57.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.102]                 }
[16:05:57.102]                 NAMES <- toupper(added)
[16:05:57.102]                 for (kk in seq_along(NAMES)) {
[16:05:57.102]                   name <- added[[kk]]
[16:05:57.102]                   NAME <- NAMES[[kk]]
[16:05:57.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.102]                     next
[16:05:57.102]                   args[[name]] <- ""
[16:05:57.102]                 }
[16:05:57.102]                 NAMES <- toupper(removed)
[16:05:57.102]                 for (kk in seq_along(NAMES)) {
[16:05:57.102]                   name <- removed[[kk]]
[16:05:57.102]                   NAME <- NAMES[[kk]]
[16:05:57.102]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.102]                     next
[16:05:57.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.102]                 }
[16:05:57.102]                 if (length(args) > 0) 
[16:05:57.102]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.102]             }
[16:05:57.102]             else {
[16:05:57.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.102]             }
[16:05:57.102]             {
[16:05:57.102]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.102]                   0L) {
[16:05:57.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.102]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.102]                   base::options(opts)
[16:05:57.102]                 }
[16:05:57.102]                 {
[16:05:57.102]                   {
[16:05:57.102]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.102]                     NULL
[16:05:57.102]                   }
[16:05:57.102]                   options(future.plan = NULL)
[16:05:57.102]                   if (is.na(NA_character_)) 
[16:05:57.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.102]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.102]                     envir = parent.frame()) 
[16:05:57.102]                   {
[16:05:57.102]                     default_workers <- missing(workers)
[16:05:57.102]                     if (is.function(workers)) 
[16:05:57.102]                       workers <- workers()
[16:05:57.102]                     workers <- structure(as.integer(workers), 
[16:05:57.102]                       class = class(workers))
[16:05:57.102]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.102]                       1L)
[16:05:57.102]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.102]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.102]                       if (default_workers) 
[16:05:57.102]                         supportsMulticore(warn = TRUE)
[16:05:57.102]                       return(sequential(..., envir = envir))
[16:05:57.102]                     }
[16:05:57.102]                     oopts <- options(mc.cores = workers)
[16:05:57.102]                     on.exit(options(oopts))
[16:05:57.102]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.102]                       envir = envir)
[16:05:57.102]                     if (!future$lazy) 
[16:05:57.102]                       future <- run(future)
[16:05:57.102]                     invisible(future)
[16:05:57.102]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.102]                 }
[16:05:57.102]             }
[16:05:57.102]         }
[16:05:57.102]     })
[16:05:57.102]     if (TRUE) {
[16:05:57.102]         base::sink(type = "output", split = FALSE)
[16:05:57.102]         if (TRUE) {
[16:05:57.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.102]         }
[16:05:57.102]         else {
[16:05:57.102]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.102]         }
[16:05:57.102]         base::close(...future.stdout)
[16:05:57.102]         ...future.stdout <- NULL
[16:05:57.102]     }
[16:05:57.102]     ...future.result$conditions <- ...future.conditions
[16:05:57.102]     ...future.result$finished <- base::Sys.time()
[16:05:57.102]     ...future.result
[16:05:57.102] }
[16:05:57.106] requestCore(): workers = 2
[16:05:57.106] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.117] result() for MulticoreFuture ...
[16:05:57.118] result() for MulticoreFuture ...
[16:05:57.118] result() for MulticoreFuture ... done
[16:05:57.118] result() for MulticoreFuture ... done
[16:05:57.119] result() for MulticoreFuture ...
[16:05:57.119] result() for MulticoreFuture ... done
[16:05:57.122] MulticoreFuture started
[16:05:57.122] - Launch lazy future ... done
[16:05:57.123] run() for ‘MulticoreFuture’ ... done
[16:05:57.123] plan(): Setting new future strategy stack:
[16:05:57.124] getGlobalsAndPackages() ...
[16:05:57.124] Searching for globals...
[16:05:57.124] List of future strategies:
[16:05:57.124] 1. sequential:
[16:05:57.124]    - args: function (..., envir = parent.frame())
[16:05:57.124]    - tweaked: FALSE
[16:05:57.124]    - call: NULL
[16:05:57.125] plan(): nbrOfWorkers() = 1
[16:05:57.126] - globals found: [1] ‘{’
[16:05:57.126] Searching for globals ... DONE
[16:05:57.126] Resolving globals: FALSE
[16:05:57.127] 
[16:05:57.127] 
[16:05:57.127] getGlobalsAndPackages() ... DONE
[16:05:57.127] plan(): Setting new future strategy stack:
[16:05:57.128] run() for ‘Future’ ...
[16:05:57.127] List of future strategies:
[16:05:57.127] 1. multicore:
[16:05:57.127]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.127]    - tweaked: FALSE
[16:05:57.127]    - call: plan(strategy)
[16:05:57.128] - state: ‘created’
[16:05:57.128] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.133] plan(): nbrOfWorkers() = 2
[16:05:57.133] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.134] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.134]   - Field: ‘label’
[16:05:57.134]   - Field: ‘local’
[16:05:57.134]   - Field: ‘owner’
[16:05:57.134]   - Field: ‘envir’
[16:05:57.135]   - Field: ‘workers’
[16:05:57.135]   - Field: ‘packages’
[16:05:57.135]   - Field: ‘gc’
[16:05:57.135]   - Field: ‘job’
[16:05:57.135]   - Field: ‘conditions’
[16:05:57.136]   - Field: ‘expr’
[16:05:57.136]   - Field: ‘uuid’
[16:05:57.136]   - Field: ‘seed’
[16:05:57.136]   - Field: ‘version’
[16:05:57.136]   - Field: ‘result’
[16:05:57.136]   - Field: ‘asynchronous’
[16:05:57.137]   - Field: ‘calls’
[16:05:57.137]   - Field: ‘globals’
[16:05:57.137]   - Field: ‘stdout’
[16:05:57.137]   - Field: ‘earlySignal’
[16:05:57.137]   - Field: ‘lazy’
[16:05:57.137]   - Field: ‘state’
[16:05:57.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.138] - Launch lazy future ...
[16:05:57.138] Packages needed by the future expression (n = 0): <none>
[16:05:57.138] Packages needed by future strategies (n = 0): <none>
[16:05:57.139] {
[16:05:57.139]     {
[16:05:57.139]         {
[16:05:57.139]             ...future.startTime <- base::Sys.time()
[16:05:57.139]             {
[16:05:57.139]                 {
[16:05:57.139]                   {
[16:05:57.139]                     {
[16:05:57.139]                       base::local({
[16:05:57.139]                         has_future <- base::requireNamespace("future", 
[16:05:57.139]                           quietly = TRUE)
[16:05:57.139]                         if (has_future) {
[16:05:57.139]                           ns <- base::getNamespace("future")
[16:05:57.139]                           version <- ns[[".package"]][["version"]]
[16:05:57.139]                           if (is.null(version)) 
[16:05:57.139]                             version <- utils::packageVersion("future")
[16:05:57.139]                         }
[16:05:57.139]                         else {
[16:05:57.139]                           version <- NULL
[16:05:57.139]                         }
[16:05:57.139]                         if (!has_future || version < "1.8.0") {
[16:05:57.139]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.139]                             "", base::R.version$version.string), 
[16:05:57.139]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.139]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.139]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.139]                               "release", "version")], collapse = " "), 
[16:05:57.139]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.139]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.139]                             info)
[16:05:57.139]                           info <- base::paste(info, collapse = "; ")
[16:05:57.139]                           if (!has_future) {
[16:05:57.139]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.139]                               info)
[16:05:57.139]                           }
[16:05:57.139]                           else {
[16:05:57.139]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.139]                               info, version)
[16:05:57.139]                           }
[16:05:57.139]                           base::stop(msg)
[16:05:57.139]                         }
[16:05:57.139]                       })
[16:05:57.139]                     }
[16:05:57.139]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.139]                     base::options(mc.cores = 1L)
[16:05:57.139]                   }
[16:05:57.139]                   options(future.plan = NULL)
[16:05:57.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.139]                 }
[16:05:57.139]                 ...future.workdir <- getwd()
[16:05:57.139]             }
[16:05:57.139]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.139]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.139]         }
[16:05:57.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.139]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.139]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.139]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.139]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.139]             base::names(...future.oldOptions))
[16:05:57.139]     }
[16:05:57.139]     if (FALSE) {
[16:05:57.139]     }
[16:05:57.139]     else {
[16:05:57.139]         if (TRUE) {
[16:05:57.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.139]                 open = "w")
[16:05:57.139]         }
[16:05:57.139]         else {
[16:05:57.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.139]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.139]         }
[16:05:57.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.139]             base::sink(type = "output", split = FALSE)
[16:05:57.139]             base::close(...future.stdout)
[16:05:57.139]         }, add = TRUE)
[16:05:57.139]     }
[16:05:57.139]     ...future.frame <- base::sys.nframe()
[16:05:57.139]     ...future.conditions <- base::list()
[16:05:57.139]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.139]     if (FALSE) {
[16:05:57.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.139]     }
[16:05:57.139]     ...future.result <- base::tryCatch({
[16:05:57.139]         base::withCallingHandlers({
[16:05:57.139]             ...future.value <- base::withVisible(base::local({
[16:05:57.139]                 withCallingHandlers({
[16:05:57.139]                   {
[16:05:57.139]                     2
[16:05:57.139]                   }
[16:05:57.139]                 }, immediateCondition = function(cond) {
[16:05:57.139]                   save_rds <- function (object, pathname, ...) 
[16:05:57.139]                   {
[16:05:57.139]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.139]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.139]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.139]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.139]                         fi_tmp[["mtime"]])
[16:05:57.139]                     }
[16:05:57.139]                     tryCatch({
[16:05:57.139]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.139]                     }, error = function(ex) {
[16:05:57.139]                       msg <- conditionMessage(ex)
[16:05:57.139]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.139]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.139]                         fi_tmp[["mtime"]], msg)
[16:05:57.139]                       ex$message <- msg
[16:05:57.139]                       stop(ex)
[16:05:57.139]                     })
[16:05:57.139]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.139]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.139]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.139]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.139]                       fi <- file.info(pathname)
[16:05:57.139]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.139]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.139]                         fi[["size"]], fi[["mtime"]])
[16:05:57.139]                       stop(msg)
[16:05:57.139]                     }
[16:05:57.139]                     invisible(pathname)
[16:05:57.139]                   }
[16:05:57.139]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.139]                     rootPath = tempdir()) 
[16:05:57.139]                   {
[16:05:57.139]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.139]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.139]                       tmpdir = path, fileext = ".rds")
[16:05:57.139]                     save_rds(obj, file)
[16:05:57.139]                   }
[16:05:57.139]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.139]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.139]                   {
[16:05:57.139]                     inherits <- base::inherits
[16:05:57.139]                     invokeRestart <- base::invokeRestart
[16:05:57.139]                     is.null <- base::is.null
[16:05:57.139]                     muffled <- FALSE
[16:05:57.139]                     if (inherits(cond, "message")) {
[16:05:57.139]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.139]                       if (muffled) 
[16:05:57.139]                         invokeRestart("muffleMessage")
[16:05:57.139]                     }
[16:05:57.139]                     else if (inherits(cond, "warning")) {
[16:05:57.139]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.139]                       if (muffled) 
[16:05:57.139]                         invokeRestart("muffleWarning")
[16:05:57.139]                     }
[16:05:57.139]                     else if (inherits(cond, "condition")) {
[16:05:57.139]                       if (!is.null(pattern)) {
[16:05:57.139]                         computeRestarts <- base::computeRestarts
[16:05:57.139]                         grepl <- base::grepl
[16:05:57.139]                         restarts <- computeRestarts(cond)
[16:05:57.139]                         for (restart in restarts) {
[16:05:57.139]                           name <- restart$name
[16:05:57.139]                           if (is.null(name)) 
[16:05:57.139]                             next
[16:05:57.139]                           if (!grepl(pattern, name)) 
[16:05:57.139]                             next
[16:05:57.139]                           invokeRestart(restart)
[16:05:57.139]                           muffled <- TRUE
[16:05:57.139]                           break
[16:05:57.139]                         }
[16:05:57.139]                       }
[16:05:57.139]                     }
[16:05:57.139]                     invisible(muffled)
[16:05:57.139]                   }
[16:05:57.139]                   muffleCondition(cond)
[16:05:57.139]                 })
[16:05:57.139]             }))
[16:05:57.139]             future::FutureResult(value = ...future.value$value, 
[16:05:57.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.139]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.139]                     ...future.globalenv.names))
[16:05:57.139]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.139]         }, condition = base::local({
[16:05:57.139]             c <- base::c
[16:05:57.139]             inherits <- base::inherits
[16:05:57.139]             invokeRestart <- base::invokeRestart
[16:05:57.139]             length <- base::length
[16:05:57.139]             list <- base::list
[16:05:57.139]             seq.int <- base::seq.int
[16:05:57.139]             signalCondition <- base::signalCondition
[16:05:57.139]             sys.calls <- base::sys.calls
[16:05:57.139]             `[[` <- base::`[[`
[16:05:57.139]             `+` <- base::`+`
[16:05:57.139]             `<<-` <- base::`<<-`
[16:05:57.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.139]                   3L)]
[16:05:57.139]             }
[16:05:57.139]             function(cond) {
[16:05:57.139]                 is_error <- inherits(cond, "error")
[16:05:57.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.139]                   NULL)
[16:05:57.139]                 if (is_error) {
[16:05:57.139]                   sessionInformation <- function() {
[16:05:57.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.139]                       search = base::search(), system = base::Sys.info())
[16:05:57.139]                   }
[16:05:57.139]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.139]                     cond$call), session = sessionInformation(), 
[16:05:57.139]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.139]                   signalCondition(cond)
[16:05:57.139]                 }
[16:05:57.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.139]                 "immediateCondition"))) {
[16:05:57.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.139]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.139]                   if (TRUE && !signal) {
[16:05:57.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.139]                     {
[16:05:57.139]                       inherits <- base::inherits
[16:05:57.139]                       invokeRestart <- base::invokeRestart
[16:05:57.139]                       is.null <- base::is.null
[16:05:57.139]                       muffled <- FALSE
[16:05:57.139]                       if (inherits(cond, "message")) {
[16:05:57.139]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.139]                         if (muffled) 
[16:05:57.139]                           invokeRestart("muffleMessage")
[16:05:57.139]                       }
[16:05:57.139]                       else if (inherits(cond, "warning")) {
[16:05:57.139]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.139]                         if (muffled) 
[16:05:57.139]                           invokeRestart("muffleWarning")
[16:05:57.139]                       }
[16:05:57.139]                       else if (inherits(cond, "condition")) {
[16:05:57.139]                         if (!is.null(pattern)) {
[16:05:57.139]                           computeRestarts <- base::computeRestarts
[16:05:57.139]                           grepl <- base::grepl
[16:05:57.139]                           restarts <- computeRestarts(cond)
[16:05:57.139]                           for (restart in restarts) {
[16:05:57.139]                             name <- restart$name
[16:05:57.139]                             if (is.null(name)) 
[16:05:57.139]                               next
[16:05:57.139]                             if (!grepl(pattern, name)) 
[16:05:57.139]                               next
[16:05:57.139]                             invokeRestart(restart)
[16:05:57.139]                             muffled <- TRUE
[16:05:57.139]                             break
[16:05:57.139]                           }
[16:05:57.139]                         }
[16:05:57.139]                       }
[16:05:57.139]                       invisible(muffled)
[16:05:57.139]                     }
[16:05:57.139]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.139]                   }
[16:05:57.139]                 }
[16:05:57.139]                 else {
[16:05:57.139]                   if (TRUE) {
[16:05:57.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.139]                     {
[16:05:57.139]                       inherits <- base::inherits
[16:05:57.139]                       invokeRestart <- base::invokeRestart
[16:05:57.139]                       is.null <- base::is.null
[16:05:57.139]                       muffled <- FALSE
[16:05:57.139]                       if (inherits(cond, "message")) {
[16:05:57.139]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.139]                         if (muffled) 
[16:05:57.139]                           invokeRestart("muffleMessage")
[16:05:57.139]                       }
[16:05:57.139]                       else if (inherits(cond, "warning")) {
[16:05:57.139]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.139]                         if (muffled) 
[16:05:57.139]                           invokeRestart("muffleWarning")
[16:05:57.139]                       }
[16:05:57.139]                       else if (inherits(cond, "condition")) {
[16:05:57.139]                         if (!is.null(pattern)) {
[16:05:57.139]                           computeRestarts <- base::computeRestarts
[16:05:57.139]                           grepl <- base::grepl
[16:05:57.139]                           restarts <- computeRestarts(cond)
[16:05:57.139]                           for (restart in restarts) {
[16:05:57.139]                             name <- restart$name
[16:05:57.139]                             if (is.null(name)) 
[16:05:57.139]                               next
[16:05:57.139]                             if (!grepl(pattern, name)) 
[16:05:57.139]                               next
[16:05:57.139]                             invokeRestart(restart)
[16:05:57.139]                             muffled <- TRUE
[16:05:57.139]                             break
[16:05:57.139]                           }
[16:05:57.139]                         }
[16:05:57.139]                       }
[16:05:57.139]                       invisible(muffled)
[16:05:57.139]                     }
[16:05:57.139]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.139]                   }
[16:05:57.139]                 }
[16:05:57.139]             }
[16:05:57.139]         }))
[16:05:57.139]     }, error = function(ex) {
[16:05:57.139]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.139]                 ...future.rng), started = ...future.startTime, 
[16:05:57.139]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.139]             version = "1.8"), class = "FutureResult")
[16:05:57.139]     }, finally = {
[16:05:57.139]         if (!identical(...future.workdir, getwd())) 
[16:05:57.139]             setwd(...future.workdir)
[16:05:57.139]         {
[16:05:57.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.139]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.139]             }
[16:05:57.139]             base::options(...future.oldOptions)
[16:05:57.139]             if (.Platform$OS.type == "windows") {
[16:05:57.139]                 old_names <- names(...future.oldEnvVars)
[16:05:57.139]                 envs <- base::Sys.getenv()
[16:05:57.139]                 names <- names(envs)
[16:05:57.139]                 common <- intersect(names, old_names)
[16:05:57.139]                 added <- setdiff(names, old_names)
[16:05:57.139]                 removed <- setdiff(old_names, names)
[16:05:57.139]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.139]                   envs[common]]
[16:05:57.139]                 NAMES <- toupper(changed)
[16:05:57.139]                 args <- list()
[16:05:57.139]                 for (kk in seq_along(NAMES)) {
[16:05:57.139]                   name <- changed[[kk]]
[16:05:57.139]                   NAME <- NAMES[[kk]]
[16:05:57.139]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.139]                     next
[16:05:57.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.139]                 }
[16:05:57.139]                 NAMES <- toupper(added)
[16:05:57.139]                 for (kk in seq_along(NAMES)) {
[16:05:57.139]                   name <- added[[kk]]
[16:05:57.139]                   NAME <- NAMES[[kk]]
[16:05:57.139]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.139]                     next
[16:05:57.139]                   args[[name]] <- ""
[16:05:57.139]                 }
[16:05:57.139]                 NAMES <- toupper(removed)
[16:05:57.139]                 for (kk in seq_along(NAMES)) {
[16:05:57.139]                   name <- removed[[kk]]
[16:05:57.139]                   NAME <- NAMES[[kk]]
[16:05:57.139]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.139]                     next
[16:05:57.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.139]                 }
[16:05:57.139]                 if (length(args) > 0) 
[16:05:57.139]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.139]             }
[16:05:57.139]             else {
[16:05:57.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.139]             }
[16:05:57.139]             {
[16:05:57.139]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.139]                   0L) {
[16:05:57.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.139]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.139]                   base::options(opts)
[16:05:57.139]                 }
[16:05:57.139]                 {
[16:05:57.139]                   {
[16:05:57.139]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.139]                     NULL
[16:05:57.139]                   }
[16:05:57.139]                   options(future.plan = NULL)
[16:05:57.139]                   if (is.na(NA_character_)) 
[16:05:57.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.139]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.139]                     envir = parent.frame()) 
[16:05:57.139]                   {
[16:05:57.139]                     default_workers <- missing(workers)
[16:05:57.139]                     if (is.function(workers)) 
[16:05:57.139]                       workers <- workers()
[16:05:57.139]                     workers <- structure(as.integer(workers), 
[16:05:57.139]                       class = class(workers))
[16:05:57.139]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.139]                       1L)
[16:05:57.139]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.139]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.139]                       if (default_workers) 
[16:05:57.139]                         supportsMulticore(warn = TRUE)
[16:05:57.139]                       return(sequential(..., envir = envir))
[16:05:57.139]                     }
[16:05:57.139]                     oopts <- options(mc.cores = workers)
[16:05:57.139]                     on.exit(options(oopts))
[16:05:57.139]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.139]                       envir = envir)
[16:05:57.139]                     if (!future$lazy) 
[16:05:57.139]                       future <- run(future)
[16:05:57.139]                     invisible(future)
[16:05:57.139]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.139]                 }
[16:05:57.139]             }
[16:05:57.139]         }
[16:05:57.139]     })
[16:05:57.139]     if (TRUE) {
[16:05:57.139]         base::sink(type = "output", split = FALSE)
[16:05:57.139]         if (TRUE) {
[16:05:57.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.139]         }
[16:05:57.139]         else {
[16:05:57.139]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.139]         }
[16:05:57.139]         base::close(...future.stdout)
[16:05:57.139]         ...future.stdout <- NULL
[16:05:57.139]     }
[16:05:57.139]     ...future.result$conditions <- ...future.conditions
[16:05:57.139]     ...future.result$finished <- base::Sys.time()
[16:05:57.139]     ...future.result
[16:05:57.139] }
[16:05:57.143] requestCore(): workers = 2
[16:05:57.143] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.154] result() for MulticoreFuture ...
[16:05:57.155] result() for MulticoreFuture ...
[16:05:57.155] result() for MulticoreFuture ... done
[16:05:57.155] result() for MulticoreFuture ... done
[16:05:57.155] result() for MulticoreFuture ...
[16:05:57.156] result() for MulticoreFuture ... done
[16:05:57.158] MulticoreFuture started
[16:05:57.159] - Launch lazy future ... done
[16:05:57.159] run() for ‘MulticoreFuture’ ... done
[16:05:57.159] plan(): Setting new future strategy stack:
[16:05:57.160] List of future strategies:
[16:05:57.160] 1. sequential:
[16:05:57.160]    - args: function (..., envir = parent.frame())
[16:05:57.160]    - tweaked: FALSE
[16:05:57.160]    - call: NULL
[16:05:57.161] plan(): nbrOfWorkers() = 1
[16:05:57.161] resolve() on environment ...
[16:05:57.161]  recursive: 0
[16:05:57.162]  elements: [3] ‘a’
[16:05:57.163] Future #1
[16:05:57.163]  length: 2 (resolved future 1)
[16:05:57.164] plan(): Setting new future strategy stack:
[16:05:57.164] List of future strategies:
[16:05:57.164] 1. multicore:
[16:05:57.164]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.164]    - tweaked: FALSE
[16:05:57.164]    - call: plan(strategy)
[16:05:57.170] plan(): nbrOfWorkers() = 2
[16:05:57.170] Future #2
[16:05:57.170]  length: 1 (resolved future 2)
[16:05:57.170]  length: 0 (resolved future 3)
[16:05:57.171] resolve() on environment ... DONE
[16:05:57.172] resolve() on environment ...
[16:05:57.172]  recursive: 0
[16:05:57.172]  elements: [3] ‘b’
[16:05:57.173] Future #1
[16:05:57.173]  length: 2 (resolved future 1)
[16:05:57.173] Future #2
[16:05:57.173]  length: 1 (resolved future 2)
[16:05:57.174]  length: 0 (resolved future 3)
[16:05:57.174] resolve() on environment ... DONE
[16:05:57.174] resolve() on environment ...
[16:05:57.175]  recursive: 0
[16:05:57.175]  elements: [3] ‘c’
[16:05:57.176] Future #1
[16:05:57.176]  length: 2 (resolved future 1)
[16:05:57.176] Future #2
[16:05:57.176]  length: 1 (resolved future 2)
[16:05:57.176]  length: 0 (resolved future 3)
[16:05:57.177] resolve() on environment ... DONE
[16:05:57.177] resolve() on environment ...
[16:05:57.177]  recursive: 0
[16:05:57.178]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:05:57.178] Future #1
[16:05:57.179] result() for MulticoreFuture ...
[16:05:57.180] result() for MulticoreFuture ...
[16:05:57.184] result() for MulticoreFuture ... done
[16:05:57.184] result() for MulticoreFuture ... done
[16:05:57.185] result() for MulticoreFuture ...
[16:05:57.185] result() for MulticoreFuture ... done
[16:05:57.185]  length: 2 (resolved future 1)
[16:05:57.186] Future #2
[16:05:57.186] result() for MulticoreFuture ...
[16:05:57.187] result() for MulticoreFuture ...
[16:05:57.188] result() for MulticoreFuture ... done
[16:05:57.188] result() for MulticoreFuture ... done
[16:05:57.189] result() for MulticoreFuture ...
[16:05:57.189] result() for MulticoreFuture ... done
[16:05:57.189]  length: 1 (resolved future 2)
[16:05:57.189]  length: 0 (resolved future 3)
[16:05:57.189] resolve() on environment ... DONE
[16:05:57.190] resolve() on environment ...
[16:05:57.190]  recursive: 99
[16:05:57.191]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:05:57.191] Future #1
[16:05:57.191] result() for MulticoreFuture ...
[16:05:57.192] result() for MulticoreFuture ... done
[16:05:57.192] result() for MulticoreFuture ...
[16:05:57.192] result() for MulticoreFuture ... done
[16:05:57.192] A MulticoreFuture was resolved
[16:05:57.192]  length: 2 (resolved future 1)
[16:05:57.192] Future #2
[16:05:57.192] result() for MulticoreFuture ...
[16:05:57.193] result() for MulticoreFuture ... done
[16:05:57.193] result() for MulticoreFuture ...
[16:05:57.193] result() for MulticoreFuture ... done
[16:05:57.193] A MulticoreFuture was resolved
[16:05:57.193]  length: 1 (resolved future 2)
[16:05:57.193]  length: 0 (resolved future 3)
[16:05:57.193] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:05:57.194] resolve() on list environment ...
[16:05:57.194]  recursive: 0
[16:05:57.195]  length: 2
[16:05:57.195]  elements: ‘a’, ‘b’
[16:05:57.195]  length: 1 (resolved future 1)
[16:05:57.196]  length: 0 (resolved future 2)
[16:05:57.196] resolve() on list environment ... DONE
[16:05:57.196] getGlobalsAndPackages() ...
[16:05:57.196] Searching for globals...
[16:05:57.196] 
[16:05:57.196] Searching for globals ... DONE
[16:05:57.197] - globals: [0] <none>
[16:05:57.197] getGlobalsAndPackages() ... DONE
[16:05:57.197] run() for ‘Future’ ...
[16:05:57.197] - state: ‘created’
[16:05:57.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.202]   - Field: ‘label’
[16:05:57.202]   - Field: ‘local’
[16:05:57.202]   - Field: ‘owner’
[16:05:57.202]   - Field: ‘envir’
[16:05:57.202]   - Field: ‘workers’
[16:05:57.202]   - Field: ‘packages’
[16:05:57.202]   - Field: ‘gc’
[16:05:57.202]   - Field: ‘job’
[16:05:57.203]   - Field: ‘conditions’
[16:05:57.203]   - Field: ‘expr’
[16:05:57.203]   - Field: ‘uuid’
[16:05:57.203]   - Field: ‘seed’
[16:05:57.203]   - Field: ‘version’
[16:05:57.203]   - Field: ‘result’
[16:05:57.203]   - Field: ‘asynchronous’
[16:05:57.203]   - Field: ‘calls’
[16:05:57.203]   - Field: ‘globals’
[16:05:57.204]   - Field: ‘stdout’
[16:05:57.204]   - Field: ‘earlySignal’
[16:05:57.204]   - Field: ‘lazy’
[16:05:57.204]   - Field: ‘state’
[16:05:57.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.204] - Launch lazy future ...
[16:05:57.204] Packages needed by the future expression (n = 0): <none>
[16:05:57.205] Packages needed by future strategies (n = 0): <none>
[16:05:57.205] {
[16:05:57.205]     {
[16:05:57.205]         {
[16:05:57.205]             ...future.startTime <- base::Sys.time()
[16:05:57.205]             {
[16:05:57.205]                 {
[16:05:57.205]                   {
[16:05:57.205]                     {
[16:05:57.205]                       base::local({
[16:05:57.205]                         has_future <- base::requireNamespace("future", 
[16:05:57.205]                           quietly = TRUE)
[16:05:57.205]                         if (has_future) {
[16:05:57.205]                           ns <- base::getNamespace("future")
[16:05:57.205]                           version <- ns[[".package"]][["version"]]
[16:05:57.205]                           if (is.null(version)) 
[16:05:57.205]                             version <- utils::packageVersion("future")
[16:05:57.205]                         }
[16:05:57.205]                         else {
[16:05:57.205]                           version <- NULL
[16:05:57.205]                         }
[16:05:57.205]                         if (!has_future || version < "1.8.0") {
[16:05:57.205]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.205]                             "", base::R.version$version.string), 
[16:05:57.205]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.205]                               "release", "version")], collapse = " "), 
[16:05:57.205]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.205]                             info)
[16:05:57.205]                           info <- base::paste(info, collapse = "; ")
[16:05:57.205]                           if (!has_future) {
[16:05:57.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.205]                               info)
[16:05:57.205]                           }
[16:05:57.205]                           else {
[16:05:57.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.205]                               info, version)
[16:05:57.205]                           }
[16:05:57.205]                           base::stop(msg)
[16:05:57.205]                         }
[16:05:57.205]                       })
[16:05:57.205]                     }
[16:05:57.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.205]                     base::options(mc.cores = 1L)
[16:05:57.205]                   }
[16:05:57.205]                   options(future.plan = NULL)
[16:05:57.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.205]                 }
[16:05:57.205]                 ...future.workdir <- getwd()
[16:05:57.205]             }
[16:05:57.205]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.205]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.205]         }
[16:05:57.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.205]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.205]             base::names(...future.oldOptions))
[16:05:57.205]     }
[16:05:57.205]     if (FALSE) {
[16:05:57.205]     }
[16:05:57.205]     else {
[16:05:57.205]         if (TRUE) {
[16:05:57.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.205]                 open = "w")
[16:05:57.205]         }
[16:05:57.205]         else {
[16:05:57.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.205]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.205]         }
[16:05:57.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.205]             base::sink(type = "output", split = FALSE)
[16:05:57.205]             base::close(...future.stdout)
[16:05:57.205]         }, add = TRUE)
[16:05:57.205]     }
[16:05:57.205]     ...future.frame <- base::sys.nframe()
[16:05:57.205]     ...future.conditions <- base::list()
[16:05:57.205]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.205]     if (FALSE) {
[16:05:57.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.205]     }
[16:05:57.205]     ...future.result <- base::tryCatch({
[16:05:57.205]         base::withCallingHandlers({
[16:05:57.205]             ...future.value <- base::withVisible(base::local({
[16:05:57.205]                 withCallingHandlers({
[16:05:57.205]                   1
[16:05:57.205]                 }, immediateCondition = function(cond) {
[16:05:57.205]                   save_rds <- function (object, pathname, ...) 
[16:05:57.205]                   {
[16:05:57.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.205]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.205]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.205]                         fi_tmp[["mtime"]])
[16:05:57.205]                     }
[16:05:57.205]                     tryCatch({
[16:05:57.205]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.205]                     }, error = function(ex) {
[16:05:57.205]                       msg <- conditionMessage(ex)
[16:05:57.205]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.205]                         fi_tmp[["mtime"]], msg)
[16:05:57.205]                       ex$message <- msg
[16:05:57.205]                       stop(ex)
[16:05:57.205]                     })
[16:05:57.205]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.205]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.205]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.205]                       fi <- file.info(pathname)
[16:05:57.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.205]                         fi[["size"]], fi[["mtime"]])
[16:05:57.205]                       stop(msg)
[16:05:57.205]                     }
[16:05:57.205]                     invisible(pathname)
[16:05:57.205]                   }
[16:05:57.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.205]                     rootPath = tempdir()) 
[16:05:57.205]                   {
[16:05:57.205]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.205]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.205]                       tmpdir = path, fileext = ".rds")
[16:05:57.205]                     save_rds(obj, file)
[16:05:57.205]                   }
[16:05:57.205]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.205]                   {
[16:05:57.205]                     inherits <- base::inherits
[16:05:57.205]                     invokeRestart <- base::invokeRestart
[16:05:57.205]                     is.null <- base::is.null
[16:05:57.205]                     muffled <- FALSE
[16:05:57.205]                     if (inherits(cond, "message")) {
[16:05:57.205]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.205]                       if (muffled) 
[16:05:57.205]                         invokeRestart("muffleMessage")
[16:05:57.205]                     }
[16:05:57.205]                     else if (inherits(cond, "warning")) {
[16:05:57.205]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.205]                       if (muffled) 
[16:05:57.205]                         invokeRestart("muffleWarning")
[16:05:57.205]                     }
[16:05:57.205]                     else if (inherits(cond, "condition")) {
[16:05:57.205]                       if (!is.null(pattern)) {
[16:05:57.205]                         computeRestarts <- base::computeRestarts
[16:05:57.205]                         grepl <- base::grepl
[16:05:57.205]                         restarts <- computeRestarts(cond)
[16:05:57.205]                         for (restart in restarts) {
[16:05:57.205]                           name <- restart$name
[16:05:57.205]                           if (is.null(name)) 
[16:05:57.205]                             next
[16:05:57.205]                           if (!grepl(pattern, name)) 
[16:05:57.205]                             next
[16:05:57.205]                           invokeRestart(restart)
[16:05:57.205]                           muffled <- TRUE
[16:05:57.205]                           break
[16:05:57.205]                         }
[16:05:57.205]                       }
[16:05:57.205]                     }
[16:05:57.205]                     invisible(muffled)
[16:05:57.205]                   }
[16:05:57.205]                   muffleCondition(cond)
[16:05:57.205]                 })
[16:05:57.205]             }))
[16:05:57.205]             future::FutureResult(value = ...future.value$value, 
[16:05:57.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.205]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.205]                     ...future.globalenv.names))
[16:05:57.205]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.205]         }, condition = base::local({
[16:05:57.205]             c <- base::c
[16:05:57.205]             inherits <- base::inherits
[16:05:57.205]             invokeRestart <- base::invokeRestart
[16:05:57.205]             length <- base::length
[16:05:57.205]             list <- base::list
[16:05:57.205]             seq.int <- base::seq.int
[16:05:57.205]             signalCondition <- base::signalCondition
[16:05:57.205]             sys.calls <- base::sys.calls
[16:05:57.205]             `[[` <- base::`[[`
[16:05:57.205]             `+` <- base::`+`
[16:05:57.205]             `<<-` <- base::`<<-`
[16:05:57.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.205]                   3L)]
[16:05:57.205]             }
[16:05:57.205]             function(cond) {
[16:05:57.205]                 is_error <- inherits(cond, "error")
[16:05:57.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.205]                   NULL)
[16:05:57.205]                 if (is_error) {
[16:05:57.205]                   sessionInformation <- function() {
[16:05:57.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.205]                       search = base::search(), system = base::Sys.info())
[16:05:57.205]                   }
[16:05:57.205]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.205]                     cond$call), session = sessionInformation(), 
[16:05:57.205]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.205]                   signalCondition(cond)
[16:05:57.205]                 }
[16:05:57.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.205]                 "immediateCondition"))) {
[16:05:57.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.205]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.205]                   if (TRUE && !signal) {
[16:05:57.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.205]                     {
[16:05:57.205]                       inherits <- base::inherits
[16:05:57.205]                       invokeRestart <- base::invokeRestart
[16:05:57.205]                       is.null <- base::is.null
[16:05:57.205]                       muffled <- FALSE
[16:05:57.205]                       if (inherits(cond, "message")) {
[16:05:57.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.205]                         if (muffled) 
[16:05:57.205]                           invokeRestart("muffleMessage")
[16:05:57.205]                       }
[16:05:57.205]                       else if (inherits(cond, "warning")) {
[16:05:57.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.205]                         if (muffled) 
[16:05:57.205]                           invokeRestart("muffleWarning")
[16:05:57.205]                       }
[16:05:57.205]                       else if (inherits(cond, "condition")) {
[16:05:57.205]                         if (!is.null(pattern)) {
[16:05:57.205]                           computeRestarts <- base::computeRestarts
[16:05:57.205]                           grepl <- base::grepl
[16:05:57.205]                           restarts <- computeRestarts(cond)
[16:05:57.205]                           for (restart in restarts) {
[16:05:57.205]                             name <- restart$name
[16:05:57.205]                             if (is.null(name)) 
[16:05:57.205]                               next
[16:05:57.205]                             if (!grepl(pattern, name)) 
[16:05:57.205]                               next
[16:05:57.205]                             invokeRestart(restart)
[16:05:57.205]                             muffled <- TRUE
[16:05:57.205]                             break
[16:05:57.205]                           }
[16:05:57.205]                         }
[16:05:57.205]                       }
[16:05:57.205]                       invisible(muffled)
[16:05:57.205]                     }
[16:05:57.205]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.205]                   }
[16:05:57.205]                 }
[16:05:57.205]                 else {
[16:05:57.205]                   if (TRUE) {
[16:05:57.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.205]                     {
[16:05:57.205]                       inherits <- base::inherits
[16:05:57.205]                       invokeRestart <- base::invokeRestart
[16:05:57.205]                       is.null <- base::is.null
[16:05:57.205]                       muffled <- FALSE
[16:05:57.205]                       if (inherits(cond, "message")) {
[16:05:57.205]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.205]                         if (muffled) 
[16:05:57.205]                           invokeRestart("muffleMessage")
[16:05:57.205]                       }
[16:05:57.205]                       else if (inherits(cond, "warning")) {
[16:05:57.205]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.205]                         if (muffled) 
[16:05:57.205]                           invokeRestart("muffleWarning")
[16:05:57.205]                       }
[16:05:57.205]                       else if (inherits(cond, "condition")) {
[16:05:57.205]                         if (!is.null(pattern)) {
[16:05:57.205]                           computeRestarts <- base::computeRestarts
[16:05:57.205]                           grepl <- base::grepl
[16:05:57.205]                           restarts <- computeRestarts(cond)
[16:05:57.205]                           for (restart in restarts) {
[16:05:57.205]                             name <- restart$name
[16:05:57.205]                             if (is.null(name)) 
[16:05:57.205]                               next
[16:05:57.205]                             if (!grepl(pattern, name)) 
[16:05:57.205]                               next
[16:05:57.205]                             invokeRestart(restart)
[16:05:57.205]                             muffled <- TRUE
[16:05:57.205]                             break
[16:05:57.205]                           }
[16:05:57.205]                         }
[16:05:57.205]                       }
[16:05:57.205]                       invisible(muffled)
[16:05:57.205]                     }
[16:05:57.205]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.205]                   }
[16:05:57.205]                 }
[16:05:57.205]             }
[16:05:57.205]         }))
[16:05:57.205]     }, error = function(ex) {
[16:05:57.205]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.205]                 ...future.rng), started = ...future.startTime, 
[16:05:57.205]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.205]             version = "1.8"), class = "FutureResult")
[16:05:57.205]     }, finally = {
[16:05:57.205]         if (!identical(...future.workdir, getwd())) 
[16:05:57.205]             setwd(...future.workdir)
[16:05:57.205]         {
[16:05:57.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.205]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.205]             }
[16:05:57.205]             base::options(...future.oldOptions)
[16:05:57.205]             if (.Platform$OS.type == "windows") {
[16:05:57.205]                 old_names <- names(...future.oldEnvVars)
[16:05:57.205]                 envs <- base::Sys.getenv()
[16:05:57.205]                 names <- names(envs)
[16:05:57.205]                 common <- intersect(names, old_names)
[16:05:57.205]                 added <- setdiff(names, old_names)
[16:05:57.205]                 removed <- setdiff(old_names, names)
[16:05:57.205]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.205]                   envs[common]]
[16:05:57.205]                 NAMES <- toupper(changed)
[16:05:57.205]                 args <- list()
[16:05:57.205]                 for (kk in seq_along(NAMES)) {
[16:05:57.205]                   name <- changed[[kk]]
[16:05:57.205]                   NAME <- NAMES[[kk]]
[16:05:57.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.205]                     next
[16:05:57.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.205]                 }
[16:05:57.205]                 NAMES <- toupper(added)
[16:05:57.205]                 for (kk in seq_along(NAMES)) {
[16:05:57.205]                   name <- added[[kk]]
[16:05:57.205]                   NAME <- NAMES[[kk]]
[16:05:57.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.205]                     next
[16:05:57.205]                   args[[name]] <- ""
[16:05:57.205]                 }
[16:05:57.205]                 NAMES <- toupper(removed)
[16:05:57.205]                 for (kk in seq_along(NAMES)) {
[16:05:57.205]                   name <- removed[[kk]]
[16:05:57.205]                   NAME <- NAMES[[kk]]
[16:05:57.205]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.205]                     next
[16:05:57.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.205]                 }
[16:05:57.205]                 if (length(args) > 0) 
[16:05:57.205]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.205]             }
[16:05:57.205]             else {
[16:05:57.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.205]             }
[16:05:57.205]             {
[16:05:57.205]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.205]                   0L) {
[16:05:57.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.205]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.205]                   base::options(opts)
[16:05:57.205]                 }
[16:05:57.205]                 {
[16:05:57.205]                   {
[16:05:57.205]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.205]                     NULL
[16:05:57.205]                   }
[16:05:57.205]                   options(future.plan = NULL)
[16:05:57.205]                   if (is.na(NA_character_)) 
[16:05:57.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.205]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.205]                     envir = parent.frame()) 
[16:05:57.205]                   {
[16:05:57.205]                     default_workers <- missing(workers)
[16:05:57.205]                     if (is.function(workers)) 
[16:05:57.205]                       workers <- workers()
[16:05:57.205]                     workers <- structure(as.integer(workers), 
[16:05:57.205]                       class = class(workers))
[16:05:57.205]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.205]                       1L)
[16:05:57.205]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.205]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.205]                       if (default_workers) 
[16:05:57.205]                         supportsMulticore(warn = TRUE)
[16:05:57.205]                       return(sequential(..., envir = envir))
[16:05:57.205]                     }
[16:05:57.205]                     oopts <- options(mc.cores = workers)
[16:05:57.205]                     on.exit(options(oopts))
[16:05:57.205]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.205]                       envir = envir)
[16:05:57.205]                     if (!future$lazy) 
[16:05:57.205]                       future <- run(future)
[16:05:57.205]                     invisible(future)
[16:05:57.205]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.205]                 }
[16:05:57.205]             }
[16:05:57.205]         }
[16:05:57.205]     })
[16:05:57.205]     if (TRUE) {
[16:05:57.205]         base::sink(type = "output", split = FALSE)
[16:05:57.205]         if (TRUE) {
[16:05:57.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.205]         }
[16:05:57.205]         else {
[16:05:57.205]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.205]         }
[16:05:57.205]         base::close(...future.stdout)
[16:05:57.205]         ...future.stdout <- NULL
[16:05:57.205]     }
[16:05:57.205]     ...future.result$conditions <- ...future.conditions
[16:05:57.205]     ...future.result$finished <- base::Sys.time()
[16:05:57.205]     ...future.result
[16:05:57.205] }
[16:05:57.208] requestCore(): workers = 2
[16:05:57.211] MulticoreFuture started
[16:05:57.211] - Launch lazy future ... done
[16:05:57.212] run() for ‘MulticoreFuture’ ... done
[16:05:57.212] getGlobalsAndPackages() ...
[16:05:57.212] Searching for globals...
[16:05:57.212] plan(): Setting new future strategy stack:
[16:05:57.212] List of future strategies:
[16:05:57.212] 1. sequential:
[16:05:57.212]    - args: function (..., envir = parent.frame())
[16:05:57.212]    - tweaked: FALSE
[16:05:57.212]    - call: NULL
[16:05:57.213] 
[16:05:57.213] Searching for globals ... DONE
[16:05:57.213] plan(): nbrOfWorkers() = 1
[16:05:57.213] - globals: [0] <none>
[16:05:57.214] getGlobalsAndPackages() ... DONE
[16:05:57.214] run() for ‘Future’ ...
[16:05:57.214] - state: ‘created’
[16:05:57.215] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.215] plan(): Setting new future strategy stack:
[16:05:57.216] List of future strategies:
[16:05:57.216] 1. multicore:
[16:05:57.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.216]    - tweaked: FALSE
[16:05:57.216]    - call: plan(strategy)
[16:05:57.220] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.221] plan(): nbrOfWorkers() = 2
[16:05:57.221]   - Field: ‘label’
[16:05:57.221]   - Field: ‘local’
[16:05:57.221]   - Field: ‘owner’
[16:05:57.222]   - Field: ‘envir’
[16:05:57.222]   - Field: ‘workers’
[16:05:57.222]   - Field: ‘packages’
[16:05:57.222]   - Field: ‘gc’
[16:05:57.222]   - Field: ‘job’
[16:05:57.222]   - Field: ‘conditions’
[16:05:57.223]   - Field: ‘expr’
[16:05:57.223]   - Field: ‘uuid’
[16:05:57.223]   - Field: ‘seed’
[16:05:57.223]   - Field: ‘version’
[16:05:57.223]   - Field: ‘result’
[16:05:57.223]   - Field: ‘asynchronous’
[16:05:57.223]   - Field: ‘calls’
[16:05:57.224]   - Field: ‘globals’
[16:05:57.224]   - Field: ‘stdout’
[16:05:57.224]   - Field: ‘earlySignal’
[16:05:57.224]   - Field: ‘lazy’
[16:05:57.224]   - Field: ‘state’
[16:05:57.224] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.224] - Launch lazy future ...
[16:05:57.225] Packages needed by the future expression (n = 0): <none>
[16:05:57.225] Packages needed by future strategies (n = 0): <none>
[16:05:57.226] {
[16:05:57.226]     {
[16:05:57.226]         {
[16:05:57.226]             ...future.startTime <- base::Sys.time()
[16:05:57.226]             {
[16:05:57.226]                 {
[16:05:57.226]                   {
[16:05:57.226]                     {
[16:05:57.226]                       base::local({
[16:05:57.226]                         has_future <- base::requireNamespace("future", 
[16:05:57.226]                           quietly = TRUE)
[16:05:57.226]                         if (has_future) {
[16:05:57.226]                           ns <- base::getNamespace("future")
[16:05:57.226]                           version <- ns[[".package"]][["version"]]
[16:05:57.226]                           if (is.null(version)) 
[16:05:57.226]                             version <- utils::packageVersion("future")
[16:05:57.226]                         }
[16:05:57.226]                         else {
[16:05:57.226]                           version <- NULL
[16:05:57.226]                         }
[16:05:57.226]                         if (!has_future || version < "1.8.0") {
[16:05:57.226]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.226]                             "", base::R.version$version.string), 
[16:05:57.226]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.226]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.226]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.226]                               "release", "version")], collapse = " "), 
[16:05:57.226]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.226]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.226]                             info)
[16:05:57.226]                           info <- base::paste(info, collapse = "; ")
[16:05:57.226]                           if (!has_future) {
[16:05:57.226]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.226]                               info)
[16:05:57.226]                           }
[16:05:57.226]                           else {
[16:05:57.226]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.226]                               info, version)
[16:05:57.226]                           }
[16:05:57.226]                           base::stop(msg)
[16:05:57.226]                         }
[16:05:57.226]                       })
[16:05:57.226]                     }
[16:05:57.226]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.226]                     base::options(mc.cores = 1L)
[16:05:57.226]                   }
[16:05:57.226]                   options(future.plan = NULL)
[16:05:57.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.226]                 }
[16:05:57.226]                 ...future.workdir <- getwd()
[16:05:57.226]             }
[16:05:57.226]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.226]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.226]         }
[16:05:57.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.226]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.226]             base::names(...future.oldOptions))
[16:05:57.226]     }
[16:05:57.226]     if (FALSE) {
[16:05:57.226]     }
[16:05:57.226]     else {
[16:05:57.226]         if (TRUE) {
[16:05:57.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.226]                 open = "w")
[16:05:57.226]         }
[16:05:57.226]         else {
[16:05:57.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.226]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.226]         }
[16:05:57.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.226]             base::sink(type = "output", split = FALSE)
[16:05:57.226]             base::close(...future.stdout)
[16:05:57.226]         }, add = TRUE)
[16:05:57.226]     }
[16:05:57.226]     ...future.frame <- base::sys.nframe()
[16:05:57.226]     ...future.conditions <- base::list()
[16:05:57.226]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.226]     if (FALSE) {
[16:05:57.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.226]     }
[16:05:57.226]     ...future.result <- base::tryCatch({
[16:05:57.226]         base::withCallingHandlers({
[16:05:57.226]             ...future.value <- base::withVisible(base::local({
[16:05:57.226]                 withCallingHandlers({
[16:05:57.226]                   2
[16:05:57.226]                 }, immediateCondition = function(cond) {
[16:05:57.226]                   save_rds <- function (object, pathname, ...) 
[16:05:57.226]                   {
[16:05:57.226]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.226]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.226]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.226]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.226]                         fi_tmp[["mtime"]])
[16:05:57.226]                     }
[16:05:57.226]                     tryCatch({
[16:05:57.226]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.226]                     }, error = function(ex) {
[16:05:57.226]                       msg <- conditionMessage(ex)
[16:05:57.226]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.226]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.226]                         fi_tmp[["mtime"]], msg)
[16:05:57.226]                       ex$message <- msg
[16:05:57.226]                       stop(ex)
[16:05:57.226]                     })
[16:05:57.226]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.226]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.226]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.226]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.226]                       fi <- file.info(pathname)
[16:05:57.226]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.226]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.226]                         fi[["size"]], fi[["mtime"]])
[16:05:57.226]                       stop(msg)
[16:05:57.226]                     }
[16:05:57.226]                     invisible(pathname)
[16:05:57.226]                   }
[16:05:57.226]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.226]                     rootPath = tempdir()) 
[16:05:57.226]                   {
[16:05:57.226]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.226]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.226]                       tmpdir = path, fileext = ".rds")
[16:05:57.226]                     save_rds(obj, file)
[16:05:57.226]                   }
[16:05:57.226]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.226]                   {
[16:05:57.226]                     inherits <- base::inherits
[16:05:57.226]                     invokeRestart <- base::invokeRestart
[16:05:57.226]                     is.null <- base::is.null
[16:05:57.226]                     muffled <- FALSE
[16:05:57.226]                     if (inherits(cond, "message")) {
[16:05:57.226]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.226]                       if (muffled) 
[16:05:57.226]                         invokeRestart("muffleMessage")
[16:05:57.226]                     }
[16:05:57.226]                     else if (inherits(cond, "warning")) {
[16:05:57.226]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.226]                       if (muffled) 
[16:05:57.226]                         invokeRestart("muffleWarning")
[16:05:57.226]                     }
[16:05:57.226]                     else if (inherits(cond, "condition")) {
[16:05:57.226]                       if (!is.null(pattern)) {
[16:05:57.226]                         computeRestarts <- base::computeRestarts
[16:05:57.226]                         grepl <- base::grepl
[16:05:57.226]                         restarts <- computeRestarts(cond)
[16:05:57.226]                         for (restart in restarts) {
[16:05:57.226]                           name <- restart$name
[16:05:57.226]                           if (is.null(name)) 
[16:05:57.226]                             next
[16:05:57.226]                           if (!grepl(pattern, name)) 
[16:05:57.226]                             next
[16:05:57.226]                           invokeRestart(restart)
[16:05:57.226]                           muffled <- TRUE
[16:05:57.226]                           break
[16:05:57.226]                         }
[16:05:57.226]                       }
[16:05:57.226]                     }
[16:05:57.226]                     invisible(muffled)
[16:05:57.226]                   }
[16:05:57.226]                   muffleCondition(cond)
[16:05:57.226]                 })
[16:05:57.226]             }))
[16:05:57.226]             future::FutureResult(value = ...future.value$value, 
[16:05:57.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.226]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.226]                     ...future.globalenv.names))
[16:05:57.226]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.226]         }, condition = base::local({
[16:05:57.226]             c <- base::c
[16:05:57.226]             inherits <- base::inherits
[16:05:57.226]             invokeRestart <- base::invokeRestart
[16:05:57.226]             length <- base::length
[16:05:57.226]             list <- base::list
[16:05:57.226]             seq.int <- base::seq.int
[16:05:57.226]             signalCondition <- base::signalCondition
[16:05:57.226]             sys.calls <- base::sys.calls
[16:05:57.226]             `[[` <- base::`[[`
[16:05:57.226]             `+` <- base::`+`
[16:05:57.226]             `<<-` <- base::`<<-`
[16:05:57.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.226]                   3L)]
[16:05:57.226]             }
[16:05:57.226]             function(cond) {
[16:05:57.226]                 is_error <- inherits(cond, "error")
[16:05:57.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.226]                   NULL)
[16:05:57.226]                 if (is_error) {
[16:05:57.226]                   sessionInformation <- function() {
[16:05:57.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.226]                       search = base::search(), system = base::Sys.info())
[16:05:57.226]                   }
[16:05:57.226]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.226]                     cond$call), session = sessionInformation(), 
[16:05:57.226]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.226]                   signalCondition(cond)
[16:05:57.226]                 }
[16:05:57.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.226]                 "immediateCondition"))) {
[16:05:57.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.226]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.226]                   if (TRUE && !signal) {
[16:05:57.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.226]                     {
[16:05:57.226]                       inherits <- base::inherits
[16:05:57.226]                       invokeRestart <- base::invokeRestart
[16:05:57.226]                       is.null <- base::is.null
[16:05:57.226]                       muffled <- FALSE
[16:05:57.226]                       if (inherits(cond, "message")) {
[16:05:57.226]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.226]                         if (muffled) 
[16:05:57.226]                           invokeRestart("muffleMessage")
[16:05:57.226]                       }
[16:05:57.226]                       else if (inherits(cond, "warning")) {
[16:05:57.226]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.226]                         if (muffled) 
[16:05:57.226]                           invokeRestart("muffleWarning")
[16:05:57.226]                       }
[16:05:57.226]                       else if (inherits(cond, "condition")) {
[16:05:57.226]                         if (!is.null(pattern)) {
[16:05:57.226]                           computeRestarts <- base::computeRestarts
[16:05:57.226]                           grepl <- base::grepl
[16:05:57.226]                           restarts <- computeRestarts(cond)
[16:05:57.226]                           for (restart in restarts) {
[16:05:57.226]                             name <- restart$name
[16:05:57.226]                             if (is.null(name)) 
[16:05:57.226]                               next
[16:05:57.226]                             if (!grepl(pattern, name)) 
[16:05:57.226]                               next
[16:05:57.226]                             invokeRestart(restart)
[16:05:57.226]                             muffled <- TRUE
[16:05:57.226]                             break
[16:05:57.226]                           }
[16:05:57.226]                         }
[16:05:57.226]                       }
[16:05:57.226]                       invisible(muffled)
[16:05:57.226]                     }
[16:05:57.226]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.226]                   }
[16:05:57.226]                 }
[16:05:57.226]                 else {
[16:05:57.226]                   if (TRUE) {
[16:05:57.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.226]                     {
[16:05:57.226]                       inherits <- base::inherits
[16:05:57.226]                       invokeRestart <- base::invokeRestart
[16:05:57.226]                       is.null <- base::is.null
[16:05:57.226]                       muffled <- FALSE
[16:05:57.226]                       if (inherits(cond, "message")) {
[16:05:57.226]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.226]                         if (muffled) 
[16:05:57.226]                           invokeRestart("muffleMessage")
[16:05:57.226]                       }
[16:05:57.226]                       else if (inherits(cond, "warning")) {
[16:05:57.226]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.226]                         if (muffled) 
[16:05:57.226]                           invokeRestart("muffleWarning")
[16:05:57.226]                       }
[16:05:57.226]                       else if (inherits(cond, "condition")) {
[16:05:57.226]                         if (!is.null(pattern)) {
[16:05:57.226]                           computeRestarts <- base::computeRestarts
[16:05:57.226]                           grepl <- base::grepl
[16:05:57.226]                           restarts <- computeRestarts(cond)
[16:05:57.226]                           for (restart in restarts) {
[16:05:57.226]                             name <- restart$name
[16:05:57.226]                             if (is.null(name)) 
[16:05:57.226]                               next
[16:05:57.226]                             if (!grepl(pattern, name)) 
[16:05:57.226]                               next
[16:05:57.226]                             invokeRestart(restart)
[16:05:57.226]                             muffled <- TRUE
[16:05:57.226]                             break
[16:05:57.226]                           }
[16:05:57.226]                         }
[16:05:57.226]                       }
[16:05:57.226]                       invisible(muffled)
[16:05:57.226]                     }
[16:05:57.226]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.226]                   }
[16:05:57.226]                 }
[16:05:57.226]             }
[16:05:57.226]         }))
[16:05:57.226]     }, error = function(ex) {
[16:05:57.226]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.226]                 ...future.rng), started = ...future.startTime, 
[16:05:57.226]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.226]             version = "1.8"), class = "FutureResult")
[16:05:57.226]     }, finally = {
[16:05:57.226]         if (!identical(...future.workdir, getwd())) 
[16:05:57.226]             setwd(...future.workdir)
[16:05:57.226]         {
[16:05:57.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.226]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.226]             }
[16:05:57.226]             base::options(...future.oldOptions)
[16:05:57.226]             if (.Platform$OS.type == "windows") {
[16:05:57.226]                 old_names <- names(...future.oldEnvVars)
[16:05:57.226]                 envs <- base::Sys.getenv()
[16:05:57.226]                 names <- names(envs)
[16:05:57.226]                 common <- intersect(names, old_names)
[16:05:57.226]                 added <- setdiff(names, old_names)
[16:05:57.226]                 removed <- setdiff(old_names, names)
[16:05:57.226]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.226]                   envs[common]]
[16:05:57.226]                 NAMES <- toupper(changed)
[16:05:57.226]                 args <- list()
[16:05:57.226]                 for (kk in seq_along(NAMES)) {
[16:05:57.226]                   name <- changed[[kk]]
[16:05:57.226]                   NAME <- NAMES[[kk]]
[16:05:57.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.226]                     next
[16:05:57.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.226]                 }
[16:05:57.226]                 NAMES <- toupper(added)
[16:05:57.226]                 for (kk in seq_along(NAMES)) {
[16:05:57.226]                   name <- added[[kk]]
[16:05:57.226]                   NAME <- NAMES[[kk]]
[16:05:57.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.226]                     next
[16:05:57.226]                   args[[name]] <- ""
[16:05:57.226]                 }
[16:05:57.226]                 NAMES <- toupper(removed)
[16:05:57.226]                 for (kk in seq_along(NAMES)) {
[16:05:57.226]                   name <- removed[[kk]]
[16:05:57.226]                   NAME <- NAMES[[kk]]
[16:05:57.226]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.226]                     next
[16:05:57.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.226]                 }
[16:05:57.226]                 if (length(args) > 0) 
[16:05:57.226]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.226]             }
[16:05:57.226]             else {
[16:05:57.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.226]             }
[16:05:57.226]             {
[16:05:57.226]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.226]                   0L) {
[16:05:57.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.226]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.226]                   base::options(opts)
[16:05:57.226]                 }
[16:05:57.226]                 {
[16:05:57.226]                   {
[16:05:57.226]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.226]                     NULL
[16:05:57.226]                   }
[16:05:57.226]                   options(future.plan = NULL)
[16:05:57.226]                   if (is.na(NA_character_)) 
[16:05:57.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.226]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.226]                     envir = parent.frame()) 
[16:05:57.226]                   {
[16:05:57.226]                     default_workers <- missing(workers)
[16:05:57.226]                     if (is.function(workers)) 
[16:05:57.226]                       workers <- workers()
[16:05:57.226]                     workers <- structure(as.integer(workers), 
[16:05:57.226]                       class = class(workers))
[16:05:57.226]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.226]                       1L)
[16:05:57.226]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.226]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.226]                       if (default_workers) 
[16:05:57.226]                         supportsMulticore(warn = TRUE)
[16:05:57.226]                       return(sequential(..., envir = envir))
[16:05:57.226]                     }
[16:05:57.226]                     oopts <- options(mc.cores = workers)
[16:05:57.226]                     on.exit(options(oopts))
[16:05:57.226]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.226]                       envir = envir)
[16:05:57.226]                     if (!future$lazy) 
[16:05:57.226]                       future <- run(future)
[16:05:57.226]                     invisible(future)
[16:05:57.226]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.226]                 }
[16:05:57.226]             }
[16:05:57.226]         }
[16:05:57.226]     })
[16:05:57.226]     if (TRUE) {
[16:05:57.226]         base::sink(type = "output", split = FALSE)
[16:05:57.226]         if (TRUE) {
[16:05:57.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.226]         }
[16:05:57.226]         else {
[16:05:57.226]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.226]         }
[16:05:57.226]         base::close(...future.stdout)
[16:05:57.226]         ...future.stdout <- NULL
[16:05:57.226]     }
[16:05:57.226]     ...future.result$conditions <- ...future.conditions
[16:05:57.226]     ...future.result$finished <- base::Sys.time()
[16:05:57.226]     ...future.result
[16:05:57.226] }
[16:05:57.230] requestCore(): workers = 2
[16:05:57.232] MulticoreFuture started
[16:05:57.232] - Launch lazy future ... done
[16:05:57.233] run() for ‘MulticoreFuture’ ... done
[16:05:57.233] plan(): Setting new future strategy stack:
[16:05:57.234] resolve() on list environment ...
[16:05:57.233] List of future strategies:
[16:05:57.233] 1. sequential:
[16:05:57.233]    - args: function (..., envir = parent.frame())
[16:05:57.233]    - tweaked: FALSE
[16:05:57.233]    - call: NULL
[16:05:57.234]  recursive: 0
[16:05:57.234] plan(): nbrOfWorkers() = 1
[16:05:57.235]  length: 3
[16:05:57.235]  elements: ‘a’, ‘b’, ‘c’
[16:05:57.236] Future #1
[16:05:57.236]  length: 2 (resolved future 1)
[16:05:57.236] plan(): Setting new future strategy stack:
[16:05:57.237] List of future strategies:
[16:05:57.237] 1. multicore:
[16:05:57.237]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.237]    - tweaked: FALSE
[16:05:57.237]    - call: plan(strategy)
[16:05:57.242] plan(): nbrOfWorkers() = 2
[16:05:57.242] Future #2
[16:05:57.243]  length: 1 (resolved future 2)
[16:05:57.243]  length: 0 (resolved future 3)
[16:05:57.243] resolve() on list environment ... DONE
[16:05:57.250] getGlobalsAndPackages() ...
[16:05:57.250] Searching for globals...
[16:05:57.252] - globals found: [1] ‘{’
[16:05:57.253] Searching for globals ... DONE
[16:05:57.253] Resolving globals: FALSE
[16:05:57.253] 
[16:05:57.254] 
[16:05:57.254] getGlobalsAndPackages() ... DONE
[16:05:57.254] run() for ‘Future’ ...
[16:05:57.254] - state: ‘created’
[16:05:57.255] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.259] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.260]   - Field: ‘label’
[16:05:57.260]   - Field: ‘local’
[16:05:57.260]   - Field: ‘owner’
[16:05:57.260]   - Field: ‘envir’
[16:05:57.261]   - Field: ‘workers’
[16:05:57.261]   - Field: ‘packages’
[16:05:57.261]   - Field: ‘gc’
[16:05:57.261]   - Field: ‘job’
[16:05:57.261]   - Field: ‘conditions’
[16:05:57.262]   - Field: ‘expr’
[16:05:57.262]   - Field: ‘uuid’
[16:05:57.262]   - Field: ‘seed’
[16:05:57.262]   - Field: ‘version’
[16:05:57.262]   - Field: ‘result’
[16:05:57.262]   - Field: ‘asynchronous’
[16:05:57.262]   - Field: ‘calls’
[16:05:57.262]   - Field: ‘globals’
[16:05:57.263]   - Field: ‘stdout’
[16:05:57.263]   - Field: ‘earlySignal’
[16:05:57.263]   - Field: ‘lazy’
[16:05:57.263]   - Field: ‘state’
[16:05:57.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.263] - Launch lazy future ...
[16:05:57.264] Packages needed by the future expression (n = 0): <none>
[16:05:57.264] Packages needed by future strategies (n = 0): <none>
[16:05:57.265] {
[16:05:57.265]     {
[16:05:57.265]         {
[16:05:57.265]             ...future.startTime <- base::Sys.time()
[16:05:57.265]             {
[16:05:57.265]                 {
[16:05:57.265]                   {
[16:05:57.265]                     {
[16:05:57.265]                       base::local({
[16:05:57.265]                         has_future <- base::requireNamespace("future", 
[16:05:57.265]                           quietly = TRUE)
[16:05:57.265]                         if (has_future) {
[16:05:57.265]                           ns <- base::getNamespace("future")
[16:05:57.265]                           version <- ns[[".package"]][["version"]]
[16:05:57.265]                           if (is.null(version)) 
[16:05:57.265]                             version <- utils::packageVersion("future")
[16:05:57.265]                         }
[16:05:57.265]                         else {
[16:05:57.265]                           version <- NULL
[16:05:57.265]                         }
[16:05:57.265]                         if (!has_future || version < "1.8.0") {
[16:05:57.265]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.265]                             "", base::R.version$version.string), 
[16:05:57.265]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.265]                               "release", "version")], collapse = " "), 
[16:05:57.265]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.265]                             info)
[16:05:57.265]                           info <- base::paste(info, collapse = "; ")
[16:05:57.265]                           if (!has_future) {
[16:05:57.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.265]                               info)
[16:05:57.265]                           }
[16:05:57.265]                           else {
[16:05:57.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.265]                               info, version)
[16:05:57.265]                           }
[16:05:57.265]                           base::stop(msg)
[16:05:57.265]                         }
[16:05:57.265]                       })
[16:05:57.265]                     }
[16:05:57.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.265]                     base::options(mc.cores = 1L)
[16:05:57.265]                   }
[16:05:57.265]                   options(future.plan = NULL)
[16:05:57.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.265]                 }
[16:05:57.265]                 ...future.workdir <- getwd()
[16:05:57.265]             }
[16:05:57.265]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.265]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.265]         }
[16:05:57.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.265]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.265]             base::names(...future.oldOptions))
[16:05:57.265]     }
[16:05:57.265]     if (FALSE) {
[16:05:57.265]     }
[16:05:57.265]     else {
[16:05:57.265]         if (TRUE) {
[16:05:57.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.265]                 open = "w")
[16:05:57.265]         }
[16:05:57.265]         else {
[16:05:57.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.265]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.265]         }
[16:05:57.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.265]             base::sink(type = "output", split = FALSE)
[16:05:57.265]             base::close(...future.stdout)
[16:05:57.265]         }, add = TRUE)
[16:05:57.265]     }
[16:05:57.265]     ...future.frame <- base::sys.nframe()
[16:05:57.265]     ...future.conditions <- base::list()
[16:05:57.265]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.265]     if (FALSE) {
[16:05:57.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.265]     }
[16:05:57.265]     ...future.result <- base::tryCatch({
[16:05:57.265]         base::withCallingHandlers({
[16:05:57.265]             ...future.value <- base::withVisible(base::local({
[16:05:57.265]                 withCallingHandlers({
[16:05:57.265]                   {
[16:05:57.265]                     1
[16:05:57.265]                   }
[16:05:57.265]                 }, immediateCondition = function(cond) {
[16:05:57.265]                   save_rds <- function (object, pathname, ...) 
[16:05:57.265]                   {
[16:05:57.265]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.265]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.265]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.265]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.265]                         fi_tmp[["mtime"]])
[16:05:57.265]                     }
[16:05:57.265]                     tryCatch({
[16:05:57.265]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.265]                     }, error = function(ex) {
[16:05:57.265]                       msg <- conditionMessage(ex)
[16:05:57.265]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.265]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.265]                         fi_tmp[["mtime"]], msg)
[16:05:57.265]                       ex$message <- msg
[16:05:57.265]                       stop(ex)
[16:05:57.265]                     })
[16:05:57.265]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.265]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.265]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.265]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.265]                       fi <- file.info(pathname)
[16:05:57.265]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.265]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.265]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.265]                         fi[["size"]], fi[["mtime"]])
[16:05:57.265]                       stop(msg)
[16:05:57.265]                     }
[16:05:57.265]                     invisible(pathname)
[16:05:57.265]                   }
[16:05:57.265]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.265]                     rootPath = tempdir()) 
[16:05:57.265]                   {
[16:05:57.265]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.265]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.265]                       tmpdir = path, fileext = ".rds")
[16:05:57.265]                     save_rds(obj, file)
[16:05:57.265]                   }
[16:05:57.265]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.265]                   {
[16:05:57.265]                     inherits <- base::inherits
[16:05:57.265]                     invokeRestart <- base::invokeRestart
[16:05:57.265]                     is.null <- base::is.null
[16:05:57.265]                     muffled <- FALSE
[16:05:57.265]                     if (inherits(cond, "message")) {
[16:05:57.265]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.265]                       if (muffled) 
[16:05:57.265]                         invokeRestart("muffleMessage")
[16:05:57.265]                     }
[16:05:57.265]                     else if (inherits(cond, "warning")) {
[16:05:57.265]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.265]                       if (muffled) 
[16:05:57.265]                         invokeRestart("muffleWarning")
[16:05:57.265]                     }
[16:05:57.265]                     else if (inherits(cond, "condition")) {
[16:05:57.265]                       if (!is.null(pattern)) {
[16:05:57.265]                         computeRestarts <- base::computeRestarts
[16:05:57.265]                         grepl <- base::grepl
[16:05:57.265]                         restarts <- computeRestarts(cond)
[16:05:57.265]                         for (restart in restarts) {
[16:05:57.265]                           name <- restart$name
[16:05:57.265]                           if (is.null(name)) 
[16:05:57.265]                             next
[16:05:57.265]                           if (!grepl(pattern, name)) 
[16:05:57.265]                             next
[16:05:57.265]                           invokeRestart(restart)
[16:05:57.265]                           muffled <- TRUE
[16:05:57.265]                           break
[16:05:57.265]                         }
[16:05:57.265]                       }
[16:05:57.265]                     }
[16:05:57.265]                     invisible(muffled)
[16:05:57.265]                   }
[16:05:57.265]                   muffleCondition(cond)
[16:05:57.265]                 })
[16:05:57.265]             }))
[16:05:57.265]             future::FutureResult(value = ...future.value$value, 
[16:05:57.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.265]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.265]                     ...future.globalenv.names))
[16:05:57.265]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.265]         }, condition = base::local({
[16:05:57.265]             c <- base::c
[16:05:57.265]             inherits <- base::inherits
[16:05:57.265]             invokeRestart <- base::invokeRestart
[16:05:57.265]             length <- base::length
[16:05:57.265]             list <- base::list
[16:05:57.265]             seq.int <- base::seq.int
[16:05:57.265]             signalCondition <- base::signalCondition
[16:05:57.265]             sys.calls <- base::sys.calls
[16:05:57.265]             `[[` <- base::`[[`
[16:05:57.265]             `+` <- base::`+`
[16:05:57.265]             `<<-` <- base::`<<-`
[16:05:57.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.265]                   3L)]
[16:05:57.265]             }
[16:05:57.265]             function(cond) {
[16:05:57.265]                 is_error <- inherits(cond, "error")
[16:05:57.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.265]                   NULL)
[16:05:57.265]                 if (is_error) {
[16:05:57.265]                   sessionInformation <- function() {
[16:05:57.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.265]                       search = base::search(), system = base::Sys.info())
[16:05:57.265]                   }
[16:05:57.265]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.265]                     cond$call), session = sessionInformation(), 
[16:05:57.265]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.265]                   signalCondition(cond)
[16:05:57.265]                 }
[16:05:57.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.265]                 "immediateCondition"))) {
[16:05:57.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.265]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.265]                   if (TRUE && !signal) {
[16:05:57.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.265]                     {
[16:05:57.265]                       inherits <- base::inherits
[16:05:57.265]                       invokeRestart <- base::invokeRestart
[16:05:57.265]                       is.null <- base::is.null
[16:05:57.265]                       muffled <- FALSE
[16:05:57.265]                       if (inherits(cond, "message")) {
[16:05:57.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.265]                         if (muffled) 
[16:05:57.265]                           invokeRestart("muffleMessage")
[16:05:57.265]                       }
[16:05:57.265]                       else if (inherits(cond, "warning")) {
[16:05:57.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.265]                         if (muffled) 
[16:05:57.265]                           invokeRestart("muffleWarning")
[16:05:57.265]                       }
[16:05:57.265]                       else if (inherits(cond, "condition")) {
[16:05:57.265]                         if (!is.null(pattern)) {
[16:05:57.265]                           computeRestarts <- base::computeRestarts
[16:05:57.265]                           grepl <- base::grepl
[16:05:57.265]                           restarts <- computeRestarts(cond)
[16:05:57.265]                           for (restart in restarts) {
[16:05:57.265]                             name <- restart$name
[16:05:57.265]                             if (is.null(name)) 
[16:05:57.265]                               next
[16:05:57.265]                             if (!grepl(pattern, name)) 
[16:05:57.265]                               next
[16:05:57.265]                             invokeRestart(restart)
[16:05:57.265]                             muffled <- TRUE
[16:05:57.265]                             break
[16:05:57.265]                           }
[16:05:57.265]                         }
[16:05:57.265]                       }
[16:05:57.265]                       invisible(muffled)
[16:05:57.265]                     }
[16:05:57.265]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.265]                   }
[16:05:57.265]                 }
[16:05:57.265]                 else {
[16:05:57.265]                   if (TRUE) {
[16:05:57.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.265]                     {
[16:05:57.265]                       inherits <- base::inherits
[16:05:57.265]                       invokeRestart <- base::invokeRestart
[16:05:57.265]                       is.null <- base::is.null
[16:05:57.265]                       muffled <- FALSE
[16:05:57.265]                       if (inherits(cond, "message")) {
[16:05:57.265]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.265]                         if (muffled) 
[16:05:57.265]                           invokeRestart("muffleMessage")
[16:05:57.265]                       }
[16:05:57.265]                       else if (inherits(cond, "warning")) {
[16:05:57.265]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.265]                         if (muffled) 
[16:05:57.265]                           invokeRestart("muffleWarning")
[16:05:57.265]                       }
[16:05:57.265]                       else if (inherits(cond, "condition")) {
[16:05:57.265]                         if (!is.null(pattern)) {
[16:05:57.265]                           computeRestarts <- base::computeRestarts
[16:05:57.265]                           grepl <- base::grepl
[16:05:57.265]                           restarts <- computeRestarts(cond)
[16:05:57.265]                           for (restart in restarts) {
[16:05:57.265]                             name <- restart$name
[16:05:57.265]                             if (is.null(name)) 
[16:05:57.265]                               next
[16:05:57.265]                             if (!grepl(pattern, name)) 
[16:05:57.265]                               next
[16:05:57.265]                             invokeRestart(restart)
[16:05:57.265]                             muffled <- TRUE
[16:05:57.265]                             break
[16:05:57.265]                           }
[16:05:57.265]                         }
[16:05:57.265]                       }
[16:05:57.265]                       invisible(muffled)
[16:05:57.265]                     }
[16:05:57.265]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.265]                   }
[16:05:57.265]                 }
[16:05:57.265]             }
[16:05:57.265]         }))
[16:05:57.265]     }, error = function(ex) {
[16:05:57.265]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.265]                 ...future.rng), started = ...future.startTime, 
[16:05:57.265]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.265]             version = "1.8"), class = "FutureResult")
[16:05:57.265]     }, finally = {
[16:05:57.265]         if (!identical(...future.workdir, getwd())) 
[16:05:57.265]             setwd(...future.workdir)
[16:05:57.265]         {
[16:05:57.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.265]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.265]             }
[16:05:57.265]             base::options(...future.oldOptions)
[16:05:57.265]             if (.Platform$OS.type == "windows") {
[16:05:57.265]                 old_names <- names(...future.oldEnvVars)
[16:05:57.265]                 envs <- base::Sys.getenv()
[16:05:57.265]                 names <- names(envs)
[16:05:57.265]                 common <- intersect(names, old_names)
[16:05:57.265]                 added <- setdiff(names, old_names)
[16:05:57.265]                 removed <- setdiff(old_names, names)
[16:05:57.265]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.265]                   envs[common]]
[16:05:57.265]                 NAMES <- toupper(changed)
[16:05:57.265]                 args <- list()
[16:05:57.265]                 for (kk in seq_along(NAMES)) {
[16:05:57.265]                   name <- changed[[kk]]
[16:05:57.265]                   NAME <- NAMES[[kk]]
[16:05:57.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.265]                     next
[16:05:57.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.265]                 }
[16:05:57.265]                 NAMES <- toupper(added)
[16:05:57.265]                 for (kk in seq_along(NAMES)) {
[16:05:57.265]                   name <- added[[kk]]
[16:05:57.265]                   NAME <- NAMES[[kk]]
[16:05:57.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.265]                     next
[16:05:57.265]                   args[[name]] <- ""
[16:05:57.265]                 }
[16:05:57.265]                 NAMES <- toupper(removed)
[16:05:57.265]                 for (kk in seq_along(NAMES)) {
[16:05:57.265]                   name <- removed[[kk]]
[16:05:57.265]                   NAME <- NAMES[[kk]]
[16:05:57.265]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.265]                     next
[16:05:57.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.265]                 }
[16:05:57.265]                 if (length(args) > 0) 
[16:05:57.265]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.265]             }
[16:05:57.265]             else {
[16:05:57.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.265]             }
[16:05:57.265]             {
[16:05:57.265]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.265]                   0L) {
[16:05:57.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.265]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.265]                   base::options(opts)
[16:05:57.265]                 }
[16:05:57.265]                 {
[16:05:57.265]                   {
[16:05:57.265]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.265]                     NULL
[16:05:57.265]                   }
[16:05:57.265]                   options(future.plan = NULL)
[16:05:57.265]                   if (is.na(NA_character_)) 
[16:05:57.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.265]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.265]                     envir = parent.frame()) 
[16:05:57.265]                   {
[16:05:57.265]                     default_workers <- missing(workers)
[16:05:57.265]                     if (is.function(workers)) 
[16:05:57.265]                       workers <- workers()
[16:05:57.265]                     workers <- structure(as.integer(workers), 
[16:05:57.265]                       class = class(workers))
[16:05:57.265]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.265]                       1L)
[16:05:57.265]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.265]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.265]                       if (default_workers) 
[16:05:57.265]                         supportsMulticore(warn = TRUE)
[16:05:57.265]                       return(sequential(..., envir = envir))
[16:05:57.265]                     }
[16:05:57.265]                     oopts <- options(mc.cores = workers)
[16:05:57.265]                     on.exit(options(oopts))
[16:05:57.265]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.265]                       envir = envir)
[16:05:57.265]                     if (!future$lazy) 
[16:05:57.265]                       future <- run(future)
[16:05:57.265]                     invisible(future)
[16:05:57.265]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.265]                 }
[16:05:57.265]             }
[16:05:57.265]         }
[16:05:57.265]     })
[16:05:57.265]     if (TRUE) {
[16:05:57.265]         base::sink(type = "output", split = FALSE)
[16:05:57.265]         if (TRUE) {
[16:05:57.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.265]         }
[16:05:57.265]         else {
[16:05:57.265]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.265]         }
[16:05:57.265]         base::close(...future.stdout)
[16:05:57.265]         ...future.stdout <- NULL
[16:05:57.265]     }
[16:05:57.265]     ...future.result$conditions <- ...future.conditions
[16:05:57.265]     ...future.result$finished <- base::Sys.time()
[16:05:57.265]     ...future.result
[16:05:57.265] }
[16:05:57.267] requestCore(): workers = 2
[16:05:57.268] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.278] result() for MulticoreFuture ...
[16:05:57.279] result() for MulticoreFuture ...
[16:05:57.279] result() for MulticoreFuture ... done
[16:05:57.280] result() for MulticoreFuture ... done
[16:05:57.280] result() for MulticoreFuture ...
[16:05:57.280] result() for MulticoreFuture ... done
[16:05:57.282] MulticoreFuture started
[16:05:57.283] - Launch lazy future ... done
[16:05:57.283] run() for ‘MulticoreFuture’ ... done
[16:05:57.283] plan(): Setting new future strategy stack:
[16:05:57.284] getGlobalsAndPackages() ...
[16:05:57.285] Searching for globals...
[16:05:57.284] List of future strategies:
[16:05:57.284] 1. sequential:
[16:05:57.284]    - args: function (..., envir = parent.frame())
[16:05:57.284]    - tweaked: FALSE
[16:05:57.284]    - call: NULL
[16:05:57.285] plan(): nbrOfWorkers() = 1
[16:05:57.286] - globals found: [1] ‘{’
[16:05:57.287] Searching for globals ... DONE
[16:05:57.287] Resolving globals: FALSE
[16:05:57.288] plan(): Setting new future strategy stack:
[16:05:57.288] 
[16:05:57.288] 
[16:05:57.288] getGlobalsAndPackages() ... DONE
[16:05:57.288] List of future strategies:
[16:05:57.288] 1. multicore:
[16:05:57.288]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.288]    - tweaked: FALSE
[16:05:57.288]    - call: plan(strategy)
[16:05:57.289] run() for ‘Future’ ...
[16:05:57.289] - state: ‘created’
[16:05:57.289] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.295] plan(): nbrOfWorkers() = 2
[16:05:57.295] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.295] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.296]   - Field: ‘label’
[16:05:57.296]   - Field: ‘local’
[16:05:57.296]   - Field: ‘owner’
[16:05:57.296]   - Field: ‘envir’
[16:05:57.296]   - Field: ‘workers’
[16:05:57.296]   - Field: ‘packages’
[16:05:57.296]   - Field: ‘gc’
[16:05:57.297]   - Field: ‘job’
[16:05:57.297]   - Field: ‘conditions’
[16:05:57.297]   - Field: ‘expr’
[16:05:57.297]   - Field: ‘uuid’
[16:05:57.297]   - Field: ‘seed’
[16:05:57.297]   - Field: ‘version’
[16:05:57.297]   - Field: ‘result’
[16:05:57.298]   - Field: ‘asynchronous’
[16:05:57.298]   - Field: ‘calls’
[16:05:57.298]   - Field: ‘globals’
[16:05:57.298]   - Field: ‘stdout’
[16:05:57.298]   - Field: ‘earlySignal’
[16:05:57.298]   - Field: ‘lazy’
[16:05:57.298]   - Field: ‘state’
[16:05:57.299] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.299] - Launch lazy future ...
[16:05:57.299] Packages needed by the future expression (n = 0): <none>
[16:05:57.299] Packages needed by future strategies (n = 0): <none>
[16:05:57.300] {
[16:05:57.300]     {
[16:05:57.300]         {
[16:05:57.300]             ...future.startTime <- base::Sys.time()
[16:05:57.300]             {
[16:05:57.300]                 {
[16:05:57.300]                   {
[16:05:57.300]                     {
[16:05:57.300]                       base::local({
[16:05:57.300]                         has_future <- base::requireNamespace("future", 
[16:05:57.300]                           quietly = TRUE)
[16:05:57.300]                         if (has_future) {
[16:05:57.300]                           ns <- base::getNamespace("future")
[16:05:57.300]                           version <- ns[[".package"]][["version"]]
[16:05:57.300]                           if (is.null(version)) 
[16:05:57.300]                             version <- utils::packageVersion("future")
[16:05:57.300]                         }
[16:05:57.300]                         else {
[16:05:57.300]                           version <- NULL
[16:05:57.300]                         }
[16:05:57.300]                         if (!has_future || version < "1.8.0") {
[16:05:57.300]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.300]                             "", base::R.version$version.string), 
[16:05:57.300]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.300]                               "release", "version")], collapse = " "), 
[16:05:57.300]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.300]                             info)
[16:05:57.300]                           info <- base::paste(info, collapse = "; ")
[16:05:57.300]                           if (!has_future) {
[16:05:57.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.300]                               info)
[16:05:57.300]                           }
[16:05:57.300]                           else {
[16:05:57.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.300]                               info, version)
[16:05:57.300]                           }
[16:05:57.300]                           base::stop(msg)
[16:05:57.300]                         }
[16:05:57.300]                       })
[16:05:57.300]                     }
[16:05:57.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.300]                     base::options(mc.cores = 1L)
[16:05:57.300]                   }
[16:05:57.300]                   options(future.plan = NULL)
[16:05:57.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.300]                 }
[16:05:57.300]                 ...future.workdir <- getwd()
[16:05:57.300]             }
[16:05:57.300]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.300]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.300]         }
[16:05:57.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.300]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.300]             base::names(...future.oldOptions))
[16:05:57.300]     }
[16:05:57.300]     if (FALSE) {
[16:05:57.300]     }
[16:05:57.300]     else {
[16:05:57.300]         if (TRUE) {
[16:05:57.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.300]                 open = "w")
[16:05:57.300]         }
[16:05:57.300]         else {
[16:05:57.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.300]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.300]         }
[16:05:57.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.300]             base::sink(type = "output", split = FALSE)
[16:05:57.300]             base::close(...future.stdout)
[16:05:57.300]         }, add = TRUE)
[16:05:57.300]     }
[16:05:57.300]     ...future.frame <- base::sys.nframe()
[16:05:57.300]     ...future.conditions <- base::list()
[16:05:57.300]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.300]     if (FALSE) {
[16:05:57.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.300]     }
[16:05:57.300]     ...future.result <- base::tryCatch({
[16:05:57.300]         base::withCallingHandlers({
[16:05:57.300]             ...future.value <- base::withVisible(base::local({
[16:05:57.300]                 withCallingHandlers({
[16:05:57.300]                   {
[16:05:57.300]                     2
[16:05:57.300]                   }
[16:05:57.300]                 }, immediateCondition = function(cond) {
[16:05:57.300]                   save_rds <- function (object, pathname, ...) 
[16:05:57.300]                   {
[16:05:57.300]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.300]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.300]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.300]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.300]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.300]                         fi_tmp[["mtime"]])
[16:05:57.300]                     }
[16:05:57.300]                     tryCatch({
[16:05:57.300]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.300]                     }, error = function(ex) {
[16:05:57.300]                       msg <- conditionMessage(ex)
[16:05:57.300]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.300]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.300]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.300]                         fi_tmp[["mtime"]], msg)
[16:05:57.300]                       ex$message <- msg
[16:05:57.300]                       stop(ex)
[16:05:57.300]                     })
[16:05:57.300]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.300]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.300]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.300]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.300]                       fi <- file.info(pathname)
[16:05:57.300]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.300]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.300]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.300]                         fi[["size"]], fi[["mtime"]])
[16:05:57.300]                       stop(msg)
[16:05:57.300]                     }
[16:05:57.300]                     invisible(pathname)
[16:05:57.300]                   }
[16:05:57.300]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.300]                     rootPath = tempdir()) 
[16:05:57.300]                   {
[16:05:57.300]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.300]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.300]                       tmpdir = path, fileext = ".rds")
[16:05:57.300]                     save_rds(obj, file)
[16:05:57.300]                   }
[16:05:57.300]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.300]                   {
[16:05:57.300]                     inherits <- base::inherits
[16:05:57.300]                     invokeRestart <- base::invokeRestart
[16:05:57.300]                     is.null <- base::is.null
[16:05:57.300]                     muffled <- FALSE
[16:05:57.300]                     if (inherits(cond, "message")) {
[16:05:57.300]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.300]                       if (muffled) 
[16:05:57.300]                         invokeRestart("muffleMessage")
[16:05:57.300]                     }
[16:05:57.300]                     else if (inherits(cond, "warning")) {
[16:05:57.300]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.300]                       if (muffled) 
[16:05:57.300]                         invokeRestart("muffleWarning")
[16:05:57.300]                     }
[16:05:57.300]                     else if (inherits(cond, "condition")) {
[16:05:57.300]                       if (!is.null(pattern)) {
[16:05:57.300]                         computeRestarts <- base::computeRestarts
[16:05:57.300]                         grepl <- base::grepl
[16:05:57.300]                         restarts <- computeRestarts(cond)
[16:05:57.300]                         for (restart in restarts) {
[16:05:57.300]                           name <- restart$name
[16:05:57.300]                           if (is.null(name)) 
[16:05:57.300]                             next
[16:05:57.300]                           if (!grepl(pattern, name)) 
[16:05:57.300]                             next
[16:05:57.300]                           invokeRestart(restart)
[16:05:57.300]                           muffled <- TRUE
[16:05:57.300]                           break
[16:05:57.300]                         }
[16:05:57.300]                       }
[16:05:57.300]                     }
[16:05:57.300]                     invisible(muffled)
[16:05:57.300]                   }
[16:05:57.300]                   muffleCondition(cond)
[16:05:57.300]                 })
[16:05:57.300]             }))
[16:05:57.300]             future::FutureResult(value = ...future.value$value, 
[16:05:57.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.300]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.300]                     ...future.globalenv.names))
[16:05:57.300]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.300]         }, condition = base::local({
[16:05:57.300]             c <- base::c
[16:05:57.300]             inherits <- base::inherits
[16:05:57.300]             invokeRestart <- base::invokeRestart
[16:05:57.300]             length <- base::length
[16:05:57.300]             list <- base::list
[16:05:57.300]             seq.int <- base::seq.int
[16:05:57.300]             signalCondition <- base::signalCondition
[16:05:57.300]             sys.calls <- base::sys.calls
[16:05:57.300]             `[[` <- base::`[[`
[16:05:57.300]             `+` <- base::`+`
[16:05:57.300]             `<<-` <- base::`<<-`
[16:05:57.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.300]                   3L)]
[16:05:57.300]             }
[16:05:57.300]             function(cond) {
[16:05:57.300]                 is_error <- inherits(cond, "error")
[16:05:57.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.300]                   NULL)
[16:05:57.300]                 if (is_error) {
[16:05:57.300]                   sessionInformation <- function() {
[16:05:57.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.300]                       search = base::search(), system = base::Sys.info())
[16:05:57.300]                   }
[16:05:57.300]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.300]                     cond$call), session = sessionInformation(), 
[16:05:57.300]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.300]                   signalCondition(cond)
[16:05:57.300]                 }
[16:05:57.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.300]                 "immediateCondition"))) {
[16:05:57.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.300]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.300]                   if (TRUE && !signal) {
[16:05:57.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.300]                     {
[16:05:57.300]                       inherits <- base::inherits
[16:05:57.300]                       invokeRestart <- base::invokeRestart
[16:05:57.300]                       is.null <- base::is.null
[16:05:57.300]                       muffled <- FALSE
[16:05:57.300]                       if (inherits(cond, "message")) {
[16:05:57.300]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.300]                         if (muffled) 
[16:05:57.300]                           invokeRestart("muffleMessage")
[16:05:57.300]                       }
[16:05:57.300]                       else if (inherits(cond, "warning")) {
[16:05:57.300]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.300]                         if (muffled) 
[16:05:57.300]                           invokeRestart("muffleWarning")
[16:05:57.300]                       }
[16:05:57.300]                       else if (inherits(cond, "condition")) {
[16:05:57.300]                         if (!is.null(pattern)) {
[16:05:57.300]                           computeRestarts <- base::computeRestarts
[16:05:57.300]                           grepl <- base::grepl
[16:05:57.300]                           restarts <- computeRestarts(cond)
[16:05:57.300]                           for (restart in restarts) {
[16:05:57.300]                             name <- restart$name
[16:05:57.300]                             if (is.null(name)) 
[16:05:57.300]                               next
[16:05:57.300]                             if (!grepl(pattern, name)) 
[16:05:57.300]                               next
[16:05:57.300]                             invokeRestart(restart)
[16:05:57.300]                             muffled <- TRUE
[16:05:57.300]                             break
[16:05:57.300]                           }
[16:05:57.300]                         }
[16:05:57.300]                       }
[16:05:57.300]                       invisible(muffled)
[16:05:57.300]                     }
[16:05:57.300]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.300]                   }
[16:05:57.300]                 }
[16:05:57.300]                 else {
[16:05:57.300]                   if (TRUE) {
[16:05:57.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.300]                     {
[16:05:57.300]                       inherits <- base::inherits
[16:05:57.300]                       invokeRestart <- base::invokeRestart
[16:05:57.300]                       is.null <- base::is.null
[16:05:57.300]                       muffled <- FALSE
[16:05:57.300]                       if (inherits(cond, "message")) {
[16:05:57.300]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.300]                         if (muffled) 
[16:05:57.300]                           invokeRestart("muffleMessage")
[16:05:57.300]                       }
[16:05:57.300]                       else if (inherits(cond, "warning")) {
[16:05:57.300]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.300]                         if (muffled) 
[16:05:57.300]                           invokeRestart("muffleWarning")
[16:05:57.300]                       }
[16:05:57.300]                       else if (inherits(cond, "condition")) {
[16:05:57.300]                         if (!is.null(pattern)) {
[16:05:57.300]                           computeRestarts <- base::computeRestarts
[16:05:57.300]                           grepl <- base::grepl
[16:05:57.300]                           restarts <- computeRestarts(cond)
[16:05:57.300]                           for (restart in restarts) {
[16:05:57.300]                             name <- restart$name
[16:05:57.300]                             if (is.null(name)) 
[16:05:57.300]                               next
[16:05:57.300]                             if (!grepl(pattern, name)) 
[16:05:57.300]                               next
[16:05:57.300]                             invokeRestart(restart)
[16:05:57.300]                             muffled <- TRUE
[16:05:57.300]                             break
[16:05:57.300]                           }
[16:05:57.300]                         }
[16:05:57.300]                       }
[16:05:57.300]                       invisible(muffled)
[16:05:57.300]                     }
[16:05:57.300]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.300]                   }
[16:05:57.300]                 }
[16:05:57.300]             }
[16:05:57.300]         }))
[16:05:57.300]     }, error = function(ex) {
[16:05:57.300]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.300]                 ...future.rng), started = ...future.startTime, 
[16:05:57.300]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.300]             version = "1.8"), class = "FutureResult")
[16:05:57.300]     }, finally = {
[16:05:57.300]         if (!identical(...future.workdir, getwd())) 
[16:05:57.300]             setwd(...future.workdir)
[16:05:57.300]         {
[16:05:57.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.300]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.300]             }
[16:05:57.300]             base::options(...future.oldOptions)
[16:05:57.300]             if (.Platform$OS.type == "windows") {
[16:05:57.300]                 old_names <- names(...future.oldEnvVars)
[16:05:57.300]                 envs <- base::Sys.getenv()
[16:05:57.300]                 names <- names(envs)
[16:05:57.300]                 common <- intersect(names, old_names)
[16:05:57.300]                 added <- setdiff(names, old_names)
[16:05:57.300]                 removed <- setdiff(old_names, names)
[16:05:57.300]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.300]                   envs[common]]
[16:05:57.300]                 NAMES <- toupper(changed)
[16:05:57.300]                 args <- list()
[16:05:57.300]                 for (kk in seq_along(NAMES)) {
[16:05:57.300]                   name <- changed[[kk]]
[16:05:57.300]                   NAME <- NAMES[[kk]]
[16:05:57.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.300]                     next
[16:05:57.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.300]                 }
[16:05:57.300]                 NAMES <- toupper(added)
[16:05:57.300]                 for (kk in seq_along(NAMES)) {
[16:05:57.300]                   name <- added[[kk]]
[16:05:57.300]                   NAME <- NAMES[[kk]]
[16:05:57.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.300]                     next
[16:05:57.300]                   args[[name]] <- ""
[16:05:57.300]                 }
[16:05:57.300]                 NAMES <- toupper(removed)
[16:05:57.300]                 for (kk in seq_along(NAMES)) {
[16:05:57.300]                   name <- removed[[kk]]
[16:05:57.300]                   NAME <- NAMES[[kk]]
[16:05:57.300]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.300]                     next
[16:05:57.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.300]                 }
[16:05:57.300]                 if (length(args) > 0) 
[16:05:57.300]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.300]             }
[16:05:57.300]             else {
[16:05:57.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.300]             }
[16:05:57.300]             {
[16:05:57.300]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.300]                   0L) {
[16:05:57.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.300]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.300]                   base::options(opts)
[16:05:57.300]                 }
[16:05:57.300]                 {
[16:05:57.300]                   {
[16:05:57.300]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.300]                     NULL
[16:05:57.300]                   }
[16:05:57.300]                   options(future.plan = NULL)
[16:05:57.300]                   if (is.na(NA_character_)) 
[16:05:57.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.300]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.300]                     envir = parent.frame()) 
[16:05:57.300]                   {
[16:05:57.300]                     default_workers <- missing(workers)
[16:05:57.300]                     if (is.function(workers)) 
[16:05:57.300]                       workers <- workers()
[16:05:57.300]                     workers <- structure(as.integer(workers), 
[16:05:57.300]                       class = class(workers))
[16:05:57.300]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.300]                       1L)
[16:05:57.300]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.300]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.300]                       if (default_workers) 
[16:05:57.300]                         supportsMulticore(warn = TRUE)
[16:05:57.300]                       return(sequential(..., envir = envir))
[16:05:57.300]                     }
[16:05:57.300]                     oopts <- options(mc.cores = workers)
[16:05:57.300]                     on.exit(options(oopts))
[16:05:57.300]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.300]                       envir = envir)
[16:05:57.300]                     if (!future$lazy) 
[16:05:57.300]                       future <- run(future)
[16:05:57.300]                     invisible(future)
[16:05:57.300]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.300]                 }
[16:05:57.300]             }
[16:05:57.300]         }
[16:05:57.300]     })
[16:05:57.300]     if (TRUE) {
[16:05:57.300]         base::sink(type = "output", split = FALSE)
[16:05:57.300]         if (TRUE) {
[16:05:57.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.300]         }
[16:05:57.300]         else {
[16:05:57.300]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.300]         }
[16:05:57.300]         base::close(...future.stdout)
[16:05:57.300]         ...future.stdout <- NULL
[16:05:57.300]     }
[16:05:57.300]     ...future.result$conditions <- ...future.conditions
[16:05:57.300]     ...future.result$finished <- base::Sys.time()
[16:05:57.300]     ...future.result
[16:05:57.300] }
[16:05:57.304] requestCore(): workers = 2
[16:05:57.304] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.315] result() for MulticoreFuture ...
[16:05:57.316] result() for MulticoreFuture ...
[16:05:57.316] result() for MulticoreFuture ... done
[16:05:57.316] result() for MulticoreFuture ... done
[16:05:57.316] result() for MulticoreFuture ...
[16:05:57.316] result() for MulticoreFuture ... done
[16:05:57.318] MulticoreFuture started
[16:05:57.319] - Launch lazy future ... done
[16:05:57.319] run() for ‘MulticoreFuture’ ... done
[16:05:57.320] plan(): Setting new future strategy stack:
[16:05:57.320] List of future strategies:
[16:05:57.320] 1. sequential:
[16:05:57.320]    - args: function (..., envir = parent.frame())
[16:05:57.320]    - tweaked: FALSE
[16:05:57.320]    - call: NULL
[16:05:57.321] resolve() on list environment ...
[16:05:57.321]  recursive: 0
[16:05:57.321] plan(): nbrOfWorkers() = 1
[16:05:57.322]  length: 3
[16:05:57.323]  elements: ‘a’, ‘b’, ‘c’
[16:05:57.323] Future #1
[16:05:57.324]  length: 2 (resolved future 1)
[16:05:57.324] plan(): Setting new future strategy stack:
[16:05:57.324] List of future strategies:
[16:05:57.324] 1. multicore:
[16:05:57.324]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.324]    - tweaked: FALSE
[16:05:57.324]    - call: plan(strategy)
[16:05:57.329] plan(): nbrOfWorkers() = 2
[16:05:57.330] Future #2
[16:05:57.330]  length: 1 (resolved future 2)
[16:05:57.330]  length: 0 (resolved future 3)
[16:05:57.330] resolve() on list environment ... DONE
[16:05:57.331] getGlobalsAndPackages() ...
[16:05:57.332] Searching for globals...
[16:05:57.333] - globals found: [1] ‘{’
[16:05:57.333] Searching for globals ... DONE
[16:05:57.333] Resolving globals: FALSE
[16:05:57.334] 
[16:05:57.334] 
[16:05:57.334] getGlobalsAndPackages() ... DONE
[16:05:57.339] run() for ‘Future’ ...
[16:05:57.339] - state: ‘created’
[16:05:57.340] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.346] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.346]   - Field: ‘label’
[16:05:57.346]   - Field: ‘local’
[16:05:57.347]   - Field: ‘owner’
[16:05:57.347]   - Field: ‘envir’
[16:05:57.347]   - Field: ‘workers’
[16:05:57.347]   - Field: ‘packages’
[16:05:57.347]   - Field: ‘gc’
[16:05:57.347]   - Field: ‘job’
[16:05:57.348]   - Field: ‘conditions’
[16:05:57.348]   - Field: ‘expr’
[16:05:57.348]   - Field: ‘uuid’
[16:05:57.348]   - Field: ‘seed’
[16:05:57.348]   - Field: ‘version’
[16:05:57.348]   - Field: ‘result’
[16:05:57.349]   - Field: ‘asynchronous’
[16:05:57.349]   - Field: ‘calls’
[16:05:57.349]   - Field: ‘globals’
[16:05:57.349]   - Field: ‘stdout’
[16:05:57.349]   - Field: ‘earlySignal’
[16:05:57.349]   - Field: ‘lazy’
[16:05:57.349]   - Field: ‘state’
[16:05:57.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.350] - Launch lazy future ...
[16:05:57.350] Packages needed by the future expression (n = 0): <none>
[16:05:57.351] Packages needed by future strategies (n = 0): <none>
[16:05:57.352] {
[16:05:57.352]     {
[16:05:57.352]         {
[16:05:57.352]             ...future.startTime <- base::Sys.time()
[16:05:57.352]             {
[16:05:57.352]                 {
[16:05:57.352]                   {
[16:05:57.352]                     {
[16:05:57.352]                       base::local({
[16:05:57.352]                         has_future <- base::requireNamespace("future", 
[16:05:57.352]                           quietly = TRUE)
[16:05:57.352]                         if (has_future) {
[16:05:57.352]                           ns <- base::getNamespace("future")
[16:05:57.352]                           version <- ns[[".package"]][["version"]]
[16:05:57.352]                           if (is.null(version)) 
[16:05:57.352]                             version <- utils::packageVersion("future")
[16:05:57.352]                         }
[16:05:57.352]                         else {
[16:05:57.352]                           version <- NULL
[16:05:57.352]                         }
[16:05:57.352]                         if (!has_future || version < "1.8.0") {
[16:05:57.352]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.352]                             "", base::R.version$version.string), 
[16:05:57.352]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.352]                               "release", "version")], collapse = " "), 
[16:05:57.352]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.352]                             info)
[16:05:57.352]                           info <- base::paste(info, collapse = "; ")
[16:05:57.352]                           if (!has_future) {
[16:05:57.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.352]                               info)
[16:05:57.352]                           }
[16:05:57.352]                           else {
[16:05:57.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.352]                               info, version)
[16:05:57.352]                           }
[16:05:57.352]                           base::stop(msg)
[16:05:57.352]                         }
[16:05:57.352]                       })
[16:05:57.352]                     }
[16:05:57.352]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.352]                     base::options(mc.cores = 1L)
[16:05:57.352]                   }
[16:05:57.352]                   options(future.plan = NULL)
[16:05:57.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.352]                 }
[16:05:57.352]                 ...future.workdir <- getwd()
[16:05:57.352]             }
[16:05:57.352]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.352]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.352]         }
[16:05:57.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.352]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.352]             base::names(...future.oldOptions))
[16:05:57.352]     }
[16:05:57.352]     if (FALSE) {
[16:05:57.352]     }
[16:05:57.352]     else {
[16:05:57.352]         if (TRUE) {
[16:05:57.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.352]                 open = "w")
[16:05:57.352]         }
[16:05:57.352]         else {
[16:05:57.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.352]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.352]         }
[16:05:57.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.352]             base::sink(type = "output", split = FALSE)
[16:05:57.352]             base::close(...future.stdout)
[16:05:57.352]         }, add = TRUE)
[16:05:57.352]     }
[16:05:57.352]     ...future.frame <- base::sys.nframe()
[16:05:57.352]     ...future.conditions <- base::list()
[16:05:57.352]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.352]     if (FALSE) {
[16:05:57.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.352]     }
[16:05:57.352]     ...future.result <- base::tryCatch({
[16:05:57.352]         base::withCallingHandlers({
[16:05:57.352]             ...future.value <- base::withVisible(base::local({
[16:05:57.352]                 withCallingHandlers({
[16:05:57.352]                   {
[16:05:57.352]                     1
[16:05:57.352]                   }
[16:05:57.352]                 }, immediateCondition = function(cond) {
[16:05:57.352]                   save_rds <- function (object, pathname, ...) 
[16:05:57.352]                   {
[16:05:57.352]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.352]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.352]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.352]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.352]                         fi_tmp[["mtime"]])
[16:05:57.352]                     }
[16:05:57.352]                     tryCatch({
[16:05:57.352]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.352]                     }, error = function(ex) {
[16:05:57.352]                       msg <- conditionMessage(ex)
[16:05:57.352]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.352]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.352]                         fi_tmp[["mtime"]], msg)
[16:05:57.352]                       ex$message <- msg
[16:05:57.352]                       stop(ex)
[16:05:57.352]                     })
[16:05:57.352]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.352]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.352]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.352]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.352]                       fi <- file.info(pathname)
[16:05:57.352]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.352]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.352]                         fi[["size"]], fi[["mtime"]])
[16:05:57.352]                       stop(msg)
[16:05:57.352]                     }
[16:05:57.352]                     invisible(pathname)
[16:05:57.352]                   }
[16:05:57.352]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.352]                     rootPath = tempdir()) 
[16:05:57.352]                   {
[16:05:57.352]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.352]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.352]                       tmpdir = path, fileext = ".rds")
[16:05:57.352]                     save_rds(obj, file)
[16:05:57.352]                   }
[16:05:57.352]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.352]                   {
[16:05:57.352]                     inherits <- base::inherits
[16:05:57.352]                     invokeRestart <- base::invokeRestart
[16:05:57.352]                     is.null <- base::is.null
[16:05:57.352]                     muffled <- FALSE
[16:05:57.352]                     if (inherits(cond, "message")) {
[16:05:57.352]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.352]                       if (muffled) 
[16:05:57.352]                         invokeRestart("muffleMessage")
[16:05:57.352]                     }
[16:05:57.352]                     else if (inherits(cond, "warning")) {
[16:05:57.352]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.352]                       if (muffled) 
[16:05:57.352]                         invokeRestart("muffleWarning")
[16:05:57.352]                     }
[16:05:57.352]                     else if (inherits(cond, "condition")) {
[16:05:57.352]                       if (!is.null(pattern)) {
[16:05:57.352]                         computeRestarts <- base::computeRestarts
[16:05:57.352]                         grepl <- base::grepl
[16:05:57.352]                         restarts <- computeRestarts(cond)
[16:05:57.352]                         for (restart in restarts) {
[16:05:57.352]                           name <- restart$name
[16:05:57.352]                           if (is.null(name)) 
[16:05:57.352]                             next
[16:05:57.352]                           if (!grepl(pattern, name)) 
[16:05:57.352]                             next
[16:05:57.352]                           invokeRestart(restart)
[16:05:57.352]                           muffled <- TRUE
[16:05:57.352]                           break
[16:05:57.352]                         }
[16:05:57.352]                       }
[16:05:57.352]                     }
[16:05:57.352]                     invisible(muffled)
[16:05:57.352]                   }
[16:05:57.352]                   muffleCondition(cond)
[16:05:57.352]                 })
[16:05:57.352]             }))
[16:05:57.352]             future::FutureResult(value = ...future.value$value, 
[16:05:57.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.352]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.352]                     ...future.globalenv.names))
[16:05:57.352]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.352]         }, condition = base::local({
[16:05:57.352]             c <- base::c
[16:05:57.352]             inherits <- base::inherits
[16:05:57.352]             invokeRestart <- base::invokeRestart
[16:05:57.352]             length <- base::length
[16:05:57.352]             list <- base::list
[16:05:57.352]             seq.int <- base::seq.int
[16:05:57.352]             signalCondition <- base::signalCondition
[16:05:57.352]             sys.calls <- base::sys.calls
[16:05:57.352]             `[[` <- base::`[[`
[16:05:57.352]             `+` <- base::`+`
[16:05:57.352]             `<<-` <- base::`<<-`
[16:05:57.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.352]                   3L)]
[16:05:57.352]             }
[16:05:57.352]             function(cond) {
[16:05:57.352]                 is_error <- inherits(cond, "error")
[16:05:57.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.352]                   NULL)
[16:05:57.352]                 if (is_error) {
[16:05:57.352]                   sessionInformation <- function() {
[16:05:57.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.352]                       search = base::search(), system = base::Sys.info())
[16:05:57.352]                   }
[16:05:57.352]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.352]                     cond$call), session = sessionInformation(), 
[16:05:57.352]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.352]                   signalCondition(cond)
[16:05:57.352]                 }
[16:05:57.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.352]                 "immediateCondition"))) {
[16:05:57.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.352]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.352]                   if (TRUE && !signal) {
[16:05:57.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.352]                     {
[16:05:57.352]                       inherits <- base::inherits
[16:05:57.352]                       invokeRestart <- base::invokeRestart
[16:05:57.352]                       is.null <- base::is.null
[16:05:57.352]                       muffled <- FALSE
[16:05:57.352]                       if (inherits(cond, "message")) {
[16:05:57.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.352]                         if (muffled) 
[16:05:57.352]                           invokeRestart("muffleMessage")
[16:05:57.352]                       }
[16:05:57.352]                       else if (inherits(cond, "warning")) {
[16:05:57.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.352]                         if (muffled) 
[16:05:57.352]                           invokeRestart("muffleWarning")
[16:05:57.352]                       }
[16:05:57.352]                       else if (inherits(cond, "condition")) {
[16:05:57.352]                         if (!is.null(pattern)) {
[16:05:57.352]                           computeRestarts <- base::computeRestarts
[16:05:57.352]                           grepl <- base::grepl
[16:05:57.352]                           restarts <- computeRestarts(cond)
[16:05:57.352]                           for (restart in restarts) {
[16:05:57.352]                             name <- restart$name
[16:05:57.352]                             if (is.null(name)) 
[16:05:57.352]                               next
[16:05:57.352]                             if (!grepl(pattern, name)) 
[16:05:57.352]                               next
[16:05:57.352]                             invokeRestart(restart)
[16:05:57.352]                             muffled <- TRUE
[16:05:57.352]                             break
[16:05:57.352]                           }
[16:05:57.352]                         }
[16:05:57.352]                       }
[16:05:57.352]                       invisible(muffled)
[16:05:57.352]                     }
[16:05:57.352]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.352]                   }
[16:05:57.352]                 }
[16:05:57.352]                 else {
[16:05:57.352]                   if (TRUE) {
[16:05:57.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.352]                     {
[16:05:57.352]                       inherits <- base::inherits
[16:05:57.352]                       invokeRestart <- base::invokeRestart
[16:05:57.352]                       is.null <- base::is.null
[16:05:57.352]                       muffled <- FALSE
[16:05:57.352]                       if (inherits(cond, "message")) {
[16:05:57.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.352]                         if (muffled) 
[16:05:57.352]                           invokeRestart("muffleMessage")
[16:05:57.352]                       }
[16:05:57.352]                       else if (inherits(cond, "warning")) {
[16:05:57.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.352]                         if (muffled) 
[16:05:57.352]                           invokeRestart("muffleWarning")
[16:05:57.352]                       }
[16:05:57.352]                       else if (inherits(cond, "condition")) {
[16:05:57.352]                         if (!is.null(pattern)) {
[16:05:57.352]                           computeRestarts <- base::computeRestarts
[16:05:57.352]                           grepl <- base::grepl
[16:05:57.352]                           restarts <- computeRestarts(cond)
[16:05:57.352]                           for (restart in restarts) {
[16:05:57.352]                             name <- restart$name
[16:05:57.352]                             if (is.null(name)) 
[16:05:57.352]                               next
[16:05:57.352]                             if (!grepl(pattern, name)) 
[16:05:57.352]                               next
[16:05:57.352]                             invokeRestart(restart)
[16:05:57.352]                             muffled <- TRUE
[16:05:57.352]                             break
[16:05:57.352]                           }
[16:05:57.352]                         }
[16:05:57.352]                       }
[16:05:57.352]                       invisible(muffled)
[16:05:57.352]                     }
[16:05:57.352]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.352]                   }
[16:05:57.352]                 }
[16:05:57.352]             }
[16:05:57.352]         }))
[16:05:57.352]     }, error = function(ex) {
[16:05:57.352]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.352]                 ...future.rng), started = ...future.startTime, 
[16:05:57.352]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.352]             version = "1.8"), class = "FutureResult")
[16:05:57.352]     }, finally = {
[16:05:57.352]         if (!identical(...future.workdir, getwd())) 
[16:05:57.352]             setwd(...future.workdir)
[16:05:57.352]         {
[16:05:57.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.352]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.352]             }
[16:05:57.352]             base::options(...future.oldOptions)
[16:05:57.352]             if (.Platform$OS.type == "windows") {
[16:05:57.352]                 old_names <- names(...future.oldEnvVars)
[16:05:57.352]                 envs <- base::Sys.getenv()
[16:05:57.352]                 names <- names(envs)
[16:05:57.352]                 common <- intersect(names, old_names)
[16:05:57.352]                 added <- setdiff(names, old_names)
[16:05:57.352]                 removed <- setdiff(old_names, names)
[16:05:57.352]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.352]                   envs[common]]
[16:05:57.352]                 NAMES <- toupper(changed)
[16:05:57.352]                 args <- list()
[16:05:57.352]                 for (kk in seq_along(NAMES)) {
[16:05:57.352]                   name <- changed[[kk]]
[16:05:57.352]                   NAME <- NAMES[[kk]]
[16:05:57.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.352]                     next
[16:05:57.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.352]                 }
[16:05:57.352]                 NAMES <- toupper(added)
[16:05:57.352]                 for (kk in seq_along(NAMES)) {
[16:05:57.352]                   name <- added[[kk]]
[16:05:57.352]                   NAME <- NAMES[[kk]]
[16:05:57.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.352]                     next
[16:05:57.352]                   args[[name]] <- ""
[16:05:57.352]                 }
[16:05:57.352]                 NAMES <- toupper(removed)
[16:05:57.352]                 for (kk in seq_along(NAMES)) {
[16:05:57.352]                   name <- removed[[kk]]
[16:05:57.352]                   NAME <- NAMES[[kk]]
[16:05:57.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.352]                     next
[16:05:57.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.352]                 }
[16:05:57.352]                 if (length(args) > 0) 
[16:05:57.352]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.352]             }
[16:05:57.352]             else {
[16:05:57.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.352]             }
[16:05:57.352]             {
[16:05:57.352]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.352]                   0L) {
[16:05:57.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.352]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.352]                   base::options(opts)
[16:05:57.352]                 }
[16:05:57.352]                 {
[16:05:57.352]                   {
[16:05:57.352]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.352]                     NULL
[16:05:57.352]                   }
[16:05:57.352]                   options(future.plan = NULL)
[16:05:57.352]                   if (is.na(NA_character_)) 
[16:05:57.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.352]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.352]                     envir = parent.frame()) 
[16:05:57.352]                   {
[16:05:57.352]                     default_workers <- missing(workers)
[16:05:57.352]                     if (is.function(workers)) 
[16:05:57.352]                       workers <- workers()
[16:05:57.352]                     workers <- structure(as.integer(workers), 
[16:05:57.352]                       class = class(workers))
[16:05:57.352]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.352]                       1L)
[16:05:57.352]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.352]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.352]                       if (default_workers) 
[16:05:57.352]                         supportsMulticore(warn = TRUE)
[16:05:57.352]                       return(sequential(..., envir = envir))
[16:05:57.352]                     }
[16:05:57.352]                     oopts <- options(mc.cores = workers)
[16:05:57.352]                     on.exit(options(oopts))
[16:05:57.352]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.352]                       envir = envir)
[16:05:57.352]                     if (!future$lazy) 
[16:05:57.352]                       future <- run(future)
[16:05:57.352]                     invisible(future)
[16:05:57.352]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.352]                 }
[16:05:57.352]             }
[16:05:57.352]         }
[16:05:57.352]     })
[16:05:57.352]     if (TRUE) {
[16:05:57.352]         base::sink(type = "output", split = FALSE)
[16:05:57.352]         if (TRUE) {
[16:05:57.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.352]         }
[16:05:57.352]         else {
[16:05:57.352]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.352]         }
[16:05:57.352]         base::close(...future.stdout)
[16:05:57.352]         ...future.stdout <- NULL
[16:05:57.352]     }
[16:05:57.352]     ...future.result$conditions <- ...future.conditions
[16:05:57.352]     ...future.result$finished <- base::Sys.time()
[16:05:57.352]     ...future.result
[16:05:57.352] }
[16:05:57.354] requestCore(): workers = 2
[16:05:57.355] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.365] result() for MulticoreFuture ...
[16:05:57.366] result() for MulticoreFuture ...
[16:05:57.366] result() for MulticoreFuture ... done
[16:05:57.367] result() for MulticoreFuture ... done
[16:05:57.367] result() for MulticoreFuture ...
[16:05:57.367] result() for MulticoreFuture ... done
[16:05:57.369] MulticoreFuture started
[16:05:57.370] - Launch lazy future ... done
[16:05:57.370] run() for ‘MulticoreFuture’ ... done
[16:05:57.371] plan(): Setting new future strategy stack:
[16:05:57.371] getGlobalsAndPackages() ...
[16:05:57.371] Searching for globals...
[16:05:57.371] List of future strategies:
[16:05:57.371] 1. sequential:
[16:05:57.371]    - args: function (..., envir = parent.frame())
[16:05:57.371]    - tweaked: FALSE
[16:05:57.371]    - call: NULL
[16:05:57.372] plan(): nbrOfWorkers() = 1
[16:05:57.374] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:05:57.374] Searching for globals ... DONE
[16:05:57.374] Resolving globals: FALSE
[16:05:57.374] plan(): Setting new future strategy stack:
[16:05:57.374] List of future strategies:
[16:05:57.374] 1. multicore:
[16:05:57.374]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.374]    - tweaked: FALSE
[16:05:57.374]    - call: plan(strategy)
[16:05:57.375] 
[16:05:57.375] 
[16:05:57.375] getGlobalsAndPackages() ... DONE
[16:05:57.375] run() for ‘Future’ ...
[16:05:57.375] - state: ‘created’
[16:05:57.376] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.379] plan(): nbrOfWorkers() = 2
[16:05:57.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.381]   - Field: ‘label’
[16:05:57.381]   - Field: ‘local’
[16:05:57.381]   - Field: ‘owner’
[16:05:57.381]   - Field: ‘envir’
[16:05:57.381]   - Field: ‘workers’
[16:05:57.382]   - Field: ‘packages’
[16:05:57.382]   - Field: ‘gc’
[16:05:57.382]   - Field: ‘job’
[16:05:57.382]   - Field: ‘conditions’
[16:05:57.382]   - Field: ‘expr’
[16:05:57.382]   - Field: ‘uuid’
[16:05:57.382]   - Field: ‘seed’
[16:05:57.383]   - Field: ‘version’
[16:05:57.383]   - Field: ‘result’
[16:05:57.383]   - Field: ‘asynchronous’
[16:05:57.383]   - Field: ‘calls’
[16:05:57.383]   - Field: ‘globals’
[16:05:57.383]   - Field: ‘stdout’
[16:05:57.383]   - Field: ‘earlySignal’
[16:05:57.384]   - Field: ‘lazy’
[16:05:57.384]   - Field: ‘state’
[16:05:57.384] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.384] - Launch lazy future ...
[16:05:57.384] Packages needed by the future expression (n = 0): <none>
[16:05:57.385] Packages needed by future strategies (n = 0): <none>
[16:05:57.385] {
[16:05:57.385]     {
[16:05:57.385]         {
[16:05:57.385]             ...future.startTime <- base::Sys.time()
[16:05:57.385]             {
[16:05:57.385]                 {
[16:05:57.385]                   {
[16:05:57.385]                     {
[16:05:57.385]                       base::local({
[16:05:57.385]                         has_future <- base::requireNamespace("future", 
[16:05:57.385]                           quietly = TRUE)
[16:05:57.385]                         if (has_future) {
[16:05:57.385]                           ns <- base::getNamespace("future")
[16:05:57.385]                           version <- ns[[".package"]][["version"]]
[16:05:57.385]                           if (is.null(version)) 
[16:05:57.385]                             version <- utils::packageVersion("future")
[16:05:57.385]                         }
[16:05:57.385]                         else {
[16:05:57.385]                           version <- NULL
[16:05:57.385]                         }
[16:05:57.385]                         if (!has_future || version < "1.8.0") {
[16:05:57.385]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.385]                             "", base::R.version$version.string), 
[16:05:57.385]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.385]                               "release", "version")], collapse = " "), 
[16:05:57.385]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.385]                             info)
[16:05:57.385]                           info <- base::paste(info, collapse = "; ")
[16:05:57.385]                           if (!has_future) {
[16:05:57.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.385]                               info)
[16:05:57.385]                           }
[16:05:57.385]                           else {
[16:05:57.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.385]                               info, version)
[16:05:57.385]                           }
[16:05:57.385]                           base::stop(msg)
[16:05:57.385]                         }
[16:05:57.385]                       })
[16:05:57.385]                     }
[16:05:57.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.385]                     base::options(mc.cores = 1L)
[16:05:57.385]                   }
[16:05:57.385]                   options(future.plan = NULL)
[16:05:57.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.385]                 }
[16:05:57.385]                 ...future.workdir <- getwd()
[16:05:57.385]             }
[16:05:57.385]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.385]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.385]         }
[16:05:57.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.385]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.385]             base::names(...future.oldOptions))
[16:05:57.385]     }
[16:05:57.385]     if (FALSE) {
[16:05:57.385]     }
[16:05:57.385]     else {
[16:05:57.385]         if (TRUE) {
[16:05:57.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.385]                 open = "w")
[16:05:57.385]         }
[16:05:57.385]         else {
[16:05:57.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.385]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.385]         }
[16:05:57.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.385]             base::sink(type = "output", split = FALSE)
[16:05:57.385]             base::close(...future.stdout)
[16:05:57.385]         }, add = TRUE)
[16:05:57.385]     }
[16:05:57.385]     ...future.frame <- base::sys.nframe()
[16:05:57.385]     ...future.conditions <- base::list()
[16:05:57.385]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.385]     if (FALSE) {
[16:05:57.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.385]     }
[16:05:57.385]     ...future.result <- base::tryCatch({
[16:05:57.385]         base::withCallingHandlers({
[16:05:57.385]             ...future.value <- base::withVisible(base::local({
[16:05:57.385]                 withCallingHandlers({
[16:05:57.385]                   {
[16:05:57.385]                     Sys.sleep(0.5)
[16:05:57.385]                     2
[16:05:57.385]                   }
[16:05:57.385]                 }, immediateCondition = function(cond) {
[16:05:57.385]                   save_rds <- function (object, pathname, ...) 
[16:05:57.385]                   {
[16:05:57.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.385]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.385]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.385]                         fi_tmp[["mtime"]])
[16:05:57.385]                     }
[16:05:57.385]                     tryCatch({
[16:05:57.385]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.385]                     }, error = function(ex) {
[16:05:57.385]                       msg <- conditionMessage(ex)
[16:05:57.385]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.385]                         fi_tmp[["mtime"]], msg)
[16:05:57.385]                       ex$message <- msg
[16:05:57.385]                       stop(ex)
[16:05:57.385]                     })
[16:05:57.385]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.385]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.385]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.385]                       fi <- file.info(pathname)
[16:05:57.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.385]                         fi[["size"]], fi[["mtime"]])
[16:05:57.385]                       stop(msg)
[16:05:57.385]                     }
[16:05:57.385]                     invisible(pathname)
[16:05:57.385]                   }
[16:05:57.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.385]                     rootPath = tempdir()) 
[16:05:57.385]                   {
[16:05:57.385]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.385]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.385]                       tmpdir = path, fileext = ".rds")
[16:05:57.385]                     save_rds(obj, file)
[16:05:57.385]                   }
[16:05:57.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.385]                   {
[16:05:57.385]                     inherits <- base::inherits
[16:05:57.385]                     invokeRestart <- base::invokeRestart
[16:05:57.385]                     is.null <- base::is.null
[16:05:57.385]                     muffled <- FALSE
[16:05:57.385]                     if (inherits(cond, "message")) {
[16:05:57.385]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.385]                       if (muffled) 
[16:05:57.385]                         invokeRestart("muffleMessage")
[16:05:57.385]                     }
[16:05:57.385]                     else if (inherits(cond, "warning")) {
[16:05:57.385]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.385]                       if (muffled) 
[16:05:57.385]                         invokeRestart("muffleWarning")
[16:05:57.385]                     }
[16:05:57.385]                     else if (inherits(cond, "condition")) {
[16:05:57.385]                       if (!is.null(pattern)) {
[16:05:57.385]                         computeRestarts <- base::computeRestarts
[16:05:57.385]                         grepl <- base::grepl
[16:05:57.385]                         restarts <- computeRestarts(cond)
[16:05:57.385]                         for (restart in restarts) {
[16:05:57.385]                           name <- restart$name
[16:05:57.385]                           if (is.null(name)) 
[16:05:57.385]                             next
[16:05:57.385]                           if (!grepl(pattern, name)) 
[16:05:57.385]                             next
[16:05:57.385]                           invokeRestart(restart)
[16:05:57.385]                           muffled <- TRUE
[16:05:57.385]                           break
[16:05:57.385]                         }
[16:05:57.385]                       }
[16:05:57.385]                     }
[16:05:57.385]                     invisible(muffled)
[16:05:57.385]                   }
[16:05:57.385]                   muffleCondition(cond)
[16:05:57.385]                 })
[16:05:57.385]             }))
[16:05:57.385]             future::FutureResult(value = ...future.value$value, 
[16:05:57.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.385]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.385]                     ...future.globalenv.names))
[16:05:57.385]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.385]         }, condition = base::local({
[16:05:57.385]             c <- base::c
[16:05:57.385]             inherits <- base::inherits
[16:05:57.385]             invokeRestart <- base::invokeRestart
[16:05:57.385]             length <- base::length
[16:05:57.385]             list <- base::list
[16:05:57.385]             seq.int <- base::seq.int
[16:05:57.385]             signalCondition <- base::signalCondition
[16:05:57.385]             sys.calls <- base::sys.calls
[16:05:57.385]             `[[` <- base::`[[`
[16:05:57.385]             `+` <- base::`+`
[16:05:57.385]             `<<-` <- base::`<<-`
[16:05:57.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.385]                   3L)]
[16:05:57.385]             }
[16:05:57.385]             function(cond) {
[16:05:57.385]                 is_error <- inherits(cond, "error")
[16:05:57.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.385]                   NULL)
[16:05:57.385]                 if (is_error) {
[16:05:57.385]                   sessionInformation <- function() {
[16:05:57.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.385]                       search = base::search(), system = base::Sys.info())
[16:05:57.385]                   }
[16:05:57.385]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.385]                     cond$call), session = sessionInformation(), 
[16:05:57.385]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.385]                   signalCondition(cond)
[16:05:57.385]                 }
[16:05:57.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.385]                 "immediateCondition"))) {
[16:05:57.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.385]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.385]                   if (TRUE && !signal) {
[16:05:57.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.385]                     {
[16:05:57.385]                       inherits <- base::inherits
[16:05:57.385]                       invokeRestart <- base::invokeRestart
[16:05:57.385]                       is.null <- base::is.null
[16:05:57.385]                       muffled <- FALSE
[16:05:57.385]                       if (inherits(cond, "message")) {
[16:05:57.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.385]                         if (muffled) 
[16:05:57.385]                           invokeRestart("muffleMessage")
[16:05:57.385]                       }
[16:05:57.385]                       else if (inherits(cond, "warning")) {
[16:05:57.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.385]                         if (muffled) 
[16:05:57.385]                           invokeRestart("muffleWarning")
[16:05:57.385]                       }
[16:05:57.385]                       else if (inherits(cond, "condition")) {
[16:05:57.385]                         if (!is.null(pattern)) {
[16:05:57.385]                           computeRestarts <- base::computeRestarts
[16:05:57.385]                           grepl <- base::grepl
[16:05:57.385]                           restarts <- computeRestarts(cond)
[16:05:57.385]                           for (restart in restarts) {
[16:05:57.385]                             name <- restart$name
[16:05:57.385]                             if (is.null(name)) 
[16:05:57.385]                               next
[16:05:57.385]                             if (!grepl(pattern, name)) 
[16:05:57.385]                               next
[16:05:57.385]                             invokeRestart(restart)
[16:05:57.385]                             muffled <- TRUE
[16:05:57.385]                             break
[16:05:57.385]                           }
[16:05:57.385]                         }
[16:05:57.385]                       }
[16:05:57.385]                       invisible(muffled)
[16:05:57.385]                     }
[16:05:57.385]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.385]                   }
[16:05:57.385]                 }
[16:05:57.385]                 else {
[16:05:57.385]                   if (TRUE) {
[16:05:57.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.385]                     {
[16:05:57.385]                       inherits <- base::inherits
[16:05:57.385]                       invokeRestart <- base::invokeRestart
[16:05:57.385]                       is.null <- base::is.null
[16:05:57.385]                       muffled <- FALSE
[16:05:57.385]                       if (inherits(cond, "message")) {
[16:05:57.385]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.385]                         if (muffled) 
[16:05:57.385]                           invokeRestart("muffleMessage")
[16:05:57.385]                       }
[16:05:57.385]                       else if (inherits(cond, "warning")) {
[16:05:57.385]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.385]                         if (muffled) 
[16:05:57.385]                           invokeRestart("muffleWarning")
[16:05:57.385]                       }
[16:05:57.385]                       else if (inherits(cond, "condition")) {
[16:05:57.385]                         if (!is.null(pattern)) {
[16:05:57.385]                           computeRestarts <- base::computeRestarts
[16:05:57.385]                           grepl <- base::grepl
[16:05:57.385]                           restarts <- computeRestarts(cond)
[16:05:57.385]                           for (restart in restarts) {
[16:05:57.385]                             name <- restart$name
[16:05:57.385]                             if (is.null(name)) 
[16:05:57.385]                               next
[16:05:57.385]                             if (!grepl(pattern, name)) 
[16:05:57.385]                               next
[16:05:57.385]                             invokeRestart(restart)
[16:05:57.385]                             muffled <- TRUE
[16:05:57.385]                             break
[16:05:57.385]                           }
[16:05:57.385]                         }
[16:05:57.385]                       }
[16:05:57.385]                       invisible(muffled)
[16:05:57.385]                     }
[16:05:57.385]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.385]                   }
[16:05:57.385]                 }
[16:05:57.385]             }
[16:05:57.385]         }))
[16:05:57.385]     }, error = function(ex) {
[16:05:57.385]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.385]                 ...future.rng), started = ...future.startTime, 
[16:05:57.385]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.385]             version = "1.8"), class = "FutureResult")
[16:05:57.385]     }, finally = {
[16:05:57.385]         if (!identical(...future.workdir, getwd())) 
[16:05:57.385]             setwd(...future.workdir)
[16:05:57.385]         {
[16:05:57.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.385]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.385]             }
[16:05:57.385]             base::options(...future.oldOptions)
[16:05:57.385]             if (.Platform$OS.type == "windows") {
[16:05:57.385]                 old_names <- names(...future.oldEnvVars)
[16:05:57.385]                 envs <- base::Sys.getenv()
[16:05:57.385]                 names <- names(envs)
[16:05:57.385]                 common <- intersect(names, old_names)
[16:05:57.385]                 added <- setdiff(names, old_names)
[16:05:57.385]                 removed <- setdiff(old_names, names)
[16:05:57.385]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.385]                   envs[common]]
[16:05:57.385]                 NAMES <- toupper(changed)
[16:05:57.385]                 args <- list()
[16:05:57.385]                 for (kk in seq_along(NAMES)) {
[16:05:57.385]                   name <- changed[[kk]]
[16:05:57.385]                   NAME <- NAMES[[kk]]
[16:05:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.385]                     next
[16:05:57.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.385]                 }
[16:05:57.385]                 NAMES <- toupper(added)
[16:05:57.385]                 for (kk in seq_along(NAMES)) {
[16:05:57.385]                   name <- added[[kk]]
[16:05:57.385]                   NAME <- NAMES[[kk]]
[16:05:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.385]                     next
[16:05:57.385]                   args[[name]] <- ""
[16:05:57.385]                 }
[16:05:57.385]                 NAMES <- toupper(removed)
[16:05:57.385]                 for (kk in seq_along(NAMES)) {
[16:05:57.385]                   name <- removed[[kk]]
[16:05:57.385]                   NAME <- NAMES[[kk]]
[16:05:57.385]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.385]                     next
[16:05:57.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.385]                 }
[16:05:57.385]                 if (length(args) > 0) 
[16:05:57.385]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.385]             }
[16:05:57.385]             else {
[16:05:57.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.385]             }
[16:05:57.385]             {
[16:05:57.385]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.385]                   0L) {
[16:05:57.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.385]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.385]                   base::options(opts)
[16:05:57.385]                 }
[16:05:57.385]                 {
[16:05:57.385]                   {
[16:05:57.385]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.385]                     NULL
[16:05:57.385]                   }
[16:05:57.385]                   options(future.plan = NULL)
[16:05:57.385]                   if (is.na(NA_character_)) 
[16:05:57.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.385]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.385]                     envir = parent.frame()) 
[16:05:57.385]                   {
[16:05:57.385]                     default_workers <- missing(workers)
[16:05:57.385]                     if (is.function(workers)) 
[16:05:57.385]                       workers <- workers()
[16:05:57.385]                     workers <- structure(as.integer(workers), 
[16:05:57.385]                       class = class(workers))
[16:05:57.385]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.385]                       1L)
[16:05:57.385]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.385]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.385]                       if (default_workers) 
[16:05:57.385]                         supportsMulticore(warn = TRUE)
[16:05:57.385]                       return(sequential(..., envir = envir))
[16:05:57.385]                     }
[16:05:57.385]                     oopts <- options(mc.cores = workers)
[16:05:57.385]                     on.exit(options(oopts))
[16:05:57.385]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.385]                       envir = envir)
[16:05:57.385]                     if (!future$lazy) 
[16:05:57.385]                       future <- run(future)
[16:05:57.385]                     invisible(future)
[16:05:57.385]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.385]                 }
[16:05:57.385]             }
[16:05:57.385]         }
[16:05:57.385]     })
[16:05:57.385]     if (TRUE) {
[16:05:57.385]         base::sink(type = "output", split = FALSE)
[16:05:57.385]         if (TRUE) {
[16:05:57.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.385]         }
[16:05:57.385]         else {
[16:05:57.385]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.385]         }
[16:05:57.385]         base::close(...future.stdout)
[16:05:57.385]         ...future.stdout <- NULL
[16:05:57.385]     }
[16:05:57.385]     ...future.result$conditions <- ...future.conditions
[16:05:57.385]     ...future.result$finished <- base::Sys.time()
[16:05:57.385]     ...future.result
[16:05:57.385] }
[16:05:57.389] requestCore(): workers = 2
[16:05:57.389] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.400] result() for MulticoreFuture ...
[16:05:57.401] result() for MulticoreFuture ...
[16:05:57.401] result() for MulticoreFuture ... done
[16:05:57.401] result() for MulticoreFuture ... done
[16:05:57.401] result() for MulticoreFuture ...
[16:05:57.402] result() for MulticoreFuture ... done
[16:05:57.404] MulticoreFuture started
[16:05:57.405] - Launch lazy future ... done
[16:05:57.405] run() for ‘MulticoreFuture’ ... done
[16:05:57.405] plan(): Setting new future strategy stack:
[16:05:57.406] getGlobalsAndPackages() ...
[16:05:57.406] Searching for globals...
[16:05:57.406] List of future strategies:
[16:05:57.406] 1. sequential:
[16:05:57.406]    - args: function (..., envir = parent.frame())
[16:05:57.406]    - tweaked: FALSE
[16:05:57.406]    - call: NULL
[16:05:57.406] plan(): nbrOfWorkers() = 1
[16:05:57.407] - globals found: [1] ‘{’
[16:05:57.408] Searching for globals ... DONE
[16:05:57.408] Resolving globals: FALSE
[16:05:57.408] 
[16:05:57.408] 
[16:05:57.409] getGlobalsAndPackages() ... DONE
[16:05:57.409] run() for ‘Future’ ...
[16:05:57.409] - state: ‘created’
[16:05:57.409] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:05:57.415] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:57.415] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:05:57.415]   - Field: ‘label’
[16:05:57.415]   - Field: ‘local’
[16:05:57.415]   - Field: ‘owner’
[16:05:57.415]   - Field: ‘envir’
[16:05:57.416]   - Field: ‘workers’
[16:05:57.416]   - Field: ‘packages’
[16:05:57.416]   - Field: ‘gc’
[16:05:57.416]   - Field: ‘job’
[16:05:57.416]   - Field: ‘conditions’
[16:05:57.416]   - Field: ‘expr’
[16:05:57.416]   - Field: ‘uuid’
[16:05:57.417]   - Field: ‘seed’
[16:05:57.417]   - Field: ‘version’
[16:05:57.417]   - Field: ‘result’
[16:05:57.417]   - Field: ‘asynchronous’
[16:05:57.417]   - Field: ‘calls’
[16:05:57.417]   - Field: ‘globals’
[16:05:57.417]   - Field: ‘stdout’
[16:05:57.418]   - Field: ‘earlySignal’
[16:05:57.418]   - Field: ‘lazy’
[16:05:57.422]   - Field: ‘state’
[16:05:57.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:05:57.423] - Launch lazy future ...
[16:05:57.423] Packages needed by the future expression (n = 0): <none>
[16:05:57.424] Packages needed by future strategies (n = 0): <none>
[16:05:57.425] {
[16:05:57.425]     {
[16:05:57.425]         {
[16:05:57.425]             ...future.startTime <- base::Sys.time()
[16:05:57.425]             {
[16:05:57.425]                 {
[16:05:57.425]                   {
[16:05:57.425]                     {
[16:05:57.425]                       base::local({
[16:05:57.425]                         has_future <- base::requireNamespace("future", 
[16:05:57.425]                           quietly = TRUE)
[16:05:57.425]                         if (has_future) {
[16:05:57.425]                           ns <- base::getNamespace("future")
[16:05:57.425]                           version <- ns[[".package"]][["version"]]
[16:05:57.425]                           if (is.null(version)) 
[16:05:57.425]                             version <- utils::packageVersion("future")
[16:05:57.425]                         }
[16:05:57.425]                         else {
[16:05:57.425]                           version <- NULL
[16:05:57.425]                         }
[16:05:57.425]                         if (!has_future || version < "1.8.0") {
[16:05:57.425]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:57.425]                             "", base::R.version$version.string), 
[16:05:57.425]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:57.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:57.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:57.425]                               "release", "version")], collapse = " "), 
[16:05:57.425]                             hostname = base::Sys.info()[["nodename"]])
[16:05:57.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:57.425]                             info)
[16:05:57.425]                           info <- base::paste(info, collapse = "; ")
[16:05:57.425]                           if (!has_future) {
[16:05:57.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:57.425]                               info)
[16:05:57.425]                           }
[16:05:57.425]                           else {
[16:05:57.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:57.425]                               info, version)
[16:05:57.425]                           }
[16:05:57.425]                           base::stop(msg)
[16:05:57.425]                         }
[16:05:57.425]                       })
[16:05:57.425]                     }
[16:05:57.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:57.425]                     base::options(mc.cores = 1L)
[16:05:57.425]                   }
[16:05:57.425]                   options(future.plan = NULL)
[16:05:57.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:57.425]                 }
[16:05:57.425]                 ...future.workdir <- getwd()
[16:05:57.425]             }
[16:05:57.425]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:57.425]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:57.425]         }
[16:05:57.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:57.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:57.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:57.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:57.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:57.425]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:57.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:57.425]             base::names(...future.oldOptions))
[16:05:57.425]     }
[16:05:57.425]     if (FALSE) {
[16:05:57.425]     }
[16:05:57.425]     else {
[16:05:57.425]         if (TRUE) {
[16:05:57.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:57.425]                 open = "w")
[16:05:57.425]         }
[16:05:57.425]         else {
[16:05:57.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:57.425]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:57.425]         }
[16:05:57.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:57.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:57.425]             base::sink(type = "output", split = FALSE)
[16:05:57.425]             base::close(...future.stdout)
[16:05:57.425]         }, add = TRUE)
[16:05:57.425]     }
[16:05:57.425]     ...future.frame <- base::sys.nframe()
[16:05:57.425]     ...future.conditions <- base::list()
[16:05:57.425]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:57.425]     if (FALSE) {
[16:05:57.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:57.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:57.425]     }
[16:05:57.425]     ...future.result <- base::tryCatch({
[16:05:57.425]         base::withCallingHandlers({
[16:05:57.425]             ...future.value <- base::withVisible(base::local({
[16:05:57.425]                 withCallingHandlers({
[16:05:57.425]                   {
[16:05:57.425]                     3
[16:05:57.425]                   }
[16:05:57.425]                 }, immediateCondition = function(cond) {
[16:05:57.425]                   save_rds <- function (object, pathname, ...) 
[16:05:57.425]                   {
[16:05:57.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:05:57.425]                     if (file_test("-f", pathname_tmp)) {
[16:05:57.425]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:05:57.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.425]                         fi_tmp[["mtime"]])
[16:05:57.425]                     }
[16:05:57.425]                     tryCatch({
[16:05:57.425]                       saveRDS(object, file = pathname_tmp, ...)
[16:05:57.425]                     }, error = function(ex) {
[16:05:57.425]                       msg <- conditionMessage(ex)
[16:05:57.425]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:05:57.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.425]                         fi_tmp[["mtime"]], msg)
[16:05:57.425]                       ex$message <- msg
[16:05:57.425]                       stop(ex)
[16:05:57.425]                     })
[16:05:57.425]                     stopifnot(file_test("-f", pathname_tmp))
[16:05:57.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:05:57.425]                     if (!res || file_test("-f", pathname_tmp)) {
[16:05:57.425]                       fi_tmp <- file.info(pathname_tmp)
[16:05:57.425]                       fi <- file.info(pathname)
[16:05:57.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:05:57.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:05:57.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:05:57.425]                         fi[["size"]], fi[["mtime"]])
[16:05:57.425]                       stop(msg)
[16:05:57.425]                     }
[16:05:57.425]                     invisible(pathname)
[16:05:57.425]                   }
[16:05:57.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:05:57.425]                     rootPath = tempdir()) 
[16:05:57.425]                   {
[16:05:57.425]                     obj <- list(time = Sys.time(), condition = cond)
[16:05:57.425]                     file <- tempfile(pattern = class(cond)[1], 
[16:05:57.425]                       tmpdir = path, fileext = ".rds")
[16:05:57.425]                     save_rds(obj, file)
[16:05:57.425]                   }
[16:05:57.425]                   saveImmediateCondition(cond, path = "/tmp/RtmpetPucI/.future/immediateConditions")
[16:05:57.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.425]                   {
[16:05:57.425]                     inherits <- base::inherits
[16:05:57.425]                     invokeRestart <- base::invokeRestart
[16:05:57.425]                     is.null <- base::is.null
[16:05:57.425]                     muffled <- FALSE
[16:05:57.425]                     if (inherits(cond, "message")) {
[16:05:57.425]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:57.425]                       if (muffled) 
[16:05:57.425]                         invokeRestart("muffleMessage")
[16:05:57.425]                     }
[16:05:57.425]                     else if (inherits(cond, "warning")) {
[16:05:57.425]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:57.425]                       if (muffled) 
[16:05:57.425]                         invokeRestart("muffleWarning")
[16:05:57.425]                     }
[16:05:57.425]                     else if (inherits(cond, "condition")) {
[16:05:57.425]                       if (!is.null(pattern)) {
[16:05:57.425]                         computeRestarts <- base::computeRestarts
[16:05:57.425]                         grepl <- base::grepl
[16:05:57.425]                         restarts <- computeRestarts(cond)
[16:05:57.425]                         for (restart in restarts) {
[16:05:57.425]                           name <- restart$name
[16:05:57.425]                           if (is.null(name)) 
[16:05:57.425]                             next
[16:05:57.425]                           if (!grepl(pattern, name)) 
[16:05:57.425]                             next
[16:05:57.425]                           invokeRestart(restart)
[16:05:57.425]                           muffled <- TRUE
[16:05:57.425]                           break
[16:05:57.425]                         }
[16:05:57.425]                       }
[16:05:57.425]                     }
[16:05:57.425]                     invisible(muffled)
[16:05:57.425]                   }
[16:05:57.425]                   muffleCondition(cond)
[16:05:57.425]                 })
[16:05:57.425]             }))
[16:05:57.425]             future::FutureResult(value = ...future.value$value, 
[16:05:57.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.425]                   ...future.rng), globalenv = if (FALSE) 
[16:05:57.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:57.425]                     ...future.globalenv.names))
[16:05:57.425]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:57.425]         }, condition = base::local({
[16:05:57.425]             c <- base::c
[16:05:57.425]             inherits <- base::inherits
[16:05:57.425]             invokeRestart <- base::invokeRestart
[16:05:57.425]             length <- base::length
[16:05:57.425]             list <- base::list
[16:05:57.425]             seq.int <- base::seq.int
[16:05:57.425]             signalCondition <- base::signalCondition
[16:05:57.425]             sys.calls <- base::sys.calls
[16:05:57.425]             `[[` <- base::`[[`
[16:05:57.425]             `+` <- base::`+`
[16:05:57.425]             `<<-` <- base::`<<-`
[16:05:57.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:57.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:57.425]                   3L)]
[16:05:57.425]             }
[16:05:57.425]             function(cond) {
[16:05:57.425]                 is_error <- inherits(cond, "error")
[16:05:57.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:57.425]                   NULL)
[16:05:57.425]                 if (is_error) {
[16:05:57.425]                   sessionInformation <- function() {
[16:05:57.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:57.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:57.425]                       search = base::search(), system = base::Sys.info())
[16:05:57.425]                   }
[16:05:57.425]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:57.425]                     cond$call), session = sessionInformation(), 
[16:05:57.425]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:57.425]                   signalCondition(cond)
[16:05:57.425]                 }
[16:05:57.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:57.425]                 "immediateCondition"))) {
[16:05:57.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:57.425]                   ...future.conditions[[length(...future.conditions) + 
[16:05:57.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:57.425]                   if (TRUE && !signal) {
[16:05:57.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.425]                     {
[16:05:57.425]                       inherits <- base::inherits
[16:05:57.425]                       invokeRestart <- base::invokeRestart
[16:05:57.425]                       is.null <- base::is.null
[16:05:57.425]                       muffled <- FALSE
[16:05:57.425]                       if (inherits(cond, "message")) {
[16:05:57.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.425]                         if (muffled) 
[16:05:57.425]                           invokeRestart("muffleMessage")
[16:05:57.425]                       }
[16:05:57.425]                       else if (inherits(cond, "warning")) {
[16:05:57.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.425]                         if (muffled) 
[16:05:57.425]                           invokeRestart("muffleWarning")
[16:05:57.425]                       }
[16:05:57.425]                       else if (inherits(cond, "condition")) {
[16:05:57.425]                         if (!is.null(pattern)) {
[16:05:57.425]                           computeRestarts <- base::computeRestarts
[16:05:57.425]                           grepl <- base::grepl
[16:05:57.425]                           restarts <- computeRestarts(cond)
[16:05:57.425]                           for (restart in restarts) {
[16:05:57.425]                             name <- restart$name
[16:05:57.425]                             if (is.null(name)) 
[16:05:57.425]                               next
[16:05:57.425]                             if (!grepl(pattern, name)) 
[16:05:57.425]                               next
[16:05:57.425]                             invokeRestart(restart)
[16:05:57.425]                             muffled <- TRUE
[16:05:57.425]                             break
[16:05:57.425]                           }
[16:05:57.425]                         }
[16:05:57.425]                       }
[16:05:57.425]                       invisible(muffled)
[16:05:57.425]                     }
[16:05:57.425]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.425]                   }
[16:05:57.425]                 }
[16:05:57.425]                 else {
[16:05:57.425]                   if (TRUE) {
[16:05:57.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:57.425]                     {
[16:05:57.425]                       inherits <- base::inherits
[16:05:57.425]                       invokeRestart <- base::invokeRestart
[16:05:57.425]                       is.null <- base::is.null
[16:05:57.425]                       muffled <- FALSE
[16:05:57.425]                       if (inherits(cond, "message")) {
[16:05:57.425]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:57.425]                         if (muffled) 
[16:05:57.425]                           invokeRestart("muffleMessage")
[16:05:57.425]                       }
[16:05:57.425]                       else if (inherits(cond, "warning")) {
[16:05:57.425]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:57.425]                         if (muffled) 
[16:05:57.425]                           invokeRestart("muffleWarning")
[16:05:57.425]                       }
[16:05:57.425]                       else if (inherits(cond, "condition")) {
[16:05:57.425]                         if (!is.null(pattern)) {
[16:05:57.425]                           computeRestarts <- base::computeRestarts
[16:05:57.425]                           grepl <- base::grepl
[16:05:57.425]                           restarts <- computeRestarts(cond)
[16:05:57.425]                           for (restart in restarts) {
[16:05:57.425]                             name <- restart$name
[16:05:57.425]                             if (is.null(name)) 
[16:05:57.425]                               next
[16:05:57.425]                             if (!grepl(pattern, name)) 
[16:05:57.425]                               next
[16:05:57.425]                             invokeRestart(restart)
[16:05:57.425]                             muffled <- TRUE
[16:05:57.425]                             break
[16:05:57.425]                           }
[16:05:57.425]                         }
[16:05:57.425]                       }
[16:05:57.425]                       invisible(muffled)
[16:05:57.425]                     }
[16:05:57.425]                     muffleCondition(cond, pattern = "^muffle")
[16:05:57.425]                   }
[16:05:57.425]                 }
[16:05:57.425]             }
[16:05:57.425]         }))
[16:05:57.425]     }, error = function(ex) {
[16:05:57.425]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:57.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:57.425]                 ...future.rng), started = ...future.startTime, 
[16:05:57.425]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:57.425]             version = "1.8"), class = "FutureResult")
[16:05:57.425]     }, finally = {
[16:05:57.425]         if (!identical(...future.workdir, getwd())) 
[16:05:57.425]             setwd(...future.workdir)
[16:05:57.425]         {
[16:05:57.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:57.425]                 ...future.oldOptions$nwarnings <- NULL
[16:05:57.425]             }
[16:05:57.425]             base::options(...future.oldOptions)
[16:05:57.425]             if (.Platform$OS.type == "windows") {
[16:05:57.425]                 old_names <- names(...future.oldEnvVars)
[16:05:57.425]                 envs <- base::Sys.getenv()
[16:05:57.425]                 names <- names(envs)
[16:05:57.425]                 common <- intersect(names, old_names)
[16:05:57.425]                 added <- setdiff(names, old_names)
[16:05:57.425]                 removed <- setdiff(old_names, names)
[16:05:57.425]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:57.425]                   envs[common]]
[16:05:57.425]                 NAMES <- toupper(changed)
[16:05:57.425]                 args <- list()
[16:05:57.425]                 for (kk in seq_along(NAMES)) {
[16:05:57.425]                   name <- changed[[kk]]
[16:05:57.425]                   NAME <- NAMES[[kk]]
[16:05:57.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.425]                     next
[16:05:57.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.425]                 }
[16:05:57.425]                 NAMES <- toupper(added)
[16:05:57.425]                 for (kk in seq_along(NAMES)) {
[16:05:57.425]                   name <- added[[kk]]
[16:05:57.425]                   NAME <- NAMES[[kk]]
[16:05:57.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.425]                     next
[16:05:57.425]                   args[[name]] <- ""
[16:05:57.425]                 }
[16:05:57.425]                 NAMES <- toupper(removed)
[16:05:57.425]                 for (kk in seq_along(NAMES)) {
[16:05:57.425]                   name <- removed[[kk]]
[16:05:57.425]                   NAME <- NAMES[[kk]]
[16:05:57.425]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:57.425]                     next
[16:05:57.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:57.425]                 }
[16:05:57.425]                 if (length(args) > 0) 
[16:05:57.425]                   base::do.call(base::Sys.setenv, args = args)
[16:05:57.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:57.425]             }
[16:05:57.425]             else {
[16:05:57.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:57.425]             }
[16:05:57.425]             {
[16:05:57.425]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:57.425]                   0L) {
[16:05:57.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:57.425]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:57.425]                   base::options(opts)
[16:05:57.425]                 }
[16:05:57.425]                 {
[16:05:57.425]                   {
[16:05:57.425]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:57.425]                     NULL
[16:05:57.425]                   }
[16:05:57.425]                   options(future.plan = NULL)
[16:05:57.425]                   if (is.na(NA_character_)) 
[16:05:57.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:57.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:57.425]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[16:05:57.425]                     envir = parent.frame()) 
[16:05:57.425]                   {
[16:05:57.425]                     default_workers <- missing(workers)
[16:05:57.425]                     if (is.function(workers)) 
[16:05:57.425]                       workers <- workers()
[16:05:57.425]                     workers <- structure(as.integer(workers), 
[16:05:57.425]                       class = class(workers))
[16:05:57.425]                     stop_if_not(is.finite(workers), workers >= 
[16:05:57.425]                       1L)
[16:05:57.425]                     if ((workers == 1L && !inherits(workers, 
[16:05:57.425]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[16:05:57.425]                       if (default_workers) 
[16:05:57.425]                         supportsMulticore(warn = TRUE)
[16:05:57.425]                       return(sequential(..., envir = envir))
[16:05:57.425]                     }
[16:05:57.425]                     oopts <- options(mc.cores = workers)
[16:05:57.425]                     on.exit(options(oopts))
[16:05:57.425]                     future <- MulticoreFuture(..., workers = workers, 
[16:05:57.425]                       envir = envir)
[16:05:57.425]                     if (!future$lazy) 
[16:05:57.425]                       future <- run(future)
[16:05:57.425]                     invisible(future)
[16:05:57.425]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:57.425]                 }
[16:05:57.425]             }
[16:05:57.425]         }
[16:05:57.425]     })
[16:05:57.425]     if (TRUE) {
[16:05:57.425]         base::sink(type = "output", split = FALSE)
[16:05:57.425]         if (TRUE) {
[16:05:57.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:57.425]         }
[16:05:57.425]         else {
[16:05:57.425]             ...future.result["stdout"] <- base::list(NULL)
[16:05:57.425]         }
[16:05:57.425]         base::close(...future.stdout)
[16:05:57.425]         ...future.stdout <- NULL
[16:05:57.425]     }
[16:05:57.425]     ...future.result$conditions <- ...future.conditions
[16:05:57.425]     ...future.result$finished <- base::Sys.time()
[16:05:57.425]     ...future.result
[16:05:57.425] }
[16:05:57.428] requestCore(): workers = 2
[16:05:57.429] Poll #1 (0): usedCores() = 2, workers = 2
[16:05:57.440] result() for MulticoreFuture ...
[16:05:57.441] result() for MulticoreFuture ...
[16:05:57.441] result() for MulticoreFuture ... done
[16:05:57.441] result() for MulticoreFuture ... done
[16:05:57.441] result() for MulticoreFuture ...
[16:05:57.441] result() for MulticoreFuture ... done
[16:05:57.443] MulticoreFuture started
[16:05:57.444] - Launch lazy future ... done
[16:05:57.444] run() for ‘MulticoreFuture’ ... done
[16:05:57.445] plan(): Setting new future strategy stack:
[16:05:57.445] List of future strategies:
[16:05:57.445] 1. sequential:
[16:05:57.445]    - args: function (..., envir = parent.frame())
[16:05:57.445]    - tweaked: FALSE
[16:05:57.445]    - call: NULL
[16:05:57.446] plan(): nbrOfWorkers() = 1
[16:05:57.446] resolve() on list environment ...
[16:05:57.446]  recursive: 0
[16:05:57.448] plan(): Setting new future strategy stack:
[16:05:57.448]  length: 4
[16:05:57.448]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:57.449] Future #1
[16:05:57.448] List of future strategies:
[16:05:57.448] 1. multicore:
[16:05:57.448]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.448]    - tweaked: FALSE
[16:05:57.448]    - call: plan(strategy)
[16:05:57.449]  length: 3 (resolved future 1)
[16:05:57.454] plan(): nbrOfWorkers() = 2
[16:05:57.460] Future #3
[16:05:57.460]  length: 2 (resolved future 3)
[16:05:57.460]  length: 1 (resolved future 4)
[16:05:57.909] plan(): Setting new future strategy stack:
[16:05:57.909] List of future strategies:
[16:05:57.909] 1. multicore:
[16:05:57.909]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:05:57.909]    - tweaked: FALSE
[16:05:57.909]    - call: plan(strategy)
[16:05:57.914] plan(): nbrOfWorkers() = 2
[16:05:57.920] Future #2
[16:05:57.921]  length: 0 (resolved future 2)
[16:05:57.921] resolve() on list environment ... DONE
[16:05:57.921] resolve() on list environment ...
[16:05:57.922]  recursive: 0
[16:05:57.923]  length: 4
[16:05:57.923]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:57.923] Future #1
[16:05:57.923]  length: 3 (resolved future 1)
[16:05:57.924] Future #2
[16:05:57.924]  length: 2 (resolved future 2)
[16:05:57.924] Future #3
[16:05:57.924]  length: 1 (resolved future 3)
[16:05:57.924]  length: 0 (resolved future 4)
[16:05:57.925] resolve() on list environment ... DONE
[16:05:57.926] resolve() on list environment ...
[16:05:57.926]  recursive: 0
[16:05:57.927]  length: 4
[16:05:57.927]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:57.927] Future #1
[16:05:57.927]  length: 3 (resolved future 1)
[16:05:57.928] Future #2
[16:05:57.928]  length: 2 (resolved future 2)
[16:05:57.928] Future #3
[16:05:57.928]  length: 1 (resolved future 3)
[16:05:57.928]  length: 0 (resolved future 4)
[16:05:57.929] resolve() on list environment ... DONE
[16:05:57.929] resolve() on list environment ...
[16:05:57.929]  recursive: 0
[16:05:57.930]  length: 4
[16:05:57.930]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:57.931] Future #1
[16:05:57.931]  length: 3 (resolved future 1)
[16:05:57.931] Future #2
[16:05:57.931]  length: 2 (resolved future 2)
[16:05:57.932] Future #3
[16:05:57.932]  length: 1 (resolved future 3)
[16:05:57.932]  length: 0 (resolved future 4)
[16:05:57.932] resolve() on list environment ... DONE
[16:05:57.933] resolve() on list environment ...
[16:05:57.933]  recursive: 0
[16:05:57.934]  length: 4
[16:05:57.934]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:57.934] Future #1
[16:05:57.934] result() for MulticoreFuture ...
[16:05:57.934] result() for MulticoreFuture ... done
[16:05:57.934] result() for MulticoreFuture ...
[16:05:57.935] result() for MulticoreFuture ... done
[16:05:57.935]  length: 3 (resolved future 1)
[16:05:57.935] Future #2
[16:05:57.935] result() for MulticoreFuture ...
[16:05:57.936] result() for MulticoreFuture ...
[16:05:57.936] result() for MulticoreFuture ... done
[16:05:57.936] result() for MulticoreFuture ... done
[16:05:57.937] result() for MulticoreFuture ...
[16:05:57.937] result() for MulticoreFuture ... done
[16:05:57.937]  length: 2 (resolved future 2)
[16:05:57.937] Future #3
[16:05:57.937] result() for MulticoreFuture ...
[16:05:57.938] result() for MulticoreFuture ...
[16:05:57.938] result() for MulticoreFuture ... done
[16:05:57.938] result() for MulticoreFuture ... done
[16:05:57.938] result() for MulticoreFuture ...
[16:05:57.938] result() for MulticoreFuture ... done
[16:05:57.939]  length: 1 (resolved future 3)
[16:05:57.939]  length: 0 (resolved future 4)
[16:05:57.939] resolve() on list environment ... DONE
[16:05:57.940] resolve() on list environment ...
[16:05:57.940]  recursive: 99
[16:05:57.943]  length: 4
[16:05:57.943]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:05:57.943] Future #1
[16:05:57.944] result() for MulticoreFuture ...
[16:05:57.944] result() for MulticoreFuture ... done
[16:05:57.944] result() for MulticoreFuture ...
[16:05:57.944] result() for MulticoreFuture ... done
[16:05:57.944] A MulticoreFuture was resolved
[16:05:57.944]  length: 3 (resolved future 1)
[16:05:57.945] Future #2
[16:05:57.945] result() for MulticoreFuture ...
[16:05:57.945] result() for MulticoreFuture ... done
[16:05:57.945] result() for MulticoreFuture ...
[16:05:57.945] result() for MulticoreFuture ... done
[16:05:57.945] A MulticoreFuture was resolved
[16:05:57.945]  length: 2 (resolved future 2)
[16:05:57.946] Future #3
[16:05:57.946] result() for MulticoreFuture ...
[16:05:57.946] result() for MulticoreFuture ... done
[16:05:57.946] result() for MulticoreFuture ...
[16:05:57.946] result() for MulticoreFuture ... done
[16:05:57.946] A MulticoreFuture was resolved
[16:05:57.946]  length: 1 (resolved future 3)
[16:05:57.946]  length: 0 (resolved future 4)
[16:05:57.946] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[16:05:57.947] plan(): Setting new future strategy stack:
[16:05:57.947] List of future strategies:
[16:05:57.947] 1. multisession:
[16:05:57.947]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:57.947]    - tweaked: FALSE
[16:05:57.947]    - call: plan(strategy)
[16:05:57.948] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:05:57.948] multisession:
[16:05:57.948] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:05:57.948] - tweaked: FALSE
[16:05:57.948] - call: plan(strategy)
[16:05:57.955] getGlobalsAndPackages() ...
[16:05:57.955] Not searching for globals
[16:05:57.955] - globals: [0] <none>
[16:05:57.955] getGlobalsAndPackages() ... DONE
[16:05:57.956] [local output] makeClusterPSOCK() ...
[16:05:57.994] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:05:57.995] [local output] Base port: 11858
[16:05:57.996] [local output] Getting setup options for 2 cluster nodes ...
[16:05:57.996] [local output]  - Node 1 of 2 ...
[16:05:57.996] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:57.997] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpetPucI/worker.rank=1.parallelly.parent=90365.160fd32ff7622.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpetPucI/worker.rank=1.parallelly.parent=90365.160fd32ff7622.pid")'’
[16:05:58.188] - Possible to infer worker's PID: TRUE
[16:05:58.188] [local output] Rscript port: 11858

[16:05:58.189] [local output]  - Node 2 of 2 ...
[16:05:58.189] [local output] localMachine=TRUE => revtunnel=FALSE

[16:05:58.190] [local output] Rscript port: 11858

[16:05:58.190] [local output] Getting setup options for 2 cluster nodes ... done
[16:05:58.190] [local output]  - Parallel setup requested for some PSOCK nodes
[16:05:58.191] [local output] Setting up PSOCK nodes in parallel
[16:05:58.191] List of 36
[16:05:58.191]  $ worker          : chr "localhost"
[16:05:58.191]   ..- attr(*, "localhost")= logi TRUE
[16:05:58.191]  $ master          : chr "localhost"
[16:05:58.191]  $ port            : int 11858
[16:05:58.191]  $ connectTimeout  : num 120
[16:05:58.191]  $ timeout         : num 2592000
[16:05:58.191]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:05:58.191]  $ homogeneous     : logi TRUE
[16:05:58.191]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:05:58.191]  $ rscript_envs    : NULL
[16:05:58.191]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:58.191]  $ rscript_startup : NULL
[16:05:58.191]  $ rscript_sh      : chr "sh"
[16:05:58.191]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:58.191]  $ methods         : logi TRUE
[16:05:58.191]  $ socketOptions   : chr "no-delay"
[16:05:58.191]  $ useXDR          : logi FALSE
[16:05:58.191]  $ outfile         : chr "/dev/null"
[16:05:58.191]  $ renice          : int NA
[16:05:58.191]  $ rshcmd          : NULL
[16:05:58.191]  $ user            : chr(0) 
[16:05:58.191]  $ revtunnel       : logi FALSE
[16:05:58.191]  $ rshlogfile      : NULL
[16:05:58.191]  $ rshopts         : chr(0) 
[16:05:58.191]  $ rank            : int 1
[16:05:58.191]  $ manual          : logi FALSE
[16:05:58.191]  $ dryrun          : logi FALSE
[16:05:58.191]  $ quiet           : logi FALSE
[16:05:58.191]  $ setup_strategy  : chr "parallel"
[16:05:58.191]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:58.191]  $ pidfile         : chr "/tmp/RtmpetPucI/worker.rank=1.parallelly.parent=90365.160fd32ff7622.pid"
[16:05:58.191]  $ rshcmd_label    : NULL
[16:05:58.191]  $ rsh_call        : NULL
[16:05:58.191]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:05:58.191]  $ localMachine    : logi TRUE
[16:05:58.191]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:05:58.191]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:05:58.191]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:05:58.191]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:05:58.191]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:05:58.191]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:05:58.191]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:05:58.191]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:05:58.191]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:05:58.191]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:05:58.191]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:05:58.191]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:05:58.191]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:05:58.191]  $ arguments       :List of 28
[16:05:58.191]   ..$ worker          : chr "localhost"
[16:05:58.191]   ..$ master          : NULL
[16:05:58.191]   ..$ port            : int 11858
[16:05:58.191]   ..$ connectTimeout  : num 120
[16:05:58.191]   ..$ timeout         : num 2592000
[16:05:58.191]   ..$ rscript         : NULL
[16:05:58.191]   ..$ homogeneous     : NULL
[16:05:58.191]   ..$ rscript_args    : NULL
[16:05:58.191]   ..$ rscript_envs    : NULL
[16:05:58.191]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:05:58.191]   ..$ rscript_startup : NULL
[16:05:58.191]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:05:58.191]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:05:58.191]   ..$ methods         : logi TRUE
[16:05:58.191]   ..$ socketOptions   : chr "no-delay"
[16:05:58.191]   ..$ useXDR          : logi FALSE
[16:05:58.191]   ..$ outfile         : chr "/dev/null"
[16:05:58.191]   ..$ renice          : int NA
[16:05:58.191]   ..$ rshcmd          : NULL
[16:05:58.191]   ..$ user            : NULL
[16:05:58.191]   ..$ revtunnel       : logi NA
[16:05:58.191]   ..$ rshlogfile      : NULL
[16:05:58.191]   ..$ rshopts         : NULL
[16:05:58.191]   ..$ rank            : int 1
[16:05:58.191]   ..$ manual          : logi FALSE
[16:05:58.191]   ..$ dryrun          : logi FALSE
[16:05:58.191]   ..$ quiet           : logi FALSE
[16:05:58.191]   ..$ setup_strategy  : chr "parallel"
[16:05:58.191]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:05:58.208] [local output] System call to launch all workers:
[16:05:58.208] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpetPucI/worker.rank=1.parallelly.parent=90365.160fd32ff7622.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11858 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:05:58.208] [local output] Starting PSOCK main server
[16:05:58.213] [local output] Workers launched
[16:05:58.213] [local output] Waiting for workers to connect back
[16:05:58.214]  - [local output] 0 workers out of 2 ready
[16:05:58.455]  - [local output] 0 workers out of 2 ready
[16:05:58.456]  - [local output] 1 workers out of 2 ready
[16:05:58.457]  - [local output] 1 workers out of 2 ready
[16:05:58.457]  - [local output] 2 workers out of 2 ready
[16:05:58.458] [local output] Launching of workers completed
[16:05:58.458] [local output] Collecting session information from workers
[16:05:58.459] [local output]  - Worker #1 of 2
[16:05:58.459] [local output]  - Worker #2 of 2
[16:05:58.460] [local output] makeClusterPSOCK() ... done
[16:05:58.472] Packages needed by the future expression (n = 0): <none>
[16:05:58.472] Packages needed by future strategies (n = 0): <none>
[16:05:58.472] {
[16:05:58.472]     {
[16:05:58.472]         {
[16:05:58.472]             ...future.startTime <- base::Sys.time()
[16:05:58.472]             {
[16:05:58.472]                 {
[16:05:58.472]                   {
[16:05:58.472]                     {
[16:05:58.472]                       base::local({
[16:05:58.472]                         has_future <- base::requireNamespace("future", 
[16:05:58.472]                           quietly = TRUE)
[16:05:58.472]                         if (has_future) {
[16:05:58.472]                           ns <- base::getNamespace("future")
[16:05:58.472]                           version <- ns[[".package"]][["version"]]
[16:05:58.472]                           if (is.null(version)) 
[16:05:58.472]                             version <- utils::packageVersion("future")
[16:05:58.472]                         }
[16:05:58.472]                         else {
[16:05:58.472]                           version <- NULL
[16:05:58.472]                         }
[16:05:58.472]                         if (!has_future || version < "1.8.0") {
[16:05:58.472]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:58.472]                             "", base::R.version$version.string), 
[16:05:58.472]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:58.472]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:58.472]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:58.472]                               "release", "version")], collapse = " "), 
[16:05:58.472]                             hostname = base::Sys.info()[["nodename"]])
[16:05:58.472]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:58.472]                             info)
[16:05:58.472]                           info <- base::paste(info, collapse = "; ")
[16:05:58.472]                           if (!has_future) {
[16:05:58.472]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:58.472]                               info)
[16:05:58.472]                           }
[16:05:58.472]                           else {
[16:05:58.472]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:58.472]                               info, version)
[16:05:58.472]                           }
[16:05:58.472]                           base::stop(msg)
[16:05:58.472]                         }
[16:05:58.472]                       })
[16:05:58.472]                     }
[16:05:58.472]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:58.472]                     base::options(mc.cores = 1L)
[16:05:58.472]                   }
[16:05:58.472]                   options(future.plan = NULL)
[16:05:58.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:58.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:58.472]                 }
[16:05:58.472]                 ...future.workdir <- getwd()
[16:05:58.472]             }
[16:05:58.472]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:58.472]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:58.472]         }
[16:05:58.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:58.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:58.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:58.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:58.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:58.472]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:58.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:58.472]             base::names(...future.oldOptions))
[16:05:58.472]     }
[16:05:58.472]     if (FALSE) {
[16:05:58.472]     }
[16:05:58.472]     else {
[16:05:58.472]         if (TRUE) {
[16:05:58.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:58.472]                 open = "w")
[16:05:58.472]         }
[16:05:58.472]         else {
[16:05:58.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:58.472]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:58.472]         }
[16:05:58.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:58.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:58.472]             base::sink(type = "output", split = FALSE)
[16:05:58.472]             base::close(...future.stdout)
[16:05:58.472]         }, add = TRUE)
[16:05:58.472]     }
[16:05:58.472]     ...future.frame <- base::sys.nframe()
[16:05:58.472]     ...future.conditions <- base::list()
[16:05:58.472]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:58.472]     if (FALSE) {
[16:05:58.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:58.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:58.472]     }
[16:05:58.472]     ...future.result <- base::tryCatch({
[16:05:58.472]         base::withCallingHandlers({
[16:05:58.472]             ...future.value <- base::withVisible(base::local({
[16:05:58.472]                 ...future.makeSendCondition <- base::local({
[16:05:58.472]                   sendCondition <- NULL
[16:05:58.472]                   function(frame = 1L) {
[16:05:58.472]                     if (is.function(sendCondition)) 
[16:05:58.472]                       return(sendCondition)
[16:05:58.472]                     ns <- getNamespace("parallel")
[16:05:58.472]                     if (exists("sendData", mode = "function", 
[16:05:58.472]                       envir = ns)) {
[16:05:58.472]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:58.472]                         envir = ns)
[16:05:58.472]                       envir <- sys.frame(frame)
[16:05:58.472]                       master <- NULL
[16:05:58.472]                       while (!identical(envir, .GlobalEnv) && 
[16:05:58.472]                         !identical(envir, emptyenv())) {
[16:05:58.472]                         if (exists("master", mode = "list", envir = envir, 
[16:05:58.472]                           inherits = FALSE)) {
[16:05:58.472]                           master <- get("master", mode = "list", 
[16:05:58.472]                             envir = envir, inherits = FALSE)
[16:05:58.472]                           if (inherits(master, c("SOCKnode", 
[16:05:58.472]                             "SOCK0node"))) {
[16:05:58.472]                             sendCondition <<- function(cond) {
[16:05:58.472]                               data <- list(type = "VALUE", value = cond, 
[16:05:58.472]                                 success = TRUE)
[16:05:58.472]                               parallel_sendData(master, data)
[16:05:58.472]                             }
[16:05:58.472]                             return(sendCondition)
[16:05:58.472]                           }
[16:05:58.472]                         }
[16:05:58.472]                         frame <- frame + 1L
[16:05:58.472]                         envir <- sys.frame(frame)
[16:05:58.472]                       }
[16:05:58.472]                     }
[16:05:58.472]                     sendCondition <<- function(cond) NULL
[16:05:58.472]                   }
[16:05:58.472]                 })
[16:05:58.472]                 withCallingHandlers({
[16:05:58.472]                   NA
[16:05:58.472]                 }, immediateCondition = function(cond) {
[16:05:58.472]                   sendCondition <- ...future.makeSendCondition()
[16:05:58.472]                   sendCondition(cond)
[16:05:58.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:58.472]                   {
[16:05:58.472]                     inherits <- base::inherits
[16:05:58.472]                     invokeRestart <- base::invokeRestart
[16:05:58.472]                     is.null <- base::is.null
[16:05:58.472]                     muffled <- FALSE
[16:05:58.472]                     if (inherits(cond, "message")) {
[16:05:58.472]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:58.472]                       if (muffled) 
[16:05:58.472]                         invokeRestart("muffleMessage")
[16:05:58.472]                     }
[16:05:58.472]                     else if (inherits(cond, "warning")) {
[16:05:58.472]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:58.472]                       if (muffled) 
[16:05:58.472]                         invokeRestart("muffleWarning")
[16:05:58.472]                     }
[16:05:58.472]                     else if (inherits(cond, "condition")) {
[16:05:58.472]                       if (!is.null(pattern)) {
[16:05:58.472]                         computeRestarts <- base::computeRestarts
[16:05:58.472]                         grepl <- base::grepl
[16:05:58.472]                         restarts <- computeRestarts(cond)
[16:05:58.472]                         for (restart in restarts) {
[16:05:58.472]                           name <- restart$name
[16:05:58.472]                           if (is.null(name)) 
[16:05:58.472]                             next
[16:05:58.472]                           if (!grepl(pattern, name)) 
[16:05:58.472]                             next
[16:05:58.472]                           invokeRestart(restart)
[16:05:58.472]                           muffled <- TRUE
[16:05:58.472]                           break
[16:05:58.472]                         }
[16:05:58.472]                       }
[16:05:58.472]                     }
[16:05:58.472]                     invisible(muffled)
[16:05:58.472]                   }
[16:05:58.472]                   muffleCondition(cond)
[16:05:58.472]                 })
[16:05:58.472]             }))
[16:05:58.472]             future::FutureResult(value = ...future.value$value, 
[16:05:58.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:58.472]                   ...future.rng), globalenv = if (FALSE) 
[16:05:58.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:58.472]                     ...future.globalenv.names))
[16:05:58.472]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:58.472]         }, condition = base::local({
[16:05:58.472]             c <- base::c
[16:05:58.472]             inherits <- base::inherits
[16:05:58.472]             invokeRestart <- base::invokeRestart
[16:05:58.472]             length <- base::length
[16:05:58.472]             list <- base::list
[16:05:58.472]             seq.int <- base::seq.int
[16:05:58.472]             signalCondition <- base::signalCondition
[16:05:58.472]             sys.calls <- base::sys.calls
[16:05:58.472]             `[[` <- base::`[[`
[16:05:58.472]             `+` <- base::`+`
[16:05:58.472]             `<<-` <- base::`<<-`
[16:05:58.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:58.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:58.472]                   3L)]
[16:05:58.472]             }
[16:05:58.472]             function(cond) {
[16:05:58.472]                 is_error <- inherits(cond, "error")
[16:05:58.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:58.472]                   NULL)
[16:05:58.472]                 if (is_error) {
[16:05:58.472]                   sessionInformation <- function() {
[16:05:58.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:58.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:58.472]                       search = base::search(), system = base::Sys.info())
[16:05:58.472]                   }
[16:05:58.472]                   ...future.conditions[[length(...future.conditions) + 
[16:05:58.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:58.472]                     cond$call), session = sessionInformation(), 
[16:05:58.472]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:58.472]                   signalCondition(cond)
[16:05:58.472]                 }
[16:05:58.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:58.472]                 "immediateCondition"))) {
[16:05:58.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:58.472]                   ...future.conditions[[length(...future.conditions) + 
[16:05:58.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:58.472]                   if (TRUE && !signal) {
[16:05:58.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:58.472]                     {
[16:05:58.472]                       inherits <- base::inherits
[16:05:58.472]                       invokeRestart <- base::invokeRestart
[16:05:58.472]                       is.null <- base::is.null
[16:05:58.472]                       muffled <- FALSE
[16:05:58.472]                       if (inherits(cond, "message")) {
[16:05:58.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:58.472]                         if (muffled) 
[16:05:58.472]                           invokeRestart("muffleMessage")
[16:05:58.472]                       }
[16:05:58.472]                       else if (inherits(cond, "warning")) {
[16:05:58.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:58.472]                         if (muffled) 
[16:05:58.472]                           invokeRestart("muffleWarning")
[16:05:58.472]                       }
[16:05:58.472]                       else if (inherits(cond, "condition")) {
[16:05:58.472]                         if (!is.null(pattern)) {
[16:05:58.472]                           computeRestarts <- base::computeRestarts
[16:05:58.472]                           grepl <- base::grepl
[16:05:58.472]                           restarts <- computeRestarts(cond)
[16:05:58.472]                           for (restart in restarts) {
[16:05:58.472]                             name <- restart$name
[16:05:58.472]                             if (is.null(name)) 
[16:05:58.472]                               next
[16:05:58.472]                             if (!grepl(pattern, name)) 
[16:05:58.472]                               next
[16:05:58.472]                             invokeRestart(restart)
[16:05:58.472]                             muffled <- TRUE
[16:05:58.472]                             break
[16:05:58.472]                           }
[16:05:58.472]                         }
[16:05:58.472]                       }
[16:05:58.472]                       invisible(muffled)
[16:05:58.472]                     }
[16:05:58.472]                     muffleCondition(cond, pattern = "^muffle")
[16:05:58.472]                   }
[16:05:58.472]                 }
[16:05:58.472]                 else {
[16:05:58.472]                   if (TRUE) {
[16:05:58.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:58.472]                     {
[16:05:58.472]                       inherits <- base::inherits
[16:05:58.472]                       invokeRestart <- base::invokeRestart
[16:05:58.472]                       is.null <- base::is.null
[16:05:58.472]                       muffled <- FALSE
[16:05:58.472]                       if (inherits(cond, "message")) {
[16:05:58.472]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:58.472]                         if (muffled) 
[16:05:58.472]                           invokeRestart("muffleMessage")
[16:05:58.472]                       }
[16:05:58.472]                       else if (inherits(cond, "warning")) {
[16:05:58.472]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:58.472]                         if (muffled) 
[16:05:58.472]                           invokeRestart("muffleWarning")
[16:05:58.472]                       }
[16:05:58.472]                       else if (inherits(cond, "condition")) {
[16:05:58.472]                         if (!is.null(pattern)) {
[16:05:58.472]                           computeRestarts <- base::computeRestarts
[16:05:58.472]                           grepl <- base::grepl
[16:05:58.472]                           restarts <- computeRestarts(cond)
[16:05:58.472]                           for (restart in restarts) {
[16:05:58.472]                             name <- restart$name
[16:05:58.472]                             if (is.null(name)) 
[16:05:58.472]                               next
[16:05:58.472]                             if (!grepl(pattern, name)) 
[16:05:58.472]                               next
[16:05:58.472]                             invokeRestart(restart)
[16:05:58.472]                             muffled <- TRUE
[16:05:58.472]                             break
[16:05:58.472]                           }
[16:05:58.472]                         }
[16:05:58.472]                       }
[16:05:58.472]                       invisible(muffled)
[16:05:58.472]                     }
[16:05:58.472]                     muffleCondition(cond, pattern = "^muffle")
[16:05:58.472]                   }
[16:05:58.472]                 }
[16:05:58.472]             }
[16:05:58.472]         }))
[16:05:58.472]     }, error = function(ex) {
[16:05:58.472]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:58.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:58.472]                 ...future.rng), started = ...future.startTime, 
[16:05:58.472]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:58.472]             version = "1.8"), class = "FutureResult")
[16:05:58.472]     }, finally = {
[16:05:58.472]         if (!identical(...future.workdir, getwd())) 
[16:05:58.472]             setwd(...future.workdir)
[16:05:58.472]         {
[16:05:58.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:58.472]                 ...future.oldOptions$nwarnings <- NULL
[16:05:58.472]             }
[16:05:58.472]             base::options(...future.oldOptions)
[16:05:58.472]             if (.Platform$OS.type == "windows") {
[16:05:58.472]                 old_names <- names(...future.oldEnvVars)
[16:05:58.472]                 envs <- base::Sys.getenv()
[16:05:58.472]                 names <- names(envs)
[16:05:58.472]                 common <- intersect(names, old_names)
[16:05:58.472]                 added <- setdiff(names, old_names)
[16:05:58.472]                 removed <- setdiff(old_names, names)
[16:05:58.472]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:58.472]                   envs[common]]
[16:05:58.472]                 NAMES <- toupper(changed)
[16:05:58.472]                 args <- list()
[16:05:58.472]                 for (kk in seq_along(NAMES)) {
[16:05:58.472]                   name <- changed[[kk]]
[16:05:58.472]                   NAME <- NAMES[[kk]]
[16:05:58.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:58.472]                     next
[16:05:58.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:58.472]                 }
[16:05:58.472]                 NAMES <- toupper(added)
[16:05:58.472]                 for (kk in seq_along(NAMES)) {
[16:05:58.472]                   name <- added[[kk]]
[16:05:58.472]                   NAME <- NAMES[[kk]]
[16:05:58.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:58.472]                     next
[16:05:58.472]                   args[[name]] <- ""
[16:05:58.472]                 }
[16:05:58.472]                 NAMES <- toupper(removed)
[16:05:58.472]                 for (kk in seq_along(NAMES)) {
[16:05:58.472]                   name <- removed[[kk]]
[16:05:58.472]                   NAME <- NAMES[[kk]]
[16:05:58.472]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:58.472]                     next
[16:05:58.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:58.472]                 }
[16:05:58.472]                 if (length(args) > 0) 
[16:05:58.472]                   base::do.call(base::Sys.setenv, args = args)
[16:05:58.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:58.472]             }
[16:05:58.472]             else {
[16:05:58.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:58.472]             }
[16:05:58.472]             {
[16:05:58.472]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:58.472]                   0L) {
[16:05:58.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:58.472]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:58.472]                   base::options(opts)
[16:05:58.472]                 }
[16:05:58.472]                 {
[16:05:58.472]                   {
[16:05:58.472]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:58.472]                     NULL
[16:05:58.472]                   }
[16:05:58.472]                   options(future.plan = NULL)
[16:05:58.472]                   if (is.na(NA_character_)) 
[16:05:58.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:58.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:58.472]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:58.472]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:58.472]                     envir = parent.frame()) 
[16:05:58.472]                   {
[16:05:58.472]                     if (is.function(workers)) 
[16:05:58.472]                       workers <- workers()
[16:05:58.472]                     workers <- structure(as.integer(workers), 
[16:05:58.472]                       class = class(workers))
[16:05:58.472]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:58.472]                       workers >= 1)
[16:05:58.472]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:58.472]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:58.472]                     }
[16:05:58.472]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:58.472]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:58.472]                       envir = envir)
[16:05:58.472]                     if (!future$lazy) 
[16:05:58.472]                       future <- run(future)
[16:05:58.472]                     invisible(future)
[16:05:58.472]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:58.472]                 }
[16:05:58.472]             }
[16:05:58.472]         }
[16:05:58.472]     })
[16:05:58.472]     if (TRUE) {
[16:05:58.472]         base::sink(type = "output", split = FALSE)
[16:05:58.472]         if (TRUE) {
[16:05:58.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:58.472]         }
[16:05:58.472]         else {
[16:05:58.472]             ...future.result["stdout"] <- base::list(NULL)
[16:05:58.472]         }
[16:05:58.472]         base::close(...future.stdout)
[16:05:58.472]         ...future.stdout <- NULL
[16:05:58.472]     }
[16:05:58.472]     ...future.result$conditions <- ...future.conditions
[16:05:58.472]     ...future.result$finished <- base::Sys.time()
[16:05:58.472]     ...future.result
[16:05:58.472] }
[16:05:58.526] MultisessionFuture started
[16:05:58.526] result() for ClusterFuture ...
[16:05:58.526] receiveMessageFromWorker() for ClusterFuture ...
[16:05:58.526] - Validating connection of MultisessionFuture
[16:05:58.569] - received message: FutureResult
[16:05:58.570] - Received FutureResult
[16:05:58.570] - Erased future from FutureRegistry
[16:05:58.570] result() for ClusterFuture ...
[16:05:58.570] - result already collected: FutureResult
[16:05:58.570] result() for ClusterFuture ... done
[16:05:58.570] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:58.570] result() for ClusterFuture ... done
[16:05:58.570] result() for ClusterFuture ...
[16:05:58.571] - result already collected: FutureResult
[16:05:58.571] result() for ClusterFuture ... done
[16:05:58.571] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:05:58.575] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[16:05:58.578] getGlobalsAndPackages() ...
[16:05:58.578] Searching for globals...
[16:05:58.580] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:05:58.580] Searching for globals ... DONE
[16:05:58.580] Resolving globals: FALSE
[16:05:58.580] 
[16:05:58.580] 
[16:05:58.581] getGlobalsAndPackages() ... DONE
[16:05:58.581] run() for ‘Future’ ...
[16:05:58.581] - state: ‘created’
[16:05:58.581] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:58.596] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:58.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:58.596]   - Field: ‘node’
[16:05:58.596]   - Field: ‘label’
[16:05:58.596]   - Field: ‘local’
[16:05:58.596]   - Field: ‘owner’
[16:05:58.596]   - Field: ‘envir’
[16:05:58.596]   - Field: ‘workers’
[16:05:58.596]   - Field: ‘packages’
[16:05:58.596]   - Field: ‘gc’
[16:05:58.597]   - Field: ‘conditions’
[16:05:58.597]   - Field: ‘persistent’
[16:05:58.597]   - Field: ‘expr’
[16:05:58.597]   - Field: ‘uuid’
[16:05:58.597]   - Field: ‘seed’
[16:05:58.597]   - Field: ‘version’
[16:05:58.597]   - Field: ‘result’
[16:05:58.597]   - Field: ‘asynchronous’
[16:05:58.598]   - Field: ‘calls’
[16:05:58.598]   - Field: ‘globals’
[16:05:58.598]   - Field: ‘stdout’
[16:05:58.598]   - Field: ‘earlySignal’
[16:05:58.598]   - Field: ‘lazy’
[16:05:58.598]   - Field: ‘state’
[16:05:58.598] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:58.598] - Launch lazy future ...
[16:05:58.599] Packages needed by the future expression (n = 0): <none>
[16:05:58.599] Packages needed by future strategies (n = 0): <none>
[16:05:58.599] {
[16:05:58.599]     {
[16:05:58.599]         {
[16:05:58.599]             ...future.startTime <- base::Sys.time()
[16:05:58.599]             {
[16:05:58.599]                 {
[16:05:58.599]                   {
[16:05:58.599]                     {
[16:05:58.599]                       base::local({
[16:05:58.599]                         has_future <- base::requireNamespace("future", 
[16:05:58.599]                           quietly = TRUE)
[16:05:58.599]                         if (has_future) {
[16:05:58.599]                           ns <- base::getNamespace("future")
[16:05:58.599]                           version <- ns[[".package"]][["version"]]
[16:05:58.599]                           if (is.null(version)) 
[16:05:58.599]                             version <- utils::packageVersion("future")
[16:05:58.599]                         }
[16:05:58.599]                         else {
[16:05:58.599]                           version <- NULL
[16:05:58.599]                         }
[16:05:58.599]                         if (!has_future || version < "1.8.0") {
[16:05:58.599]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:58.599]                             "", base::R.version$version.string), 
[16:05:58.599]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:58.599]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:58.599]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:58.599]                               "release", "version")], collapse = " "), 
[16:05:58.599]                             hostname = base::Sys.info()[["nodename"]])
[16:05:58.599]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:58.599]                             info)
[16:05:58.599]                           info <- base::paste(info, collapse = "; ")
[16:05:58.599]                           if (!has_future) {
[16:05:58.599]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:58.599]                               info)
[16:05:58.599]                           }
[16:05:58.599]                           else {
[16:05:58.599]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:58.599]                               info, version)
[16:05:58.599]                           }
[16:05:58.599]                           base::stop(msg)
[16:05:58.599]                         }
[16:05:58.599]                       })
[16:05:58.599]                     }
[16:05:58.599]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:58.599]                     base::options(mc.cores = 1L)
[16:05:58.599]                   }
[16:05:58.599]                   options(future.plan = NULL)
[16:05:58.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:58.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:58.599]                 }
[16:05:58.599]                 ...future.workdir <- getwd()
[16:05:58.599]             }
[16:05:58.599]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:58.599]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:58.599]         }
[16:05:58.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:58.599]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:58.599]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:58.599]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:58.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:58.599]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:58.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:58.599]             base::names(...future.oldOptions))
[16:05:58.599]     }
[16:05:58.599]     if (FALSE) {
[16:05:58.599]     }
[16:05:58.599]     else {
[16:05:58.599]         if (TRUE) {
[16:05:58.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:58.599]                 open = "w")
[16:05:58.599]         }
[16:05:58.599]         else {
[16:05:58.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:58.599]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:58.599]         }
[16:05:58.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:58.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:58.599]             base::sink(type = "output", split = FALSE)
[16:05:58.599]             base::close(...future.stdout)
[16:05:58.599]         }, add = TRUE)
[16:05:58.599]     }
[16:05:58.599]     ...future.frame <- base::sys.nframe()
[16:05:58.599]     ...future.conditions <- base::list()
[16:05:58.599]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:58.599]     if (FALSE) {
[16:05:58.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:58.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:58.599]     }
[16:05:58.599]     ...future.result <- base::tryCatch({
[16:05:58.599]         base::withCallingHandlers({
[16:05:58.599]             ...future.value <- base::withVisible(base::local({
[16:05:58.599]                 ...future.makeSendCondition <- base::local({
[16:05:58.599]                   sendCondition <- NULL
[16:05:58.599]                   function(frame = 1L) {
[16:05:58.599]                     if (is.function(sendCondition)) 
[16:05:58.599]                       return(sendCondition)
[16:05:58.599]                     ns <- getNamespace("parallel")
[16:05:58.599]                     if (exists("sendData", mode = "function", 
[16:05:58.599]                       envir = ns)) {
[16:05:58.599]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:58.599]                         envir = ns)
[16:05:58.599]                       envir <- sys.frame(frame)
[16:05:58.599]                       master <- NULL
[16:05:58.599]                       while (!identical(envir, .GlobalEnv) && 
[16:05:58.599]                         !identical(envir, emptyenv())) {
[16:05:58.599]                         if (exists("master", mode = "list", envir = envir, 
[16:05:58.599]                           inherits = FALSE)) {
[16:05:58.599]                           master <- get("master", mode = "list", 
[16:05:58.599]                             envir = envir, inherits = FALSE)
[16:05:58.599]                           if (inherits(master, c("SOCKnode", 
[16:05:58.599]                             "SOCK0node"))) {
[16:05:58.599]                             sendCondition <<- function(cond) {
[16:05:58.599]                               data <- list(type = "VALUE", value = cond, 
[16:05:58.599]                                 success = TRUE)
[16:05:58.599]                               parallel_sendData(master, data)
[16:05:58.599]                             }
[16:05:58.599]                             return(sendCondition)
[16:05:58.599]                           }
[16:05:58.599]                         }
[16:05:58.599]                         frame <- frame + 1L
[16:05:58.599]                         envir <- sys.frame(frame)
[16:05:58.599]                       }
[16:05:58.599]                     }
[16:05:58.599]                     sendCondition <<- function(cond) NULL
[16:05:58.599]                   }
[16:05:58.599]                 })
[16:05:58.599]                 withCallingHandlers({
[16:05:58.599]                   {
[16:05:58.599]                     Sys.sleep(0.5)
[16:05:58.599]                     list(a = 1, b = 42L)
[16:05:58.599]                   }
[16:05:58.599]                 }, immediateCondition = function(cond) {
[16:05:58.599]                   sendCondition <- ...future.makeSendCondition()
[16:05:58.599]                   sendCondition(cond)
[16:05:58.599]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:58.599]                   {
[16:05:58.599]                     inherits <- base::inherits
[16:05:58.599]                     invokeRestart <- base::invokeRestart
[16:05:58.599]                     is.null <- base::is.null
[16:05:58.599]                     muffled <- FALSE
[16:05:58.599]                     if (inherits(cond, "message")) {
[16:05:58.599]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:58.599]                       if (muffled) 
[16:05:58.599]                         invokeRestart("muffleMessage")
[16:05:58.599]                     }
[16:05:58.599]                     else if (inherits(cond, "warning")) {
[16:05:58.599]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:58.599]                       if (muffled) 
[16:05:58.599]                         invokeRestart("muffleWarning")
[16:05:58.599]                     }
[16:05:58.599]                     else if (inherits(cond, "condition")) {
[16:05:58.599]                       if (!is.null(pattern)) {
[16:05:58.599]                         computeRestarts <- base::computeRestarts
[16:05:58.599]                         grepl <- base::grepl
[16:05:58.599]                         restarts <- computeRestarts(cond)
[16:05:58.599]                         for (restart in restarts) {
[16:05:58.599]                           name <- restart$name
[16:05:58.599]                           if (is.null(name)) 
[16:05:58.599]                             next
[16:05:58.599]                           if (!grepl(pattern, name)) 
[16:05:58.599]                             next
[16:05:58.599]                           invokeRestart(restart)
[16:05:58.599]                           muffled <- TRUE
[16:05:58.599]                           break
[16:05:58.599]                         }
[16:05:58.599]                       }
[16:05:58.599]                     }
[16:05:58.599]                     invisible(muffled)
[16:05:58.599]                   }
[16:05:58.599]                   muffleCondition(cond)
[16:05:58.599]                 })
[16:05:58.599]             }))
[16:05:58.599]             future::FutureResult(value = ...future.value$value, 
[16:05:58.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:58.599]                   ...future.rng), globalenv = if (FALSE) 
[16:05:58.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:58.599]                     ...future.globalenv.names))
[16:05:58.599]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:58.599]         }, condition = base::local({
[16:05:58.599]             c <- base::c
[16:05:58.599]             inherits <- base::inherits
[16:05:58.599]             invokeRestart <- base::invokeRestart
[16:05:58.599]             length <- base::length
[16:05:58.599]             list <- base::list
[16:05:58.599]             seq.int <- base::seq.int
[16:05:58.599]             signalCondition <- base::signalCondition
[16:05:58.599]             sys.calls <- base::sys.calls
[16:05:58.599]             `[[` <- base::`[[`
[16:05:58.599]             `+` <- base::`+`
[16:05:58.599]             `<<-` <- base::`<<-`
[16:05:58.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:58.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:58.599]                   3L)]
[16:05:58.599]             }
[16:05:58.599]             function(cond) {
[16:05:58.599]                 is_error <- inherits(cond, "error")
[16:05:58.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:58.599]                   NULL)
[16:05:58.599]                 if (is_error) {
[16:05:58.599]                   sessionInformation <- function() {
[16:05:58.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:58.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:58.599]                       search = base::search(), system = base::Sys.info())
[16:05:58.599]                   }
[16:05:58.599]                   ...future.conditions[[length(...future.conditions) + 
[16:05:58.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:58.599]                     cond$call), session = sessionInformation(), 
[16:05:58.599]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:58.599]                   signalCondition(cond)
[16:05:58.599]                 }
[16:05:58.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:58.599]                 "immediateCondition"))) {
[16:05:58.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:58.599]                   ...future.conditions[[length(...future.conditions) + 
[16:05:58.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:58.599]                   if (TRUE && !signal) {
[16:05:58.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:58.599]                     {
[16:05:58.599]                       inherits <- base::inherits
[16:05:58.599]                       invokeRestart <- base::invokeRestart
[16:05:58.599]                       is.null <- base::is.null
[16:05:58.599]                       muffled <- FALSE
[16:05:58.599]                       if (inherits(cond, "message")) {
[16:05:58.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:58.599]                         if (muffled) 
[16:05:58.599]                           invokeRestart("muffleMessage")
[16:05:58.599]                       }
[16:05:58.599]                       else if (inherits(cond, "warning")) {
[16:05:58.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:58.599]                         if (muffled) 
[16:05:58.599]                           invokeRestart("muffleWarning")
[16:05:58.599]                       }
[16:05:58.599]                       else if (inherits(cond, "condition")) {
[16:05:58.599]                         if (!is.null(pattern)) {
[16:05:58.599]                           computeRestarts <- base::computeRestarts
[16:05:58.599]                           grepl <- base::grepl
[16:05:58.599]                           restarts <- computeRestarts(cond)
[16:05:58.599]                           for (restart in restarts) {
[16:05:58.599]                             name <- restart$name
[16:05:58.599]                             if (is.null(name)) 
[16:05:58.599]                               next
[16:05:58.599]                             if (!grepl(pattern, name)) 
[16:05:58.599]                               next
[16:05:58.599]                             invokeRestart(restart)
[16:05:58.599]                             muffled <- TRUE
[16:05:58.599]                             break
[16:05:58.599]                           }
[16:05:58.599]                         }
[16:05:58.599]                       }
[16:05:58.599]                       invisible(muffled)
[16:05:58.599]                     }
[16:05:58.599]                     muffleCondition(cond, pattern = "^muffle")
[16:05:58.599]                   }
[16:05:58.599]                 }
[16:05:58.599]                 else {
[16:05:58.599]                   if (TRUE) {
[16:05:58.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:58.599]                     {
[16:05:58.599]                       inherits <- base::inherits
[16:05:58.599]                       invokeRestart <- base::invokeRestart
[16:05:58.599]                       is.null <- base::is.null
[16:05:58.599]                       muffled <- FALSE
[16:05:58.599]                       if (inherits(cond, "message")) {
[16:05:58.599]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:58.599]                         if (muffled) 
[16:05:58.599]                           invokeRestart("muffleMessage")
[16:05:58.599]                       }
[16:05:58.599]                       else if (inherits(cond, "warning")) {
[16:05:58.599]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:58.599]                         if (muffled) 
[16:05:58.599]                           invokeRestart("muffleWarning")
[16:05:58.599]                       }
[16:05:58.599]                       else if (inherits(cond, "condition")) {
[16:05:58.599]                         if (!is.null(pattern)) {
[16:05:58.599]                           computeRestarts <- base::computeRestarts
[16:05:58.599]                           grepl <- base::grepl
[16:05:58.599]                           restarts <- computeRestarts(cond)
[16:05:58.599]                           for (restart in restarts) {
[16:05:58.599]                             name <- restart$name
[16:05:58.599]                             if (is.null(name)) 
[16:05:58.599]                               next
[16:05:58.599]                             if (!grepl(pattern, name)) 
[16:05:58.599]                               next
[16:05:58.599]                             invokeRestart(restart)
[16:05:58.599]                             muffled <- TRUE
[16:05:58.599]                             break
[16:05:58.599]                           }
[16:05:58.599]                         }
[16:05:58.599]                       }
[16:05:58.599]                       invisible(muffled)
[16:05:58.599]                     }
[16:05:58.599]                     muffleCondition(cond, pattern = "^muffle")
[16:05:58.599]                   }
[16:05:58.599]                 }
[16:05:58.599]             }
[16:05:58.599]         }))
[16:05:58.599]     }, error = function(ex) {
[16:05:58.599]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:58.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:58.599]                 ...future.rng), started = ...future.startTime, 
[16:05:58.599]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:58.599]             version = "1.8"), class = "FutureResult")
[16:05:58.599]     }, finally = {
[16:05:58.599]         if (!identical(...future.workdir, getwd())) 
[16:05:58.599]             setwd(...future.workdir)
[16:05:58.599]         {
[16:05:58.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:58.599]                 ...future.oldOptions$nwarnings <- NULL
[16:05:58.599]             }
[16:05:58.599]             base::options(...future.oldOptions)
[16:05:58.599]             if (.Platform$OS.type == "windows") {
[16:05:58.599]                 old_names <- names(...future.oldEnvVars)
[16:05:58.599]                 envs <- base::Sys.getenv()
[16:05:58.599]                 names <- names(envs)
[16:05:58.599]                 common <- intersect(names, old_names)
[16:05:58.599]                 added <- setdiff(names, old_names)
[16:05:58.599]                 removed <- setdiff(old_names, names)
[16:05:58.599]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:58.599]                   envs[common]]
[16:05:58.599]                 NAMES <- toupper(changed)
[16:05:58.599]                 args <- list()
[16:05:58.599]                 for (kk in seq_along(NAMES)) {
[16:05:58.599]                   name <- changed[[kk]]
[16:05:58.599]                   NAME <- NAMES[[kk]]
[16:05:58.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:58.599]                     next
[16:05:58.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:58.599]                 }
[16:05:58.599]                 NAMES <- toupper(added)
[16:05:58.599]                 for (kk in seq_along(NAMES)) {
[16:05:58.599]                   name <- added[[kk]]
[16:05:58.599]                   NAME <- NAMES[[kk]]
[16:05:58.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:58.599]                     next
[16:05:58.599]                   args[[name]] <- ""
[16:05:58.599]                 }
[16:05:58.599]                 NAMES <- toupper(removed)
[16:05:58.599]                 for (kk in seq_along(NAMES)) {
[16:05:58.599]                   name <- removed[[kk]]
[16:05:58.599]                   NAME <- NAMES[[kk]]
[16:05:58.599]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:58.599]                     next
[16:05:58.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:58.599]                 }
[16:05:58.599]                 if (length(args) > 0) 
[16:05:58.599]                   base::do.call(base::Sys.setenv, args = args)
[16:05:58.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:58.599]             }
[16:05:58.599]             else {
[16:05:58.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:58.599]             }
[16:05:58.599]             {
[16:05:58.599]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:58.599]                   0L) {
[16:05:58.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:58.599]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:58.599]                   base::options(opts)
[16:05:58.599]                 }
[16:05:58.599]                 {
[16:05:58.599]                   {
[16:05:58.599]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:58.599]                     NULL
[16:05:58.599]                   }
[16:05:58.599]                   options(future.plan = NULL)
[16:05:58.599]                   if (is.na(NA_character_)) 
[16:05:58.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:58.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:58.599]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:58.599]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:58.599]                     envir = parent.frame()) 
[16:05:58.599]                   {
[16:05:58.599]                     if (is.function(workers)) 
[16:05:58.599]                       workers <- workers()
[16:05:58.599]                     workers <- structure(as.integer(workers), 
[16:05:58.599]                       class = class(workers))
[16:05:58.599]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:58.599]                       workers >= 1)
[16:05:58.599]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:58.599]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:58.599]                     }
[16:05:58.599]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:58.599]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:58.599]                       envir = envir)
[16:05:58.599]                     if (!future$lazy) 
[16:05:58.599]                       future <- run(future)
[16:05:58.599]                     invisible(future)
[16:05:58.599]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:58.599]                 }
[16:05:58.599]             }
[16:05:58.599]         }
[16:05:58.599]     })
[16:05:58.599]     if (TRUE) {
[16:05:58.599]         base::sink(type = "output", split = FALSE)
[16:05:58.599]         if (TRUE) {
[16:05:58.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:58.599]         }
[16:05:58.599]         else {
[16:05:58.599]             ...future.result["stdout"] <- base::list(NULL)
[16:05:58.599]         }
[16:05:58.599]         base::close(...future.stdout)
[16:05:58.599]         ...future.stdout <- NULL
[16:05:58.599]     }
[16:05:58.599]     ...future.result$conditions <- ...future.conditions
[16:05:58.599]     ...future.result$finished <- base::Sys.time()
[16:05:58.599]     ...future.result
[16:05:58.599] }
[16:05:58.603] MultisessionFuture started
[16:05:58.603] - Launch lazy future ... done
[16:05:58.603] run() for ‘MultisessionFuture’ ... done
[16:05:59.149] receiveMessageFromWorker() for ClusterFuture ...
[16:05:59.149] - Validating connection of MultisessionFuture
[16:05:59.149] - received message: FutureResult
[16:05:59.149] - Received FutureResult
[16:05:59.149] - Erased future from FutureRegistry
[16:05:59.150] result() for ClusterFuture ...
[16:05:59.150] - result already collected: FutureResult
[16:05:59.150] result() for ClusterFuture ... done
[16:05:59.150] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:59.150] A MultisessionFuture was resolved (result was not collected)
[16:05:59.150] getGlobalsAndPackages() ...
[16:05:59.150] Searching for globals...
[16:05:59.152] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:05:59.152] Searching for globals ... DONE
[16:05:59.152] Resolving globals: FALSE
[16:05:59.153] 
[16:05:59.153] 
[16:05:59.153] getGlobalsAndPackages() ... DONE
[16:05:59.153] run() for ‘Future’ ...
[16:05:59.153] - state: ‘created’
[16:05:59.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:59.168] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:59.168] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:59.168]   - Field: ‘node’
[16:05:59.168]   - Field: ‘label’
[16:05:59.168]   - Field: ‘local’
[16:05:59.168]   - Field: ‘owner’
[16:05:59.169]   - Field: ‘envir’
[16:05:59.169]   - Field: ‘workers’
[16:05:59.169]   - Field: ‘packages’
[16:05:59.169]   - Field: ‘gc’
[16:05:59.169]   - Field: ‘conditions’
[16:05:59.169]   - Field: ‘persistent’
[16:05:59.169]   - Field: ‘expr’
[16:05:59.169]   - Field: ‘uuid’
[16:05:59.169]   - Field: ‘seed’
[16:05:59.170]   - Field: ‘version’
[16:05:59.170]   - Field: ‘result’
[16:05:59.170]   - Field: ‘asynchronous’
[16:05:59.170]   - Field: ‘calls’
[16:05:59.170]   - Field: ‘globals’
[16:05:59.170]   - Field: ‘stdout’
[16:05:59.170]   - Field: ‘earlySignal’
[16:05:59.170]   - Field: ‘lazy’
[16:05:59.170]   - Field: ‘state’
[16:05:59.171] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:59.171] - Launch lazy future ...
[16:05:59.171] Packages needed by the future expression (n = 0): <none>
[16:05:59.171] Packages needed by future strategies (n = 0): <none>
[16:05:59.172] {
[16:05:59.172]     {
[16:05:59.172]         {
[16:05:59.172]             ...future.startTime <- base::Sys.time()
[16:05:59.172]             {
[16:05:59.172]                 {
[16:05:59.172]                   {
[16:05:59.172]                     {
[16:05:59.172]                       base::local({
[16:05:59.172]                         has_future <- base::requireNamespace("future", 
[16:05:59.172]                           quietly = TRUE)
[16:05:59.172]                         if (has_future) {
[16:05:59.172]                           ns <- base::getNamespace("future")
[16:05:59.172]                           version <- ns[[".package"]][["version"]]
[16:05:59.172]                           if (is.null(version)) 
[16:05:59.172]                             version <- utils::packageVersion("future")
[16:05:59.172]                         }
[16:05:59.172]                         else {
[16:05:59.172]                           version <- NULL
[16:05:59.172]                         }
[16:05:59.172]                         if (!has_future || version < "1.8.0") {
[16:05:59.172]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:59.172]                             "", base::R.version$version.string), 
[16:05:59.172]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:59.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:59.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:59.172]                               "release", "version")], collapse = " "), 
[16:05:59.172]                             hostname = base::Sys.info()[["nodename"]])
[16:05:59.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:59.172]                             info)
[16:05:59.172]                           info <- base::paste(info, collapse = "; ")
[16:05:59.172]                           if (!has_future) {
[16:05:59.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:59.172]                               info)
[16:05:59.172]                           }
[16:05:59.172]                           else {
[16:05:59.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:59.172]                               info, version)
[16:05:59.172]                           }
[16:05:59.172]                           base::stop(msg)
[16:05:59.172]                         }
[16:05:59.172]                       })
[16:05:59.172]                     }
[16:05:59.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:59.172]                     base::options(mc.cores = 1L)
[16:05:59.172]                   }
[16:05:59.172]                   options(future.plan = NULL)
[16:05:59.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:59.172]                 }
[16:05:59.172]                 ...future.workdir <- getwd()
[16:05:59.172]             }
[16:05:59.172]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:59.172]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:59.172]         }
[16:05:59.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:59.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:59.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:59.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:59.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:59.172]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:59.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:59.172]             base::names(...future.oldOptions))
[16:05:59.172]     }
[16:05:59.172]     if (FALSE) {
[16:05:59.172]     }
[16:05:59.172]     else {
[16:05:59.172]         if (TRUE) {
[16:05:59.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:59.172]                 open = "w")
[16:05:59.172]         }
[16:05:59.172]         else {
[16:05:59.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:59.172]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:59.172]         }
[16:05:59.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:59.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:59.172]             base::sink(type = "output", split = FALSE)
[16:05:59.172]             base::close(...future.stdout)
[16:05:59.172]         }, add = TRUE)
[16:05:59.172]     }
[16:05:59.172]     ...future.frame <- base::sys.nframe()
[16:05:59.172]     ...future.conditions <- base::list()
[16:05:59.172]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:59.172]     if (FALSE) {
[16:05:59.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:59.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:59.172]     }
[16:05:59.172]     ...future.result <- base::tryCatch({
[16:05:59.172]         base::withCallingHandlers({
[16:05:59.172]             ...future.value <- base::withVisible(base::local({
[16:05:59.172]                 ...future.makeSendCondition <- base::local({
[16:05:59.172]                   sendCondition <- NULL
[16:05:59.172]                   function(frame = 1L) {
[16:05:59.172]                     if (is.function(sendCondition)) 
[16:05:59.172]                       return(sendCondition)
[16:05:59.172]                     ns <- getNamespace("parallel")
[16:05:59.172]                     if (exists("sendData", mode = "function", 
[16:05:59.172]                       envir = ns)) {
[16:05:59.172]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:59.172]                         envir = ns)
[16:05:59.172]                       envir <- sys.frame(frame)
[16:05:59.172]                       master <- NULL
[16:05:59.172]                       while (!identical(envir, .GlobalEnv) && 
[16:05:59.172]                         !identical(envir, emptyenv())) {
[16:05:59.172]                         if (exists("master", mode = "list", envir = envir, 
[16:05:59.172]                           inherits = FALSE)) {
[16:05:59.172]                           master <- get("master", mode = "list", 
[16:05:59.172]                             envir = envir, inherits = FALSE)
[16:05:59.172]                           if (inherits(master, c("SOCKnode", 
[16:05:59.172]                             "SOCK0node"))) {
[16:05:59.172]                             sendCondition <<- function(cond) {
[16:05:59.172]                               data <- list(type = "VALUE", value = cond, 
[16:05:59.172]                                 success = TRUE)
[16:05:59.172]                               parallel_sendData(master, data)
[16:05:59.172]                             }
[16:05:59.172]                             return(sendCondition)
[16:05:59.172]                           }
[16:05:59.172]                         }
[16:05:59.172]                         frame <- frame + 1L
[16:05:59.172]                         envir <- sys.frame(frame)
[16:05:59.172]                       }
[16:05:59.172]                     }
[16:05:59.172]                     sendCondition <<- function(cond) NULL
[16:05:59.172]                   }
[16:05:59.172]                 })
[16:05:59.172]                 withCallingHandlers({
[16:05:59.172]                   {
[16:05:59.172]                     Sys.sleep(0.5)
[16:05:59.172]                     list(a = 1, b = 42L)
[16:05:59.172]                   }
[16:05:59.172]                 }, immediateCondition = function(cond) {
[16:05:59.172]                   sendCondition <- ...future.makeSendCondition()
[16:05:59.172]                   sendCondition(cond)
[16:05:59.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.172]                   {
[16:05:59.172]                     inherits <- base::inherits
[16:05:59.172]                     invokeRestart <- base::invokeRestart
[16:05:59.172]                     is.null <- base::is.null
[16:05:59.172]                     muffled <- FALSE
[16:05:59.172]                     if (inherits(cond, "message")) {
[16:05:59.172]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:59.172]                       if (muffled) 
[16:05:59.172]                         invokeRestart("muffleMessage")
[16:05:59.172]                     }
[16:05:59.172]                     else if (inherits(cond, "warning")) {
[16:05:59.172]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:59.172]                       if (muffled) 
[16:05:59.172]                         invokeRestart("muffleWarning")
[16:05:59.172]                     }
[16:05:59.172]                     else if (inherits(cond, "condition")) {
[16:05:59.172]                       if (!is.null(pattern)) {
[16:05:59.172]                         computeRestarts <- base::computeRestarts
[16:05:59.172]                         grepl <- base::grepl
[16:05:59.172]                         restarts <- computeRestarts(cond)
[16:05:59.172]                         for (restart in restarts) {
[16:05:59.172]                           name <- restart$name
[16:05:59.172]                           if (is.null(name)) 
[16:05:59.172]                             next
[16:05:59.172]                           if (!grepl(pattern, name)) 
[16:05:59.172]                             next
[16:05:59.172]                           invokeRestart(restart)
[16:05:59.172]                           muffled <- TRUE
[16:05:59.172]                           break
[16:05:59.172]                         }
[16:05:59.172]                       }
[16:05:59.172]                     }
[16:05:59.172]                     invisible(muffled)
[16:05:59.172]                   }
[16:05:59.172]                   muffleCondition(cond)
[16:05:59.172]                 })
[16:05:59.172]             }))
[16:05:59.172]             future::FutureResult(value = ...future.value$value, 
[16:05:59.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.172]                   ...future.rng), globalenv = if (FALSE) 
[16:05:59.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:59.172]                     ...future.globalenv.names))
[16:05:59.172]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:59.172]         }, condition = base::local({
[16:05:59.172]             c <- base::c
[16:05:59.172]             inherits <- base::inherits
[16:05:59.172]             invokeRestart <- base::invokeRestart
[16:05:59.172]             length <- base::length
[16:05:59.172]             list <- base::list
[16:05:59.172]             seq.int <- base::seq.int
[16:05:59.172]             signalCondition <- base::signalCondition
[16:05:59.172]             sys.calls <- base::sys.calls
[16:05:59.172]             `[[` <- base::`[[`
[16:05:59.172]             `+` <- base::`+`
[16:05:59.172]             `<<-` <- base::`<<-`
[16:05:59.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:59.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:59.172]                   3L)]
[16:05:59.172]             }
[16:05:59.172]             function(cond) {
[16:05:59.172]                 is_error <- inherits(cond, "error")
[16:05:59.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:59.172]                   NULL)
[16:05:59.172]                 if (is_error) {
[16:05:59.172]                   sessionInformation <- function() {
[16:05:59.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:59.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:59.172]                       search = base::search(), system = base::Sys.info())
[16:05:59.172]                   }
[16:05:59.172]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:59.172]                     cond$call), session = sessionInformation(), 
[16:05:59.172]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:59.172]                   signalCondition(cond)
[16:05:59.172]                 }
[16:05:59.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:59.172]                 "immediateCondition"))) {
[16:05:59.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:59.172]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:59.172]                   if (TRUE && !signal) {
[16:05:59.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.172]                     {
[16:05:59.172]                       inherits <- base::inherits
[16:05:59.172]                       invokeRestart <- base::invokeRestart
[16:05:59.172]                       is.null <- base::is.null
[16:05:59.172]                       muffled <- FALSE
[16:05:59.172]                       if (inherits(cond, "message")) {
[16:05:59.172]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.172]                         if (muffled) 
[16:05:59.172]                           invokeRestart("muffleMessage")
[16:05:59.172]                       }
[16:05:59.172]                       else if (inherits(cond, "warning")) {
[16:05:59.172]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.172]                         if (muffled) 
[16:05:59.172]                           invokeRestart("muffleWarning")
[16:05:59.172]                       }
[16:05:59.172]                       else if (inherits(cond, "condition")) {
[16:05:59.172]                         if (!is.null(pattern)) {
[16:05:59.172]                           computeRestarts <- base::computeRestarts
[16:05:59.172]                           grepl <- base::grepl
[16:05:59.172]                           restarts <- computeRestarts(cond)
[16:05:59.172]                           for (restart in restarts) {
[16:05:59.172]                             name <- restart$name
[16:05:59.172]                             if (is.null(name)) 
[16:05:59.172]                               next
[16:05:59.172]                             if (!grepl(pattern, name)) 
[16:05:59.172]                               next
[16:05:59.172]                             invokeRestart(restart)
[16:05:59.172]                             muffled <- TRUE
[16:05:59.172]                             break
[16:05:59.172]                           }
[16:05:59.172]                         }
[16:05:59.172]                       }
[16:05:59.172]                       invisible(muffled)
[16:05:59.172]                     }
[16:05:59.172]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.172]                   }
[16:05:59.172]                 }
[16:05:59.172]                 else {
[16:05:59.172]                   if (TRUE) {
[16:05:59.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.172]                     {
[16:05:59.172]                       inherits <- base::inherits
[16:05:59.172]                       invokeRestart <- base::invokeRestart
[16:05:59.172]                       is.null <- base::is.null
[16:05:59.172]                       muffled <- FALSE
[16:05:59.172]                       if (inherits(cond, "message")) {
[16:05:59.172]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.172]                         if (muffled) 
[16:05:59.172]                           invokeRestart("muffleMessage")
[16:05:59.172]                       }
[16:05:59.172]                       else if (inherits(cond, "warning")) {
[16:05:59.172]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.172]                         if (muffled) 
[16:05:59.172]                           invokeRestart("muffleWarning")
[16:05:59.172]                       }
[16:05:59.172]                       else if (inherits(cond, "condition")) {
[16:05:59.172]                         if (!is.null(pattern)) {
[16:05:59.172]                           computeRestarts <- base::computeRestarts
[16:05:59.172]                           grepl <- base::grepl
[16:05:59.172]                           restarts <- computeRestarts(cond)
[16:05:59.172]                           for (restart in restarts) {
[16:05:59.172]                             name <- restart$name
[16:05:59.172]                             if (is.null(name)) 
[16:05:59.172]                               next
[16:05:59.172]                             if (!grepl(pattern, name)) 
[16:05:59.172]                               next
[16:05:59.172]                             invokeRestart(restart)
[16:05:59.172]                             muffled <- TRUE
[16:05:59.172]                             break
[16:05:59.172]                           }
[16:05:59.172]                         }
[16:05:59.172]                       }
[16:05:59.172]                       invisible(muffled)
[16:05:59.172]                     }
[16:05:59.172]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.172]                   }
[16:05:59.172]                 }
[16:05:59.172]             }
[16:05:59.172]         }))
[16:05:59.172]     }, error = function(ex) {
[16:05:59.172]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:59.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.172]                 ...future.rng), started = ...future.startTime, 
[16:05:59.172]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:59.172]             version = "1.8"), class = "FutureResult")
[16:05:59.172]     }, finally = {
[16:05:59.172]         if (!identical(...future.workdir, getwd())) 
[16:05:59.172]             setwd(...future.workdir)
[16:05:59.172]         {
[16:05:59.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:59.172]                 ...future.oldOptions$nwarnings <- NULL
[16:05:59.172]             }
[16:05:59.172]             base::options(...future.oldOptions)
[16:05:59.172]             if (.Platform$OS.type == "windows") {
[16:05:59.172]                 old_names <- names(...future.oldEnvVars)
[16:05:59.172]                 envs <- base::Sys.getenv()
[16:05:59.172]                 names <- names(envs)
[16:05:59.172]                 common <- intersect(names, old_names)
[16:05:59.172]                 added <- setdiff(names, old_names)
[16:05:59.172]                 removed <- setdiff(old_names, names)
[16:05:59.172]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:59.172]                   envs[common]]
[16:05:59.172]                 NAMES <- toupper(changed)
[16:05:59.172]                 args <- list()
[16:05:59.172]                 for (kk in seq_along(NAMES)) {
[16:05:59.172]                   name <- changed[[kk]]
[16:05:59.172]                   NAME <- NAMES[[kk]]
[16:05:59.172]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.172]                     next
[16:05:59.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.172]                 }
[16:05:59.172]                 NAMES <- toupper(added)
[16:05:59.172]                 for (kk in seq_along(NAMES)) {
[16:05:59.172]                   name <- added[[kk]]
[16:05:59.172]                   NAME <- NAMES[[kk]]
[16:05:59.172]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.172]                     next
[16:05:59.172]                   args[[name]] <- ""
[16:05:59.172]                 }
[16:05:59.172]                 NAMES <- toupper(removed)
[16:05:59.172]                 for (kk in seq_along(NAMES)) {
[16:05:59.172]                   name <- removed[[kk]]
[16:05:59.172]                   NAME <- NAMES[[kk]]
[16:05:59.172]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.172]                     next
[16:05:59.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.172]                 }
[16:05:59.172]                 if (length(args) > 0) 
[16:05:59.172]                   base::do.call(base::Sys.setenv, args = args)
[16:05:59.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:59.172]             }
[16:05:59.172]             else {
[16:05:59.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:59.172]             }
[16:05:59.172]             {
[16:05:59.172]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:59.172]                   0L) {
[16:05:59.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:59.172]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:59.172]                   base::options(opts)
[16:05:59.172]                 }
[16:05:59.172]                 {
[16:05:59.172]                   {
[16:05:59.172]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:59.172]                     NULL
[16:05:59.172]                   }
[16:05:59.172]                   options(future.plan = NULL)
[16:05:59.172]                   if (is.na(NA_character_)) 
[16:05:59.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:59.172]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:59.172]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:59.172]                     envir = parent.frame()) 
[16:05:59.172]                   {
[16:05:59.172]                     if (is.function(workers)) 
[16:05:59.172]                       workers <- workers()
[16:05:59.172]                     workers <- structure(as.integer(workers), 
[16:05:59.172]                       class = class(workers))
[16:05:59.172]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:59.172]                       workers >= 1)
[16:05:59.172]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:59.172]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:59.172]                     }
[16:05:59.172]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:59.172]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:59.172]                       envir = envir)
[16:05:59.172]                     if (!future$lazy) 
[16:05:59.172]                       future <- run(future)
[16:05:59.172]                     invisible(future)
[16:05:59.172]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:59.172]                 }
[16:05:59.172]             }
[16:05:59.172]         }
[16:05:59.172]     })
[16:05:59.172]     if (TRUE) {
[16:05:59.172]         base::sink(type = "output", split = FALSE)
[16:05:59.172]         if (TRUE) {
[16:05:59.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:59.172]         }
[16:05:59.172]         else {
[16:05:59.172]             ...future.result["stdout"] <- base::list(NULL)
[16:05:59.172]         }
[16:05:59.172]         base::close(...future.stdout)
[16:05:59.172]         ...future.stdout <- NULL
[16:05:59.172]     }
[16:05:59.172]     ...future.result$conditions <- ...future.conditions
[16:05:59.172]     ...future.result$finished <- base::Sys.time()
[16:05:59.172]     ...future.result
[16:05:59.172] }
[16:05:59.175] MultisessionFuture started
[16:05:59.175] - Launch lazy future ... done
[16:05:59.175] run() for ‘MultisessionFuture’ ... done
[16:05:59.734] receiveMessageFromWorker() for ClusterFuture ...
[16:05:59.734] - Validating connection of MultisessionFuture
[16:05:59.735] - received message: FutureResult
[16:05:59.735] - Received FutureResult
[16:05:59.735] - Erased future from FutureRegistry
[16:05:59.735] result() for ClusterFuture ...
[16:05:59.735] - result already collected: FutureResult
[16:05:59.735] result() for ClusterFuture ... done
[16:05:59.735] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:59.735] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:05:59.736] getGlobalsAndPackages() ...
[16:05:59.736] Searching for globals...
[16:05:59.737] - globals found: [2] ‘list’, ‘stop’
[16:05:59.737] Searching for globals ... DONE
[16:05:59.737] Resolving globals: FALSE
[16:05:59.737] 
[16:05:59.737] 
[16:05:59.737] getGlobalsAndPackages() ... DONE
[16:05:59.738] run() for ‘Future’ ...
[16:05:59.738] - state: ‘created’
[16:05:59.738] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:59.754] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:59.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:59.754]   - Field: ‘node’
[16:05:59.754]   - Field: ‘label’
[16:05:59.754]   - Field: ‘local’
[16:05:59.754]   - Field: ‘owner’
[16:05:59.754]   - Field: ‘envir’
[16:05:59.755]   - Field: ‘workers’
[16:05:59.755]   - Field: ‘packages’
[16:05:59.755]   - Field: ‘gc’
[16:05:59.755]   - Field: ‘conditions’
[16:05:59.755]   - Field: ‘persistent’
[16:05:59.755]   - Field: ‘expr’
[16:05:59.755]   - Field: ‘uuid’
[16:05:59.755]   - Field: ‘seed’
[16:05:59.755]   - Field: ‘version’
[16:05:59.755]   - Field: ‘result’
[16:05:59.755]   - Field: ‘asynchronous’
[16:05:59.756]   - Field: ‘calls’
[16:05:59.756]   - Field: ‘globals’
[16:05:59.756]   - Field: ‘stdout’
[16:05:59.756]   - Field: ‘earlySignal’
[16:05:59.756]   - Field: ‘lazy’
[16:05:59.756]   - Field: ‘state’
[16:05:59.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:59.756] - Launch lazy future ...
[16:05:59.756] Packages needed by the future expression (n = 0): <none>
[16:05:59.757] Packages needed by future strategies (n = 0): <none>
[16:05:59.757] {
[16:05:59.757]     {
[16:05:59.757]         {
[16:05:59.757]             ...future.startTime <- base::Sys.time()
[16:05:59.757]             {
[16:05:59.757]                 {
[16:05:59.757]                   {
[16:05:59.757]                     {
[16:05:59.757]                       base::local({
[16:05:59.757]                         has_future <- base::requireNamespace("future", 
[16:05:59.757]                           quietly = TRUE)
[16:05:59.757]                         if (has_future) {
[16:05:59.757]                           ns <- base::getNamespace("future")
[16:05:59.757]                           version <- ns[[".package"]][["version"]]
[16:05:59.757]                           if (is.null(version)) 
[16:05:59.757]                             version <- utils::packageVersion("future")
[16:05:59.757]                         }
[16:05:59.757]                         else {
[16:05:59.757]                           version <- NULL
[16:05:59.757]                         }
[16:05:59.757]                         if (!has_future || version < "1.8.0") {
[16:05:59.757]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:59.757]                             "", base::R.version$version.string), 
[16:05:59.757]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:59.757]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:59.757]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:59.757]                               "release", "version")], collapse = " "), 
[16:05:59.757]                             hostname = base::Sys.info()[["nodename"]])
[16:05:59.757]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:59.757]                             info)
[16:05:59.757]                           info <- base::paste(info, collapse = "; ")
[16:05:59.757]                           if (!has_future) {
[16:05:59.757]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:59.757]                               info)
[16:05:59.757]                           }
[16:05:59.757]                           else {
[16:05:59.757]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:59.757]                               info, version)
[16:05:59.757]                           }
[16:05:59.757]                           base::stop(msg)
[16:05:59.757]                         }
[16:05:59.757]                       })
[16:05:59.757]                     }
[16:05:59.757]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:59.757]                     base::options(mc.cores = 1L)
[16:05:59.757]                   }
[16:05:59.757]                   options(future.plan = NULL)
[16:05:59.757]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.757]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:59.757]                 }
[16:05:59.757]                 ...future.workdir <- getwd()
[16:05:59.757]             }
[16:05:59.757]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:59.757]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:59.757]         }
[16:05:59.757]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:59.757]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:59.757]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:59.757]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:59.757]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:59.757]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:59.757]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:59.757]             base::names(...future.oldOptions))
[16:05:59.757]     }
[16:05:59.757]     if (FALSE) {
[16:05:59.757]     }
[16:05:59.757]     else {
[16:05:59.757]         if (TRUE) {
[16:05:59.757]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:59.757]                 open = "w")
[16:05:59.757]         }
[16:05:59.757]         else {
[16:05:59.757]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:59.757]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:59.757]         }
[16:05:59.757]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:59.757]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:59.757]             base::sink(type = "output", split = FALSE)
[16:05:59.757]             base::close(...future.stdout)
[16:05:59.757]         }, add = TRUE)
[16:05:59.757]     }
[16:05:59.757]     ...future.frame <- base::sys.nframe()
[16:05:59.757]     ...future.conditions <- base::list()
[16:05:59.757]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:59.757]     if (FALSE) {
[16:05:59.757]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:59.757]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:59.757]     }
[16:05:59.757]     ...future.result <- base::tryCatch({
[16:05:59.757]         base::withCallingHandlers({
[16:05:59.757]             ...future.value <- base::withVisible(base::local({
[16:05:59.757]                 ...future.makeSendCondition <- base::local({
[16:05:59.757]                   sendCondition <- NULL
[16:05:59.757]                   function(frame = 1L) {
[16:05:59.757]                     if (is.function(sendCondition)) 
[16:05:59.757]                       return(sendCondition)
[16:05:59.757]                     ns <- getNamespace("parallel")
[16:05:59.757]                     if (exists("sendData", mode = "function", 
[16:05:59.757]                       envir = ns)) {
[16:05:59.757]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:59.757]                         envir = ns)
[16:05:59.757]                       envir <- sys.frame(frame)
[16:05:59.757]                       master <- NULL
[16:05:59.757]                       while (!identical(envir, .GlobalEnv) && 
[16:05:59.757]                         !identical(envir, emptyenv())) {
[16:05:59.757]                         if (exists("master", mode = "list", envir = envir, 
[16:05:59.757]                           inherits = FALSE)) {
[16:05:59.757]                           master <- get("master", mode = "list", 
[16:05:59.757]                             envir = envir, inherits = FALSE)
[16:05:59.757]                           if (inherits(master, c("SOCKnode", 
[16:05:59.757]                             "SOCK0node"))) {
[16:05:59.757]                             sendCondition <<- function(cond) {
[16:05:59.757]                               data <- list(type = "VALUE", value = cond, 
[16:05:59.757]                                 success = TRUE)
[16:05:59.757]                               parallel_sendData(master, data)
[16:05:59.757]                             }
[16:05:59.757]                             return(sendCondition)
[16:05:59.757]                           }
[16:05:59.757]                         }
[16:05:59.757]                         frame <- frame + 1L
[16:05:59.757]                         envir <- sys.frame(frame)
[16:05:59.757]                       }
[16:05:59.757]                     }
[16:05:59.757]                     sendCondition <<- function(cond) NULL
[16:05:59.757]                   }
[16:05:59.757]                 })
[16:05:59.757]                 withCallingHandlers({
[16:05:59.757]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:05:59.757]                 }, immediateCondition = function(cond) {
[16:05:59.757]                   sendCondition <- ...future.makeSendCondition()
[16:05:59.757]                   sendCondition(cond)
[16:05:59.757]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.757]                   {
[16:05:59.757]                     inherits <- base::inherits
[16:05:59.757]                     invokeRestart <- base::invokeRestart
[16:05:59.757]                     is.null <- base::is.null
[16:05:59.757]                     muffled <- FALSE
[16:05:59.757]                     if (inherits(cond, "message")) {
[16:05:59.757]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:59.757]                       if (muffled) 
[16:05:59.757]                         invokeRestart("muffleMessage")
[16:05:59.757]                     }
[16:05:59.757]                     else if (inherits(cond, "warning")) {
[16:05:59.757]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:59.757]                       if (muffled) 
[16:05:59.757]                         invokeRestart("muffleWarning")
[16:05:59.757]                     }
[16:05:59.757]                     else if (inherits(cond, "condition")) {
[16:05:59.757]                       if (!is.null(pattern)) {
[16:05:59.757]                         computeRestarts <- base::computeRestarts
[16:05:59.757]                         grepl <- base::grepl
[16:05:59.757]                         restarts <- computeRestarts(cond)
[16:05:59.757]                         for (restart in restarts) {
[16:05:59.757]                           name <- restart$name
[16:05:59.757]                           if (is.null(name)) 
[16:05:59.757]                             next
[16:05:59.757]                           if (!grepl(pattern, name)) 
[16:05:59.757]                             next
[16:05:59.757]                           invokeRestart(restart)
[16:05:59.757]                           muffled <- TRUE
[16:05:59.757]                           break
[16:05:59.757]                         }
[16:05:59.757]                       }
[16:05:59.757]                     }
[16:05:59.757]                     invisible(muffled)
[16:05:59.757]                   }
[16:05:59.757]                   muffleCondition(cond)
[16:05:59.757]                 })
[16:05:59.757]             }))
[16:05:59.757]             future::FutureResult(value = ...future.value$value, 
[16:05:59.757]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.757]                   ...future.rng), globalenv = if (FALSE) 
[16:05:59.757]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:59.757]                     ...future.globalenv.names))
[16:05:59.757]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:59.757]         }, condition = base::local({
[16:05:59.757]             c <- base::c
[16:05:59.757]             inherits <- base::inherits
[16:05:59.757]             invokeRestart <- base::invokeRestart
[16:05:59.757]             length <- base::length
[16:05:59.757]             list <- base::list
[16:05:59.757]             seq.int <- base::seq.int
[16:05:59.757]             signalCondition <- base::signalCondition
[16:05:59.757]             sys.calls <- base::sys.calls
[16:05:59.757]             `[[` <- base::`[[`
[16:05:59.757]             `+` <- base::`+`
[16:05:59.757]             `<<-` <- base::`<<-`
[16:05:59.757]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:59.757]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:59.757]                   3L)]
[16:05:59.757]             }
[16:05:59.757]             function(cond) {
[16:05:59.757]                 is_error <- inherits(cond, "error")
[16:05:59.757]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:59.757]                   NULL)
[16:05:59.757]                 if (is_error) {
[16:05:59.757]                   sessionInformation <- function() {
[16:05:59.757]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:59.757]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:59.757]                       search = base::search(), system = base::Sys.info())
[16:05:59.757]                   }
[16:05:59.757]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.757]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:59.757]                     cond$call), session = sessionInformation(), 
[16:05:59.757]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:59.757]                   signalCondition(cond)
[16:05:59.757]                 }
[16:05:59.757]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:59.757]                 "immediateCondition"))) {
[16:05:59.757]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:59.757]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.757]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:59.757]                   if (TRUE && !signal) {
[16:05:59.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.757]                     {
[16:05:59.757]                       inherits <- base::inherits
[16:05:59.757]                       invokeRestart <- base::invokeRestart
[16:05:59.757]                       is.null <- base::is.null
[16:05:59.757]                       muffled <- FALSE
[16:05:59.757]                       if (inherits(cond, "message")) {
[16:05:59.757]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.757]                         if (muffled) 
[16:05:59.757]                           invokeRestart("muffleMessage")
[16:05:59.757]                       }
[16:05:59.757]                       else if (inherits(cond, "warning")) {
[16:05:59.757]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.757]                         if (muffled) 
[16:05:59.757]                           invokeRestart("muffleWarning")
[16:05:59.757]                       }
[16:05:59.757]                       else if (inherits(cond, "condition")) {
[16:05:59.757]                         if (!is.null(pattern)) {
[16:05:59.757]                           computeRestarts <- base::computeRestarts
[16:05:59.757]                           grepl <- base::grepl
[16:05:59.757]                           restarts <- computeRestarts(cond)
[16:05:59.757]                           for (restart in restarts) {
[16:05:59.757]                             name <- restart$name
[16:05:59.757]                             if (is.null(name)) 
[16:05:59.757]                               next
[16:05:59.757]                             if (!grepl(pattern, name)) 
[16:05:59.757]                               next
[16:05:59.757]                             invokeRestart(restart)
[16:05:59.757]                             muffled <- TRUE
[16:05:59.757]                             break
[16:05:59.757]                           }
[16:05:59.757]                         }
[16:05:59.757]                       }
[16:05:59.757]                       invisible(muffled)
[16:05:59.757]                     }
[16:05:59.757]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.757]                   }
[16:05:59.757]                 }
[16:05:59.757]                 else {
[16:05:59.757]                   if (TRUE) {
[16:05:59.757]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.757]                     {
[16:05:59.757]                       inherits <- base::inherits
[16:05:59.757]                       invokeRestart <- base::invokeRestart
[16:05:59.757]                       is.null <- base::is.null
[16:05:59.757]                       muffled <- FALSE
[16:05:59.757]                       if (inherits(cond, "message")) {
[16:05:59.757]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.757]                         if (muffled) 
[16:05:59.757]                           invokeRestart("muffleMessage")
[16:05:59.757]                       }
[16:05:59.757]                       else if (inherits(cond, "warning")) {
[16:05:59.757]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.757]                         if (muffled) 
[16:05:59.757]                           invokeRestart("muffleWarning")
[16:05:59.757]                       }
[16:05:59.757]                       else if (inherits(cond, "condition")) {
[16:05:59.757]                         if (!is.null(pattern)) {
[16:05:59.757]                           computeRestarts <- base::computeRestarts
[16:05:59.757]                           grepl <- base::grepl
[16:05:59.757]                           restarts <- computeRestarts(cond)
[16:05:59.757]                           for (restart in restarts) {
[16:05:59.757]                             name <- restart$name
[16:05:59.757]                             if (is.null(name)) 
[16:05:59.757]                               next
[16:05:59.757]                             if (!grepl(pattern, name)) 
[16:05:59.757]                               next
[16:05:59.757]                             invokeRestart(restart)
[16:05:59.757]                             muffled <- TRUE
[16:05:59.757]                             break
[16:05:59.757]                           }
[16:05:59.757]                         }
[16:05:59.757]                       }
[16:05:59.757]                       invisible(muffled)
[16:05:59.757]                     }
[16:05:59.757]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.757]                   }
[16:05:59.757]                 }
[16:05:59.757]             }
[16:05:59.757]         }))
[16:05:59.757]     }, error = function(ex) {
[16:05:59.757]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:59.757]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.757]                 ...future.rng), started = ...future.startTime, 
[16:05:59.757]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:59.757]             version = "1.8"), class = "FutureResult")
[16:05:59.757]     }, finally = {
[16:05:59.757]         if (!identical(...future.workdir, getwd())) 
[16:05:59.757]             setwd(...future.workdir)
[16:05:59.757]         {
[16:05:59.757]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:59.757]                 ...future.oldOptions$nwarnings <- NULL
[16:05:59.757]             }
[16:05:59.757]             base::options(...future.oldOptions)
[16:05:59.757]             if (.Platform$OS.type == "windows") {
[16:05:59.757]                 old_names <- names(...future.oldEnvVars)
[16:05:59.757]                 envs <- base::Sys.getenv()
[16:05:59.757]                 names <- names(envs)
[16:05:59.757]                 common <- intersect(names, old_names)
[16:05:59.757]                 added <- setdiff(names, old_names)
[16:05:59.757]                 removed <- setdiff(old_names, names)
[16:05:59.757]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:59.757]                   envs[common]]
[16:05:59.757]                 NAMES <- toupper(changed)
[16:05:59.757]                 args <- list()
[16:05:59.757]                 for (kk in seq_along(NAMES)) {
[16:05:59.757]                   name <- changed[[kk]]
[16:05:59.757]                   NAME <- NAMES[[kk]]
[16:05:59.757]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.757]                     next
[16:05:59.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.757]                 }
[16:05:59.757]                 NAMES <- toupper(added)
[16:05:59.757]                 for (kk in seq_along(NAMES)) {
[16:05:59.757]                   name <- added[[kk]]
[16:05:59.757]                   NAME <- NAMES[[kk]]
[16:05:59.757]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.757]                     next
[16:05:59.757]                   args[[name]] <- ""
[16:05:59.757]                 }
[16:05:59.757]                 NAMES <- toupper(removed)
[16:05:59.757]                 for (kk in seq_along(NAMES)) {
[16:05:59.757]                   name <- removed[[kk]]
[16:05:59.757]                   NAME <- NAMES[[kk]]
[16:05:59.757]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.757]                     next
[16:05:59.757]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.757]                 }
[16:05:59.757]                 if (length(args) > 0) 
[16:05:59.757]                   base::do.call(base::Sys.setenv, args = args)
[16:05:59.757]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:59.757]             }
[16:05:59.757]             else {
[16:05:59.757]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:59.757]             }
[16:05:59.757]             {
[16:05:59.757]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:59.757]                   0L) {
[16:05:59.757]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:59.757]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:59.757]                   base::options(opts)
[16:05:59.757]                 }
[16:05:59.757]                 {
[16:05:59.757]                   {
[16:05:59.757]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:59.757]                     NULL
[16:05:59.757]                   }
[16:05:59.757]                   options(future.plan = NULL)
[16:05:59.757]                   if (is.na(NA_character_)) 
[16:05:59.757]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.757]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:59.757]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:59.757]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:59.757]                     envir = parent.frame()) 
[16:05:59.757]                   {
[16:05:59.757]                     if (is.function(workers)) 
[16:05:59.757]                       workers <- workers()
[16:05:59.757]                     workers <- structure(as.integer(workers), 
[16:05:59.757]                       class = class(workers))
[16:05:59.757]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:59.757]                       workers >= 1)
[16:05:59.757]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:59.757]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:59.757]                     }
[16:05:59.757]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:59.757]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:59.757]                       envir = envir)
[16:05:59.757]                     if (!future$lazy) 
[16:05:59.757]                       future <- run(future)
[16:05:59.757]                     invisible(future)
[16:05:59.757]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:59.757]                 }
[16:05:59.757]             }
[16:05:59.757]         }
[16:05:59.757]     })
[16:05:59.757]     if (TRUE) {
[16:05:59.757]         base::sink(type = "output", split = FALSE)
[16:05:59.757]         if (TRUE) {
[16:05:59.757]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:59.757]         }
[16:05:59.757]         else {
[16:05:59.757]             ...future.result["stdout"] <- base::list(NULL)
[16:05:59.757]         }
[16:05:59.757]         base::close(...future.stdout)
[16:05:59.757]         ...future.stdout <- NULL
[16:05:59.757]     }
[16:05:59.757]     ...future.result$conditions <- ...future.conditions
[16:05:59.757]     ...future.result$finished <- base::Sys.time()
[16:05:59.757]     ...future.result
[16:05:59.757] }
[16:05:59.760] MultisessionFuture started
[16:05:59.760] - Launch lazy future ... done
[16:05:59.760] run() for ‘MultisessionFuture’ ... done
[16:05:59.808] receiveMessageFromWorker() for ClusterFuture ...
[16:05:59.808] - Validating connection of MultisessionFuture
[16:05:59.808] - received message: FutureResult
[16:05:59.808] - Received FutureResult
[16:05:59.809] - Erased future from FutureRegistry
[16:05:59.809] result() for ClusterFuture ...
[16:05:59.809] - result already collected: FutureResult
[16:05:59.809] result() for ClusterFuture ... done
[16:05:59.809] signalConditions() ...
[16:05:59.809]  - include = ‘immediateCondition’
[16:05:59.809]  - exclude = 
[16:05:59.809]  - resignal = FALSE
[16:05:59.809]  - Number of conditions: 1
[16:05:59.809] signalConditions() ... done
[16:05:59.809] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:59.809] A MultisessionFuture was resolved (result was not collected)
[16:05:59.810] getGlobalsAndPackages() ...
[16:05:59.810] Searching for globals...
[16:05:59.810] - globals found: [2] ‘list’, ‘stop’
[16:05:59.810] Searching for globals ... DONE
[16:05:59.811] Resolving globals: FALSE
[16:05:59.811] 
[16:05:59.811] 
[16:05:59.811] getGlobalsAndPackages() ... DONE
[16:05:59.811] run() for ‘Future’ ...
[16:05:59.811] - state: ‘created’
[16:05:59.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:59.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:59.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:59.825]   - Field: ‘node’
[16:05:59.825]   - Field: ‘label’
[16:05:59.825]   - Field: ‘local’
[16:05:59.825]   - Field: ‘owner’
[16:05:59.825]   - Field: ‘envir’
[16:05:59.825]   - Field: ‘workers’
[16:05:59.825]   - Field: ‘packages’
[16:05:59.826]   - Field: ‘gc’
[16:05:59.826]   - Field: ‘conditions’
[16:05:59.826]   - Field: ‘persistent’
[16:05:59.826]   - Field: ‘expr’
[16:05:59.826]   - Field: ‘uuid’
[16:05:59.826]   - Field: ‘seed’
[16:05:59.826]   - Field: ‘version’
[16:05:59.826]   - Field: ‘result’
[16:05:59.826]   - Field: ‘asynchronous’
[16:05:59.826]   - Field: ‘calls’
[16:05:59.826]   - Field: ‘globals’
[16:05:59.827]   - Field: ‘stdout’
[16:05:59.827]   - Field: ‘earlySignal’
[16:05:59.827]   - Field: ‘lazy’
[16:05:59.827]   - Field: ‘state’
[16:05:59.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:59.827] - Launch lazy future ...
[16:05:59.827] Packages needed by the future expression (n = 0): <none>
[16:05:59.827] Packages needed by future strategies (n = 0): <none>
[16:05:59.828] {
[16:05:59.828]     {
[16:05:59.828]         {
[16:05:59.828]             ...future.startTime <- base::Sys.time()
[16:05:59.828]             {
[16:05:59.828]                 {
[16:05:59.828]                   {
[16:05:59.828]                     {
[16:05:59.828]                       base::local({
[16:05:59.828]                         has_future <- base::requireNamespace("future", 
[16:05:59.828]                           quietly = TRUE)
[16:05:59.828]                         if (has_future) {
[16:05:59.828]                           ns <- base::getNamespace("future")
[16:05:59.828]                           version <- ns[[".package"]][["version"]]
[16:05:59.828]                           if (is.null(version)) 
[16:05:59.828]                             version <- utils::packageVersion("future")
[16:05:59.828]                         }
[16:05:59.828]                         else {
[16:05:59.828]                           version <- NULL
[16:05:59.828]                         }
[16:05:59.828]                         if (!has_future || version < "1.8.0") {
[16:05:59.828]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:59.828]                             "", base::R.version$version.string), 
[16:05:59.828]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:59.828]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:59.828]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:59.828]                               "release", "version")], collapse = " "), 
[16:05:59.828]                             hostname = base::Sys.info()[["nodename"]])
[16:05:59.828]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:59.828]                             info)
[16:05:59.828]                           info <- base::paste(info, collapse = "; ")
[16:05:59.828]                           if (!has_future) {
[16:05:59.828]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:59.828]                               info)
[16:05:59.828]                           }
[16:05:59.828]                           else {
[16:05:59.828]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:59.828]                               info, version)
[16:05:59.828]                           }
[16:05:59.828]                           base::stop(msg)
[16:05:59.828]                         }
[16:05:59.828]                       })
[16:05:59.828]                     }
[16:05:59.828]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:59.828]                     base::options(mc.cores = 1L)
[16:05:59.828]                   }
[16:05:59.828]                   options(future.plan = NULL)
[16:05:59.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:59.828]                 }
[16:05:59.828]                 ...future.workdir <- getwd()
[16:05:59.828]             }
[16:05:59.828]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:59.828]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:59.828]         }
[16:05:59.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:59.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:59.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:59.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:59.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:59.828]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:59.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:59.828]             base::names(...future.oldOptions))
[16:05:59.828]     }
[16:05:59.828]     if (FALSE) {
[16:05:59.828]     }
[16:05:59.828]     else {
[16:05:59.828]         if (TRUE) {
[16:05:59.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:59.828]                 open = "w")
[16:05:59.828]         }
[16:05:59.828]         else {
[16:05:59.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:59.828]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:59.828]         }
[16:05:59.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:59.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:59.828]             base::sink(type = "output", split = FALSE)
[16:05:59.828]             base::close(...future.stdout)
[16:05:59.828]         }, add = TRUE)
[16:05:59.828]     }
[16:05:59.828]     ...future.frame <- base::sys.nframe()
[16:05:59.828]     ...future.conditions <- base::list()
[16:05:59.828]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:59.828]     if (FALSE) {
[16:05:59.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:59.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:59.828]     }
[16:05:59.828]     ...future.result <- base::tryCatch({
[16:05:59.828]         base::withCallingHandlers({
[16:05:59.828]             ...future.value <- base::withVisible(base::local({
[16:05:59.828]                 ...future.makeSendCondition <- base::local({
[16:05:59.828]                   sendCondition <- NULL
[16:05:59.828]                   function(frame = 1L) {
[16:05:59.828]                     if (is.function(sendCondition)) 
[16:05:59.828]                       return(sendCondition)
[16:05:59.828]                     ns <- getNamespace("parallel")
[16:05:59.828]                     if (exists("sendData", mode = "function", 
[16:05:59.828]                       envir = ns)) {
[16:05:59.828]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:59.828]                         envir = ns)
[16:05:59.828]                       envir <- sys.frame(frame)
[16:05:59.828]                       master <- NULL
[16:05:59.828]                       while (!identical(envir, .GlobalEnv) && 
[16:05:59.828]                         !identical(envir, emptyenv())) {
[16:05:59.828]                         if (exists("master", mode = "list", envir = envir, 
[16:05:59.828]                           inherits = FALSE)) {
[16:05:59.828]                           master <- get("master", mode = "list", 
[16:05:59.828]                             envir = envir, inherits = FALSE)
[16:05:59.828]                           if (inherits(master, c("SOCKnode", 
[16:05:59.828]                             "SOCK0node"))) {
[16:05:59.828]                             sendCondition <<- function(cond) {
[16:05:59.828]                               data <- list(type = "VALUE", value = cond, 
[16:05:59.828]                                 success = TRUE)
[16:05:59.828]                               parallel_sendData(master, data)
[16:05:59.828]                             }
[16:05:59.828]                             return(sendCondition)
[16:05:59.828]                           }
[16:05:59.828]                         }
[16:05:59.828]                         frame <- frame + 1L
[16:05:59.828]                         envir <- sys.frame(frame)
[16:05:59.828]                       }
[16:05:59.828]                     }
[16:05:59.828]                     sendCondition <<- function(cond) NULL
[16:05:59.828]                   }
[16:05:59.828]                 })
[16:05:59.828]                 withCallingHandlers({
[16:05:59.828]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:05:59.828]                 }, immediateCondition = function(cond) {
[16:05:59.828]                   sendCondition <- ...future.makeSendCondition()
[16:05:59.828]                   sendCondition(cond)
[16:05:59.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.828]                   {
[16:05:59.828]                     inherits <- base::inherits
[16:05:59.828]                     invokeRestart <- base::invokeRestart
[16:05:59.828]                     is.null <- base::is.null
[16:05:59.828]                     muffled <- FALSE
[16:05:59.828]                     if (inherits(cond, "message")) {
[16:05:59.828]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:59.828]                       if (muffled) 
[16:05:59.828]                         invokeRestart("muffleMessage")
[16:05:59.828]                     }
[16:05:59.828]                     else if (inherits(cond, "warning")) {
[16:05:59.828]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:59.828]                       if (muffled) 
[16:05:59.828]                         invokeRestart("muffleWarning")
[16:05:59.828]                     }
[16:05:59.828]                     else if (inherits(cond, "condition")) {
[16:05:59.828]                       if (!is.null(pattern)) {
[16:05:59.828]                         computeRestarts <- base::computeRestarts
[16:05:59.828]                         grepl <- base::grepl
[16:05:59.828]                         restarts <- computeRestarts(cond)
[16:05:59.828]                         for (restart in restarts) {
[16:05:59.828]                           name <- restart$name
[16:05:59.828]                           if (is.null(name)) 
[16:05:59.828]                             next
[16:05:59.828]                           if (!grepl(pattern, name)) 
[16:05:59.828]                             next
[16:05:59.828]                           invokeRestart(restart)
[16:05:59.828]                           muffled <- TRUE
[16:05:59.828]                           break
[16:05:59.828]                         }
[16:05:59.828]                       }
[16:05:59.828]                     }
[16:05:59.828]                     invisible(muffled)
[16:05:59.828]                   }
[16:05:59.828]                   muffleCondition(cond)
[16:05:59.828]                 })
[16:05:59.828]             }))
[16:05:59.828]             future::FutureResult(value = ...future.value$value, 
[16:05:59.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.828]                   ...future.rng), globalenv = if (FALSE) 
[16:05:59.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:59.828]                     ...future.globalenv.names))
[16:05:59.828]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:59.828]         }, condition = base::local({
[16:05:59.828]             c <- base::c
[16:05:59.828]             inherits <- base::inherits
[16:05:59.828]             invokeRestart <- base::invokeRestart
[16:05:59.828]             length <- base::length
[16:05:59.828]             list <- base::list
[16:05:59.828]             seq.int <- base::seq.int
[16:05:59.828]             signalCondition <- base::signalCondition
[16:05:59.828]             sys.calls <- base::sys.calls
[16:05:59.828]             `[[` <- base::`[[`
[16:05:59.828]             `+` <- base::`+`
[16:05:59.828]             `<<-` <- base::`<<-`
[16:05:59.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:59.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:59.828]                   3L)]
[16:05:59.828]             }
[16:05:59.828]             function(cond) {
[16:05:59.828]                 is_error <- inherits(cond, "error")
[16:05:59.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:59.828]                   NULL)
[16:05:59.828]                 if (is_error) {
[16:05:59.828]                   sessionInformation <- function() {
[16:05:59.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:59.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:59.828]                       search = base::search(), system = base::Sys.info())
[16:05:59.828]                   }
[16:05:59.828]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:59.828]                     cond$call), session = sessionInformation(), 
[16:05:59.828]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:59.828]                   signalCondition(cond)
[16:05:59.828]                 }
[16:05:59.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:59.828]                 "immediateCondition"))) {
[16:05:59.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:59.828]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:59.828]                   if (TRUE && !signal) {
[16:05:59.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.828]                     {
[16:05:59.828]                       inherits <- base::inherits
[16:05:59.828]                       invokeRestart <- base::invokeRestart
[16:05:59.828]                       is.null <- base::is.null
[16:05:59.828]                       muffled <- FALSE
[16:05:59.828]                       if (inherits(cond, "message")) {
[16:05:59.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.828]                         if (muffled) 
[16:05:59.828]                           invokeRestart("muffleMessage")
[16:05:59.828]                       }
[16:05:59.828]                       else if (inherits(cond, "warning")) {
[16:05:59.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.828]                         if (muffled) 
[16:05:59.828]                           invokeRestart("muffleWarning")
[16:05:59.828]                       }
[16:05:59.828]                       else if (inherits(cond, "condition")) {
[16:05:59.828]                         if (!is.null(pattern)) {
[16:05:59.828]                           computeRestarts <- base::computeRestarts
[16:05:59.828]                           grepl <- base::grepl
[16:05:59.828]                           restarts <- computeRestarts(cond)
[16:05:59.828]                           for (restart in restarts) {
[16:05:59.828]                             name <- restart$name
[16:05:59.828]                             if (is.null(name)) 
[16:05:59.828]                               next
[16:05:59.828]                             if (!grepl(pattern, name)) 
[16:05:59.828]                               next
[16:05:59.828]                             invokeRestart(restart)
[16:05:59.828]                             muffled <- TRUE
[16:05:59.828]                             break
[16:05:59.828]                           }
[16:05:59.828]                         }
[16:05:59.828]                       }
[16:05:59.828]                       invisible(muffled)
[16:05:59.828]                     }
[16:05:59.828]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.828]                   }
[16:05:59.828]                 }
[16:05:59.828]                 else {
[16:05:59.828]                   if (TRUE) {
[16:05:59.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.828]                     {
[16:05:59.828]                       inherits <- base::inherits
[16:05:59.828]                       invokeRestart <- base::invokeRestart
[16:05:59.828]                       is.null <- base::is.null
[16:05:59.828]                       muffled <- FALSE
[16:05:59.828]                       if (inherits(cond, "message")) {
[16:05:59.828]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.828]                         if (muffled) 
[16:05:59.828]                           invokeRestart("muffleMessage")
[16:05:59.828]                       }
[16:05:59.828]                       else if (inherits(cond, "warning")) {
[16:05:59.828]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.828]                         if (muffled) 
[16:05:59.828]                           invokeRestart("muffleWarning")
[16:05:59.828]                       }
[16:05:59.828]                       else if (inherits(cond, "condition")) {
[16:05:59.828]                         if (!is.null(pattern)) {
[16:05:59.828]                           computeRestarts <- base::computeRestarts
[16:05:59.828]                           grepl <- base::grepl
[16:05:59.828]                           restarts <- computeRestarts(cond)
[16:05:59.828]                           for (restart in restarts) {
[16:05:59.828]                             name <- restart$name
[16:05:59.828]                             if (is.null(name)) 
[16:05:59.828]                               next
[16:05:59.828]                             if (!grepl(pattern, name)) 
[16:05:59.828]                               next
[16:05:59.828]                             invokeRestart(restart)
[16:05:59.828]                             muffled <- TRUE
[16:05:59.828]                             break
[16:05:59.828]                           }
[16:05:59.828]                         }
[16:05:59.828]                       }
[16:05:59.828]                       invisible(muffled)
[16:05:59.828]                     }
[16:05:59.828]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.828]                   }
[16:05:59.828]                 }
[16:05:59.828]             }
[16:05:59.828]         }))
[16:05:59.828]     }, error = function(ex) {
[16:05:59.828]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:59.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.828]                 ...future.rng), started = ...future.startTime, 
[16:05:59.828]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:59.828]             version = "1.8"), class = "FutureResult")
[16:05:59.828]     }, finally = {
[16:05:59.828]         if (!identical(...future.workdir, getwd())) 
[16:05:59.828]             setwd(...future.workdir)
[16:05:59.828]         {
[16:05:59.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:59.828]                 ...future.oldOptions$nwarnings <- NULL
[16:05:59.828]             }
[16:05:59.828]             base::options(...future.oldOptions)
[16:05:59.828]             if (.Platform$OS.type == "windows") {
[16:05:59.828]                 old_names <- names(...future.oldEnvVars)
[16:05:59.828]                 envs <- base::Sys.getenv()
[16:05:59.828]                 names <- names(envs)
[16:05:59.828]                 common <- intersect(names, old_names)
[16:05:59.828]                 added <- setdiff(names, old_names)
[16:05:59.828]                 removed <- setdiff(old_names, names)
[16:05:59.828]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:59.828]                   envs[common]]
[16:05:59.828]                 NAMES <- toupper(changed)
[16:05:59.828]                 args <- list()
[16:05:59.828]                 for (kk in seq_along(NAMES)) {
[16:05:59.828]                   name <- changed[[kk]]
[16:05:59.828]                   NAME <- NAMES[[kk]]
[16:05:59.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.828]                     next
[16:05:59.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.828]                 }
[16:05:59.828]                 NAMES <- toupper(added)
[16:05:59.828]                 for (kk in seq_along(NAMES)) {
[16:05:59.828]                   name <- added[[kk]]
[16:05:59.828]                   NAME <- NAMES[[kk]]
[16:05:59.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.828]                     next
[16:05:59.828]                   args[[name]] <- ""
[16:05:59.828]                 }
[16:05:59.828]                 NAMES <- toupper(removed)
[16:05:59.828]                 for (kk in seq_along(NAMES)) {
[16:05:59.828]                   name <- removed[[kk]]
[16:05:59.828]                   NAME <- NAMES[[kk]]
[16:05:59.828]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.828]                     next
[16:05:59.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.828]                 }
[16:05:59.828]                 if (length(args) > 0) 
[16:05:59.828]                   base::do.call(base::Sys.setenv, args = args)
[16:05:59.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:59.828]             }
[16:05:59.828]             else {
[16:05:59.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:59.828]             }
[16:05:59.828]             {
[16:05:59.828]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:59.828]                   0L) {
[16:05:59.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:59.828]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:59.828]                   base::options(opts)
[16:05:59.828]                 }
[16:05:59.828]                 {
[16:05:59.828]                   {
[16:05:59.828]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:59.828]                     NULL
[16:05:59.828]                   }
[16:05:59.828]                   options(future.plan = NULL)
[16:05:59.828]                   if (is.na(NA_character_)) 
[16:05:59.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:59.828]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:59.828]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:59.828]                     envir = parent.frame()) 
[16:05:59.828]                   {
[16:05:59.828]                     if (is.function(workers)) 
[16:05:59.828]                       workers <- workers()
[16:05:59.828]                     workers <- structure(as.integer(workers), 
[16:05:59.828]                       class = class(workers))
[16:05:59.828]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:59.828]                       workers >= 1)
[16:05:59.828]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:59.828]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:59.828]                     }
[16:05:59.828]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:59.828]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:59.828]                       envir = envir)
[16:05:59.828]                     if (!future$lazy) 
[16:05:59.828]                       future <- run(future)
[16:05:59.828]                     invisible(future)
[16:05:59.828]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:59.828]                 }
[16:05:59.828]             }
[16:05:59.828]         }
[16:05:59.828]     })
[16:05:59.828]     if (TRUE) {
[16:05:59.828]         base::sink(type = "output", split = FALSE)
[16:05:59.828]         if (TRUE) {
[16:05:59.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:59.828]         }
[16:05:59.828]         else {
[16:05:59.828]             ...future.result["stdout"] <- base::list(NULL)
[16:05:59.828]         }
[16:05:59.828]         base::close(...future.stdout)
[16:05:59.828]         ...future.stdout <- NULL
[16:05:59.828]     }
[16:05:59.828]     ...future.result$conditions <- ...future.conditions
[16:05:59.828]     ...future.result$finished <- base::Sys.time()
[16:05:59.828]     ...future.result
[16:05:59.828] }
[16:05:59.831] MultisessionFuture started
[16:05:59.831] - Launch lazy future ... done
[16:05:59.831] run() for ‘MultisessionFuture’ ... done
[16:05:59.875] receiveMessageFromWorker() for ClusterFuture ...
[16:05:59.876] - Validating connection of MultisessionFuture
[16:05:59.876] - received message: FutureResult
[16:05:59.876] - Received FutureResult
[16:05:59.876] - Erased future from FutureRegistry
[16:05:59.876] result() for ClusterFuture ...
[16:05:59.876] - result already collected: FutureResult
[16:05:59.877] result() for ClusterFuture ... done
[16:05:59.877] signalConditions() ...
[16:05:59.877]  - include = ‘immediateCondition’
[16:05:59.877]  - exclude = 
[16:05:59.877]  - resignal = FALSE
[16:05:59.877]  - Number of conditions: 1
[16:05:59.877] signalConditions() ... done
[16:05:59.877] receiveMessageFromWorker() for ClusterFuture ... done
[16:05:59.877] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[16:05:59.877] getGlobalsAndPackages() ...
[16:05:59.878] Searching for globals...
[16:05:59.879] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:05:59.879] Searching for globals ... DONE
[16:05:59.879] Resolving globals: FALSE
[16:05:59.879] 
[16:05:59.879] 
[16:05:59.879] getGlobalsAndPackages() ... DONE
[16:05:59.880] run() for ‘Future’ ...
[16:05:59.880] - state: ‘created’
[16:05:59.880] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:05:59.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:05:59.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:05:59.896]   - Field: ‘node’
[16:05:59.896]   - Field: ‘label’
[16:05:59.896]   - Field: ‘local’
[16:05:59.896]   - Field: ‘owner’
[16:05:59.896]   - Field: ‘envir’
[16:05:59.896]   - Field: ‘workers’
[16:05:59.896]   - Field: ‘packages’
[16:05:59.897]   - Field: ‘gc’
[16:05:59.897]   - Field: ‘conditions’
[16:05:59.897]   - Field: ‘persistent’
[16:05:59.897]   - Field: ‘expr’
[16:05:59.897]   - Field: ‘uuid’
[16:05:59.897]   - Field: ‘seed’
[16:05:59.897]   - Field: ‘version’
[16:05:59.897]   - Field: ‘result’
[16:05:59.897]   - Field: ‘asynchronous’
[16:05:59.897]   - Field: ‘calls’
[16:05:59.897]   - Field: ‘globals’
[16:05:59.898]   - Field: ‘stdout’
[16:05:59.898]   - Field: ‘earlySignal’
[16:05:59.898]   - Field: ‘lazy’
[16:05:59.898]   - Field: ‘state’
[16:05:59.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:05:59.898] - Launch lazy future ...
[16:05:59.898] Packages needed by the future expression (n = 0): <none>
[16:05:59.898] Packages needed by future strategies (n = 0): <none>
[16:05:59.899] {
[16:05:59.899]     {
[16:05:59.899]         {
[16:05:59.899]             ...future.startTime <- base::Sys.time()
[16:05:59.899]             {
[16:05:59.899]                 {
[16:05:59.899]                   {
[16:05:59.899]                     {
[16:05:59.899]                       base::local({
[16:05:59.899]                         has_future <- base::requireNamespace("future", 
[16:05:59.899]                           quietly = TRUE)
[16:05:59.899]                         if (has_future) {
[16:05:59.899]                           ns <- base::getNamespace("future")
[16:05:59.899]                           version <- ns[[".package"]][["version"]]
[16:05:59.899]                           if (is.null(version)) 
[16:05:59.899]                             version <- utils::packageVersion("future")
[16:05:59.899]                         }
[16:05:59.899]                         else {
[16:05:59.899]                           version <- NULL
[16:05:59.899]                         }
[16:05:59.899]                         if (!has_future || version < "1.8.0") {
[16:05:59.899]                           info <- base::c(r_version = base::gsub("R version ", 
[16:05:59.899]                             "", base::R.version$version.string), 
[16:05:59.899]                             platform = base::sprintf("%s (%s-bit)", 
[16:05:59.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:05:59.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:05:59.899]                               "release", "version")], collapse = " "), 
[16:05:59.899]                             hostname = base::Sys.info()[["nodename"]])
[16:05:59.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:05:59.899]                             info)
[16:05:59.899]                           info <- base::paste(info, collapse = "; ")
[16:05:59.899]                           if (!has_future) {
[16:05:59.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:05:59.899]                               info)
[16:05:59.899]                           }
[16:05:59.899]                           else {
[16:05:59.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:05:59.899]                               info, version)
[16:05:59.899]                           }
[16:05:59.899]                           base::stop(msg)
[16:05:59.899]                         }
[16:05:59.899]                       })
[16:05:59.899]                     }
[16:05:59.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:05:59.899]                     base::options(mc.cores = 1L)
[16:05:59.899]                   }
[16:05:59.899]                   options(future.plan = NULL)
[16:05:59.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:05:59.899]                 }
[16:05:59.899]                 ...future.workdir <- getwd()
[16:05:59.899]             }
[16:05:59.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:05:59.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:05:59.899]         }
[16:05:59.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:05:59.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:05:59.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:05:59.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:05:59.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:05:59.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:05:59.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:05:59.899]             base::names(...future.oldOptions))
[16:05:59.899]     }
[16:05:59.899]     if (FALSE) {
[16:05:59.899]     }
[16:05:59.899]     else {
[16:05:59.899]         if (TRUE) {
[16:05:59.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:05:59.899]                 open = "w")
[16:05:59.899]         }
[16:05:59.899]         else {
[16:05:59.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:05:59.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:05:59.899]         }
[16:05:59.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:05:59.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:05:59.899]             base::sink(type = "output", split = FALSE)
[16:05:59.899]             base::close(...future.stdout)
[16:05:59.899]         }, add = TRUE)
[16:05:59.899]     }
[16:05:59.899]     ...future.frame <- base::sys.nframe()
[16:05:59.899]     ...future.conditions <- base::list()
[16:05:59.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:05:59.899]     if (FALSE) {
[16:05:59.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:05:59.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:05:59.899]     }
[16:05:59.899]     ...future.result <- base::tryCatch({
[16:05:59.899]         base::withCallingHandlers({
[16:05:59.899]             ...future.value <- base::withVisible(base::local({
[16:05:59.899]                 ...future.makeSendCondition <- base::local({
[16:05:59.899]                   sendCondition <- NULL
[16:05:59.899]                   function(frame = 1L) {
[16:05:59.899]                     if (is.function(sendCondition)) 
[16:05:59.899]                       return(sendCondition)
[16:05:59.899]                     ns <- getNamespace("parallel")
[16:05:59.899]                     if (exists("sendData", mode = "function", 
[16:05:59.899]                       envir = ns)) {
[16:05:59.899]                       parallel_sendData <- get("sendData", mode = "function", 
[16:05:59.899]                         envir = ns)
[16:05:59.899]                       envir <- sys.frame(frame)
[16:05:59.899]                       master <- NULL
[16:05:59.899]                       while (!identical(envir, .GlobalEnv) && 
[16:05:59.899]                         !identical(envir, emptyenv())) {
[16:05:59.899]                         if (exists("master", mode = "list", envir = envir, 
[16:05:59.899]                           inherits = FALSE)) {
[16:05:59.899]                           master <- get("master", mode = "list", 
[16:05:59.899]                             envir = envir, inherits = FALSE)
[16:05:59.899]                           if (inherits(master, c("SOCKnode", 
[16:05:59.899]                             "SOCK0node"))) {
[16:05:59.899]                             sendCondition <<- function(cond) {
[16:05:59.899]                               data <- list(type = "VALUE", value = cond, 
[16:05:59.899]                                 success = TRUE)
[16:05:59.899]                               parallel_sendData(master, data)
[16:05:59.899]                             }
[16:05:59.899]                             return(sendCondition)
[16:05:59.899]                           }
[16:05:59.899]                         }
[16:05:59.899]                         frame <- frame + 1L
[16:05:59.899]                         envir <- sys.frame(frame)
[16:05:59.899]                       }
[16:05:59.899]                     }
[16:05:59.899]                     sendCondition <<- function(cond) NULL
[16:05:59.899]                   }
[16:05:59.899]                 })
[16:05:59.899]                 withCallingHandlers({
[16:05:59.899]                   {
[16:05:59.899]                     Sys.sleep(0.5)
[16:05:59.899]                     list(a = 1, b = 42L)
[16:05:59.899]                   }
[16:05:59.899]                 }, immediateCondition = function(cond) {
[16:05:59.899]                   sendCondition <- ...future.makeSendCondition()
[16:05:59.899]                   sendCondition(cond)
[16:05:59.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.899]                   {
[16:05:59.899]                     inherits <- base::inherits
[16:05:59.899]                     invokeRestart <- base::invokeRestart
[16:05:59.899]                     is.null <- base::is.null
[16:05:59.899]                     muffled <- FALSE
[16:05:59.899]                     if (inherits(cond, "message")) {
[16:05:59.899]                       muffled <- grepl(pattern, "muffleMessage")
[16:05:59.899]                       if (muffled) 
[16:05:59.899]                         invokeRestart("muffleMessage")
[16:05:59.899]                     }
[16:05:59.899]                     else if (inherits(cond, "warning")) {
[16:05:59.899]                       muffled <- grepl(pattern, "muffleWarning")
[16:05:59.899]                       if (muffled) 
[16:05:59.899]                         invokeRestart("muffleWarning")
[16:05:59.899]                     }
[16:05:59.899]                     else if (inherits(cond, "condition")) {
[16:05:59.899]                       if (!is.null(pattern)) {
[16:05:59.899]                         computeRestarts <- base::computeRestarts
[16:05:59.899]                         grepl <- base::grepl
[16:05:59.899]                         restarts <- computeRestarts(cond)
[16:05:59.899]                         for (restart in restarts) {
[16:05:59.899]                           name <- restart$name
[16:05:59.899]                           if (is.null(name)) 
[16:05:59.899]                             next
[16:05:59.899]                           if (!grepl(pattern, name)) 
[16:05:59.899]                             next
[16:05:59.899]                           invokeRestart(restart)
[16:05:59.899]                           muffled <- TRUE
[16:05:59.899]                           break
[16:05:59.899]                         }
[16:05:59.899]                       }
[16:05:59.899]                     }
[16:05:59.899]                     invisible(muffled)
[16:05:59.899]                   }
[16:05:59.899]                   muffleCondition(cond)
[16:05:59.899]                 })
[16:05:59.899]             }))
[16:05:59.899]             future::FutureResult(value = ...future.value$value, 
[16:05:59.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.899]                   ...future.rng), globalenv = if (FALSE) 
[16:05:59.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:05:59.899]                     ...future.globalenv.names))
[16:05:59.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:05:59.899]         }, condition = base::local({
[16:05:59.899]             c <- base::c
[16:05:59.899]             inherits <- base::inherits
[16:05:59.899]             invokeRestart <- base::invokeRestart
[16:05:59.899]             length <- base::length
[16:05:59.899]             list <- base::list
[16:05:59.899]             seq.int <- base::seq.int
[16:05:59.899]             signalCondition <- base::signalCondition
[16:05:59.899]             sys.calls <- base::sys.calls
[16:05:59.899]             `[[` <- base::`[[`
[16:05:59.899]             `+` <- base::`+`
[16:05:59.899]             `<<-` <- base::`<<-`
[16:05:59.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:05:59.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:05:59.899]                   3L)]
[16:05:59.899]             }
[16:05:59.899]             function(cond) {
[16:05:59.899]                 is_error <- inherits(cond, "error")
[16:05:59.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:05:59.899]                   NULL)
[16:05:59.899]                 if (is_error) {
[16:05:59.899]                   sessionInformation <- function() {
[16:05:59.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:05:59.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:05:59.899]                       search = base::search(), system = base::Sys.info())
[16:05:59.899]                   }
[16:05:59.899]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:05:59.899]                     cond$call), session = sessionInformation(), 
[16:05:59.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:05:59.899]                   signalCondition(cond)
[16:05:59.899]                 }
[16:05:59.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:05:59.899]                 "immediateCondition"))) {
[16:05:59.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:05:59.899]                   ...future.conditions[[length(...future.conditions) + 
[16:05:59.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:05:59.899]                   if (TRUE && !signal) {
[16:05:59.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.899]                     {
[16:05:59.899]                       inherits <- base::inherits
[16:05:59.899]                       invokeRestart <- base::invokeRestart
[16:05:59.899]                       is.null <- base::is.null
[16:05:59.899]                       muffled <- FALSE
[16:05:59.899]                       if (inherits(cond, "message")) {
[16:05:59.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.899]                         if (muffled) 
[16:05:59.899]                           invokeRestart("muffleMessage")
[16:05:59.899]                       }
[16:05:59.899]                       else if (inherits(cond, "warning")) {
[16:05:59.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.899]                         if (muffled) 
[16:05:59.899]                           invokeRestart("muffleWarning")
[16:05:59.899]                       }
[16:05:59.899]                       else if (inherits(cond, "condition")) {
[16:05:59.899]                         if (!is.null(pattern)) {
[16:05:59.899]                           computeRestarts <- base::computeRestarts
[16:05:59.899]                           grepl <- base::grepl
[16:05:59.899]                           restarts <- computeRestarts(cond)
[16:05:59.899]                           for (restart in restarts) {
[16:05:59.899]                             name <- restart$name
[16:05:59.899]                             if (is.null(name)) 
[16:05:59.899]                               next
[16:05:59.899]                             if (!grepl(pattern, name)) 
[16:05:59.899]                               next
[16:05:59.899]                             invokeRestart(restart)
[16:05:59.899]                             muffled <- TRUE
[16:05:59.899]                             break
[16:05:59.899]                           }
[16:05:59.899]                         }
[16:05:59.899]                       }
[16:05:59.899]                       invisible(muffled)
[16:05:59.899]                     }
[16:05:59.899]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.899]                   }
[16:05:59.899]                 }
[16:05:59.899]                 else {
[16:05:59.899]                   if (TRUE) {
[16:05:59.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:05:59.899]                     {
[16:05:59.899]                       inherits <- base::inherits
[16:05:59.899]                       invokeRestart <- base::invokeRestart
[16:05:59.899]                       is.null <- base::is.null
[16:05:59.899]                       muffled <- FALSE
[16:05:59.899]                       if (inherits(cond, "message")) {
[16:05:59.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:05:59.899]                         if (muffled) 
[16:05:59.899]                           invokeRestart("muffleMessage")
[16:05:59.899]                       }
[16:05:59.899]                       else if (inherits(cond, "warning")) {
[16:05:59.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:05:59.899]                         if (muffled) 
[16:05:59.899]                           invokeRestart("muffleWarning")
[16:05:59.899]                       }
[16:05:59.899]                       else if (inherits(cond, "condition")) {
[16:05:59.899]                         if (!is.null(pattern)) {
[16:05:59.899]                           computeRestarts <- base::computeRestarts
[16:05:59.899]                           grepl <- base::grepl
[16:05:59.899]                           restarts <- computeRestarts(cond)
[16:05:59.899]                           for (restart in restarts) {
[16:05:59.899]                             name <- restart$name
[16:05:59.899]                             if (is.null(name)) 
[16:05:59.899]                               next
[16:05:59.899]                             if (!grepl(pattern, name)) 
[16:05:59.899]                               next
[16:05:59.899]                             invokeRestart(restart)
[16:05:59.899]                             muffled <- TRUE
[16:05:59.899]                             break
[16:05:59.899]                           }
[16:05:59.899]                         }
[16:05:59.899]                       }
[16:05:59.899]                       invisible(muffled)
[16:05:59.899]                     }
[16:05:59.899]                     muffleCondition(cond, pattern = "^muffle")
[16:05:59.899]                   }
[16:05:59.899]                 }
[16:05:59.899]             }
[16:05:59.899]         }))
[16:05:59.899]     }, error = function(ex) {
[16:05:59.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:05:59.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:05:59.899]                 ...future.rng), started = ...future.startTime, 
[16:05:59.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:05:59.899]             version = "1.8"), class = "FutureResult")
[16:05:59.899]     }, finally = {
[16:05:59.899]         if (!identical(...future.workdir, getwd())) 
[16:05:59.899]             setwd(...future.workdir)
[16:05:59.899]         {
[16:05:59.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:05:59.899]                 ...future.oldOptions$nwarnings <- NULL
[16:05:59.899]             }
[16:05:59.899]             base::options(...future.oldOptions)
[16:05:59.899]             if (.Platform$OS.type == "windows") {
[16:05:59.899]                 old_names <- names(...future.oldEnvVars)
[16:05:59.899]                 envs <- base::Sys.getenv()
[16:05:59.899]                 names <- names(envs)
[16:05:59.899]                 common <- intersect(names, old_names)
[16:05:59.899]                 added <- setdiff(names, old_names)
[16:05:59.899]                 removed <- setdiff(old_names, names)
[16:05:59.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:05:59.899]                   envs[common]]
[16:05:59.899]                 NAMES <- toupper(changed)
[16:05:59.899]                 args <- list()
[16:05:59.899]                 for (kk in seq_along(NAMES)) {
[16:05:59.899]                   name <- changed[[kk]]
[16:05:59.899]                   NAME <- NAMES[[kk]]
[16:05:59.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.899]                     next
[16:05:59.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.899]                 }
[16:05:59.899]                 NAMES <- toupper(added)
[16:05:59.899]                 for (kk in seq_along(NAMES)) {
[16:05:59.899]                   name <- added[[kk]]
[16:05:59.899]                   NAME <- NAMES[[kk]]
[16:05:59.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.899]                     next
[16:05:59.899]                   args[[name]] <- ""
[16:05:59.899]                 }
[16:05:59.899]                 NAMES <- toupper(removed)
[16:05:59.899]                 for (kk in seq_along(NAMES)) {
[16:05:59.899]                   name <- removed[[kk]]
[16:05:59.899]                   NAME <- NAMES[[kk]]
[16:05:59.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:05:59.899]                     next
[16:05:59.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:05:59.899]                 }
[16:05:59.899]                 if (length(args) > 0) 
[16:05:59.899]                   base::do.call(base::Sys.setenv, args = args)
[16:05:59.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:05:59.899]             }
[16:05:59.899]             else {
[16:05:59.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:05:59.899]             }
[16:05:59.899]             {
[16:05:59.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:05:59.899]                   0L) {
[16:05:59.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:05:59.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:05:59.899]                   base::options(opts)
[16:05:59.899]                 }
[16:05:59.899]                 {
[16:05:59.899]                   {
[16:05:59.899]                     base::options(mc.cores = ...future.mc.cores.old)
[16:05:59.899]                     NULL
[16:05:59.899]                   }
[16:05:59.899]                   options(future.plan = NULL)
[16:05:59.899]                   if (is.na(NA_character_)) 
[16:05:59.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:05:59.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:05:59.899]                   future::plan(list(function (..., workers = availableCores(), 
[16:05:59.899]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:05:59.899]                     envir = parent.frame()) 
[16:05:59.899]                   {
[16:05:59.899]                     if (is.function(workers)) 
[16:05:59.899]                       workers <- workers()
[16:05:59.899]                     workers <- structure(as.integer(workers), 
[16:05:59.899]                       class = class(workers))
[16:05:59.899]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:05:59.899]                       workers >= 1)
[16:05:59.899]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:05:59.899]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:05:59.899]                     }
[16:05:59.899]                     future <- MultisessionFuture(..., workers = workers, 
[16:05:59.899]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:05:59.899]                       envir = envir)
[16:05:59.899]                     if (!future$lazy) 
[16:05:59.899]                       future <- run(future)
[16:05:59.899]                     invisible(future)
[16:05:59.899]                   }), .cleanup = FALSE, .init = FALSE)
[16:05:59.899]                 }
[16:05:59.899]             }
[16:05:59.899]         }
[16:05:59.899]     })
[16:05:59.899]     if (TRUE) {
[16:05:59.899]         base::sink(type = "output", split = FALSE)
[16:05:59.899]         if (TRUE) {
[16:05:59.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:05:59.899]         }
[16:05:59.899]         else {
[16:05:59.899]             ...future.result["stdout"] <- base::list(NULL)
[16:05:59.899]         }
[16:05:59.899]         base::close(...future.stdout)
[16:05:59.899]         ...future.stdout <- NULL
[16:05:59.899]     }
[16:05:59.899]     ...future.result$conditions <- ...future.conditions
[16:05:59.899]     ...future.result$finished <- base::Sys.time()
[16:05:59.899]     ...future.result
[16:05:59.899] }
[16:05:59.902] MultisessionFuture started
[16:05:59.902] - Launch lazy future ... done
[16:05:59.902] run() for ‘MultisessionFuture’ ... done
[16:06:00.449] receiveMessageFromWorker() for ClusterFuture ...
[16:06:00.449] - Validating connection of MultisessionFuture
[16:06:00.450] - received message: FutureResult
[16:06:00.450] - Received FutureResult
[16:06:00.450] - Erased future from FutureRegistry
[16:06:00.450] result() for ClusterFuture ...
[16:06:00.450] - result already collected: FutureResult
[16:06:00.450] result() for ClusterFuture ... done
[16:06:00.450] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:00.450] A MultisessionFuture was resolved (result was not collected)
[16:06:00.451] getGlobalsAndPackages() ...
[16:06:00.451] Searching for globals...
[16:06:00.452] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:00.452] Searching for globals ... DONE
[16:06:00.452] Resolving globals: FALSE
[16:06:00.452] 
[16:06:00.452] 
[16:06:00.453] getGlobalsAndPackages() ... DONE
[16:06:00.453] run() for ‘Future’ ...
[16:06:00.453] - state: ‘created’
[16:06:00.453] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:00.467] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:00.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:00.467]   - Field: ‘node’
[16:06:00.467]   - Field: ‘label’
[16:06:00.467]   - Field: ‘local’
[16:06:00.467]   - Field: ‘owner’
[16:06:00.467]   - Field: ‘envir’
[16:06:00.467]   - Field: ‘workers’
[16:06:00.468]   - Field: ‘packages’
[16:06:00.468]   - Field: ‘gc’
[16:06:00.468]   - Field: ‘conditions’
[16:06:00.468]   - Field: ‘persistent’
[16:06:00.468]   - Field: ‘expr’
[16:06:00.468]   - Field: ‘uuid’
[16:06:00.468]   - Field: ‘seed’
[16:06:00.468]   - Field: ‘version’
[16:06:00.468]   - Field: ‘result’
[16:06:00.468]   - Field: ‘asynchronous’
[16:06:00.468]   - Field: ‘calls’
[16:06:00.469]   - Field: ‘globals’
[16:06:00.469]   - Field: ‘stdout’
[16:06:00.469]   - Field: ‘earlySignal’
[16:06:00.469]   - Field: ‘lazy’
[16:06:00.469]   - Field: ‘state’
[16:06:00.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:00.469] - Launch lazy future ...
[16:06:00.469] Packages needed by the future expression (n = 0): <none>
[16:06:00.469] Packages needed by future strategies (n = 0): <none>
[16:06:00.470] {
[16:06:00.470]     {
[16:06:00.470]         {
[16:06:00.470]             ...future.startTime <- base::Sys.time()
[16:06:00.470]             {
[16:06:00.470]                 {
[16:06:00.470]                   {
[16:06:00.470]                     {
[16:06:00.470]                       base::local({
[16:06:00.470]                         has_future <- base::requireNamespace("future", 
[16:06:00.470]                           quietly = TRUE)
[16:06:00.470]                         if (has_future) {
[16:06:00.470]                           ns <- base::getNamespace("future")
[16:06:00.470]                           version <- ns[[".package"]][["version"]]
[16:06:00.470]                           if (is.null(version)) 
[16:06:00.470]                             version <- utils::packageVersion("future")
[16:06:00.470]                         }
[16:06:00.470]                         else {
[16:06:00.470]                           version <- NULL
[16:06:00.470]                         }
[16:06:00.470]                         if (!has_future || version < "1.8.0") {
[16:06:00.470]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:00.470]                             "", base::R.version$version.string), 
[16:06:00.470]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:00.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:00.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:00.470]                               "release", "version")], collapse = " "), 
[16:06:00.470]                             hostname = base::Sys.info()[["nodename"]])
[16:06:00.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:00.470]                             info)
[16:06:00.470]                           info <- base::paste(info, collapse = "; ")
[16:06:00.470]                           if (!has_future) {
[16:06:00.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:00.470]                               info)
[16:06:00.470]                           }
[16:06:00.470]                           else {
[16:06:00.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:00.470]                               info, version)
[16:06:00.470]                           }
[16:06:00.470]                           base::stop(msg)
[16:06:00.470]                         }
[16:06:00.470]                       })
[16:06:00.470]                     }
[16:06:00.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:00.470]                     base::options(mc.cores = 1L)
[16:06:00.470]                   }
[16:06:00.470]                   options(future.plan = NULL)
[16:06:00.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:00.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:00.470]                 }
[16:06:00.470]                 ...future.workdir <- getwd()
[16:06:00.470]             }
[16:06:00.470]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:00.470]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:00.470]         }
[16:06:00.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:00.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:00.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:00.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:00.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:00.470]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:00.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:00.470]             base::names(...future.oldOptions))
[16:06:00.470]     }
[16:06:00.470]     if (FALSE) {
[16:06:00.470]     }
[16:06:00.470]     else {
[16:06:00.470]         if (TRUE) {
[16:06:00.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:00.470]                 open = "w")
[16:06:00.470]         }
[16:06:00.470]         else {
[16:06:00.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:00.470]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:00.470]         }
[16:06:00.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:00.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:00.470]             base::sink(type = "output", split = FALSE)
[16:06:00.470]             base::close(...future.stdout)
[16:06:00.470]         }, add = TRUE)
[16:06:00.470]     }
[16:06:00.470]     ...future.frame <- base::sys.nframe()
[16:06:00.470]     ...future.conditions <- base::list()
[16:06:00.470]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:00.470]     if (FALSE) {
[16:06:00.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:00.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:00.470]     }
[16:06:00.470]     ...future.result <- base::tryCatch({
[16:06:00.470]         base::withCallingHandlers({
[16:06:00.470]             ...future.value <- base::withVisible(base::local({
[16:06:00.470]                 ...future.makeSendCondition <- base::local({
[16:06:00.470]                   sendCondition <- NULL
[16:06:00.470]                   function(frame = 1L) {
[16:06:00.470]                     if (is.function(sendCondition)) 
[16:06:00.470]                       return(sendCondition)
[16:06:00.470]                     ns <- getNamespace("parallel")
[16:06:00.470]                     if (exists("sendData", mode = "function", 
[16:06:00.470]                       envir = ns)) {
[16:06:00.470]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:00.470]                         envir = ns)
[16:06:00.470]                       envir <- sys.frame(frame)
[16:06:00.470]                       master <- NULL
[16:06:00.470]                       while (!identical(envir, .GlobalEnv) && 
[16:06:00.470]                         !identical(envir, emptyenv())) {
[16:06:00.470]                         if (exists("master", mode = "list", envir = envir, 
[16:06:00.470]                           inherits = FALSE)) {
[16:06:00.470]                           master <- get("master", mode = "list", 
[16:06:00.470]                             envir = envir, inherits = FALSE)
[16:06:00.470]                           if (inherits(master, c("SOCKnode", 
[16:06:00.470]                             "SOCK0node"))) {
[16:06:00.470]                             sendCondition <<- function(cond) {
[16:06:00.470]                               data <- list(type = "VALUE", value = cond, 
[16:06:00.470]                                 success = TRUE)
[16:06:00.470]                               parallel_sendData(master, data)
[16:06:00.470]                             }
[16:06:00.470]                             return(sendCondition)
[16:06:00.470]                           }
[16:06:00.470]                         }
[16:06:00.470]                         frame <- frame + 1L
[16:06:00.470]                         envir <- sys.frame(frame)
[16:06:00.470]                       }
[16:06:00.470]                     }
[16:06:00.470]                     sendCondition <<- function(cond) NULL
[16:06:00.470]                   }
[16:06:00.470]                 })
[16:06:00.470]                 withCallingHandlers({
[16:06:00.470]                   {
[16:06:00.470]                     Sys.sleep(0.5)
[16:06:00.470]                     list(a = 1, b = 42L)
[16:06:00.470]                   }
[16:06:00.470]                 }, immediateCondition = function(cond) {
[16:06:00.470]                   sendCondition <- ...future.makeSendCondition()
[16:06:00.470]                   sendCondition(cond)
[16:06:00.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:00.470]                   {
[16:06:00.470]                     inherits <- base::inherits
[16:06:00.470]                     invokeRestart <- base::invokeRestart
[16:06:00.470]                     is.null <- base::is.null
[16:06:00.470]                     muffled <- FALSE
[16:06:00.470]                     if (inherits(cond, "message")) {
[16:06:00.470]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:00.470]                       if (muffled) 
[16:06:00.470]                         invokeRestart("muffleMessage")
[16:06:00.470]                     }
[16:06:00.470]                     else if (inherits(cond, "warning")) {
[16:06:00.470]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:00.470]                       if (muffled) 
[16:06:00.470]                         invokeRestart("muffleWarning")
[16:06:00.470]                     }
[16:06:00.470]                     else if (inherits(cond, "condition")) {
[16:06:00.470]                       if (!is.null(pattern)) {
[16:06:00.470]                         computeRestarts <- base::computeRestarts
[16:06:00.470]                         grepl <- base::grepl
[16:06:00.470]                         restarts <- computeRestarts(cond)
[16:06:00.470]                         for (restart in restarts) {
[16:06:00.470]                           name <- restart$name
[16:06:00.470]                           if (is.null(name)) 
[16:06:00.470]                             next
[16:06:00.470]                           if (!grepl(pattern, name)) 
[16:06:00.470]                             next
[16:06:00.470]                           invokeRestart(restart)
[16:06:00.470]                           muffled <- TRUE
[16:06:00.470]                           break
[16:06:00.470]                         }
[16:06:00.470]                       }
[16:06:00.470]                     }
[16:06:00.470]                     invisible(muffled)
[16:06:00.470]                   }
[16:06:00.470]                   muffleCondition(cond)
[16:06:00.470]                 })
[16:06:00.470]             }))
[16:06:00.470]             future::FutureResult(value = ...future.value$value, 
[16:06:00.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:00.470]                   ...future.rng), globalenv = if (FALSE) 
[16:06:00.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:00.470]                     ...future.globalenv.names))
[16:06:00.470]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:00.470]         }, condition = base::local({
[16:06:00.470]             c <- base::c
[16:06:00.470]             inherits <- base::inherits
[16:06:00.470]             invokeRestart <- base::invokeRestart
[16:06:00.470]             length <- base::length
[16:06:00.470]             list <- base::list
[16:06:00.470]             seq.int <- base::seq.int
[16:06:00.470]             signalCondition <- base::signalCondition
[16:06:00.470]             sys.calls <- base::sys.calls
[16:06:00.470]             `[[` <- base::`[[`
[16:06:00.470]             `+` <- base::`+`
[16:06:00.470]             `<<-` <- base::`<<-`
[16:06:00.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:00.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:00.470]                   3L)]
[16:06:00.470]             }
[16:06:00.470]             function(cond) {
[16:06:00.470]                 is_error <- inherits(cond, "error")
[16:06:00.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:00.470]                   NULL)
[16:06:00.470]                 if (is_error) {
[16:06:00.470]                   sessionInformation <- function() {
[16:06:00.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:00.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:00.470]                       search = base::search(), system = base::Sys.info())
[16:06:00.470]                   }
[16:06:00.470]                   ...future.conditions[[length(...future.conditions) + 
[16:06:00.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:00.470]                     cond$call), session = sessionInformation(), 
[16:06:00.470]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:00.470]                   signalCondition(cond)
[16:06:00.470]                 }
[16:06:00.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:00.470]                 "immediateCondition"))) {
[16:06:00.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:00.470]                   ...future.conditions[[length(...future.conditions) + 
[16:06:00.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:00.470]                   if (TRUE && !signal) {
[16:06:00.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:00.470]                     {
[16:06:00.470]                       inherits <- base::inherits
[16:06:00.470]                       invokeRestart <- base::invokeRestart
[16:06:00.470]                       is.null <- base::is.null
[16:06:00.470]                       muffled <- FALSE
[16:06:00.470]                       if (inherits(cond, "message")) {
[16:06:00.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:00.470]                         if (muffled) 
[16:06:00.470]                           invokeRestart("muffleMessage")
[16:06:00.470]                       }
[16:06:00.470]                       else if (inherits(cond, "warning")) {
[16:06:00.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:00.470]                         if (muffled) 
[16:06:00.470]                           invokeRestart("muffleWarning")
[16:06:00.470]                       }
[16:06:00.470]                       else if (inherits(cond, "condition")) {
[16:06:00.470]                         if (!is.null(pattern)) {
[16:06:00.470]                           computeRestarts <- base::computeRestarts
[16:06:00.470]                           grepl <- base::grepl
[16:06:00.470]                           restarts <- computeRestarts(cond)
[16:06:00.470]                           for (restart in restarts) {
[16:06:00.470]                             name <- restart$name
[16:06:00.470]                             if (is.null(name)) 
[16:06:00.470]                               next
[16:06:00.470]                             if (!grepl(pattern, name)) 
[16:06:00.470]                               next
[16:06:00.470]                             invokeRestart(restart)
[16:06:00.470]                             muffled <- TRUE
[16:06:00.470]                             break
[16:06:00.470]                           }
[16:06:00.470]                         }
[16:06:00.470]                       }
[16:06:00.470]                       invisible(muffled)
[16:06:00.470]                     }
[16:06:00.470]                     muffleCondition(cond, pattern = "^muffle")
[16:06:00.470]                   }
[16:06:00.470]                 }
[16:06:00.470]                 else {
[16:06:00.470]                   if (TRUE) {
[16:06:00.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:00.470]                     {
[16:06:00.470]                       inherits <- base::inherits
[16:06:00.470]                       invokeRestart <- base::invokeRestart
[16:06:00.470]                       is.null <- base::is.null
[16:06:00.470]                       muffled <- FALSE
[16:06:00.470]                       if (inherits(cond, "message")) {
[16:06:00.470]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:00.470]                         if (muffled) 
[16:06:00.470]                           invokeRestart("muffleMessage")
[16:06:00.470]                       }
[16:06:00.470]                       else if (inherits(cond, "warning")) {
[16:06:00.470]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:00.470]                         if (muffled) 
[16:06:00.470]                           invokeRestart("muffleWarning")
[16:06:00.470]                       }
[16:06:00.470]                       else if (inherits(cond, "condition")) {
[16:06:00.470]                         if (!is.null(pattern)) {
[16:06:00.470]                           computeRestarts <- base::computeRestarts
[16:06:00.470]                           grepl <- base::grepl
[16:06:00.470]                           restarts <- computeRestarts(cond)
[16:06:00.470]                           for (restart in restarts) {
[16:06:00.470]                             name <- restart$name
[16:06:00.470]                             if (is.null(name)) 
[16:06:00.470]                               next
[16:06:00.470]                             if (!grepl(pattern, name)) 
[16:06:00.470]                               next
[16:06:00.470]                             invokeRestart(restart)
[16:06:00.470]                             muffled <- TRUE
[16:06:00.470]                             break
[16:06:00.470]                           }
[16:06:00.470]                         }
[16:06:00.470]                       }
[16:06:00.470]                       invisible(muffled)
[16:06:00.470]                     }
[16:06:00.470]                     muffleCondition(cond, pattern = "^muffle")
[16:06:00.470]                   }
[16:06:00.470]                 }
[16:06:00.470]             }
[16:06:00.470]         }))
[16:06:00.470]     }, error = function(ex) {
[16:06:00.470]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:00.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:00.470]                 ...future.rng), started = ...future.startTime, 
[16:06:00.470]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:00.470]             version = "1.8"), class = "FutureResult")
[16:06:00.470]     }, finally = {
[16:06:00.470]         if (!identical(...future.workdir, getwd())) 
[16:06:00.470]             setwd(...future.workdir)
[16:06:00.470]         {
[16:06:00.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:00.470]                 ...future.oldOptions$nwarnings <- NULL
[16:06:00.470]             }
[16:06:00.470]             base::options(...future.oldOptions)
[16:06:00.470]             if (.Platform$OS.type == "windows") {
[16:06:00.470]                 old_names <- names(...future.oldEnvVars)
[16:06:00.470]                 envs <- base::Sys.getenv()
[16:06:00.470]                 names <- names(envs)
[16:06:00.470]                 common <- intersect(names, old_names)
[16:06:00.470]                 added <- setdiff(names, old_names)
[16:06:00.470]                 removed <- setdiff(old_names, names)
[16:06:00.470]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:00.470]                   envs[common]]
[16:06:00.470]                 NAMES <- toupper(changed)
[16:06:00.470]                 args <- list()
[16:06:00.470]                 for (kk in seq_along(NAMES)) {
[16:06:00.470]                   name <- changed[[kk]]
[16:06:00.470]                   NAME <- NAMES[[kk]]
[16:06:00.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:00.470]                     next
[16:06:00.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:00.470]                 }
[16:06:00.470]                 NAMES <- toupper(added)
[16:06:00.470]                 for (kk in seq_along(NAMES)) {
[16:06:00.470]                   name <- added[[kk]]
[16:06:00.470]                   NAME <- NAMES[[kk]]
[16:06:00.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:00.470]                     next
[16:06:00.470]                   args[[name]] <- ""
[16:06:00.470]                 }
[16:06:00.470]                 NAMES <- toupper(removed)
[16:06:00.470]                 for (kk in seq_along(NAMES)) {
[16:06:00.470]                   name <- removed[[kk]]
[16:06:00.470]                   NAME <- NAMES[[kk]]
[16:06:00.470]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:00.470]                     next
[16:06:00.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:00.470]                 }
[16:06:00.470]                 if (length(args) > 0) 
[16:06:00.470]                   base::do.call(base::Sys.setenv, args = args)
[16:06:00.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:00.470]             }
[16:06:00.470]             else {
[16:06:00.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:00.470]             }
[16:06:00.470]             {
[16:06:00.470]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:00.470]                   0L) {
[16:06:00.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:00.470]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:00.470]                   base::options(opts)
[16:06:00.470]                 }
[16:06:00.470]                 {
[16:06:00.470]                   {
[16:06:00.470]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:00.470]                     NULL
[16:06:00.470]                   }
[16:06:00.470]                   options(future.plan = NULL)
[16:06:00.470]                   if (is.na(NA_character_)) 
[16:06:00.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:00.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:00.470]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:00.470]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:00.470]                     envir = parent.frame()) 
[16:06:00.470]                   {
[16:06:00.470]                     if (is.function(workers)) 
[16:06:00.470]                       workers <- workers()
[16:06:00.470]                     workers <- structure(as.integer(workers), 
[16:06:00.470]                       class = class(workers))
[16:06:00.470]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:00.470]                       workers >= 1)
[16:06:00.470]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:00.470]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:00.470]                     }
[16:06:00.470]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:00.470]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:00.470]                       envir = envir)
[16:06:00.470]                     if (!future$lazy) 
[16:06:00.470]                       future <- run(future)
[16:06:00.470]                     invisible(future)
[16:06:00.470]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:00.470]                 }
[16:06:00.470]             }
[16:06:00.470]         }
[16:06:00.470]     })
[16:06:00.470]     if (TRUE) {
[16:06:00.470]         base::sink(type = "output", split = FALSE)
[16:06:00.470]         if (TRUE) {
[16:06:00.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:00.470]         }
[16:06:00.470]         else {
[16:06:00.470]             ...future.result["stdout"] <- base::list(NULL)
[16:06:00.470]         }
[16:06:00.470]         base::close(...future.stdout)
[16:06:00.470]         ...future.stdout <- NULL
[16:06:00.470]     }
[16:06:00.470]     ...future.result$conditions <- ...future.conditions
[16:06:00.470]     ...future.result$finished <- base::Sys.time()
[16:06:00.470]     ...future.result
[16:06:00.470] }
[16:06:00.473] MultisessionFuture started
[16:06:00.474] - Launch lazy future ... done
[16:06:00.474] run() for ‘MultisessionFuture’ ... done
[16:06:01.021] receiveMessageFromWorker() for ClusterFuture ...
[16:06:01.021] - Validating connection of MultisessionFuture
[16:06:01.022] - received message: FutureResult
[16:06:01.022] - Received FutureResult
[16:06:01.022] - Erased future from FutureRegistry
[16:06:01.022] result() for ClusterFuture ...
[16:06:01.022] - result already collected: FutureResult
[16:06:01.022] result() for ClusterFuture ... done
[16:06:01.022] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:01.023] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:06:01.023] getGlobalsAndPackages() ...
[16:06:01.023] Searching for globals...
[16:06:01.024] - globals found: [2] ‘list’, ‘stop’
[16:06:01.024] Searching for globals ... DONE
[16:06:01.024] Resolving globals: FALSE
[16:06:01.024] 
[16:06:01.024] 
[16:06:01.024] getGlobalsAndPackages() ... DONE
[16:06:01.025] run() for ‘Future’ ...
[16:06:01.025] - state: ‘created’
[16:06:01.025] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:01.039] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:01.039] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:01.039]   - Field: ‘node’
[16:06:01.039]   - Field: ‘label’
[16:06:01.039]   - Field: ‘local’
[16:06:01.039]   - Field: ‘owner’
[16:06:01.039]   - Field: ‘envir’
[16:06:01.039]   - Field: ‘workers’
[16:06:01.040]   - Field: ‘packages’
[16:06:01.040]   - Field: ‘gc’
[16:06:01.040]   - Field: ‘conditions’
[16:06:01.040]   - Field: ‘persistent’
[16:06:01.040]   - Field: ‘expr’
[16:06:01.040]   - Field: ‘uuid’
[16:06:01.040]   - Field: ‘seed’
[16:06:01.040]   - Field: ‘version’
[16:06:01.040]   - Field: ‘result’
[16:06:01.040]   - Field: ‘asynchronous’
[16:06:01.040]   - Field: ‘calls’
[16:06:01.041]   - Field: ‘globals’
[16:06:01.041]   - Field: ‘stdout’
[16:06:01.041]   - Field: ‘earlySignal’
[16:06:01.041]   - Field: ‘lazy’
[16:06:01.041]   - Field: ‘state’
[16:06:01.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:01.041] - Launch lazy future ...
[16:06:01.041] Packages needed by the future expression (n = 0): <none>
[16:06:01.042] Packages needed by future strategies (n = 0): <none>
[16:06:01.042] {
[16:06:01.042]     {
[16:06:01.042]         {
[16:06:01.042]             ...future.startTime <- base::Sys.time()
[16:06:01.042]             {
[16:06:01.042]                 {
[16:06:01.042]                   {
[16:06:01.042]                     {
[16:06:01.042]                       base::local({
[16:06:01.042]                         has_future <- base::requireNamespace("future", 
[16:06:01.042]                           quietly = TRUE)
[16:06:01.042]                         if (has_future) {
[16:06:01.042]                           ns <- base::getNamespace("future")
[16:06:01.042]                           version <- ns[[".package"]][["version"]]
[16:06:01.042]                           if (is.null(version)) 
[16:06:01.042]                             version <- utils::packageVersion("future")
[16:06:01.042]                         }
[16:06:01.042]                         else {
[16:06:01.042]                           version <- NULL
[16:06:01.042]                         }
[16:06:01.042]                         if (!has_future || version < "1.8.0") {
[16:06:01.042]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:01.042]                             "", base::R.version$version.string), 
[16:06:01.042]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:01.042]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:01.042]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:01.042]                               "release", "version")], collapse = " "), 
[16:06:01.042]                             hostname = base::Sys.info()[["nodename"]])
[16:06:01.042]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:01.042]                             info)
[16:06:01.042]                           info <- base::paste(info, collapse = "; ")
[16:06:01.042]                           if (!has_future) {
[16:06:01.042]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:01.042]                               info)
[16:06:01.042]                           }
[16:06:01.042]                           else {
[16:06:01.042]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:01.042]                               info, version)
[16:06:01.042]                           }
[16:06:01.042]                           base::stop(msg)
[16:06:01.042]                         }
[16:06:01.042]                       })
[16:06:01.042]                     }
[16:06:01.042]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:01.042]                     base::options(mc.cores = 1L)
[16:06:01.042]                   }
[16:06:01.042]                   options(future.plan = NULL)
[16:06:01.042]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.042]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:01.042]                 }
[16:06:01.042]                 ...future.workdir <- getwd()
[16:06:01.042]             }
[16:06:01.042]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:01.042]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:01.042]         }
[16:06:01.042]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:01.042]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:01.042]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:01.042]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:01.042]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:01.042]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:01.042]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:01.042]             base::names(...future.oldOptions))
[16:06:01.042]     }
[16:06:01.042]     if (FALSE) {
[16:06:01.042]     }
[16:06:01.042]     else {
[16:06:01.042]         if (TRUE) {
[16:06:01.042]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:01.042]                 open = "w")
[16:06:01.042]         }
[16:06:01.042]         else {
[16:06:01.042]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:01.042]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:01.042]         }
[16:06:01.042]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:01.042]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:01.042]             base::sink(type = "output", split = FALSE)
[16:06:01.042]             base::close(...future.stdout)
[16:06:01.042]         }, add = TRUE)
[16:06:01.042]     }
[16:06:01.042]     ...future.frame <- base::sys.nframe()
[16:06:01.042]     ...future.conditions <- base::list()
[16:06:01.042]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:01.042]     if (FALSE) {
[16:06:01.042]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:01.042]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:01.042]     }
[16:06:01.042]     ...future.result <- base::tryCatch({
[16:06:01.042]         base::withCallingHandlers({
[16:06:01.042]             ...future.value <- base::withVisible(base::local({
[16:06:01.042]                 ...future.makeSendCondition <- base::local({
[16:06:01.042]                   sendCondition <- NULL
[16:06:01.042]                   function(frame = 1L) {
[16:06:01.042]                     if (is.function(sendCondition)) 
[16:06:01.042]                       return(sendCondition)
[16:06:01.042]                     ns <- getNamespace("parallel")
[16:06:01.042]                     if (exists("sendData", mode = "function", 
[16:06:01.042]                       envir = ns)) {
[16:06:01.042]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:01.042]                         envir = ns)
[16:06:01.042]                       envir <- sys.frame(frame)
[16:06:01.042]                       master <- NULL
[16:06:01.042]                       while (!identical(envir, .GlobalEnv) && 
[16:06:01.042]                         !identical(envir, emptyenv())) {
[16:06:01.042]                         if (exists("master", mode = "list", envir = envir, 
[16:06:01.042]                           inherits = FALSE)) {
[16:06:01.042]                           master <- get("master", mode = "list", 
[16:06:01.042]                             envir = envir, inherits = FALSE)
[16:06:01.042]                           if (inherits(master, c("SOCKnode", 
[16:06:01.042]                             "SOCK0node"))) {
[16:06:01.042]                             sendCondition <<- function(cond) {
[16:06:01.042]                               data <- list(type = "VALUE", value = cond, 
[16:06:01.042]                                 success = TRUE)
[16:06:01.042]                               parallel_sendData(master, data)
[16:06:01.042]                             }
[16:06:01.042]                             return(sendCondition)
[16:06:01.042]                           }
[16:06:01.042]                         }
[16:06:01.042]                         frame <- frame + 1L
[16:06:01.042]                         envir <- sys.frame(frame)
[16:06:01.042]                       }
[16:06:01.042]                     }
[16:06:01.042]                     sendCondition <<- function(cond) NULL
[16:06:01.042]                   }
[16:06:01.042]                 })
[16:06:01.042]                 withCallingHandlers({
[16:06:01.042]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:01.042]                 }, immediateCondition = function(cond) {
[16:06:01.042]                   sendCondition <- ...future.makeSendCondition()
[16:06:01.042]                   sendCondition(cond)
[16:06:01.042]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.042]                   {
[16:06:01.042]                     inherits <- base::inherits
[16:06:01.042]                     invokeRestart <- base::invokeRestart
[16:06:01.042]                     is.null <- base::is.null
[16:06:01.042]                     muffled <- FALSE
[16:06:01.042]                     if (inherits(cond, "message")) {
[16:06:01.042]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:01.042]                       if (muffled) 
[16:06:01.042]                         invokeRestart("muffleMessage")
[16:06:01.042]                     }
[16:06:01.042]                     else if (inherits(cond, "warning")) {
[16:06:01.042]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:01.042]                       if (muffled) 
[16:06:01.042]                         invokeRestart("muffleWarning")
[16:06:01.042]                     }
[16:06:01.042]                     else if (inherits(cond, "condition")) {
[16:06:01.042]                       if (!is.null(pattern)) {
[16:06:01.042]                         computeRestarts <- base::computeRestarts
[16:06:01.042]                         grepl <- base::grepl
[16:06:01.042]                         restarts <- computeRestarts(cond)
[16:06:01.042]                         for (restart in restarts) {
[16:06:01.042]                           name <- restart$name
[16:06:01.042]                           if (is.null(name)) 
[16:06:01.042]                             next
[16:06:01.042]                           if (!grepl(pattern, name)) 
[16:06:01.042]                             next
[16:06:01.042]                           invokeRestart(restart)
[16:06:01.042]                           muffled <- TRUE
[16:06:01.042]                           break
[16:06:01.042]                         }
[16:06:01.042]                       }
[16:06:01.042]                     }
[16:06:01.042]                     invisible(muffled)
[16:06:01.042]                   }
[16:06:01.042]                   muffleCondition(cond)
[16:06:01.042]                 })
[16:06:01.042]             }))
[16:06:01.042]             future::FutureResult(value = ...future.value$value, 
[16:06:01.042]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.042]                   ...future.rng), globalenv = if (FALSE) 
[16:06:01.042]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:01.042]                     ...future.globalenv.names))
[16:06:01.042]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:01.042]         }, condition = base::local({
[16:06:01.042]             c <- base::c
[16:06:01.042]             inherits <- base::inherits
[16:06:01.042]             invokeRestart <- base::invokeRestart
[16:06:01.042]             length <- base::length
[16:06:01.042]             list <- base::list
[16:06:01.042]             seq.int <- base::seq.int
[16:06:01.042]             signalCondition <- base::signalCondition
[16:06:01.042]             sys.calls <- base::sys.calls
[16:06:01.042]             `[[` <- base::`[[`
[16:06:01.042]             `+` <- base::`+`
[16:06:01.042]             `<<-` <- base::`<<-`
[16:06:01.042]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:01.042]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:01.042]                   3L)]
[16:06:01.042]             }
[16:06:01.042]             function(cond) {
[16:06:01.042]                 is_error <- inherits(cond, "error")
[16:06:01.042]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:01.042]                   NULL)
[16:06:01.042]                 if (is_error) {
[16:06:01.042]                   sessionInformation <- function() {
[16:06:01.042]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:01.042]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:01.042]                       search = base::search(), system = base::Sys.info())
[16:06:01.042]                   }
[16:06:01.042]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.042]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:01.042]                     cond$call), session = sessionInformation(), 
[16:06:01.042]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:01.042]                   signalCondition(cond)
[16:06:01.042]                 }
[16:06:01.042]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:01.042]                 "immediateCondition"))) {
[16:06:01.042]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:01.042]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.042]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:01.042]                   if (TRUE && !signal) {
[16:06:01.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.042]                     {
[16:06:01.042]                       inherits <- base::inherits
[16:06:01.042]                       invokeRestart <- base::invokeRestart
[16:06:01.042]                       is.null <- base::is.null
[16:06:01.042]                       muffled <- FALSE
[16:06:01.042]                       if (inherits(cond, "message")) {
[16:06:01.042]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.042]                         if (muffled) 
[16:06:01.042]                           invokeRestart("muffleMessage")
[16:06:01.042]                       }
[16:06:01.042]                       else if (inherits(cond, "warning")) {
[16:06:01.042]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.042]                         if (muffled) 
[16:06:01.042]                           invokeRestart("muffleWarning")
[16:06:01.042]                       }
[16:06:01.042]                       else if (inherits(cond, "condition")) {
[16:06:01.042]                         if (!is.null(pattern)) {
[16:06:01.042]                           computeRestarts <- base::computeRestarts
[16:06:01.042]                           grepl <- base::grepl
[16:06:01.042]                           restarts <- computeRestarts(cond)
[16:06:01.042]                           for (restart in restarts) {
[16:06:01.042]                             name <- restart$name
[16:06:01.042]                             if (is.null(name)) 
[16:06:01.042]                               next
[16:06:01.042]                             if (!grepl(pattern, name)) 
[16:06:01.042]                               next
[16:06:01.042]                             invokeRestart(restart)
[16:06:01.042]                             muffled <- TRUE
[16:06:01.042]                             break
[16:06:01.042]                           }
[16:06:01.042]                         }
[16:06:01.042]                       }
[16:06:01.042]                       invisible(muffled)
[16:06:01.042]                     }
[16:06:01.042]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.042]                   }
[16:06:01.042]                 }
[16:06:01.042]                 else {
[16:06:01.042]                   if (TRUE) {
[16:06:01.042]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.042]                     {
[16:06:01.042]                       inherits <- base::inherits
[16:06:01.042]                       invokeRestart <- base::invokeRestart
[16:06:01.042]                       is.null <- base::is.null
[16:06:01.042]                       muffled <- FALSE
[16:06:01.042]                       if (inherits(cond, "message")) {
[16:06:01.042]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.042]                         if (muffled) 
[16:06:01.042]                           invokeRestart("muffleMessage")
[16:06:01.042]                       }
[16:06:01.042]                       else if (inherits(cond, "warning")) {
[16:06:01.042]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.042]                         if (muffled) 
[16:06:01.042]                           invokeRestart("muffleWarning")
[16:06:01.042]                       }
[16:06:01.042]                       else if (inherits(cond, "condition")) {
[16:06:01.042]                         if (!is.null(pattern)) {
[16:06:01.042]                           computeRestarts <- base::computeRestarts
[16:06:01.042]                           grepl <- base::grepl
[16:06:01.042]                           restarts <- computeRestarts(cond)
[16:06:01.042]                           for (restart in restarts) {
[16:06:01.042]                             name <- restart$name
[16:06:01.042]                             if (is.null(name)) 
[16:06:01.042]                               next
[16:06:01.042]                             if (!grepl(pattern, name)) 
[16:06:01.042]                               next
[16:06:01.042]                             invokeRestart(restart)
[16:06:01.042]                             muffled <- TRUE
[16:06:01.042]                             break
[16:06:01.042]                           }
[16:06:01.042]                         }
[16:06:01.042]                       }
[16:06:01.042]                       invisible(muffled)
[16:06:01.042]                     }
[16:06:01.042]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.042]                   }
[16:06:01.042]                 }
[16:06:01.042]             }
[16:06:01.042]         }))
[16:06:01.042]     }, error = function(ex) {
[16:06:01.042]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:01.042]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.042]                 ...future.rng), started = ...future.startTime, 
[16:06:01.042]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:01.042]             version = "1.8"), class = "FutureResult")
[16:06:01.042]     }, finally = {
[16:06:01.042]         if (!identical(...future.workdir, getwd())) 
[16:06:01.042]             setwd(...future.workdir)
[16:06:01.042]         {
[16:06:01.042]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:01.042]                 ...future.oldOptions$nwarnings <- NULL
[16:06:01.042]             }
[16:06:01.042]             base::options(...future.oldOptions)
[16:06:01.042]             if (.Platform$OS.type == "windows") {
[16:06:01.042]                 old_names <- names(...future.oldEnvVars)
[16:06:01.042]                 envs <- base::Sys.getenv()
[16:06:01.042]                 names <- names(envs)
[16:06:01.042]                 common <- intersect(names, old_names)
[16:06:01.042]                 added <- setdiff(names, old_names)
[16:06:01.042]                 removed <- setdiff(old_names, names)
[16:06:01.042]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:01.042]                   envs[common]]
[16:06:01.042]                 NAMES <- toupper(changed)
[16:06:01.042]                 args <- list()
[16:06:01.042]                 for (kk in seq_along(NAMES)) {
[16:06:01.042]                   name <- changed[[kk]]
[16:06:01.042]                   NAME <- NAMES[[kk]]
[16:06:01.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.042]                     next
[16:06:01.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.042]                 }
[16:06:01.042]                 NAMES <- toupper(added)
[16:06:01.042]                 for (kk in seq_along(NAMES)) {
[16:06:01.042]                   name <- added[[kk]]
[16:06:01.042]                   NAME <- NAMES[[kk]]
[16:06:01.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.042]                     next
[16:06:01.042]                   args[[name]] <- ""
[16:06:01.042]                 }
[16:06:01.042]                 NAMES <- toupper(removed)
[16:06:01.042]                 for (kk in seq_along(NAMES)) {
[16:06:01.042]                   name <- removed[[kk]]
[16:06:01.042]                   NAME <- NAMES[[kk]]
[16:06:01.042]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.042]                     next
[16:06:01.042]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.042]                 }
[16:06:01.042]                 if (length(args) > 0) 
[16:06:01.042]                   base::do.call(base::Sys.setenv, args = args)
[16:06:01.042]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:01.042]             }
[16:06:01.042]             else {
[16:06:01.042]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:01.042]             }
[16:06:01.042]             {
[16:06:01.042]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:01.042]                   0L) {
[16:06:01.042]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:01.042]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:01.042]                   base::options(opts)
[16:06:01.042]                 }
[16:06:01.042]                 {
[16:06:01.042]                   {
[16:06:01.042]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:01.042]                     NULL
[16:06:01.042]                   }
[16:06:01.042]                   options(future.plan = NULL)
[16:06:01.042]                   if (is.na(NA_character_)) 
[16:06:01.042]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.042]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:01.042]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:01.042]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:01.042]                     envir = parent.frame()) 
[16:06:01.042]                   {
[16:06:01.042]                     if (is.function(workers)) 
[16:06:01.042]                       workers <- workers()
[16:06:01.042]                     workers <- structure(as.integer(workers), 
[16:06:01.042]                       class = class(workers))
[16:06:01.042]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:01.042]                       workers >= 1)
[16:06:01.042]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:01.042]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:01.042]                     }
[16:06:01.042]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:01.042]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:01.042]                       envir = envir)
[16:06:01.042]                     if (!future$lazy) 
[16:06:01.042]                       future <- run(future)
[16:06:01.042]                     invisible(future)
[16:06:01.042]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:01.042]                 }
[16:06:01.042]             }
[16:06:01.042]         }
[16:06:01.042]     })
[16:06:01.042]     if (TRUE) {
[16:06:01.042]         base::sink(type = "output", split = FALSE)
[16:06:01.042]         if (TRUE) {
[16:06:01.042]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:01.042]         }
[16:06:01.042]         else {
[16:06:01.042]             ...future.result["stdout"] <- base::list(NULL)
[16:06:01.042]         }
[16:06:01.042]         base::close(...future.stdout)
[16:06:01.042]         ...future.stdout <- NULL
[16:06:01.042]     }
[16:06:01.042]     ...future.result$conditions <- ...future.conditions
[16:06:01.042]     ...future.result$finished <- base::Sys.time()
[16:06:01.042]     ...future.result
[16:06:01.042] }
[16:06:01.045] MultisessionFuture started
[16:06:01.046] - Launch lazy future ... done
[16:06:01.046] run() for ‘MultisessionFuture’ ... done
[16:06:01.092] receiveMessageFromWorker() for ClusterFuture ...
[16:06:01.092] - Validating connection of MultisessionFuture
[16:06:01.093] - received message: FutureResult
[16:06:01.093] - Received FutureResult
[16:06:01.093] - Erased future from FutureRegistry
[16:06:01.093] result() for ClusterFuture ...
[16:06:01.093] - result already collected: FutureResult
[16:06:01.093] result() for ClusterFuture ... done
[16:06:01.093] signalConditions() ...
[16:06:01.093]  - include = ‘immediateCondition’
[16:06:01.093]  - exclude = 
[16:06:01.093]  - resignal = FALSE
[16:06:01.094]  - Number of conditions: 1
[16:06:01.094] signalConditions() ... done
[16:06:01.094] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:01.094] A MultisessionFuture was resolved (result was not collected)
[16:06:01.094] getGlobalsAndPackages() ...
[16:06:01.094] Searching for globals...
[16:06:01.095] - globals found: [2] ‘list’, ‘stop’
[16:06:01.095] Searching for globals ... DONE
[16:06:01.095] Resolving globals: FALSE
[16:06:01.095] 
[16:06:01.095] 
[16:06:01.096] getGlobalsAndPackages() ... DONE
[16:06:01.096] run() for ‘Future’ ...
[16:06:01.096] - state: ‘created’
[16:06:01.096] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:01.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:01.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:01.110]   - Field: ‘node’
[16:06:01.112]   - Field: ‘label’
[16:06:01.112]   - Field: ‘local’
[16:06:01.112]   - Field: ‘owner’
[16:06:01.112]   - Field: ‘envir’
[16:06:01.113]   - Field: ‘workers’
[16:06:01.113]   - Field: ‘packages’
[16:06:01.113]   - Field: ‘gc’
[16:06:01.113]   - Field: ‘conditions’
[16:06:01.113]   - Field: ‘persistent’
[16:06:01.113]   - Field: ‘expr’
[16:06:01.113]   - Field: ‘uuid’
[16:06:01.113]   - Field: ‘seed’
[16:06:01.113]   - Field: ‘version’
[16:06:01.113]   - Field: ‘result’
[16:06:01.113]   - Field: ‘asynchronous’
[16:06:01.114]   - Field: ‘calls’
[16:06:01.114]   - Field: ‘globals’
[16:06:01.114]   - Field: ‘stdout’
[16:06:01.114]   - Field: ‘earlySignal’
[16:06:01.114]   - Field: ‘lazy’
[16:06:01.114]   - Field: ‘state’
[16:06:01.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:01.114] - Launch lazy future ...
[16:06:01.114] Packages needed by the future expression (n = 0): <none>
[16:06:01.115] Packages needed by future strategies (n = 0): <none>
[16:06:01.115] {
[16:06:01.115]     {
[16:06:01.115]         {
[16:06:01.115]             ...future.startTime <- base::Sys.time()
[16:06:01.115]             {
[16:06:01.115]                 {
[16:06:01.115]                   {
[16:06:01.115]                     {
[16:06:01.115]                       base::local({
[16:06:01.115]                         has_future <- base::requireNamespace("future", 
[16:06:01.115]                           quietly = TRUE)
[16:06:01.115]                         if (has_future) {
[16:06:01.115]                           ns <- base::getNamespace("future")
[16:06:01.115]                           version <- ns[[".package"]][["version"]]
[16:06:01.115]                           if (is.null(version)) 
[16:06:01.115]                             version <- utils::packageVersion("future")
[16:06:01.115]                         }
[16:06:01.115]                         else {
[16:06:01.115]                           version <- NULL
[16:06:01.115]                         }
[16:06:01.115]                         if (!has_future || version < "1.8.0") {
[16:06:01.115]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:01.115]                             "", base::R.version$version.string), 
[16:06:01.115]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:01.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:01.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:01.115]                               "release", "version")], collapse = " "), 
[16:06:01.115]                             hostname = base::Sys.info()[["nodename"]])
[16:06:01.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:01.115]                             info)
[16:06:01.115]                           info <- base::paste(info, collapse = "; ")
[16:06:01.115]                           if (!has_future) {
[16:06:01.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:01.115]                               info)
[16:06:01.115]                           }
[16:06:01.115]                           else {
[16:06:01.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:01.115]                               info, version)
[16:06:01.115]                           }
[16:06:01.115]                           base::stop(msg)
[16:06:01.115]                         }
[16:06:01.115]                       })
[16:06:01.115]                     }
[16:06:01.115]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:01.115]                     base::options(mc.cores = 1L)
[16:06:01.115]                   }
[16:06:01.115]                   options(future.plan = NULL)
[16:06:01.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:01.115]                 }
[16:06:01.115]                 ...future.workdir <- getwd()
[16:06:01.115]             }
[16:06:01.115]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:01.115]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:01.115]         }
[16:06:01.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:01.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:01.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:01.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:01.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:01.115]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:01.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:01.115]             base::names(...future.oldOptions))
[16:06:01.115]     }
[16:06:01.115]     if (FALSE) {
[16:06:01.115]     }
[16:06:01.115]     else {
[16:06:01.115]         if (TRUE) {
[16:06:01.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:01.115]                 open = "w")
[16:06:01.115]         }
[16:06:01.115]         else {
[16:06:01.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:01.115]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:01.115]         }
[16:06:01.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:01.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:01.115]             base::sink(type = "output", split = FALSE)
[16:06:01.115]             base::close(...future.stdout)
[16:06:01.115]         }, add = TRUE)
[16:06:01.115]     }
[16:06:01.115]     ...future.frame <- base::sys.nframe()
[16:06:01.115]     ...future.conditions <- base::list()
[16:06:01.115]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:01.115]     if (FALSE) {
[16:06:01.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:01.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:01.115]     }
[16:06:01.115]     ...future.result <- base::tryCatch({
[16:06:01.115]         base::withCallingHandlers({
[16:06:01.115]             ...future.value <- base::withVisible(base::local({
[16:06:01.115]                 ...future.makeSendCondition <- base::local({
[16:06:01.115]                   sendCondition <- NULL
[16:06:01.115]                   function(frame = 1L) {
[16:06:01.115]                     if (is.function(sendCondition)) 
[16:06:01.115]                       return(sendCondition)
[16:06:01.115]                     ns <- getNamespace("parallel")
[16:06:01.115]                     if (exists("sendData", mode = "function", 
[16:06:01.115]                       envir = ns)) {
[16:06:01.115]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:01.115]                         envir = ns)
[16:06:01.115]                       envir <- sys.frame(frame)
[16:06:01.115]                       master <- NULL
[16:06:01.115]                       while (!identical(envir, .GlobalEnv) && 
[16:06:01.115]                         !identical(envir, emptyenv())) {
[16:06:01.115]                         if (exists("master", mode = "list", envir = envir, 
[16:06:01.115]                           inherits = FALSE)) {
[16:06:01.115]                           master <- get("master", mode = "list", 
[16:06:01.115]                             envir = envir, inherits = FALSE)
[16:06:01.115]                           if (inherits(master, c("SOCKnode", 
[16:06:01.115]                             "SOCK0node"))) {
[16:06:01.115]                             sendCondition <<- function(cond) {
[16:06:01.115]                               data <- list(type = "VALUE", value = cond, 
[16:06:01.115]                                 success = TRUE)
[16:06:01.115]                               parallel_sendData(master, data)
[16:06:01.115]                             }
[16:06:01.115]                             return(sendCondition)
[16:06:01.115]                           }
[16:06:01.115]                         }
[16:06:01.115]                         frame <- frame + 1L
[16:06:01.115]                         envir <- sys.frame(frame)
[16:06:01.115]                       }
[16:06:01.115]                     }
[16:06:01.115]                     sendCondition <<- function(cond) NULL
[16:06:01.115]                   }
[16:06:01.115]                 })
[16:06:01.115]                 withCallingHandlers({
[16:06:01.115]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:01.115]                 }, immediateCondition = function(cond) {
[16:06:01.115]                   sendCondition <- ...future.makeSendCondition()
[16:06:01.115]                   sendCondition(cond)
[16:06:01.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.115]                   {
[16:06:01.115]                     inherits <- base::inherits
[16:06:01.115]                     invokeRestart <- base::invokeRestart
[16:06:01.115]                     is.null <- base::is.null
[16:06:01.115]                     muffled <- FALSE
[16:06:01.115]                     if (inherits(cond, "message")) {
[16:06:01.115]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:01.115]                       if (muffled) 
[16:06:01.115]                         invokeRestart("muffleMessage")
[16:06:01.115]                     }
[16:06:01.115]                     else if (inherits(cond, "warning")) {
[16:06:01.115]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:01.115]                       if (muffled) 
[16:06:01.115]                         invokeRestart("muffleWarning")
[16:06:01.115]                     }
[16:06:01.115]                     else if (inherits(cond, "condition")) {
[16:06:01.115]                       if (!is.null(pattern)) {
[16:06:01.115]                         computeRestarts <- base::computeRestarts
[16:06:01.115]                         grepl <- base::grepl
[16:06:01.115]                         restarts <- computeRestarts(cond)
[16:06:01.115]                         for (restart in restarts) {
[16:06:01.115]                           name <- restart$name
[16:06:01.115]                           if (is.null(name)) 
[16:06:01.115]                             next
[16:06:01.115]                           if (!grepl(pattern, name)) 
[16:06:01.115]                             next
[16:06:01.115]                           invokeRestart(restart)
[16:06:01.115]                           muffled <- TRUE
[16:06:01.115]                           break
[16:06:01.115]                         }
[16:06:01.115]                       }
[16:06:01.115]                     }
[16:06:01.115]                     invisible(muffled)
[16:06:01.115]                   }
[16:06:01.115]                   muffleCondition(cond)
[16:06:01.115]                 })
[16:06:01.115]             }))
[16:06:01.115]             future::FutureResult(value = ...future.value$value, 
[16:06:01.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.115]                   ...future.rng), globalenv = if (FALSE) 
[16:06:01.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:01.115]                     ...future.globalenv.names))
[16:06:01.115]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:01.115]         }, condition = base::local({
[16:06:01.115]             c <- base::c
[16:06:01.115]             inherits <- base::inherits
[16:06:01.115]             invokeRestart <- base::invokeRestart
[16:06:01.115]             length <- base::length
[16:06:01.115]             list <- base::list
[16:06:01.115]             seq.int <- base::seq.int
[16:06:01.115]             signalCondition <- base::signalCondition
[16:06:01.115]             sys.calls <- base::sys.calls
[16:06:01.115]             `[[` <- base::`[[`
[16:06:01.115]             `+` <- base::`+`
[16:06:01.115]             `<<-` <- base::`<<-`
[16:06:01.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:01.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:01.115]                   3L)]
[16:06:01.115]             }
[16:06:01.115]             function(cond) {
[16:06:01.115]                 is_error <- inherits(cond, "error")
[16:06:01.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:01.115]                   NULL)
[16:06:01.115]                 if (is_error) {
[16:06:01.115]                   sessionInformation <- function() {
[16:06:01.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:01.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:01.115]                       search = base::search(), system = base::Sys.info())
[16:06:01.115]                   }
[16:06:01.115]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:01.115]                     cond$call), session = sessionInformation(), 
[16:06:01.115]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:01.115]                   signalCondition(cond)
[16:06:01.115]                 }
[16:06:01.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:01.115]                 "immediateCondition"))) {
[16:06:01.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:01.115]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:01.115]                   if (TRUE && !signal) {
[16:06:01.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.115]                     {
[16:06:01.115]                       inherits <- base::inherits
[16:06:01.115]                       invokeRestart <- base::invokeRestart
[16:06:01.115]                       is.null <- base::is.null
[16:06:01.115]                       muffled <- FALSE
[16:06:01.115]                       if (inherits(cond, "message")) {
[16:06:01.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.115]                         if (muffled) 
[16:06:01.115]                           invokeRestart("muffleMessage")
[16:06:01.115]                       }
[16:06:01.115]                       else if (inherits(cond, "warning")) {
[16:06:01.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.115]                         if (muffled) 
[16:06:01.115]                           invokeRestart("muffleWarning")
[16:06:01.115]                       }
[16:06:01.115]                       else if (inherits(cond, "condition")) {
[16:06:01.115]                         if (!is.null(pattern)) {
[16:06:01.115]                           computeRestarts <- base::computeRestarts
[16:06:01.115]                           grepl <- base::grepl
[16:06:01.115]                           restarts <- computeRestarts(cond)
[16:06:01.115]                           for (restart in restarts) {
[16:06:01.115]                             name <- restart$name
[16:06:01.115]                             if (is.null(name)) 
[16:06:01.115]                               next
[16:06:01.115]                             if (!grepl(pattern, name)) 
[16:06:01.115]                               next
[16:06:01.115]                             invokeRestart(restart)
[16:06:01.115]                             muffled <- TRUE
[16:06:01.115]                             break
[16:06:01.115]                           }
[16:06:01.115]                         }
[16:06:01.115]                       }
[16:06:01.115]                       invisible(muffled)
[16:06:01.115]                     }
[16:06:01.115]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.115]                   }
[16:06:01.115]                 }
[16:06:01.115]                 else {
[16:06:01.115]                   if (TRUE) {
[16:06:01.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.115]                     {
[16:06:01.115]                       inherits <- base::inherits
[16:06:01.115]                       invokeRestart <- base::invokeRestart
[16:06:01.115]                       is.null <- base::is.null
[16:06:01.115]                       muffled <- FALSE
[16:06:01.115]                       if (inherits(cond, "message")) {
[16:06:01.115]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.115]                         if (muffled) 
[16:06:01.115]                           invokeRestart("muffleMessage")
[16:06:01.115]                       }
[16:06:01.115]                       else if (inherits(cond, "warning")) {
[16:06:01.115]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.115]                         if (muffled) 
[16:06:01.115]                           invokeRestart("muffleWarning")
[16:06:01.115]                       }
[16:06:01.115]                       else if (inherits(cond, "condition")) {
[16:06:01.115]                         if (!is.null(pattern)) {
[16:06:01.115]                           computeRestarts <- base::computeRestarts
[16:06:01.115]                           grepl <- base::grepl
[16:06:01.115]                           restarts <- computeRestarts(cond)
[16:06:01.115]                           for (restart in restarts) {
[16:06:01.115]                             name <- restart$name
[16:06:01.115]                             if (is.null(name)) 
[16:06:01.115]                               next
[16:06:01.115]                             if (!grepl(pattern, name)) 
[16:06:01.115]                               next
[16:06:01.115]                             invokeRestart(restart)
[16:06:01.115]                             muffled <- TRUE
[16:06:01.115]                             break
[16:06:01.115]                           }
[16:06:01.115]                         }
[16:06:01.115]                       }
[16:06:01.115]                       invisible(muffled)
[16:06:01.115]                     }
[16:06:01.115]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.115]                   }
[16:06:01.115]                 }
[16:06:01.115]             }
[16:06:01.115]         }))
[16:06:01.115]     }, error = function(ex) {
[16:06:01.115]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:01.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.115]                 ...future.rng), started = ...future.startTime, 
[16:06:01.115]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:01.115]             version = "1.8"), class = "FutureResult")
[16:06:01.115]     }, finally = {
[16:06:01.115]         if (!identical(...future.workdir, getwd())) 
[16:06:01.115]             setwd(...future.workdir)
[16:06:01.115]         {
[16:06:01.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:01.115]                 ...future.oldOptions$nwarnings <- NULL
[16:06:01.115]             }
[16:06:01.115]             base::options(...future.oldOptions)
[16:06:01.115]             if (.Platform$OS.type == "windows") {
[16:06:01.115]                 old_names <- names(...future.oldEnvVars)
[16:06:01.115]                 envs <- base::Sys.getenv()
[16:06:01.115]                 names <- names(envs)
[16:06:01.115]                 common <- intersect(names, old_names)
[16:06:01.115]                 added <- setdiff(names, old_names)
[16:06:01.115]                 removed <- setdiff(old_names, names)
[16:06:01.115]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:01.115]                   envs[common]]
[16:06:01.115]                 NAMES <- toupper(changed)
[16:06:01.115]                 args <- list()
[16:06:01.115]                 for (kk in seq_along(NAMES)) {
[16:06:01.115]                   name <- changed[[kk]]
[16:06:01.115]                   NAME <- NAMES[[kk]]
[16:06:01.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.115]                     next
[16:06:01.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.115]                 }
[16:06:01.115]                 NAMES <- toupper(added)
[16:06:01.115]                 for (kk in seq_along(NAMES)) {
[16:06:01.115]                   name <- added[[kk]]
[16:06:01.115]                   NAME <- NAMES[[kk]]
[16:06:01.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.115]                     next
[16:06:01.115]                   args[[name]] <- ""
[16:06:01.115]                 }
[16:06:01.115]                 NAMES <- toupper(removed)
[16:06:01.115]                 for (kk in seq_along(NAMES)) {
[16:06:01.115]                   name <- removed[[kk]]
[16:06:01.115]                   NAME <- NAMES[[kk]]
[16:06:01.115]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.115]                     next
[16:06:01.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.115]                 }
[16:06:01.115]                 if (length(args) > 0) 
[16:06:01.115]                   base::do.call(base::Sys.setenv, args = args)
[16:06:01.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:01.115]             }
[16:06:01.115]             else {
[16:06:01.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:01.115]             }
[16:06:01.115]             {
[16:06:01.115]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:01.115]                   0L) {
[16:06:01.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:01.115]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:01.115]                   base::options(opts)
[16:06:01.115]                 }
[16:06:01.115]                 {
[16:06:01.115]                   {
[16:06:01.115]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:01.115]                     NULL
[16:06:01.115]                   }
[16:06:01.115]                   options(future.plan = NULL)
[16:06:01.115]                   if (is.na(NA_character_)) 
[16:06:01.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:01.115]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:01.115]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:01.115]                     envir = parent.frame()) 
[16:06:01.115]                   {
[16:06:01.115]                     if (is.function(workers)) 
[16:06:01.115]                       workers <- workers()
[16:06:01.115]                     workers <- structure(as.integer(workers), 
[16:06:01.115]                       class = class(workers))
[16:06:01.115]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:01.115]                       workers >= 1)
[16:06:01.115]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:01.115]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:01.115]                     }
[16:06:01.115]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:01.115]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:01.115]                       envir = envir)
[16:06:01.115]                     if (!future$lazy) 
[16:06:01.115]                       future <- run(future)
[16:06:01.115]                     invisible(future)
[16:06:01.115]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:01.115]                 }
[16:06:01.115]             }
[16:06:01.115]         }
[16:06:01.115]     })
[16:06:01.115]     if (TRUE) {
[16:06:01.115]         base::sink(type = "output", split = FALSE)
[16:06:01.115]         if (TRUE) {
[16:06:01.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:01.115]         }
[16:06:01.115]         else {
[16:06:01.115]             ...future.result["stdout"] <- base::list(NULL)
[16:06:01.115]         }
[16:06:01.115]         base::close(...future.stdout)
[16:06:01.115]         ...future.stdout <- NULL
[16:06:01.115]     }
[16:06:01.115]     ...future.result$conditions <- ...future.conditions
[16:06:01.115]     ...future.result$finished <- base::Sys.time()
[16:06:01.115]     ...future.result
[16:06:01.115] }
[16:06:01.118] MultisessionFuture started
[16:06:01.118] - Launch lazy future ... done
[16:06:01.118] run() for ‘MultisessionFuture’ ... done
[16:06:01.164] receiveMessageFromWorker() for ClusterFuture ...
[16:06:01.164] - Validating connection of MultisessionFuture
[16:06:01.165] - received message: FutureResult
[16:06:01.165] - Received FutureResult
[16:06:01.165] - Erased future from FutureRegistry
[16:06:01.165] result() for ClusterFuture ...
[16:06:01.165] - result already collected: FutureResult
[16:06:01.165] result() for ClusterFuture ... done
[16:06:01.165] signalConditions() ...
[16:06:01.165]  - include = ‘immediateCondition’
[16:06:01.165]  - exclude = 
[16:06:01.165]  - resignal = FALSE
[16:06:01.166]  - Number of conditions: 1
[16:06:01.166] signalConditions() ... done
[16:06:01.166] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:01.166] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[16:06:01.166] getGlobalsAndPackages() ...
[16:06:01.166] Searching for globals...
[16:06:01.167] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:01.167] Searching for globals ... DONE
[16:06:01.168] Resolving globals: FALSE
[16:06:01.168] 
[16:06:01.168] 
[16:06:01.168] getGlobalsAndPackages() ... DONE
[16:06:01.168] run() for ‘Future’ ...
[16:06:01.168] - state: ‘created’
[16:06:01.169] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:01.182] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:01.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:01.182]   - Field: ‘node’
[16:06:01.183]   - Field: ‘label’
[16:06:01.183]   - Field: ‘local’
[16:06:01.183]   - Field: ‘owner’
[16:06:01.183]   - Field: ‘envir’
[16:06:01.183]   - Field: ‘workers’
[16:06:01.183]   - Field: ‘packages’
[16:06:01.183]   - Field: ‘gc’
[16:06:01.183]   - Field: ‘conditions’
[16:06:01.183]   - Field: ‘persistent’
[16:06:01.183]   - Field: ‘expr’
[16:06:01.184]   - Field: ‘uuid’
[16:06:01.184]   - Field: ‘seed’
[16:06:01.184]   - Field: ‘version’
[16:06:01.184]   - Field: ‘result’
[16:06:01.184]   - Field: ‘asynchronous’
[16:06:01.184]   - Field: ‘calls’
[16:06:01.184]   - Field: ‘globals’
[16:06:01.184]   - Field: ‘stdout’
[16:06:01.184]   - Field: ‘earlySignal’
[16:06:01.184]   - Field: ‘lazy’
[16:06:01.184]   - Field: ‘state’
[16:06:01.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:01.185] - Launch lazy future ...
[16:06:01.185] Packages needed by the future expression (n = 0): <none>
[16:06:01.185] Packages needed by future strategies (n = 0): <none>
[16:06:01.185] {
[16:06:01.185]     {
[16:06:01.185]         {
[16:06:01.185]             ...future.startTime <- base::Sys.time()
[16:06:01.185]             {
[16:06:01.185]                 {
[16:06:01.185]                   {
[16:06:01.185]                     {
[16:06:01.185]                       base::local({
[16:06:01.185]                         has_future <- base::requireNamespace("future", 
[16:06:01.185]                           quietly = TRUE)
[16:06:01.185]                         if (has_future) {
[16:06:01.185]                           ns <- base::getNamespace("future")
[16:06:01.185]                           version <- ns[[".package"]][["version"]]
[16:06:01.185]                           if (is.null(version)) 
[16:06:01.185]                             version <- utils::packageVersion("future")
[16:06:01.185]                         }
[16:06:01.185]                         else {
[16:06:01.185]                           version <- NULL
[16:06:01.185]                         }
[16:06:01.185]                         if (!has_future || version < "1.8.0") {
[16:06:01.185]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:01.185]                             "", base::R.version$version.string), 
[16:06:01.185]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:01.185]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:01.185]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:01.185]                               "release", "version")], collapse = " "), 
[16:06:01.185]                             hostname = base::Sys.info()[["nodename"]])
[16:06:01.185]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:01.185]                             info)
[16:06:01.185]                           info <- base::paste(info, collapse = "; ")
[16:06:01.185]                           if (!has_future) {
[16:06:01.185]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:01.185]                               info)
[16:06:01.185]                           }
[16:06:01.185]                           else {
[16:06:01.185]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:01.185]                               info, version)
[16:06:01.185]                           }
[16:06:01.185]                           base::stop(msg)
[16:06:01.185]                         }
[16:06:01.185]                       })
[16:06:01.185]                     }
[16:06:01.185]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:01.185]                     base::options(mc.cores = 1L)
[16:06:01.185]                   }
[16:06:01.185]                   options(future.plan = NULL)
[16:06:01.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:01.185]                 }
[16:06:01.185]                 ...future.workdir <- getwd()
[16:06:01.185]             }
[16:06:01.185]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:01.185]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:01.185]         }
[16:06:01.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:01.185]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:01.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:01.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:01.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:01.185]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:01.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:01.185]             base::names(...future.oldOptions))
[16:06:01.185]     }
[16:06:01.185]     if (FALSE) {
[16:06:01.185]     }
[16:06:01.185]     else {
[16:06:01.185]         if (TRUE) {
[16:06:01.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:01.185]                 open = "w")
[16:06:01.185]         }
[16:06:01.185]         else {
[16:06:01.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:01.185]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:01.185]         }
[16:06:01.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:01.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:01.185]             base::sink(type = "output", split = FALSE)
[16:06:01.185]             base::close(...future.stdout)
[16:06:01.185]         }, add = TRUE)
[16:06:01.185]     }
[16:06:01.185]     ...future.frame <- base::sys.nframe()
[16:06:01.185]     ...future.conditions <- base::list()
[16:06:01.185]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:01.185]     if (FALSE) {
[16:06:01.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:01.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:01.185]     }
[16:06:01.185]     ...future.result <- base::tryCatch({
[16:06:01.185]         base::withCallingHandlers({
[16:06:01.185]             ...future.value <- base::withVisible(base::local({
[16:06:01.185]                 ...future.makeSendCondition <- base::local({
[16:06:01.185]                   sendCondition <- NULL
[16:06:01.185]                   function(frame = 1L) {
[16:06:01.185]                     if (is.function(sendCondition)) 
[16:06:01.185]                       return(sendCondition)
[16:06:01.185]                     ns <- getNamespace("parallel")
[16:06:01.185]                     if (exists("sendData", mode = "function", 
[16:06:01.185]                       envir = ns)) {
[16:06:01.185]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:01.185]                         envir = ns)
[16:06:01.185]                       envir <- sys.frame(frame)
[16:06:01.185]                       master <- NULL
[16:06:01.185]                       while (!identical(envir, .GlobalEnv) && 
[16:06:01.185]                         !identical(envir, emptyenv())) {
[16:06:01.185]                         if (exists("master", mode = "list", envir = envir, 
[16:06:01.185]                           inherits = FALSE)) {
[16:06:01.185]                           master <- get("master", mode = "list", 
[16:06:01.185]                             envir = envir, inherits = FALSE)
[16:06:01.185]                           if (inherits(master, c("SOCKnode", 
[16:06:01.185]                             "SOCK0node"))) {
[16:06:01.185]                             sendCondition <<- function(cond) {
[16:06:01.185]                               data <- list(type = "VALUE", value = cond, 
[16:06:01.185]                                 success = TRUE)
[16:06:01.185]                               parallel_sendData(master, data)
[16:06:01.185]                             }
[16:06:01.185]                             return(sendCondition)
[16:06:01.185]                           }
[16:06:01.185]                         }
[16:06:01.185]                         frame <- frame + 1L
[16:06:01.185]                         envir <- sys.frame(frame)
[16:06:01.185]                       }
[16:06:01.185]                     }
[16:06:01.185]                     sendCondition <<- function(cond) NULL
[16:06:01.185]                   }
[16:06:01.185]                 })
[16:06:01.185]                 withCallingHandlers({
[16:06:01.185]                   {
[16:06:01.185]                     Sys.sleep(0.5)
[16:06:01.185]                     list(a = 1, b = 42L)
[16:06:01.185]                   }
[16:06:01.185]                 }, immediateCondition = function(cond) {
[16:06:01.185]                   sendCondition <- ...future.makeSendCondition()
[16:06:01.185]                   sendCondition(cond)
[16:06:01.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.185]                   {
[16:06:01.185]                     inherits <- base::inherits
[16:06:01.185]                     invokeRestart <- base::invokeRestart
[16:06:01.185]                     is.null <- base::is.null
[16:06:01.185]                     muffled <- FALSE
[16:06:01.185]                     if (inherits(cond, "message")) {
[16:06:01.185]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:01.185]                       if (muffled) 
[16:06:01.185]                         invokeRestart("muffleMessage")
[16:06:01.185]                     }
[16:06:01.185]                     else if (inherits(cond, "warning")) {
[16:06:01.185]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:01.185]                       if (muffled) 
[16:06:01.185]                         invokeRestart("muffleWarning")
[16:06:01.185]                     }
[16:06:01.185]                     else if (inherits(cond, "condition")) {
[16:06:01.185]                       if (!is.null(pattern)) {
[16:06:01.185]                         computeRestarts <- base::computeRestarts
[16:06:01.185]                         grepl <- base::grepl
[16:06:01.185]                         restarts <- computeRestarts(cond)
[16:06:01.185]                         for (restart in restarts) {
[16:06:01.185]                           name <- restart$name
[16:06:01.185]                           if (is.null(name)) 
[16:06:01.185]                             next
[16:06:01.185]                           if (!grepl(pattern, name)) 
[16:06:01.185]                             next
[16:06:01.185]                           invokeRestart(restart)
[16:06:01.185]                           muffled <- TRUE
[16:06:01.185]                           break
[16:06:01.185]                         }
[16:06:01.185]                       }
[16:06:01.185]                     }
[16:06:01.185]                     invisible(muffled)
[16:06:01.185]                   }
[16:06:01.185]                   muffleCondition(cond)
[16:06:01.185]                 })
[16:06:01.185]             }))
[16:06:01.185]             future::FutureResult(value = ...future.value$value, 
[16:06:01.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.185]                   ...future.rng), globalenv = if (FALSE) 
[16:06:01.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:01.185]                     ...future.globalenv.names))
[16:06:01.185]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:01.185]         }, condition = base::local({
[16:06:01.185]             c <- base::c
[16:06:01.185]             inherits <- base::inherits
[16:06:01.185]             invokeRestart <- base::invokeRestart
[16:06:01.185]             length <- base::length
[16:06:01.185]             list <- base::list
[16:06:01.185]             seq.int <- base::seq.int
[16:06:01.185]             signalCondition <- base::signalCondition
[16:06:01.185]             sys.calls <- base::sys.calls
[16:06:01.185]             `[[` <- base::`[[`
[16:06:01.185]             `+` <- base::`+`
[16:06:01.185]             `<<-` <- base::`<<-`
[16:06:01.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:01.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:01.185]                   3L)]
[16:06:01.185]             }
[16:06:01.185]             function(cond) {
[16:06:01.185]                 is_error <- inherits(cond, "error")
[16:06:01.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:01.185]                   NULL)
[16:06:01.185]                 if (is_error) {
[16:06:01.185]                   sessionInformation <- function() {
[16:06:01.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:01.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:01.185]                       search = base::search(), system = base::Sys.info())
[16:06:01.185]                   }
[16:06:01.185]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:01.185]                     cond$call), session = sessionInformation(), 
[16:06:01.185]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:01.185]                   signalCondition(cond)
[16:06:01.185]                 }
[16:06:01.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:01.185]                 "immediateCondition"))) {
[16:06:01.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:01.185]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:01.185]                   if (TRUE && !signal) {
[16:06:01.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.185]                     {
[16:06:01.185]                       inherits <- base::inherits
[16:06:01.185]                       invokeRestart <- base::invokeRestart
[16:06:01.185]                       is.null <- base::is.null
[16:06:01.185]                       muffled <- FALSE
[16:06:01.185]                       if (inherits(cond, "message")) {
[16:06:01.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.185]                         if (muffled) 
[16:06:01.185]                           invokeRestart("muffleMessage")
[16:06:01.185]                       }
[16:06:01.185]                       else if (inherits(cond, "warning")) {
[16:06:01.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.185]                         if (muffled) 
[16:06:01.185]                           invokeRestart("muffleWarning")
[16:06:01.185]                       }
[16:06:01.185]                       else if (inherits(cond, "condition")) {
[16:06:01.185]                         if (!is.null(pattern)) {
[16:06:01.185]                           computeRestarts <- base::computeRestarts
[16:06:01.185]                           grepl <- base::grepl
[16:06:01.185]                           restarts <- computeRestarts(cond)
[16:06:01.185]                           for (restart in restarts) {
[16:06:01.185]                             name <- restart$name
[16:06:01.185]                             if (is.null(name)) 
[16:06:01.185]                               next
[16:06:01.185]                             if (!grepl(pattern, name)) 
[16:06:01.185]                               next
[16:06:01.185]                             invokeRestart(restart)
[16:06:01.185]                             muffled <- TRUE
[16:06:01.185]                             break
[16:06:01.185]                           }
[16:06:01.185]                         }
[16:06:01.185]                       }
[16:06:01.185]                       invisible(muffled)
[16:06:01.185]                     }
[16:06:01.185]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.185]                   }
[16:06:01.185]                 }
[16:06:01.185]                 else {
[16:06:01.185]                   if (TRUE) {
[16:06:01.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.185]                     {
[16:06:01.185]                       inherits <- base::inherits
[16:06:01.185]                       invokeRestart <- base::invokeRestart
[16:06:01.185]                       is.null <- base::is.null
[16:06:01.185]                       muffled <- FALSE
[16:06:01.185]                       if (inherits(cond, "message")) {
[16:06:01.185]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.185]                         if (muffled) 
[16:06:01.185]                           invokeRestart("muffleMessage")
[16:06:01.185]                       }
[16:06:01.185]                       else if (inherits(cond, "warning")) {
[16:06:01.185]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.185]                         if (muffled) 
[16:06:01.185]                           invokeRestart("muffleWarning")
[16:06:01.185]                       }
[16:06:01.185]                       else if (inherits(cond, "condition")) {
[16:06:01.185]                         if (!is.null(pattern)) {
[16:06:01.185]                           computeRestarts <- base::computeRestarts
[16:06:01.185]                           grepl <- base::grepl
[16:06:01.185]                           restarts <- computeRestarts(cond)
[16:06:01.185]                           for (restart in restarts) {
[16:06:01.185]                             name <- restart$name
[16:06:01.185]                             if (is.null(name)) 
[16:06:01.185]                               next
[16:06:01.185]                             if (!grepl(pattern, name)) 
[16:06:01.185]                               next
[16:06:01.185]                             invokeRestart(restart)
[16:06:01.185]                             muffled <- TRUE
[16:06:01.185]                             break
[16:06:01.185]                           }
[16:06:01.185]                         }
[16:06:01.185]                       }
[16:06:01.185]                       invisible(muffled)
[16:06:01.185]                     }
[16:06:01.185]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.185]                   }
[16:06:01.185]                 }
[16:06:01.185]             }
[16:06:01.185]         }))
[16:06:01.185]     }, error = function(ex) {
[16:06:01.185]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:01.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.185]                 ...future.rng), started = ...future.startTime, 
[16:06:01.185]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:01.185]             version = "1.8"), class = "FutureResult")
[16:06:01.185]     }, finally = {
[16:06:01.185]         if (!identical(...future.workdir, getwd())) 
[16:06:01.185]             setwd(...future.workdir)
[16:06:01.185]         {
[16:06:01.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:01.185]                 ...future.oldOptions$nwarnings <- NULL
[16:06:01.185]             }
[16:06:01.185]             base::options(...future.oldOptions)
[16:06:01.185]             if (.Platform$OS.type == "windows") {
[16:06:01.185]                 old_names <- names(...future.oldEnvVars)
[16:06:01.185]                 envs <- base::Sys.getenv()
[16:06:01.185]                 names <- names(envs)
[16:06:01.185]                 common <- intersect(names, old_names)
[16:06:01.185]                 added <- setdiff(names, old_names)
[16:06:01.185]                 removed <- setdiff(old_names, names)
[16:06:01.185]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:01.185]                   envs[common]]
[16:06:01.185]                 NAMES <- toupper(changed)
[16:06:01.185]                 args <- list()
[16:06:01.185]                 for (kk in seq_along(NAMES)) {
[16:06:01.185]                   name <- changed[[kk]]
[16:06:01.185]                   NAME <- NAMES[[kk]]
[16:06:01.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.185]                     next
[16:06:01.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.185]                 }
[16:06:01.185]                 NAMES <- toupper(added)
[16:06:01.185]                 for (kk in seq_along(NAMES)) {
[16:06:01.185]                   name <- added[[kk]]
[16:06:01.185]                   NAME <- NAMES[[kk]]
[16:06:01.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.185]                     next
[16:06:01.185]                   args[[name]] <- ""
[16:06:01.185]                 }
[16:06:01.185]                 NAMES <- toupper(removed)
[16:06:01.185]                 for (kk in seq_along(NAMES)) {
[16:06:01.185]                   name <- removed[[kk]]
[16:06:01.185]                   NAME <- NAMES[[kk]]
[16:06:01.185]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.185]                     next
[16:06:01.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.185]                 }
[16:06:01.185]                 if (length(args) > 0) 
[16:06:01.185]                   base::do.call(base::Sys.setenv, args = args)
[16:06:01.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:01.185]             }
[16:06:01.185]             else {
[16:06:01.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:01.185]             }
[16:06:01.185]             {
[16:06:01.185]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:01.185]                   0L) {
[16:06:01.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:01.185]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:01.185]                   base::options(opts)
[16:06:01.185]                 }
[16:06:01.185]                 {
[16:06:01.185]                   {
[16:06:01.185]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:01.185]                     NULL
[16:06:01.185]                   }
[16:06:01.185]                   options(future.plan = NULL)
[16:06:01.185]                   if (is.na(NA_character_)) 
[16:06:01.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:01.185]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:01.185]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:01.185]                     envir = parent.frame()) 
[16:06:01.185]                   {
[16:06:01.185]                     if (is.function(workers)) 
[16:06:01.185]                       workers <- workers()
[16:06:01.185]                     workers <- structure(as.integer(workers), 
[16:06:01.185]                       class = class(workers))
[16:06:01.185]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:01.185]                       workers >= 1)
[16:06:01.185]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:01.185]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:01.185]                     }
[16:06:01.185]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:01.185]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:01.185]                       envir = envir)
[16:06:01.185]                     if (!future$lazy) 
[16:06:01.185]                       future <- run(future)
[16:06:01.185]                     invisible(future)
[16:06:01.185]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:01.185]                 }
[16:06:01.185]             }
[16:06:01.185]         }
[16:06:01.185]     })
[16:06:01.185]     if (TRUE) {
[16:06:01.185]         base::sink(type = "output", split = FALSE)
[16:06:01.185]         if (TRUE) {
[16:06:01.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:01.185]         }
[16:06:01.185]         else {
[16:06:01.185]             ...future.result["stdout"] <- base::list(NULL)
[16:06:01.185]         }
[16:06:01.185]         base::close(...future.stdout)
[16:06:01.185]         ...future.stdout <- NULL
[16:06:01.185]     }
[16:06:01.185]     ...future.result$conditions <- ...future.conditions
[16:06:01.185]     ...future.result$finished <- base::Sys.time()
[16:06:01.185]     ...future.result
[16:06:01.185] }
[16:06:01.189] MultisessionFuture started
[16:06:01.189] - Launch lazy future ... done
[16:06:01.189] run() for ‘MultisessionFuture’ ... done
[16:06:01.189] getGlobalsAndPackages() ...
[16:06:01.189] Searching for globals...
[16:06:01.190] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:01.190] Searching for globals ... DONE
[16:06:01.190] Resolving globals: FALSE
[16:06:01.191] 
[16:06:01.191] 
[16:06:01.191] getGlobalsAndPackages() ... DONE
- w/ exception ...
[16:06:01.191] getGlobalsAndPackages() ...
[16:06:01.191] Searching for globals...
[16:06:01.192] - globals found: [2] ‘list’, ‘stop’
[16:06:01.192] Searching for globals ... DONE
[16:06:01.192] Resolving globals: FALSE
[16:06:01.192] 
[16:06:01.192] 
[16:06:01.193] getGlobalsAndPackages() ... DONE
[16:06:01.193] run() for ‘Future’ ...
[16:06:01.193] - state: ‘created’
[16:06:01.193] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:01.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:01.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:01.208]   - Field: ‘node’
[16:06:01.208]   - Field: ‘label’
[16:06:01.208]   - Field: ‘local’
[16:06:01.208]   - Field: ‘owner’
[16:06:01.209]   - Field: ‘envir’
[16:06:01.209]   - Field: ‘workers’
[16:06:01.209]   - Field: ‘packages’
[16:06:01.209]   - Field: ‘gc’
[16:06:01.209]   - Field: ‘conditions’
[16:06:01.209]   - Field: ‘persistent’
[16:06:01.209]   - Field: ‘expr’
[16:06:01.209]   - Field: ‘uuid’
[16:06:01.209]   - Field: ‘seed’
[16:06:01.209]   - Field: ‘version’
[16:06:01.209]   - Field: ‘result’
[16:06:01.210]   - Field: ‘asynchronous’
[16:06:01.210]   - Field: ‘calls’
[16:06:01.210]   - Field: ‘globals’
[16:06:01.210]   - Field: ‘stdout’
[16:06:01.210]   - Field: ‘earlySignal’
[16:06:01.210]   - Field: ‘lazy’
[16:06:01.210]   - Field: ‘state’
[16:06:01.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:01.210] - Launch lazy future ...
[16:06:01.211] Packages needed by the future expression (n = 0): <none>
[16:06:01.211] Packages needed by future strategies (n = 0): <none>
[16:06:01.211] {
[16:06:01.211]     {
[16:06:01.211]         {
[16:06:01.211]             ...future.startTime <- base::Sys.time()
[16:06:01.211]             {
[16:06:01.211]                 {
[16:06:01.211]                   {
[16:06:01.211]                     {
[16:06:01.211]                       base::local({
[16:06:01.211]                         has_future <- base::requireNamespace("future", 
[16:06:01.211]                           quietly = TRUE)
[16:06:01.211]                         if (has_future) {
[16:06:01.211]                           ns <- base::getNamespace("future")
[16:06:01.211]                           version <- ns[[".package"]][["version"]]
[16:06:01.211]                           if (is.null(version)) 
[16:06:01.211]                             version <- utils::packageVersion("future")
[16:06:01.211]                         }
[16:06:01.211]                         else {
[16:06:01.211]                           version <- NULL
[16:06:01.211]                         }
[16:06:01.211]                         if (!has_future || version < "1.8.0") {
[16:06:01.211]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:01.211]                             "", base::R.version$version.string), 
[16:06:01.211]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:01.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:01.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:01.211]                               "release", "version")], collapse = " "), 
[16:06:01.211]                             hostname = base::Sys.info()[["nodename"]])
[16:06:01.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:01.211]                             info)
[16:06:01.211]                           info <- base::paste(info, collapse = "; ")
[16:06:01.211]                           if (!has_future) {
[16:06:01.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:01.211]                               info)
[16:06:01.211]                           }
[16:06:01.211]                           else {
[16:06:01.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:01.211]                               info, version)
[16:06:01.211]                           }
[16:06:01.211]                           base::stop(msg)
[16:06:01.211]                         }
[16:06:01.211]                       })
[16:06:01.211]                     }
[16:06:01.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:01.211]                     base::options(mc.cores = 1L)
[16:06:01.211]                   }
[16:06:01.211]                   options(future.plan = NULL)
[16:06:01.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:01.211]                 }
[16:06:01.211]                 ...future.workdir <- getwd()
[16:06:01.211]             }
[16:06:01.211]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:01.211]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:01.211]         }
[16:06:01.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:01.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:01.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:01.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:01.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:01.211]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:01.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:01.211]             base::names(...future.oldOptions))
[16:06:01.211]     }
[16:06:01.211]     if (FALSE) {
[16:06:01.211]     }
[16:06:01.211]     else {
[16:06:01.211]         if (TRUE) {
[16:06:01.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:01.211]                 open = "w")
[16:06:01.211]         }
[16:06:01.211]         else {
[16:06:01.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:01.211]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:01.211]         }
[16:06:01.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:01.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:01.211]             base::sink(type = "output", split = FALSE)
[16:06:01.211]             base::close(...future.stdout)
[16:06:01.211]         }, add = TRUE)
[16:06:01.211]     }
[16:06:01.211]     ...future.frame <- base::sys.nframe()
[16:06:01.211]     ...future.conditions <- base::list()
[16:06:01.211]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:01.211]     if (FALSE) {
[16:06:01.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:01.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:01.211]     }
[16:06:01.211]     ...future.result <- base::tryCatch({
[16:06:01.211]         base::withCallingHandlers({
[16:06:01.211]             ...future.value <- base::withVisible(base::local({
[16:06:01.211]                 ...future.makeSendCondition <- base::local({
[16:06:01.211]                   sendCondition <- NULL
[16:06:01.211]                   function(frame = 1L) {
[16:06:01.211]                     if (is.function(sendCondition)) 
[16:06:01.211]                       return(sendCondition)
[16:06:01.211]                     ns <- getNamespace("parallel")
[16:06:01.211]                     if (exists("sendData", mode = "function", 
[16:06:01.211]                       envir = ns)) {
[16:06:01.211]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:01.211]                         envir = ns)
[16:06:01.211]                       envir <- sys.frame(frame)
[16:06:01.211]                       master <- NULL
[16:06:01.211]                       while (!identical(envir, .GlobalEnv) && 
[16:06:01.211]                         !identical(envir, emptyenv())) {
[16:06:01.211]                         if (exists("master", mode = "list", envir = envir, 
[16:06:01.211]                           inherits = FALSE)) {
[16:06:01.211]                           master <- get("master", mode = "list", 
[16:06:01.211]                             envir = envir, inherits = FALSE)
[16:06:01.211]                           if (inherits(master, c("SOCKnode", 
[16:06:01.211]                             "SOCK0node"))) {
[16:06:01.211]                             sendCondition <<- function(cond) {
[16:06:01.211]                               data <- list(type = "VALUE", value = cond, 
[16:06:01.211]                                 success = TRUE)
[16:06:01.211]                               parallel_sendData(master, data)
[16:06:01.211]                             }
[16:06:01.211]                             return(sendCondition)
[16:06:01.211]                           }
[16:06:01.211]                         }
[16:06:01.211]                         frame <- frame + 1L
[16:06:01.211]                         envir <- sys.frame(frame)
[16:06:01.211]                       }
[16:06:01.211]                     }
[16:06:01.211]                     sendCondition <<- function(cond) NULL
[16:06:01.211]                   }
[16:06:01.211]                 })
[16:06:01.211]                 withCallingHandlers({
[16:06:01.211]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:01.211]                 }, immediateCondition = function(cond) {
[16:06:01.211]                   sendCondition <- ...future.makeSendCondition()
[16:06:01.211]                   sendCondition(cond)
[16:06:01.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.211]                   {
[16:06:01.211]                     inherits <- base::inherits
[16:06:01.211]                     invokeRestart <- base::invokeRestart
[16:06:01.211]                     is.null <- base::is.null
[16:06:01.211]                     muffled <- FALSE
[16:06:01.211]                     if (inherits(cond, "message")) {
[16:06:01.211]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:01.211]                       if (muffled) 
[16:06:01.211]                         invokeRestart("muffleMessage")
[16:06:01.211]                     }
[16:06:01.211]                     else if (inherits(cond, "warning")) {
[16:06:01.211]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:01.211]                       if (muffled) 
[16:06:01.211]                         invokeRestart("muffleWarning")
[16:06:01.211]                     }
[16:06:01.211]                     else if (inherits(cond, "condition")) {
[16:06:01.211]                       if (!is.null(pattern)) {
[16:06:01.211]                         computeRestarts <- base::computeRestarts
[16:06:01.211]                         grepl <- base::grepl
[16:06:01.211]                         restarts <- computeRestarts(cond)
[16:06:01.211]                         for (restart in restarts) {
[16:06:01.211]                           name <- restart$name
[16:06:01.211]                           if (is.null(name)) 
[16:06:01.211]                             next
[16:06:01.211]                           if (!grepl(pattern, name)) 
[16:06:01.211]                             next
[16:06:01.211]                           invokeRestart(restart)
[16:06:01.211]                           muffled <- TRUE
[16:06:01.211]                           break
[16:06:01.211]                         }
[16:06:01.211]                       }
[16:06:01.211]                     }
[16:06:01.211]                     invisible(muffled)
[16:06:01.211]                   }
[16:06:01.211]                   muffleCondition(cond)
[16:06:01.211]                 })
[16:06:01.211]             }))
[16:06:01.211]             future::FutureResult(value = ...future.value$value, 
[16:06:01.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.211]                   ...future.rng), globalenv = if (FALSE) 
[16:06:01.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:01.211]                     ...future.globalenv.names))
[16:06:01.211]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:01.211]         }, condition = base::local({
[16:06:01.211]             c <- base::c
[16:06:01.211]             inherits <- base::inherits
[16:06:01.211]             invokeRestart <- base::invokeRestart
[16:06:01.211]             length <- base::length
[16:06:01.211]             list <- base::list
[16:06:01.211]             seq.int <- base::seq.int
[16:06:01.211]             signalCondition <- base::signalCondition
[16:06:01.211]             sys.calls <- base::sys.calls
[16:06:01.211]             `[[` <- base::`[[`
[16:06:01.211]             `+` <- base::`+`
[16:06:01.211]             `<<-` <- base::`<<-`
[16:06:01.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:01.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:01.211]                   3L)]
[16:06:01.211]             }
[16:06:01.211]             function(cond) {
[16:06:01.211]                 is_error <- inherits(cond, "error")
[16:06:01.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:01.211]                   NULL)
[16:06:01.211]                 if (is_error) {
[16:06:01.211]                   sessionInformation <- function() {
[16:06:01.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:01.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:01.211]                       search = base::search(), system = base::Sys.info())
[16:06:01.211]                   }
[16:06:01.211]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:01.211]                     cond$call), session = sessionInformation(), 
[16:06:01.211]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:01.211]                   signalCondition(cond)
[16:06:01.211]                 }
[16:06:01.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:01.211]                 "immediateCondition"))) {
[16:06:01.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:01.211]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:01.211]                   if (TRUE && !signal) {
[16:06:01.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.211]                     {
[16:06:01.211]                       inherits <- base::inherits
[16:06:01.211]                       invokeRestart <- base::invokeRestart
[16:06:01.211]                       is.null <- base::is.null
[16:06:01.211]                       muffled <- FALSE
[16:06:01.211]                       if (inherits(cond, "message")) {
[16:06:01.211]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.211]                         if (muffled) 
[16:06:01.211]                           invokeRestart("muffleMessage")
[16:06:01.211]                       }
[16:06:01.211]                       else if (inherits(cond, "warning")) {
[16:06:01.211]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.211]                         if (muffled) 
[16:06:01.211]                           invokeRestart("muffleWarning")
[16:06:01.211]                       }
[16:06:01.211]                       else if (inherits(cond, "condition")) {
[16:06:01.211]                         if (!is.null(pattern)) {
[16:06:01.211]                           computeRestarts <- base::computeRestarts
[16:06:01.211]                           grepl <- base::grepl
[16:06:01.211]                           restarts <- computeRestarts(cond)
[16:06:01.211]                           for (restart in restarts) {
[16:06:01.211]                             name <- restart$name
[16:06:01.211]                             if (is.null(name)) 
[16:06:01.211]                               next
[16:06:01.211]                             if (!grepl(pattern, name)) 
[16:06:01.211]                               next
[16:06:01.211]                             invokeRestart(restart)
[16:06:01.211]                             muffled <- TRUE
[16:06:01.211]                             break
[16:06:01.211]                           }
[16:06:01.211]                         }
[16:06:01.211]                       }
[16:06:01.211]                       invisible(muffled)
[16:06:01.211]                     }
[16:06:01.211]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.211]                   }
[16:06:01.211]                 }
[16:06:01.211]                 else {
[16:06:01.211]                   if (TRUE) {
[16:06:01.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.211]                     {
[16:06:01.211]                       inherits <- base::inherits
[16:06:01.211]                       invokeRestart <- base::invokeRestart
[16:06:01.211]                       is.null <- base::is.null
[16:06:01.211]                       muffled <- FALSE
[16:06:01.211]                       if (inherits(cond, "message")) {
[16:06:01.211]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.211]                         if (muffled) 
[16:06:01.211]                           invokeRestart("muffleMessage")
[16:06:01.211]                       }
[16:06:01.211]                       else if (inherits(cond, "warning")) {
[16:06:01.211]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.211]                         if (muffled) 
[16:06:01.211]                           invokeRestart("muffleWarning")
[16:06:01.211]                       }
[16:06:01.211]                       else if (inherits(cond, "condition")) {
[16:06:01.211]                         if (!is.null(pattern)) {
[16:06:01.211]                           computeRestarts <- base::computeRestarts
[16:06:01.211]                           grepl <- base::grepl
[16:06:01.211]                           restarts <- computeRestarts(cond)
[16:06:01.211]                           for (restart in restarts) {
[16:06:01.211]                             name <- restart$name
[16:06:01.211]                             if (is.null(name)) 
[16:06:01.211]                               next
[16:06:01.211]                             if (!grepl(pattern, name)) 
[16:06:01.211]                               next
[16:06:01.211]                             invokeRestart(restart)
[16:06:01.211]                             muffled <- TRUE
[16:06:01.211]                             break
[16:06:01.211]                           }
[16:06:01.211]                         }
[16:06:01.211]                       }
[16:06:01.211]                       invisible(muffled)
[16:06:01.211]                     }
[16:06:01.211]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.211]                   }
[16:06:01.211]                 }
[16:06:01.211]             }
[16:06:01.211]         }))
[16:06:01.211]     }, error = function(ex) {
[16:06:01.211]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:01.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.211]                 ...future.rng), started = ...future.startTime, 
[16:06:01.211]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:01.211]             version = "1.8"), class = "FutureResult")
[16:06:01.211]     }, finally = {
[16:06:01.211]         if (!identical(...future.workdir, getwd())) 
[16:06:01.211]             setwd(...future.workdir)
[16:06:01.211]         {
[16:06:01.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:01.211]                 ...future.oldOptions$nwarnings <- NULL
[16:06:01.211]             }
[16:06:01.211]             base::options(...future.oldOptions)
[16:06:01.211]             if (.Platform$OS.type == "windows") {
[16:06:01.211]                 old_names <- names(...future.oldEnvVars)
[16:06:01.211]                 envs <- base::Sys.getenv()
[16:06:01.211]                 names <- names(envs)
[16:06:01.211]                 common <- intersect(names, old_names)
[16:06:01.211]                 added <- setdiff(names, old_names)
[16:06:01.211]                 removed <- setdiff(old_names, names)
[16:06:01.211]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:01.211]                   envs[common]]
[16:06:01.211]                 NAMES <- toupper(changed)
[16:06:01.211]                 args <- list()
[16:06:01.211]                 for (kk in seq_along(NAMES)) {
[16:06:01.211]                   name <- changed[[kk]]
[16:06:01.211]                   NAME <- NAMES[[kk]]
[16:06:01.211]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.211]                     next
[16:06:01.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.211]                 }
[16:06:01.211]                 NAMES <- toupper(added)
[16:06:01.211]                 for (kk in seq_along(NAMES)) {
[16:06:01.211]                   name <- added[[kk]]
[16:06:01.211]                   NAME <- NAMES[[kk]]
[16:06:01.211]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.211]                     next
[16:06:01.211]                   args[[name]] <- ""
[16:06:01.211]                 }
[16:06:01.211]                 NAMES <- toupper(removed)
[16:06:01.211]                 for (kk in seq_along(NAMES)) {
[16:06:01.211]                   name <- removed[[kk]]
[16:06:01.211]                   NAME <- NAMES[[kk]]
[16:06:01.211]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.211]                     next
[16:06:01.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.211]                 }
[16:06:01.211]                 if (length(args) > 0) 
[16:06:01.211]                   base::do.call(base::Sys.setenv, args = args)
[16:06:01.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:01.211]             }
[16:06:01.211]             else {
[16:06:01.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:01.211]             }
[16:06:01.211]             {
[16:06:01.211]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:01.211]                   0L) {
[16:06:01.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:01.211]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:01.211]                   base::options(opts)
[16:06:01.211]                 }
[16:06:01.211]                 {
[16:06:01.211]                   {
[16:06:01.211]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:01.211]                     NULL
[16:06:01.211]                   }
[16:06:01.211]                   options(future.plan = NULL)
[16:06:01.211]                   if (is.na(NA_character_)) 
[16:06:01.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:01.211]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:01.211]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:01.211]                     envir = parent.frame()) 
[16:06:01.211]                   {
[16:06:01.211]                     if (is.function(workers)) 
[16:06:01.211]                       workers <- workers()
[16:06:01.211]                     workers <- structure(as.integer(workers), 
[16:06:01.211]                       class = class(workers))
[16:06:01.211]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:01.211]                       workers >= 1)
[16:06:01.211]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:01.211]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:01.211]                     }
[16:06:01.211]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:01.211]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:01.211]                       envir = envir)
[16:06:01.211]                     if (!future$lazy) 
[16:06:01.211]                       future <- run(future)
[16:06:01.211]                     invisible(future)
[16:06:01.211]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:01.211]                 }
[16:06:01.211]             }
[16:06:01.211]         }
[16:06:01.211]     })
[16:06:01.211]     if (TRUE) {
[16:06:01.211]         base::sink(type = "output", split = FALSE)
[16:06:01.211]         if (TRUE) {
[16:06:01.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:01.211]         }
[16:06:01.211]         else {
[16:06:01.211]             ...future.result["stdout"] <- base::list(NULL)
[16:06:01.211]         }
[16:06:01.211]         base::close(...future.stdout)
[16:06:01.211]         ...future.stdout <- NULL
[16:06:01.211]     }
[16:06:01.211]     ...future.result$conditions <- ...future.conditions
[16:06:01.211]     ...future.result$finished <- base::Sys.time()
[16:06:01.211]     ...future.result
[16:06:01.211] }
[16:06:01.264] MultisessionFuture started
[16:06:01.264] - Launch lazy future ... done
[16:06:01.265] run() for ‘MultisessionFuture’ ... done
[16:06:01.265] getGlobalsAndPackages() ...
[16:06:01.265] Searching for globals...
[16:06:01.266] - globals found: [2] ‘list’, ‘stop’
[16:06:01.266] Searching for globals ... DONE
[16:06:01.266] Resolving globals: FALSE
[16:06:01.267] 
[16:06:01.267] 
[16:06:01.267] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[16:06:01.268] getGlobalsAndPackages() ...
[16:06:01.268] Searching for globals...
[16:06:01.270] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:01.270] Searching for globals ... DONE
[16:06:01.270] Resolving globals: FALSE
[16:06:01.271] 
[16:06:01.271] 
[16:06:01.271] getGlobalsAndPackages() ... DONE
[16:06:01.271] run() for ‘Future’ ...
[16:06:01.271] - state: ‘created’
[16:06:01.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:01.288] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:01.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:01.289]   - Field: ‘node’
[16:06:01.289]   - Field: ‘label’
[16:06:01.289]   - Field: ‘local’
[16:06:01.289]   - Field: ‘owner’
[16:06:01.289]   - Field: ‘envir’
[16:06:01.290]   - Field: ‘workers’
[16:06:01.290]   - Field: ‘packages’
[16:06:01.290]   - Field: ‘gc’
[16:06:01.290]   - Field: ‘conditions’
[16:06:01.290]   - Field: ‘persistent’
[16:06:01.290]   - Field: ‘expr’
[16:06:01.291]   - Field: ‘uuid’
[16:06:01.291]   - Field: ‘seed’
[16:06:01.291]   - Field: ‘version’
[16:06:01.291]   - Field: ‘result’
[16:06:01.291]   - Field: ‘asynchronous’
[16:06:01.291]   - Field: ‘calls’
[16:06:01.292]   - Field: ‘globals’
[16:06:01.292]   - Field: ‘stdout’
[16:06:01.292]   - Field: ‘earlySignal’
[16:06:01.292]   - Field: ‘lazy’
[16:06:01.292]   - Field: ‘state’
[16:06:01.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:01.293] - Launch lazy future ...
[16:06:01.293] Packages needed by the future expression (n = 0): <none>
[16:06:01.293] Packages needed by future strategies (n = 0): <none>
[16:06:01.294] {
[16:06:01.294]     {
[16:06:01.294]         {
[16:06:01.294]             ...future.startTime <- base::Sys.time()
[16:06:01.294]             {
[16:06:01.294]                 {
[16:06:01.294]                   {
[16:06:01.294]                     {
[16:06:01.294]                       base::local({
[16:06:01.294]                         has_future <- base::requireNamespace("future", 
[16:06:01.294]                           quietly = TRUE)
[16:06:01.294]                         if (has_future) {
[16:06:01.294]                           ns <- base::getNamespace("future")
[16:06:01.294]                           version <- ns[[".package"]][["version"]]
[16:06:01.294]                           if (is.null(version)) 
[16:06:01.294]                             version <- utils::packageVersion("future")
[16:06:01.294]                         }
[16:06:01.294]                         else {
[16:06:01.294]                           version <- NULL
[16:06:01.294]                         }
[16:06:01.294]                         if (!has_future || version < "1.8.0") {
[16:06:01.294]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:01.294]                             "", base::R.version$version.string), 
[16:06:01.294]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:01.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:01.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:01.294]                               "release", "version")], collapse = " "), 
[16:06:01.294]                             hostname = base::Sys.info()[["nodename"]])
[16:06:01.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:01.294]                             info)
[16:06:01.294]                           info <- base::paste(info, collapse = "; ")
[16:06:01.294]                           if (!has_future) {
[16:06:01.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:01.294]                               info)
[16:06:01.294]                           }
[16:06:01.294]                           else {
[16:06:01.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:01.294]                               info, version)
[16:06:01.294]                           }
[16:06:01.294]                           base::stop(msg)
[16:06:01.294]                         }
[16:06:01.294]                       })
[16:06:01.294]                     }
[16:06:01.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:01.294]                     base::options(mc.cores = 1L)
[16:06:01.294]                   }
[16:06:01.294]                   options(future.plan = NULL)
[16:06:01.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:01.294]                 }
[16:06:01.294]                 ...future.workdir <- getwd()
[16:06:01.294]             }
[16:06:01.294]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:01.294]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:01.294]         }
[16:06:01.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:01.294]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:01.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:01.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:01.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:01.294]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:01.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:01.294]             base::names(...future.oldOptions))
[16:06:01.294]     }
[16:06:01.294]     if (FALSE) {
[16:06:01.294]     }
[16:06:01.294]     else {
[16:06:01.294]         if (TRUE) {
[16:06:01.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:01.294]                 open = "w")
[16:06:01.294]         }
[16:06:01.294]         else {
[16:06:01.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:01.294]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:01.294]         }
[16:06:01.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:01.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:01.294]             base::sink(type = "output", split = FALSE)
[16:06:01.294]             base::close(...future.stdout)
[16:06:01.294]         }, add = TRUE)
[16:06:01.294]     }
[16:06:01.294]     ...future.frame <- base::sys.nframe()
[16:06:01.294]     ...future.conditions <- base::list()
[16:06:01.294]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:01.294]     if (FALSE) {
[16:06:01.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:01.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:01.294]     }
[16:06:01.294]     ...future.result <- base::tryCatch({
[16:06:01.294]         base::withCallingHandlers({
[16:06:01.294]             ...future.value <- base::withVisible(base::local({
[16:06:01.294]                 ...future.makeSendCondition <- base::local({
[16:06:01.294]                   sendCondition <- NULL
[16:06:01.294]                   function(frame = 1L) {
[16:06:01.294]                     if (is.function(sendCondition)) 
[16:06:01.294]                       return(sendCondition)
[16:06:01.294]                     ns <- getNamespace("parallel")
[16:06:01.294]                     if (exists("sendData", mode = "function", 
[16:06:01.294]                       envir = ns)) {
[16:06:01.294]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:01.294]                         envir = ns)
[16:06:01.294]                       envir <- sys.frame(frame)
[16:06:01.294]                       master <- NULL
[16:06:01.294]                       while (!identical(envir, .GlobalEnv) && 
[16:06:01.294]                         !identical(envir, emptyenv())) {
[16:06:01.294]                         if (exists("master", mode = "list", envir = envir, 
[16:06:01.294]                           inherits = FALSE)) {
[16:06:01.294]                           master <- get("master", mode = "list", 
[16:06:01.294]                             envir = envir, inherits = FALSE)
[16:06:01.294]                           if (inherits(master, c("SOCKnode", 
[16:06:01.294]                             "SOCK0node"))) {
[16:06:01.294]                             sendCondition <<- function(cond) {
[16:06:01.294]                               data <- list(type = "VALUE", value = cond, 
[16:06:01.294]                                 success = TRUE)
[16:06:01.294]                               parallel_sendData(master, data)
[16:06:01.294]                             }
[16:06:01.294]                             return(sendCondition)
[16:06:01.294]                           }
[16:06:01.294]                         }
[16:06:01.294]                         frame <- frame + 1L
[16:06:01.294]                         envir <- sys.frame(frame)
[16:06:01.294]                       }
[16:06:01.294]                     }
[16:06:01.294]                     sendCondition <<- function(cond) NULL
[16:06:01.294]                   }
[16:06:01.294]                 })
[16:06:01.294]                 withCallingHandlers({
[16:06:01.294]                   {
[16:06:01.294]                     Sys.sleep(0.5)
[16:06:01.294]                     list(a = 1, b = 42L)
[16:06:01.294]                   }
[16:06:01.294]                 }, immediateCondition = function(cond) {
[16:06:01.294]                   sendCondition <- ...future.makeSendCondition()
[16:06:01.294]                   sendCondition(cond)
[16:06:01.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.294]                   {
[16:06:01.294]                     inherits <- base::inherits
[16:06:01.294]                     invokeRestart <- base::invokeRestart
[16:06:01.294]                     is.null <- base::is.null
[16:06:01.294]                     muffled <- FALSE
[16:06:01.294]                     if (inherits(cond, "message")) {
[16:06:01.294]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:01.294]                       if (muffled) 
[16:06:01.294]                         invokeRestart("muffleMessage")
[16:06:01.294]                     }
[16:06:01.294]                     else if (inherits(cond, "warning")) {
[16:06:01.294]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:01.294]                       if (muffled) 
[16:06:01.294]                         invokeRestart("muffleWarning")
[16:06:01.294]                     }
[16:06:01.294]                     else if (inherits(cond, "condition")) {
[16:06:01.294]                       if (!is.null(pattern)) {
[16:06:01.294]                         computeRestarts <- base::computeRestarts
[16:06:01.294]                         grepl <- base::grepl
[16:06:01.294]                         restarts <- computeRestarts(cond)
[16:06:01.294]                         for (restart in restarts) {
[16:06:01.294]                           name <- restart$name
[16:06:01.294]                           if (is.null(name)) 
[16:06:01.294]                             next
[16:06:01.294]                           if (!grepl(pattern, name)) 
[16:06:01.294]                             next
[16:06:01.294]                           invokeRestart(restart)
[16:06:01.294]                           muffled <- TRUE
[16:06:01.294]                           break
[16:06:01.294]                         }
[16:06:01.294]                       }
[16:06:01.294]                     }
[16:06:01.294]                     invisible(muffled)
[16:06:01.294]                   }
[16:06:01.294]                   muffleCondition(cond)
[16:06:01.294]                 })
[16:06:01.294]             }))
[16:06:01.294]             future::FutureResult(value = ...future.value$value, 
[16:06:01.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.294]                   ...future.rng), globalenv = if (FALSE) 
[16:06:01.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:01.294]                     ...future.globalenv.names))
[16:06:01.294]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:01.294]         }, condition = base::local({
[16:06:01.294]             c <- base::c
[16:06:01.294]             inherits <- base::inherits
[16:06:01.294]             invokeRestart <- base::invokeRestart
[16:06:01.294]             length <- base::length
[16:06:01.294]             list <- base::list
[16:06:01.294]             seq.int <- base::seq.int
[16:06:01.294]             signalCondition <- base::signalCondition
[16:06:01.294]             sys.calls <- base::sys.calls
[16:06:01.294]             `[[` <- base::`[[`
[16:06:01.294]             `+` <- base::`+`
[16:06:01.294]             `<<-` <- base::`<<-`
[16:06:01.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:01.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:01.294]                   3L)]
[16:06:01.294]             }
[16:06:01.294]             function(cond) {
[16:06:01.294]                 is_error <- inherits(cond, "error")
[16:06:01.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:01.294]                   NULL)
[16:06:01.294]                 if (is_error) {
[16:06:01.294]                   sessionInformation <- function() {
[16:06:01.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:01.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:01.294]                       search = base::search(), system = base::Sys.info())
[16:06:01.294]                   }
[16:06:01.294]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:01.294]                     cond$call), session = sessionInformation(), 
[16:06:01.294]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:01.294]                   signalCondition(cond)
[16:06:01.294]                 }
[16:06:01.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:01.294]                 "immediateCondition"))) {
[16:06:01.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:01.294]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:01.294]                   if (TRUE && !signal) {
[16:06:01.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.294]                     {
[16:06:01.294]                       inherits <- base::inherits
[16:06:01.294]                       invokeRestart <- base::invokeRestart
[16:06:01.294]                       is.null <- base::is.null
[16:06:01.294]                       muffled <- FALSE
[16:06:01.294]                       if (inherits(cond, "message")) {
[16:06:01.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.294]                         if (muffled) 
[16:06:01.294]                           invokeRestart("muffleMessage")
[16:06:01.294]                       }
[16:06:01.294]                       else if (inherits(cond, "warning")) {
[16:06:01.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.294]                         if (muffled) 
[16:06:01.294]                           invokeRestart("muffleWarning")
[16:06:01.294]                       }
[16:06:01.294]                       else if (inherits(cond, "condition")) {
[16:06:01.294]                         if (!is.null(pattern)) {
[16:06:01.294]                           computeRestarts <- base::computeRestarts
[16:06:01.294]                           grepl <- base::grepl
[16:06:01.294]                           restarts <- computeRestarts(cond)
[16:06:01.294]                           for (restart in restarts) {
[16:06:01.294]                             name <- restart$name
[16:06:01.294]                             if (is.null(name)) 
[16:06:01.294]                               next
[16:06:01.294]                             if (!grepl(pattern, name)) 
[16:06:01.294]                               next
[16:06:01.294]                             invokeRestart(restart)
[16:06:01.294]                             muffled <- TRUE
[16:06:01.294]                             break
[16:06:01.294]                           }
[16:06:01.294]                         }
[16:06:01.294]                       }
[16:06:01.294]                       invisible(muffled)
[16:06:01.294]                     }
[16:06:01.294]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.294]                   }
[16:06:01.294]                 }
[16:06:01.294]                 else {
[16:06:01.294]                   if (TRUE) {
[16:06:01.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.294]                     {
[16:06:01.294]                       inherits <- base::inherits
[16:06:01.294]                       invokeRestart <- base::invokeRestart
[16:06:01.294]                       is.null <- base::is.null
[16:06:01.294]                       muffled <- FALSE
[16:06:01.294]                       if (inherits(cond, "message")) {
[16:06:01.294]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.294]                         if (muffled) 
[16:06:01.294]                           invokeRestart("muffleMessage")
[16:06:01.294]                       }
[16:06:01.294]                       else if (inherits(cond, "warning")) {
[16:06:01.294]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.294]                         if (muffled) 
[16:06:01.294]                           invokeRestart("muffleWarning")
[16:06:01.294]                       }
[16:06:01.294]                       else if (inherits(cond, "condition")) {
[16:06:01.294]                         if (!is.null(pattern)) {
[16:06:01.294]                           computeRestarts <- base::computeRestarts
[16:06:01.294]                           grepl <- base::grepl
[16:06:01.294]                           restarts <- computeRestarts(cond)
[16:06:01.294]                           for (restart in restarts) {
[16:06:01.294]                             name <- restart$name
[16:06:01.294]                             if (is.null(name)) 
[16:06:01.294]                               next
[16:06:01.294]                             if (!grepl(pattern, name)) 
[16:06:01.294]                               next
[16:06:01.294]                             invokeRestart(restart)
[16:06:01.294]                             muffled <- TRUE
[16:06:01.294]                             break
[16:06:01.294]                           }
[16:06:01.294]                         }
[16:06:01.294]                       }
[16:06:01.294]                       invisible(muffled)
[16:06:01.294]                     }
[16:06:01.294]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.294]                   }
[16:06:01.294]                 }
[16:06:01.294]             }
[16:06:01.294]         }))
[16:06:01.294]     }, error = function(ex) {
[16:06:01.294]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:01.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.294]                 ...future.rng), started = ...future.startTime, 
[16:06:01.294]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:01.294]             version = "1.8"), class = "FutureResult")
[16:06:01.294]     }, finally = {
[16:06:01.294]         if (!identical(...future.workdir, getwd())) 
[16:06:01.294]             setwd(...future.workdir)
[16:06:01.294]         {
[16:06:01.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:01.294]                 ...future.oldOptions$nwarnings <- NULL
[16:06:01.294]             }
[16:06:01.294]             base::options(...future.oldOptions)
[16:06:01.294]             if (.Platform$OS.type == "windows") {
[16:06:01.294]                 old_names <- names(...future.oldEnvVars)
[16:06:01.294]                 envs <- base::Sys.getenv()
[16:06:01.294]                 names <- names(envs)
[16:06:01.294]                 common <- intersect(names, old_names)
[16:06:01.294]                 added <- setdiff(names, old_names)
[16:06:01.294]                 removed <- setdiff(old_names, names)
[16:06:01.294]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:01.294]                   envs[common]]
[16:06:01.294]                 NAMES <- toupper(changed)
[16:06:01.294]                 args <- list()
[16:06:01.294]                 for (kk in seq_along(NAMES)) {
[16:06:01.294]                   name <- changed[[kk]]
[16:06:01.294]                   NAME <- NAMES[[kk]]
[16:06:01.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.294]                     next
[16:06:01.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.294]                 }
[16:06:01.294]                 NAMES <- toupper(added)
[16:06:01.294]                 for (kk in seq_along(NAMES)) {
[16:06:01.294]                   name <- added[[kk]]
[16:06:01.294]                   NAME <- NAMES[[kk]]
[16:06:01.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.294]                     next
[16:06:01.294]                   args[[name]] <- ""
[16:06:01.294]                 }
[16:06:01.294]                 NAMES <- toupper(removed)
[16:06:01.294]                 for (kk in seq_along(NAMES)) {
[16:06:01.294]                   name <- removed[[kk]]
[16:06:01.294]                   NAME <- NAMES[[kk]]
[16:06:01.294]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.294]                     next
[16:06:01.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.294]                 }
[16:06:01.294]                 if (length(args) > 0) 
[16:06:01.294]                   base::do.call(base::Sys.setenv, args = args)
[16:06:01.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:01.294]             }
[16:06:01.294]             else {
[16:06:01.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:01.294]             }
[16:06:01.294]             {
[16:06:01.294]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:01.294]                   0L) {
[16:06:01.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:01.294]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:01.294]                   base::options(opts)
[16:06:01.294]                 }
[16:06:01.294]                 {
[16:06:01.294]                   {
[16:06:01.294]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:01.294]                     NULL
[16:06:01.294]                   }
[16:06:01.294]                   options(future.plan = NULL)
[16:06:01.294]                   if (is.na(NA_character_)) 
[16:06:01.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:01.294]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:01.294]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:01.294]                     envir = parent.frame()) 
[16:06:01.294]                   {
[16:06:01.294]                     if (is.function(workers)) 
[16:06:01.294]                       workers <- workers()
[16:06:01.294]                     workers <- structure(as.integer(workers), 
[16:06:01.294]                       class = class(workers))
[16:06:01.294]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:01.294]                       workers >= 1)
[16:06:01.294]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:01.294]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:01.294]                     }
[16:06:01.294]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:01.294]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:01.294]                       envir = envir)
[16:06:01.294]                     if (!future$lazy) 
[16:06:01.294]                       future <- run(future)
[16:06:01.294]                     invisible(future)
[16:06:01.294]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:01.294]                 }
[16:06:01.294]             }
[16:06:01.294]         }
[16:06:01.294]     })
[16:06:01.294]     if (TRUE) {
[16:06:01.294]         base::sink(type = "output", split = FALSE)
[16:06:01.294]         if (TRUE) {
[16:06:01.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:01.294]         }
[16:06:01.294]         else {
[16:06:01.294]             ...future.result["stdout"] <- base::list(NULL)
[16:06:01.294]         }
[16:06:01.294]         base::close(...future.stdout)
[16:06:01.294]         ...future.stdout <- NULL
[16:06:01.294]     }
[16:06:01.294]     ...future.result$conditions <- ...future.conditions
[16:06:01.294]     ...future.result$finished <- base::Sys.time()
[16:06:01.294]     ...future.result
[16:06:01.294] }
[16:06:01.298] Poll #1 (0): usedNodes() = 2, workers = 2
[16:06:01.321] receiveMessageFromWorker() for ClusterFuture ...
[16:06:01.322] - Validating connection of MultisessionFuture
[16:06:01.322] - received message: FutureResult
[16:06:01.322] - Received FutureResult
[16:06:01.322] - Erased future from FutureRegistry
[16:06:01.323] result() for ClusterFuture ...
[16:06:01.323] - result already collected: FutureResult
[16:06:01.323] result() for ClusterFuture ... done
[16:06:01.323] signalConditions() ...
[16:06:01.323]  - include = ‘immediateCondition’
[16:06:01.323]  - exclude = 
[16:06:01.323]  - resignal = FALSE
[16:06:01.323]  - Number of conditions: 1
[16:06:01.323] signalConditions() ... done
[16:06:01.323] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:01.324] result() for ClusterFuture ...
[16:06:01.324] - result already collected: FutureResult
[16:06:01.324] result() for ClusterFuture ... done
[16:06:01.324] result() for ClusterFuture ...
[16:06:01.324] - result already collected: FutureResult
[16:06:01.324] result() for ClusterFuture ... done
[16:06:01.324] signalConditions() ...
[16:06:01.324]  - include = ‘immediateCondition’
[16:06:01.324]  - exclude = 
[16:06:01.324]  - resignal = FALSE
[16:06:01.324]  - Number of conditions: 1
[16:06:01.325] signalConditions() ... done
[16:06:01.326] MultisessionFuture started
[16:06:01.326] - Launch lazy future ... done
[16:06:01.326] run() for ‘MultisessionFuture’ ... done
[16:06:01.883] receiveMessageFromWorker() for ClusterFuture ...
[16:06:01.883] - Validating connection of MultisessionFuture
[16:06:01.883] - received message: FutureResult
[16:06:01.883] - Received FutureResult
[16:06:01.883] - Erased future from FutureRegistry
[16:06:01.883] result() for ClusterFuture ...
[16:06:01.884] - result already collected: FutureResult
[16:06:01.884] result() for ClusterFuture ... done
[16:06:01.884] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:01.884] A MultisessionFuture was resolved (result was not collected)
[16:06:01.884] getGlobalsAndPackages() ...
[16:06:01.884] Searching for globals...
[16:06:01.885] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:01.885] Searching for globals ... DONE
[16:06:01.885] Resolving globals: FALSE
[16:06:01.886] 
[16:06:01.886] 
[16:06:01.886] getGlobalsAndPackages() ... DONE
[16:06:01.886] run() for ‘Future’ ...
[16:06:01.886] - state: ‘created’
[16:06:01.886] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:01.900] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:01.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:01.900]   - Field: ‘node’
[16:06:01.900]   - Field: ‘label’
[16:06:01.901]   - Field: ‘local’
[16:06:01.901]   - Field: ‘owner’
[16:06:01.901]   - Field: ‘envir’
[16:06:01.901]   - Field: ‘workers’
[16:06:01.901]   - Field: ‘packages’
[16:06:01.901]   - Field: ‘gc’
[16:06:01.901]   - Field: ‘conditions’
[16:06:01.901]   - Field: ‘persistent’
[16:06:01.901]   - Field: ‘expr’
[16:06:01.901]   - Field: ‘uuid’
[16:06:01.901]   - Field: ‘seed’
[16:06:01.902]   - Field: ‘version’
[16:06:01.902]   - Field: ‘result’
[16:06:01.902]   - Field: ‘asynchronous’
[16:06:01.902]   - Field: ‘calls’
[16:06:01.902]   - Field: ‘globals’
[16:06:01.902]   - Field: ‘stdout’
[16:06:01.902]   - Field: ‘earlySignal’
[16:06:01.902]   - Field: ‘lazy’
[16:06:01.902]   - Field: ‘state’
[16:06:01.902] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:01.902] - Launch lazy future ...
[16:06:01.903] Packages needed by the future expression (n = 0): <none>
[16:06:01.903] Packages needed by future strategies (n = 0): <none>
[16:06:01.903] {
[16:06:01.903]     {
[16:06:01.903]         {
[16:06:01.903]             ...future.startTime <- base::Sys.time()
[16:06:01.903]             {
[16:06:01.903]                 {
[16:06:01.903]                   {
[16:06:01.903]                     {
[16:06:01.903]                       base::local({
[16:06:01.903]                         has_future <- base::requireNamespace("future", 
[16:06:01.903]                           quietly = TRUE)
[16:06:01.903]                         if (has_future) {
[16:06:01.903]                           ns <- base::getNamespace("future")
[16:06:01.903]                           version <- ns[[".package"]][["version"]]
[16:06:01.903]                           if (is.null(version)) 
[16:06:01.903]                             version <- utils::packageVersion("future")
[16:06:01.903]                         }
[16:06:01.903]                         else {
[16:06:01.903]                           version <- NULL
[16:06:01.903]                         }
[16:06:01.903]                         if (!has_future || version < "1.8.0") {
[16:06:01.903]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:01.903]                             "", base::R.version$version.string), 
[16:06:01.903]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:01.903]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:01.903]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:01.903]                               "release", "version")], collapse = " "), 
[16:06:01.903]                             hostname = base::Sys.info()[["nodename"]])
[16:06:01.903]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:01.903]                             info)
[16:06:01.903]                           info <- base::paste(info, collapse = "; ")
[16:06:01.903]                           if (!has_future) {
[16:06:01.903]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:01.903]                               info)
[16:06:01.903]                           }
[16:06:01.903]                           else {
[16:06:01.903]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:01.903]                               info, version)
[16:06:01.903]                           }
[16:06:01.903]                           base::stop(msg)
[16:06:01.903]                         }
[16:06:01.903]                       })
[16:06:01.903]                     }
[16:06:01.903]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:01.903]                     base::options(mc.cores = 1L)
[16:06:01.903]                   }
[16:06:01.903]                   options(future.plan = NULL)
[16:06:01.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:01.903]                 }
[16:06:01.903]                 ...future.workdir <- getwd()
[16:06:01.903]             }
[16:06:01.903]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:01.903]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:01.903]         }
[16:06:01.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:01.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:01.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:01.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:01.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:01.903]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:01.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:01.903]             base::names(...future.oldOptions))
[16:06:01.903]     }
[16:06:01.903]     if (FALSE) {
[16:06:01.903]     }
[16:06:01.903]     else {
[16:06:01.903]         if (TRUE) {
[16:06:01.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:01.903]                 open = "w")
[16:06:01.903]         }
[16:06:01.903]         else {
[16:06:01.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:01.903]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:01.903]         }
[16:06:01.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:01.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:01.903]             base::sink(type = "output", split = FALSE)
[16:06:01.903]             base::close(...future.stdout)
[16:06:01.903]         }, add = TRUE)
[16:06:01.903]     }
[16:06:01.903]     ...future.frame <- base::sys.nframe()
[16:06:01.903]     ...future.conditions <- base::list()
[16:06:01.903]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:01.903]     if (FALSE) {
[16:06:01.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:01.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:01.903]     }
[16:06:01.903]     ...future.result <- base::tryCatch({
[16:06:01.903]         base::withCallingHandlers({
[16:06:01.903]             ...future.value <- base::withVisible(base::local({
[16:06:01.903]                 ...future.makeSendCondition <- base::local({
[16:06:01.903]                   sendCondition <- NULL
[16:06:01.903]                   function(frame = 1L) {
[16:06:01.903]                     if (is.function(sendCondition)) 
[16:06:01.903]                       return(sendCondition)
[16:06:01.903]                     ns <- getNamespace("parallel")
[16:06:01.903]                     if (exists("sendData", mode = "function", 
[16:06:01.903]                       envir = ns)) {
[16:06:01.903]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:01.903]                         envir = ns)
[16:06:01.903]                       envir <- sys.frame(frame)
[16:06:01.903]                       master <- NULL
[16:06:01.903]                       while (!identical(envir, .GlobalEnv) && 
[16:06:01.903]                         !identical(envir, emptyenv())) {
[16:06:01.903]                         if (exists("master", mode = "list", envir = envir, 
[16:06:01.903]                           inherits = FALSE)) {
[16:06:01.903]                           master <- get("master", mode = "list", 
[16:06:01.903]                             envir = envir, inherits = FALSE)
[16:06:01.903]                           if (inherits(master, c("SOCKnode", 
[16:06:01.903]                             "SOCK0node"))) {
[16:06:01.903]                             sendCondition <<- function(cond) {
[16:06:01.903]                               data <- list(type = "VALUE", value = cond, 
[16:06:01.903]                                 success = TRUE)
[16:06:01.903]                               parallel_sendData(master, data)
[16:06:01.903]                             }
[16:06:01.903]                             return(sendCondition)
[16:06:01.903]                           }
[16:06:01.903]                         }
[16:06:01.903]                         frame <- frame + 1L
[16:06:01.903]                         envir <- sys.frame(frame)
[16:06:01.903]                       }
[16:06:01.903]                     }
[16:06:01.903]                     sendCondition <<- function(cond) NULL
[16:06:01.903]                   }
[16:06:01.903]                 })
[16:06:01.903]                 withCallingHandlers({
[16:06:01.903]                   {
[16:06:01.903]                     Sys.sleep(0.5)
[16:06:01.903]                     list(a = 1, b = 42L)
[16:06:01.903]                   }
[16:06:01.903]                 }, immediateCondition = function(cond) {
[16:06:01.903]                   sendCondition <- ...future.makeSendCondition()
[16:06:01.903]                   sendCondition(cond)
[16:06:01.903]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.903]                   {
[16:06:01.903]                     inherits <- base::inherits
[16:06:01.903]                     invokeRestart <- base::invokeRestart
[16:06:01.903]                     is.null <- base::is.null
[16:06:01.903]                     muffled <- FALSE
[16:06:01.903]                     if (inherits(cond, "message")) {
[16:06:01.903]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:01.903]                       if (muffled) 
[16:06:01.903]                         invokeRestart("muffleMessage")
[16:06:01.903]                     }
[16:06:01.903]                     else if (inherits(cond, "warning")) {
[16:06:01.903]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:01.903]                       if (muffled) 
[16:06:01.903]                         invokeRestart("muffleWarning")
[16:06:01.903]                     }
[16:06:01.903]                     else if (inherits(cond, "condition")) {
[16:06:01.903]                       if (!is.null(pattern)) {
[16:06:01.903]                         computeRestarts <- base::computeRestarts
[16:06:01.903]                         grepl <- base::grepl
[16:06:01.903]                         restarts <- computeRestarts(cond)
[16:06:01.903]                         for (restart in restarts) {
[16:06:01.903]                           name <- restart$name
[16:06:01.903]                           if (is.null(name)) 
[16:06:01.903]                             next
[16:06:01.903]                           if (!grepl(pattern, name)) 
[16:06:01.903]                             next
[16:06:01.903]                           invokeRestart(restart)
[16:06:01.903]                           muffled <- TRUE
[16:06:01.903]                           break
[16:06:01.903]                         }
[16:06:01.903]                       }
[16:06:01.903]                     }
[16:06:01.903]                     invisible(muffled)
[16:06:01.903]                   }
[16:06:01.903]                   muffleCondition(cond)
[16:06:01.903]                 })
[16:06:01.903]             }))
[16:06:01.903]             future::FutureResult(value = ...future.value$value, 
[16:06:01.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.903]                   ...future.rng), globalenv = if (FALSE) 
[16:06:01.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:01.903]                     ...future.globalenv.names))
[16:06:01.903]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:01.903]         }, condition = base::local({
[16:06:01.903]             c <- base::c
[16:06:01.903]             inherits <- base::inherits
[16:06:01.903]             invokeRestart <- base::invokeRestart
[16:06:01.903]             length <- base::length
[16:06:01.903]             list <- base::list
[16:06:01.903]             seq.int <- base::seq.int
[16:06:01.903]             signalCondition <- base::signalCondition
[16:06:01.903]             sys.calls <- base::sys.calls
[16:06:01.903]             `[[` <- base::`[[`
[16:06:01.903]             `+` <- base::`+`
[16:06:01.903]             `<<-` <- base::`<<-`
[16:06:01.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:01.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:01.903]                   3L)]
[16:06:01.903]             }
[16:06:01.903]             function(cond) {
[16:06:01.903]                 is_error <- inherits(cond, "error")
[16:06:01.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:01.903]                   NULL)
[16:06:01.903]                 if (is_error) {
[16:06:01.903]                   sessionInformation <- function() {
[16:06:01.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:01.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:01.903]                       search = base::search(), system = base::Sys.info())
[16:06:01.903]                   }
[16:06:01.903]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:01.903]                     cond$call), session = sessionInformation(), 
[16:06:01.903]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:01.903]                   signalCondition(cond)
[16:06:01.903]                 }
[16:06:01.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:01.903]                 "immediateCondition"))) {
[16:06:01.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:01.903]                   ...future.conditions[[length(...future.conditions) + 
[16:06:01.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:01.903]                   if (TRUE && !signal) {
[16:06:01.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.903]                     {
[16:06:01.903]                       inherits <- base::inherits
[16:06:01.903]                       invokeRestart <- base::invokeRestart
[16:06:01.903]                       is.null <- base::is.null
[16:06:01.903]                       muffled <- FALSE
[16:06:01.903]                       if (inherits(cond, "message")) {
[16:06:01.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.903]                         if (muffled) 
[16:06:01.903]                           invokeRestart("muffleMessage")
[16:06:01.903]                       }
[16:06:01.903]                       else if (inherits(cond, "warning")) {
[16:06:01.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.903]                         if (muffled) 
[16:06:01.903]                           invokeRestart("muffleWarning")
[16:06:01.903]                       }
[16:06:01.903]                       else if (inherits(cond, "condition")) {
[16:06:01.903]                         if (!is.null(pattern)) {
[16:06:01.903]                           computeRestarts <- base::computeRestarts
[16:06:01.903]                           grepl <- base::grepl
[16:06:01.903]                           restarts <- computeRestarts(cond)
[16:06:01.903]                           for (restart in restarts) {
[16:06:01.903]                             name <- restart$name
[16:06:01.903]                             if (is.null(name)) 
[16:06:01.903]                               next
[16:06:01.903]                             if (!grepl(pattern, name)) 
[16:06:01.903]                               next
[16:06:01.903]                             invokeRestart(restart)
[16:06:01.903]                             muffled <- TRUE
[16:06:01.903]                             break
[16:06:01.903]                           }
[16:06:01.903]                         }
[16:06:01.903]                       }
[16:06:01.903]                       invisible(muffled)
[16:06:01.903]                     }
[16:06:01.903]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.903]                   }
[16:06:01.903]                 }
[16:06:01.903]                 else {
[16:06:01.903]                   if (TRUE) {
[16:06:01.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:01.903]                     {
[16:06:01.903]                       inherits <- base::inherits
[16:06:01.903]                       invokeRestart <- base::invokeRestart
[16:06:01.903]                       is.null <- base::is.null
[16:06:01.903]                       muffled <- FALSE
[16:06:01.903]                       if (inherits(cond, "message")) {
[16:06:01.903]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:01.903]                         if (muffled) 
[16:06:01.903]                           invokeRestart("muffleMessage")
[16:06:01.903]                       }
[16:06:01.903]                       else if (inherits(cond, "warning")) {
[16:06:01.903]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:01.903]                         if (muffled) 
[16:06:01.903]                           invokeRestart("muffleWarning")
[16:06:01.903]                       }
[16:06:01.903]                       else if (inherits(cond, "condition")) {
[16:06:01.903]                         if (!is.null(pattern)) {
[16:06:01.903]                           computeRestarts <- base::computeRestarts
[16:06:01.903]                           grepl <- base::grepl
[16:06:01.903]                           restarts <- computeRestarts(cond)
[16:06:01.903]                           for (restart in restarts) {
[16:06:01.903]                             name <- restart$name
[16:06:01.903]                             if (is.null(name)) 
[16:06:01.903]                               next
[16:06:01.903]                             if (!grepl(pattern, name)) 
[16:06:01.903]                               next
[16:06:01.903]                             invokeRestart(restart)
[16:06:01.903]                             muffled <- TRUE
[16:06:01.903]                             break
[16:06:01.903]                           }
[16:06:01.903]                         }
[16:06:01.903]                       }
[16:06:01.903]                       invisible(muffled)
[16:06:01.903]                     }
[16:06:01.903]                     muffleCondition(cond, pattern = "^muffle")
[16:06:01.903]                   }
[16:06:01.903]                 }
[16:06:01.903]             }
[16:06:01.903]         }))
[16:06:01.903]     }, error = function(ex) {
[16:06:01.903]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:01.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:01.903]                 ...future.rng), started = ...future.startTime, 
[16:06:01.903]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:01.903]             version = "1.8"), class = "FutureResult")
[16:06:01.903]     }, finally = {
[16:06:01.903]         if (!identical(...future.workdir, getwd())) 
[16:06:01.903]             setwd(...future.workdir)
[16:06:01.903]         {
[16:06:01.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:01.903]                 ...future.oldOptions$nwarnings <- NULL
[16:06:01.903]             }
[16:06:01.903]             base::options(...future.oldOptions)
[16:06:01.903]             if (.Platform$OS.type == "windows") {
[16:06:01.903]                 old_names <- names(...future.oldEnvVars)
[16:06:01.903]                 envs <- base::Sys.getenv()
[16:06:01.903]                 names <- names(envs)
[16:06:01.903]                 common <- intersect(names, old_names)
[16:06:01.903]                 added <- setdiff(names, old_names)
[16:06:01.903]                 removed <- setdiff(old_names, names)
[16:06:01.903]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:01.903]                   envs[common]]
[16:06:01.903]                 NAMES <- toupper(changed)
[16:06:01.903]                 args <- list()
[16:06:01.903]                 for (kk in seq_along(NAMES)) {
[16:06:01.903]                   name <- changed[[kk]]
[16:06:01.903]                   NAME <- NAMES[[kk]]
[16:06:01.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.903]                     next
[16:06:01.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.903]                 }
[16:06:01.903]                 NAMES <- toupper(added)
[16:06:01.903]                 for (kk in seq_along(NAMES)) {
[16:06:01.903]                   name <- added[[kk]]
[16:06:01.903]                   NAME <- NAMES[[kk]]
[16:06:01.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.903]                     next
[16:06:01.903]                   args[[name]] <- ""
[16:06:01.903]                 }
[16:06:01.903]                 NAMES <- toupper(removed)
[16:06:01.903]                 for (kk in seq_along(NAMES)) {
[16:06:01.903]                   name <- removed[[kk]]
[16:06:01.903]                   NAME <- NAMES[[kk]]
[16:06:01.903]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:01.903]                     next
[16:06:01.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:01.903]                 }
[16:06:01.903]                 if (length(args) > 0) 
[16:06:01.903]                   base::do.call(base::Sys.setenv, args = args)
[16:06:01.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:01.903]             }
[16:06:01.903]             else {
[16:06:01.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:01.903]             }
[16:06:01.903]             {
[16:06:01.903]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:01.903]                   0L) {
[16:06:01.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:01.903]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:01.903]                   base::options(opts)
[16:06:01.903]                 }
[16:06:01.903]                 {
[16:06:01.903]                   {
[16:06:01.903]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:01.903]                     NULL
[16:06:01.903]                   }
[16:06:01.903]                   options(future.plan = NULL)
[16:06:01.903]                   if (is.na(NA_character_)) 
[16:06:01.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:01.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:01.903]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:01.903]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:01.903]                     envir = parent.frame()) 
[16:06:01.903]                   {
[16:06:01.903]                     if (is.function(workers)) 
[16:06:01.903]                       workers <- workers()
[16:06:01.903]                     workers <- structure(as.integer(workers), 
[16:06:01.903]                       class = class(workers))
[16:06:01.903]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:01.903]                       workers >= 1)
[16:06:01.903]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:01.903]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:01.903]                     }
[16:06:01.903]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:01.903]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:01.903]                       envir = envir)
[16:06:01.903]                     if (!future$lazy) 
[16:06:01.903]                       future <- run(future)
[16:06:01.903]                     invisible(future)
[16:06:01.903]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:01.903]                 }
[16:06:01.903]             }
[16:06:01.903]         }
[16:06:01.903]     })
[16:06:01.903]     if (TRUE) {
[16:06:01.903]         base::sink(type = "output", split = FALSE)
[16:06:01.903]         if (TRUE) {
[16:06:01.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:01.903]         }
[16:06:01.903]         else {
[16:06:01.903]             ...future.result["stdout"] <- base::list(NULL)
[16:06:01.903]         }
[16:06:01.903]         base::close(...future.stdout)
[16:06:01.903]         ...future.stdout <- NULL
[16:06:01.903]     }
[16:06:01.903]     ...future.result$conditions <- ...future.conditions
[16:06:01.903]     ...future.result$finished <- base::Sys.time()
[16:06:01.903]     ...future.result
[16:06:01.903] }
[16:06:01.906] MultisessionFuture started
[16:06:01.906] - Launch lazy future ... done
[16:06:01.907] run() for ‘MultisessionFuture’ ... done
[16:06:02.453] receiveMessageFromWorker() for ClusterFuture ...
[16:06:02.453] - Validating connection of MultisessionFuture
[16:06:02.453] - received message: FutureResult
[16:06:02.453] - Received FutureResult
[16:06:02.454] - Erased future from FutureRegistry
[16:06:02.454] result() for ClusterFuture ...
[16:06:02.454] - result already collected: FutureResult
[16:06:02.454] result() for ClusterFuture ... done
[16:06:02.454] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:02.454] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:06:02.454] getGlobalsAndPackages() ...
[16:06:02.454] Searching for globals...
[16:06:02.455] - globals found: [2] ‘list’, ‘stop’
[16:06:02.455] Searching for globals ... DONE
[16:06:02.455] Resolving globals: FALSE
[16:06:02.456] 
[16:06:02.456] 
[16:06:02.456] getGlobalsAndPackages() ... DONE
[16:06:02.456] run() for ‘Future’ ...
[16:06:02.456] - state: ‘created’
[16:06:02.456] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:02.472] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:02.472] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:02.472]   - Field: ‘node’
[16:06:02.472]   - Field: ‘label’
[16:06:02.472]   - Field: ‘local’
[16:06:02.472]   - Field: ‘owner’
[16:06:02.473]   - Field: ‘envir’
[16:06:02.473]   - Field: ‘workers’
[16:06:02.473]   - Field: ‘packages’
[16:06:02.473]   - Field: ‘gc’
[16:06:02.473]   - Field: ‘conditions’
[16:06:02.473]   - Field: ‘persistent’
[16:06:02.473]   - Field: ‘expr’
[16:06:02.473]   - Field: ‘uuid’
[16:06:02.473]   - Field: ‘seed’
[16:06:02.473]   - Field: ‘version’
[16:06:02.473]   - Field: ‘result’
[16:06:02.473]   - Field: ‘asynchronous’
[16:06:02.474]   - Field: ‘calls’
[16:06:02.474]   - Field: ‘globals’
[16:06:02.474]   - Field: ‘stdout’
[16:06:02.474]   - Field: ‘earlySignal’
[16:06:02.474]   - Field: ‘lazy’
[16:06:02.474]   - Field: ‘state’
[16:06:02.474] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:02.474] - Launch lazy future ...
[16:06:02.474] Packages needed by the future expression (n = 0): <none>
[16:06:02.475] Packages needed by future strategies (n = 0): <none>
[16:06:02.475] {
[16:06:02.475]     {
[16:06:02.475]         {
[16:06:02.475]             ...future.startTime <- base::Sys.time()
[16:06:02.475]             {
[16:06:02.475]                 {
[16:06:02.475]                   {
[16:06:02.475]                     {
[16:06:02.475]                       base::local({
[16:06:02.475]                         has_future <- base::requireNamespace("future", 
[16:06:02.475]                           quietly = TRUE)
[16:06:02.475]                         if (has_future) {
[16:06:02.475]                           ns <- base::getNamespace("future")
[16:06:02.475]                           version <- ns[[".package"]][["version"]]
[16:06:02.475]                           if (is.null(version)) 
[16:06:02.475]                             version <- utils::packageVersion("future")
[16:06:02.475]                         }
[16:06:02.475]                         else {
[16:06:02.475]                           version <- NULL
[16:06:02.475]                         }
[16:06:02.475]                         if (!has_future || version < "1.8.0") {
[16:06:02.475]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:02.475]                             "", base::R.version$version.string), 
[16:06:02.475]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:02.475]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:02.475]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:02.475]                               "release", "version")], collapse = " "), 
[16:06:02.475]                             hostname = base::Sys.info()[["nodename"]])
[16:06:02.475]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:02.475]                             info)
[16:06:02.475]                           info <- base::paste(info, collapse = "; ")
[16:06:02.475]                           if (!has_future) {
[16:06:02.475]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:02.475]                               info)
[16:06:02.475]                           }
[16:06:02.475]                           else {
[16:06:02.475]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:02.475]                               info, version)
[16:06:02.475]                           }
[16:06:02.475]                           base::stop(msg)
[16:06:02.475]                         }
[16:06:02.475]                       })
[16:06:02.475]                     }
[16:06:02.475]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:02.475]                     base::options(mc.cores = 1L)
[16:06:02.475]                   }
[16:06:02.475]                   options(future.plan = NULL)
[16:06:02.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:02.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:02.475]                 }
[16:06:02.475]                 ...future.workdir <- getwd()
[16:06:02.475]             }
[16:06:02.475]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:02.475]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:02.475]         }
[16:06:02.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:02.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:02.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:02.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:02.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:02.475]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:02.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:02.475]             base::names(...future.oldOptions))
[16:06:02.475]     }
[16:06:02.475]     if (FALSE) {
[16:06:02.475]     }
[16:06:02.475]     else {
[16:06:02.475]         if (TRUE) {
[16:06:02.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:02.475]                 open = "w")
[16:06:02.475]         }
[16:06:02.475]         else {
[16:06:02.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:02.475]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:02.475]         }
[16:06:02.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:02.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:02.475]             base::sink(type = "output", split = FALSE)
[16:06:02.475]             base::close(...future.stdout)
[16:06:02.475]         }, add = TRUE)
[16:06:02.475]     }
[16:06:02.475]     ...future.frame <- base::sys.nframe()
[16:06:02.475]     ...future.conditions <- base::list()
[16:06:02.475]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:02.475]     if (FALSE) {
[16:06:02.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:02.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:02.475]     }
[16:06:02.475]     ...future.result <- base::tryCatch({
[16:06:02.475]         base::withCallingHandlers({
[16:06:02.475]             ...future.value <- base::withVisible(base::local({
[16:06:02.475]                 ...future.makeSendCondition <- base::local({
[16:06:02.475]                   sendCondition <- NULL
[16:06:02.475]                   function(frame = 1L) {
[16:06:02.475]                     if (is.function(sendCondition)) 
[16:06:02.475]                       return(sendCondition)
[16:06:02.475]                     ns <- getNamespace("parallel")
[16:06:02.475]                     if (exists("sendData", mode = "function", 
[16:06:02.475]                       envir = ns)) {
[16:06:02.475]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:02.475]                         envir = ns)
[16:06:02.475]                       envir <- sys.frame(frame)
[16:06:02.475]                       master <- NULL
[16:06:02.475]                       while (!identical(envir, .GlobalEnv) && 
[16:06:02.475]                         !identical(envir, emptyenv())) {
[16:06:02.475]                         if (exists("master", mode = "list", envir = envir, 
[16:06:02.475]                           inherits = FALSE)) {
[16:06:02.475]                           master <- get("master", mode = "list", 
[16:06:02.475]                             envir = envir, inherits = FALSE)
[16:06:02.475]                           if (inherits(master, c("SOCKnode", 
[16:06:02.475]                             "SOCK0node"))) {
[16:06:02.475]                             sendCondition <<- function(cond) {
[16:06:02.475]                               data <- list(type = "VALUE", value = cond, 
[16:06:02.475]                                 success = TRUE)
[16:06:02.475]                               parallel_sendData(master, data)
[16:06:02.475]                             }
[16:06:02.475]                             return(sendCondition)
[16:06:02.475]                           }
[16:06:02.475]                         }
[16:06:02.475]                         frame <- frame + 1L
[16:06:02.475]                         envir <- sys.frame(frame)
[16:06:02.475]                       }
[16:06:02.475]                     }
[16:06:02.475]                     sendCondition <<- function(cond) NULL
[16:06:02.475]                   }
[16:06:02.475]                 })
[16:06:02.475]                 withCallingHandlers({
[16:06:02.475]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:02.475]                 }, immediateCondition = function(cond) {
[16:06:02.475]                   sendCondition <- ...future.makeSendCondition()
[16:06:02.475]                   sendCondition(cond)
[16:06:02.475]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.475]                   {
[16:06:02.475]                     inherits <- base::inherits
[16:06:02.475]                     invokeRestart <- base::invokeRestart
[16:06:02.475]                     is.null <- base::is.null
[16:06:02.475]                     muffled <- FALSE
[16:06:02.475]                     if (inherits(cond, "message")) {
[16:06:02.475]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:02.475]                       if (muffled) 
[16:06:02.475]                         invokeRestart("muffleMessage")
[16:06:02.475]                     }
[16:06:02.475]                     else if (inherits(cond, "warning")) {
[16:06:02.475]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:02.475]                       if (muffled) 
[16:06:02.475]                         invokeRestart("muffleWarning")
[16:06:02.475]                     }
[16:06:02.475]                     else if (inherits(cond, "condition")) {
[16:06:02.475]                       if (!is.null(pattern)) {
[16:06:02.475]                         computeRestarts <- base::computeRestarts
[16:06:02.475]                         grepl <- base::grepl
[16:06:02.475]                         restarts <- computeRestarts(cond)
[16:06:02.475]                         for (restart in restarts) {
[16:06:02.475]                           name <- restart$name
[16:06:02.475]                           if (is.null(name)) 
[16:06:02.475]                             next
[16:06:02.475]                           if (!grepl(pattern, name)) 
[16:06:02.475]                             next
[16:06:02.475]                           invokeRestart(restart)
[16:06:02.475]                           muffled <- TRUE
[16:06:02.475]                           break
[16:06:02.475]                         }
[16:06:02.475]                       }
[16:06:02.475]                     }
[16:06:02.475]                     invisible(muffled)
[16:06:02.475]                   }
[16:06:02.475]                   muffleCondition(cond)
[16:06:02.475]                 })
[16:06:02.475]             }))
[16:06:02.475]             future::FutureResult(value = ...future.value$value, 
[16:06:02.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:02.475]                   ...future.rng), globalenv = if (FALSE) 
[16:06:02.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:02.475]                     ...future.globalenv.names))
[16:06:02.475]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:02.475]         }, condition = base::local({
[16:06:02.475]             c <- base::c
[16:06:02.475]             inherits <- base::inherits
[16:06:02.475]             invokeRestart <- base::invokeRestart
[16:06:02.475]             length <- base::length
[16:06:02.475]             list <- base::list
[16:06:02.475]             seq.int <- base::seq.int
[16:06:02.475]             signalCondition <- base::signalCondition
[16:06:02.475]             sys.calls <- base::sys.calls
[16:06:02.475]             `[[` <- base::`[[`
[16:06:02.475]             `+` <- base::`+`
[16:06:02.475]             `<<-` <- base::`<<-`
[16:06:02.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:02.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:02.475]                   3L)]
[16:06:02.475]             }
[16:06:02.475]             function(cond) {
[16:06:02.475]                 is_error <- inherits(cond, "error")
[16:06:02.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:02.475]                   NULL)
[16:06:02.475]                 if (is_error) {
[16:06:02.475]                   sessionInformation <- function() {
[16:06:02.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:02.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:02.475]                       search = base::search(), system = base::Sys.info())
[16:06:02.475]                   }
[16:06:02.475]                   ...future.conditions[[length(...future.conditions) + 
[16:06:02.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:02.475]                     cond$call), session = sessionInformation(), 
[16:06:02.475]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:02.475]                   signalCondition(cond)
[16:06:02.475]                 }
[16:06:02.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:02.475]                 "immediateCondition"))) {
[16:06:02.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:02.475]                   ...future.conditions[[length(...future.conditions) + 
[16:06:02.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:02.475]                   if (TRUE && !signal) {
[16:06:02.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.475]                     {
[16:06:02.475]                       inherits <- base::inherits
[16:06:02.475]                       invokeRestart <- base::invokeRestart
[16:06:02.475]                       is.null <- base::is.null
[16:06:02.475]                       muffled <- FALSE
[16:06:02.475]                       if (inherits(cond, "message")) {
[16:06:02.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:02.475]                         if (muffled) 
[16:06:02.475]                           invokeRestart("muffleMessage")
[16:06:02.475]                       }
[16:06:02.475]                       else if (inherits(cond, "warning")) {
[16:06:02.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:02.475]                         if (muffled) 
[16:06:02.475]                           invokeRestart("muffleWarning")
[16:06:02.475]                       }
[16:06:02.475]                       else if (inherits(cond, "condition")) {
[16:06:02.475]                         if (!is.null(pattern)) {
[16:06:02.475]                           computeRestarts <- base::computeRestarts
[16:06:02.475]                           grepl <- base::grepl
[16:06:02.475]                           restarts <- computeRestarts(cond)
[16:06:02.475]                           for (restart in restarts) {
[16:06:02.475]                             name <- restart$name
[16:06:02.475]                             if (is.null(name)) 
[16:06:02.475]                               next
[16:06:02.475]                             if (!grepl(pattern, name)) 
[16:06:02.475]                               next
[16:06:02.475]                             invokeRestart(restart)
[16:06:02.475]                             muffled <- TRUE
[16:06:02.475]                             break
[16:06:02.475]                           }
[16:06:02.475]                         }
[16:06:02.475]                       }
[16:06:02.475]                       invisible(muffled)
[16:06:02.475]                     }
[16:06:02.475]                     muffleCondition(cond, pattern = "^muffle")
[16:06:02.475]                   }
[16:06:02.475]                 }
[16:06:02.475]                 else {
[16:06:02.475]                   if (TRUE) {
[16:06:02.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.475]                     {
[16:06:02.475]                       inherits <- base::inherits
[16:06:02.475]                       invokeRestart <- base::invokeRestart
[16:06:02.475]                       is.null <- base::is.null
[16:06:02.475]                       muffled <- FALSE
[16:06:02.475]                       if (inherits(cond, "message")) {
[16:06:02.475]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:02.475]                         if (muffled) 
[16:06:02.475]                           invokeRestart("muffleMessage")
[16:06:02.475]                       }
[16:06:02.475]                       else if (inherits(cond, "warning")) {
[16:06:02.475]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:02.475]                         if (muffled) 
[16:06:02.475]                           invokeRestart("muffleWarning")
[16:06:02.475]                       }
[16:06:02.475]                       else if (inherits(cond, "condition")) {
[16:06:02.475]                         if (!is.null(pattern)) {
[16:06:02.475]                           computeRestarts <- base::computeRestarts
[16:06:02.475]                           grepl <- base::grepl
[16:06:02.475]                           restarts <- computeRestarts(cond)
[16:06:02.475]                           for (restart in restarts) {
[16:06:02.475]                             name <- restart$name
[16:06:02.475]                             if (is.null(name)) 
[16:06:02.475]                               next
[16:06:02.475]                             if (!grepl(pattern, name)) 
[16:06:02.475]                               next
[16:06:02.475]                             invokeRestart(restart)
[16:06:02.475]                             muffled <- TRUE
[16:06:02.475]                             break
[16:06:02.475]                           }
[16:06:02.475]                         }
[16:06:02.475]                       }
[16:06:02.475]                       invisible(muffled)
[16:06:02.475]                     }
[16:06:02.475]                     muffleCondition(cond, pattern = "^muffle")
[16:06:02.475]                   }
[16:06:02.475]                 }
[16:06:02.475]             }
[16:06:02.475]         }))
[16:06:02.475]     }, error = function(ex) {
[16:06:02.475]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:02.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:02.475]                 ...future.rng), started = ...future.startTime, 
[16:06:02.475]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:02.475]             version = "1.8"), class = "FutureResult")
[16:06:02.475]     }, finally = {
[16:06:02.475]         if (!identical(...future.workdir, getwd())) 
[16:06:02.475]             setwd(...future.workdir)
[16:06:02.475]         {
[16:06:02.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:02.475]                 ...future.oldOptions$nwarnings <- NULL
[16:06:02.475]             }
[16:06:02.475]             base::options(...future.oldOptions)
[16:06:02.475]             if (.Platform$OS.type == "windows") {
[16:06:02.475]                 old_names <- names(...future.oldEnvVars)
[16:06:02.475]                 envs <- base::Sys.getenv()
[16:06:02.475]                 names <- names(envs)
[16:06:02.475]                 common <- intersect(names, old_names)
[16:06:02.475]                 added <- setdiff(names, old_names)
[16:06:02.475]                 removed <- setdiff(old_names, names)
[16:06:02.475]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:02.475]                   envs[common]]
[16:06:02.475]                 NAMES <- toupper(changed)
[16:06:02.475]                 args <- list()
[16:06:02.475]                 for (kk in seq_along(NAMES)) {
[16:06:02.475]                   name <- changed[[kk]]
[16:06:02.475]                   NAME <- NAMES[[kk]]
[16:06:02.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.475]                     next
[16:06:02.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:02.475]                 }
[16:06:02.475]                 NAMES <- toupper(added)
[16:06:02.475]                 for (kk in seq_along(NAMES)) {
[16:06:02.475]                   name <- added[[kk]]
[16:06:02.475]                   NAME <- NAMES[[kk]]
[16:06:02.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.475]                     next
[16:06:02.475]                   args[[name]] <- ""
[16:06:02.475]                 }
[16:06:02.475]                 NAMES <- toupper(removed)
[16:06:02.475]                 for (kk in seq_along(NAMES)) {
[16:06:02.475]                   name <- removed[[kk]]
[16:06:02.475]                   NAME <- NAMES[[kk]]
[16:06:02.475]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.475]                     next
[16:06:02.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:02.475]                 }
[16:06:02.475]                 if (length(args) > 0) 
[16:06:02.475]                   base::do.call(base::Sys.setenv, args = args)
[16:06:02.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:02.475]             }
[16:06:02.475]             else {
[16:06:02.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:02.475]             }
[16:06:02.475]             {
[16:06:02.475]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:02.475]                   0L) {
[16:06:02.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:02.475]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:02.475]                   base::options(opts)
[16:06:02.475]                 }
[16:06:02.475]                 {
[16:06:02.475]                   {
[16:06:02.475]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:02.475]                     NULL
[16:06:02.475]                   }
[16:06:02.475]                   options(future.plan = NULL)
[16:06:02.475]                   if (is.na(NA_character_)) 
[16:06:02.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:02.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:02.475]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:02.475]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:02.475]                     envir = parent.frame()) 
[16:06:02.475]                   {
[16:06:02.475]                     if (is.function(workers)) 
[16:06:02.475]                       workers <- workers()
[16:06:02.475]                     workers <- structure(as.integer(workers), 
[16:06:02.475]                       class = class(workers))
[16:06:02.475]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:02.475]                       workers >= 1)
[16:06:02.475]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:02.475]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:02.475]                     }
[16:06:02.475]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:02.475]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:02.475]                       envir = envir)
[16:06:02.475]                     if (!future$lazy) 
[16:06:02.475]                       future <- run(future)
[16:06:02.475]                     invisible(future)
[16:06:02.475]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:02.475]                 }
[16:06:02.475]             }
[16:06:02.475]         }
[16:06:02.475]     })
[16:06:02.475]     if (TRUE) {
[16:06:02.475]         base::sink(type = "output", split = FALSE)
[16:06:02.475]         if (TRUE) {
[16:06:02.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:02.475]         }
[16:06:02.475]         else {
[16:06:02.475]             ...future.result["stdout"] <- base::list(NULL)
[16:06:02.475]         }
[16:06:02.475]         base::close(...future.stdout)
[16:06:02.475]         ...future.stdout <- NULL
[16:06:02.475]     }
[16:06:02.475]     ...future.result$conditions <- ...future.conditions
[16:06:02.475]     ...future.result$finished <- base::Sys.time()
[16:06:02.475]     ...future.result
[16:06:02.475] }
[16:06:02.478] MultisessionFuture started
[16:06:02.478] - Launch lazy future ... done
[16:06:02.479] run() for ‘MultisessionFuture’ ... done
[16:06:02.524] receiveMessageFromWorker() for ClusterFuture ...
[16:06:02.524] - Validating connection of MultisessionFuture
[16:06:02.525] - received message: FutureResult
[16:06:02.525] - Received FutureResult
[16:06:02.525] - Erased future from FutureRegistry
[16:06:02.525] result() for ClusterFuture ...
[16:06:02.525] - result already collected: FutureResult
[16:06:02.525] result() for ClusterFuture ... done
[16:06:02.525] signalConditions() ...
[16:06:02.525]  - include = ‘immediateCondition’
[16:06:02.525]  - exclude = 
[16:06:02.526]  - resignal = FALSE
[16:06:02.526]  - Number of conditions: 1
[16:06:02.526] signalConditions() ... done
[16:06:02.526] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:02.526] A MultisessionFuture was resolved (result was not collected)
[16:06:02.526] getGlobalsAndPackages() ...
[16:06:02.526] Searching for globals...
[16:06:02.527] - globals found: [2] ‘list’, ‘stop’
[16:06:02.527] Searching for globals ... DONE
[16:06:02.527] Resolving globals: FALSE
[16:06:02.527] 
[16:06:02.527] 
[16:06:02.528] getGlobalsAndPackages() ... DONE
[16:06:02.528] run() for ‘Future’ ...
[16:06:02.528] - state: ‘created’
[16:06:02.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:02.542] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:02.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:02.542]   - Field: ‘node’
[16:06:02.543]   - Field: ‘label’
[16:06:02.543]   - Field: ‘local’
[16:06:02.543]   - Field: ‘owner’
[16:06:02.543]   - Field: ‘envir’
[16:06:02.543]   - Field: ‘workers’
[16:06:02.543]   - Field: ‘packages’
[16:06:02.543]   - Field: ‘gc’
[16:06:02.543]   - Field: ‘conditions’
[16:06:02.543]   - Field: ‘persistent’
[16:06:02.543]   - Field: ‘expr’
[16:06:02.543]   - Field: ‘uuid’
[16:06:02.544]   - Field: ‘seed’
[16:06:02.544]   - Field: ‘version’
[16:06:02.544]   - Field: ‘result’
[16:06:02.544]   - Field: ‘asynchronous’
[16:06:02.544]   - Field: ‘calls’
[16:06:02.544]   - Field: ‘globals’
[16:06:02.544]   - Field: ‘stdout’
[16:06:02.544]   - Field: ‘earlySignal’
[16:06:02.544]   - Field: ‘lazy’
[16:06:02.544]   - Field: ‘state’
[16:06:02.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:02.545] - Launch lazy future ...
[16:06:02.545] Packages needed by the future expression (n = 0): <none>
[16:06:02.545] Packages needed by future strategies (n = 0): <none>
[16:06:02.545] {
[16:06:02.545]     {
[16:06:02.545]         {
[16:06:02.545]             ...future.startTime <- base::Sys.time()
[16:06:02.545]             {
[16:06:02.545]                 {
[16:06:02.545]                   {
[16:06:02.545]                     {
[16:06:02.545]                       base::local({
[16:06:02.545]                         has_future <- base::requireNamespace("future", 
[16:06:02.545]                           quietly = TRUE)
[16:06:02.545]                         if (has_future) {
[16:06:02.545]                           ns <- base::getNamespace("future")
[16:06:02.545]                           version <- ns[[".package"]][["version"]]
[16:06:02.545]                           if (is.null(version)) 
[16:06:02.545]                             version <- utils::packageVersion("future")
[16:06:02.545]                         }
[16:06:02.545]                         else {
[16:06:02.545]                           version <- NULL
[16:06:02.545]                         }
[16:06:02.545]                         if (!has_future || version < "1.8.0") {
[16:06:02.545]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:02.545]                             "", base::R.version$version.string), 
[16:06:02.545]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:02.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:02.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:02.545]                               "release", "version")], collapse = " "), 
[16:06:02.545]                             hostname = base::Sys.info()[["nodename"]])
[16:06:02.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:02.545]                             info)
[16:06:02.545]                           info <- base::paste(info, collapse = "; ")
[16:06:02.545]                           if (!has_future) {
[16:06:02.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:02.545]                               info)
[16:06:02.545]                           }
[16:06:02.545]                           else {
[16:06:02.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:02.545]                               info, version)
[16:06:02.545]                           }
[16:06:02.545]                           base::stop(msg)
[16:06:02.545]                         }
[16:06:02.545]                       })
[16:06:02.545]                     }
[16:06:02.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:02.545]                     base::options(mc.cores = 1L)
[16:06:02.545]                   }
[16:06:02.545]                   options(future.plan = NULL)
[16:06:02.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:02.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:02.545]                 }
[16:06:02.545]                 ...future.workdir <- getwd()
[16:06:02.545]             }
[16:06:02.545]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:02.545]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:02.545]         }
[16:06:02.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:02.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:02.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:02.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:02.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:02.545]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:02.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:02.545]             base::names(...future.oldOptions))
[16:06:02.545]     }
[16:06:02.545]     if (FALSE) {
[16:06:02.545]     }
[16:06:02.545]     else {
[16:06:02.545]         if (TRUE) {
[16:06:02.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:02.545]                 open = "w")
[16:06:02.545]         }
[16:06:02.545]         else {
[16:06:02.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:02.545]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:02.545]         }
[16:06:02.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:02.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:02.545]             base::sink(type = "output", split = FALSE)
[16:06:02.545]             base::close(...future.stdout)
[16:06:02.545]         }, add = TRUE)
[16:06:02.545]     }
[16:06:02.545]     ...future.frame <- base::sys.nframe()
[16:06:02.545]     ...future.conditions <- base::list()
[16:06:02.545]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:02.545]     if (FALSE) {
[16:06:02.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:02.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:02.545]     }
[16:06:02.545]     ...future.result <- base::tryCatch({
[16:06:02.545]         base::withCallingHandlers({
[16:06:02.545]             ...future.value <- base::withVisible(base::local({
[16:06:02.545]                 ...future.makeSendCondition <- base::local({
[16:06:02.545]                   sendCondition <- NULL
[16:06:02.545]                   function(frame = 1L) {
[16:06:02.545]                     if (is.function(sendCondition)) 
[16:06:02.545]                       return(sendCondition)
[16:06:02.545]                     ns <- getNamespace("parallel")
[16:06:02.545]                     if (exists("sendData", mode = "function", 
[16:06:02.545]                       envir = ns)) {
[16:06:02.545]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:02.545]                         envir = ns)
[16:06:02.545]                       envir <- sys.frame(frame)
[16:06:02.545]                       master <- NULL
[16:06:02.545]                       while (!identical(envir, .GlobalEnv) && 
[16:06:02.545]                         !identical(envir, emptyenv())) {
[16:06:02.545]                         if (exists("master", mode = "list", envir = envir, 
[16:06:02.545]                           inherits = FALSE)) {
[16:06:02.545]                           master <- get("master", mode = "list", 
[16:06:02.545]                             envir = envir, inherits = FALSE)
[16:06:02.545]                           if (inherits(master, c("SOCKnode", 
[16:06:02.545]                             "SOCK0node"))) {
[16:06:02.545]                             sendCondition <<- function(cond) {
[16:06:02.545]                               data <- list(type = "VALUE", value = cond, 
[16:06:02.545]                                 success = TRUE)
[16:06:02.545]                               parallel_sendData(master, data)
[16:06:02.545]                             }
[16:06:02.545]                             return(sendCondition)
[16:06:02.545]                           }
[16:06:02.545]                         }
[16:06:02.545]                         frame <- frame + 1L
[16:06:02.545]                         envir <- sys.frame(frame)
[16:06:02.545]                       }
[16:06:02.545]                     }
[16:06:02.545]                     sendCondition <<- function(cond) NULL
[16:06:02.545]                   }
[16:06:02.545]                 })
[16:06:02.545]                 withCallingHandlers({
[16:06:02.545]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:02.545]                 }, immediateCondition = function(cond) {
[16:06:02.545]                   sendCondition <- ...future.makeSendCondition()
[16:06:02.545]                   sendCondition(cond)
[16:06:02.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.545]                   {
[16:06:02.545]                     inherits <- base::inherits
[16:06:02.545]                     invokeRestart <- base::invokeRestart
[16:06:02.545]                     is.null <- base::is.null
[16:06:02.545]                     muffled <- FALSE
[16:06:02.545]                     if (inherits(cond, "message")) {
[16:06:02.545]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:02.545]                       if (muffled) 
[16:06:02.545]                         invokeRestart("muffleMessage")
[16:06:02.545]                     }
[16:06:02.545]                     else if (inherits(cond, "warning")) {
[16:06:02.545]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:02.545]                       if (muffled) 
[16:06:02.545]                         invokeRestart("muffleWarning")
[16:06:02.545]                     }
[16:06:02.545]                     else if (inherits(cond, "condition")) {
[16:06:02.545]                       if (!is.null(pattern)) {
[16:06:02.545]                         computeRestarts <- base::computeRestarts
[16:06:02.545]                         grepl <- base::grepl
[16:06:02.545]                         restarts <- computeRestarts(cond)
[16:06:02.545]                         for (restart in restarts) {
[16:06:02.545]                           name <- restart$name
[16:06:02.545]                           if (is.null(name)) 
[16:06:02.545]                             next
[16:06:02.545]                           if (!grepl(pattern, name)) 
[16:06:02.545]                             next
[16:06:02.545]                           invokeRestart(restart)
[16:06:02.545]                           muffled <- TRUE
[16:06:02.545]                           break
[16:06:02.545]                         }
[16:06:02.545]                       }
[16:06:02.545]                     }
[16:06:02.545]                     invisible(muffled)
[16:06:02.545]                   }
[16:06:02.545]                   muffleCondition(cond)
[16:06:02.545]                 })
[16:06:02.545]             }))
[16:06:02.545]             future::FutureResult(value = ...future.value$value, 
[16:06:02.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:02.545]                   ...future.rng), globalenv = if (FALSE) 
[16:06:02.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:02.545]                     ...future.globalenv.names))
[16:06:02.545]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:02.545]         }, condition = base::local({
[16:06:02.545]             c <- base::c
[16:06:02.545]             inherits <- base::inherits
[16:06:02.545]             invokeRestart <- base::invokeRestart
[16:06:02.545]             length <- base::length
[16:06:02.545]             list <- base::list
[16:06:02.545]             seq.int <- base::seq.int
[16:06:02.545]             signalCondition <- base::signalCondition
[16:06:02.545]             sys.calls <- base::sys.calls
[16:06:02.545]             `[[` <- base::`[[`
[16:06:02.545]             `+` <- base::`+`
[16:06:02.545]             `<<-` <- base::`<<-`
[16:06:02.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:02.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:02.545]                   3L)]
[16:06:02.545]             }
[16:06:02.545]             function(cond) {
[16:06:02.545]                 is_error <- inherits(cond, "error")
[16:06:02.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:02.545]                   NULL)
[16:06:02.545]                 if (is_error) {
[16:06:02.545]                   sessionInformation <- function() {
[16:06:02.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:02.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:02.545]                       search = base::search(), system = base::Sys.info())
[16:06:02.545]                   }
[16:06:02.545]                   ...future.conditions[[length(...future.conditions) + 
[16:06:02.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:02.545]                     cond$call), session = sessionInformation(), 
[16:06:02.545]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:02.545]                   signalCondition(cond)
[16:06:02.545]                 }
[16:06:02.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:02.545]                 "immediateCondition"))) {
[16:06:02.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:02.545]                   ...future.conditions[[length(...future.conditions) + 
[16:06:02.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:02.545]                   if (TRUE && !signal) {
[16:06:02.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.545]                     {
[16:06:02.545]                       inherits <- base::inherits
[16:06:02.545]                       invokeRestart <- base::invokeRestart
[16:06:02.545]                       is.null <- base::is.null
[16:06:02.545]                       muffled <- FALSE
[16:06:02.545]                       if (inherits(cond, "message")) {
[16:06:02.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:02.545]                         if (muffled) 
[16:06:02.545]                           invokeRestart("muffleMessage")
[16:06:02.545]                       }
[16:06:02.545]                       else if (inherits(cond, "warning")) {
[16:06:02.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:02.545]                         if (muffled) 
[16:06:02.545]                           invokeRestart("muffleWarning")
[16:06:02.545]                       }
[16:06:02.545]                       else if (inherits(cond, "condition")) {
[16:06:02.545]                         if (!is.null(pattern)) {
[16:06:02.545]                           computeRestarts <- base::computeRestarts
[16:06:02.545]                           grepl <- base::grepl
[16:06:02.545]                           restarts <- computeRestarts(cond)
[16:06:02.545]                           for (restart in restarts) {
[16:06:02.545]                             name <- restart$name
[16:06:02.545]                             if (is.null(name)) 
[16:06:02.545]                               next
[16:06:02.545]                             if (!grepl(pattern, name)) 
[16:06:02.545]                               next
[16:06:02.545]                             invokeRestart(restart)
[16:06:02.545]                             muffled <- TRUE
[16:06:02.545]                             break
[16:06:02.545]                           }
[16:06:02.545]                         }
[16:06:02.545]                       }
[16:06:02.545]                       invisible(muffled)
[16:06:02.545]                     }
[16:06:02.545]                     muffleCondition(cond, pattern = "^muffle")
[16:06:02.545]                   }
[16:06:02.545]                 }
[16:06:02.545]                 else {
[16:06:02.545]                   if (TRUE) {
[16:06:02.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.545]                     {
[16:06:02.545]                       inherits <- base::inherits
[16:06:02.545]                       invokeRestart <- base::invokeRestart
[16:06:02.545]                       is.null <- base::is.null
[16:06:02.545]                       muffled <- FALSE
[16:06:02.545]                       if (inherits(cond, "message")) {
[16:06:02.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:02.545]                         if (muffled) 
[16:06:02.545]                           invokeRestart("muffleMessage")
[16:06:02.545]                       }
[16:06:02.545]                       else if (inherits(cond, "warning")) {
[16:06:02.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:02.545]                         if (muffled) 
[16:06:02.545]                           invokeRestart("muffleWarning")
[16:06:02.545]                       }
[16:06:02.545]                       else if (inherits(cond, "condition")) {
[16:06:02.545]                         if (!is.null(pattern)) {
[16:06:02.545]                           computeRestarts <- base::computeRestarts
[16:06:02.545]                           grepl <- base::grepl
[16:06:02.545]                           restarts <- computeRestarts(cond)
[16:06:02.545]                           for (restart in restarts) {
[16:06:02.545]                             name <- restart$name
[16:06:02.545]                             if (is.null(name)) 
[16:06:02.545]                               next
[16:06:02.545]                             if (!grepl(pattern, name)) 
[16:06:02.545]                               next
[16:06:02.545]                             invokeRestart(restart)
[16:06:02.545]                             muffled <- TRUE
[16:06:02.545]                             break
[16:06:02.545]                           }
[16:06:02.545]                         }
[16:06:02.545]                       }
[16:06:02.545]                       invisible(muffled)
[16:06:02.545]                     }
[16:06:02.545]                     muffleCondition(cond, pattern = "^muffle")
[16:06:02.545]                   }
[16:06:02.545]                 }
[16:06:02.545]             }
[16:06:02.545]         }))
[16:06:02.545]     }, error = function(ex) {
[16:06:02.545]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:02.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:02.545]                 ...future.rng), started = ...future.startTime, 
[16:06:02.545]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:02.545]             version = "1.8"), class = "FutureResult")
[16:06:02.545]     }, finally = {
[16:06:02.545]         if (!identical(...future.workdir, getwd())) 
[16:06:02.545]             setwd(...future.workdir)
[16:06:02.545]         {
[16:06:02.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:02.545]                 ...future.oldOptions$nwarnings <- NULL
[16:06:02.545]             }
[16:06:02.545]             base::options(...future.oldOptions)
[16:06:02.545]             if (.Platform$OS.type == "windows") {
[16:06:02.545]                 old_names <- names(...future.oldEnvVars)
[16:06:02.545]                 envs <- base::Sys.getenv()
[16:06:02.545]                 names <- names(envs)
[16:06:02.545]                 common <- intersect(names, old_names)
[16:06:02.545]                 added <- setdiff(names, old_names)
[16:06:02.545]                 removed <- setdiff(old_names, names)
[16:06:02.545]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:02.545]                   envs[common]]
[16:06:02.545]                 NAMES <- toupper(changed)
[16:06:02.545]                 args <- list()
[16:06:02.545]                 for (kk in seq_along(NAMES)) {
[16:06:02.545]                   name <- changed[[kk]]
[16:06:02.545]                   NAME <- NAMES[[kk]]
[16:06:02.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.545]                     next
[16:06:02.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:02.545]                 }
[16:06:02.545]                 NAMES <- toupper(added)
[16:06:02.545]                 for (kk in seq_along(NAMES)) {
[16:06:02.545]                   name <- added[[kk]]
[16:06:02.545]                   NAME <- NAMES[[kk]]
[16:06:02.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.545]                     next
[16:06:02.545]                   args[[name]] <- ""
[16:06:02.545]                 }
[16:06:02.545]                 NAMES <- toupper(removed)
[16:06:02.545]                 for (kk in seq_along(NAMES)) {
[16:06:02.545]                   name <- removed[[kk]]
[16:06:02.545]                   NAME <- NAMES[[kk]]
[16:06:02.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.545]                     next
[16:06:02.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:02.545]                 }
[16:06:02.545]                 if (length(args) > 0) 
[16:06:02.545]                   base::do.call(base::Sys.setenv, args = args)
[16:06:02.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:02.545]             }
[16:06:02.545]             else {
[16:06:02.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:02.545]             }
[16:06:02.545]             {
[16:06:02.545]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:02.545]                   0L) {
[16:06:02.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:02.545]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:02.545]                   base::options(opts)
[16:06:02.545]                 }
[16:06:02.545]                 {
[16:06:02.545]                   {
[16:06:02.545]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:02.545]                     NULL
[16:06:02.545]                   }
[16:06:02.545]                   options(future.plan = NULL)
[16:06:02.545]                   if (is.na(NA_character_)) 
[16:06:02.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:02.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:02.545]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:02.545]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:02.545]                     envir = parent.frame()) 
[16:06:02.545]                   {
[16:06:02.545]                     if (is.function(workers)) 
[16:06:02.545]                       workers <- workers()
[16:06:02.545]                     workers <- structure(as.integer(workers), 
[16:06:02.545]                       class = class(workers))
[16:06:02.545]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:02.545]                       workers >= 1)
[16:06:02.545]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:02.545]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:02.545]                     }
[16:06:02.545]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:02.545]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:02.545]                       envir = envir)
[16:06:02.545]                     if (!future$lazy) 
[16:06:02.545]                       future <- run(future)
[16:06:02.545]                     invisible(future)
[16:06:02.545]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:02.545]                 }
[16:06:02.545]             }
[16:06:02.545]         }
[16:06:02.545]     })
[16:06:02.545]     if (TRUE) {
[16:06:02.545]         base::sink(type = "output", split = FALSE)
[16:06:02.545]         if (TRUE) {
[16:06:02.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:02.545]         }
[16:06:02.545]         else {
[16:06:02.545]             ...future.result["stdout"] <- base::list(NULL)
[16:06:02.545]         }
[16:06:02.545]         base::close(...future.stdout)
[16:06:02.545]         ...future.stdout <- NULL
[16:06:02.545]     }
[16:06:02.545]     ...future.result$conditions <- ...future.conditions
[16:06:02.545]     ...future.result$finished <- base::Sys.time()
[16:06:02.545]     ...future.result
[16:06:02.545] }
[16:06:02.548] MultisessionFuture started
[16:06:02.549] - Launch lazy future ... done
[16:06:02.549] run() for ‘MultisessionFuture’ ... done
[16:06:02.596] receiveMessageFromWorker() for ClusterFuture ...
[16:06:02.596] - Validating connection of MultisessionFuture
[16:06:02.596] - received message: FutureResult
[16:06:02.597] - Received FutureResult
[16:06:02.597] - Erased future from FutureRegistry
[16:06:02.597] result() for ClusterFuture ...
[16:06:02.597] - result already collected: FutureResult
[16:06:02.597] result() for ClusterFuture ... done
[16:06:02.597] signalConditions() ...
[16:06:02.597]  - include = ‘immediateCondition’
[16:06:02.597]  - exclude = 
[16:06:02.597]  - resignal = FALSE
[16:06:02.597]  - Number of conditions: 1
[16:06:02.598] signalConditions() ... done
[16:06:02.598] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:02.598] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[16:06:02.598] getGlobalsAndPackages() ...
[16:06:02.598] Searching for globals...
[16:06:02.599] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:02.599] Searching for globals ... DONE
[16:06:02.599] Resolving globals: FALSE
[16:06:02.600] 
[16:06:02.600] 
[16:06:02.600] getGlobalsAndPackages() ... DONE
[16:06:02.600] run() for ‘Future’ ...
[16:06:02.600] - state: ‘created’
[16:06:02.600] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:02.615] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:02.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:02.616]   - Field: ‘node’
[16:06:02.616]   - Field: ‘label’
[16:06:02.616]   - Field: ‘local’
[16:06:02.616]   - Field: ‘owner’
[16:06:02.616]   - Field: ‘envir’
[16:06:02.616]   - Field: ‘workers’
[16:06:02.616]   - Field: ‘packages’
[16:06:02.616]   - Field: ‘gc’
[16:06:02.617]   - Field: ‘conditions’
[16:06:02.617]   - Field: ‘persistent’
[16:06:02.617]   - Field: ‘expr’
[16:06:02.617]   - Field: ‘uuid’
[16:06:02.617]   - Field: ‘seed’
[16:06:02.617]   - Field: ‘version’
[16:06:02.617]   - Field: ‘result’
[16:06:02.617]   - Field: ‘asynchronous’
[16:06:02.617]   - Field: ‘calls’
[16:06:02.617]   - Field: ‘globals’
[16:06:02.617]   - Field: ‘stdout’
[16:06:02.618]   - Field: ‘earlySignal’
[16:06:02.618]   - Field: ‘lazy’
[16:06:02.618]   - Field: ‘state’
[16:06:02.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:02.618] - Launch lazy future ...
[16:06:02.618] Packages needed by the future expression (n = 0): <none>
[16:06:02.618] Packages needed by future strategies (n = 0): <none>
[16:06:02.619] {
[16:06:02.619]     {
[16:06:02.619]         {
[16:06:02.619]             ...future.startTime <- base::Sys.time()
[16:06:02.619]             {
[16:06:02.619]                 {
[16:06:02.619]                   {
[16:06:02.619]                     {
[16:06:02.619]                       base::local({
[16:06:02.619]                         has_future <- base::requireNamespace("future", 
[16:06:02.619]                           quietly = TRUE)
[16:06:02.619]                         if (has_future) {
[16:06:02.619]                           ns <- base::getNamespace("future")
[16:06:02.619]                           version <- ns[[".package"]][["version"]]
[16:06:02.619]                           if (is.null(version)) 
[16:06:02.619]                             version <- utils::packageVersion("future")
[16:06:02.619]                         }
[16:06:02.619]                         else {
[16:06:02.619]                           version <- NULL
[16:06:02.619]                         }
[16:06:02.619]                         if (!has_future || version < "1.8.0") {
[16:06:02.619]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:02.619]                             "", base::R.version$version.string), 
[16:06:02.619]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:02.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:02.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:02.619]                               "release", "version")], collapse = " "), 
[16:06:02.619]                             hostname = base::Sys.info()[["nodename"]])
[16:06:02.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:02.619]                             info)
[16:06:02.619]                           info <- base::paste(info, collapse = "; ")
[16:06:02.619]                           if (!has_future) {
[16:06:02.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:02.619]                               info)
[16:06:02.619]                           }
[16:06:02.619]                           else {
[16:06:02.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:02.619]                               info, version)
[16:06:02.619]                           }
[16:06:02.619]                           base::stop(msg)
[16:06:02.619]                         }
[16:06:02.619]                       })
[16:06:02.619]                     }
[16:06:02.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:02.619]                     base::options(mc.cores = 1L)
[16:06:02.619]                   }
[16:06:02.619]                   options(future.plan = NULL)
[16:06:02.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:02.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:02.619]                 }
[16:06:02.619]                 ...future.workdir <- getwd()
[16:06:02.619]             }
[16:06:02.619]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:02.619]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:02.619]         }
[16:06:02.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:02.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:02.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:02.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:02.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:02.619]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:02.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:02.619]             base::names(...future.oldOptions))
[16:06:02.619]     }
[16:06:02.619]     if (FALSE) {
[16:06:02.619]     }
[16:06:02.619]     else {
[16:06:02.619]         if (TRUE) {
[16:06:02.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:02.619]                 open = "w")
[16:06:02.619]         }
[16:06:02.619]         else {
[16:06:02.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:02.619]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:02.619]         }
[16:06:02.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:02.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:02.619]             base::sink(type = "output", split = FALSE)
[16:06:02.619]             base::close(...future.stdout)
[16:06:02.619]         }, add = TRUE)
[16:06:02.619]     }
[16:06:02.619]     ...future.frame <- base::sys.nframe()
[16:06:02.619]     ...future.conditions <- base::list()
[16:06:02.619]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:02.619]     if (FALSE) {
[16:06:02.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:02.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:02.619]     }
[16:06:02.619]     ...future.result <- base::tryCatch({
[16:06:02.619]         base::withCallingHandlers({
[16:06:02.619]             ...future.value <- base::withVisible(base::local({
[16:06:02.619]                 ...future.makeSendCondition <- base::local({
[16:06:02.619]                   sendCondition <- NULL
[16:06:02.619]                   function(frame = 1L) {
[16:06:02.619]                     if (is.function(sendCondition)) 
[16:06:02.619]                       return(sendCondition)
[16:06:02.619]                     ns <- getNamespace("parallel")
[16:06:02.619]                     if (exists("sendData", mode = "function", 
[16:06:02.619]                       envir = ns)) {
[16:06:02.619]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:02.619]                         envir = ns)
[16:06:02.619]                       envir <- sys.frame(frame)
[16:06:02.619]                       master <- NULL
[16:06:02.619]                       while (!identical(envir, .GlobalEnv) && 
[16:06:02.619]                         !identical(envir, emptyenv())) {
[16:06:02.619]                         if (exists("master", mode = "list", envir = envir, 
[16:06:02.619]                           inherits = FALSE)) {
[16:06:02.619]                           master <- get("master", mode = "list", 
[16:06:02.619]                             envir = envir, inherits = FALSE)
[16:06:02.619]                           if (inherits(master, c("SOCKnode", 
[16:06:02.619]                             "SOCK0node"))) {
[16:06:02.619]                             sendCondition <<- function(cond) {
[16:06:02.619]                               data <- list(type = "VALUE", value = cond, 
[16:06:02.619]                                 success = TRUE)
[16:06:02.619]                               parallel_sendData(master, data)
[16:06:02.619]                             }
[16:06:02.619]                             return(sendCondition)
[16:06:02.619]                           }
[16:06:02.619]                         }
[16:06:02.619]                         frame <- frame + 1L
[16:06:02.619]                         envir <- sys.frame(frame)
[16:06:02.619]                       }
[16:06:02.619]                     }
[16:06:02.619]                     sendCondition <<- function(cond) NULL
[16:06:02.619]                   }
[16:06:02.619]                 })
[16:06:02.619]                 withCallingHandlers({
[16:06:02.619]                   {
[16:06:02.619]                     Sys.sleep(0.5)
[16:06:02.619]                     list(a = 1, b = 42L)
[16:06:02.619]                   }
[16:06:02.619]                 }, immediateCondition = function(cond) {
[16:06:02.619]                   sendCondition <- ...future.makeSendCondition()
[16:06:02.619]                   sendCondition(cond)
[16:06:02.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.619]                   {
[16:06:02.619]                     inherits <- base::inherits
[16:06:02.619]                     invokeRestart <- base::invokeRestart
[16:06:02.619]                     is.null <- base::is.null
[16:06:02.619]                     muffled <- FALSE
[16:06:02.619]                     if (inherits(cond, "message")) {
[16:06:02.619]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:02.619]                       if (muffled) 
[16:06:02.619]                         invokeRestart("muffleMessage")
[16:06:02.619]                     }
[16:06:02.619]                     else if (inherits(cond, "warning")) {
[16:06:02.619]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:02.619]                       if (muffled) 
[16:06:02.619]                         invokeRestart("muffleWarning")
[16:06:02.619]                     }
[16:06:02.619]                     else if (inherits(cond, "condition")) {
[16:06:02.619]                       if (!is.null(pattern)) {
[16:06:02.619]                         computeRestarts <- base::computeRestarts
[16:06:02.619]                         grepl <- base::grepl
[16:06:02.619]                         restarts <- computeRestarts(cond)
[16:06:02.619]                         for (restart in restarts) {
[16:06:02.619]                           name <- restart$name
[16:06:02.619]                           if (is.null(name)) 
[16:06:02.619]                             next
[16:06:02.619]                           if (!grepl(pattern, name)) 
[16:06:02.619]                             next
[16:06:02.619]                           invokeRestart(restart)
[16:06:02.619]                           muffled <- TRUE
[16:06:02.619]                           break
[16:06:02.619]                         }
[16:06:02.619]                       }
[16:06:02.619]                     }
[16:06:02.619]                     invisible(muffled)
[16:06:02.619]                   }
[16:06:02.619]                   muffleCondition(cond)
[16:06:02.619]                 })
[16:06:02.619]             }))
[16:06:02.619]             future::FutureResult(value = ...future.value$value, 
[16:06:02.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:02.619]                   ...future.rng), globalenv = if (FALSE) 
[16:06:02.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:02.619]                     ...future.globalenv.names))
[16:06:02.619]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:02.619]         }, condition = base::local({
[16:06:02.619]             c <- base::c
[16:06:02.619]             inherits <- base::inherits
[16:06:02.619]             invokeRestart <- base::invokeRestart
[16:06:02.619]             length <- base::length
[16:06:02.619]             list <- base::list
[16:06:02.619]             seq.int <- base::seq.int
[16:06:02.619]             signalCondition <- base::signalCondition
[16:06:02.619]             sys.calls <- base::sys.calls
[16:06:02.619]             `[[` <- base::`[[`
[16:06:02.619]             `+` <- base::`+`
[16:06:02.619]             `<<-` <- base::`<<-`
[16:06:02.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:02.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:02.619]                   3L)]
[16:06:02.619]             }
[16:06:02.619]             function(cond) {
[16:06:02.619]                 is_error <- inherits(cond, "error")
[16:06:02.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:02.619]                   NULL)
[16:06:02.619]                 if (is_error) {
[16:06:02.619]                   sessionInformation <- function() {
[16:06:02.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:02.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:02.619]                       search = base::search(), system = base::Sys.info())
[16:06:02.619]                   }
[16:06:02.619]                   ...future.conditions[[length(...future.conditions) + 
[16:06:02.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:02.619]                     cond$call), session = sessionInformation(), 
[16:06:02.619]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:02.619]                   signalCondition(cond)
[16:06:02.619]                 }
[16:06:02.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:02.619]                 "immediateCondition"))) {
[16:06:02.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:02.619]                   ...future.conditions[[length(...future.conditions) + 
[16:06:02.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:02.619]                   if (TRUE && !signal) {
[16:06:02.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.619]                     {
[16:06:02.619]                       inherits <- base::inherits
[16:06:02.619]                       invokeRestart <- base::invokeRestart
[16:06:02.619]                       is.null <- base::is.null
[16:06:02.619]                       muffled <- FALSE
[16:06:02.619]                       if (inherits(cond, "message")) {
[16:06:02.619]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:02.619]                         if (muffled) 
[16:06:02.619]                           invokeRestart("muffleMessage")
[16:06:02.619]                       }
[16:06:02.619]                       else if (inherits(cond, "warning")) {
[16:06:02.619]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:02.619]                         if (muffled) 
[16:06:02.619]                           invokeRestart("muffleWarning")
[16:06:02.619]                       }
[16:06:02.619]                       else if (inherits(cond, "condition")) {
[16:06:02.619]                         if (!is.null(pattern)) {
[16:06:02.619]                           computeRestarts <- base::computeRestarts
[16:06:02.619]                           grepl <- base::grepl
[16:06:02.619]                           restarts <- computeRestarts(cond)
[16:06:02.619]                           for (restart in restarts) {
[16:06:02.619]                             name <- restart$name
[16:06:02.619]                             if (is.null(name)) 
[16:06:02.619]                               next
[16:06:02.619]                             if (!grepl(pattern, name)) 
[16:06:02.619]                               next
[16:06:02.619]                             invokeRestart(restart)
[16:06:02.619]                             muffled <- TRUE
[16:06:02.619]                             break
[16:06:02.619]                           }
[16:06:02.619]                         }
[16:06:02.619]                       }
[16:06:02.619]                       invisible(muffled)
[16:06:02.619]                     }
[16:06:02.619]                     muffleCondition(cond, pattern = "^muffle")
[16:06:02.619]                   }
[16:06:02.619]                 }
[16:06:02.619]                 else {
[16:06:02.619]                   if (TRUE) {
[16:06:02.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:02.619]                     {
[16:06:02.619]                       inherits <- base::inherits
[16:06:02.619]                       invokeRestart <- base::invokeRestart
[16:06:02.619]                       is.null <- base::is.null
[16:06:02.619]                       muffled <- FALSE
[16:06:02.619]                       if (inherits(cond, "message")) {
[16:06:02.619]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:02.619]                         if (muffled) 
[16:06:02.619]                           invokeRestart("muffleMessage")
[16:06:02.619]                       }
[16:06:02.619]                       else if (inherits(cond, "warning")) {
[16:06:02.619]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:02.619]                         if (muffled) 
[16:06:02.619]                           invokeRestart("muffleWarning")
[16:06:02.619]                       }
[16:06:02.619]                       else if (inherits(cond, "condition")) {
[16:06:02.619]                         if (!is.null(pattern)) {
[16:06:02.619]                           computeRestarts <- base::computeRestarts
[16:06:02.619]                           grepl <- base::grepl
[16:06:02.619]                           restarts <- computeRestarts(cond)
[16:06:02.619]                           for (restart in restarts) {
[16:06:02.619]                             name <- restart$name
[16:06:02.619]                             if (is.null(name)) 
[16:06:02.619]                               next
[16:06:02.619]                             if (!grepl(pattern, name)) 
[16:06:02.619]                               next
[16:06:02.619]                             invokeRestart(restart)
[16:06:02.619]                             muffled <- TRUE
[16:06:02.619]                             break
[16:06:02.619]                           }
[16:06:02.619]                         }
[16:06:02.619]                       }
[16:06:02.619]                       invisible(muffled)
[16:06:02.619]                     }
[16:06:02.619]                     muffleCondition(cond, pattern = "^muffle")
[16:06:02.619]                   }
[16:06:02.619]                 }
[16:06:02.619]             }
[16:06:02.619]         }))
[16:06:02.619]     }, error = function(ex) {
[16:06:02.619]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:02.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:02.619]                 ...future.rng), started = ...future.startTime, 
[16:06:02.619]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:02.619]             version = "1.8"), class = "FutureResult")
[16:06:02.619]     }, finally = {
[16:06:02.619]         if (!identical(...future.workdir, getwd())) 
[16:06:02.619]             setwd(...future.workdir)
[16:06:02.619]         {
[16:06:02.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:02.619]                 ...future.oldOptions$nwarnings <- NULL
[16:06:02.619]             }
[16:06:02.619]             base::options(...future.oldOptions)
[16:06:02.619]             if (.Platform$OS.type == "windows") {
[16:06:02.619]                 old_names <- names(...future.oldEnvVars)
[16:06:02.619]                 envs <- base::Sys.getenv()
[16:06:02.619]                 names <- names(envs)
[16:06:02.619]                 common <- intersect(names, old_names)
[16:06:02.619]                 added <- setdiff(names, old_names)
[16:06:02.619]                 removed <- setdiff(old_names, names)
[16:06:02.619]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:02.619]                   envs[common]]
[16:06:02.619]                 NAMES <- toupper(changed)
[16:06:02.619]                 args <- list()
[16:06:02.619]                 for (kk in seq_along(NAMES)) {
[16:06:02.619]                   name <- changed[[kk]]
[16:06:02.619]                   NAME <- NAMES[[kk]]
[16:06:02.619]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.619]                     next
[16:06:02.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:02.619]                 }
[16:06:02.619]                 NAMES <- toupper(added)
[16:06:02.619]                 for (kk in seq_along(NAMES)) {
[16:06:02.619]                   name <- added[[kk]]
[16:06:02.619]                   NAME <- NAMES[[kk]]
[16:06:02.619]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.619]                     next
[16:06:02.619]                   args[[name]] <- ""
[16:06:02.619]                 }
[16:06:02.619]                 NAMES <- toupper(removed)
[16:06:02.619]                 for (kk in seq_along(NAMES)) {
[16:06:02.619]                   name <- removed[[kk]]
[16:06:02.619]                   NAME <- NAMES[[kk]]
[16:06:02.619]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:02.619]                     next
[16:06:02.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:02.619]                 }
[16:06:02.619]                 if (length(args) > 0) 
[16:06:02.619]                   base::do.call(base::Sys.setenv, args = args)
[16:06:02.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:02.619]             }
[16:06:02.619]             else {
[16:06:02.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:02.619]             }
[16:06:02.619]             {
[16:06:02.619]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:02.619]                   0L) {
[16:06:02.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:02.619]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:02.619]                   base::options(opts)
[16:06:02.619]                 }
[16:06:02.619]                 {
[16:06:02.619]                   {
[16:06:02.619]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:02.619]                     NULL
[16:06:02.619]                   }
[16:06:02.619]                   options(future.plan = NULL)
[16:06:02.619]                   if (is.na(NA_character_)) 
[16:06:02.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:02.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:02.619]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:02.619]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:02.619]                     envir = parent.frame()) 
[16:06:02.619]                   {
[16:06:02.619]                     if (is.function(workers)) 
[16:06:02.619]                       workers <- workers()
[16:06:02.619]                     workers <- structure(as.integer(workers), 
[16:06:02.619]                       class = class(workers))
[16:06:02.619]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:02.619]                       workers >= 1)
[16:06:02.619]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:02.619]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:02.619]                     }
[16:06:02.619]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:02.619]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:02.619]                       envir = envir)
[16:06:02.619]                     if (!future$lazy) 
[16:06:02.619]                       future <- run(future)
[16:06:02.619]                     invisible(future)
[16:06:02.619]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:02.619]                 }
[16:06:02.619]             }
[16:06:02.619]         }
[16:06:02.619]     })
[16:06:02.619]     if (TRUE) {
[16:06:02.619]         base::sink(type = "output", split = FALSE)
[16:06:02.619]         if (TRUE) {
[16:06:02.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:02.619]         }
[16:06:02.619]         else {
[16:06:02.619]             ...future.result["stdout"] <- base::list(NULL)
[16:06:02.619]         }
[16:06:02.619]         base::close(...future.stdout)
[16:06:02.619]         ...future.stdout <- NULL
[16:06:02.619]     }
[16:06:02.619]     ...future.result$conditions <- ...future.conditions
[16:06:02.619]     ...future.result$finished <- base::Sys.time()
[16:06:02.619]     ...future.result
[16:06:02.619] }
[16:06:02.622] MultisessionFuture started
[16:06:02.622] - Launch lazy future ... done
[16:06:02.622] run() for ‘MultisessionFuture’ ... done
[16:06:03.169] receiveMessageFromWorker() for ClusterFuture ...
[16:06:03.169] - Validating connection of MultisessionFuture
[16:06:03.169] - received message: FutureResult
[16:06:03.170] - Received FutureResult
[16:06:03.170] - Erased future from FutureRegistry
[16:06:03.170] result() for ClusterFuture ...
[16:06:03.170] - result already collected: FutureResult
[16:06:03.170] result() for ClusterFuture ... done
[16:06:03.170] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:03.170] A MultisessionFuture was resolved (result was not collected)
[16:06:03.170] getGlobalsAndPackages() ...
[16:06:03.170] Searching for globals...
[16:06:03.172] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:03.172] Searching for globals ... DONE
[16:06:03.172] Resolving globals: FALSE
[16:06:03.172] 
[16:06:03.172] 
[16:06:03.172] getGlobalsAndPackages() ... DONE
[16:06:03.173] run() for ‘Future’ ...
[16:06:03.173] - state: ‘created’
[16:06:03.173] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:03.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:03.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:03.187]   - Field: ‘node’
[16:06:03.187]   - Field: ‘label’
[16:06:03.187]   - Field: ‘local’
[16:06:03.187]   - Field: ‘owner’
[16:06:03.187]   - Field: ‘envir’
[16:06:03.187]   - Field: ‘workers’
[16:06:03.187]   - Field: ‘packages’
[16:06:03.188]   - Field: ‘gc’
[16:06:03.188]   - Field: ‘conditions’
[16:06:03.188]   - Field: ‘persistent’
[16:06:03.188]   - Field: ‘expr’
[16:06:03.188]   - Field: ‘uuid’
[16:06:03.188]   - Field: ‘seed’
[16:06:03.188]   - Field: ‘version’
[16:06:03.188]   - Field: ‘result’
[16:06:03.188]   - Field: ‘asynchronous’
[16:06:03.188]   - Field: ‘calls’
[16:06:03.188]   - Field: ‘globals’
[16:06:03.189]   - Field: ‘stdout’
[16:06:03.189]   - Field: ‘earlySignal’
[16:06:03.189]   - Field: ‘lazy’
[16:06:03.189]   - Field: ‘state’
[16:06:03.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:03.189] - Launch lazy future ...
[16:06:03.189] Packages needed by the future expression (n = 0): <none>
[16:06:03.189] Packages needed by future strategies (n = 0): <none>
[16:06:03.190] {
[16:06:03.190]     {
[16:06:03.190]         {
[16:06:03.190]             ...future.startTime <- base::Sys.time()
[16:06:03.190]             {
[16:06:03.190]                 {
[16:06:03.190]                   {
[16:06:03.190]                     {
[16:06:03.190]                       base::local({
[16:06:03.190]                         has_future <- base::requireNamespace("future", 
[16:06:03.190]                           quietly = TRUE)
[16:06:03.190]                         if (has_future) {
[16:06:03.190]                           ns <- base::getNamespace("future")
[16:06:03.190]                           version <- ns[[".package"]][["version"]]
[16:06:03.190]                           if (is.null(version)) 
[16:06:03.190]                             version <- utils::packageVersion("future")
[16:06:03.190]                         }
[16:06:03.190]                         else {
[16:06:03.190]                           version <- NULL
[16:06:03.190]                         }
[16:06:03.190]                         if (!has_future || version < "1.8.0") {
[16:06:03.190]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:03.190]                             "", base::R.version$version.string), 
[16:06:03.190]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:03.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:03.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:03.190]                               "release", "version")], collapse = " "), 
[16:06:03.190]                             hostname = base::Sys.info()[["nodename"]])
[16:06:03.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:03.190]                             info)
[16:06:03.190]                           info <- base::paste(info, collapse = "; ")
[16:06:03.190]                           if (!has_future) {
[16:06:03.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:03.190]                               info)
[16:06:03.190]                           }
[16:06:03.190]                           else {
[16:06:03.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:03.190]                               info, version)
[16:06:03.190]                           }
[16:06:03.190]                           base::stop(msg)
[16:06:03.190]                         }
[16:06:03.190]                       })
[16:06:03.190]                     }
[16:06:03.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:03.190]                     base::options(mc.cores = 1L)
[16:06:03.190]                   }
[16:06:03.190]                   options(future.plan = NULL)
[16:06:03.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:03.190]                 }
[16:06:03.190]                 ...future.workdir <- getwd()
[16:06:03.190]             }
[16:06:03.190]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:03.190]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:03.190]         }
[16:06:03.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:03.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:03.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:03.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:03.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:03.190]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:03.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:03.190]             base::names(...future.oldOptions))
[16:06:03.190]     }
[16:06:03.190]     if (FALSE) {
[16:06:03.190]     }
[16:06:03.190]     else {
[16:06:03.190]         if (TRUE) {
[16:06:03.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:03.190]                 open = "w")
[16:06:03.190]         }
[16:06:03.190]         else {
[16:06:03.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:03.190]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:03.190]         }
[16:06:03.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:03.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:03.190]             base::sink(type = "output", split = FALSE)
[16:06:03.190]             base::close(...future.stdout)
[16:06:03.190]         }, add = TRUE)
[16:06:03.190]     }
[16:06:03.190]     ...future.frame <- base::sys.nframe()
[16:06:03.190]     ...future.conditions <- base::list()
[16:06:03.190]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:03.190]     if (FALSE) {
[16:06:03.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:03.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:03.190]     }
[16:06:03.190]     ...future.result <- base::tryCatch({
[16:06:03.190]         base::withCallingHandlers({
[16:06:03.190]             ...future.value <- base::withVisible(base::local({
[16:06:03.190]                 ...future.makeSendCondition <- base::local({
[16:06:03.190]                   sendCondition <- NULL
[16:06:03.190]                   function(frame = 1L) {
[16:06:03.190]                     if (is.function(sendCondition)) 
[16:06:03.190]                       return(sendCondition)
[16:06:03.190]                     ns <- getNamespace("parallel")
[16:06:03.190]                     if (exists("sendData", mode = "function", 
[16:06:03.190]                       envir = ns)) {
[16:06:03.190]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:03.190]                         envir = ns)
[16:06:03.190]                       envir <- sys.frame(frame)
[16:06:03.190]                       master <- NULL
[16:06:03.190]                       while (!identical(envir, .GlobalEnv) && 
[16:06:03.190]                         !identical(envir, emptyenv())) {
[16:06:03.190]                         if (exists("master", mode = "list", envir = envir, 
[16:06:03.190]                           inherits = FALSE)) {
[16:06:03.190]                           master <- get("master", mode = "list", 
[16:06:03.190]                             envir = envir, inherits = FALSE)
[16:06:03.190]                           if (inherits(master, c("SOCKnode", 
[16:06:03.190]                             "SOCK0node"))) {
[16:06:03.190]                             sendCondition <<- function(cond) {
[16:06:03.190]                               data <- list(type = "VALUE", value = cond, 
[16:06:03.190]                                 success = TRUE)
[16:06:03.190]                               parallel_sendData(master, data)
[16:06:03.190]                             }
[16:06:03.190]                             return(sendCondition)
[16:06:03.190]                           }
[16:06:03.190]                         }
[16:06:03.190]                         frame <- frame + 1L
[16:06:03.190]                         envir <- sys.frame(frame)
[16:06:03.190]                       }
[16:06:03.190]                     }
[16:06:03.190]                     sendCondition <<- function(cond) NULL
[16:06:03.190]                   }
[16:06:03.190]                 })
[16:06:03.190]                 withCallingHandlers({
[16:06:03.190]                   {
[16:06:03.190]                     Sys.sleep(0.5)
[16:06:03.190]                     list(a = 1, b = 42L)
[16:06:03.190]                   }
[16:06:03.190]                 }, immediateCondition = function(cond) {
[16:06:03.190]                   sendCondition <- ...future.makeSendCondition()
[16:06:03.190]                   sendCondition(cond)
[16:06:03.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.190]                   {
[16:06:03.190]                     inherits <- base::inherits
[16:06:03.190]                     invokeRestart <- base::invokeRestart
[16:06:03.190]                     is.null <- base::is.null
[16:06:03.190]                     muffled <- FALSE
[16:06:03.190]                     if (inherits(cond, "message")) {
[16:06:03.190]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:03.190]                       if (muffled) 
[16:06:03.190]                         invokeRestart("muffleMessage")
[16:06:03.190]                     }
[16:06:03.190]                     else if (inherits(cond, "warning")) {
[16:06:03.190]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:03.190]                       if (muffled) 
[16:06:03.190]                         invokeRestart("muffleWarning")
[16:06:03.190]                     }
[16:06:03.190]                     else if (inherits(cond, "condition")) {
[16:06:03.190]                       if (!is.null(pattern)) {
[16:06:03.190]                         computeRestarts <- base::computeRestarts
[16:06:03.190]                         grepl <- base::grepl
[16:06:03.190]                         restarts <- computeRestarts(cond)
[16:06:03.190]                         for (restart in restarts) {
[16:06:03.190]                           name <- restart$name
[16:06:03.190]                           if (is.null(name)) 
[16:06:03.190]                             next
[16:06:03.190]                           if (!grepl(pattern, name)) 
[16:06:03.190]                             next
[16:06:03.190]                           invokeRestart(restart)
[16:06:03.190]                           muffled <- TRUE
[16:06:03.190]                           break
[16:06:03.190]                         }
[16:06:03.190]                       }
[16:06:03.190]                     }
[16:06:03.190]                     invisible(muffled)
[16:06:03.190]                   }
[16:06:03.190]                   muffleCondition(cond)
[16:06:03.190]                 })
[16:06:03.190]             }))
[16:06:03.190]             future::FutureResult(value = ...future.value$value, 
[16:06:03.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.190]                   ...future.rng), globalenv = if (FALSE) 
[16:06:03.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:03.190]                     ...future.globalenv.names))
[16:06:03.190]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:03.190]         }, condition = base::local({
[16:06:03.190]             c <- base::c
[16:06:03.190]             inherits <- base::inherits
[16:06:03.190]             invokeRestart <- base::invokeRestart
[16:06:03.190]             length <- base::length
[16:06:03.190]             list <- base::list
[16:06:03.190]             seq.int <- base::seq.int
[16:06:03.190]             signalCondition <- base::signalCondition
[16:06:03.190]             sys.calls <- base::sys.calls
[16:06:03.190]             `[[` <- base::`[[`
[16:06:03.190]             `+` <- base::`+`
[16:06:03.190]             `<<-` <- base::`<<-`
[16:06:03.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:03.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:03.190]                   3L)]
[16:06:03.190]             }
[16:06:03.190]             function(cond) {
[16:06:03.190]                 is_error <- inherits(cond, "error")
[16:06:03.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:03.190]                   NULL)
[16:06:03.190]                 if (is_error) {
[16:06:03.190]                   sessionInformation <- function() {
[16:06:03.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:03.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:03.190]                       search = base::search(), system = base::Sys.info())
[16:06:03.190]                   }
[16:06:03.190]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:03.190]                     cond$call), session = sessionInformation(), 
[16:06:03.190]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:03.190]                   signalCondition(cond)
[16:06:03.190]                 }
[16:06:03.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:03.190]                 "immediateCondition"))) {
[16:06:03.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:03.190]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:03.190]                   if (TRUE && !signal) {
[16:06:03.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.190]                     {
[16:06:03.190]                       inherits <- base::inherits
[16:06:03.190]                       invokeRestart <- base::invokeRestart
[16:06:03.190]                       is.null <- base::is.null
[16:06:03.190]                       muffled <- FALSE
[16:06:03.190]                       if (inherits(cond, "message")) {
[16:06:03.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.190]                         if (muffled) 
[16:06:03.190]                           invokeRestart("muffleMessage")
[16:06:03.190]                       }
[16:06:03.190]                       else if (inherits(cond, "warning")) {
[16:06:03.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.190]                         if (muffled) 
[16:06:03.190]                           invokeRestart("muffleWarning")
[16:06:03.190]                       }
[16:06:03.190]                       else if (inherits(cond, "condition")) {
[16:06:03.190]                         if (!is.null(pattern)) {
[16:06:03.190]                           computeRestarts <- base::computeRestarts
[16:06:03.190]                           grepl <- base::grepl
[16:06:03.190]                           restarts <- computeRestarts(cond)
[16:06:03.190]                           for (restart in restarts) {
[16:06:03.190]                             name <- restart$name
[16:06:03.190]                             if (is.null(name)) 
[16:06:03.190]                               next
[16:06:03.190]                             if (!grepl(pattern, name)) 
[16:06:03.190]                               next
[16:06:03.190]                             invokeRestart(restart)
[16:06:03.190]                             muffled <- TRUE
[16:06:03.190]                             break
[16:06:03.190]                           }
[16:06:03.190]                         }
[16:06:03.190]                       }
[16:06:03.190]                       invisible(muffled)
[16:06:03.190]                     }
[16:06:03.190]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.190]                   }
[16:06:03.190]                 }
[16:06:03.190]                 else {
[16:06:03.190]                   if (TRUE) {
[16:06:03.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.190]                     {
[16:06:03.190]                       inherits <- base::inherits
[16:06:03.190]                       invokeRestart <- base::invokeRestart
[16:06:03.190]                       is.null <- base::is.null
[16:06:03.190]                       muffled <- FALSE
[16:06:03.190]                       if (inherits(cond, "message")) {
[16:06:03.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.190]                         if (muffled) 
[16:06:03.190]                           invokeRestart("muffleMessage")
[16:06:03.190]                       }
[16:06:03.190]                       else if (inherits(cond, "warning")) {
[16:06:03.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.190]                         if (muffled) 
[16:06:03.190]                           invokeRestart("muffleWarning")
[16:06:03.190]                       }
[16:06:03.190]                       else if (inherits(cond, "condition")) {
[16:06:03.190]                         if (!is.null(pattern)) {
[16:06:03.190]                           computeRestarts <- base::computeRestarts
[16:06:03.190]                           grepl <- base::grepl
[16:06:03.190]                           restarts <- computeRestarts(cond)
[16:06:03.190]                           for (restart in restarts) {
[16:06:03.190]                             name <- restart$name
[16:06:03.190]                             if (is.null(name)) 
[16:06:03.190]                               next
[16:06:03.190]                             if (!grepl(pattern, name)) 
[16:06:03.190]                               next
[16:06:03.190]                             invokeRestart(restart)
[16:06:03.190]                             muffled <- TRUE
[16:06:03.190]                             break
[16:06:03.190]                           }
[16:06:03.190]                         }
[16:06:03.190]                       }
[16:06:03.190]                       invisible(muffled)
[16:06:03.190]                     }
[16:06:03.190]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.190]                   }
[16:06:03.190]                 }
[16:06:03.190]             }
[16:06:03.190]         }))
[16:06:03.190]     }, error = function(ex) {
[16:06:03.190]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:03.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.190]                 ...future.rng), started = ...future.startTime, 
[16:06:03.190]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:03.190]             version = "1.8"), class = "FutureResult")
[16:06:03.190]     }, finally = {
[16:06:03.190]         if (!identical(...future.workdir, getwd())) 
[16:06:03.190]             setwd(...future.workdir)
[16:06:03.190]         {
[16:06:03.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:03.190]                 ...future.oldOptions$nwarnings <- NULL
[16:06:03.190]             }
[16:06:03.190]             base::options(...future.oldOptions)
[16:06:03.190]             if (.Platform$OS.type == "windows") {
[16:06:03.190]                 old_names <- names(...future.oldEnvVars)
[16:06:03.190]                 envs <- base::Sys.getenv()
[16:06:03.190]                 names <- names(envs)
[16:06:03.190]                 common <- intersect(names, old_names)
[16:06:03.190]                 added <- setdiff(names, old_names)
[16:06:03.190]                 removed <- setdiff(old_names, names)
[16:06:03.190]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:03.190]                   envs[common]]
[16:06:03.190]                 NAMES <- toupper(changed)
[16:06:03.190]                 args <- list()
[16:06:03.190]                 for (kk in seq_along(NAMES)) {
[16:06:03.190]                   name <- changed[[kk]]
[16:06:03.190]                   NAME <- NAMES[[kk]]
[16:06:03.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.190]                     next
[16:06:03.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.190]                 }
[16:06:03.190]                 NAMES <- toupper(added)
[16:06:03.190]                 for (kk in seq_along(NAMES)) {
[16:06:03.190]                   name <- added[[kk]]
[16:06:03.190]                   NAME <- NAMES[[kk]]
[16:06:03.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.190]                     next
[16:06:03.190]                   args[[name]] <- ""
[16:06:03.190]                 }
[16:06:03.190]                 NAMES <- toupper(removed)
[16:06:03.190]                 for (kk in seq_along(NAMES)) {
[16:06:03.190]                   name <- removed[[kk]]
[16:06:03.190]                   NAME <- NAMES[[kk]]
[16:06:03.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.190]                     next
[16:06:03.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.190]                 }
[16:06:03.190]                 if (length(args) > 0) 
[16:06:03.190]                   base::do.call(base::Sys.setenv, args = args)
[16:06:03.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:03.190]             }
[16:06:03.190]             else {
[16:06:03.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:03.190]             }
[16:06:03.190]             {
[16:06:03.190]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:03.190]                   0L) {
[16:06:03.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:03.190]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:03.190]                   base::options(opts)
[16:06:03.190]                 }
[16:06:03.190]                 {
[16:06:03.190]                   {
[16:06:03.190]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:03.190]                     NULL
[16:06:03.190]                   }
[16:06:03.190]                   options(future.plan = NULL)
[16:06:03.190]                   if (is.na(NA_character_)) 
[16:06:03.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:03.190]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:03.190]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:03.190]                     envir = parent.frame()) 
[16:06:03.190]                   {
[16:06:03.190]                     if (is.function(workers)) 
[16:06:03.190]                       workers <- workers()
[16:06:03.190]                     workers <- structure(as.integer(workers), 
[16:06:03.190]                       class = class(workers))
[16:06:03.190]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:03.190]                       workers >= 1)
[16:06:03.190]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:03.190]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:03.190]                     }
[16:06:03.190]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:03.190]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:03.190]                       envir = envir)
[16:06:03.190]                     if (!future$lazy) 
[16:06:03.190]                       future <- run(future)
[16:06:03.190]                     invisible(future)
[16:06:03.190]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:03.190]                 }
[16:06:03.190]             }
[16:06:03.190]         }
[16:06:03.190]     })
[16:06:03.190]     if (TRUE) {
[16:06:03.190]         base::sink(type = "output", split = FALSE)
[16:06:03.190]         if (TRUE) {
[16:06:03.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:03.190]         }
[16:06:03.190]         else {
[16:06:03.190]             ...future.result["stdout"] <- base::list(NULL)
[16:06:03.190]         }
[16:06:03.190]         base::close(...future.stdout)
[16:06:03.190]         ...future.stdout <- NULL
[16:06:03.190]     }
[16:06:03.190]     ...future.result$conditions <- ...future.conditions
[16:06:03.190]     ...future.result$finished <- base::Sys.time()
[16:06:03.190]     ...future.result
[16:06:03.190] }
[16:06:03.193] MultisessionFuture started
[16:06:03.193] - Launch lazy future ... done
[16:06:03.193] run() for ‘MultisessionFuture’ ... done
[16:06:03.750] receiveMessageFromWorker() for ClusterFuture ...
[16:06:03.750] - Validating connection of MultisessionFuture
[16:06:03.751] - received message: FutureResult
[16:06:03.751] - Received FutureResult
[16:06:03.751] - Erased future from FutureRegistry
[16:06:03.751] result() for ClusterFuture ...
[16:06:03.751] - result already collected: FutureResult
[16:06:03.751] result() for ClusterFuture ... done
[16:06:03.751] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:03.751] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:06:03.751] getGlobalsAndPackages() ...
[16:06:03.752] Searching for globals...
[16:06:03.752] - globals found: [2] ‘list’, ‘stop’
[16:06:03.752] Searching for globals ... DONE
[16:06:03.752] Resolving globals: FALSE
[16:06:03.753] 
[16:06:03.753] 
[16:06:03.753] getGlobalsAndPackages() ... DONE
[16:06:03.753] run() for ‘Future’ ...
[16:06:03.753] - state: ‘created’
[16:06:03.753] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:03.767] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:03.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:03.767]   - Field: ‘node’
[16:06:03.767]   - Field: ‘label’
[16:06:03.768]   - Field: ‘local’
[16:06:03.768]   - Field: ‘owner’
[16:06:03.768]   - Field: ‘envir’
[16:06:03.768]   - Field: ‘workers’
[16:06:03.768]   - Field: ‘packages’
[16:06:03.768]   - Field: ‘gc’
[16:06:03.768]   - Field: ‘conditions’
[16:06:03.768]   - Field: ‘persistent’
[16:06:03.768]   - Field: ‘expr’
[16:06:03.768]   - Field: ‘uuid’
[16:06:03.768]   - Field: ‘seed’
[16:06:03.769]   - Field: ‘version’
[16:06:03.769]   - Field: ‘result’
[16:06:03.769]   - Field: ‘asynchronous’
[16:06:03.769]   - Field: ‘calls’
[16:06:03.769]   - Field: ‘globals’
[16:06:03.769]   - Field: ‘stdout’
[16:06:03.769]   - Field: ‘earlySignal’
[16:06:03.769]   - Field: ‘lazy’
[16:06:03.769]   - Field: ‘state’
[16:06:03.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:03.769] - Launch lazy future ...
[16:06:03.770] Packages needed by the future expression (n = 0): <none>
[16:06:03.770] Packages needed by future strategies (n = 0): <none>
[16:06:03.770] {
[16:06:03.770]     {
[16:06:03.770]         {
[16:06:03.770]             ...future.startTime <- base::Sys.time()
[16:06:03.770]             {
[16:06:03.770]                 {
[16:06:03.770]                   {
[16:06:03.770]                     {
[16:06:03.770]                       base::local({
[16:06:03.770]                         has_future <- base::requireNamespace("future", 
[16:06:03.770]                           quietly = TRUE)
[16:06:03.770]                         if (has_future) {
[16:06:03.770]                           ns <- base::getNamespace("future")
[16:06:03.770]                           version <- ns[[".package"]][["version"]]
[16:06:03.770]                           if (is.null(version)) 
[16:06:03.770]                             version <- utils::packageVersion("future")
[16:06:03.770]                         }
[16:06:03.770]                         else {
[16:06:03.770]                           version <- NULL
[16:06:03.770]                         }
[16:06:03.770]                         if (!has_future || version < "1.8.0") {
[16:06:03.770]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:03.770]                             "", base::R.version$version.string), 
[16:06:03.770]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:03.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:03.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:03.770]                               "release", "version")], collapse = " "), 
[16:06:03.770]                             hostname = base::Sys.info()[["nodename"]])
[16:06:03.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:03.770]                             info)
[16:06:03.770]                           info <- base::paste(info, collapse = "; ")
[16:06:03.770]                           if (!has_future) {
[16:06:03.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:03.770]                               info)
[16:06:03.770]                           }
[16:06:03.770]                           else {
[16:06:03.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:03.770]                               info, version)
[16:06:03.770]                           }
[16:06:03.770]                           base::stop(msg)
[16:06:03.770]                         }
[16:06:03.770]                       })
[16:06:03.770]                     }
[16:06:03.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:03.770]                     base::options(mc.cores = 1L)
[16:06:03.770]                   }
[16:06:03.770]                   options(future.plan = NULL)
[16:06:03.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:03.770]                 }
[16:06:03.770]                 ...future.workdir <- getwd()
[16:06:03.770]             }
[16:06:03.770]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:03.770]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:03.770]         }
[16:06:03.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:03.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:03.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:03.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:03.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:03.770]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:03.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:03.770]             base::names(...future.oldOptions))
[16:06:03.770]     }
[16:06:03.770]     if (FALSE) {
[16:06:03.770]     }
[16:06:03.770]     else {
[16:06:03.770]         if (TRUE) {
[16:06:03.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:03.770]                 open = "w")
[16:06:03.770]         }
[16:06:03.770]         else {
[16:06:03.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:03.770]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:03.770]         }
[16:06:03.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:03.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:03.770]             base::sink(type = "output", split = FALSE)
[16:06:03.770]             base::close(...future.stdout)
[16:06:03.770]         }, add = TRUE)
[16:06:03.770]     }
[16:06:03.770]     ...future.frame <- base::sys.nframe()
[16:06:03.770]     ...future.conditions <- base::list()
[16:06:03.770]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:03.770]     if (FALSE) {
[16:06:03.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:03.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:03.770]     }
[16:06:03.770]     ...future.result <- base::tryCatch({
[16:06:03.770]         base::withCallingHandlers({
[16:06:03.770]             ...future.value <- base::withVisible(base::local({
[16:06:03.770]                 ...future.makeSendCondition <- base::local({
[16:06:03.770]                   sendCondition <- NULL
[16:06:03.770]                   function(frame = 1L) {
[16:06:03.770]                     if (is.function(sendCondition)) 
[16:06:03.770]                       return(sendCondition)
[16:06:03.770]                     ns <- getNamespace("parallel")
[16:06:03.770]                     if (exists("sendData", mode = "function", 
[16:06:03.770]                       envir = ns)) {
[16:06:03.770]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:03.770]                         envir = ns)
[16:06:03.770]                       envir <- sys.frame(frame)
[16:06:03.770]                       master <- NULL
[16:06:03.770]                       while (!identical(envir, .GlobalEnv) && 
[16:06:03.770]                         !identical(envir, emptyenv())) {
[16:06:03.770]                         if (exists("master", mode = "list", envir = envir, 
[16:06:03.770]                           inherits = FALSE)) {
[16:06:03.770]                           master <- get("master", mode = "list", 
[16:06:03.770]                             envir = envir, inherits = FALSE)
[16:06:03.770]                           if (inherits(master, c("SOCKnode", 
[16:06:03.770]                             "SOCK0node"))) {
[16:06:03.770]                             sendCondition <<- function(cond) {
[16:06:03.770]                               data <- list(type = "VALUE", value = cond, 
[16:06:03.770]                                 success = TRUE)
[16:06:03.770]                               parallel_sendData(master, data)
[16:06:03.770]                             }
[16:06:03.770]                             return(sendCondition)
[16:06:03.770]                           }
[16:06:03.770]                         }
[16:06:03.770]                         frame <- frame + 1L
[16:06:03.770]                         envir <- sys.frame(frame)
[16:06:03.770]                       }
[16:06:03.770]                     }
[16:06:03.770]                     sendCondition <<- function(cond) NULL
[16:06:03.770]                   }
[16:06:03.770]                 })
[16:06:03.770]                 withCallingHandlers({
[16:06:03.770]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:03.770]                 }, immediateCondition = function(cond) {
[16:06:03.770]                   sendCondition <- ...future.makeSendCondition()
[16:06:03.770]                   sendCondition(cond)
[16:06:03.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.770]                   {
[16:06:03.770]                     inherits <- base::inherits
[16:06:03.770]                     invokeRestart <- base::invokeRestart
[16:06:03.770]                     is.null <- base::is.null
[16:06:03.770]                     muffled <- FALSE
[16:06:03.770]                     if (inherits(cond, "message")) {
[16:06:03.770]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:03.770]                       if (muffled) 
[16:06:03.770]                         invokeRestart("muffleMessage")
[16:06:03.770]                     }
[16:06:03.770]                     else if (inherits(cond, "warning")) {
[16:06:03.770]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:03.770]                       if (muffled) 
[16:06:03.770]                         invokeRestart("muffleWarning")
[16:06:03.770]                     }
[16:06:03.770]                     else if (inherits(cond, "condition")) {
[16:06:03.770]                       if (!is.null(pattern)) {
[16:06:03.770]                         computeRestarts <- base::computeRestarts
[16:06:03.770]                         grepl <- base::grepl
[16:06:03.770]                         restarts <- computeRestarts(cond)
[16:06:03.770]                         for (restart in restarts) {
[16:06:03.770]                           name <- restart$name
[16:06:03.770]                           if (is.null(name)) 
[16:06:03.770]                             next
[16:06:03.770]                           if (!grepl(pattern, name)) 
[16:06:03.770]                             next
[16:06:03.770]                           invokeRestart(restart)
[16:06:03.770]                           muffled <- TRUE
[16:06:03.770]                           break
[16:06:03.770]                         }
[16:06:03.770]                       }
[16:06:03.770]                     }
[16:06:03.770]                     invisible(muffled)
[16:06:03.770]                   }
[16:06:03.770]                   muffleCondition(cond)
[16:06:03.770]                 })
[16:06:03.770]             }))
[16:06:03.770]             future::FutureResult(value = ...future.value$value, 
[16:06:03.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.770]                   ...future.rng), globalenv = if (FALSE) 
[16:06:03.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:03.770]                     ...future.globalenv.names))
[16:06:03.770]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:03.770]         }, condition = base::local({
[16:06:03.770]             c <- base::c
[16:06:03.770]             inherits <- base::inherits
[16:06:03.770]             invokeRestart <- base::invokeRestart
[16:06:03.770]             length <- base::length
[16:06:03.770]             list <- base::list
[16:06:03.770]             seq.int <- base::seq.int
[16:06:03.770]             signalCondition <- base::signalCondition
[16:06:03.770]             sys.calls <- base::sys.calls
[16:06:03.770]             `[[` <- base::`[[`
[16:06:03.770]             `+` <- base::`+`
[16:06:03.770]             `<<-` <- base::`<<-`
[16:06:03.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:03.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:03.770]                   3L)]
[16:06:03.770]             }
[16:06:03.770]             function(cond) {
[16:06:03.770]                 is_error <- inherits(cond, "error")
[16:06:03.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:03.770]                   NULL)
[16:06:03.770]                 if (is_error) {
[16:06:03.770]                   sessionInformation <- function() {
[16:06:03.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:03.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:03.770]                       search = base::search(), system = base::Sys.info())
[16:06:03.770]                   }
[16:06:03.770]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:03.770]                     cond$call), session = sessionInformation(), 
[16:06:03.770]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:03.770]                   signalCondition(cond)
[16:06:03.770]                 }
[16:06:03.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:03.770]                 "immediateCondition"))) {
[16:06:03.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:03.770]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:03.770]                   if (TRUE && !signal) {
[16:06:03.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.770]                     {
[16:06:03.770]                       inherits <- base::inherits
[16:06:03.770]                       invokeRestart <- base::invokeRestart
[16:06:03.770]                       is.null <- base::is.null
[16:06:03.770]                       muffled <- FALSE
[16:06:03.770]                       if (inherits(cond, "message")) {
[16:06:03.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.770]                         if (muffled) 
[16:06:03.770]                           invokeRestart("muffleMessage")
[16:06:03.770]                       }
[16:06:03.770]                       else if (inherits(cond, "warning")) {
[16:06:03.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.770]                         if (muffled) 
[16:06:03.770]                           invokeRestart("muffleWarning")
[16:06:03.770]                       }
[16:06:03.770]                       else if (inherits(cond, "condition")) {
[16:06:03.770]                         if (!is.null(pattern)) {
[16:06:03.770]                           computeRestarts <- base::computeRestarts
[16:06:03.770]                           grepl <- base::grepl
[16:06:03.770]                           restarts <- computeRestarts(cond)
[16:06:03.770]                           for (restart in restarts) {
[16:06:03.770]                             name <- restart$name
[16:06:03.770]                             if (is.null(name)) 
[16:06:03.770]                               next
[16:06:03.770]                             if (!grepl(pattern, name)) 
[16:06:03.770]                               next
[16:06:03.770]                             invokeRestart(restart)
[16:06:03.770]                             muffled <- TRUE
[16:06:03.770]                             break
[16:06:03.770]                           }
[16:06:03.770]                         }
[16:06:03.770]                       }
[16:06:03.770]                       invisible(muffled)
[16:06:03.770]                     }
[16:06:03.770]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.770]                   }
[16:06:03.770]                 }
[16:06:03.770]                 else {
[16:06:03.770]                   if (TRUE) {
[16:06:03.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.770]                     {
[16:06:03.770]                       inherits <- base::inherits
[16:06:03.770]                       invokeRestart <- base::invokeRestart
[16:06:03.770]                       is.null <- base::is.null
[16:06:03.770]                       muffled <- FALSE
[16:06:03.770]                       if (inherits(cond, "message")) {
[16:06:03.770]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.770]                         if (muffled) 
[16:06:03.770]                           invokeRestart("muffleMessage")
[16:06:03.770]                       }
[16:06:03.770]                       else if (inherits(cond, "warning")) {
[16:06:03.770]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.770]                         if (muffled) 
[16:06:03.770]                           invokeRestart("muffleWarning")
[16:06:03.770]                       }
[16:06:03.770]                       else if (inherits(cond, "condition")) {
[16:06:03.770]                         if (!is.null(pattern)) {
[16:06:03.770]                           computeRestarts <- base::computeRestarts
[16:06:03.770]                           grepl <- base::grepl
[16:06:03.770]                           restarts <- computeRestarts(cond)
[16:06:03.770]                           for (restart in restarts) {
[16:06:03.770]                             name <- restart$name
[16:06:03.770]                             if (is.null(name)) 
[16:06:03.770]                               next
[16:06:03.770]                             if (!grepl(pattern, name)) 
[16:06:03.770]                               next
[16:06:03.770]                             invokeRestart(restart)
[16:06:03.770]                             muffled <- TRUE
[16:06:03.770]                             break
[16:06:03.770]                           }
[16:06:03.770]                         }
[16:06:03.770]                       }
[16:06:03.770]                       invisible(muffled)
[16:06:03.770]                     }
[16:06:03.770]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.770]                   }
[16:06:03.770]                 }
[16:06:03.770]             }
[16:06:03.770]         }))
[16:06:03.770]     }, error = function(ex) {
[16:06:03.770]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:03.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.770]                 ...future.rng), started = ...future.startTime, 
[16:06:03.770]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:03.770]             version = "1.8"), class = "FutureResult")
[16:06:03.770]     }, finally = {
[16:06:03.770]         if (!identical(...future.workdir, getwd())) 
[16:06:03.770]             setwd(...future.workdir)
[16:06:03.770]         {
[16:06:03.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:03.770]                 ...future.oldOptions$nwarnings <- NULL
[16:06:03.770]             }
[16:06:03.770]             base::options(...future.oldOptions)
[16:06:03.770]             if (.Platform$OS.type == "windows") {
[16:06:03.770]                 old_names <- names(...future.oldEnvVars)
[16:06:03.770]                 envs <- base::Sys.getenv()
[16:06:03.770]                 names <- names(envs)
[16:06:03.770]                 common <- intersect(names, old_names)
[16:06:03.770]                 added <- setdiff(names, old_names)
[16:06:03.770]                 removed <- setdiff(old_names, names)
[16:06:03.770]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:03.770]                   envs[common]]
[16:06:03.770]                 NAMES <- toupper(changed)
[16:06:03.770]                 args <- list()
[16:06:03.770]                 for (kk in seq_along(NAMES)) {
[16:06:03.770]                   name <- changed[[kk]]
[16:06:03.770]                   NAME <- NAMES[[kk]]
[16:06:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.770]                     next
[16:06:03.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.770]                 }
[16:06:03.770]                 NAMES <- toupper(added)
[16:06:03.770]                 for (kk in seq_along(NAMES)) {
[16:06:03.770]                   name <- added[[kk]]
[16:06:03.770]                   NAME <- NAMES[[kk]]
[16:06:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.770]                     next
[16:06:03.770]                   args[[name]] <- ""
[16:06:03.770]                 }
[16:06:03.770]                 NAMES <- toupper(removed)
[16:06:03.770]                 for (kk in seq_along(NAMES)) {
[16:06:03.770]                   name <- removed[[kk]]
[16:06:03.770]                   NAME <- NAMES[[kk]]
[16:06:03.770]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.770]                     next
[16:06:03.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.770]                 }
[16:06:03.770]                 if (length(args) > 0) 
[16:06:03.770]                   base::do.call(base::Sys.setenv, args = args)
[16:06:03.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:03.770]             }
[16:06:03.770]             else {
[16:06:03.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:03.770]             }
[16:06:03.770]             {
[16:06:03.770]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:03.770]                   0L) {
[16:06:03.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:03.770]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:03.770]                   base::options(opts)
[16:06:03.770]                 }
[16:06:03.770]                 {
[16:06:03.770]                   {
[16:06:03.770]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:03.770]                     NULL
[16:06:03.770]                   }
[16:06:03.770]                   options(future.plan = NULL)
[16:06:03.770]                   if (is.na(NA_character_)) 
[16:06:03.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:03.770]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:03.770]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:03.770]                     envir = parent.frame()) 
[16:06:03.770]                   {
[16:06:03.770]                     if (is.function(workers)) 
[16:06:03.770]                       workers <- workers()
[16:06:03.770]                     workers <- structure(as.integer(workers), 
[16:06:03.770]                       class = class(workers))
[16:06:03.770]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:03.770]                       workers >= 1)
[16:06:03.770]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:03.770]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:03.770]                     }
[16:06:03.770]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:03.770]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:03.770]                       envir = envir)
[16:06:03.770]                     if (!future$lazy) 
[16:06:03.770]                       future <- run(future)
[16:06:03.770]                     invisible(future)
[16:06:03.770]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:03.770]                 }
[16:06:03.770]             }
[16:06:03.770]         }
[16:06:03.770]     })
[16:06:03.770]     if (TRUE) {
[16:06:03.770]         base::sink(type = "output", split = FALSE)
[16:06:03.770]         if (TRUE) {
[16:06:03.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:03.770]         }
[16:06:03.770]         else {
[16:06:03.770]             ...future.result["stdout"] <- base::list(NULL)
[16:06:03.770]         }
[16:06:03.770]         base::close(...future.stdout)
[16:06:03.770]         ...future.stdout <- NULL
[16:06:03.770]     }
[16:06:03.770]     ...future.result$conditions <- ...future.conditions
[16:06:03.770]     ...future.result$finished <- base::Sys.time()
[16:06:03.770]     ...future.result
[16:06:03.770] }
[16:06:03.774] MultisessionFuture started
[16:06:03.774] - Launch lazy future ... done
[16:06:03.774] run() for ‘MultisessionFuture’ ... done
[16:06:03.820] receiveMessageFromWorker() for ClusterFuture ...
[16:06:03.820] - Validating connection of MultisessionFuture
[16:06:03.821] - received message: FutureResult
[16:06:03.821] - Received FutureResult
[16:06:03.821] - Erased future from FutureRegistry
[16:06:03.821] result() for ClusterFuture ...
[16:06:03.821] - result already collected: FutureResult
[16:06:03.821] result() for ClusterFuture ... done
[16:06:03.821] signalConditions() ...
[16:06:03.822]  - include = ‘immediateCondition’
[16:06:03.822]  - exclude = 
[16:06:03.822]  - resignal = FALSE
[16:06:03.822]  - Number of conditions: 1
[16:06:03.822] signalConditions() ... done
[16:06:03.822] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:03.822] A MultisessionFuture was resolved (result was not collected)
[16:06:03.822] getGlobalsAndPackages() ...
[16:06:03.822] Searching for globals...
[16:06:03.823] - globals found: [2] ‘list’, ‘stop’
[16:06:03.823] Searching for globals ... DONE
[16:06:03.823] Resolving globals: FALSE
[16:06:03.824] 
[16:06:03.824] 
[16:06:03.824] getGlobalsAndPackages() ... DONE
[16:06:03.824] run() for ‘Future’ ...
[16:06:03.824] - state: ‘created’
[16:06:03.824] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:03.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:03.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:03.840]   - Field: ‘node’
[16:06:03.840]   - Field: ‘label’
[16:06:03.841]   - Field: ‘local’
[16:06:03.841]   - Field: ‘owner’
[16:06:03.841]   - Field: ‘envir’
[16:06:03.841]   - Field: ‘workers’
[16:06:03.841]   - Field: ‘packages’
[16:06:03.841]   - Field: ‘gc’
[16:06:03.841]   - Field: ‘conditions’
[16:06:03.841]   - Field: ‘persistent’
[16:06:03.841]   - Field: ‘expr’
[16:06:03.841]   - Field: ‘uuid’
[16:06:03.841]   - Field: ‘seed’
[16:06:03.842]   - Field: ‘version’
[16:06:03.842]   - Field: ‘result’
[16:06:03.842]   - Field: ‘asynchronous’
[16:06:03.842]   - Field: ‘calls’
[16:06:03.842]   - Field: ‘globals’
[16:06:03.842]   - Field: ‘stdout’
[16:06:03.842]   - Field: ‘earlySignal’
[16:06:03.842]   - Field: ‘lazy’
[16:06:03.842]   - Field: ‘state’
[16:06:03.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:03.842] - Launch lazy future ...
[16:06:03.843] Packages needed by the future expression (n = 0): <none>
[16:06:03.843] Packages needed by future strategies (n = 0): <none>
[16:06:03.843] {
[16:06:03.843]     {
[16:06:03.843]         {
[16:06:03.843]             ...future.startTime <- base::Sys.time()
[16:06:03.843]             {
[16:06:03.843]                 {
[16:06:03.843]                   {
[16:06:03.843]                     {
[16:06:03.843]                       base::local({
[16:06:03.843]                         has_future <- base::requireNamespace("future", 
[16:06:03.843]                           quietly = TRUE)
[16:06:03.843]                         if (has_future) {
[16:06:03.843]                           ns <- base::getNamespace("future")
[16:06:03.843]                           version <- ns[[".package"]][["version"]]
[16:06:03.843]                           if (is.null(version)) 
[16:06:03.843]                             version <- utils::packageVersion("future")
[16:06:03.843]                         }
[16:06:03.843]                         else {
[16:06:03.843]                           version <- NULL
[16:06:03.843]                         }
[16:06:03.843]                         if (!has_future || version < "1.8.0") {
[16:06:03.843]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:03.843]                             "", base::R.version$version.string), 
[16:06:03.843]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:03.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:03.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:03.843]                               "release", "version")], collapse = " "), 
[16:06:03.843]                             hostname = base::Sys.info()[["nodename"]])
[16:06:03.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:03.843]                             info)
[16:06:03.843]                           info <- base::paste(info, collapse = "; ")
[16:06:03.843]                           if (!has_future) {
[16:06:03.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:03.843]                               info)
[16:06:03.843]                           }
[16:06:03.843]                           else {
[16:06:03.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:03.843]                               info, version)
[16:06:03.843]                           }
[16:06:03.843]                           base::stop(msg)
[16:06:03.843]                         }
[16:06:03.843]                       })
[16:06:03.843]                     }
[16:06:03.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:03.843]                     base::options(mc.cores = 1L)
[16:06:03.843]                   }
[16:06:03.843]                   options(future.plan = NULL)
[16:06:03.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:03.843]                 }
[16:06:03.843]                 ...future.workdir <- getwd()
[16:06:03.843]             }
[16:06:03.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:03.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:03.843]         }
[16:06:03.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:03.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:03.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:03.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:03.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:03.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:03.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:03.843]             base::names(...future.oldOptions))
[16:06:03.843]     }
[16:06:03.843]     if (FALSE) {
[16:06:03.843]     }
[16:06:03.843]     else {
[16:06:03.843]         if (TRUE) {
[16:06:03.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:03.843]                 open = "w")
[16:06:03.843]         }
[16:06:03.843]         else {
[16:06:03.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:03.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:03.843]         }
[16:06:03.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:03.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:03.843]             base::sink(type = "output", split = FALSE)
[16:06:03.843]             base::close(...future.stdout)
[16:06:03.843]         }, add = TRUE)
[16:06:03.843]     }
[16:06:03.843]     ...future.frame <- base::sys.nframe()
[16:06:03.843]     ...future.conditions <- base::list()
[16:06:03.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:03.843]     if (FALSE) {
[16:06:03.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:03.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:03.843]     }
[16:06:03.843]     ...future.result <- base::tryCatch({
[16:06:03.843]         base::withCallingHandlers({
[16:06:03.843]             ...future.value <- base::withVisible(base::local({
[16:06:03.843]                 ...future.makeSendCondition <- base::local({
[16:06:03.843]                   sendCondition <- NULL
[16:06:03.843]                   function(frame = 1L) {
[16:06:03.843]                     if (is.function(sendCondition)) 
[16:06:03.843]                       return(sendCondition)
[16:06:03.843]                     ns <- getNamespace("parallel")
[16:06:03.843]                     if (exists("sendData", mode = "function", 
[16:06:03.843]                       envir = ns)) {
[16:06:03.843]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:03.843]                         envir = ns)
[16:06:03.843]                       envir <- sys.frame(frame)
[16:06:03.843]                       master <- NULL
[16:06:03.843]                       while (!identical(envir, .GlobalEnv) && 
[16:06:03.843]                         !identical(envir, emptyenv())) {
[16:06:03.843]                         if (exists("master", mode = "list", envir = envir, 
[16:06:03.843]                           inherits = FALSE)) {
[16:06:03.843]                           master <- get("master", mode = "list", 
[16:06:03.843]                             envir = envir, inherits = FALSE)
[16:06:03.843]                           if (inherits(master, c("SOCKnode", 
[16:06:03.843]                             "SOCK0node"))) {
[16:06:03.843]                             sendCondition <<- function(cond) {
[16:06:03.843]                               data <- list(type = "VALUE", value = cond, 
[16:06:03.843]                                 success = TRUE)
[16:06:03.843]                               parallel_sendData(master, data)
[16:06:03.843]                             }
[16:06:03.843]                             return(sendCondition)
[16:06:03.843]                           }
[16:06:03.843]                         }
[16:06:03.843]                         frame <- frame + 1L
[16:06:03.843]                         envir <- sys.frame(frame)
[16:06:03.843]                       }
[16:06:03.843]                     }
[16:06:03.843]                     sendCondition <<- function(cond) NULL
[16:06:03.843]                   }
[16:06:03.843]                 })
[16:06:03.843]                 withCallingHandlers({
[16:06:03.843]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:03.843]                 }, immediateCondition = function(cond) {
[16:06:03.843]                   sendCondition <- ...future.makeSendCondition()
[16:06:03.843]                   sendCondition(cond)
[16:06:03.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.843]                   {
[16:06:03.843]                     inherits <- base::inherits
[16:06:03.843]                     invokeRestart <- base::invokeRestart
[16:06:03.843]                     is.null <- base::is.null
[16:06:03.843]                     muffled <- FALSE
[16:06:03.843]                     if (inherits(cond, "message")) {
[16:06:03.843]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:03.843]                       if (muffled) 
[16:06:03.843]                         invokeRestart("muffleMessage")
[16:06:03.843]                     }
[16:06:03.843]                     else if (inherits(cond, "warning")) {
[16:06:03.843]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:03.843]                       if (muffled) 
[16:06:03.843]                         invokeRestart("muffleWarning")
[16:06:03.843]                     }
[16:06:03.843]                     else if (inherits(cond, "condition")) {
[16:06:03.843]                       if (!is.null(pattern)) {
[16:06:03.843]                         computeRestarts <- base::computeRestarts
[16:06:03.843]                         grepl <- base::grepl
[16:06:03.843]                         restarts <- computeRestarts(cond)
[16:06:03.843]                         for (restart in restarts) {
[16:06:03.843]                           name <- restart$name
[16:06:03.843]                           if (is.null(name)) 
[16:06:03.843]                             next
[16:06:03.843]                           if (!grepl(pattern, name)) 
[16:06:03.843]                             next
[16:06:03.843]                           invokeRestart(restart)
[16:06:03.843]                           muffled <- TRUE
[16:06:03.843]                           break
[16:06:03.843]                         }
[16:06:03.843]                       }
[16:06:03.843]                     }
[16:06:03.843]                     invisible(muffled)
[16:06:03.843]                   }
[16:06:03.843]                   muffleCondition(cond)
[16:06:03.843]                 })
[16:06:03.843]             }))
[16:06:03.843]             future::FutureResult(value = ...future.value$value, 
[16:06:03.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.843]                   ...future.rng), globalenv = if (FALSE) 
[16:06:03.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:03.843]                     ...future.globalenv.names))
[16:06:03.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:03.843]         }, condition = base::local({
[16:06:03.843]             c <- base::c
[16:06:03.843]             inherits <- base::inherits
[16:06:03.843]             invokeRestart <- base::invokeRestart
[16:06:03.843]             length <- base::length
[16:06:03.843]             list <- base::list
[16:06:03.843]             seq.int <- base::seq.int
[16:06:03.843]             signalCondition <- base::signalCondition
[16:06:03.843]             sys.calls <- base::sys.calls
[16:06:03.843]             `[[` <- base::`[[`
[16:06:03.843]             `+` <- base::`+`
[16:06:03.843]             `<<-` <- base::`<<-`
[16:06:03.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:03.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:03.843]                   3L)]
[16:06:03.843]             }
[16:06:03.843]             function(cond) {
[16:06:03.843]                 is_error <- inherits(cond, "error")
[16:06:03.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:03.843]                   NULL)
[16:06:03.843]                 if (is_error) {
[16:06:03.843]                   sessionInformation <- function() {
[16:06:03.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:03.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:03.843]                       search = base::search(), system = base::Sys.info())
[16:06:03.843]                   }
[16:06:03.843]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:03.843]                     cond$call), session = sessionInformation(), 
[16:06:03.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:03.843]                   signalCondition(cond)
[16:06:03.843]                 }
[16:06:03.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:03.843]                 "immediateCondition"))) {
[16:06:03.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:03.843]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:03.843]                   if (TRUE && !signal) {
[16:06:03.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.843]                     {
[16:06:03.843]                       inherits <- base::inherits
[16:06:03.843]                       invokeRestart <- base::invokeRestart
[16:06:03.843]                       is.null <- base::is.null
[16:06:03.843]                       muffled <- FALSE
[16:06:03.843]                       if (inherits(cond, "message")) {
[16:06:03.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.843]                         if (muffled) 
[16:06:03.843]                           invokeRestart("muffleMessage")
[16:06:03.843]                       }
[16:06:03.843]                       else if (inherits(cond, "warning")) {
[16:06:03.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.843]                         if (muffled) 
[16:06:03.843]                           invokeRestart("muffleWarning")
[16:06:03.843]                       }
[16:06:03.843]                       else if (inherits(cond, "condition")) {
[16:06:03.843]                         if (!is.null(pattern)) {
[16:06:03.843]                           computeRestarts <- base::computeRestarts
[16:06:03.843]                           grepl <- base::grepl
[16:06:03.843]                           restarts <- computeRestarts(cond)
[16:06:03.843]                           for (restart in restarts) {
[16:06:03.843]                             name <- restart$name
[16:06:03.843]                             if (is.null(name)) 
[16:06:03.843]                               next
[16:06:03.843]                             if (!grepl(pattern, name)) 
[16:06:03.843]                               next
[16:06:03.843]                             invokeRestart(restart)
[16:06:03.843]                             muffled <- TRUE
[16:06:03.843]                             break
[16:06:03.843]                           }
[16:06:03.843]                         }
[16:06:03.843]                       }
[16:06:03.843]                       invisible(muffled)
[16:06:03.843]                     }
[16:06:03.843]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.843]                   }
[16:06:03.843]                 }
[16:06:03.843]                 else {
[16:06:03.843]                   if (TRUE) {
[16:06:03.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.843]                     {
[16:06:03.843]                       inherits <- base::inherits
[16:06:03.843]                       invokeRestart <- base::invokeRestart
[16:06:03.843]                       is.null <- base::is.null
[16:06:03.843]                       muffled <- FALSE
[16:06:03.843]                       if (inherits(cond, "message")) {
[16:06:03.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.843]                         if (muffled) 
[16:06:03.843]                           invokeRestart("muffleMessage")
[16:06:03.843]                       }
[16:06:03.843]                       else if (inherits(cond, "warning")) {
[16:06:03.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.843]                         if (muffled) 
[16:06:03.843]                           invokeRestart("muffleWarning")
[16:06:03.843]                       }
[16:06:03.843]                       else if (inherits(cond, "condition")) {
[16:06:03.843]                         if (!is.null(pattern)) {
[16:06:03.843]                           computeRestarts <- base::computeRestarts
[16:06:03.843]                           grepl <- base::grepl
[16:06:03.843]                           restarts <- computeRestarts(cond)
[16:06:03.843]                           for (restart in restarts) {
[16:06:03.843]                             name <- restart$name
[16:06:03.843]                             if (is.null(name)) 
[16:06:03.843]                               next
[16:06:03.843]                             if (!grepl(pattern, name)) 
[16:06:03.843]                               next
[16:06:03.843]                             invokeRestart(restart)
[16:06:03.843]                             muffled <- TRUE
[16:06:03.843]                             break
[16:06:03.843]                           }
[16:06:03.843]                         }
[16:06:03.843]                       }
[16:06:03.843]                       invisible(muffled)
[16:06:03.843]                     }
[16:06:03.843]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.843]                   }
[16:06:03.843]                 }
[16:06:03.843]             }
[16:06:03.843]         }))
[16:06:03.843]     }, error = function(ex) {
[16:06:03.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:03.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.843]                 ...future.rng), started = ...future.startTime, 
[16:06:03.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:03.843]             version = "1.8"), class = "FutureResult")
[16:06:03.843]     }, finally = {
[16:06:03.843]         if (!identical(...future.workdir, getwd())) 
[16:06:03.843]             setwd(...future.workdir)
[16:06:03.843]         {
[16:06:03.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:03.843]                 ...future.oldOptions$nwarnings <- NULL
[16:06:03.843]             }
[16:06:03.843]             base::options(...future.oldOptions)
[16:06:03.843]             if (.Platform$OS.type == "windows") {
[16:06:03.843]                 old_names <- names(...future.oldEnvVars)
[16:06:03.843]                 envs <- base::Sys.getenv()
[16:06:03.843]                 names <- names(envs)
[16:06:03.843]                 common <- intersect(names, old_names)
[16:06:03.843]                 added <- setdiff(names, old_names)
[16:06:03.843]                 removed <- setdiff(old_names, names)
[16:06:03.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:03.843]                   envs[common]]
[16:06:03.843]                 NAMES <- toupper(changed)
[16:06:03.843]                 args <- list()
[16:06:03.843]                 for (kk in seq_along(NAMES)) {
[16:06:03.843]                   name <- changed[[kk]]
[16:06:03.843]                   NAME <- NAMES[[kk]]
[16:06:03.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.843]                     next
[16:06:03.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.843]                 }
[16:06:03.843]                 NAMES <- toupper(added)
[16:06:03.843]                 for (kk in seq_along(NAMES)) {
[16:06:03.843]                   name <- added[[kk]]
[16:06:03.843]                   NAME <- NAMES[[kk]]
[16:06:03.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.843]                     next
[16:06:03.843]                   args[[name]] <- ""
[16:06:03.843]                 }
[16:06:03.843]                 NAMES <- toupper(removed)
[16:06:03.843]                 for (kk in seq_along(NAMES)) {
[16:06:03.843]                   name <- removed[[kk]]
[16:06:03.843]                   NAME <- NAMES[[kk]]
[16:06:03.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.843]                     next
[16:06:03.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.843]                 }
[16:06:03.843]                 if (length(args) > 0) 
[16:06:03.843]                   base::do.call(base::Sys.setenv, args = args)
[16:06:03.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:03.843]             }
[16:06:03.843]             else {
[16:06:03.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:03.843]             }
[16:06:03.843]             {
[16:06:03.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:03.843]                   0L) {
[16:06:03.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:03.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:03.843]                   base::options(opts)
[16:06:03.843]                 }
[16:06:03.843]                 {
[16:06:03.843]                   {
[16:06:03.843]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:03.843]                     NULL
[16:06:03.843]                   }
[16:06:03.843]                   options(future.plan = NULL)
[16:06:03.843]                   if (is.na(NA_character_)) 
[16:06:03.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:03.843]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:03.843]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:03.843]                     envir = parent.frame()) 
[16:06:03.843]                   {
[16:06:03.843]                     if (is.function(workers)) 
[16:06:03.843]                       workers <- workers()
[16:06:03.843]                     workers <- structure(as.integer(workers), 
[16:06:03.843]                       class = class(workers))
[16:06:03.843]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:03.843]                       workers >= 1)
[16:06:03.843]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:03.843]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:03.843]                     }
[16:06:03.843]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:03.843]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:03.843]                       envir = envir)
[16:06:03.843]                     if (!future$lazy) 
[16:06:03.843]                       future <- run(future)
[16:06:03.843]                     invisible(future)
[16:06:03.843]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:03.843]                 }
[16:06:03.843]             }
[16:06:03.843]         }
[16:06:03.843]     })
[16:06:03.843]     if (TRUE) {
[16:06:03.843]         base::sink(type = "output", split = FALSE)
[16:06:03.843]         if (TRUE) {
[16:06:03.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:03.843]         }
[16:06:03.843]         else {
[16:06:03.843]             ...future.result["stdout"] <- base::list(NULL)
[16:06:03.843]         }
[16:06:03.843]         base::close(...future.stdout)
[16:06:03.843]         ...future.stdout <- NULL
[16:06:03.843]     }
[16:06:03.843]     ...future.result$conditions <- ...future.conditions
[16:06:03.843]     ...future.result$finished <- base::Sys.time()
[16:06:03.843]     ...future.result
[16:06:03.843] }
[16:06:03.846] MultisessionFuture started
[16:06:03.846] - Launch lazy future ... done
[16:06:03.846] run() for ‘MultisessionFuture’ ... done
[16:06:03.892] receiveMessageFromWorker() for ClusterFuture ...
[16:06:03.892] - Validating connection of MultisessionFuture
[16:06:03.892] - received message: FutureResult
[16:06:03.892] - Received FutureResult
[16:06:03.893] - Erased future from FutureRegistry
[16:06:03.893] result() for ClusterFuture ...
[16:06:03.893] - result already collected: FutureResult
[16:06:03.893] result() for ClusterFuture ... done
[16:06:03.893] signalConditions() ...
[16:06:03.893]  - include = ‘immediateCondition’
[16:06:03.893]  - exclude = 
[16:06:03.893]  - resignal = FALSE
[16:06:03.893]  - Number of conditions: 1
[16:06:03.893] signalConditions() ... done
[16:06:03.893] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:03.894] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[16:06:03.894] getGlobalsAndPackages() ...
[16:06:03.894] Searching for globals...
[16:06:03.895] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:03.895] Searching for globals ... DONE
[16:06:03.895] Resolving globals: FALSE
[16:06:03.896] 
[16:06:03.896] 
[16:06:03.896] getGlobalsAndPackages() ... DONE
[16:06:03.896] run() for ‘Future’ ...
[16:06:03.896] - state: ‘created’
[16:06:03.896] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:03.910] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:03.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:03.910]   - Field: ‘node’
[16:06:03.910]   - Field: ‘label’
[16:06:03.910]   - Field: ‘local’
[16:06:03.910]   - Field: ‘owner’
[16:06:03.910]   - Field: ‘envir’
[16:06:03.911]   - Field: ‘workers’
[16:06:03.911]   - Field: ‘packages’
[16:06:03.911]   - Field: ‘gc’
[16:06:03.911]   - Field: ‘conditions’
[16:06:03.911]   - Field: ‘persistent’
[16:06:03.911]   - Field: ‘expr’
[16:06:03.911]   - Field: ‘uuid’
[16:06:03.911]   - Field: ‘seed’
[16:06:03.911]   - Field: ‘version’
[16:06:03.911]   - Field: ‘result’
[16:06:03.911]   - Field: ‘asynchronous’
[16:06:03.912]   - Field: ‘calls’
[16:06:03.912]   - Field: ‘globals’
[16:06:03.912]   - Field: ‘stdout’
[16:06:03.912]   - Field: ‘earlySignal’
[16:06:03.912]   - Field: ‘lazy’
[16:06:03.912]   - Field: ‘state’
[16:06:03.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:03.912] - Launch lazy future ...
[16:06:03.912] Packages needed by the future expression (n = 0): <none>
[16:06:03.912] Packages needed by future strategies (n = 0): <none>
[16:06:03.913] {
[16:06:03.913]     {
[16:06:03.913]         {
[16:06:03.913]             ...future.startTime <- base::Sys.time()
[16:06:03.913]             {
[16:06:03.913]                 {
[16:06:03.913]                   {
[16:06:03.913]                     {
[16:06:03.913]                       base::local({
[16:06:03.913]                         has_future <- base::requireNamespace("future", 
[16:06:03.913]                           quietly = TRUE)
[16:06:03.913]                         if (has_future) {
[16:06:03.913]                           ns <- base::getNamespace("future")
[16:06:03.913]                           version <- ns[[".package"]][["version"]]
[16:06:03.913]                           if (is.null(version)) 
[16:06:03.913]                             version <- utils::packageVersion("future")
[16:06:03.913]                         }
[16:06:03.913]                         else {
[16:06:03.913]                           version <- NULL
[16:06:03.913]                         }
[16:06:03.913]                         if (!has_future || version < "1.8.0") {
[16:06:03.913]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:03.913]                             "", base::R.version$version.string), 
[16:06:03.913]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:03.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:03.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:03.913]                               "release", "version")], collapse = " "), 
[16:06:03.913]                             hostname = base::Sys.info()[["nodename"]])
[16:06:03.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:03.913]                             info)
[16:06:03.913]                           info <- base::paste(info, collapse = "; ")
[16:06:03.913]                           if (!has_future) {
[16:06:03.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:03.913]                               info)
[16:06:03.913]                           }
[16:06:03.913]                           else {
[16:06:03.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:03.913]                               info, version)
[16:06:03.913]                           }
[16:06:03.913]                           base::stop(msg)
[16:06:03.913]                         }
[16:06:03.913]                       })
[16:06:03.913]                     }
[16:06:03.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:03.913]                     base::options(mc.cores = 1L)
[16:06:03.913]                   }
[16:06:03.913]                   options(future.plan = NULL)
[16:06:03.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:03.913]                 }
[16:06:03.913]                 ...future.workdir <- getwd()
[16:06:03.913]             }
[16:06:03.913]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:03.913]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:03.913]         }
[16:06:03.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:03.913]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:03.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:03.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:03.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:03.913]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:03.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:03.913]             base::names(...future.oldOptions))
[16:06:03.913]     }
[16:06:03.913]     if (FALSE) {
[16:06:03.913]     }
[16:06:03.913]     else {
[16:06:03.913]         if (TRUE) {
[16:06:03.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:03.913]                 open = "w")
[16:06:03.913]         }
[16:06:03.913]         else {
[16:06:03.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:03.913]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:03.913]         }
[16:06:03.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:03.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:03.913]             base::sink(type = "output", split = FALSE)
[16:06:03.913]             base::close(...future.stdout)
[16:06:03.913]         }, add = TRUE)
[16:06:03.913]     }
[16:06:03.913]     ...future.frame <- base::sys.nframe()
[16:06:03.913]     ...future.conditions <- base::list()
[16:06:03.913]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:03.913]     if (FALSE) {
[16:06:03.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:03.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:03.913]     }
[16:06:03.913]     ...future.result <- base::tryCatch({
[16:06:03.913]         base::withCallingHandlers({
[16:06:03.913]             ...future.value <- base::withVisible(base::local({
[16:06:03.913]                 ...future.makeSendCondition <- base::local({
[16:06:03.913]                   sendCondition <- NULL
[16:06:03.913]                   function(frame = 1L) {
[16:06:03.913]                     if (is.function(sendCondition)) 
[16:06:03.913]                       return(sendCondition)
[16:06:03.913]                     ns <- getNamespace("parallel")
[16:06:03.913]                     if (exists("sendData", mode = "function", 
[16:06:03.913]                       envir = ns)) {
[16:06:03.913]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:03.913]                         envir = ns)
[16:06:03.913]                       envir <- sys.frame(frame)
[16:06:03.913]                       master <- NULL
[16:06:03.913]                       while (!identical(envir, .GlobalEnv) && 
[16:06:03.913]                         !identical(envir, emptyenv())) {
[16:06:03.913]                         if (exists("master", mode = "list", envir = envir, 
[16:06:03.913]                           inherits = FALSE)) {
[16:06:03.913]                           master <- get("master", mode = "list", 
[16:06:03.913]                             envir = envir, inherits = FALSE)
[16:06:03.913]                           if (inherits(master, c("SOCKnode", 
[16:06:03.913]                             "SOCK0node"))) {
[16:06:03.913]                             sendCondition <<- function(cond) {
[16:06:03.913]                               data <- list(type = "VALUE", value = cond, 
[16:06:03.913]                                 success = TRUE)
[16:06:03.913]                               parallel_sendData(master, data)
[16:06:03.913]                             }
[16:06:03.913]                             return(sendCondition)
[16:06:03.913]                           }
[16:06:03.913]                         }
[16:06:03.913]                         frame <- frame + 1L
[16:06:03.913]                         envir <- sys.frame(frame)
[16:06:03.913]                       }
[16:06:03.913]                     }
[16:06:03.913]                     sendCondition <<- function(cond) NULL
[16:06:03.913]                   }
[16:06:03.913]                 })
[16:06:03.913]                 withCallingHandlers({
[16:06:03.913]                   {
[16:06:03.913]                     Sys.sleep(0.5)
[16:06:03.913]                     list(a = 1, b = 42L)
[16:06:03.913]                   }
[16:06:03.913]                 }, immediateCondition = function(cond) {
[16:06:03.913]                   sendCondition <- ...future.makeSendCondition()
[16:06:03.913]                   sendCondition(cond)
[16:06:03.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.913]                   {
[16:06:03.913]                     inherits <- base::inherits
[16:06:03.913]                     invokeRestart <- base::invokeRestart
[16:06:03.913]                     is.null <- base::is.null
[16:06:03.913]                     muffled <- FALSE
[16:06:03.913]                     if (inherits(cond, "message")) {
[16:06:03.913]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:03.913]                       if (muffled) 
[16:06:03.913]                         invokeRestart("muffleMessage")
[16:06:03.913]                     }
[16:06:03.913]                     else if (inherits(cond, "warning")) {
[16:06:03.913]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:03.913]                       if (muffled) 
[16:06:03.913]                         invokeRestart("muffleWarning")
[16:06:03.913]                     }
[16:06:03.913]                     else if (inherits(cond, "condition")) {
[16:06:03.913]                       if (!is.null(pattern)) {
[16:06:03.913]                         computeRestarts <- base::computeRestarts
[16:06:03.913]                         grepl <- base::grepl
[16:06:03.913]                         restarts <- computeRestarts(cond)
[16:06:03.913]                         for (restart in restarts) {
[16:06:03.913]                           name <- restart$name
[16:06:03.913]                           if (is.null(name)) 
[16:06:03.913]                             next
[16:06:03.913]                           if (!grepl(pattern, name)) 
[16:06:03.913]                             next
[16:06:03.913]                           invokeRestart(restart)
[16:06:03.913]                           muffled <- TRUE
[16:06:03.913]                           break
[16:06:03.913]                         }
[16:06:03.913]                       }
[16:06:03.913]                     }
[16:06:03.913]                     invisible(muffled)
[16:06:03.913]                   }
[16:06:03.913]                   muffleCondition(cond)
[16:06:03.913]                 })
[16:06:03.913]             }))
[16:06:03.913]             future::FutureResult(value = ...future.value$value, 
[16:06:03.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.913]                   ...future.rng), globalenv = if (FALSE) 
[16:06:03.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:03.913]                     ...future.globalenv.names))
[16:06:03.913]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:03.913]         }, condition = base::local({
[16:06:03.913]             c <- base::c
[16:06:03.913]             inherits <- base::inherits
[16:06:03.913]             invokeRestart <- base::invokeRestart
[16:06:03.913]             length <- base::length
[16:06:03.913]             list <- base::list
[16:06:03.913]             seq.int <- base::seq.int
[16:06:03.913]             signalCondition <- base::signalCondition
[16:06:03.913]             sys.calls <- base::sys.calls
[16:06:03.913]             `[[` <- base::`[[`
[16:06:03.913]             `+` <- base::`+`
[16:06:03.913]             `<<-` <- base::`<<-`
[16:06:03.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:03.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:03.913]                   3L)]
[16:06:03.913]             }
[16:06:03.913]             function(cond) {
[16:06:03.913]                 is_error <- inherits(cond, "error")
[16:06:03.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:03.913]                   NULL)
[16:06:03.913]                 if (is_error) {
[16:06:03.913]                   sessionInformation <- function() {
[16:06:03.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:03.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:03.913]                       search = base::search(), system = base::Sys.info())
[16:06:03.913]                   }
[16:06:03.913]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:03.913]                     cond$call), session = sessionInformation(), 
[16:06:03.913]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:03.913]                   signalCondition(cond)
[16:06:03.913]                 }
[16:06:03.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:03.913]                 "immediateCondition"))) {
[16:06:03.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:03.913]                   ...future.conditions[[length(...future.conditions) + 
[16:06:03.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:03.913]                   if (TRUE && !signal) {
[16:06:03.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.913]                     {
[16:06:03.913]                       inherits <- base::inherits
[16:06:03.913]                       invokeRestart <- base::invokeRestart
[16:06:03.913]                       is.null <- base::is.null
[16:06:03.913]                       muffled <- FALSE
[16:06:03.913]                       if (inherits(cond, "message")) {
[16:06:03.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.913]                         if (muffled) 
[16:06:03.913]                           invokeRestart("muffleMessage")
[16:06:03.913]                       }
[16:06:03.913]                       else if (inherits(cond, "warning")) {
[16:06:03.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.913]                         if (muffled) 
[16:06:03.913]                           invokeRestart("muffleWarning")
[16:06:03.913]                       }
[16:06:03.913]                       else if (inherits(cond, "condition")) {
[16:06:03.913]                         if (!is.null(pattern)) {
[16:06:03.913]                           computeRestarts <- base::computeRestarts
[16:06:03.913]                           grepl <- base::grepl
[16:06:03.913]                           restarts <- computeRestarts(cond)
[16:06:03.913]                           for (restart in restarts) {
[16:06:03.913]                             name <- restart$name
[16:06:03.913]                             if (is.null(name)) 
[16:06:03.913]                               next
[16:06:03.913]                             if (!grepl(pattern, name)) 
[16:06:03.913]                               next
[16:06:03.913]                             invokeRestart(restart)
[16:06:03.913]                             muffled <- TRUE
[16:06:03.913]                             break
[16:06:03.913]                           }
[16:06:03.913]                         }
[16:06:03.913]                       }
[16:06:03.913]                       invisible(muffled)
[16:06:03.913]                     }
[16:06:03.913]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.913]                   }
[16:06:03.913]                 }
[16:06:03.913]                 else {
[16:06:03.913]                   if (TRUE) {
[16:06:03.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:03.913]                     {
[16:06:03.913]                       inherits <- base::inherits
[16:06:03.913]                       invokeRestart <- base::invokeRestart
[16:06:03.913]                       is.null <- base::is.null
[16:06:03.913]                       muffled <- FALSE
[16:06:03.913]                       if (inherits(cond, "message")) {
[16:06:03.913]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:03.913]                         if (muffled) 
[16:06:03.913]                           invokeRestart("muffleMessage")
[16:06:03.913]                       }
[16:06:03.913]                       else if (inherits(cond, "warning")) {
[16:06:03.913]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:03.913]                         if (muffled) 
[16:06:03.913]                           invokeRestart("muffleWarning")
[16:06:03.913]                       }
[16:06:03.913]                       else if (inherits(cond, "condition")) {
[16:06:03.913]                         if (!is.null(pattern)) {
[16:06:03.913]                           computeRestarts <- base::computeRestarts
[16:06:03.913]                           grepl <- base::grepl
[16:06:03.913]                           restarts <- computeRestarts(cond)
[16:06:03.913]                           for (restart in restarts) {
[16:06:03.913]                             name <- restart$name
[16:06:03.913]                             if (is.null(name)) 
[16:06:03.913]                               next
[16:06:03.913]                             if (!grepl(pattern, name)) 
[16:06:03.913]                               next
[16:06:03.913]                             invokeRestart(restart)
[16:06:03.913]                             muffled <- TRUE
[16:06:03.913]                             break
[16:06:03.913]                           }
[16:06:03.913]                         }
[16:06:03.913]                       }
[16:06:03.913]                       invisible(muffled)
[16:06:03.913]                     }
[16:06:03.913]                     muffleCondition(cond, pattern = "^muffle")
[16:06:03.913]                   }
[16:06:03.913]                 }
[16:06:03.913]             }
[16:06:03.913]         }))
[16:06:03.913]     }, error = function(ex) {
[16:06:03.913]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:03.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:03.913]                 ...future.rng), started = ...future.startTime, 
[16:06:03.913]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:03.913]             version = "1.8"), class = "FutureResult")
[16:06:03.913]     }, finally = {
[16:06:03.913]         if (!identical(...future.workdir, getwd())) 
[16:06:03.913]             setwd(...future.workdir)
[16:06:03.913]         {
[16:06:03.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:03.913]                 ...future.oldOptions$nwarnings <- NULL
[16:06:03.913]             }
[16:06:03.913]             base::options(...future.oldOptions)
[16:06:03.913]             if (.Platform$OS.type == "windows") {
[16:06:03.913]                 old_names <- names(...future.oldEnvVars)
[16:06:03.913]                 envs <- base::Sys.getenv()
[16:06:03.913]                 names <- names(envs)
[16:06:03.913]                 common <- intersect(names, old_names)
[16:06:03.913]                 added <- setdiff(names, old_names)
[16:06:03.913]                 removed <- setdiff(old_names, names)
[16:06:03.913]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:03.913]                   envs[common]]
[16:06:03.913]                 NAMES <- toupper(changed)
[16:06:03.913]                 args <- list()
[16:06:03.913]                 for (kk in seq_along(NAMES)) {
[16:06:03.913]                   name <- changed[[kk]]
[16:06:03.913]                   NAME <- NAMES[[kk]]
[16:06:03.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.913]                     next
[16:06:03.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.913]                 }
[16:06:03.913]                 NAMES <- toupper(added)
[16:06:03.913]                 for (kk in seq_along(NAMES)) {
[16:06:03.913]                   name <- added[[kk]]
[16:06:03.913]                   NAME <- NAMES[[kk]]
[16:06:03.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.913]                     next
[16:06:03.913]                   args[[name]] <- ""
[16:06:03.913]                 }
[16:06:03.913]                 NAMES <- toupper(removed)
[16:06:03.913]                 for (kk in seq_along(NAMES)) {
[16:06:03.913]                   name <- removed[[kk]]
[16:06:03.913]                   NAME <- NAMES[[kk]]
[16:06:03.913]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:03.913]                     next
[16:06:03.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:03.913]                 }
[16:06:03.913]                 if (length(args) > 0) 
[16:06:03.913]                   base::do.call(base::Sys.setenv, args = args)
[16:06:03.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:03.913]             }
[16:06:03.913]             else {
[16:06:03.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:03.913]             }
[16:06:03.913]             {
[16:06:03.913]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:03.913]                   0L) {
[16:06:03.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:03.913]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:03.913]                   base::options(opts)
[16:06:03.913]                 }
[16:06:03.913]                 {
[16:06:03.913]                   {
[16:06:03.913]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:03.913]                     NULL
[16:06:03.913]                   }
[16:06:03.913]                   options(future.plan = NULL)
[16:06:03.913]                   if (is.na(NA_character_)) 
[16:06:03.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:03.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:03.913]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:03.913]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:03.913]                     envir = parent.frame()) 
[16:06:03.913]                   {
[16:06:03.913]                     if (is.function(workers)) 
[16:06:03.913]                       workers <- workers()
[16:06:03.913]                     workers <- structure(as.integer(workers), 
[16:06:03.913]                       class = class(workers))
[16:06:03.913]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:03.913]                       workers >= 1)
[16:06:03.913]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:03.913]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:03.913]                     }
[16:06:03.913]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:03.913]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:03.913]                       envir = envir)
[16:06:03.913]                     if (!future$lazy) 
[16:06:03.913]                       future <- run(future)
[16:06:03.913]                     invisible(future)
[16:06:03.913]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:03.913]                 }
[16:06:03.913]             }
[16:06:03.913]         }
[16:06:03.913]     })
[16:06:03.913]     if (TRUE) {
[16:06:03.913]         base::sink(type = "output", split = FALSE)
[16:06:03.913]         if (TRUE) {
[16:06:03.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:03.913]         }
[16:06:03.913]         else {
[16:06:03.913]             ...future.result["stdout"] <- base::list(NULL)
[16:06:03.913]         }
[16:06:03.913]         base::close(...future.stdout)
[16:06:03.913]         ...future.stdout <- NULL
[16:06:03.913]     }
[16:06:03.913]     ...future.result$conditions <- ...future.conditions
[16:06:03.913]     ...future.result$finished <- base::Sys.time()
[16:06:03.913]     ...future.result
[16:06:03.913] }
[16:06:03.916] MultisessionFuture started
[16:06:03.916] - Launch lazy future ... done
[16:06:03.916] run() for ‘MultisessionFuture’ ... done
[16:06:04.473] receiveMessageFromWorker() for ClusterFuture ...
[16:06:04.473] - Validating connection of MultisessionFuture
[16:06:04.474] - received message: FutureResult
[16:06:04.474] - Received FutureResult
[16:06:04.474] - Erased future from FutureRegistry
[16:06:04.474] result() for ClusterFuture ...
[16:06:04.474] - result already collected: FutureResult
[16:06:04.474] result() for ClusterFuture ... done
[16:06:04.474] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:04.474] A MultisessionFuture was resolved (result was not collected)
[16:06:04.475] getGlobalsAndPackages() ...
[16:06:04.475] Searching for globals...
[16:06:04.476] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:04.476] Searching for globals ... DONE
[16:06:04.476] Resolving globals: FALSE
[16:06:04.476] 
[16:06:04.476] 
[16:06:04.477] getGlobalsAndPackages() ... DONE
[16:06:04.477] run() for ‘Future’ ...
[16:06:04.477] - state: ‘created’
[16:06:04.477] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:04.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:04.491] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:04.491]   - Field: ‘node’
[16:06:04.491]   - Field: ‘label’
[16:06:04.491]   - Field: ‘local’
[16:06:04.491]   - Field: ‘owner’
[16:06:04.491]   - Field: ‘envir’
[16:06:04.491]   - Field: ‘workers’
[16:06:04.491]   - Field: ‘packages’
[16:06:04.491]   - Field: ‘gc’
[16:06:04.492]   - Field: ‘conditions’
[16:06:04.492]   - Field: ‘persistent’
[16:06:04.492]   - Field: ‘expr’
[16:06:04.492]   - Field: ‘uuid’
[16:06:04.492]   - Field: ‘seed’
[16:06:04.492]   - Field: ‘version’
[16:06:04.492]   - Field: ‘result’
[16:06:04.492]   - Field: ‘asynchronous’
[16:06:04.492]   - Field: ‘calls’
[16:06:04.492]   - Field: ‘globals’
[16:06:04.492]   - Field: ‘stdout’
[16:06:04.492]   - Field: ‘earlySignal’
[16:06:04.493]   - Field: ‘lazy’
[16:06:04.493]   - Field: ‘state’
[16:06:04.493] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:04.493] - Launch lazy future ...
[16:06:04.493] Packages needed by the future expression (n = 0): <none>
[16:06:04.493] Packages needed by future strategies (n = 0): <none>
[16:06:04.494] {
[16:06:04.494]     {
[16:06:04.494]         {
[16:06:04.494]             ...future.startTime <- base::Sys.time()
[16:06:04.494]             {
[16:06:04.494]                 {
[16:06:04.494]                   {
[16:06:04.494]                     {
[16:06:04.494]                       base::local({
[16:06:04.494]                         has_future <- base::requireNamespace("future", 
[16:06:04.494]                           quietly = TRUE)
[16:06:04.494]                         if (has_future) {
[16:06:04.494]                           ns <- base::getNamespace("future")
[16:06:04.494]                           version <- ns[[".package"]][["version"]]
[16:06:04.494]                           if (is.null(version)) 
[16:06:04.494]                             version <- utils::packageVersion("future")
[16:06:04.494]                         }
[16:06:04.494]                         else {
[16:06:04.494]                           version <- NULL
[16:06:04.494]                         }
[16:06:04.494]                         if (!has_future || version < "1.8.0") {
[16:06:04.494]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:04.494]                             "", base::R.version$version.string), 
[16:06:04.494]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:04.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:04.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:04.494]                               "release", "version")], collapse = " "), 
[16:06:04.494]                             hostname = base::Sys.info()[["nodename"]])
[16:06:04.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:04.494]                             info)
[16:06:04.494]                           info <- base::paste(info, collapse = "; ")
[16:06:04.494]                           if (!has_future) {
[16:06:04.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:04.494]                               info)
[16:06:04.494]                           }
[16:06:04.494]                           else {
[16:06:04.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:04.494]                               info, version)
[16:06:04.494]                           }
[16:06:04.494]                           base::stop(msg)
[16:06:04.494]                         }
[16:06:04.494]                       })
[16:06:04.494]                     }
[16:06:04.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:04.494]                     base::options(mc.cores = 1L)
[16:06:04.494]                   }
[16:06:04.494]                   options(future.plan = NULL)
[16:06:04.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:04.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:04.494]                 }
[16:06:04.494]                 ...future.workdir <- getwd()
[16:06:04.494]             }
[16:06:04.494]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:04.494]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:04.494]         }
[16:06:04.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:04.494]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:04.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:04.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:04.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:04.494]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:04.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:04.494]             base::names(...future.oldOptions))
[16:06:04.494]     }
[16:06:04.494]     if (FALSE) {
[16:06:04.494]     }
[16:06:04.494]     else {
[16:06:04.494]         if (TRUE) {
[16:06:04.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:04.494]                 open = "w")
[16:06:04.494]         }
[16:06:04.494]         else {
[16:06:04.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:04.494]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:04.494]         }
[16:06:04.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:04.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:04.494]             base::sink(type = "output", split = FALSE)
[16:06:04.494]             base::close(...future.stdout)
[16:06:04.494]         }, add = TRUE)
[16:06:04.494]     }
[16:06:04.494]     ...future.frame <- base::sys.nframe()
[16:06:04.494]     ...future.conditions <- base::list()
[16:06:04.494]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:04.494]     if (FALSE) {
[16:06:04.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:04.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:04.494]     }
[16:06:04.494]     ...future.result <- base::tryCatch({
[16:06:04.494]         base::withCallingHandlers({
[16:06:04.494]             ...future.value <- base::withVisible(base::local({
[16:06:04.494]                 ...future.makeSendCondition <- base::local({
[16:06:04.494]                   sendCondition <- NULL
[16:06:04.494]                   function(frame = 1L) {
[16:06:04.494]                     if (is.function(sendCondition)) 
[16:06:04.494]                       return(sendCondition)
[16:06:04.494]                     ns <- getNamespace("parallel")
[16:06:04.494]                     if (exists("sendData", mode = "function", 
[16:06:04.494]                       envir = ns)) {
[16:06:04.494]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:04.494]                         envir = ns)
[16:06:04.494]                       envir <- sys.frame(frame)
[16:06:04.494]                       master <- NULL
[16:06:04.494]                       while (!identical(envir, .GlobalEnv) && 
[16:06:04.494]                         !identical(envir, emptyenv())) {
[16:06:04.494]                         if (exists("master", mode = "list", envir = envir, 
[16:06:04.494]                           inherits = FALSE)) {
[16:06:04.494]                           master <- get("master", mode = "list", 
[16:06:04.494]                             envir = envir, inherits = FALSE)
[16:06:04.494]                           if (inherits(master, c("SOCKnode", 
[16:06:04.494]                             "SOCK0node"))) {
[16:06:04.494]                             sendCondition <<- function(cond) {
[16:06:04.494]                               data <- list(type = "VALUE", value = cond, 
[16:06:04.494]                                 success = TRUE)
[16:06:04.494]                               parallel_sendData(master, data)
[16:06:04.494]                             }
[16:06:04.494]                             return(sendCondition)
[16:06:04.494]                           }
[16:06:04.494]                         }
[16:06:04.494]                         frame <- frame + 1L
[16:06:04.494]                         envir <- sys.frame(frame)
[16:06:04.494]                       }
[16:06:04.494]                     }
[16:06:04.494]                     sendCondition <<- function(cond) NULL
[16:06:04.494]                   }
[16:06:04.494]                 })
[16:06:04.494]                 withCallingHandlers({
[16:06:04.494]                   {
[16:06:04.494]                     Sys.sleep(0.5)
[16:06:04.494]                     list(a = 1, b = 42L)
[16:06:04.494]                   }
[16:06:04.494]                 }, immediateCondition = function(cond) {
[16:06:04.494]                   sendCondition <- ...future.makeSendCondition()
[16:06:04.494]                   sendCondition(cond)
[16:06:04.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:04.494]                   {
[16:06:04.494]                     inherits <- base::inherits
[16:06:04.494]                     invokeRestart <- base::invokeRestart
[16:06:04.494]                     is.null <- base::is.null
[16:06:04.494]                     muffled <- FALSE
[16:06:04.494]                     if (inherits(cond, "message")) {
[16:06:04.494]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:04.494]                       if (muffled) 
[16:06:04.494]                         invokeRestart("muffleMessage")
[16:06:04.494]                     }
[16:06:04.494]                     else if (inherits(cond, "warning")) {
[16:06:04.494]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:04.494]                       if (muffled) 
[16:06:04.494]                         invokeRestart("muffleWarning")
[16:06:04.494]                     }
[16:06:04.494]                     else if (inherits(cond, "condition")) {
[16:06:04.494]                       if (!is.null(pattern)) {
[16:06:04.494]                         computeRestarts <- base::computeRestarts
[16:06:04.494]                         grepl <- base::grepl
[16:06:04.494]                         restarts <- computeRestarts(cond)
[16:06:04.494]                         for (restart in restarts) {
[16:06:04.494]                           name <- restart$name
[16:06:04.494]                           if (is.null(name)) 
[16:06:04.494]                             next
[16:06:04.494]                           if (!grepl(pattern, name)) 
[16:06:04.494]                             next
[16:06:04.494]                           invokeRestart(restart)
[16:06:04.494]                           muffled <- TRUE
[16:06:04.494]                           break
[16:06:04.494]                         }
[16:06:04.494]                       }
[16:06:04.494]                     }
[16:06:04.494]                     invisible(muffled)
[16:06:04.494]                   }
[16:06:04.494]                   muffleCondition(cond)
[16:06:04.494]                 })
[16:06:04.494]             }))
[16:06:04.494]             future::FutureResult(value = ...future.value$value, 
[16:06:04.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:04.494]                   ...future.rng), globalenv = if (FALSE) 
[16:06:04.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:04.494]                     ...future.globalenv.names))
[16:06:04.494]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:04.494]         }, condition = base::local({
[16:06:04.494]             c <- base::c
[16:06:04.494]             inherits <- base::inherits
[16:06:04.494]             invokeRestart <- base::invokeRestart
[16:06:04.494]             length <- base::length
[16:06:04.494]             list <- base::list
[16:06:04.494]             seq.int <- base::seq.int
[16:06:04.494]             signalCondition <- base::signalCondition
[16:06:04.494]             sys.calls <- base::sys.calls
[16:06:04.494]             `[[` <- base::`[[`
[16:06:04.494]             `+` <- base::`+`
[16:06:04.494]             `<<-` <- base::`<<-`
[16:06:04.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:04.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:04.494]                   3L)]
[16:06:04.494]             }
[16:06:04.494]             function(cond) {
[16:06:04.494]                 is_error <- inherits(cond, "error")
[16:06:04.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:04.494]                   NULL)
[16:06:04.494]                 if (is_error) {
[16:06:04.494]                   sessionInformation <- function() {
[16:06:04.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:04.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:04.494]                       search = base::search(), system = base::Sys.info())
[16:06:04.494]                   }
[16:06:04.494]                   ...future.conditions[[length(...future.conditions) + 
[16:06:04.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:04.494]                     cond$call), session = sessionInformation(), 
[16:06:04.494]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:04.494]                   signalCondition(cond)
[16:06:04.494]                 }
[16:06:04.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:04.494]                 "immediateCondition"))) {
[16:06:04.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:04.494]                   ...future.conditions[[length(...future.conditions) + 
[16:06:04.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:04.494]                   if (TRUE && !signal) {
[16:06:04.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:04.494]                     {
[16:06:04.494]                       inherits <- base::inherits
[16:06:04.494]                       invokeRestart <- base::invokeRestart
[16:06:04.494]                       is.null <- base::is.null
[16:06:04.494]                       muffled <- FALSE
[16:06:04.494]                       if (inherits(cond, "message")) {
[16:06:04.494]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:04.494]                         if (muffled) 
[16:06:04.494]                           invokeRestart("muffleMessage")
[16:06:04.494]                       }
[16:06:04.494]                       else if (inherits(cond, "warning")) {
[16:06:04.494]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:04.494]                         if (muffled) 
[16:06:04.494]                           invokeRestart("muffleWarning")
[16:06:04.494]                       }
[16:06:04.494]                       else if (inherits(cond, "condition")) {
[16:06:04.494]                         if (!is.null(pattern)) {
[16:06:04.494]                           computeRestarts <- base::computeRestarts
[16:06:04.494]                           grepl <- base::grepl
[16:06:04.494]                           restarts <- computeRestarts(cond)
[16:06:04.494]                           for (restart in restarts) {
[16:06:04.494]                             name <- restart$name
[16:06:04.494]                             if (is.null(name)) 
[16:06:04.494]                               next
[16:06:04.494]                             if (!grepl(pattern, name)) 
[16:06:04.494]                               next
[16:06:04.494]                             invokeRestart(restart)
[16:06:04.494]                             muffled <- TRUE
[16:06:04.494]                             break
[16:06:04.494]                           }
[16:06:04.494]                         }
[16:06:04.494]                       }
[16:06:04.494]                       invisible(muffled)
[16:06:04.494]                     }
[16:06:04.494]                     muffleCondition(cond, pattern = "^muffle")
[16:06:04.494]                   }
[16:06:04.494]                 }
[16:06:04.494]                 else {
[16:06:04.494]                   if (TRUE) {
[16:06:04.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:04.494]                     {
[16:06:04.494]                       inherits <- base::inherits
[16:06:04.494]                       invokeRestart <- base::invokeRestart
[16:06:04.494]                       is.null <- base::is.null
[16:06:04.494]                       muffled <- FALSE
[16:06:04.494]                       if (inherits(cond, "message")) {
[16:06:04.494]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:04.494]                         if (muffled) 
[16:06:04.494]                           invokeRestart("muffleMessage")
[16:06:04.494]                       }
[16:06:04.494]                       else if (inherits(cond, "warning")) {
[16:06:04.494]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:04.494]                         if (muffled) 
[16:06:04.494]                           invokeRestart("muffleWarning")
[16:06:04.494]                       }
[16:06:04.494]                       else if (inherits(cond, "condition")) {
[16:06:04.494]                         if (!is.null(pattern)) {
[16:06:04.494]                           computeRestarts <- base::computeRestarts
[16:06:04.494]                           grepl <- base::grepl
[16:06:04.494]                           restarts <- computeRestarts(cond)
[16:06:04.494]                           for (restart in restarts) {
[16:06:04.494]                             name <- restart$name
[16:06:04.494]                             if (is.null(name)) 
[16:06:04.494]                               next
[16:06:04.494]                             if (!grepl(pattern, name)) 
[16:06:04.494]                               next
[16:06:04.494]                             invokeRestart(restart)
[16:06:04.494]                             muffled <- TRUE
[16:06:04.494]                             break
[16:06:04.494]                           }
[16:06:04.494]                         }
[16:06:04.494]                       }
[16:06:04.494]                       invisible(muffled)
[16:06:04.494]                     }
[16:06:04.494]                     muffleCondition(cond, pattern = "^muffle")
[16:06:04.494]                   }
[16:06:04.494]                 }
[16:06:04.494]             }
[16:06:04.494]         }))
[16:06:04.494]     }, error = function(ex) {
[16:06:04.494]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:04.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:04.494]                 ...future.rng), started = ...future.startTime, 
[16:06:04.494]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:04.494]             version = "1.8"), class = "FutureResult")
[16:06:04.494]     }, finally = {
[16:06:04.494]         if (!identical(...future.workdir, getwd())) 
[16:06:04.494]             setwd(...future.workdir)
[16:06:04.494]         {
[16:06:04.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:04.494]                 ...future.oldOptions$nwarnings <- NULL
[16:06:04.494]             }
[16:06:04.494]             base::options(...future.oldOptions)
[16:06:04.494]             if (.Platform$OS.type == "windows") {
[16:06:04.494]                 old_names <- names(...future.oldEnvVars)
[16:06:04.494]                 envs <- base::Sys.getenv()
[16:06:04.494]                 names <- names(envs)
[16:06:04.494]                 common <- intersect(names, old_names)
[16:06:04.494]                 added <- setdiff(names, old_names)
[16:06:04.494]                 removed <- setdiff(old_names, names)
[16:06:04.494]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:04.494]                   envs[common]]
[16:06:04.494]                 NAMES <- toupper(changed)
[16:06:04.494]                 args <- list()
[16:06:04.494]                 for (kk in seq_along(NAMES)) {
[16:06:04.494]                   name <- changed[[kk]]
[16:06:04.494]                   NAME <- NAMES[[kk]]
[16:06:04.494]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:04.494]                     next
[16:06:04.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:04.494]                 }
[16:06:04.494]                 NAMES <- toupper(added)
[16:06:04.494]                 for (kk in seq_along(NAMES)) {
[16:06:04.494]                   name <- added[[kk]]
[16:06:04.494]                   NAME <- NAMES[[kk]]
[16:06:04.494]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:04.494]                     next
[16:06:04.494]                   args[[name]] <- ""
[16:06:04.494]                 }
[16:06:04.494]                 NAMES <- toupper(removed)
[16:06:04.494]                 for (kk in seq_along(NAMES)) {
[16:06:04.494]                   name <- removed[[kk]]
[16:06:04.494]                   NAME <- NAMES[[kk]]
[16:06:04.494]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:04.494]                     next
[16:06:04.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:04.494]                 }
[16:06:04.494]                 if (length(args) > 0) 
[16:06:04.494]                   base::do.call(base::Sys.setenv, args = args)
[16:06:04.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:04.494]             }
[16:06:04.494]             else {
[16:06:04.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:04.494]             }
[16:06:04.494]             {
[16:06:04.494]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:04.494]                   0L) {
[16:06:04.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:04.494]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:04.494]                   base::options(opts)
[16:06:04.494]                 }
[16:06:04.494]                 {
[16:06:04.494]                   {
[16:06:04.494]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:04.494]                     NULL
[16:06:04.494]                   }
[16:06:04.494]                   options(future.plan = NULL)
[16:06:04.494]                   if (is.na(NA_character_)) 
[16:06:04.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:04.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:04.494]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:04.494]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:04.494]                     envir = parent.frame()) 
[16:06:04.494]                   {
[16:06:04.494]                     if (is.function(workers)) 
[16:06:04.494]                       workers <- workers()
[16:06:04.494]                     workers <- structure(as.integer(workers), 
[16:06:04.494]                       class = class(workers))
[16:06:04.494]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:04.494]                       workers >= 1)
[16:06:04.494]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:04.494]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:04.494]                     }
[16:06:04.494]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:04.494]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:04.494]                       envir = envir)
[16:06:04.494]                     if (!future$lazy) 
[16:06:04.494]                       future <- run(future)
[16:06:04.494]                     invisible(future)
[16:06:04.494]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:04.494]                 }
[16:06:04.494]             }
[16:06:04.494]         }
[16:06:04.494]     })
[16:06:04.494]     if (TRUE) {
[16:06:04.494]         base::sink(type = "output", split = FALSE)
[16:06:04.494]         if (TRUE) {
[16:06:04.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:04.494]         }
[16:06:04.494]         else {
[16:06:04.494]             ...future.result["stdout"] <- base::list(NULL)
[16:06:04.494]         }
[16:06:04.494]         base::close(...future.stdout)
[16:06:04.494]         ...future.stdout <- NULL
[16:06:04.494]     }
[16:06:04.494]     ...future.result$conditions <- ...future.conditions
[16:06:04.494]     ...future.result$finished <- base::Sys.time()
[16:06:04.494]     ...future.result
[16:06:04.494] }
[16:06:04.497] MultisessionFuture started
[16:06:04.497] - Launch lazy future ... done
[16:06:04.497] run() for ‘MultisessionFuture’ ... done
[16:06:05.054] receiveMessageFromWorker() for ClusterFuture ...
[16:06:05.054] - Validating connection of MultisessionFuture
[16:06:05.054] - received message: FutureResult
[16:06:05.054] - Received FutureResult
[16:06:05.055] - Erased future from FutureRegistry
[16:06:05.055] result() for ClusterFuture ...
[16:06:05.055] - result already collected: FutureResult
[16:06:05.055] result() for ClusterFuture ... done
[16:06:05.055] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:05.055] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:06:05.055] getGlobalsAndPackages() ...
[16:06:05.055] Searching for globals...
[16:06:05.056] - globals found: [2] ‘list’, ‘stop’
[16:06:05.056] Searching for globals ... DONE
[16:06:05.056] Resolving globals: FALSE
[16:06:05.057] 
[16:06:05.057] 
[16:06:05.057] getGlobalsAndPackages() ... DONE
[16:06:05.057] run() for ‘Future’ ...
[16:06:05.057] - state: ‘created’
[16:06:05.057] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:05.071] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:05.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:05.071]   - Field: ‘node’
[16:06:05.071]   - Field: ‘label’
[16:06:05.071]   - Field: ‘local’
[16:06:05.071]   - Field: ‘owner’
[16:06:05.072]   - Field: ‘envir’
[16:06:05.072]   - Field: ‘workers’
[16:06:05.072]   - Field: ‘packages’
[16:06:05.072]   - Field: ‘gc’
[16:06:05.072]   - Field: ‘conditions’
[16:06:05.072]   - Field: ‘persistent’
[16:06:05.072]   - Field: ‘expr’
[16:06:05.072]   - Field: ‘uuid’
[16:06:05.072]   - Field: ‘seed’
[16:06:05.072]   - Field: ‘version’
[16:06:05.072]   - Field: ‘result’
[16:06:05.073]   - Field: ‘asynchronous’
[16:06:05.073]   - Field: ‘calls’
[16:06:05.073]   - Field: ‘globals’
[16:06:05.073]   - Field: ‘stdout’
[16:06:05.073]   - Field: ‘earlySignal’
[16:06:05.073]   - Field: ‘lazy’
[16:06:05.073]   - Field: ‘state’
[16:06:05.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:05.073] - Launch lazy future ...
[16:06:05.074] Packages needed by the future expression (n = 0): <none>
[16:06:05.074] Packages needed by future strategies (n = 0): <none>
[16:06:05.074] {
[16:06:05.074]     {
[16:06:05.074]         {
[16:06:05.074]             ...future.startTime <- base::Sys.time()
[16:06:05.074]             {
[16:06:05.074]                 {
[16:06:05.074]                   {
[16:06:05.074]                     {
[16:06:05.074]                       base::local({
[16:06:05.074]                         has_future <- base::requireNamespace("future", 
[16:06:05.074]                           quietly = TRUE)
[16:06:05.074]                         if (has_future) {
[16:06:05.074]                           ns <- base::getNamespace("future")
[16:06:05.074]                           version <- ns[[".package"]][["version"]]
[16:06:05.074]                           if (is.null(version)) 
[16:06:05.074]                             version <- utils::packageVersion("future")
[16:06:05.074]                         }
[16:06:05.074]                         else {
[16:06:05.074]                           version <- NULL
[16:06:05.074]                         }
[16:06:05.074]                         if (!has_future || version < "1.8.0") {
[16:06:05.074]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:05.074]                             "", base::R.version$version.string), 
[16:06:05.074]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:05.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:05.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:05.074]                               "release", "version")], collapse = " "), 
[16:06:05.074]                             hostname = base::Sys.info()[["nodename"]])
[16:06:05.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:05.074]                             info)
[16:06:05.074]                           info <- base::paste(info, collapse = "; ")
[16:06:05.074]                           if (!has_future) {
[16:06:05.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:05.074]                               info)
[16:06:05.074]                           }
[16:06:05.074]                           else {
[16:06:05.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:05.074]                               info, version)
[16:06:05.074]                           }
[16:06:05.074]                           base::stop(msg)
[16:06:05.074]                         }
[16:06:05.074]                       })
[16:06:05.074]                     }
[16:06:05.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:05.074]                     base::options(mc.cores = 1L)
[16:06:05.074]                   }
[16:06:05.074]                   options(future.plan = NULL)
[16:06:05.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:05.074]                 }
[16:06:05.074]                 ...future.workdir <- getwd()
[16:06:05.074]             }
[16:06:05.074]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:05.074]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:05.074]         }
[16:06:05.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:05.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:05.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:05.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:05.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:05.074]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:05.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:05.074]             base::names(...future.oldOptions))
[16:06:05.074]     }
[16:06:05.074]     if (FALSE) {
[16:06:05.074]     }
[16:06:05.074]     else {
[16:06:05.074]         if (TRUE) {
[16:06:05.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:05.074]                 open = "w")
[16:06:05.074]         }
[16:06:05.074]         else {
[16:06:05.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:05.074]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:05.074]         }
[16:06:05.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:05.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:05.074]             base::sink(type = "output", split = FALSE)
[16:06:05.074]             base::close(...future.stdout)
[16:06:05.074]         }, add = TRUE)
[16:06:05.074]     }
[16:06:05.074]     ...future.frame <- base::sys.nframe()
[16:06:05.074]     ...future.conditions <- base::list()
[16:06:05.074]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:05.074]     if (FALSE) {
[16:06:05.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:05.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:05.074]     }
[16:06:05.074]     ...future.result <- base::tryCatch({
[16:06:05.074]         base::withCallingHandlers({
[16:06:05.074]             ...future.value <- base::withVisible(base::local({
[16:06:05.074]                 ...future.makeSendCondition <- base::local({
[16:06:05.074]                   sendCondition <- NULL
[16:06:05.074]                   function(frame = 1L) {
[16:06:05.074]                     if (is.function(sendCondition)) 
[16:06:05.074]                       return(sendCondition)
[16:06:05.074]                     ns <- getNamespace("parallel")
[16:06:05.074]                     if (exists("sendData", mode = "function", 
[16:06:05.074]                       envir = ns)) {
[16:06:05.074]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:05.074]                         envir = ns)
[16:06:05.074]                       envir <- sys.frame(frame)
[16:06:05.074]                       master <- NULL
[16:06:05.074]                       while (!identical(envir, .GlobalEnv) && 
[16:06:05.074]                         !identical(envir, emptyenv())) {
[16:06:05.074]                         if (exists("master", mode = "list", envir = envir, 
[16:06:05.074]                           inherits = FALSE)) {
[16:06:05.074]                           master <- get("master", mode = "list", 
[16:06:05.074]                             envir = envir, inherits = FALSE)
[16:06:05.074]                           if (inherits(master, c("SOCKnode", 
[16:06:05.074]                             "SOCK0node"))) {
[16:06:05.074]                             sendCondition <<- function(cond) {
[16:06:05.074]                               data <- list(type = "VALUE", value = cond, 
[16:06:05.074]                                 success = TRUE)
[16:06:05.074]                               parallel_sendData(master, data)
[16:06:05.074]                             }
[16:06:05.074]                             return(sendCondition)
[16:06:05.074]                           }
[16:06:05.074]                         }
[16:06:05.074]                         frame <- frame + 1L
[16:06:05.074]                         envir <- sys.frame(frame)
[16:06:05.074]                       }
[16:06:05.074]                     }
[16:06:05.074]                     sendCondition <<- function(cond) NULL
[16:06:05.074]                   }
[16:06:05.074]                 })
[16:06:05.074]                 withCallingHandlers({
[16:06:05.074]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:05.074]                 }, immediateCondition = function(cond) {
[16:06:05.074]                   sendCondition <- ...future.makeSendCondition()
[16:06:05.074]                   sendCondition(cond)
[16:06:05.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.074]                   {
[16:06:05.074]                     inherits <- base::inherits
[16:06:05.074]                     invokeRestart <- base::invokeRestart
[16:06:05.074]                     is.null <- base::is.null
[16:06:05.074]                     muffled <- FALSE
[16:06:05.074]                     if (inherits(cond, "message")) {
[16:06:05.074]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:05.074]                       if (muffled) 
[16:06:05.074]                         invokeRestart("muffleMessage")
[16:06:05.074]                     }
[16:06:05.074]                     else if (inherits(cond, "warning")) {
[16:06:05.074]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:05.074]                       if (muffled) 
[16:06:05.074]                         invokeRestart("muffleWarning")
[16:06:05.074]                     }
[16:06:05.074]                     else if (inherits(cond, "condition")) {
[16:06:05.074]                       if (!is.null(pattern)) {
[16:06:05.074]                         computeRestarts <- base::computeRestarts
[16:06:05.074]                         grepl <- base::grepl
[16:06:05.074]                         restarts <- computeRestarts(cond)
[16:06:05.074]                         for (restart in restarts) {
[16:06:05.074]                           name <- restart$name
[16:06:05.074]                           if (is.null(name)) 
[16:06:05.074]                             next
[16:06:05.074]                           if (!grepl(pattern, name)) 
[16:06:05.074]                             next
[16:06:05.074]                           invokeRestart(restart)
[16:06:05.074]                           muffled <- TRUE
[16:06:05.074]                           break
[16:06:05.074]                         }
[16:06:05.074]                       }
[16:06:05.074]                     }
[16:06:05.074]                     invisible(muffled)
[16:06:05.074]                   }
[16:06:05.074]                   muffleCondition(cond)
[16:06:05.074]                 })
[16:06:05.074]             }))
[16:06:05.074]             future::FutureResult(value = ...future.value$value, 
[16:06:05.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.074]                   ...future.rng), globalenv = if (FALSE) 
[16:06:05.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:05.074]                     ...future.globalenv.names))
[16:06:05.074]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:05.074]         }, condition = base::local({
[16:06:05.074]             c <- base::c
[16:06:05.074]             inherits <- base::inherits
[16:06:05.074]             invokeRestart <- base::invokeRestart
[16:06:05.074]             length <- base::length
[16:06:05.074]             list <- base::list
[16:06:05.074]             seq.int <- base::seq.int
[16:06:05.074]             signalCondition <- base::signalCondition
[16:06:05.074]             sys.calls <- base::sys.calls
[16:06:05.074]             `[[` <- base::`[[`
[16:06:05.074]             `+` <- base::`+`
[16:06:05.074]             `<<-` <- base::`<<-`
[16:06:05.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:05.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:05.074]                   3L)]
[16:06:05.074]             }
[16:06:05.074]             function(cond) {
[16:06:05.074]                 is_error <- inherits(cond, "error")
[16:06:05.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:05.074]                   NULL)
[16:06:05.074]                 if (is_error) {
[16:06:05.074]                   sessionInformation <- function() {
[16:06:05.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:05.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:05.074]                       search = base::search(), system = base::Sys.info())
[16:06:05.074]                   }
[16:06:05.074]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:05.074]                     cond$call), session = sessionInformation(), 
[16:06:05.074]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:05.074]                   signalCondition(cond)
[16:06:05.074]                 }
[16:06:05.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:05.074]                 "immediateCondition"))) {
[16:06:05.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:05.074]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:05.074]                   if (TRUE && !signal) {
[16:06:05.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.074]                     {
[16:06:05.074]                       inherits <- base::inherits
[16:06:05.074]                       invokeRestart <- base::invokeRestart
[16:06:05.074]                       is.null <- base::is.null
[16:06:05.074]                       muffled <- FALSE
[16:06:05.074]                       if (inherits(cond, "message")) {
[16:06:05.074]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.074]                         if (muffled) 
[16:06:05.074]                           invokeRestart("muffleMessage")
[16:06:05.074]                       }
[16:06:05.074]                       else if (inherits(cond, "warning")) {
[16:06:05.074]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.074]                         if (muffled) 
[16:06:05.074]                           invokeRestart("muffleWarning")
[16:06:05.074]                       }
[16:06:05.074]                       else if (inherits(cond, "condition")) {
[16:06:05.074]                         if (!is.null(pattern)) {
[16:06:05.074]                           computeRestarts <- base::computeRestarts
[16:06:05.074]                           grepl <- base::grepl
[16:06:05.074]                           restarts <- computeRestarts(cond)
[16:06:05.074]                           for (restart in restarts) {
[16:06:05.074]                             name <- restart$name
[16:06:05.074]                             if (is.null(name)) 
[16:06:05.074]                               next
[16:06:05.074]                             if (!grepl(pattern, name)) 
[16:06:05.074]                               next
[16:06:05.074]                             invokeRestart(restart)
[16:06:05.074]                             muffled <- TRUE
[16:06:05.074]                             break
[16:06:05.074]                           }
[16:06:05.074]                         }
[16:06:05.074]                       }
[16:06:05.074]                       invisible(muffled)
[16:06:05.074]                     }
[16:06:05.074]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.074]                   }
[16:06:05.074]                 }
[16:06:05.074]                 else {
[16:06:05.074]                   if (TRUE) {
[16:06:05.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.074]                     {
[16:06:05.074]                       inherits <- base::inherits
[16:06:05.074]                       invokeRestart <- base::invokeRestart
[16:06:05.074]                       is.null <- base::is.null
[16:06:05.074]                       muffled <- FALSE
[16:06:05.074]                       if (inherits(cond, "message")) {
[16:06:05.074]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.074]                         if (muffled) 
[16:06:05.074]                           invokeRestart("muffleMessage")
[16:06:05.074]                       }
[16:06:05.074]                       else if (inherits(cond, "warning")) {
[16:06:05.074]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.074]                         if (muffled) 
[16:06:05.074]                           invokeRestart("muffleWarning")
[16:06:05.074]                       }
[16:06:05.074]                       else if (inherits(cond, "condition")) {
[16:06:05.074]                         if (!is.null(pattern)) {
[16:06:05.074]                           computeRestarts <- base::computeRestarts
[16:06:05.074]                           grepl <- base::grepl
[16:06:05.074]                           restarts <- computeRestarts(cond)
[16:06:05.074]                           for (restart in restarts) {
[16:06:05.074]                             name <- restart$name
[16:06:05.074]                             if (is.null(name)) 
[16:06:05.074]                               next
[16:06:05.074]                             if (!grepl(pattern, name)) 
[16:06:05.074]                               next
[16:06:05.074]                             invokeRestart(restart)
[16:06:05.074]                             muffled <- TRUE
[16:06:05.074]                             break
[16:06:05.074]                           }
[16:06:05.074]                         }
[16:06:05.074]                       }
[16:06:05.074]                       invisible(muffled)
[16:06:05.074]                     }
[16:06:05.074]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.074]                   }
[16:06:05.074]                 }
[16:06:05.074]             }
[16:06:05.074]         }))
[16:06:05.074]     }, error = function(ex) {
[16:06:05.074]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:05.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.074]                 ...future.rng), started = ...future.startTime, 
[16:06:05.074]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:05.074]             version = "1.8"), class = "FutureResult")
[16:06:05.074]     }, finally = {
[16:06:05.074]         if (!identical(...future.workdir, getwd())) 
[16:06:05.074]             setwd(...future.workdir)
[16:06:05.074]         {
[16:06:05.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:05.074]                 ...future.oldOptions$nwarnings <- NULL
[16:06:05.074]             }
[16:06:05.074]             base::options(...future.oldOptions)
[16:06:05.074]             if (.Platform$OS.type == "windows") {
[16:06:05.074]                 old_names <- names(...future.oldEnvVars)
[16:06:05.074]                 envs <- base::Sys.getenv()
[16:06:05.074]                 names <- names(envs)
[16:06:05.074]                 common <- intersect(names, old_names)
[16:06:05.074]                 added <- setdiff(names, old_names)
[16:06:05.074]                 removed <- setdiff(old_names, names)
[16:06:05.074]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:05.074]                   envs[common]]
[16:06:05.074]                 NAMES <- toupper(changed)
[16:06:05.074]                 args <- list()
[16:06:05.074]                 for (kk in seq_along(NAMES)) {
[16:06:05.074]                   name <- changed[[kk]]
[16:06:05.074]                   NAME <- NAMES[[kk]]
[16:06:05.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.074]                     next
[16:06:05.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.074]                 }
[16:06:05.074]                 NAMES <- toupper(added)
[16:06:05.074]                 for (kk in seq_along(NAMES)) {
[16:06:05.074]                   name <- added[[kk]]
[16:06:05.074]                   NAME <- NAMES[[kk]]
[16:06:05.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.074]                     next
[16:06:05.074]                   args[[name]] <- ""
[16:06:05.074]                 }
[16:06:05.074]                 NAMES <- toupper(removed)
[16:06:05.074]                 for (kk in seq_along(NAMES)) {
[16:06:05.074]                   name <- removed[[kk]]
[16:06:05.074]                   NAME <- NAMES[[kk]]
[16:06:05.074]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.074]                     next
[16:06:05.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.074]                 }
[16:06:05.074]                 if (length(args) > 0) 
[16:06:05.074]                   base::do.call(base::Sys.setenv, args = args)
[16:06:05.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:05.074]             }
[16:06:05.074]             else {
[16:06:05.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:05.074]             }
[16:06:05.074]             {
[16:06:05.074]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:05.074]                   0L) {
[16:06:05.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:05.074]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:05.074]                   base::options(opts)
[16:06:05.074]                 }
[16:06:05.074]                 {
[16:06:05.074]                   {
[16:06:05.074]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:05.074]                     NULL
[16:06:05.074]                   }
[16:06:05.074]                   options(future.plan = NULL)
[16:06:05.074]                   if (is.na(NA_character_)) 
[16:06:05.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:05.074]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:05.074]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:05.074]                     envir = parent.frame()) 
[16:06:05.074]                   {
[16:06:05.074]                     if (is.function(workers)) 
[16:06:05.074]                       workers <- workers()
[16:06:05.074]                     workers <- structure(as.integer(workers), 
[16:06:05.074]                       class = class(workers))
[16:06:05.074]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:05.074]                       workers >= 1)
[16:06:05.074]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:05.074]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:05.074]                     }
[16:06:05.074]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:05.074]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:05.074]                       envir = envir)
[16:06:05.074]                     if (!future$lazy) 
[16:06:05.074]                       future <- run(future)
[16:06:05.074]                     invisible(future)
[16:06:05.074]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:05.074]                 }
[16:06:05.074]             }
[16:06:05.074]         }
[16:06:05.074]     })
[16:06:05.074]     if (TRUE) {
[16:06:05.074]         base::sink(type = "output", split = FALSE)
[16:06:05.074]         if (TRUE) {
[16:06:05.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:05.074]         }
[16:06:05.074]         else {
[16:06:05.074]             ...future.result["stdout"] <- base::list(NULL)
[16:06:05.074]         }
[16:06:05.074]         base::close(...future.stdout)
[16:06:05.074]         ...future.stdout <- NULL
[16:06:05.074]     }
[16:06:05.074]     ...future.result$conditions <- ...future.conditions
[16:06:05.074]     ...future.result$finished <- base::Sys.time()
[16:06:05.074]     ...future.result
[16:06:05.074] }
[16:06:05.077] MultisessionFuture started
[16:06:05.077] - Launch lazy future ... done
[16:06:05.077] run() for ‘MultisessionFuture’ ... done
[16:06:05.124] receiveMessageFromWorker() for ClusterFuture ...
[16:06:05.124] - Validating connection of MultisessionFuture
[16:06:05.124] - received message: FutureResult
[16:06:05.124] - Received FutureResult
[16:06:05.125] - Erased future from FutureRegistry
[16:06:05.125] result() for ClusterFuture ...
[16:06:05.125] - result already collected: FutureResult
[16:06:05.125] result() for ClusterFuture ... done
[16:06:05.125] signalConditions() ...
[16:06:05.125]  - include = ‘immediateCondition’
[16:06:05.125]  - exclude = 
[16:06:05.125]  - resignal = FALSE
[16:06:05.125]  - Number of conditions: 1
[16:06:05.125] signalConditions() ... done
[16:06:05.125] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:05.126] A MultisessionFuture was resolved (result was not collected)
[16:06:05.126] getGlobalsAndPackages() ...
[16:06:05.126] Searching for globals...
[16:06:05.126] - globals found: [2] ‘list’, ‘stop’
[16:06:05.126] Searching for globals ... DONE
[16:06:05.127] Resolving globals: FALSE
[16:06:05.127] 
[16:06:05.127] 
[16:06:05.127] getGlobalsAndPackages() ... DONE
[16:06:05.127] run() for ‘Future’ ...
[16:06:05.127] - state: ‘created’
[16:06:05.128] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:05.141] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:05.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:05.141]   - Field: ‘node’
[16:06:05.141]   - Field: ‘label’
[16:06:05.141]   - Field: ‘local’
[16:06:05.142]   - Field: ‘owner’
[16:06:05.142]   - Field: ‘envir’
[16:06:05.142]   - Field: ‘workers’
[16:06:05.142]   - Field: ‘packages’
[16:06:05.142]   - Field: ‘gc’
[16:06:05.142]   - Field: ‘conditions’
[16:06:05.142]   - Field: ‘persistent’
[16:06:05.142]   - Field: ‘expr’
[16:06:05.142]   - Field: ‘uuid’
[16:06:05.142]   - Field: ‘seed’
[16:06:05.142]   - Field: ‘version’
[16:06:05.143]   - Field: ‘result’
[16:06:05.143]   - Field: ‘asynchronous’
[16:06:05.143]   - Field: ‘calls’
[16:06:05.143]   - Field: ‘globals’
[16:06:05.143]   - Field: ‘stdout’
[16:06:05.143]   - Field: ‘earlySignal’
[16:06:05.143]   - Field: ‘lazy’
[16:06:05.143]   - Field: ‘state’
[16:06:05.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:05.143] - Launch lazy future ...
[16:06:05.144] Packages needed by the future expression (n = 0): <none>
[16:06:05.144] Packages needed by future strategies (n = 0): <none>
[16:06:05.144] {
[16:06:05.144]     {
[16:06:05.144]         {
[16:06:05.144]             ...future.startTime <- base::Sys.time()
[16:06:05.144]             {
[16:06:05.144]                 {
[16:06:05.144]                   {
[16:06:05.144]                     {
[16:06:05.144]                       base::local({
[16:06:05.144]                         has_future <- base::requireNamespace("future", 
[16:06:05.144]                           quietly = TRUE)
[16:06:05.144]                         if (has_future) {
[16:06:05.144]                           ns <- base::getNamespace("future")
[16:06:05.144]                           version <- ns[[".package"]][["version"]]
[16:06:05.144]                           if (is.null(version)) 
[16:06:05.144]                             version <- utils::packageVersion("future")
[16:06:05.144]                         }
[16:06:05.144]                         else {
[16:06:05.144]                           version <- NULL
[16:06:05.144]                         }
[16:06:05.144]                         if (!has_future || version < "1.8.0") {
[16:06:05.144]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:05.144]                             "", base::R.version$version.string), 
[16:06:05.144]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:05.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:05.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:05.144]                               "release", "version")], collapse = " "), 
[16:06:05.144]                             hostname = base::Sys.info()[["nodename"]])
[16:06:05.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:05.144]                             info)
[16:06:05.144]                           info <- base::paste(info, collapse = "; ")
[16:06:05.144]                           if (!has_future) {
[16:06:05.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:05.144]                               info)
[16:06:05.144]                           }
[16:06:05.144]                           else {
[16:06:05.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:05.144]                               info, version)
[16:06:05.144]                           }
[16:06:05.144]                           base::stop(msg)
[16:06:05.144]                         }
[16:06:05.144]                       })
[16:06:05.144]                     }
[16:06:05.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:05.144]                     base::options(mc.cores = 1L)
[16:06:05.144]                   }
[16:06:05.144]                   options(future.plan = NULL)
[16:06:05.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:05.144]                 }
[16:06:05.144]                 ...future.workdir <- getwd()
[16:06:05.144]             }
[16:06:05.144]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:05.144]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:05.144]         }
[16:06:05.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:05.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:05.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:05.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:05.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:05.144]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:05.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:05.144]             base::names(...future.oldOptions))
[16:06:05.144]     }
[16:06:05.144]     if (FALSE) {
[16:06:05.144]     }
[16:06:05.144]     else {
[16:06:05.144]         if (TRUE) {
[16:06:05.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:05.144]                 open = "w")
[16:06:05.144]         }
[16:06:05.144]         else {
[16:06:05.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:05.144]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:05.144]         }
[16:06:05.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:05.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:05.144]             base::sink(type = "output", split = FALSE)
[16:06:05.144]             base::close(...future.stdout)
[16:06:05.144]         }, add = TRUE)
[16:06:05.144]     }
[16:06:05.144]     ...future.frame <- base::sys.nframe()
[16:06:05.144]     ...future.conditions <- base::list()
[16:06:05.144]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:05.144]     if (FALSE) {
[16:06:05.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:05.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:05.144]     }
[16:06:05.144]     ...future.result <- base::tryCatch({
[16:06:05.144]         base::withCallingHandlers({
[16:06:05.144]             ...future.value <- base::withVisible(base::local({
[16:06:05.144]                 ...future.makeSendCondition <- base::local({
[16:06:05.144]                   sendCondition <- NULL
[16:06:05.144]                   function(frame = 1L) {
[16:06:05.144]                     if (is.function(sendCondition)) 
[16:06:05.144]                       return(sendCondition)
[16:06:05.144]                     ns <- getNamespace("parallel")
[16:06:05.144]                     if (exists("sendData", mode = "function", 
[16:06:05.144]                       envir = ns)) {
[16:06:05.144]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:05.144]                         envir = ns)
[16:06:05.144]                       envir <- sys.frame(frame)
[16:06:05.144]                       master <- NULL
[16:06:05.144]                       while (!identical(envir, .GlobalEnv) && 
[16:06:05.144]                         !identical(envir, emptyenv())) {
[16:06:05.144]                         if (exists("master", mode = "list", envir = envir, 
[16:06:05.144]                           inherits = FALSE)) {
[16:06:05.144]                           master <- get("master", mode = "list", 
[16:06:05.144]                             envir = envir, inherits = FALSE)
[16:06:05.144]                           if (inherits(master, c("SOCKnode", 
[16:06:05.144]                             "SOCK0node"))) {
[16:06:05.144]                             sendCondition <<- function(cond) {
[16:06:05.144]                               data <- list(type = "VALUE", value = cond, 
[16:06:05.144]                                 success = TRUE)
[16:06:05.144]                               parallel_sendData(master, data)
[16:06:05.144]                             }
[16:06:05.144]                             return(sendCondition)
[16:06:05.144]                           }
[16:06:05.144]                         }
[16:06:05.144]                         frame <- frame + 1L
[16:06:05.144]                         envir <- sys.frame(frame)
[16:06:05.144]                       }
[16:06:05.144]                     }
[16:06:05.144]                     sendCondition <<- function(cond) NULL
[16:06:05.144]                   }
[16:06:05.144]                 })
[16:06:05.144]                 withCallingHandlers({
[16:06:05.144]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:05.144]                 }, immediateCondition = function(cond) {
[16:06:05.144]                   sendCondition <- ...future.makeSendCondition()
[16:06:05.144]                   sendCondition(cond)
[16:06:05.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.144]                   {
[16:06:05.144]                     inherits <- base::inherits
[16:06:05.144]                     invokeRestart <- base::invokeRestart
[16:06:05.144]                     is.null <- base::is.null
[16:06:05.144]                     muffled <- FALSE
[16:06:05.144]                     if (inherits(cond, "message")) {
[16:06:05.144]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:05.144]                       if (muffled) 
[16:06:05.144]                         invokeRestart("muffleMessage")
[16:06:05.144]                     }
[16:06:05.144]                     else if (inherits(cond, "warning")) {
[16:06:05.144]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:05.144]                       if (muffled) 
[16:06:05.144]                         invokeRestart("muffleWarning")
[16:06:05.144]                     }
[16:06:05.144]                     else if (inherits(cond, "condition")) {
[16:06:05.144]                       if (!is.null(pattern)) {
[16:06:05.144]                         computeRestarts <- base::computeRestarts
[16:06:05.144]                         grepl <- base::grepl
[16:06:05.144]                         restarts <- computeRestarts(cond)
[16:06:05.144]                         for (restart in restarts) {
[16:06:05.144]                           name <- restart$name
[16:06:05.144]                           if (is.null(name)) 
[16:06:05.144]                             next
[16:06:05.144]                           if (!grepl(pattern, name)) 
[16:06:05.144]                             next
[16:06:05.144]                           invokeRestart(restart)
[16:06:05.144]                           muffled <- TRUE
[16:06:05.144]                           break
[16:06:05.144]                         }
[16:06:05.144]                       }
[16:06:05.144]                     }
[16:06:05.144]                     invisible(muffled)
[16:06:05.144]                   }
[16:06:05.144]                   muffleCondition(cond)
[16:06:05.144]                 })
[16:06:05.144]             }))
[16:06:05.144]             future::FutureResult(value = ...future.value$value, 
[16:06:05.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.144]                   ...future.rng), globalenv = if (FALSE) 
[16:06:05.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:05.144]                     ...future.globalenv.names))
[16:06:05.144]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:05.144]         }, condition = base::local({
[16:06:05.144]             c <- base::c
[16:06:05.144]             inherits <- base::inherits
[16:06:05.144]             invokeRestart <- base::invokeRestart
[16:06:05.144]             length <- base::length
[16:06:05.144]             list <- base::list
[16:06:05.144]             seq.int <- base::seq.int
[16:06:05.144]             signalCondition <- base::signalCondition
[16:06:05.144]             sys.calls <- base::sys.calls
[16:06:05.144]             `[[` <- base::`[[`
[16:06:05.144]             `+` <- base::`+`
[16:06:05.144]             `<<-` <- base::`<<-`
[16:06:05.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:05.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:05.144]                   3L)]
[16:06:05.144]             }
[16:06:05.144]             function(cond) {
[16:06:05.144]                 is_error <- inherits(cond, "error")
[16:06:05.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:05.144]                   NULL)
[16:06:05.144]                 if (is_error) {
[16:06:05.144]                   sessionInformation <- function() {
[16:06:05.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:05.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:05.144]                       search = base::search(), system = base::Sys.info())
[16:06:05.144]                   }
[16:06:05.144]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:05.144]                     cond$call), session = sessionInformation(), 
[16:06:05.144]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:05.144]                   signalCondition(cond)
[16:06:05.144]                 }
[16:06:05.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:05.144]                 "immediateCondition"))) {
[16:06:05.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:05.144]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:05.144]                   if (TRUE && !signal) {
[16:06:05.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.144]                     {
[16:06:05.144]                       inherits <- base::inherits
[16:06:05.144]                       invokeRestart <- base::invokeRestart
[16:06:05.144]                       is.null <- base::is.null
[16:06:05.144]                       muffled <- FALSE
[16:06:05.144]                       if (inherits(cond, "message")) {
[16:06:05.144]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.144]                         if (muffled) 
[16:06:05.144]                           invokeRestart("muffleMessage")
[16:06:05.144]                       }
[16:06:05.144]                       else if (inherits(cond, "warning")) {
[16:06:05.144]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.144]                         if (muffled) 
[16:06:05.144]                           invokeRestart("muffleWarning")
[16:06:05.144]                       }
[16:06:05.144]                       else if (inherits(cond, "condition")) {
[16:06:05.144]                         if (!is.null(pattern)) {
[16:06:05.144]                           computeRestarts <- base::computeRestarts
[16:06:05.144]                           grepl <- base::grepl
[16:06:05.144]                           restarts <- computeRestarts(cond)
[16:06:05.144]                           for (restart in restarts) {
[16:06:05.144]                             name <- restart$name
[16:06:05.144]                             if (is.null(name)) 
[16:06:05.144]                               next
[16:06:05.144]                             if (!grepl(pattern, name)) 
[16:06:05.144]                               next
[16:06:05.144]                             invokeRestart(restart)
[16:06:05.144]                             muffled <- TRUE
[16:06:05.144]                             break
[16:06:05.144]                           }
[16:06:05.144]                         }
[16:06:05.144]                       }
[16:06:05.144]                       invisible(muffled)
[16:06:05.144]                     }
[16:06:05.144]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.144]                   }
[16:06:05.144]                 }
[16:06:05.144]                 else {
[16:06:05.144]                   if (TRUE) {
[16:06:05.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.144]                     {
[16:06:05.144]                       inherits <- base::inherits
[16:06:05.144]                       invokeRestart <- base::invokeRestart
[16:06:05.144]                       is.null <- base::is.null
[16:06:05.144]                       muffled <- FALSE
[16:06:05.144]                       if (inherits(cond, "message")) {
[16:06:05.144]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.144]                         if (muffled) 
[16:06:05.144]                           invokeRestart("muffleMessage")
[16:06:05.144]                       }
[16:06:05.144]                       else if (inherits(cond, "warning")) {
[16:06:05.144]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.144]                         if (muffled) 
[16:06:05.144]                           invokeRestart("muffleWarning")
[16:06:05.144]                       }
[16:06:05.144]                       else if (inherits(cond, "condition")) {
[16:06:05.144]                         if (!is.null(pattern)) {
[16:06:05.144]                           computeRestarts <- base::computeRestarts
[16:06:05.144]                           grepl <- base::grepl
[16:06:05.144]                           restarts <- computeRestarts(cond)
[16:06:05.144]                           for (restart in restarts) {
[16:06:05.144]                             name <- restart$name
[16:06:05.144]                             if (is.null(name)) 
[16:06:05.144]                               next
[16:06:05.144]                             if (!grepl(pattern, name)) 
[16:06:05.144]                               next
[16:06:05.144]                             invokeRestart(restart)
[16:06:05.144]                             muffled <- TRUE
[16:06:05.144]                             break
[16:06:05.144]                           }
[16:06:05.144]                         }
[16:06:05.144]                       }
[16:06:05.144]                       invisible(muffled)
[16:06:05.144]                     }
[16:06:05.144]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.144]                   }
[16:06:05.144]                 }
[16:06:05.144]             }
[16:06:05.144]         }))
[16:06:05.144]     }, error = function(ex) {
[16:06:05.144]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:05.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.144]                 ...future.rng), started = ...future.startTime, 
[16:06:05.144]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:05.144]             version = "1.8"), class = "FutureResult")
[16:06:05.144]     }, finally = {
[16:06:05.144]         if (!identical(...future.workdir, getwd())) 
[16:06:05.144]             setwd(...future.workdir)
[16:06:05.144]         {
[16:06:05.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:05.144]                 ...future.oldOptions$nwarnings <- NULL
[16:06:05.144]             }
[16:06:05.144]             base::options(...future.oldOptions)
[16:06:05.144]             if (.Platform$OS.type == "windows") {
[16:06:05.144]                 old_names <- names(...future.oldEnvVars)
[16:06:05.144]                 envs <- base::Sys.getenv()
[16:06:05.144]                 names <- names(envs)
[16:06:05.144]                 common <- intersect(names, old_names)
[16:06:05.144]                 added <- setdiff(names, old_names)
[16:06:05.144]                 removed <- setdiff(old_names, names)
[16:06:05.144]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:05.144]                   envs[common]]
[16:06:05.144]                 NAMES <- toupper(changed)
[16:06:05.144]                 args <- list()
[16:06:05.144]                 for (kk in seq_along(NAMES)) {
[16:06:05.144]                   name <- changed[[kk]]
[16:06:05.144]                   NAME <- NAMES[[kk]]
[16:06:05.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.144]                     next
[16:06:05.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.144]                 }
[16:06:05.144]                 NAMES <- toupper(added)
[16:06:05.144]                 for (kk in seq_along(NAMES)) {
[16:06:05.144]                   name <- added[[kk]]
[16:06:05.144]                   NAME <- NAMES[[kk]]
[16:06:05.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.144]                     next
[16:06:05.144]                   args[[name]] <- ""
[16:06:05.144]                 }
[16:06:05.144]                 NAMES <- toupper(removed)
[16:06:05.144]                 for (kk in seq_along(NAMES)) {
[16:06:05.144]                   name <- removed[[kk]]
[16:06:05.144]                   NAME <- NAMES[[kk]]
[16:06:05.144]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.144]                     next
[16:06:05.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.144]                 }
[16:06:05.144]                 if (length(args) > 0) 
[16:06:05.144]                   base::do.call(base::Sys.setenv, args = args)
[16:06:05.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:05.144]             }
[16:06:05.144]             else {
[16:06:05.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:05.144]             }
[16:06:05.144]             {
[16:06:05.144]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:05.144]                   0L) {
[16:06:05.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:05.144]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:05.144]                   base::options(opts)
[16:06:05.144]                 }
[16:06:05.144]                 {
[16:06:05.144]                   {
[16:06:05.144]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:05.144]                     NULL
[16:06:05.144]                   }
[16:06:05.144]                   options(future.plan = NULL)
[16:06:05.144]                   if (is.na(NA_character_)) 
[16:06:05.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:05.144]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:05.144]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:05.144]                     envir = parent.frame()) 
[16:06:05.144]                   {
[16:06:05.144]                     if (is.function(workers)) 
[16:06:05.144]                       workers <- workers()
[16:06:05.144]                     workers <- structure(as.integer(workers), 
[16:06:05.144]                       class = class(workers))
[16:06:05.144]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:05.144]                       workers >= 1)
[16:06:05.144]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:05.144]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:05.144]                     }
[16:06:05.144]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:05.144]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:05.144]                       envir = envir)
[16:06:05.144]                     if (!future$lazy) 
[16:06:05.144]                       future <- run(future)
[16:06:05.144]                     invisible(future)
[16:06:05.144]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:05.144]                 }
[16:06:05.144]             }
[16:06:05.144]         }
[16:06:05.144]     })
[16:06:05.144]     if (TRUE) {
[16:06:05.144]         base::sink(type = "output", split = FALSE)
[16:06:05.144]         if (TRUE) {
[16:06:05.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:05.144]         }
[16:06:05.144]         else {
[16:06:05.144]             ...future.result["stdout"] <- base::list(NULL)
[16:06:05.144]         }
[16:06:05.144]         base::close(...future.stdout)
[16:06:05.144]         ...future.stdout <- NULL
[16:06:05.144]     }
[16:06:05.144]     ...future.result$conditions <- ...future.conditions
[16:06:05.144]     ...future.result$finished <- base::Sys.time()
[16:06:05.144]     ...future.result
[16:06:05.144] }
[16:06:05.148] MultisessionFuture started
[16:06:05.148] - Launch lazy future ... done
[16:06:05.148] run() for ‘MultisessionFuture’ ... done
[16:06:05.196] receiveMessageFromWorker() for ClusterFuture ...
[16:06:05.196] - Validating connection of MultisessionFuture
[16:06:05.197] - received message: FutureResult
[16:06:05.197] - Received FutureResult
[16:06:05.197] - Erased future from FutureRegistry
[16:06:05.197] result() for ClusterFuture ...
[16:06:05.197] - result already collected: FutureResult
[16:06:05.197] result() for ClusterFuture ... done
[16:06:05.198] signalConditions() ...
[16:06:05.198]  - include = ‘immediateCondition’
[16:06:05.198]  - exclude = 
[16:06:05.198]  - resignal = FALSE
[16:06:05.198]  - Number of conditions: 1
[16:06:05.198] signalConditions() ... done
[16:06:05.198] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:05.198] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[16:06:05.198] getGlobalsAndPackages() ...
[16:06:05.199] Searching for globals...
[16:06:05.200] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:05.200] Searching for globals ... DONE
[16:06:05.200] Resolving globals: FALSE
[16:06:05.200] 
[16:06:05.200] 
[16:06:05.201] getGlobalsAndPackages() ... DONE
[16:06:05.201] run() for ‘Future’ ...
[16:06:05.201] - state: ‘created’
[16:06:05.201] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:05.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:05.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:05.217]   - Field: ‘node’
[16:06:05.217]   - Field: ‘label’
[16:06:05.217]   - Field: ‘local’
[16:06:05.217]   - Field: ‘owner’
[16:06:05.217]   - Field: ‘envir’
[16:06:05.218]   - Field: ‘workers’
[16:06:05.218]   - Field: ‘packages’
[16:06:05.218]   - Field: ‘gc’
[16:06:05.218]   - Field: ‘conditions’
[16:06:05.218]   - Field: ‘persistent’
[16:06:05.218]   - Field: ‘expr’
[16:06:05.218]   - Field: ‘uuid’
[16:06:05.218]   - Field: ‘seed’
[16:06:05.218]   - Field: ‘version’
[16:06:05.218]   - Field: ‘result’
[16:06:05.218]   - Field: ‘asynchronous’
[16:06:05.219]   - Field: ‘calls’
[16:06:05.219]   - Field: ‘globals’
[16:06:05.219]   - Field: ‘stdout’
[16:06:05.219]   - Field: ‘earlySignal’
[16:06:05.219]   - Field: ‘lazy’
[16:06:05.219]   - Field: ‘state’
[16:06:05.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:05.219] - Launch lazy future ...
[16:06:05.219] Packages needed by the future expression (n = 0): <none>
[16:06:05.220] Packages needed by future strategies (n = 0): <none>
[16:06:05.220] {
[16:06:05.220]     {
[16:06:05.220]         {
[16:06:05.220]             ...future.startTime <- base::Sys.time()
[16:06:05.220]             {
[16:06:05.220]                 {
[16:06:05.220]                   {
[16:06:05.220]                     {
[16:06:05.220]                       base::local({
[16:06:05.220]                         has_future <- base::requireNamespace("future", 
[16:06:05.220]                           quietly = TRUE)
[16:06:05.220]                         if (has_future) {
[16:06:05.220]                           ns <- base::getNamespace("future")
[16:06:05.220]                           version <- ns[[".package"]][["version"]]
[16:06:05.220]                           if (is.null(version)) 
[16:06:05.220]                             version <- utils::packageVersion("future")
[16:06:05.220]                         }
[16:06:05.220]                         else {
[16:06:05.220]                           version <- NULL
[16:06:05.220]                         }
[16:06:05.220]                         if (!has_future || version < "1.8.0") {
[16:06:05.220]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:05.220]                             "", base::R.version$version.string), 
[16:06:05.220]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:05.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:05.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:05.220]                               "release", "version")], collapse = " "), 
[16:06:05.220]                             hostname = base::Sys.info()[["nodename"]])
[16:06:05.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:05.220]                             info)
[16:06:05.220]                           info <- base::paste(info, collapse = "; ")
[16:06:05.220]                           if (!has_future) {
[16:06:05.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:05.220]                               info)
[16:06:05.220]                           }
[16:06:05.220]                           else {
[16:06:05.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:05.220]                               info, version)
[16:06:05.220]                           }
[16:06:05.220]                           base::stop(msg)
[16:06:05.220]                         }
[16:06:05.220]                       })
[16:06:05.220]                     }
[16:06:05.220]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:05.220]                     base::options(mc.cores = 1L)
[16:06:05.220]                   }
[16:06:05.220]                   options(future.plan = NULL)
[16:06:05.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:05.220]                 }
[16:06:05.220]                 ...future.workdir <- getwd()
[16:06:05.220]             }
[16:06:05.220]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:05.220]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:05.220]         }
[16:06:05.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:05.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:05.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:05.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:05.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:05.220]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:05.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:05.220]             base::names(...future.oldOptions))
[16:06:05.220]     }
[16:06:05.220]     if (FALSE) {
[16:06:05.220]     }
[16:06:05.220]     else {
[16:06:05.220]         if (TRUE) {
[16:06:05.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:05.220]                 open = "w")
[16:06:05.220]         }
[16:06:05.220]         else {
[16:06:05.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:05.220]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:05.220]         }
[16:06:05.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:05.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:05.220]             base::sink(type = "output", split = FALSE)
[16:06:05.220]             base::close(...future.stdout)
[16:06:05.220]         }, add = TRUE)
[16:06:05.220]     }
[16:06:05.220]     ...future.frame <- base::sys.nframe()
[16:06:05.220]     ...future.conditions <- base::list()
[16:06:05.220]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:05.220]     if (FALSE) {
[16:06:05.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:05.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:05.220]     }
[16:06:05.220]     ...future.result <- base::tryCatch({
[16:06:05.220]         base::withCallingHandlers({
[16:06:05.220]             ...future.value <- base::withVisible(base::local({
[16:06:05.220]                 ...future.makeSendCondition <- base::local({
[16:06:05.220]                   sendCondition <- NULL
[16:06:05.220]                   function(frame = 1L) {
[16:06:05.220]                     if (is.function(sendCondition)) 
[16:06:05.220]                       return(sendCondition)
[16:06:05.220]                     ns <- getNamespace("parallel")
[16:06:05.220]                     if (exists("sendData", mode = "function", 
[16:06:05.220]                       envir = ns)) {
[16:06:05.220]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:05.220]                         envir = ns)
[16:06:05.220]                       envir <- sys.frame(frame)
[16:06:05.220]                       master <- NULL
[16:06:05.220]                       while (!identical(envir, .GlobalEnv) && 
[16:06:05.220]                         !identical(envir, emptyenv())) {
[16:06:05.220]                         if (exists("master", mode = "list", envir = envir, 
[16:06:05.220]                           inherits = FALSE)) {
[16:06:05.220]                           master <- get("master", mode = "list", 
[16:06:05.220]                             envir = envir, inherits = FALSE)
[16:06:05.220]                           if (inherits(master, c("SOCKnode", 
[16:06:05.220]                             "SOCK0node"))) {
[16:06:05.220]                             sendCondition <<- function(cond) {
[16:06:05.220]                               data <- list(type = "VALUE", value = cond, 
[16:06:05.220]                                 success = TRUE)
[16:06:05.220]                               parallel_sendData(master, data)
[16:06:05.220]                             }
[16:06:05.220]                             return(sendCondition)
[16:06:05.220]                           }
[16:06:05.220]                         }
[16:06:05.220]                         frame <- frame + 1L
[16:06:05.220]                         envir <- sys.frame(frame)
[16:06:05.220]                       }
[16:06:05.220]                     }
[16:06:05.220]                     sendCondition <<- function(cond) NULL
[16:06:05.220]                   }
[16:06:05.220]                 })
[16:06:05.220]                 withCallingHandlers({
[16:06:05.220]                   {
[16:06:05.220]                     Sys.sleep(0.5)
[16:06:05.220]                     list(a = 1, b = 42L)
[16:06:05.220]                   }
[16:06:05.220]                 }, immediateCondition = function(cond) {
[16:06:05.220]                   sendCondition <- ...future.makeSendCondition()
[16:06:05.220]                   sendCondition(cond)
[16:06:05.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.220]                   {
[16:06:05.220]                     inherits <- base::inherits
[16:06:05.220]                     invokeRestart <- base::invokeRestart
[16:06:05.220]                     is.null <- base::is.null
[16:06:05.220]                     muffled <- FALSE
[16:06:05.220]                     if (inherits(cond, "message")) {
[16:06:05.220]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:05.220]                       if (muffled) 
[16:06:05.220]                         invokeRestart("muffleMessage")
[16:06:05.220]                     }
[16:06:05.220]                     else if (inherits(cond, "warning")) {
[16:06:05.220]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:05.220]                       if (muffled) 
[16:06:05.220]                         invokeRestart("muffleWarning")
[16:06:05.220]                     }
[16:06:05.220]                     else if (inherits(cond, "condition")) {
[16:06:05.220]                       if (!is.null(pattern)) {
[16:06:05.220]                         computeRestarts <- base::computeRestarts
[16:06:05.220]                         grepl <- base::grepl
[16:06:05.220]                         restarts <- computeRestarts(cond)
[16:06:05.220]                         for (restart in restarts) {
[16:06:05.220]                           name <- restart$name
[16:06:05.220]                           if (is.null(name)) 
[16:06:05.220]                             next
[16:06:05.220]                           if (!grepl(pattern, name)) 
[16:06:05.220]                             next
[16:06:05.220]                           invokeRestart(restart)
[16:06:05.220]                           muffled <- TRUE
[16:06:05.220]                           break
[16:06:05.220]                         }
[16:06:05.220]                       }
[16:06:05.220]                     }
[16:06:05.220]                     invisible(muffled)
[16:06:05.220]                   }
[16:06:05.220]                   muffleCondition(cond)
[16:06:05.220]                 })
[16:06:05.220]             }))
[16:06:05.220]             future::FutureResult(value = ...future.value$value, 
[16:06:05.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.220]                   ...future.rng), globalenv = if (FALSE) 
[16:06:05.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:05.220]                     ...future.globalenv.names))
[16:06:05.220]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:05.220]         }, condition = base::local({
[16:06:05.220]             c <- base::c
[16:06:05.220]             inherits <- base::inherits
[16:06:05.220]             invokeRestart <- base::invokeRestart
[16:06:05.220]             length <- base::length
[16:06:05.220]             list <- base::list
[16:06:05.220]             seq.int <- base::seq.int
[16:06:05.220]             signalCondition <- base::signalCondition
[16:06:05.220]             sys.calls <- base::sys.calls
[16:06:05.220]             `[[` <- base::`[[`
[16:06:05.220]             `+` <- base::`+`
[16:06:05.220]             `<<-` <- base::`<<-`
[16:06:05.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:05.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:05.220]                   3L)]
[16:06:05.220]             }
[16:06:05.220]             function(cond) {
[16:06:05.220]                 is_error <- inherits(cond, "error")
[16:06:05.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:05.220]                   NULL)
[16:06:05.220]                 if (is_error) {
[16:06:05.220]                   sessionInformation <- function() {
[16:06:05.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:05.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:05.220]                       search = base::search(), system = base::Sys.info())
[16:06:05.220]                   }
[16:06:05.220]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:05.220]                     cond$call), session = sessionInformation(), 
[16:06:05.220]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:05.220]                   signalCondition(cond)
[16:06:05.220]                 }
[16:06:05.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:05.220]                 "immediateCondition"))) {
[16:06:05.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:05.220]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:05.220]                   if (TRUE && !signal) {
[16:06:05.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.220]                     {
[16:06:05.220]                       inherits <- base::inherits
[16:06:05.220]                       invokeRestart <- base::invokeRestart
[16:06:05.220]                       is.null <- base::is.null
[16:06:05.220]                       muffled <- FALSE
[16:06:05.220]                       if (inherits(cond, "message")) {
[16:06:05.220]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.220]                         if (muffled) 
[16:06:05.220]                           invokeRestart("muffleMessage")
[16:06:05.220]                       }
[16:06:05.220]                       else if (inherits(cond, "warning")) {
[16:06:05.220]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.220]                         if (muffled) 
[16:06:05.220]                           invokeRestart("muffleWarning")
[16:06:05.220]                       }
[16:06:05.220]                       else if (inherits(cond, "condition")) {
[16:06:05.220]                         if (!is.null(pattern)) {
[16:06:05.220]                           computeRestarts <- base::computeRestarts
[16:06:05.220]                           grepl <- base::grepl
[16:06:05.220]                           restarts <- computeRestarts(cond)
[16:06:05.220]                           for (restart in restarts) {
[16:06:05.220]                             name <- restart$name
[16:06:05.220]                             if (is.null(name)) 
[16:06:05.220]                               next
[16:06:05.220]                             if (!grepl(pattern, name)) 
[16:06:05.220]                               next
[16:06:05.220]                             invokeRestart(restart)
[16:06:05.220]                             muffled <- TRUE
[16:06:05.220]                             break
[16:06:05.220]                           }
[16:06:05.220]                         }
[16:06:05.220]                       }
[16:06:05.220]                       invisible(muffled)
[16:06:05.220]                     }
[16:06:05.220]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.220]                   }
[16:06:05.220]                 }
[16:06:05.220]                 else {
[16:06:05.220]                   if (TRUE) {
[16:06:05.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.220]                     {
[16:06:05.220]                       inherits <- base::inherits
[16:06:05.220]                       invokeRestart <- base::invokeRestart
[16:06:05.220]                       is.null <- base::is.null
[16:06:05.220]                       muffled <- FALSE
[16:06:05.220]                       if (inherits(cond, "message")) {
[16:06:05.220]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.220]                         if (muffled) 
[16:06:05.220]                           invokeRestart("muffleMessage")
[16:06:05.220]                       }
[16:06:05.220]                       else if (inherits(cond, "warning")) {
[16:06:05.220]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.220]                         if (muffled) 
[16:06:05.220]                           invokeRestart("muffleWarning")
[16:06:05.220]                       }
[16:06:05.220]                       else if (inherits(cond, "condition")) {
[16:06:05.220]                         if (!is.null(pattern)) {
[16:06:05.220]                           computeRestarts <- base::computeRestarts
[16:06:05.220]                           grepl <- base::grepl
[16:06:05.220]                           restarts <- computeRestarts(cond)
[16:06:05.220]                           for (restart in restarts) {
[16:06:05.220]                             name <- restart$name
[16:06:05.220]                             if (is.null(name)) 
[16:06:05.220]                               next
[16:06:05.220]                             if (!grepl(pattern, name)) 
[16:06:05.220]                               next
[16:06:05.220]                             invokeRestart(restart)
[16:06:05.220]                             muffled <- TRUE
[16:06:05.220]                             break
[16:06:05.220]                           }
[16:06:05.220]                         }
[16:06:05.220]                       }
[16:06:05.220]                       invisible(muffled)
[16:06:05.220]                     }
[16:06:05.220]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.220]                   }
[16:06:05.220]                 }
[16:06:05.220]             }
[16:06:05.220]         }))
[16:06:05.220]     }, error = function(ex) {
[16:06:05.220]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:05.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.220]                 ...future.rng), started = ...future.startTime, 
[16:06:05.220]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:05.220]             version = "1.8"), class = "FutureResult")
[16:06:05.220]     }, finally = {
[16:06:05.220]         if (!identical(...future.workdir, getwd())) 
[16:06:05.220]             setwd(...future.workdir)
[16:06:05.220]         {
[16:06:05.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:05.220]                 ...future.oldOptions$nwarnings <- NULL
[16:06:05.220]             }
[16:06:05.220]             base::options(...future.oldOptions)
[16:06:05.220]             if (.Platform$OS.type == "windows") {
[16:06:05.220]                 old_names <- names(...future.oldEnvVars)
[16:06:05.220]                 envs <- base::Sys.getenv()
[16:06:05.220]                 names <- names(envs)
[16:06:05.220]                 common <- intersect(names, old_names)
[16:06:05.220]                 added <- setdiff(names, old_names)
[16:06:05.220]                 removed <- setdiff(old_names, names)
[16:06:05.220]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:05.220]                   envs[common]]
[16:06:05.220]                 NAMES <- toupper(changed)
[16:06:05.220]                 args <- list()
[16:06:05.220]                 for (kk in seq_along(NAMES)) {
[16:06:05.220]                   name <- changed[[kk]]
[16:06:05.220]                   NAME <- NAMES[[kk]]
[16:06:05.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.220]                     next
[16:06:05.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.220]                 }
[16:06:05.220]                 NAMES <- toupper(added)
[16:06:05.220]                 for (kk in seq_along(NAMES)) {
[16:06:05.220]                   name <- added[[kk]]
[16:06:05.220]                   NAME <- NAMES[[kk]]
[16:06:05.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.220]                     next
[16:06:05.220]                   args[[name]] <- ""
[16:06:05.220]                 }
[16:06:05.220]                 NAMES <- toupper(removed)
[16:06:05.220]                 for (kk in seq_along(NAMES)) {
[16:06:05.220]                   name <- removed[[kk]]
[16:06:05.220]                   NAME <- NAMES[[kk]]
[16:06:05.220]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.220]                     next
[16:06:05.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.220]                 }
[16:06:05.220]                 if (length(args) > 0) 
[16:06:05.220]                   base::do.call(base::Sys.setenv, args = args)
[16:06:05.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:05.220]             }
[16:06:05.220]             else {
[16:06:05.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:05.220]             }
[16:06:05.220]             {
[16:06:05.220]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:05.220]                   0L) {
[16:06:05.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:05.220]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:05.220]                   base::options(opts)
[16:06:05.220]                 }
[16:06:05.220]                 {
[16:06:05.220]                   {
[16:06:05.220]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:05.220]                     NULL
[16:06:05.220]                   }
[16:06:05.220]                   options(future.plan = NULL)
[16:06:05.220]                   if (is.na(NA_character_)) 
[16:06:05.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:05.220]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:05.220]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:05.220]                     envir = parent.frame()) 
[16:06:05.220]                   {
[16:06:05.220]                     if (is.function(workers)) 
[16:06:05.220]                       workers <- workers()
[16:06:05.220]                     workers <- structure(as.integer(workers), 
[16:06:05.220]                       class = class(workers))
[16:06:05.220]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:05.220]                       workers >= 1)
[16:06:05.220]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:05.220]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:05.220]                     }
[16:06:05.220]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:05.220]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:05.220]                       envir = envir)
[16:06:05.220]                     if (!future$lazy) 
[16:06:05.220]                       future <- run(future)
[16:06:05.220]                     invisible(future)
[16:06:05.220]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:05.220]                 }
[16:06:05.220]             }
[16:06:05.220]         }
[16:06:05.220]     })
[16:06:05.220]     if (TRUE) {
[16:06:05.220]         base::sink(type = "output", split = FALSE)
[16:06:05.220]         if (TRUE) {
[16:06:05.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:05.220]         }
[16:06:05.220]         else {
[16:06:05.220]             ...future.result["stdout"] <- base::list(NULL)
[16:06:05.220]         }
[16:06:05.220]         base::close(...future.stdout)
[16:06:05.220]         ...future.stdout <- NULL
[16:06:05.220]     }
[16:06:05.220]     ...future.result$conditions <- ...future.conditions
[16:06:05.220]     ...future.result$finished <- base::Sys.time()
[16:06:05.220]     ...future.result
[16:06:05.220] }
[16:06:05.223] MultisessionFuture started
[16:06:05.223] - Launch lazy future ... done
[16:06:05.223] run() for ‘MultisessionFuture’ ... done
[16:06:05.782] receiveMessageFromWorker() for ClusterFuture ...
[16:06:05.782] - Validating connection of MultisessionFuture
[16:06:05.782] - received message: FutureResult
[16:06:05.782] - Received FutureResult
[16:06:05.782] - Erased future from FutureRegistry
[16:06:05.782] result() for ClusterFuture ...
[16:06:05.783] - result already collected: FutureResult
[16:06:05.783] result() for ClusterFuture ... done
[16:06:05.783] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:05.783] A MultisessionFuture was resolved (result was not collected)
[16:06:05.783] getGlobalsAndPackages() ...
[16:06:05.783] Searching for globals...
[16:06:05.784] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:05.784] Searching for globals ... DONE
[16:06:05.784] Resolving globals: FALSE
[16:06:05.785] 
[16:06:05.785] 
[16:06:05.785] getGlobalsAndPackages() ... DONE
[16:06:05.785] run() for ‘Future’ ...
[16:06:05.785] - state: ‘created’
[16:06:05.786] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:05.800] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:05.800] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:05.800]   - Field: ‘node’
[16:06:05.800]   - Field: ‘label’
[16:06:05.800]   - Field: ‘local’
[16:06:05.800]   - Field: ‘owner’
[16:06:05.800]   - Field: ‘envir’
[16:06:05.801]   - Field: ‘workers’
[16:06:05.801]   - Field: ‘packages’
[16:06:05.801]   - Field: ‘gc’
[16:06:05.801]   - Field: ‘conditions’
[16:06:05.801]   - Field: ‘persistent’
[16:06:05.801]   - Field: ‘expr’
[16:06:05.801]   - Field: ‘uuid’
[16:06:05.801]   - Field: ‘seed’
[16:06:05.801]   - Field: ‘version’
[16:06:05.801]   - Field: ‘result’
[16:06:05.801]   - Field: ‘asynchronous’
[16:06:05.802]   - Field: ‘calls’
[16:06:05.802]   - Field: ‘globals’
[16:06:05.802]   - Field: ‘stdout’
[16:06:05.802]   - Field: ‘earlySignal’
[16:06:05.802]   - Field: ‘lazy’
[16:06:05.802]   - Field: ‘state’
[16:06:05.802] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:05.802] - Launch lazy future ...
[16:06:05.802] Packages needed by the future expression (n = 0): <none>
[16:06:05.803] Packages needed by future strategies (n = 0): <none>
[16:06:05.803] {
[16:06:05.803]     {
[16:06:05.803]         {
[16:06:05.803]             ...future.startTime <- base::Sys.time()
[16:06:05.803]             {
[16:06:05.803]                 {
[16:06:05.803]                   {
[16:06:05.803]                     {
[16:06:05.803]                       base::local({
[16:06:05.803]                         has_future <- base::requireNamespace("future", 
[16:06:05.803]                           quietly = TRUE)
[16:06:05.803]                         if (has_future) {
[16:06:05.803]                           ns <- base::getNamespace("future")
[16:06:05.803]                           version <- ns[[".package"]][["version"]]
[16:06:05.803]                           if (is.null(version)) 
[16:06:05.803]                             version <- utils::packageVersion("future")
[16:06:05.803]                         }
[16:06:05.803]                         else {
[16:06:05.803]                           version <- NULL
[16:06:05.803]                         }
[16:06:05.803]                         if (!has_future || version < "1.8.0") {
[16:06:05.803]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:05.803]                             "", base::R.version$version.string), 
[16:06:05.803]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:05.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:05.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:05.803]                               "release", "version")], collapse = " "), 
[16:06:05.803]                             hostname = base::Sys.info()[["nodename"]])
[16:06:05.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:05.803]                             info)
[16:06:05.803]                           info <- base::paste(info, collapse = "; ")
[16:06:05.803]                           if (!has_future) {
[16:06:05.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:05.803]                               info)
[16:06:05.803]                           }
[16:06:05.803]                           else {
[16:06:05.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:05.803]                               info, version)
[16:06:05.803]                           }
[16:06:05.803]                           base::stop(msg)
[16:06:05.803]                         }
[16:06:05.803]                       })
[16:06:05.803]                     }
[16:06:05.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:05.803]                     base::options(mc.cores = 1L)
[16:06:05.803]                   }
[16:06:05.803]                   options(future.plan = NULL)
[16:06:05.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:05.803]                 }
[16:06:05.803]                 ...future.workdir <- getwd()
[16:06:05.803]             }
[16:06:05.803]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:05.803]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:05.803]         }
[16:06:05.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:05.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:05.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:05.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:05.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:05.803]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:05.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:05.803]             base::names(...future.oldOptions))
[16:06:05.803]     }
[16:06:05.803]     if (FALSE) {
[16:06:05.803]     }
[16:06:05.803]     else {
[16:06:05.803]         if (TRUE) {
[16:06:05.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:05.803]                 open = "w")
[16:06:05.803]         }
[16:06:05.803]         else {
[16:06:05.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:05.803]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:05.803]         }
[16:06:05.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:05.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:05.803]             base::sink(type = "output", split = FALSE)
[16:06:05.803]             base::close(...future.stdout)
[16:06:05.803]         }, add = TRUE)
[16:06:05.803]     }
[16:06:05.803]     ...future.frame <- base::sys.nframe()
[16:06:05.803]     ...future.conditions <- base::list()
[16:06:05.803]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:05.803]     if (FALSE) {
[16:06:05.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:05.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:05.803]     }
[16:06:05.803]     ...future.result <- base::tryCatch({
[16:06:05.803]         base::withCallingHandlers({
[16:06:05.803]             ...future.value <- base::withVisible(base::local({
[16:06:05.803]                 ...future.makeSendCondition <- base::local({
[16:06:05.803]                   sendCondition <- NULL
[16:06:05.803]                   function(frame = 1L) {
[16:06:05.803]                     if (is.function(sendCondition)) 
[16:06:05.803]                       return(sendCondition)
[16:06:05.803]                     ns <- getNamespace("parallel")
[16:06:05.803]                     if (exists("sendData", mode = "function", 
[16:06:05.803]                       envir = ns)) {
[16:06:05.803]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:05.803]                         envir = ns)
[16:06:05.803]                       envir <- sys.frame(frame)
[16:06:05.803]                       master <- NULL
[16:06:05.803]                       while (!identical(envir, .GlobalEnv) && 
[16:06:05.803]                         !identical(envir, emptyenv())) {
[16:06:05.803]                         if (exists("master", mode = "list", envir = envir, 
[16:06:05.803]                           inherits = FALSE)) {
[16:06:05.803]                           master <- get("master", mode = "list", 
[16:06:05.803]                             envir = envir, inherits = FALSE)
[16:06:05.803]                           if (inherits(master, c("SOCKnode", 
[16:06:05.803]                             "SOCK0node"))) {
[16:06:05.803]                             sendCondition <<- function(cond) {
[16:06:05.803]                               data <- list(type = "VALUE", value = cond, 
[16:06:05.803]                                 success = TRUE)
[16:06:05.803]                               parallel_sendData(master, data)
[16:06:05.803]                             }
[16:06:05.803]                             return(sendCondition)
[16:06:05.803]                           }
[16:06:05.803]                         }
[16:06:05.803]                         frame <- frame + 1L
[16:06:05.803]                         envir <- sys.frame(frame)
[16:06:05.803]                       }
[16:06:05.803]                     }
[16:06:05.803]                     sendCondition <<- function(cond) NULL
[16:06:05.803]                   }
[16:06:05.803]                 })
[16:06:05.803]                 withCallingHandlers({
[16:06:05.803]                   {
[16:06:05.803]                     Sys.sleep(0.5)
[16:06:05.803]                     list(a = 1, b = 42L)
[16:06:05.803]                   }
[16:06:05.803]                 }, immediateCondition = function(cond) {
[16:06:05.803]                   sendCondition <- ...future.makeSendCondition()
[16:06:05.803]                   sendCondition(cond)
[16:06:05.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.803]                   {
[16:06:05.803]                     inherits <- base::inherits
[16:06:05.803]                     invokeRestart <- base::invokeRestart
[16:06:05.803]                     is.null <- base::is.null
[16:06:05.803]                     muffled <- FALSE
[16:06:05.803]                     if (inherits(cond, "message")) {
[16:06:05.803]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:05.803]                       if (muffled) 
[16:06:05.803]                         invokeRestart("muffleMessage")
[16:06:05.803]                     }
[16:06:05.803]                     else if (inherits(cond, "warning")) {
[16:06:05.803]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:05.803]                       if (muffled) 
[16:06:05.803]                         invokeRestart("muffleWarning")
[16:06:05.803]                     }
[16:06:05.803]                     else if (inherits(cond, "condition")) {
[16:06:05.803]                       if (!is.null(pattern)) {
[16:06:05.803]                         computeRestarts <- base::computeRestarts
[16:06:05.803]                         grepl <- base::grepl
[16:06:05.803]                         restarts <- computeRestarts(cond)
[16:06:05.803]                         for (restart in restarts) {
[16:06:05.803]                           name <- restart$name
[16:06:05.803]                           if (is.null(name)) 
[16:06:05.803]                             next
[16:06:05.803]                           if (!grepl(pattern, name)) 
[16:06:05.803]                             next
[16:06:05.803]                           invokeRestart(restart)
[16:06:05.803]                           muffled <- TRUE
[16:06:05.803]                           break
[16:06:05.803]                         }
[16:06:05.803]                       }
[16:06:05.803]                     }
[16:06:05.803]                     invisible(muffled)
[16:06:05.803]                   }
[16:06:05.803]                   muffleCondition(cond)
[16:06:05.803]                 })
[16:06:05.803]             }))
[16:06:05.803]             future::FutureResult(value = ...future.value$value, 
[16:06:05.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.803]                   ...future.rng), globalenv = if (FALSE) 
[16:06:05.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:05.803]                     ...future.globalenv.names))
[16:06:05.803]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:05.803]         }, condition = base::local({
[16:06:05.803]             c <- base::c
[16:06:05.803]             inherits <- base::inherits
[16:06:05.803]             invokeRestart <- base::invokeRestart
[16:06:05.803]             length <- base::length
[16:06:05.803]             list <- base::list
[16:06:05.803]             seq.int <- base::seq.int
[16:06:05.803]             signalCondition <- base::signalCondition
[16:06:05.803]             sys.calls <- base::sys.calls
[16:06:05.803]             `[[` <- base::`[[`
[16:06:05.803]             `+` <- base::`+`
[16:06:05.803]             `<<-` <- base::`<<-`
[16:06:05.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:05.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:05.803]                   3L)]
[16:06:05.803]             }
[16:06:05.803]             function(cond) {
[16:06:05.803]                 is_error <- inherits(cond, "error")
[16:06:05.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:05.803]                   NULL)
[16:06:05.803]                 if (is_error) {
[16:06:05.803]                   sessionInformation <- function() {
[16:06:05.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:05.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:05.803]                       search = base::search(), system = base::Sys.info())
[16:06:05.803]                   }
[16:06:05.803]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:05.803]                     cond$call), session = sessionInformation(), 
[16:06:05.803]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:05.803]                   signalCondition(cond)
[16:06:05.803]                 }
[16:06:05.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:05.803]                 "immediateCondition"))) {
[16:06:05.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:05.803]                   ...future.conditions[[length(...future.conditions) + 
[16:06:05.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:05.803]                   if (TRUE && !signal) {
[16:06:05.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.803]                     {
[16:06:05.803]                       inherits <- base::inherits
[16:06:05.803]                       invokeRestart <- base::invokeRestart
[16:06:05.803]                       is.null <- base::is.null
[16:06:05.803]                       muffled <- FALSE
[16:06:05.803]                       if (inherits(cond, "message")) {
[16:06:05.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.803]                         if (muffled) 
[16:06:05.803]                           invokeRestart("muffleMessage")
[16:06:05.803]                       }
[16:06:05.803]                       else if (inherits(cond, "warning")) {
[16:06:05.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.803]                         if (muffled) 
[16:06:05.803]                           invokeRestart("muffleWarning")
[16:06:05.803]                       }
[16:06:05.803]                       else if (inherits(cond, "condition")) {
[16:06:05.803]                         if (!is.null(pattern)) {
[16:06:05.803]                           computeRestarts <- base::computeRestarts
[16:06:05.803]                           grepl <- base::grepl
[16:06:05.803]                           restarts <- computeRestarts(cond)
[16:06:05.803]                           for (restart in restarts) {
[16:06:05.803]                             name <- restart$name
[16:06:05.803]                             if (is.null(name)) 
[16:06:05.803]                               next
[16:06:05.803]                             if (!grepl(pattern, name)) 
[16:06:05.803]                               next
[16:06:05.803]                             invokeRestart(restart)
[16:06:05.803]                             muffled <- TRUE
[16:06:05.803]                             break
[16:06:05.803]                           }
[16:06:05.803]                         }
[16:06:05.803]                       }
[16:06:05.803]                       invisible(muffled)
[16:06:05.803]                     }
[16:06:05.803]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.803]                   }
[16:06:05.803]                 }
[16:06:05.803]                 else {
[16:06:05.803]                   if (TRUE) {
[16:06:05.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:05.803]                     {
[16:06:05.803]                       inherits <- base::inherits
[16:06:05.803]                       invokeRestart <- base::invokeRestart
[16:06:05.803]                       is.null <- base::is.null
[16:06:05.803]                       muffled <- FALSE
[16:06:05.803]                       if (inherits(cond, "message")) {
[16:06:05.803]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:05.803]                         if (muffled) 
[16:06:05.803]                           invokeRestart("muffleMessage")
[16:06:05.803]                       }
[16:06:05.803]                       else if (inherits(cond, "warning")) {
[16:06:05.803]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:05.803]                         if (muffled) 
[16:06:05.803]                           invokeRestart("muffleWarning")
[16:06:05.803]                       }
[16:06:05.803]                       else if (inherits(cond, "condition")) {
[16:06:05.803]                         if (!is.null(pattern)) {
[16:06:05.803]                           computeRestarts <- base::computeRestarts
[16:06:05.803]                           grepl <- base::grepl
[16:06:05.803]                           restarts <- computeRestarts(cond)
[16:06:05.803]                           for (restart in restarts) {
[16:06:05.803]                             name <- restart$name
[16:06:05.803]                             if (is.null(name)) 
[16:06:05.803]                               next
[16:06:05.803]                             if (!grepl(pattern, name)) 
[16:06:05.803]                               next
[16:06:05.803]                             invokeRestart(restart)
[16:06:05.803]                             muffled <- TRUE
[16:06:05.803]                             break
[16:06:05.803]                           }
[16:06:05.803]                         }
[16:06:05.803]                       }
[16:06:05.803]                       invisible(muffled)
[16:06:05.803]                     }
[16:06:05.803]                     muffleCondition(cond, pattern = "^muffle")
[16:06:05.803]                   }
[16:06:05.803]                 }
[16:06:05.803]             }
[16:06:05.803]         }))
[16:06:05.803]     }, error = function(ex) {
[16:06:05.803]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:05.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:05.803]                 ...future.rng), started = ...future.startTime, 
[16:06:05.803]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:05.803]             version = "1.8"), class = "FutureResult")
[16:06:05.803]     }, finally = {
[16:06:05.803]         if (!identical(...future.workdir, getwd())) 
[16:06:05.803]             setwd(...future.workdir)
[16:06:05.803]         {
[16:06:05.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:05.803]                 ...future.oldOptions$nwarnings <- NULL
[16:06:05.803]             }
[16:06:05.803]             base::options(...future.oldOptions)
[16:06:05.803]             if (.Platform$OS.type == "windows") {
[16:06:05.803]                 old_names <- names(...future.oldEnvVars)
[16:06:05.803]                 envs <- base::Sys.getenv()
[16:06:05.803]                 names <- names(envs)
[16:06:05.803]                 common <- intersect(names, old_names)
[16:06:05.803]                 added <- setdiff(names, old_names)
[16:06:05.803]                 removed <- setdiff(old_names, names)
[16:06:05.803]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:05.803]                   envs[common]]
[16:06:05.803]                 NAMES <- toupper(changed)
[16:06:05.803]                 args <- list()
[16:06:05.803]                 for (kk in seq_along(NAMES)) {
[16:06:05.803]                   name <- changed[[kk]]
[16:06:05.803]                   NAME <- NAMES[[kk]]
[16:06:05.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.803]                     next
[16:06:05.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.803]                 }
[16:06:05.803]                 NAMES <- toupper(added)
[16:06:05.803]                 for (kk in seq_along(NAMES)) {
[16:06:05.803]                   name <- added[[kk]]
[16:06:05.803]                   NAME <- NAMES[[kk]]
[16:06:05.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.803]                     next
[16:06:05.803]                   args[[name]] <- ""
[16:06:05.803]                 }
[16:06:05.803]                 NAMES <- toupper(removed)
[16:06:05.803]                 for (kk in seq_along(NAMES)) {
[16:06:05.803]                   name <- removed[[kk]]
[16:06:05.803]                   NAME <- NAMES[[kk]]
[16:06:05.803]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:05.803]                     next
[16:06:05.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:05.803]                 }
[16:06:05.803]                 if (length(args) > 0) 
[16:06:05.803]                   base::do.call(base::Sys.setenv, args = args)
[16:06:05.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:05.803]             }
[16:06:05.803]             else {
[16:06:05.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:05.803]             }
[16:06:05.803]             {
[16:06:05.803]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:05.803]                   0L) {
[16:06:05.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:05.803]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:05.803]                   base::options(opts)
[16:06:05.803]                 }
[16:06:05.803]                 {
[16:06:05.803]                   {
[16:06:05.803]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:05.803]                     NULL
[16:06:05.803]                   }
[16:06:05.803]                   options(future.plan = NULL)
[16:06:05.803]                   if (is.na(NA_character_)) 
[16:06:05.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:05.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:05.803]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:05.803]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:05.803]                     envir = parent.frame()) 
[16:06:05.803]                   {
[16:06:05.803]                     if (is.function(workers)) 
[16:06:05.803]                       workers <- workers()
[16:06:05.803]                     workers <- structure(as.integer(workers), 
[16:06:05.803]                       class = class(workers))
[16:06:05.803]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:05.803]                       workers >= 1)
[16:06:05.803]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:05.803]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:05.803]                     }
[16:06:05.803]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:05.803]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:05.803]                       envir = envir)
[16:06:05.803]                     if (!future$lazy) 
[16:06:05.803]                       future <- run(future)
[16:06:05.803]                     invisible(future)
[16:06:05.803]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:05.803]                 }
[16:06:05.803]             }
[16:06:05.803]         }
[16:06:05.803]     })
[16:06:05.803]     if (TRUE) {
[16:06:05.803]         base::sink(type = "output", split = FALSE)
[16:06:05.803]         if (TRUE) {
[16:06:05.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:05.803]         }
[16:06:05.803]         else {
[16:06:05.803]             ...future.result["stdout"] <- base::list(NULL)
[16:06:05.803]         }
[16:06:05.803]         base::close(...future.stdout)
[16:06:05.803]         ...future.stdout <- NULL
[16:06:05.803]     }
[16:06:05.803]     ...future.result$conditions <- ...future.conditions
[16:06:05.803]     ...future.result$finished <- base::Sys.time()
[16:06:05.803]     ...future.result
[16:06:05.803] }
[16:06:05.806] MultisessionFuture started
[16:06:05.806] - Launch lazy future ... done
[16:06:05.806] run() for ‘MultisessionFuture’ ... done
[16:06:06.353] receiveMessageFromWorker() for ClusterFuture ...
[16:06:06.353] - Validating connection of MultisessionFuture
[16:06:06.354] - received message: FutureResult
[16:06:06.354] - Received FutureResult
[16:06:06.354] - Erased future from FutureRegistry
[16:06:06.354] result() for ClusterFuture ...
[16:06:06.354] - result already collected: FutureResult
[16:06:06.354] result() for ClusterFuture ... done
[16:06:06.354] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:06.354] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[16:06:06.355] getGlobalsAndPackages() ...
[16:06:06.355] Searching for globals...
[16:06:06.355] - globals found: [2] ‘list’, ‘stop’
[16:06:06.355] Searching for globals ... DONE
[16:06:06.356] Resolving globals: FALSE
[16:06:06.356] 
[16:06:06.356] 
[16:06:06.356] getGlobalsAndPackages() ... DONE
[16:06:06.356] run() for ‘Future’ ...
[16:06:06.356] - state: ‘created’
[16:06:06.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:06.370] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:06.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:06.370]   - Field: ‘node’
[16:06:06.370]   - Field: ‘label’
[16:06:06.371]   - Field: ‘local’
[16:06:06.371]   - Field: ‘owner’
[16:06:06.371]   - Field: ‘envir’
[16:06:06.371]   - Field: ‘workers’
[16:06:06.371]   - Field: ‘packages’
[16:06:06.371]   - Field: ‘gc’
[16:06:06.371]   - Field: ‘conditions’
[16:06:06.371]   - Field: ‘persistent’
[16:06:06.371]   - Field: ‘expr’
[16:06:06.371]   - Field: ‘uuid’
[16:06:06.372]   - Field: ‘seed’
[16:06:06.372]   - Field: ‘version’
[16:06:06.372]   - Field: ‘result’
[16:06:06.372]   - Field: ‘asynchronous’
[16:06:06.372]   - Field: ‘calls’
[16:06:06.372]   - Field: ‘globals’
[16:06:06.372]   - Field: ‘stdout’
[16:06:06.372]   - Field: ‘earlySignal’
[16:06:06.372]   - Field: ‘lazy’
[16:06:06.372]   - Field: ‘state’
[16:06:06.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:06.373] - Launch lazy future ...
[16:06:06.373] Packages needed by the future expression (n = 0): <none>
[16:06:06.373] Packages needed by future strategies (n = 0): <none>
[16:06:06.373] {
[16:06:06.373]     {
[16:06:06.373]         {
[16:06:06.373]             ...future.startTime <- base::Sys.time()
[16:06:06.373]             {
[16:06:06.373]                 {
[16:06:06.373]                   {
[16:06:06.373]                     {
[16:06:06.373]                       base::local({
[16:06:06.373]                         has_future <- base::requireNamespace("future", 
[16:06:06.373]                           quietly = TRUE)
[16:06:06.373]                         if (has_future) {
[16:06:06.373]                           ns <- base::getNamespace("future")
[16:06:06.373]                           version <- ns[[".package"]][["version"]]
[16:06:06.373]                           if (is.null(version)) 
[16:06:06.373]                             version <- utils::packageVersion("future")
[16:06:06.373]                         }
[16:06:06.373]                         else {
[16:06:06.373]                           version <- NULL
[16:06:06.373]                         }
[16:06:06.373]                         if (!has_future || version < "1.8.0") {
[16:06:06.373]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:06.373]                             "", base::R.version$version.string), 
[16:06:06.373]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:06.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:06.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:06.373]                               "release", "version")], collapse = " "), 
[16:06:06.373]                             hostname = base::Sys.info()[["nodename"]])
[16:06:06.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:06.373]                             info)
[16:06:06.373]                           info <- base::paste(info, collapse = "; ")
[16:06:06.373]                           if (!has_future) {
[16:06:06.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:06.373]                               info)
[16:06:06.373]                           }
[16:06:06.373]                           else {
[16:06:06.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:06.373]                               info, version)
[16:06:06.373]                           }
[16:06:06.373]                           base::stop(msg)
[16:06:06.373]                         }
[16:06:06.373]                       })
[16:06:06.373]                     }
[16:06:06.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:06.373]                     base::options(mc.cores = 1L)
[16:06:06.373]                   }
[16:06:06.373]                   options(future.plan = NULL)
[16:06:06.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:06.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:06.373]                 }
[16:06:06.373]                 ...future.workdir <- getwd()
[16:06:06.373]             }
[16:06:06.373]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:06.373]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:06.373]         }
[16:06:06.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:06.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:06.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:06.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:06.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:06.373]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:06.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:06.373]             base::names(...future.oldOptions))
[16:06:06.373]     }
[16:06:06.373]     if (FALSE) {
[16:06:06.373]     }
[16:06:06.373]     else {
[16:06:06.373]         if (TRUE) {
[16:06:06.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:06.373]                 open = "w")
[16:06:06.373]         }
[16:06:06.373]         else {
[16:06:06.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:06.373]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:06.373]         }
[16:06:06.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:06.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:06.373]             base::sink(type = "output", split = FALSE)
[16:06:06.373]             base::close(...future.stdout)
[16:06:06.373]         }, add = TRUE)
[16:06:06.373]     }
[16:06:06.373]     ...future.frame <- base::sys.nframe()
[16:06:06.373]     ...future.conditions <- base::list()
[16:06:06.373]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:06.373]     if (FALSE) {
[16:06:06.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:06.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:06.373]     }
[16:06:06.373]     ...future.result <- base::tryCatch({
[16:06:06.373]         base::withCallingHandlers({
[16:06:06.373]             ...future.value <- base::withVisible(base::local({
[16:06:06.373]                 ...future.makeSendCondition <- base::local({
[16:06:06.373]                   sendCondition <- NULL
[16:06:06.373]                   function(frame = 1L) {
[16:06:06.373]                     if (is.function(sendCondition)) 
[16:06:06.373]                       return(sendCondition)
[16:06:06.373]                     ns <- getNamespace("parallel")
[16:06:06.373]                     if (exists("sendData", mode = "function", 
[16:06:06.373]                       envir = ns)) {
[16:06:06.373]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:06.373]                         envir = ns)
[16:06:06.373]                       envir <- sys.frame(frame)
[16:06:06.373]                       master <- NULL
[16:06:06.373]                       while (!identical(envir, .GlobalEnv) && 
[16:06:06.373]                         !identical(envir, emptyenv())) {
[16:06:06.373]                         if (exists("master", mode = "list", envir = envir, 
[16:06:06.373]                           inherits = FALSE)) {
[16:06:06.373]                           master <- get("master", mode = "list", 
[16:06:06.373]                             envir = envir, inherits = FALSE)
[16:06:06.373]                           if (inherits(master, c("SOCKnode", 
[16:06:06.373]                             "SOCK0node"))) {
[16:06:06.373]                             sendCondition <<- function(cond) {
[16:06:06.373]                               data <- list(type = "VALUE", value = cond, 
[16:06:06.373]                                 success = TRUE)
[16:06:06.373]                               parallel_sendData(master, data)
[16:06:06.373]                             }
[16:06:06.373]                             return(sendCondition)
[16:06:06.373]                           }
[16:06:06.373]                         }
[16:06:06.373]                         frame <- frame + 1L
[16:06:06.373]                         envir <- sys.frame(frame)
[16:06:06.373]                       }
[16:06:06.373]                     }
[16:06:06.373]                     sendCondition <<- function(cond) NULL
[16:06:06.373]                   }
[16:06:06.373]                 })
[16:06:06.373]                 withCallingHandlers({
[16:06:06.373]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:06.373]                 }, immediateCondition = function(cond) {
[16:06:06.373]                   sendCondition <- ...future.makeSendCondition()
[16:06:06.373]                   sendCondition(cond)
[16:06:06.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.373]                   {
[16:06:06.373]                     inherits <- base::inherits
[16:06:06.373]                     invokeRestart <- base::invokeRestart
[16:06:06.373]                     is.null <- base::is.null
[16:06:06.373]                     muffled <- FALSE
[16:06:06.373]                     if (inherits(cond, "message")) {
[16:06:06.373]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:06.373]                       if (muffled) 
[16:06:06.373]                         invokeRestart("muffleMessage")
[16:06:06.373]                     }
[16:06:06.373]                     else if (inherits(cond, "warning")) {
[16:06:06.373]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:06.373]                       if (muffled) 
[16:06:06.373]                         invokeRestart("muffleWarning")
[16:06:06.373]                     }
[16:06:06.373]                     else if (inherits(cond, "condition")) {
[16:06:06.373]                       if (!is.null(pattern)) {
[16:06:06.373]                         computeRestarts <- base::computeRestarts
[16:06:06.373]                         grepl <- base::grepl
[16:06:06.373]                         restarts <- computeRestarts(cond)
[16:06:06.373]                         for (restart in restarts) {
[16:06:06.373]                           name <- restart$name
[16:06:06.373]                           if (is.null(name)) 
[16:06:06.373]                             next
[16:06:06.373]                           if (!grepl(pattern, name)) 
[16:06:06.373]                             next
[16:06:06.373]                           invokeRestart(restart)
[16:06:06.373]                           muffled <- TRUE
[16:06:06.373]                           break
[16:06:06.373]                         }
[16:06:06.373]                       }
[16:06:06.373]                     }
[16:06:06.373]                     invisible(muffled)
[16:06:06.373]                   }
[16:06:06.373]                   muffleCondition(cond)
[16:06:06.373]                 })
[16:06:06.373]             }))
[16:06:06.373]             future::FutureResult(value = ...future.value$value, 
[16:06:06.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:06.373]                   ...future.rng), globalenv = if (FALSE) 
[16:06:06.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:06.373]                     ...future.globalenv.names))
[16:06:06.373]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:06.373]         }, condition = base::local({
[16:06:06.373]             c <- base::c
[16:06:06.373]             inherits <- base::inherits
[16:06:06.373]             invokeRestart <- base::invokeRestart
[16:06:06.373]             length <- base::length
[16:06:06.373]             list <- base::list
[16:06:06.373]             seq.int <- base::seq.int
[16:06:06.373]             signalCondition <- base::signalCondition
[16:06:06.373]             sys.calls <- base::sys.calls
[16:06:06.373]             `[[` <- base::`[[`
[16:06:06.373]             `+` <- base::`+`
[16:06:06.373]             `<<-` <- base::`<<-`
[16:06:06.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:06.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:06.373]                   3L)]
[16:06:06.373]             }
[16:06:06.373]             function(cond) {
[16:06:06.373]                 is_error <- inherits(cond, "error")
[16:06:06.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:06.373]                   NULL)
[16:06:06.373]                 if (is_error) {
[16:06:06.373]                   sessionInformation <- function() {
[16:06:06.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:06.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:06.373]                       search = base::search(), system = base::Sys.info())
[16:06:06.373]                   }
[16:06:06.373]                   ...future.conditions[[length(...future.conditions) + 
[16:06:06.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:06.373]                     cond$call), session = sessionInformation(), 
[16:06:06.373]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:06.373]                   signalCondition(cond)
[16:06:06.373]                 }
[16:06:06.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:06.373]                 "immediateCondition"))) {
[16:06:06.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:06.373]                   ...future.conditions[[length(...future.conditions) + 
[16:06:06.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:06.373]                   if (TRUE && !signal) {
[16:06:06.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.373]                     {
[16:06:06.373]                       inherits <- base::inherits
[16:06:06.373]                       invokeRestart <- base::invokeRestart
[16:06:06.373]                       is.null <- base::is.null
[16:06:06.373]                       muffled <- FALSE
[16:06:06.373]                       if (inherits(cond, "message")) {
[16:06:06.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:06.373]                         if (muffled) 
[16:06:06.373]                           invokeRestart("muffleMessage")
[16:06:06.373]                       }
[16:06:06.373]                       else if (inherits(cond, "warning")) {
[16:06:06.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:06.373]                         if (muffled) 
[16:06:06.373]                           invokeRestart("muffleWarning")
[16:06:06.373]                       }
[16:06:06.373]                       else if (inherits(cond, "condition")) {
[16:06:06.373]                         if (!is.null(pattern)) {
[16:06:06.373]                           computeRestarts <- base::computeRestarts
[16:06:06.373]                           grepl <- base::grepl
[16:06:06.373]                           restarts <- computeRestarts(cond)
[16:06:06.373]                           for (restart in restarts) {
[16:06:06.373]                             name <- restart$name
[16:06:06.373]                             if (is.null(name)) 
[16:06:06.373]                               next
[16:06:06.373]                             if (!grepl(pattern, name)) 
[16:06:06.373]                               next
[16:06:06.373]                             invokeRestart(restart)
[16:06:06.373]                             muffled <- TRUE
[16:06:06.373]                             break
[16:06:06.373]                           }
[16:06:06.373]                         }
[16:06:06.373]                       }
[16:06:06.373]                       invisible(muffled)
[16:06:06.373]                     }
[16:06:06.373]                     muffleCondition(cond, pattern = "^muffle")
[16:06:06.373]                   }
[16:06:06.373]                 }
[16:06:06.373]                 else {
[16:06:06.373]                   if (TRUE) {
[16:06:06.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.373]                     {
[16:06:06.373]                       inherits <- base::inherits
[16:06:06.373]                       invokeRestart <- base::invokeRestart
[16:06:06.373]                       is.null <- base::is.null
[16:06:06.373]                       muffled <- FALSE
[16:06:06.373]                       if (inherits(cond, "message")) {
[16:06:06.373]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:06.373]                         if (muffled) 
[16:06:06.373]                           invokeRestart("muffleMessage")
[16:06:06.373]                       }
[16:06:06.373]                       else if (inherits(cond, "warning")) {
[16:06:06.373]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:06.373]                         if (muffled) 
[16:06:06.373]                           invokeRestart("muffleWarning")
[16:06:06.373]                       }
[16:06:06.373]                       else if (inherits(cond, "condition")) {
[16:06:06.373]                         if (!is.null(pattern)) {
[16:06:06.373]                           computeRestarts <- base::computeRestarts
[16:06:06.373]                           grepl <- base::grepl
[16:06:06.373]                           restarts <- computeRestarts(cond)
[16:06:06.373]                           for (restart in restarts) {
[16:06:06.373]                             name <- restart$name
[16:06:06.373]                             if (is.null(name)) 
[16:06:06.373]                               next
[16:06:06.373]                             if (!grepl(pattern, name)) 
[16:06:06.373]                               next
[16:06:06.373]                             invokeRestart(restart)
[16:06:06.373]                             muffled <- TRUE
[16:06:06.373]                             break
[16:06:06.373]                           }
[16:06:06.373]                         }
[16:06:06.373]                       }
[16:06:06.373]                       invisible(muffled)
[16:06:06.373]                     }
[16:06:06.373]                     muffleCondition(cond, pattern = "^muffle")
[16:06:06.373]                   }
[16:06:06.373]                 }
[16:06:06.373]             }
[16:06:06.373]         }))
[16:06:06.373]     }, error = function(ex) {
[16:06:06.373]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:06.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:06.373]                 ...future.rng), started = ...future.startTime, 
[16:06:06.373]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:06.373]             version = "1.8"), class = "FutureResult")
[16:06:06.373]     }, finally = {
[16:06:06.373]         if (!identical(...future.workdir, getwd())) 
[16:06:06.373]             setwd(...future.workdir)
[16:06:06.373]         {
[16:06:06.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:06.373]                 ...future.oldOptions$nwarnings <- NULL
[16:06:06.373]             }
[16:06:06.373]             base::options(...future.oldOptions)
[16:06:06.373]             if (.Platform$OS.type == "windows") {
[16:06:06.373]                 old_names <- names(...future.oldEnvVars)
[16:06:06.373]                 envs <- base::Sys.getenv()
[16:06:06.373]                 names <- names(envs)
[16:06:06.373]                 common <- intersect(names, old_names)
[16:06:06.373]                 added <- setdiff(names, old_names)
[16:06:06.373]                 removed <- setdiff(old_names, names)
[16:06:06.373]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:06.373]                   envs[common]]
[16:06:06.373]                 NAMES <- toupper(changed)
[16:06:06.373]                 args <- list()
[16:06:06.373]                 for (kk in seq_along(NAMES)) {
[16:06:06.373]                   name <- changed[[kk]]
[16:06:06.373]                   NAME <- NAMES[[kk]]
[16:06:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.373]                     next
[16:06:06.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:06.373]                 }
[16:06:06.373]                 NAMES <- toupper(added)
[16:06:06.373]                 for (kk in seq_along(NAMES)) {
[16:06:06.373]                   name <- added[[kk]]
[16:06:06.373]                   NAME <- NAMES[[kk]]
[16:06:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.373]                     next
[16:06:06.373]                   args[[name]] <- ""
[16:06:06.373]                 }
[16:06:06.373]                 NAMES <- toupper(removed)
[16:06:06.373]                 for (kk in seq_along(NAMES)) {
[16:06:06.373]                   name <- removed[[kk]]
[16:06:06.373]                   NAME <- NAMES[[kk]]
[16:06:06.373]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.373]                     next
[16:06:06.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:06.373]                 }
[16:06:06.373]                 if (length(args) > 0) 
[16:06:06.373]                   base::do.call(base::Sys.setenv, args = args)
[16:06:06.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:06.373]             }
[16:06:06.373]             else {
[16:06:06.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:06.373]             }
[16:06:06.373]             {
[16:06:06.373]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:06.373]                   0L) {
[16:06:06.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:06.373]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:06.373]                   base::options(opts)
[16:06:06.373]                 }
[16:06:06.373]                 {
[16:06:06.373]                   {
[16:06:06.373]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:06.373]                     NULL
[16:06:06.373]                   }
[16:06:06.373]                   options(future.plan = NULL)
[16:06:06.373]                   if (is.na(NA_character_)) 
[16:06:06.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:06.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:06.373]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:06.373]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:06.373]                     envir = parent.frame()) 
[16:06:06.373]                   {
[16:06:06.373]                     if (is.function(workers)) 
[16:06:06.373]                       workers <- workers()
[16:06:06.373]                     workers <- structure(as.integer(workers), 
[16:06:06.373]                       class = class(workers))
[16:06:06.373]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:06.373]                       workers >= 1)
[16:06:06.373]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:06.373]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:06.373]                     }
[16:06:06.373]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:06.373]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:06.373]                       envir = envir)
[16:06:06.373]                     if (!future$lazy) 
[16:06:06.373]                       future <- run(future)
[16:06:06.373]                     invisible(future)
[16:06:06.373]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:06.373]                 }
[16:06:06.373]             }
[16:06:06.373]         }
[16:06:06.373]     })
[16:06:06.373]     if (TRUE) {
[16:06:06.373]         base::sink(type = "output", split = FALSE)
[16:06:06.373]         if (TRUE) {
[16:06:06.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:06.373]         }
[16:06:06.373]         else {
[16:06:06.373]             ...future.result["stdout"] <- base::list(NULL)
[16:06:06.373]         }
[16:06:06.373]         base::close(...future.stdout)
[16:06:06.373]         ...future.stdout <- NULL
[16:06:06.373]     }
[16:06:06.373]     ...future.result$conditions <- ...future.conditions
[16:06:06.373]     ...future.result$finished <- base::Sys.time()
[16:06:06.373]     ...future.result
[16:06:06.373] }
[16:06:06.377] MultisessionFuture started
[16:06:06.377] - Launch lazy future ... done
[16:06:06.377] run() for ‘MultisessionFuture’ ... done
[16:06:06.424] receiveMessageFromWorker() for ClusterFuture ...
[16:06:06.424] - Validating connection of MultisessionFuture
[16:06:06.425] - received message: FutureResult
[16:06:06.425] - Received FutureResult
[16:06:06.425] - Erased future from FutureRegistry
[16:06:06.425] result() for ClusterFuture ...
[16:06:06.425] - result already collected: FutureResult
[16:06:06.425] result() for ClusterFuture ... done
[16:06:06.425] signalConditions() ...
[16:06:06.426]  - include = ‘immediateCondition’
[16:06:06.426]  - exclude = 
[16:06:06.426]  - resignal = FALSE
[16:06:06.426]  - Number of conditions: 1
[16:06:06.426] signalConditions() ... done
[16:06:06.426] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:06.426] A MultisessionFuture was resolved (result was not collected)
[16:06:06.426] getGlobalsAndPackages() ...
[16:06:06.426] Searching for globals...
[16:06:06.427] - globals found: [2] ‘list’, ‘stop’
[16:06:06.427] Searching for globals ... DONE
[16:06:06.427] Resolving globals: FALSE
[16:06:06.428] 
[16:06:06.428] 
[16:06:06.428] getGlobalsAndPackages() ... DONE
[16:06:06.428] run() for ‘Future’ ...
[16:06:06.428] - state: ‘created’
[16:06:06.428] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:06.442] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:06.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:06.443]   - Field: ‘node’
[16:06:06.443]   - Field: ‘label’
[16:06:06.443]   - Field: ‘local’
[16:06:06.443]   - Field: ‘owner’
[16:06:06.443]   - Field: ‘envir’
[16:06:06.443]   - Field: ‘workers’
[16:06:06.443]   - Field: ‘packages’
[16:06:06.443]   - Field: ‘gc’
[16:06:06.443]   - Field: ‘conditions’
[16:06:06.443]   - Field: ‘persistent’
[16:06:06.444]   - Field: ‘expr’
[16:06:06.444]   - Field: ‘uuid’
[16:06:06.444]   - Field: ‘seed’
[16:06:06.444]   - Field: ‘version’
[16:06:06.444]   - Field: ‘result’
[16:06:06.444]   - Field: ‘asynchronous’
[16:06:06.444]   - Field: ‘calls’
[16:06:06.444]   - Field: ‘globals’
[16:06:06.444]   - Field: ‘stdout’
[16:06:06.444]   - Field: ‘earlySignal’
[16:06:06.444]   - Field: ‘lazy’
[16:06:06.445]   - Field: ‘state’
[16:06:06.445] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:06.445] - Launch lazy future ...
[16:06:06.445] Packages needed by the future expression (n = 0): <none>
[16:06:06.445] Packages needed by future strategies (n = 0): <none>
[16:06:06.446] {
[16:06:06.446]     {
[16:06:06.446]         {
[16:06:06.446]             ...future.startTime <- base::Sys.time()
[16:06:06.446]             {
[16:06:06.446]                 {
[16:06:06.446]                   {
[16:06:06.446]                     {
[16:06:06.446]                       base::local({
[16:06:06.446]                         has_future <- base::requireNamespace("future", 
[16:06:06.446]                           quietly = TRUE)
[16:06:06.446]                         if (has_future) {
[16:06:06.446]                           ns <- base::getNamespace("future")
[16:06:06.446]                           version <- ns[[".package"]][["version"]]
[16:06:06.446]                           if (is.null(version)) 
[16:06:06.446]                             version <- utils::packageVersion("future")
[16:06:06.446]                         }
[16:06:06.446]                         else {
[16:06:06.446]                           version <- NULL
[16:06:06.446]                         }
[16:06:06.446]                         if (!has_future || version < "1.8.0") {
[16:06:06.446]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:06.446]                             "", base::R.version$version.string), 
[16:06:06.446]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:06.446]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:06.446]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:06.446]                               "release", "version")], collapse = " "), 
[16:06:06.446]                             hostname = base::Sys.info()[["nodename"]])
[16:06:06.446]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:06.446]                             info)
[16:06:06.446]                           info <- base::paste(info, collapse = "; ")
[16:06:06.446]                           if (!has_future) {
[16:06:06.446]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:06.446]                               info)
[16:06:06.446]                           }
[16:06:06.446]                           else {
[16:06:06.446]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:06.446]                               info, version)
[16:06:06.446]                           }
[16:06:06.446]                           base::stop(msg)
[16:06:06.446]                         }
[16:06:06.446]                       })
[16:06:06.446]                     }
[16:06:06.446]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:06.446]                     base::options(mc.cores = 1L)
[16:06:06.446]                   }
[16:06:06.446]                   options(future.plan = NULL)
[16:06:06.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:06.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:06.446]                 }
[16:06:06.446]                 ...future.workdir <- getwd()
[16:06:06.446]             }
[16:06:06.446]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:06.446]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:06.446]         }
[16:06:06.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:06.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:06.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:06.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:06.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:06.446]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:06.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:06.446]             base::names(...future.oldOptions))
[16:06:06.446]     }
[16:06:06.446]     if (FALSE) {
[16:06:06.446]     }
[16:06:06.446]     else {
[16:06:06.446]         if (TRUE) {
[16:06:06.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:06.446]                 open = "w")
[16:06:06.446]         }
[16:06:06.446]         else {
[16:06:06.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:06.446]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:06.446]         }
[16:06:06.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:06.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:06.446]             base::sink(type = "output", split = FALSE)
[16:06:06.446]             base::close(...future.stdout)
[16:06:06.446]         }, add = TRUE)
[16:06:06.446]     }
[16:06:06.446]     ...future.frame <- base::sys.nframe()
[16:06:06.446]     ...future.conditions <- base::list()
[16:06:06.446]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:06.446]     if (FALSE) {
[16:06:06.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:06.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:06.446]     }
[16:06:06.446]     ...future.result <- base::tryCatch({
[16:06:06.446]         base::withCallingHandlers({
[16:06:06.446]             ...future.value <- base::withVisible(base::local({
[16:06:06.446]                 ...future.makeSendCondition <- base::local({
[16:06:06.446]                   sendCondition <- NULL
[16:06:06.446]                   function(frame = 1L) {
[16:06:06.446]                     if (is.function(sendCondition)) 
[16:06:06.446]                       return(sendCondition)
[16:06:06.446]                     ns <- getNamespace("parallel")
[16:06:06.446]                     if (exists("sendData", mode = "function", 
[16:06:06.446]                       envir = ns)) {
[16:06:06.446]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:06.446]                         envir = ns)
[16:06:06.446]                       envir <- sys.frame(frame)
[16:06:06.446]                       master <- NULL
[16:06:06.446]                       while (!identical(envir, .GlobalEnv) && 
[16:06:06.446]                         !identical(envir, emptyenv())) {
[16:06:06.446]                         if (exists("master", mode = "list", envir = envir, 
[16:06:06.446]                           inherits = FALSE)) {
[16:06:06.446]                           master <- get("master", mode = "list", 
[16:06:06.446]                             envir = envir, inherits = FALSE)
[16:06:06.446]                           if (inherits(master, c("SOCKnode", 
[16:06:06.446]                             "SOCK0node"))) {
[16:06:06.446]                             sendCondition <<- function(cond) {
[16:06:06.446]                               data <- list(type = "VALUE", value = cond, 
[16:06:06.446]                                 success = TRUE)
[16:06:06.446]                               parallel_sendData(master, data)
[16:06:06.446]                             }
[16:06:06.446]                             return(sendCondition)
[16:06:06.446]                           }
[16:06:06.446]                         }
[16:06:06.446]                         frame <- frame + 1L
[16:06:06.446]                         envir <- sys.frame(frame)
[16:06:06.446]                       }
[16:06:06.446]                     }
[16:06:06.446]                     sendCondition <<- function(cond) NULL
[16:06:06.446]                   }
[16:06:06.446]                 })
[16:06:06.446]                 withCallingHandlers({
[16:06:06.446]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:06.446]                 }, immediateCondition = function(cond) {
[16:06:06.446]                   sendCondition <- ...future.makeSendCondition()
[16:06:06.446]                   sendCondition(cond)
[16:06:06.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.446]                   {
[16:06:06.446]                     inherits <- base::inherits
[16:06:06.446]                     invokeRestart <- base::invokeRestart
[16:06:06.446]                     is.null <- base::is.null
[16:06:06.446]                     muffled <- FALSE
[16:06:06.446]                     if (inherits(cond, "message")) {
[16:06:06.446]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:06.446]                       if (muffled) 
[16:06:06.446]                         invokeRestart("muffleMessage")
[16:06:06.446]                     }
[16:06:06.446]                     else if (inherits(cond, "warning")) {
[16:06:06.446]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:06.446]                       if (muffled) 
[16:06:06.446]                         invokeRestart("muffleWarning")
[16:06:06.446]                     }
[16:06:06.446]                     else if (inherits(cond, "condition")) {
[16:06:06.446]                       if (!is.null(pattern)) {
[16:06:06.446]                         computeRestarts <- base::computeRestarts
[16:06:06.446]                         grepl <- base::grepl
[16:06:06.446]                         restarts <- computeRestarts(cond)
[16:06:06.446]                         for (restart in restarts) {
[16:06:06.446]                           name <- restart$name
[16:06:06.446]                           if (is.null(name)) 
[16:06:06.446]                             next
[16:06:06.446]                           if (!grepl(pattern, name)) 
[16:06:06.446]                             next
[16:06:06.446]                           invokeRestart(restart)
[16:06:06.446]                           muffled <- TRUE
[16:06:06.446]                           break
[16:06:06.446]                         }
[16:06:06.446]                       }
[16:06:06.446]                     }
[16:06:06.446]                     invisible(muffled)
[16:06:06.446]                   }
[16:06:06.446]                   muffleCondition(cond)
[16:06:06.446]                 })
[16:06:06.446]             }))
[16:06:06.446]             future::FutureResult(value = ...future.value$value, 
[16:06:06.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:06.446]                   ...future.rng), globalenv = if (FALSE) 
[16:06:06.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:06.446]                     ...future.globalenv.names))
[16:06:06.446]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:06.446]         }, condition = base::local({
[16:06:06.446]             c <- base::c
[16:06:06.446]             inherits <- base::inherits
[16:06:06.446]             invokeRestart <- base::invokeRestart
[16:06:06.446]             length <- base::length
[16:06:06.446]             list <- base::list
[16:06:06.446]             seq.int <- base::seq.int
[16:06:06.446]             signalCondition <- base::signalCondition
[16:06:06.446]             sys.calls <- base::sys.calls
[16:06:06.446]             `[[` <- base::`[[`
[16:06:06.446]             `+` <- base::`+`
[16:06:06.446]             `<<-` <- base::`<<-`
[16:06:06.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:06.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:06.446]                   3L)]
[16:06:06.446]             }
[16:06:06.446]             function(cond) {
[16:06:06.446]                 is_error <- inherits(cond, "error")
[16:06:06.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:06.446]                   NULL)
[16:06:06.446]                 if (is_error) {
[16:06:06.446]                   sessionInformation <- function() {
[16:06:06.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:06.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:06.446]                       search = base::search(), system = base::Sys.info())
[16:06:06.446]                   }
[16:06:06.446]                   ...future.conditions[[length(...future.conditions) + 
[16:06:06.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:06.446]                     cond$call), session = sessionInformation(), 
[16:06:06.446]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:06.446]                   signalCondition(cond)
[16:06:06.446]                 }
[16:06:06.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:06.446]                 "immediateCondition"))) {
[16:06:06.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:06.446]                   ...future.conditions[[length(...future.conditions) + 
[16:06:06.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:06.446]                   if (TRUE && !signal) {
[16:06:06.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.446]                     {
[16:06:06.446]                       inherits <- base::inherits
[16:06:06.446]                       invokeRestart <- base::invokeRestart
[16:06:06.446]                       is.null <- base::is.null
[16:06:06.446]                       muffled <- FALSE
[16:06:06.446]                       if (inherits(cond, "message")) {
[16:06:06.446]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:06.446]                         if (muffled) 
[16:06:06.446]                           invokeRestart("muffleMessage")
[16:06:06.446]                       }
[16:06:06.446]                       else if (inherits(cond, "warning")) {
[16:06:06.446]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:06.446]                         if (muffled) 
[16:06:06.446]                           invokeRestart("muffleWarning")
[16:06:06.446]                       }
[16:06:06.446]                       else if (inherits(cond, "condition")) {
[16:06:06.446]                         if (!is.null(pattern)) {
[16:06:06.446]                           computeRestarts <- base::computeRestarts
[16:06:06.446]                           grepl <- base::grepl
[16:06:06.446]                           restarts <- computeRestarts(cond)
[16:06:06.446]                           for (restart in restarts) {
[16:06:06.446]                             name <- restart$name
[16:06:06.446]                             if (is.null(name)) 
[16:06:06.446]                               next
[16:06:06.446]                             if (!grepl(pattern, name)) 
[16:06:06.446]                               next
[16:06:06.446]                             invokeRestart(restart)
[16:06:06.446]                             muffled <- TRUE
[16:06:06.446]                             break
[16:06:06.446]                           }
[16:06:06.446]                         }
[16:06:06.446]                       }
[16:06:06.446]                       invisible(muffled)
[16:06:06.446]                     }
[16:06:06.446]                     muffleCondition(cond, pattern = "^muffle")
[16:06:06.446]                   }
[16:06:06.446]                 }
[16:06:06.446]                 else {
[16:06:06.446]                   if (TRUE) {
[16:06:06.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.446]                     {
[16:06:06.446]                       inherits <- base::inherits
[16:06:06.446]                       invokeRestart <- base::invokeRestart
[16:06:06.446]                       is.null <- base::is.null
[16:06:06.446]                       muffled <- FALSE
[16:06:06.446]                       if (inherits(cond, "message")) {
[16:06:06.446]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:06.446]                         if (muffled) 
[16:06:06.446]                           invokeRestart("muffleMessage")
[16:06:06.446]                       }
[16:06:06.446]                       else if (inherits(cond, "warning")) {
[16:06:06.446]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:06.446]                         if (muffled) 
[16:06:06.446]                           invokeRestart("muffleWarning")
[16:06:06.446]                       }
[16:06:06.446]                       else if (inherits(cond, "condition")) {
[16:06:06.446]                         if (!is.null(pattern)) {
[16:06:06.446]                           computeRestarts <- base::computeRestarts
[16:06:06.446]                           grepl <- base::grepl
[16:06:06.446]                           restarts <- computeRestarts(cond)
[16:06:06.446]                           for (restart in restarts) {
[16:06:06.446]                             name <- restart$name
[16:06:06.446]                             if (is.null(name)) 
[16:06:06.446]                               next
[16:06:06.446]                             if (!grepl(pattern, name)) 
[16:06:06.446]                               next
[16:06:06.446]                             invokeRestart(restart)
[16:06:06.446]                             muffled <- TRUE
[16:06:06.446]                             break
[16:06:06.446]                           }
[16:06:06.446]                         }
[16:06:06.446]                       }
[16:06:06.446]                       invisible(muffled)
[16:06:06.446]                     }
[16:06:06.446]                     muffleCondition(cond, pattern = "^muffle")
[16:06:06.446]                   }
[16:06:06.446]                 }
[16:06:06.446]             }
[16:06:06.446]         }))
[16:06:06.446]     }, error = function(ex) {
[16:06:06.446]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:06.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:06.446]                 ...future.rng), started = ...future.startTime, 
[16:06:06.446]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:06.446]             version = "1.8"), class = "FutureResult")
[16:06:06.446]     }, finally = {
[16:06:06.446]         if (!identical(...future.workdir, getwd())) 
[16:06:06.446]             setwd(...future.workdir)
[16:06:06.446]         {
[16:06:06.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:06.446]                 ...future.oldOptions$nwarnings <- NULL
[16:06:06.446]             }
[16:06:06.446]             base::options(...future.oldOptions)
[16:06:06.446]             if (.Platform$OS.type == "windows") {
[16:06:06.446]                 old_names <- names(...future.oldEnvVars)
[16:06:06.446]                 envs <- base::Sys.getenv()
[16:06:06.446]                 names <- names(envs)
[16:06:06.446]                 common <- intersect(names, old_names)
[16:06:06.446]                 added <- setdiff(names, old_names)
[16:06:06.446]                 removed <- setdiff(old_names, names)
[16:06:06.446]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:06.446]                   envs[common]]
[16:06:06.446]                 NAMES <- toupper(changed)
[16:06:06.446]                 args <- list()
[16:06:06.446]                 for (kk in seq_along(NAMES)) {
[16:06:06.446]                   name <- changed[[kk]]
[16:06:06.446]                   NAME <- NAMES[[kk]]
[16:06:06.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.446]                     next
[16:06:06.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:06.446]                 }
[16:06:06.446]                 NAMES <- toupper(added)
[16:06:06.446]                 for (kk in seq_along(NAMES)) {
[16:06:06.446]                   name <- added[[kk]]
[16:06:06.446]                   NAME <- NAMES[[kk]]
[16:06:06.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.446]                     next
[16:06:06.446]                   args[[name]] <- ""
[16:06:06.446]                 }
[16:06:06.446]                 NAMES <- toupper(removed)
[16:06:06.446]                 for (kk in seq_along(NAMES)) {
[16:06:06.446]                   name <- removed[[kk]]
[16:06:06.446]                   NAME <- NAMES[[kk]]
[16:06:06.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.446]                     next
[16:06:06.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:06.446]                 }
[16:06:06.446]                 if (length(args) > 0) 
[16:06:06.446]                   base::do.call(base::Sys.setenv, args = args)
[16:06:06.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:06.446]             }
[16:06:06.446]             else {
[16:06:06.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:06.446]             }
[16:06:06.446]             {
[16:06:06.446]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:06.446]                   0L) {
[16:06:06.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:06.446]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:06.446]                   base::options(opts)
[16:06:06.446]                 }
[16:06:06.446]                 {
[16:06:06.446]                   {
[16:06:06.446]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:06.446]                     NULL
[16:06:06.446]                   }
[16:06:06.446]                   options(future.plan = NULL)
[16:06:06.446]                   if (is.na(NA_character_)) 
[16:06:06.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:06.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:06.446]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:06.446]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:06.446]                     envir = parent.frame()) 
[16:06:06.446]                   {
[16:06:06.446]                     if (is.function(workers)) 
[16:06:06.446]                       workers <- workers()
[16:06:06.446]                     workers <- structure(as.integer(workers), 
[16:06:06.446]                       class = class(workers))
[16:06:06.446]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:06.446]                       workers >= 1)
[16:06:06.446]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:06.446]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:06.446]                     }
[16:06:06.446]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:06.446]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:06.446]                       envir = envir)
[16:06:06.446]                     if (!future$lazy) 
[16:06:06.446]                       future <- run(future)
[16:06:06.446]                     invisible(future)
[16:06:06.446]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:06.446]                 }
[16:06:06.446]             }
[16:06:06.446]         }
[16:06:06.446]     })
[16:06:06.446]     if (TRUE) {
[16:06:06.446]         base::sink(type = "output", split = FALSE)
[16:06:06.446]         if (TRUE) {
[16:06:06.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:06.446]         }
[16:06:06.446]         else {
[16:06:06.446]             ...future.result["stdout"] <- base::list(NULL)
[16:06:06.446]         }
[16:06:06.446]         base::close(...future.stdout)
[16:06:06.446]         ...future.stdout <- NULL
[16:06:06.446]     }
[16:06:06.446]     ...future.result$conditions <- ...future.conditions
[16:06:06.446]     ...future.result$finished <- base::Sys.time()
[16:06:06.446]     ...future.result
[16:06:06.446] }
[16:06:06.449] MultisessionFuture started
[16:06:06.449] - Launch lazy future ... done
[16:06:06.449] run() for ‘MultisessionFuture’ ... done
[16:06:06.496] receiveMessageFromWorker() for ClusterFuture ...
[16:06:06.496] - Validating connection of MultisessionFuture
[16:06:06.497] - received message: FutureResult
[16:06:06.497] - Received FutureResult
[16:06:06.497] - Erased future from FutureRegistry
[16:06:06.497] result() for ClusterFuture ...
[16:06:06.497] - result already collected: FutureResult
[16:06:06.497] result() for ClusterFuture ... done
[16:06:06.498] signalConditions() ...
[16:06:06.498]  - include = ‘immediateCondition’
[16:06:06.498]  - exclude = 
[16:06:06.498]  - resignal = FALSE
[16:06:06.498]  - Number of conditions: 1
[16:06:06.498] signalConditions() ... done
[16:06:06.498] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:06.498] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[16:06:06.498] getGlobalsAndPackages() ...
[16:06:06.499] Searching for globals...
[16:06:06.500] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:06.500] Searching for globals ... DONE
[16:06:06.500] Resolving globals: FALSE
[16:06:06.500] 
[16:06:06.500] 
[16:06:06.501] getGlobalsAndPackages() ... DONE
[16:06:06.501] run() for ‘Future’ ...
[16:06:06.501] - state: ‘created’
[16:06:06.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:06.515] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:06.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:06.515]   - Field: ‘node’
[16:06:06.515]   - Field: ‘label’
[16:06:06.516]   - Field: ‘local’
[16:06:06.516]   - Field: ‘owner’
[16:06:06.516]   - Field: ‘envir’
[16:06:06.516]   - Field: ‘workers’
[16:06:06.516]   - Field: ‘packages’
[16:06:06.516]   - Field: ‘gc’
[16:06:06.516]   - Field: ‘conditions’
[16:06:06.516]   - Field: ‘persistent’
[16:06:06.516]   - Field: ‘expr’
[16:06:06.516]   - Field: ‘uuid’
[16:06:06.516]   - Field: ‘seed’
[16:06:06.517]   - Field: ‘version’
[16:06:06.517]   - Field: ‘result’
[16:06:06.517]   - Field: ‘asynchronous’
[16:06:06.517]   - Field: ‘calls’
[16:06:06.517]   - Field: ‘globals’
[16:06:06.517]   - Field: ‘stdout’
[16:06:06.517]   - Field: ‘earlySignal’
[16:06:06.517]   - Field: ‘lazy’
[16:06:06.517]   - Field: ‘state’
[16:06:06.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:06.518] - Launch lazy future ...
[16:06:06.518] Packages needed by the future expression (n = 0): <none>
[16:06:06.518] Packages needed by future strategies (n = 0): <none>
[16:06:06.518] {
[16:06:06.518]     {
[16:06:06.518]         {
[16:06:06.518]             ...future.startTime <- base::Sys.time()
[16:06:06.518]             {
[16:06:06.518]                 {
[16:06:06.518]                   {
[16:06:06.518]                     {
[16:06:06.518]                       base::local({
[16:06:06.518]                         has_future <- base::requireNamespace("future", 
[16:06:06.518]                           quietly = TRUE)
[16:06:06.518]                         if (has_future) {
[16:06:06.518]                           ns <- base::getNamespace("future")
[16:06:06.518]                           version <- ns[[".package"]][["version"]]
[16:06:06.518]                           if (is.null(version)) 
[16:06:06.518]                             version <- utils::packageVersion("future")
[16:06:06.518]                         }
[16:06:06.518]                         else {
[16:06:06.518]                           version <- NULL
[16:06:06.518]                         }
[16:06:06.518]                         if (!has_future || version < "1.8.0") {
[16:06:06.518]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:06.518]                             "", base::R.version$version.string), 
[16:06:06.518]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:06.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:06.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:06.518]                               "release", "version")], collapse = " "), 
[16:06:06.518]                             hostname = base::Sys.info()[["nodename"]])
[16:06:06.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:06.518]                             info)
[16:06:06.518]                           info <- base::paste(info, collapse = "; ")
[16:06:06.518]                           if (!has_future) {
[16:06:06.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:06.518]                               info)
[16:06:06.518]                           }
[16:06:06.518]                           else {
[16:06:06.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:06.518]                               info, version)
[16:06:06.518]                           }
[16:06:06.518]                           base::stop(msg)
[16:06:06.518]                         }
[16:06:06.518]                       })
[16:06:06.518]                     }
[16:06:06.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:06.518]                     base::options(mc.cores = 1L)
[16:06:06.518]                   }
[16:06:06.518]                   options(future.plan = NULL)
[16:06:06.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:06.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:06.518]                 }
[16:06:06.518]                 ...future.workdir <- getwd()
[16:06:06.518]             }
[16:06:06.518]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:06.518]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:06.518]         }
[16:06:06.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:06.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:06.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:06.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:06.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:06.518]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:06.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:06.518]             base::names(...future.oldOptions))
[16:06:06.518]     }
[16:06:06.518]     if (FALSE) {
[16:06:06.518]     }
[16:06:06.518]     else {
[16:06:06.518]         if (TRUE) {
[16:06:06.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:06.518]                 open = "w")
[16:06:06.518]         }
[16:06:06.518]         else {
[16:06:06.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:06.518]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:06.518]         }
[16:06:06.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:06.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:06.518]             base::sink(type = "output", split = FALSE)
[16:06:06.518]             base::close(...future.stdout)
[16:06:06.518]         }, add = TRUE)
[16:06:06.518]     }
[16:06:06.518]     ...future.frame <- base::sys.nframe()
[16:06:06.518]     ...future.conditions <- base::list()
[16:06:06.518]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:06.518]     if (FALSE) {
[16:06:06.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:06.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:06.518]     }
[16:06:06.518]     ...future.result <- base::tryCatch({
[16:06:06.518]         base::withCallingHandlers({
[16:06:06.518]             ...future.value <- base::withVisible(base::local({
[16:06:06.518]                 ...future.makeSendCondition <- base::local({
[16:06:06.518]                   sendCondition <- NULL
[16:06:06.518]                   function(frame = 1L) {
[16:06:06.518]                     if (is.function(sendCondition)) 
[16:06:06.518]                       return(sendCondition)
[16:06:06.518]                     ns <- getNamespace("parallel")
[16:06:06.518]                     if (exists("sendData", mode = "function", 
[16:06:06.518]                       envir = ns)) {
[16:06:06.518]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:06.518]                         envir = ns)
[16:06:06.518]                       envir <- sys.frame(frame)
[16:06:06.518]                       master <- NULL
[16:06:06.518]                       while (!identical(envir, .GlobalEnv) && 
[16:06:06.518]                         !identical(envir, emptyenv())) {
[16:06:06.518]                         if (exists("master", mode = "list", envir = envir, 
[16:06:06.518]                           inherits = FALSE)) {
[16:06:06.518]                           master <- get("master", mode = "list", 
[16:06:06.518]                             envir = envir, inherits = FALSE)
[16:06:06.518]                           if (inherits(master, c("SOCKnode", 
[16:06:06.518]                             "SOCK0node"))) {
[16:06:06.518]                             sendCondition <<- function(cond) {
[16:06:06.518]                               data <- list(type = "VALUE", value = cond, 
[16:06:06.518]                                 success = TRUE)
[16:06:06.518]                               parallel_sendData(master, data)
[16:06:06.518]                             }
[16:06:06.518]                             return(sendCondition)
[16:06:06.518]                           }
[16:06:06.518]                         }
[16:06:06.518]                         frame <- frame + 1L
[16:06:06.518]                         envir <- sys.frame(frame)
[16:06:06.518]                       }
[16:06:06.518]                     }
[16:06:06.518]                     sendCondition <<- function(cond) NULL
[16:06:06.518]                   }
[16:06:06.518]                 })
[16:06:06.518]                 withCallingHandlers({
[16:06:06.518]                   {
[16:06:06.518]                     Sys.sleep(0.5)
[16:06:06.518]                     list(a = 1, b = 42L)
[16:06:06.518]                   }
[16:06:06.518]                 }, immediateCondition = function(cond) {
[16:06:06.518]                   sendCondition <- ...future.makeSendCondition()
[16:06:06.518]                   sendCondition(cond)
[16:06:06.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.518]                   {
[16:06:06.518]                     inherits <- base::inherits
[16:06:06.518]                     invokeRestart <- base::invokeRestart
[16:06:06.518]                     is.null <- base::is.null
[16:06:06.518]                     muffled <- FALSE
[16:06:06.518]                     if (inherits(cond, "message")) {
[16:06:06.518]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:06.518]                       if (muffled) 
[16:06:06.518]                         invokeRestart("muffleMessage")
[16:06:06.518]                     }
[16:06:06.518]                     else if (inherits(cond, "warning")) {
[16:06:06.518]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:06.518]                       if (muffled) 
[16:06:06.518]                         invokeRestart("muffleWarning")
[16:06:06.518]                     }
[16:06:06.518]                     else if (inherits(cond, "condition")) {
[16:06:06.518]                       if (!is.null(pattern)) {
[16:06:06.518]                         computeRestarts <- base::computeRestarts
[16:06:06.518]                         grepl <- base::grepl
[16:06:06.518]                         restarts <- computeRestarts(cond)
[16:06:06.518]                         for (restart in restarts) {
[16:06:06.518]                           name <- restart$name
[16:06:06.518]                           if (is.null(name)) 
[16:06:06.518]                             next
[16:06:06.518]                           if (!grepl(pattern, name)) 
[16:06:06.518]                             next
[16:06:06.518]                           invokeRestart(restart)
[16:06:06.518]                           muffled <- TRUE
[16:06:06.518]                           break
[16:06:06.518]                         }
[16:06:06.518]                       }
[16:06:06.518]                     }
[16:06:06.518]                     invisible(muffled)
[16:06:06.518]                   }
[16:06:06.518]                   muffleCondition(cond)
[16:06:06.518]                 })
[16:06:06.518]             }))
[16:06:06.518]             future::FutureResult(value = ...future.value$value, 
[16:06:06.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:06.518]                   ...future.rng), globalenv = if (FALSE) 
[16:06:06.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:06.518]                     ...future.globalenv.names))
[16:06:06.518]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:06.518]         }, condition = base::local({
[16:06:06.518]             c <- base::c
[16:06:06.518]             inherits <- base::inherits
[16:06:06.518]             invokeRestart <- base::invokeRestart
[16:06:06.518]             length <- base::length
[16:06:06.518]             list <- base::list
[16:06:06.518]             seq.int <- base::seq.int
[16:06:06.518]             signalCondition <- base::signalCondition
[16:06:06.518]             sys.calls <- base::sys.calls
[16:06:06.518]             `[[` <- base::`[[`
[16:06:06.518]             `+` <- base::`+`
[16:06:06.518]             `<<-` <- base::`<<-`
[16:06:06.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:06.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:06.518]                   3L)]
[16:06:06.518]             }
[16:06:06.518]             function(cond) {
[16:06:06.518]                 is_error <- inherits(cond, "error")
[16:06:06.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:06.518]                   NULL)
[16:06:06.518]                 if (is_error) {
[16:06:06.518]                   sessionInformation <- function() {
[16:06:06.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:06.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:06.518]                       search = base::search(), system = base::Sys.info())
[16:06:06.518]                   }
[16:06:06.518]                   ...future.conditions[[length(...future.conditions) + 
[16:06:06.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:06.518]                     cond$call), session = sessionInformation(), 
[16:06:06.518]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:06.518]                   signalCondition(cond)
[16:06:06.518]                 }
[16:06:06.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:06.518]                 "immediateCondition"))) {
[16:06:06.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:06.518]                   ...future.conditions[[length(...future.conditions) + 
[16:06:06.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:06.518]                   if (TRUE && !signal) {
[16:06:06.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.518]                     {
[16:06:06.518]                       inherits <- base::inherits
[16:06:06.518]                       invokeRestart <- base::invokeRestart
[16:06:06.518]                       is.null <- base::is.null
[16:06:06.518]                       muffled <- FALSE
[16:06:06.518]                       if (inherits(cond, "message")) {
[16:06:06.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:06.518]                         if (muffled) 
[16:06:06.518]                           invokeRestart("muffleMessage")
[16:06:06.518]                       }
[16:06:06.518]                       else if (inherits(cond, "warning")) {
[16:06:06.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:06.518]                         if (muffled) 
[16:06:06.518]                           invokeRestart("muffleWarning")
[16:06:06.518]                       }
[16:06:06.518]                       else if (inherits(cond, "condition")) {
[16:06:06.518]                         if (!is.null(pattern)) {
[16:06:06.518]                           computeRestarts <- base::computeRestarts
[16:06:06.518]                           grepl <- base::grepl
[16:06:06.518]                           restarts <- computeRestarts(cond)
[16:06:06.518]                           for (restart in restarts) {
[16:06:06.518]                             name <- restart$name
[16:06:06.518]                             if (is.null(name)) 
[16:06:06.518]                               next
[16:06:06.518]                             if (!grepl(pattern, name)) 
[16:06:06.518]                               next
[16:06:06.518]                             invokeRestart(restart)
[16:06:06.518]                             muffled <- TRUE
[16:06:06.518]                             break
[16:06:06.518]                           }
[16:06:06.518]                         }
[16:06:06.518]                       }
[16:06:06.518]                       invisible(muffled)
[16:06:06.518]                     }
[16:06:06.518]                     muffleCondition(cond, pattern = "^muffle")
[16:06:06.518]                   }
[16:06:06.518]                 }
[16:06:06.518]                 else {
[16:06:06.518]                   if (TRUE) {
[16:06:06.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:06.518]                     {
[16:06:06.518]                       inherits <- base::inherits
[16:06:06.518]                       invokeRestart <- base::invokeRestart
[16:06:06.518]                       is.null <- base::is.null
[16:06:06.518]                       muffled <- FALSE
[16:06:06.518]                       if (inherits(cond, "message")) {
[16:06:06.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:06.518]                         if (muffled) 
[16:06:06.518]                           invokeRestart("muffleMessage")
[16:06:06.518]                       }
[16:06:06.518]                       else if (inherits(cond, "warning")) {
[16:06:06.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:06.518]                         if (muffled) 
[16:06:06.518]                           invokeRestart("muffleWarning")
[16:06:06.518]                       }
[16:06:06.518]                       else if (inherits(cond, "condition")) {
[16:06:06.518]                         if (!is.null(pattern)) {
[16:06:06.518]                           computeRestarts <- base::computeRestarts
[16:06:06.518]                           grepl <- base::grepl
[16:06:06.518]                           restarts <- computeRestarts(cond)
[16:06:06.518]                           for (restart in restarts) {
[16:06:06.518]                             name <- restart$name
[16:06:06.518]                             if (is.null(name)) 
[16:06:06.518]                               next
[16:06:06.518]                             if (!grepl(pattern, name)) 
[16:06:06.518]                               next
[16:06:06.518]                             invokeRestart(restart)
[16:06:06.518]                             muffled <- TRUE
[16:06:06.518]                             break
[16:06:06.518]                           }
[16:06:06.518]                         }
[16:06:06.518]                       }
[16:06:06.518]                       invisible(muffled)
[16:06:06.518]                     }
[16:06:06.518]                     muffleCondition(cond, pattern = "^muffle")
[16:06:06.518]                   }
[16:06:06.518]                 }
[16:06:06.518]             }
[16:06:06.518]         }))
[16:06:06.518]     }, error = function(ex) {
[16:06:06.518]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:06.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:06.518]                 ...future.rng), started = ...future.startTime, 
[16:06:06.518]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:06.518]             version = "1.8"), class = "FutureResult")
[16:06:06.518]     }, finally = {
[16:06:06.518]         if (!identical(...future.workdir, getwd())) 
[16:06:06.518]             setwd(...future.workdir)
[16:06:06.518]         {
[16:06:06.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:06.518]                 ...future.oldOptions$nwarnings <- NULL
[16:06:06.518]             }
[16:06:06.518]             base::options(...future.oldOptions)
[16:06:06.518]             if (.Platform$OS.type == "windows") {
[16:06:06.518]                 old_names <- names(...future.oldEnvVars)
[16:06:06.518]                 envs <- base::Sys.getenv()
[16:06:06.518]                 names <- names(envs)
[16:06:06.518]                 common <- intersect(names, old_names)
[16:06:06.518]                 added <- setdiff(names, old_names)
[16:06:06.518]                 removed <- setdiff(old_names, names)
[16:06:06.518]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:06.518]                   envs[common]]
[16:06:06.518]                 NAMES <- toupper(changed)
[16:06:06.518]                 args <- list()
[16:06:06.518]                 for (kk in seq_along(NAMES)) {
[16:06:06.518]                   name <- changed[[kk]]
[16:06:06.518]                   NAME <- NAMES[[kk]]
[16:06:06.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.518]                     next
[16:06:06.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:06.518]                 }
[16:06:06.518]                 NAMES <- toupper(added)
[16:06:06.518]                 for (kk in seq_along(NAMES)) {
[16:06:06.518]                   name <- added[[kk]]
[16:06:06.518]                   NAME <- NAMES[[kk]]
[16:06:06.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.518]                     next
[16:06:06.518]                   args[[name]] <- ""
[16:06:06.518]                 }
[16:06:06.518]                 NAMES <- toupper(removed)
[16:06:06.518]                 for (kk in seq_along(NAMES)) {
[16:06:06.518]                   name <- removed[[kk]]
[16:06:06.518]                   NAME <- NAMES[[kk]]
[16:06:06.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:06.518]                     next
[16:06:06.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:06.518]                 }
[16:06:06.518]                 if (length(args) > 0) 
[16:06:06.518]                   base::do.call(base::Sys.setenv, args = args)
[16:06:06.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:06.518]             }
[16:06:06.518]             else {
[16:06:06.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:06.518]             }
[16:06:06.518]             {
[16:06:06.518]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:06.518]                   0L) {
[16:06:06.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:06.518]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:06.518]                   base::options(opts)
[16:06:06.518]                 }
[16:06:06.518]                 {
[16:06:06.518]                   {
[16:06:06.518]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:06.518]                     NULL
[16:06:06.518]                   }
[16:06:06.518]                   options(future.plan = NULL)
[16:06:06.518]                   if (is.na(NA_character_)) 
[16:06:06.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:06.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:06.518]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:06.518]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:06.518]                     envir = parent.frame()) 
[16:06:06.518]                   {
[16:06:06.518]                     if (is.function(workers)) 
[16:06:06.518]                       workers <- workers()
[16:06:06.518]                     workers <- structure(as.integer(workers), 
[16:06:06.518]                       class = class(workers))
[16:06:06.518]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:06.518]                       workers >= 1)
[16:06:06.518]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:06.518]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:06.518]                     }
[16:06:06.518]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:06.518]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:06.518]                       envir = envir)
[16:06:06.518]                     if (!future$lazy) 
[16:06:06.518]                       future <- run(future)
[16:06:06.518]                     invisible(future)
[16:06:06.518]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:06.518]                 }
[16:06:06.518]             }
[16:06:06.518]         }
[16:06:06.518]     })
[16:06:06.518]     if (TRUE) {
[16:06:06.518]         base::sink(type = "output", split = FALSE)
[16:06:06.518]         if (TRUE) {
[16:06:06.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:06.518]         }
[16:06:06.518]         else {
[16:06:06.518]             ...future.result["stdout"] <- base::list(NULL)
[16:06:06.518]         }
[16:06:06.518]         base::close(...future.stdout)
[16:06:06.518]         ...future.stdout <- NULL
[16:06:06.518]     }
[16:06:06.518]     ...future.result$conditions <- ...future.conditions
[16:06:06.518]     ...future.result$finished <- base::Sys.time()
[16:06:06.518]     ...future.result
[16:06:06.518] }
[16:06:06.522] MultisessionFuture started
[16:06:06.522] - Launch lazy future ... done
[16:06:06.522] run() for ‘MultisessionFuture’ ... done
[16:06:07.069] receiveMessageFromWorker() for ClusterFuture ...
[16:06:07.069] - Validating connection of MultisessionFuture
[16:06:07.069] - received message: FutureResult
[16:06:07.069] - Received FutureResult
[16:06:07.069] - Erased future from FutureRegistry
[16:06:07.070] result() for ClusterFuture ...
[16:06:07.070] - result already collected: FutureResult
[16:06:07.070] result() for ClusterFuture ... done
[16:06:07.070] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:07.070] A MultisessionFuture was resolved
[16:06:07.070] getGlobalsAndPackages() ...
[16:06:07.070] Searching for globals...
[16:06:07.071] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:07.071] Searching for globals ... DONE
[16:06:07.072] Resolving globals: FALSE
[16:06:07.072] 
[16:06:07.072] 
[16:06:07.072] getGlobalsAndPackages() ... DONE
[16:06:07.072] run() for ‘Future’ ...
[16:06:07.072] - state: ‘created’
[16:06:07.073] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:07.086] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:07.086] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:07.086]   - Field: ‘node’
[16:06:07.087]   - Field: ‘label’
[16:06:07.087]   - Field: ‘local’
[16:06:07.087]   - Field: ‘owner’
[16:06:07.087]   - Field: ‘envir’
[16:06:07.087]   - Field: ‘workers’
[16:06:07.087]   - Field: ‘packages’
[16:06:07.087]   - Field: ‘gc’
[16:06:07.087]   - Field: ‘conditions’
[16:06:07.087]   - Field: ‘persistent’
[16:06:07.087]   - Field: ‘expr’
[16:06:07.088]   - Field: ‘uuid’
[16:06:07.088]   - Field: ‘seed’
[16:06:07.088]   - Field: ‘version’
[16:06:07.088]   - Field: ‘result’
[16:06:07.088]   - Field: ‘asynchronous’
[16:06:07.088]   - Field: ‘calls’
[16:06:07.088]   - Field: ‘globals’
[16:06:07.088]   - Field: ‘stdout’
[16:06:07.088]   - Field: ‘earlySignal’
[16:06:07.088]   - Field: ‘lazy’
[16:06:07.088]   - Field: ‘state’
[16:06:07.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:07.089] - Launch lazy future ...
[16:06:07.089] Packages needed by the future expression (n = 0): <none>
[16:06:07.089] Packages needed by future strategies (n = 0): <none>
[16:06:07.089] {
[16:06:07.089]     {
[16:06:07.089]         {
[16:06:07.089]             ...future.startTime <- base::Sys.time()
[16:06:07.089]             {
[16:06:07.089]                 {
[16:06:07.089]                   {
[16:06:07.089]                     {
[16:06:07.089]                       base::local({
[16:06:07.089]                         has_future <- base::requireNamespace("future", 
[16:06:07.089]                           quietly = TRUE)
[16:06:07.089]                         if (has_future) {
[16:06:07.089]                           ns <- base::getNamespace("future")
[16:06:07.089]                           version <- ns[[".package"]][["version"]]
[16:06:07.089]                           if (is.null(version)) 
[16:06:07.089]                             version <- utils::packageVersion("future")
[16:06:07.089]                         }
[16:06:07.089]                         else {
[16:06:07.089]                           version <- NULL
[16:06:07.089]                         }
[16:06:07.089]                         if (!has_future || version < "1.8.0") {
[16:06:07.089]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:07.089]                             "", base::R.version$version.string), 
[16:06:07.089]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:07.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:07.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:07.089]                               "release", "version")], collapse = " "), 
[16:06:07.089]                             hostname = base::Sys.info()[["nodename"]])
[16:06:07.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:07.089]                             info)
[16:06:07.089]                           info <- base::paste(info, collapse = "; ")
[16:06:07.089]                           if (!has_future) {
[16:06:07.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:07.089]                               info)
[16:06:07.089]                           }
[16:06:07.089]                           else {
[16:06:07.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:07.089]                               info, version)
[16:06:07.089]                           }
[16:06:07.089]                           base::stop(msg)
[16:06:07.089]                         }
[16:06:07.089]                       })
[16:06:07.089]                     }
[16:06:07.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:07.089]                     base::options(mc.cores = 1L)
[16:06:07.089]                   }
[16:06:07.089]                   options(future.plan = NULL)
[16:06:07.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:07.089]                 }
[16:06:07.089]                 ...future.workdir <- getwd()
[16:06:07.089]             }
[16:06:07.089]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:07.089]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:07.089]         }
[16:06:07.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:07.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:07.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:07.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:07.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:07.089]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:07.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:07.089]             base::names(...future.oldOptions))
[16:06:07.089]     }
[16:06:07.089]     if (FALSE) {
[16:06:07.089]     }
[16:06:07.089]     else {
[16:06:07.089]         if (TRUE) {
[16:06:07.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:07.089]                 open = "w")
[16:06:07.089]         }
[16:06:07.089]         else {
[16:06:07.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:07.089]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:07.089]         }
[16:06:07.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:07.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:07.089]             base::sink(type = "output", split = FALSE)
[16:06:07.089]             base::close(...future.stdout)
[16:06:07.089]         }, add = TRUE)
[16:06:07.089]     }
[16:06:07.089]     ...future.frame <- base::sys.nframe()
[16:06:07.089]     ...future.conditions <- base::list()
[16:06:07.089]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:07.089]     if (FALSE) {
[16:06:07.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:07.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:07.089]     }
[16:06:07.089]     ...future.result <- base::tryCatch({
[16:06:07.089]         base::withCallingHandlers({
[16:06:07.089]             ...future.value <- base::withVisible(base::local({
[16:06:07.089]                 ...future.makeSendCondition <- base::local({
[16:06:07.089]                   sendCondition <- NULL
[16:06:07.089]                   function(frame = 1L) {
[16:06:07.089]                     if (is.function(sendCondition)) 
[16:06:07.089]                       return(sendCondition)
[16:06:07.089]                     ns <- getNamespace("parallel")
[16:06:07.089]                     if (exists("sendData", mode = "function", 
[16:06:07.089]                       envir = ns)) {
[16:06:07.089]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:07.089]                         envir = ns)
[16:06:07.089]                       envir <- sys.frame(frame)
[16:06:07.089]                       master <- NULL
[16:06:07.089]                       while (!identical(envir, .GlobalEnv) && 
[16:06:07.089]                         !identical(envir, emptyenv())) {
[16:06:07.089]                         if (exists("master", mode = "list", envir = envir, 
[16:06:07.089]                           inherits = FALSE)) {
[16:06:07.089]                           master <- get("master", mode = "list", 
[16:06:07.089]                             envir = envir, inherits = FALSE)
[16:06:07.089]                           if (inherits(master, c("SOCKnode", 
[16:06:07.089]                             "SOCK0node"))) {
[16:06:07.089]                             sendCondition <<- function(cond) {
[16:06:07.089]                               data <- list(type = "VALUE", value = cond, 
[16:06:07.089]                                 success = TRUE)
[16:06:07.089]                               parallel_sendData(master, data)
[16:06:07.089]                             }
[16:06:07.089]                             return(sendCondition)
[16:06:07.089]                           }
[16:06:07.089]                         }
[16:06:07.089]                         frame <- frame + 1L
[16:06:07.089]                         envir <- sys.frame(frame)
[16:06:07.089]                       }
[16:06:07.089]                     }
[16:06:07.089]                     sendCondition <<- function(cond) NULL
[16:06:07.089]                   }
[16:06:07.089]                 })
[16:06:07.089]                 withCallingHandlers({
[16:06:07.089]                   {
[16:06:07.089]                     Sys.sleep(0.5)
[16:06:07.089]                     list(a = 1, b = 42L)
[16:06:07.089]                   }
[16:06:07.089]                 }, immediateCondition = function(cond) {
[16:06:07.089]                   sendCondition <- ...future.makeSendCondition()
[16:06:07.089]                   sendCondition(cond)
[16:06:07.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.089]                   {
[16:06:07.089]                     inherits <- base::inherits
[16:06:07.089]                     invokeRestart <- base::invokeRestart
[16:06:07.089]                     is.null <- base::is.null
[16:06:07.089]                     muffled <- FALSE
[16:06:07.089]                     if (inherits(cond, "message")) {
[16:06:07.089]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:07.089]                       if (muffled) 
[16:06:07.089]                         invokeRestart("muffleMessage")
[16:06:07.089]                     }
[16:06:07.089]                     else if (inherits(cond, "warning")) {
[16:06:07.089]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:07.089]                       if (muffled) 
[16:06:07.089]                         invokeRestart("muffleWarning")
[16:06:07.089]                     }
[16:06:07.089]                     else if (inherits(cond, "condition")) {
[16:06:07.089]                       if (!is.null(pattern)) {
[16:06:07.089]                         computeRestarts <- base::computeRestarts
[16:06:07.089]                         grepl <- base::grepl
[16:06:07.089]                         restarts <- computeRestarts(cond)
[16:06:07.089]                         for (restart in restarts) {
[16:06:07.089]                           name <- restart$name
[16:06:07.089]                           if (is.null(name)) 
[16:06:07.089]                             next
[16:06:07.089]                           if (!grepl(pattern, name)) 
[16:06:07.089]                             next
[16:06:07.089]                           invokeRestart(restart)
[16:06:07.089]                           muffled <- TRUE
[16:06:07.089]                           break
[16:06:07.089]                         }
[16:06:07.089]                       }
[16:06:07.089]                     }
[16:06:07.089]                     invisible(muffled)
[16:06:07.089]                   }
[16:06:07.089]                   muffleCondition(cond)
[16:06:07.089]                 })
[16:06:07.089]             }))
[16:06:07.089]             future::FutureResult(value = ...future.value$value, 
[16:06:07.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.089]                   ...future.rng), globalenv = if (FALSE) 
[16:06:07.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:07.089]                     ...future.globalenv.names))
[16:06:07.089]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:07.089]         }, condition = base::local({
[16:06:07.089]             c <- base::c
[16:06:07.089]             inherits <- base::inherits
[16:06:07.089]             invokeRestart <- base::invokeRestart
[16:06:07.089]             length <- base::length
[16:06:07.089]             list <- base::list
[16:06:07.089]             seq.int <- base::seq.int
[16:06:07.089]             signalCondition <- base::signalCondition
[16:06:07.089]             sys.calls <- base::sys.calls
[16:06:07.089]             `[[` <- base::`[[`
[16:06:07.089]             `+` <- base::`+`
[16:06:07.089]             `<<-` <- base::`<<-`
[16:06:07.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:07.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:07.089]                   3L)]
[16:06:07.089]             }
[16:06:07.089]             function(cond) {
[16:06:07.089]                 is_error <- inherits(cond, "error")
[16:06:07.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:07.089]                   NULL)
[16:06:07.089]                 if (is_error) {
[16:06:07.089]                   sessionInformation <- function() {
[16:06:07.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:07.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:07.089]                       search = base::search(), system = base::Sys.info())
[16:06:07.089]                   }
[16:06:07.089]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:07.089]                     cond$call), session = sessionInformation(), 
[16:06:07.089]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:07.089]                   signalCondition(cond)
[16:06:07.089]                 }
[16:06:07.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:07.089]                 "immediateCondition"))) {
[16:06:07.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:07.089]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:07.089]                   if (TRUE && !signal) {
[16:06:07.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.089]                     {
[16:06:07.089]                       inherits <- base::inherits
[16:06:07.089]                       invokeRestart <- base::invokeRestart
[16:06:07.089]                       is.null <- base::is.null
[16:06:07.089]                       muffled <- FALSE
[16:06:07.089]                       if (inherits(cond, "message")) {
[16:06:07.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.089]                         if (muffled) 
[16:06:07.089]                           invokeRestart("muffleMessage")
[16:06:07.089]                       }
[16:06:07.089]                       else if (inherits(cond, "warning")) {
[16:06:07.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.089]                         if (muffled) 
[16:06:07.089]                           invokeRestart("muffleWarning")
[16:06:07.089]                       }
[16:06:07.089]                       else if (inherits(cond, "condition")) {
[16:06:07.089]                         if (!is.null(pattern)) {
[16:06:07.089]                           computeRestarts <- base::computeRestarts
[16:06:07.089]                           grepl <- base::grepl
[16:06:07.089]                           restarts <- computeRestarts(cond)
[16:06:07.089]                           for (restart in restarts) {
[16:06:07.089]                             name <- restart$name
[16:06:07.089]                             if (is.null(name)) 
[16:06:07.089]                               next
[16:06:07.089]                             if (!grepl(pattern, name)) 
[16:06:07.089]                               next
[16:06:07.089]                             invokeRestart(restart)
[16:06:07.089]                             muffled <- TRUE
[16:06:07.089]                             break
[16:06:07.089]                           }
[16:06:07.089]                         }
[16:06:07.089]                       }
[16:06:07.089]                       invisible(muffled)
[16:06:07.089]                     }
[16:06:07.089]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.089]                   }
[16:06:07.089]                 }
[16:06:07.089]                 else {
[16:06:07.089]                   if (TRUE) {
[16:06:07.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.089]                     {
[16:06:07.089]                       inherits <- base::inherits
[16:06:07.089]                       invokeRestart <- base::invokeRestart
[16:06:07.089]                       is.null <- base::is.null
[16:06:07.089]                       muffled <- FALSE
[16:06:07.089]                       if (inherits(cond, "message")) {
[16:06:07.089]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.089]                         if (muffled) 
[16:06:07.089]                           invokeRestart("muffleMessage")
[16:06:07.089]                       }
[16:06:07.089]                       else if (inherits(cond, "warning")) {
[16:06:07.089]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.089]                         if (muffled) 
[16:06:07.089]                           invokeRestart("muffleWarning")
[16:06:07.089]                       }
[16:06:07.089]                       else if (inherits(cond, "condition")) {
[16:06:07.089]                         if (!is.null(pattern)) {
[16:06:07.089]                           computeRestarts <- base::computeRestarts
[16:06:07.089]                           grepl <- base::grepl
[16:06:07.089]                           restarts <- computeRestarts(cond)
[16:06:07.089]                           for (restart in restarts) {
[16:06:07.089]                             name <- restart$name
[16:06:07.089]                             if (is.null(name)) 
[16:06:07.089]                               next
[16:06:07.089]                             if (!grepl(pattern, name)) 
[16:06:07.089]                               next
[16:06:07.089]                             invokeRestart(restart)
[16:06:07.089]                             muffled <- TRUE
[16:06:07.089]                             break
[16:06:07.089]                           }
[16:06:07.089]                         }
[16:06:07.089]                       }
[16:06:07.089]                       invisible(muffled)
[16:06:07.089]                     }
[16:06:07.089]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.089]                   }
[16:06:07.089]                 }
[16:06:07.089]             }
[16:06:07.089]         }))
[16:06:07.089]     }, error = function(ex) {
[16:06:07.089]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:07.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.089]                 ...future.rng), started = ...future.startTime, 
[16:06:07.089]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:07.089]             version = "1.8"), class = "FutureResult")
[16:06:07.089]     }, finally = {
[16:06:07.089]         if (!identical(...future.workdir, getwd())) 
[16:06:07.089]             setwd(...future.workdir)
[16:06:07.089]         {
[16:06:07.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:07.089]                 ...future.oldOptions$nwarnings <- NULL
[16:06:07.089]             }
[16:06:07.089]             base::options(...future.oldOptions)
[16:06:07.089]             if (.Platform$OS.type == "windows") {
[16:06:07.089]                 old_names <- names(...future.oldEnvVars)
[16:06:07.089]                 envs <- base::Sys.getenv()
[16:06:07.089]                 names <- names(envs)
[16:06:07.089]                 common <- intersect(names, old_names)
[16:06:07.089]                 added <- setdiff(names, old_names)
[16:06:07.089]                 removed <- setdiff(old_names, names)
[16:06:07.089]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:07.089]                   envs[common]]
[16:06:07.089]                 NAMES <- toupper(changed)
[16:06:07.089]                 args <- list()
[16:06:07.089]                 for (kk in seq_along(NAMES)) {
[16:06:07.089]                   name <- changed[[kk]]
[16:06:07.089]                   NAME <- NAMES[[kk]]
[16:06:07.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.089]                     next
[16:06:07.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.089]                 }
[16:06:07.089]                 NAMES <- toupper(added)
[16:06:07.089]                 for (kk in seq_along(NAMES)) {
[16:06:07.089]                   name <- added[[kk]]
[16:06:07.089]                   NAME <- NAMES[[kk]]
[16:06:07.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.089]                     next
[16:06:07.089]                   args[[name]] <- ""
[16:06:07.089]                 }
[16:06:07.089]                 NAMES <- toupper(removed)
[16:06:07.089]                 for (kk in seq_along(NAMES)) {
[16:06:07.089]                   name <- removed[[kk]]
[16:06:07.089]                   NAME <- NAMES[[kk]]
[16:06:07.089]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.089]                     next
[16:06:07.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.089]                 }
[16:06:07.089]                 if (length(args) > 0) 
[16:06:07.089]                   base::do.call(base::Sys.setenv, args = args)
[16:06:07.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:07.089]             }
[16:06:07.089]             else {
[16:06:07.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:07.089]             }
[16:06:07.089]             {
[16:06:07.089]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:07.089]                   0L) {
[16:06:07.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:07.089]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:07.089]                   base::options(opts)
[16:06:07.089]                 }
[16:06:07.089]                 {
[16:06:07.089]                   {
[16:06:07.089]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:07.089]                     NULL
[16:06:07.089]                   }
[16:06:07.089]                   options(future.plan = NULL)
[16:06:07.089]                   if (is.na(NA_character_)) 
[16:06:07.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:07.089]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:07.089]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:07.089]                     envir = parent.frame()) 
[16:06:07.089]                   {
[16:06:07.089]                     if (is.function(workers)) 
[16:06:07.089]                       workers <- workers()
[16:06:07.089]                     workers <- structure(as.integer(workers), 
[16:06:07.089]                       class = class(workers))
[16:06:07.089]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:07.089]                       workers >= 1)
[16:06:07.089]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:07.089]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:07.089]                     }
[16:06:07.089]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:07.089]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:07.089]                       envir = envir)
[16:06:07.089]                     if (!future$lazy) 
[16:06:07.089]                       future <- run(future)
[16:06:07.089]                     invisible(future)
[16:06:07.089]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:07.089]                 }
[16:06:07.089]             }
[16:06:07.089]         }
[16:06:07.089]     })
[16:06:07.089]     if (TRUE) {
[16:06:07.089]         base::sink(type = "output", split = FALSE)
[16:06:07.089]         if (TRUE) {
[16:06:07.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:07.089]         }
[16:06:07.089]         else {
[16:06:07.089]             ...future.result["stdout"] <- base::list(NULL)
[16:06:07.089]         }
[16:06:07.089]         base::close(...future.stdout)
[16:06:07.089]         ...future.stdout <- NULL
[16:06:07.089]     }
[16:06:07.089]     ...future.result$conditions <- ...future.conditions
[16:06:07.089]     ...future.result$finished <- base::Sys.time()
[16:06:07.089]     ...future.result
[16:06:07.089] }
[16:06:07.093] MultisessionFuture started
[16:06:07.093] - Launch lazy future ... done
[16:06:07.093] run() for ‘MultisessionFuture’ ... done
[16:06:07.651] receiveMessageFromWorker() for ClusterFuture ...
[16:06:07.651] - Validating connection of MultisessionFuture
[16:06:07.651] - received message: FutureResult
[16:06:07.651] - Received FutureResult
[16:06:07.652] - Erased future from FutureRegistry
[16:06:07.652] result() for ClusterFuture ...
[16:06:07.652] - result already collected: FutureResult
[16:06:07.652] result() for ClusterFuture ... done
[16:06:07.652] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:07.652] A MultisessionFuture was resolved
- w/ exception ...
[16:06:07.652] getGlobalsAndPackages() ...
[16:06:07.652] Searching for globals...
[16:06:07.653] - globals found: [2] ‘list’, ‘stop’
[16:06:07.653] Searching for globals ... DONE
[16:06:07.653] Resolving globals: FALSE
[16:06:07.654] 
[16:06:07.654] 
[16:06:07.654] getGlobalsAndPackages() ... DONE
[16:06:07.654] run() for ‘Future’ ...
[16:06:07.654] - state: ‘created’
[16:06:07.654] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:07.668] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:07.668] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:07.668]   - Field: ‘node’
[16:06:07.668]   - Field: ‘label’
[16:06:07.668]   - Field: ‘local’
[16:06:07.668]   - Field: ‘owner’
[16:06:07.668]   - Field: ‘envir’
[16:06:07.669]   - Field: ‘workers’
[16:06:07.669]   - Field: ‘packages’
[16:06:07.669]   - Field: ‘gc’
[16:06:07.669]   - Field: ‘conditions’
[16:06:07.669]   - Field: ‘persistent’
[16:06:07.669]   - Field: ‘expr’
[16:06:07.669]   - Field: ‘uuid’
[16:06:07.669]   - Field: ‘seed’
[16:06:07.669]   - Field: ‘version’
[16:06:07.669]   - Field: ‘result’
[16:06:07.669]   - Field: ‘asynchronous’
[16:06:07.670]   - Field: ‘calls’
[16:06:07.670]   - Field: ‘globals’
[16:06:07.670]   - Field: ‘stdout’
[16:06:07.670]   - Field: ‘earlySignal’
[16:06:07.670]   - Field: ‘lazy’
[16:06:07.670]   - Field: ‘state’
[16:06:07.670] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:07.670] - Launch lazy future ...
[16:06:07.670] Packages needed by the future expression (n = 0): <none>
[16:06:07.671] Packages needed by future strategies (n = 0): <none>
[16:06:07.671] {
[16:06:07.671]     {
[16:06:07.671]         {
[16:06:07.671]             ...future.startTime <- base::Sys.time()
[16:06:07.671]             {
[16:06:07.671]                 {
[16:06:07.671]                   {
[16:06:07.671]                     {
[16:06:07.671]                       base::local({
[16:06:07.671]                         has_future <- base::requireNamespace("future", 
[16:06:07.671]                           quietly = TRUE)
[16:06:07.671]                         if (has_future) {
[16:06:07.671]                           ns <- base::getNamespace("future")
[16:06:07.671]                           version <- ns[[".package"]][["version"]]
[16:06:07.671]                           if (is.null(version)) 
[16:06:07.671]                             version <- utils::packageVersion("future")
[16:06:07.671]                         }
[16:06:07.671]                         else {
[16:06:07.671]                           version <- NULL
[16:06:07.671]                         }
[16:06:07.671]                         if (!has_future || version < "1.8.0") {
[16:06:07.671]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:07.671]                             "", base::R.version$version.string), 
[16:06:07.671]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:07.671]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:07.671]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:07.671]                               "release", "version")], collapse = " "), 
[16:06:07.671]                             hostname = base::Sys.info()[["nodename"]])
[16:06:07.671]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:07.671]                             info)
[16:06:07.671]                           info <- base::paste(info, collapse = "; ")
[16:06:07.671]                           if (!has_future) {
[16:06:07.671]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:07.671]                               info)
[16:06:07.671]                           }
[16:06:07.671]                           else {
[16:06:07.671]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:07.671]                               info, version)
[16:06:07.671]                           }
[16:06:07.671]                           base::stop(msg)
[16:06:07.671]                         }
[16:06:07.671]                       })
[16:06:07.671]                     }
[16:06:07.671]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:07.671]                     base::options(mc.cores = 1L)
[16:06:07.671]                   }
[16:06:07.671]                   options(future.plan = NULL)
[16:06:07.671]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.671]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:07.671]                 }
[16:06:07.671]                 ...future.workdir <- getwd()
[16:06:07.671]             }
[16:06:07.671]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:07.671]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:07.671]         }
[16:06:07.671]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:07.671]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:07.671]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:07.671]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:07.671]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:07.671]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:07.671]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:07.671]             base::names(...future.oldOptions))
[16:06:07.671]     }
[16:06:07.671]     if (FALSE) {
[16:06:07.671]     }
[16:06:07.671]     else {
[16:06:07.671]         if (TRUE) {
[16:06:07.671]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:07.671]                 open = "w")
[16:06:07.671]         }
[16:06:07.671]         else {
[16:06:07.671]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:07.671]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:07.671]         }
[16:06:07.671]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:07.671]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:07.671]             base::sink(type = "output", split = FALSE)
[16:06:07.671]             base::close(...future.stdout)
[16:06:07.671]         }, add = TRUE)
[16:06:07.671]     }
[16:06:07.671]     ...future.frame <- base::sys.nframe()
[16:06:07.671]     ...future.conditions <- base::list()
[16:06:07.671]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:07.671]     if (FALSE) {
[16:06:07.671]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:07.671]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:07.671]     }
[16:06:07.671]     ...future.result <- base::tryCatch({
[16:06:07.671]         base::withCallingHandlers({
[16:06:07.671]             ...future.value <- base::withVisible(base::local({
[16:06:07.671]                 ...future.makeSendCondition <- base::local({
[16:06:07.671]                   sendCondition <- NULL
[16:06:07.671]                   function(frame = 1L) {
[16:06:07.671]                     if (is.function(sendCondition)) 
[16:06:07.671]                       return(sendCondition)
[16:06:07.671]                     ns <- getNamespace("parallel")
[16:06:07.671]                     if (exists("sendData", mode = "function", 
[16:06:07.671]                       envir = ns)) {
[16:06:07.671]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:07.671]                         envir = ns)
[16:06:07.671]                       envir <- sys.frame(frame)
[16:06:07.671]                       master <- NULL
[16:06:07.671]                       while (!identical(envir, .GlobalEnv) && 
[16:06:07.671]                         !identical(envir, emptyenv())) {
[16:06:07.671]                         if (exists("master", mode = "list", envir = envir, 
[16:06:07.671]                           inherits = FALSE)) {
[16:06:07.671]                           master <- get("master", mode = "list", 
[16:06:07.671]                             envir = envir, inherits = FALSE)
[16:06:07.671]                           if (inherits(master, c("SOCKnode", 
[16:06:07.671]                             "SOCK0node"))) {
[16:06:07.671]                             sendCondition <<- function(cond) {
[16:06:07.671]                               data <- list(type = "VALUE", value = cond, 
[16:06:07.671]                                 success = TRUE)
[16:06:07.671]                               parallel_sendData(master, data)
[16:06:07.671]                             }
[16:06:07.671]                             return(sendCondition)
[16:06:07.671]                           }
[16:06:07.671]                         }
[16:06:07.671]                         frame <- frame + 1L
[16:06:07.671]                         envir <- sys.frame(frame)
[16:06:07.671]                       }
[16:06:07.671]                     }
[16:06:07.671]                     sendCondition <<- function(cond) NULL
[16:06:07.671]                   }
[16:06:07.671]                 })
[16:06:07.671]                 withCallingHandlers({
[16:06:07.671]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:07.671]                 }, immediateCondition = function(cond) {
[16:06:07.671]                   sendCondition <- ...future.makeSendCondition()
[16:06:07.671]                   sendCondition(cond)
[16:06:07.671]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.671]                   {
[16:06:07.671]                     inherits <- base::inherits
[16:06:07.671]                     invokeRestart <- base::invokeRestart
[16:06:07.671]                     is.null <- base::is.null
[16:06:07.671]                     muffled <- FALSE
[16:06:07.671]                     if (inherits(cond, "message")) {
[16:06:07.671]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:07.671]                       if (muffled) 
[16:06:07.671]                         invokeRestart("muffleMessage")
[16:06:07.671]                     }
[16:06:07.671]                     else if (inherits(cond, "warning")) {
[16:06:07.671]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:07.671]                       if (muffled) 
[16:06:07.671]                         invokeRestart("muffleWarning")
[16:06:07.671]                     }
[16:06:07.671]                     else if (inherits(cond, "condition")) {
[16:06:07.671]                       if (!is.null(pattern)) {
[16:06:07.671]                         computeRestarts <- base::computeRestarts
[16:06:07.671]                         grepl <- base::grepl
[16:06:07.671]                         restarts <- computeRestarts(cond)
[16:06:07.671]                         for (restart in restarts) {
[16:06:07.671]                           name <- restart$name
[16:06:07.671]                           if (is.null(name)) 
[16:06:07.671]                             next
[16:06:07.671]                           if (!grepl(pattern, name)) 
[16:06:07.671]                             next
[16:06:07.671]                           invokeRestart(restart)
[16:06:07.671]                           muffled <- TRUE
[16:06:07.671]                           break
[16:06:07.671]                         }
[16:06:07.671]                       }
[16:06:07.671]                     }
[16:06:07.671]                     invisible(muffled)
[16:06:07.671]                   }
[16:06:07.671]                   muffleCondition(cond)
[16:06:07.671]                 })
[16:06:07.671]             }))
[16:06:07.671]             future::FutureResult(value = ...future.value$value, 
[16:06:07.671]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.671]                   ...future.rng), globalenv = if (FALSE) 
[16:06:07.671]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:07.671]                     ...future.globalenv.names))
[16:06:07.671]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:07.671]         }, condition = base::local({
[16:06:07.671]             c <- base::c
[16:06:07.671]             inherits <- base::inherits
[16:06:07.671]             invokeRestart <- base::invokeRestart
[16:06:07.671]             length <- base::length
[16:06:07.671]             list <- base::list
[16:06:07.671]             seq.int <- base::seq.int
[16:06:07.671]             signalCondition <- base::signalCondition
[16:06:07.671]             sys.calls <- base::sys.calls
[16:06:07.671]             `[[` <- base::`[[`
[16:06:07.671]             `+` <- base::`+`
[16:06:07.671]             `<<-` <- base::`<<-`
[16:06:07.671]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:07.671]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:07.671]                   3L)]
[16:06:07.671]             }
[16:06:07.671]             function(cond) {
[16:06:07.671]                 is_error <- inherits(cond, "error")
[16:06:07.671]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:07.671]                   NULL)
[16:06:07.671]                 if (is_error) {
[16:06:07.671]                   sessionInformation <- function() {
[16:06:07.671]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:07.671]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:07.671]                       search = base::search(), system = base::Sys.info())
[16:06:07.671]                   }
[16:06:07.671]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.671]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:07.671]                     cond$call), session = sessionInformation(), 
[16:06:07.671]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:07.671]                   signalCondition(cond)
[16:06:07.671]                 }
[16:06:07.671]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:07.671]                 "immediateCondition"))) {
[16:06:07.671]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:07.671]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.671]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:07.671]                   if (TRUE && !signal) {
[16:06:07.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.671]                     {
[16:06:07.671]                       inherits <- base::inherits
[16:06:07.671]                       invokeRestart <- base::invokeRestart
[16:06:07.671]                       is.null <- base::is.null
[16:06:07.671]                       muffled <- FALSE
[16:06:07.671]                       if (inherits(cond, "message")) {
[16:06:07.671]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.671]                         if (muffled) 
[16:06:07.671]                           invokeRestart("muffleMessage")
[16:06:07.671]                       }
[16:06:07.671]                       else if (inherits(cond, "warning")) {
[16:06:07.671]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.671]                         if (muffled) 
[16:06:07.671]                           invokeRestart("muffleWarning")
[16:06:07.671]                       }
[16:06:07.671]                       else if (inherits(cond, "condition")) {
[16:06:07.671]                         if (!is.null(pattern)) {
[16:06:07.671]                           computeRestarts <- base::computeRestarts
[16:06:07.671]                           grepl <- base::grepl
[16:06:07.671]                           restarts <- computeRestarts(cond)
[16:06:07.671]                           for (restart in restarts) {
[16:06:07.671]                             name <- restart$name
[16:06:07.671]                             if (is.null(name)) 
[16:06:07.671]                               next
[16:06:07.671]                             if (!grepl(pattern, name)) 
[16:06:07.671]                               next
[16:06:07.671]                             invokeRestart(restart)
[16:06:07.671]                             muffled <- TRUE
[16:06:07.671]                             break
[16:06:07.671]                           }
[16:06:07.671]                         }
[16:06:07.671]                       }
[16:06:07.671]                       invisible(muffled)
[16:06:07.671]                     }
[16:06:07.671]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.671]                   }
[16:06:07.671]                 }
[16:06:07.671]                 else {
[16:06:07.671]                   if (TRUE) {
[16:06:07.671]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.671]                     {
[16:06:07.671]                       inherits <- base::inherits
[16:06:07.671]                       invokeRestart <- base::invokeRestart
[16:06:07.671]                       is.null <- base::is.null
[16:06:07.671]                       muffled <- FALSE
[16:06:07.671]                       if (inherits(cond, "message")) {
[16:06:07.671]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.671]                         if (muffled) 
[16:06:07.671]                           invokeRestart("muffleMessage")
[16:06:07.671]                       }
[16:06:07.671]                       else if (inherits(cond, "warning")) {
[16:06:07.671]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.671]                         if (muffled) 
[16:06:07.671]                           invokeRestart("muffleWarning")
[16:06:07.671]                       }
[16:06:07.671]                       else if (inherits(cond, "condition")) {
[16:06:07.671]                         if (!is.null(pattern)) {
[16:06:07.671]                           computeRestarts <- base::computeRestarts
[16:06:07.671]                           grepl <- base::grepl
[16:06:07.671]                           restarts <- computeRestarts(cond)
[16:06:07.671]                           for (restart in restarts) {
[16:06:07.671]                             name <- restart$name
[16:06:07.671]                             if (is.null(name)) 
[16:06:07.671]                               next
[16:06:07.671]                             if (!grepl(pattern, name)) 
[16:06:07.671]                               next
[16:06:07.671]                             invokeRestart(restart)
[16:06:07.671]                             muffled <- TRUE
[16:06:07.671]                             break
[16:06:07.671]                           }
[16:06:07.671]                         }
[16:06:07.671]                       }
[16:06:07.671]                       invisible(muffled)
[16:06:07.671]                     }
[16:06:07.671]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.671]                   }
[16:06:07.671]                 }
[16:06:07.671]             }
[16:06:07.671]         }))
[16:06:07.671]     }, error = function(ex) {
[16:06:07.671]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:07.671]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.671]                 ...future.rng), started = ...future.startTime, 
[16:06:07.671]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:07.671]             version = "1.8"), class = "FutureResult")
[16:06:07.671]     }, finally = {
[16:06:07.671]         if (!identical(...future.workdir, getwd())) 
[16:06:07.671]             setwd(...future.workdir)
[16:06:07.671]         {
[16:06:07.671]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:07.671]                 ...future.oldOptions$nwarnings <- NULL
[16:06:07.671]             }
[16:06:07.671]             base::options(...future.oldOptions)
[16:06:07.671]             if (.Platform$OS.type == "windows") {
[16:06:07.671]                 old_names <- names(...future.oldEnvVars)
[16:06:07.671]                 envs <- base::Sys.getenv()
[16:06:07.671]                 names <- names(envs)
[16:06:07.671]                 common <- intersect(names, old_names)
[16:06:07.671]                 added <- setdiff(names, old_names)
[16:06:07.671]                 removed <- setdiff(old_names, names)
[16:06:07.671]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:07.671]                   envs[common]]
[16:06:07.671]                 NAMES <- toupper(changed)
[16:06:07.671]                 args <- list()
[16:06:07.671]                 for (kk in seq_along(NAMES)) {
[16:06:07.671]                   name <- changed[[kk]]
[16:06:07.671]                   NAME <- NAMES[[kk]]
[16:06:07.671]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.671]                     next
[16:06:07.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.671]                 }
[16:06:07.671]                 NAMES <- toupper(added)
[16:06:07.671]                 for (kk in seq_along(NAMES)) {
[16:06:07.671]                   name <- added[[kk]]
[16:06:07.671]                   NAME <- NAMES[[kk]]
[16:06:07.671]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.671]                     next
[16:06:07.671]                   args[[name]] <- ""
[16:06:07.671]                 }
[16:06:07.671]                 NAMES <- toupper(removed)
[16:06:07.671]                 for (kk in seq_along(NAMES)) {
[16:06:07.671]                   name <- removed[[kk]]
[16:06:07.671]                   NAME <- NAMES[[kk]]
[16:06:07.671]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.671]                     next
[16:06:07.671]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.671]                 }
[16:06:07.671]                 if (length(args) > 0) 
[16:06:07.671]                   base::do.call(base::Sys.setenv, args = args)
[16:06:07.671]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:07.671]             }
[16:06:07.671]             else {
[16:06:07.671]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:07.671]             }
[16:06:07.671]             {
[16:06:07.671]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:07.671]                   0L) {
[16:06:07.671]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:07.671]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:07.671]                   base::options(opts)
[16:06:07.671]                 }
[16:06:07.671]                 {
[16:06:07.671]                   {
[16:06:07.671]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:07.671]                     NULL
[16:06:07.671]                   }
[16:06:07.671]                   options(future.plan = NULL)
[16:06:07.671]                   if (is.na(NA_character_)) 
[16:06:07.671]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.671]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:07.671]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:07.671]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:07.671]                     envir = parent.frame()) 
[16:06:07.671]                   {
[16:06:07.671]                     if (is.function(workers)) 
[16:06:07.671]                       workers <- workers()
[16:06:07.671]                     workers <- structure(as.integer(workers), 
[16:06:07.671]                       class = class(workers))
[16:06:07.671]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:07.671]                       workers >= 1)
[16:06:07.671]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:07.671]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:07.671]                     }
[16:06:07.671]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:07.671]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:07.671]                       envir = envir)
[16:06:07.671]                     if (!future$lazy) 
[16:06:07.671]                       future <- run(future)
[16:06:07.671]                     invisible(future)
[16:06:07.671]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:07.671]                 }
[16:06:07.671]             }
[16:06:07.671]         }
[16:06:07.671]     })
[16:06:07.671]     if (TRUE) {
[16:06:07.671]         base::sink(type = "output", split = FALSE)
[16:06:07.671]         if (TRUE) {
[16:06:07.671]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:07.671]         }
[16:06:07.671]         else {
[16:06:07.671]             ...future.result["stdout"] <- base::list(NULL)
[16:06:07.671]         }
[16:06:07.671]         base::close(...future.stdout)
[16:06:07.671]         ...future.stdout <- NULL
[16:06:07.671]     }
[16:06:07.671]     ...future.result$conditions <- ...future.conditions
[16:06:07.671]     ...future.result$finished <- base::Sys.time()
[16:06:07.671]     ...future.result
[16:06:07.671] }
[16:06:07.674] MultisessionFuture started
[16:06:07.674] - Launch lazy future ... done
[16:06:07.674] run() for ‘MultisessionFuture’ ... done
[16:06:07.720] receiveMessageFromWorker() for ClusterFuture ...
[16:06:07.720] - Validating connection of MultisessionFuture
[16:06:07.721] - received message: FutureResult
[16:06:07.721] - Received FutureResult
[16:06:07.721] - Erased future from FutureRegistry
[16:06:07.721] result() for ClusterFuture ...
[16:06:07.721] - result already collected: FutureResult
[16:06:07.721] result() for ClusterFuture ... done
[16:06:07.721] signalConditions() ...
[16:06:07.721]  - include = ‘immediateCondition’
[16:06:07.721]  - exclude = 
[16:06:07.721]  - resignal = FALSE
[16:06:07.721]  - Number of conditions: 1
[16:06:07.722] signalConditions() ... done
[16:06:07.722] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:07.722] A MultisessionFuture was resolved
[16:06:07.722] getGlobalsAndPackages() ...
[16:06:07.722] Searching for globals...
[16:06:07.723] - globals found: [2] ‘list’, ‘stop’
[16:06:07.723] Searching for globals ... DONE
[16:06:07.723] Resolving globals: FALSE
[16:06:07.723] 
[16:06:07.723] 
[16:06:07.723] getGlobalsAndPackages() ... DONE
[16:06:07.724] run() for ‘Future’ ...
[16:06:07.724] - state: ‘created’
[16:06:07.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:07.737] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:07.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:07.738]   - Field: ‘node’
[16:06:07.738]   - Field: ‘label’
[16:06:07.738]   - Field: ‘local’
[16:06:07.738]   - Field: ‘owner’
[16:06:07.738]   - Field: ‘envir’
[16:06:07.738]   - Field: ‘workers’
[16:06:07.738]   - Field: ‘packages’
[16:06:07.738]   - Field: ‘gc’
[16:06:07.738]   - Field: ‘conditions’
[16:06:07.738]   - Field: ‘persistent’
[16:06:07.738]   - Field: ‘expr’
[16:06:07.739]   - Field: ‘uuid’
[16:06:07.739]   - Field: ‘seed’
[16:06:07.739]   - Field: ‘version’
[16:06:07.739]   - Field: ‘result’
[16:06:07.739]   - Field: ‘asynchronous’
[16:06:07.739]   - Field: ‘calls’
[16:06:07.739]   - Field: ‘globals’
[16:06:07.739]   - Field: ‘stdout’
[16:06:07.739]   - Field: ‘earlySignal’
[16:06:07.739]   - Field: ‘lazy’
[16:06:07.740]   - Field: ‘state’
[16:06:07.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:07.740] - Launch lazy future ...
[16:06:07.740] Packages needed by the future expression (n = 0): <none>
[16:06:07.740] Packages needed by future strategies (n = 0): <none>
[16:06:07.741] {
[16:06:07.741]     {
[16:06:07.741]         {
[16:06:07.741]             ...future.startTime <- base::Sys.time()
[16:06:07.741]             {
[16:06:07.741]                 {
[16:06:07.741]                   {
[16:06:07.741]                     {
[16:06:07.741]                       base::local({
[16:06:07.741]                         has_future <- base::requireNamespace("future", 
[16:06:07.741]                           quietly = TRUE)
[16:06:07.741]                         if (has_future) {
[16:06:07.741]                           ns <- base::getNamespace("future")
[16:06:07.741]                           version <- ns[[".package"]][["version"]]
[16:06:07.741]                           if (is.null(version)) 
[16:06:07.741]                             version <- utils::packageVersion("future")
[16:06:07.741]                         }
[16:06:07.741]                         else {
[16:06:07.741]                           version <- NULL
[16:06:07.741]                         }
[16:06:07.741]                         if (!has_future || version < "1.8.0") {
[16:06:07.741]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:07.741]                             "", base::R.version$version.string), 
[16:06:07.741]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:07.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:07.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:07.741]                               "release", "version")], collapse = " "), 
[16:06:07.741]                             hostname = base::Sys.info()[["nodename"]])
[16:06:07.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:07.741]                             info)
[16:06:07.741]                           info <- base::paste(info, collapse = "; ")
[16:06:07.741]                           if (!has_future) {
[16:06:07.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:07.741]                               info)
[16:06:07.741]                           }
[16:06:07.741]                           else {
[16:06:07.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:07.741]                               info, version)
[16:06:07.741]                           }
[16:06:07.741]                           base::stop(msg)
[16:06:07.741]                         }
[16:06:07.741]                       })
[16:06:07.741]                     }
[16:06:07.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:07.741]                     base::options(mc.cores = 1L)
[16:06:07.741]                   }
[16:06:07.741]                   options(future.plan = NULL)
[16:06:07.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:07.741]                 }
[16:06:07.741]                 ...future.workdir <- getwd()
[16:06:07.741]             }
[16:06:07.741]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:07.741]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:07.741]         }
[16:06:07.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:07.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:07.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:07.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:07.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:07.741]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:07.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:07.741]             base::names(...future.oldOptions))
[16:06:07.741]     }
[16:06:07.741]     if (FALSE) {
[16:06:07.741]     }
[16:06:07.741]     else {
[16:06:07.741]         if (TRUE) {
[16:06:07.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:07.741]                 open = "w")
[16:06:07.741]         }
[16:06:07.741]         else {
[16:06:07.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:07.741]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:07.741]         }
[16:06:07.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:07.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:07.741]             base::sink(type = "output", split = FALSE)
[16:06:07.741]             base::close(...future.stdout)
[16:06:07.741]         }, add = TRUE)
[16:06:07.741]     }
[16:06:07.741]     ...future.frame <- base::sys.nframe()
[16:06:07.741]     ...future.conditions <- base::list()
[16:06:07.741]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:07.741]     if (FALSE) {
[16:06:07.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:07.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:07.741]     }
[16:06:07.741]     ...future.result <- base::tryCatch({
[16:06:07.741]         base::withCallingHandlers({
[16:06:07.741]             ...future.value <- base::withVisible(base::local({
[16:06:07.741]                 ...future.makeSendCondition <- base::local({
[16:06:07.741]                   sendCondition <- NULL
[16:06:07.741]                   function(frame = 1L) {
[16:06:07.741]                     if (is.function(sendCondition)) 
[16:06:07.741]                       return(sendCondition)
[16:06:07.741]                     ns <- getNamespace("parallel")
[16:06:07.741]                     if (exists("sendData", mode = "function", 
[16:06:07.741]                       envir = ns)) {
[16:06:07.741]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:07.741]                         envir = ns)
[16:06:07.741]                       envir <- sys.frame(frame)
[16:06:07.741]                       master <- NULL
[16:06:07.741]                       while (!identical(envir, .GlobalEnv) && 
[16:06:07.741]                         !identical(envir, emptyenv())) {
[16:06:07.741]                         if (exists("master", mode = "list", envir = envir, 
[16:06:07.741]                           inherits = FALSE)) {
[16:06:07.741]                           master <- get("master", mode = "list", 
[16:06:07.741]                             envir = envir, inherits = FALSE)
[16:06:07.741]                           if (inherits(master, c("SOCKnode", 
[16:06:07.741]                             "SOCK0node"))) {
[16:06:07.741]                             sendCondition <<- function(cond) {
[16:06:07.741]                               data <- list(type = "VALUE", value = cond, 
[16:06:07.741]                                 success = TRUE)
[16:06:07.741]                               parallel_sendData(master, data)
[16:06:07.741]                             }
[16:06:07.741]                             return(sendCondition)
[16:06:07.741]                           }
[16:06:07.741]                         }
[16:06:07.741]                         frame <- frame + 1L
[16:06:07.741]                         envir <- sys.frame(frame)
[16:06:07.741]                       }
[16:06:07.741]                     }
[16:06:07.741]                     sendCondition <<- function(cond) NULL
[16:06:07.741]                   }
[16:06:07.741]                 })
[16:06:07.741]                 withCallingHandlers({
[16:06:07.741]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:07.741]                 }, immediateCondition = function(cond) {
[16:06:07.741]                   sendCondition <- ...future.makeSendCondition()
[16:06:07.741]                   sendCondition(cond)
[16:06:07.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.741]                   {
[16:06:07.741]                     inherits <- base::inherits
[16:06:07.741]                     invokeRestart <- base::invokeRestart
[16:06:07.741]                     is.null <- base::is.null
[16:06:07.741]                     muffled <- FALSE
[16:06:07.741]                     if (inherits(cond, "message")) {
[16:06:07.741]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:07.741]                       if (muffled) 
[16:06:07.741]                         invokeRestart("muffleMessage")
[16:06:07.741]                     }
[16:06:07.741]                     else if (inherits(cond, "warning")) {
[16:06:07.741]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:07.741]                       if (muffled) 
[16:06:07.741]                         invokeRestart("muffleWarning")
[16:06:07.741]                     }
[16:06:07.741]                     else if (inherits(cond, "condition")) {
[16:06:07.741]                       if (!is.null(pattern)) {
[16:06:07.741]                         computeRestarts <- base::computeRestarts
[16:06:07.741]                         grepl <- base::grepl
[16:06:07.741]                         restarts <- computeRestarts(cond)
[16:06:07.741]                         for (restart in restarts) {
[16:06:07.741]                           name <- restart$name
[16:06:07.741]                           if (is.null(name)) 
[16:06:07.741]                             next
[16:06:07.741]                           if (!grepl(pattern, name)) 
[16:06:07.741]                             next
[16:06:07.741]                           invokeRestart(restart)
[16:06:07.741]                           muffled <- TRUE
[16:06:07.741]                           break
[16:06:07.741]                         }
[16:06:07.741]                       }
[16:06:07.741]                     }
[16:06:07.741]                     invisible(muffled)
[16:06:07.741]                   }
[16:06:07.741]                   muffleCondition(cond)
[16:06:07.741]                 })
[16:06:07.741]             }))
[16:06:07.741]             future::FutureResult(value = ...future.value$value, 
[16:06:07.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.741]                   ...future.rng), globalenv = if (FALSE) 
[16:06:07.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:07.741]                     ...future.globalenv.names))
[16:06:07.741]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:07.741]         }, condition = base::local({
[16:06:07.741]             c <- base::c
[16:06:07.741]             inherits <- base::inherits
[16:06:07.741]             invokeRestart <- base::invokeRestart
[16:06:07.741]             length <- base::length
[16:06:07.741]             list <- base::list
[16:06:07.741]             seq.int <- base::seq.int
[16:06:07.741]             signalCondition <- base::signalCondition
[16:06:07.741]             sys.calls <- base::sys.calls
[16:06:07.741]             `[[` <- base::`[[`
[16:06:07.741]             `+` <- base::`+`
[16:06:07.741]             `<<-` <- base::`<<-`
[16:06:07.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:07.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:07.741]                   3L)]
[16:06:07.741]             }
[16:06:07.741]             function(cond) {
[16:06:07.741]                 is_error <- inherits(cond, "error")
[16:06:07.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:07.741]                   NULL)
[16:06:07.741]                 if (is_error) {
[16:06:07.741]                   sessionInformation <- function() {
[16:06:07.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:07.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:07.741]                       search = base::search(), system = base::Sys.info())
[16:06:07.741]                   }
[16:06:07.741]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:07.741]                     cond$call), session = sessionInformation(), 
[16:06:07.741]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:07.741]                   signalCondition(cond)
[16:06:07.741]                 }
[16:06:07.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:07.741]                 "immediateCondition"))) {
[16:06:07.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:07.741]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:07.741]                   if (TRUE && !signal) {
[16:06:07.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.741]                     {
[16:06:07.741]                       inherits <- base::inherits
[16:06:07.741]                       invokeRestart <- base::invokeRestart
[16:06:07.741]                       is.null <- base::is.null
[16:06:07.741]                       muffled <- FALSE
[16:06:07.741]                       if (inherits(cond, "message")) {
[16:06:07.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.741]                         if (muffled) 
[16:06:07.741]                           invokeRestart("muffleMessage")
[16:06:07.741]                       }
[16:06:07.741]                       else if (inherits(cond, "warning")) {
[16:06:07.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.741]                         if (muffled) 
[16:06:07.741]                           invokeRestart("muffleWarning")
[16:06:07.741]                       }
[16:06:07.741]                       else if (inherits(cond, "condition")) {
[16:06:07.741]                         if (!is.null(pattern)) {
[16:06:07.741]                           computeRestarts <- base::computeRestarts
[16:06:07.741]                           grepl <- base::grepl
[16:06:07.741]                           restarts <- computeRestarts(cond)
[16:06:07.741]                           for (restart in restarts) {
[16:06:07.741]                             name <- restart$name
[16:06:07.741]                             if (is.null(name)) 
[16:06:07.741]                               next
[16:06:07.741]                             if (!grepl(pattern, name)) 
[16:06:07.741]                               next
[16:06:07.741]                             invokeRestart(restart)
[16:06:07.741]                             muffled <- TRUE
[16:06:07.741]                             break
[16:06:07.741]                           }
[16:06:07.741]                         }
[16:06:07.741]                       }
[16:06:07.741]                       invisible(muffled)
[16:06:07.741]                     }
[16:06:07.741]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.741]                   }
[16:06:07.741]                 }
[16:06:07.741]                 else {
[16:06:07.741]                   if (TRUE) {
[16:06:07.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.741]                     {
[16:06:07.741]                       inherits <- base::inherits
[16:06:07.741]                       invokeRestart <- base::invokeRestart
[16:06:07.741]                       is.null <- base::is.null
[16:06:07.741]                       muffled <- FALSE
[16:06:07.741]                       if (inherits(cond, "message")) {
[16:06:07.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.741]                         if (muffled) 
[16:06:07.741]                           invokeRestart("muffleMessage")
[16:06:07.741]                       }
[16:06:07.741]                       else if (inherits(cond, "warning")) {
[16:06:07.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.741]                         if (muffled) 
[16:06:07.741]                           invokeRestart("muffleWarning")
[16:06:07.741]                       }
[16:06:07.741]                       else if (inherits(cond, "condition")) {
[16:06:07.741]                         if (!is.null(pattern)) {
[16:06:07.741]                           computeRestarts <- base::computeRestarts
[16:06:07.741]                           grepl <- base::grepl
[16:06:07.741]                           restarts <- computeRestarts(cond)
[16:06:07.741]                           for (restart in restarts) {
[16:06:07.741]                             name <- restart$name
[16:06:07.741]                             if (is.null(name)) 
[16:06:07.741]                               next
[16:06:07.741]                             if (!grepl(pattern, name)) 
[16:06:07.741]                               next
[16:06:07.741]                             invokeRestart(restart)
[16:06:07.741]                             muffled <- TRUE
[16:06:07.741]                             break
[16:06:07.741]                           }
[16:06:07.741]                         }
[16:06:07.741]                       }
[16:06:07.741]                       invisible(muffled)
[16:06:07.741]                     }
[16:06:07.741]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.741]                   }
[16:06:07.741]                 }
[16:06:07.741]             }
[16:06:07.741]         }))
[16:06:07.741]     }, error = function(ex) {
[16:06:07.741]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:07.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.741]                 ...future.rng), started = ...future.startTime, 
[16:06:07.741]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:07.741]             version = "1.8"), class = "FutureResult")
[16:06:07.741]     }, finally = {
[16:06:07.741]         if (!identical(...future.workdir, getwd())) 
[16:06:07.741]             setwd(...future.workdir)
[16:06:07.741]         {
[16:06:07.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:07.741]                 ...future.oldOptions$nwarnings <- NULL
[16:06:07.741]             }
[16:06:07.741]             base::options(...future.oldOptions)
[16:06:07.741]             if (.Platform$OS.type == "windows") {
[16:06:07.741]                 old_names <- names(...future.oldEnvVars)
[16:06:07.741]                 envs <- base::Sys.getenv()
[16:06:07.741]                 names <- names(envs)
[16:06:07.741]                 common <- intersect(names, old_names)
[16:06:07.741]                 added <- setdiff(names, old_names)
[16:06:07.741]                 removed <- setdiff(old_names, names)
[16:06:07.741]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:07.741]                   envs[common]]
[16:06:07.741]                 NAMES <- toupper(changed)
[16:06:07.741]                 args <- list()
[16:06:07.741]                 for (kk in seq_along(NAMES)) {
[16:06:07.741]                   name <- changed[[kk]]
[16:06:07.741]                   NAME <- NAMES[[kk]]
[16:06:07.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.741]                     next
[16:06:07.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.741]                 }
[16:06:07.741]                 NAMES <- toupper(added)
[16:06:07.741]                 for (kk in seq_along(NAMES)) {
[16:06:07.741]                   name <- added[[kk]]
[16:06:07.741]                   NAME <- NAMES[[kk]]
[16:06:07.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.741]                     next
[16:06:07.741]                   args[[name]] <- ""
[16:06:07.741]                 }
[16:06:07.741]                 NAMES <- toupper(removed)
[16:06:07.741]                 for (kk in seq_along(NAMES)) {
[16:06:07.741]                   name <- removed[[kk]]
[16:06:07.741]                   NAME <- NAMES[[kk]]
[16:06:07.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.741]                     next
[16:06:07.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.741]                 }
[16:06:07.741]                 if (length(args) > 0) 
[16:06:07.741]                   base::do.call(base::Sys.setenv, args = args)
[16:06:07.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:07.741]             }
[16:06:07.741]             else {
[16:06:07.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:07.741]             }
[16:06:07.741]             {
[16:06:07.741]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:07.741]                   0L) {
[16:06:07.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:07.741]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:07.741]                   base::options(opts)
[16:06:07.741]                 }
[16:06:07.741]                 {
[16:06:07.741]                   {
[16:06:07.741]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:07.741]                     NULL
[16:06:07.741]                   }
[16:06:07.741]                   options(future.plan = NULL)
[16:06:07.741]                   if (is.na(NA_character_)) 
[16:06:07.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:07.741]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:07.741]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:07.741]                     envir = parent.frame()) 
[16:06:07.741]                   {
[16:06:07.741]                     if (is.function(workers)) 
[16:06:07.741]                       workers <- workers()
[16:06:07.741]                     workers <- structure(as.integer(workers), 
[16:06:07.741]                       class = class(workers))
[16:06:07.741]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:07.741]                       workers >= 1)
[16:06:07.741]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:07.741]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:07.741]                     }
[16:06:07.741]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:07.741]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:07.741]                       envir = envir)
[16:06:07.741]                     if (!future$lazy) 
[16:06:07.741]                       future <- run(future)
[16:06:07.741]                     invisible(future)
[16:06:07.741]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:07.741]                 }
[16:06:07.741]             }
[16:06:07.741]         }
[16:06:07.741]     })
[16:06:07.741]     if (TRUE) {
[16:06:07.741]         base::sink(type = "output", split = FALSE)
[16:06:07.741]         if (TRUE) {
[16:06:07.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:07.741]         }
[16:06:07.741]         else {
[16:06:07.741]             ...future.result["stdout"] <- base::list(NULL)
[16:06:07.741]         }
[16:06:07.741]         base::close(...future.stdout)
[16:06:07.741]         ...future.stdout <- NULL
[16:06:07.741]     }
[16:06:07.741]     ...future.result$conditions <- ...future.conditions
[16:06:07.741]     ...future.result$finished <- base::Sys.time()
[16:06:07.741]     ...future.result
[16:06:07.741] }
[16:06:07.744] MultisessionFuture started
[16:06:07.744] - Launch lazy future ... done
[16:06:07.744] run() for ‘MultisessionFuture’ ... done
[16:06:07.792] receiveMessageFromWorker() for ClusterFuture ...
[16:06:07.792] - Validating connection of MultisessionFuture
[16:06:07.793] - received message: FutureResult
[16:06:07.793] - Received FutureResult
[16:06:07.793] - Erased future from FutureRegistry
[16:06:07.793] result() for ClusterFuture ...
[16:06:07.793] - result already collected: FutureResult
[16:06:07.793] result() for ClusterFuture ... done
[16:06:07.793] signalConditions() ...
[16:06:07.793]  - include = ‘immediateCondition’
[16:06:07.793]  - exclude = 
[16:06:07.794]  - resignal = FALSE
[16:06:07.794]  - Number of conditions: 1
[16:06:07.794] signalConditions() ... done
[16:06:07.794] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:07.794] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[16:06:07.794] getGlobalsAndPackages() ...
[16:06:07.794] Searching for globals...
[16:06:07.795] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:07.796] Searching for globals ... DONE
[16:06:07.796] Resolving globals: FALSE
[16:06:07.796] 
[16:06:07.796] 
[16:06:07.796] getGlobalsAndPackages() ... DONE
[16:06:07.796] run() for ‘Future’ ...
[16:06:07.797] - state: ‘created’
[16:06:07.797] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:07.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:07.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:07.811]   - Field: ‘node’
[16:06:07.811]   - Field: ‘label’
[16:06:07.811]   - Field: ‘local’
[16:06:07.811]   - Field: ‘owner’
[16:06:07.811]   - Field: ‘envir’
[16:06:07.811]   - Field: ‘workers’
[16:06:07.811]   - Field: ‘packages’
[16:06:07.811]   - Field: ‘gc’
[16:06:07.811]   - Field: ‘conditions’
[16:06:07.811]   - Field: ‘persistent’
[16:06:07.812]   - Field: ‘expr’
[16:06:07.812]   - Field: ‘uuid’
[16:06:07.812]   - Field: ‘seed’
[16:06:07.812]   - Field: ‘version’
[16:06:07.812]   - Field: ‘result’
[16:06:07.812]   - Field: ‘asynchronous’
[16:06:07.812]   - Field: ‘calls’
[16:06:07.812]   - Field: ‘globals’
[16:06:07.812]   - Field: ‘stdout’
[16:06:07.812]   - Field: ‘earlySignal’
[16:06:07.812]   - Field: ‘lazy’
[16:06:07.813]   - Field: ‘state’
[16:06:07.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:07.813] - Launch lazy future ...
[16:06:07.813] Packages needed by the future expression (n = 0): <none>
[16:06:07.813] Packages needed by future strategies (n = 0): <none>
[16:06:07.814] {
[16:06:07.814]     {
[16:06:07.814]         {
[16:06:07.814]             ...future.startTime <- base::Sys.time()
[16:06:07.814]             {
[16:06:07.814]                 {
[16:06:07.814]                   {
[16:06:07.814]                     {
[16:06:07.814]                       base::local({
[16:06:07.814]                         has_future <- base::requireNamespace("future", 
[16:06:07.814]                           quietly = TRUE)
[16:06:07.814]                         if (has_future) {
[16:06:07.814]                           ns <- base::getNamespace("future")
[16:06:07.814]                           version <- ns[[".package"]][["version"]]
[16:06:07.814]                           if (is.null(version)) 
[16:06:07.814]                             version <- utils::packageVersion("future")
[16:06:07.814]                         }
[16:06:07.814]                         else {
[16:06:07.814]                           version <- NULL
[16:06:07.814]                         }
[16:06:07.814]                         if (!has_future || version < "1.8.0") {
[16:06:07.814]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:07.814]                             "", base::R.version$version.string), 
[16:06:07.814]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:07.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:07.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:07.814]                               "release", "version")], collapse = " "), 
[16:06:07.814]                             hostname = base::Sys.info()[["nodename"]])
[16:06:07.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:07.814]                             info)
[16:06:07.814]                           info <- base::paste(info, collapse = "; ")
[16:06:07.814]                           if (!has_future) {
[16:06:07.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:07.814]                               info)
[16:06:07.814]                           }
[16:06:07.814]                           else {
[16:06:07.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:07.814]                               info, version)
[16:06:07.814]                           }
[16:06:07.814]                           base::stop(msg)
[16:06:07.814]                         }
[16:06:07.814]                       })
[16:06:07.814]                     }
[16:06:07.814]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:07.814]                     base::options(mc.cores = 1L)
[16:06:07.814]                   }
[16:06:07.814]                   options(future.plan = NULL)
[16:06:07.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:07.814]                 }
[16:06:07.814]                 ...future.workdir <- getwd()
[16:06:07.814]             }
[16:06:07.814]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:07.814]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:07.814]         }
[16:06:07.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:07.814]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:07.814]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:07.814]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:07.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:07.814]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:07.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:07.814]             base::names(...future.oldOptions))
[16:06:07.814]     }
[16:06:07.814]     if (FALSE) {
[16:06:07.814]     }
[16:06:07.814]     else {
[16:06:07.814]         if (TRUE) {
[16:06:07.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:07.814]                 open = "w")
[16:06:07.814]         }
[16:06:07.814]         else {
[16:06:07.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:07.814]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:07.814]         }
[16:06:07.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:07.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:07.814]             base::sink(type = "output", split = FALSE)
[16:06:07.814]             base::close(...future.stdout)
[16:06:07.814]         }, add = TRUE)
[16:06:07.814]     }
[16:06:07.814]     ...future.frame <- base::sys.nframe()
[16:06:07.814]     ...future.conditions <- base::list()
[16:06:07.814]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:07.814]     if (FALSE) {
[16:06:07.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:07.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:07.814]     }
[16:06:07.814]     ...future.result <- base::tryCatch({
[16:06:07.814]         base::withCallingHandlers({
[16:06:07.814]             ...future.value <- base::withVisible(base::local({
[16:06:07.814]                 ...future.makeSendCondition <- base::local({
[16:06:07.814]                   sendCondition <- NULL
[16:06:07.814]                   function(frame = 1L) {
[16:06:07.814]                     if (is.function(sendCondition)) 
[16:06:07.814]                       return(sendCondition)
[16:06:07.814]                     ns <- getNamespace("parallel")
[16:06:07.814]                     if (exists("sendData", mode = "function", 
[16:06:07.814]                       envir = ns)) {
[16:06:07.814]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:07.814]                         envir = ns)
[16:06:07.814]                       envir <- sys.frame(frame)
[16:06:07.814]                       master <- NULL
[16:06:07.814]                       while (!identical(envir, .GlobalEnv) && 
[16:06:07.814]                         !identical(envir, emptyenv())) {
[16:06:07.814]                         if (exists("master", mode = "list", envir = envir, 
[16:06:07.814]                           inherits = FALSE)) {
[16:06:07.814]                           master <- get("master", mode = "list", 
[16:06:07.814]                             envir = envir, inherits = FALSE)
[16:06:07.814]                           if (inherits(master, c("SOCKnode", 
[16:06:07.814]                             "SOCK0node"))) {
[16:06:07.814]                             sendCondition <<- function(cond) {
[16:06:07.814]                               data <- list(type = "VALUE", value = cond, 
[16:06:07.814]                                 success = TRUE)
[16:06:07.814]                               parallel_sendData(master, data)
[16:06:07.814]                             }
[16:06:07.814]                             return(sendCondition)
[16:06:07.814]                           }
[16:06:07.814]                         }
[16:06:07.814]                         frame <- frame + 1L
[16:06:07.814]                         envir <- sys.frame(frame)
[16:06:07.814]                       }
[16:06:07.814]                     }
[16:06:07.814]                     sendCondition <<- function(cond) NULL
[16:06:07.814]                   }
[16:06:07.814]                 })
[16:06:07.814]                 withCallingHandlers({
[16:06:07.814]                   {
[16:06:07.814]                     Sys.sleep(0.5)
[16:06:07.814]                     list(a = 1, b = 42L)
[16:06:07.814]                   }
[16:06:07.814]                 }, immediateCondition = function(cond) {
[16:06:07.814]                   sendCondition <- ...future.makeSendCondition()
[16:06:07.814]                   sendCondition(cond)
[16:06:07.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.814]                   {
[16:06:07.814]                     inherits <- base::inherits
[16:06:07.814]                     invokeRestart <- base::invokeRestart
[16:06:07.814]                     is.null <- base::is.null
[16:06:07.814]                     muffled <- FALSE
[16:06:07.814]                     if (inherits(cond, "message")) {
[16:06:07.814]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:07.814]                       if (muffled) 
[16:06:07.814]                         invokeRestart("muffleMessage")
[16:06:07.814]                     }
[16:06:07.814]                     else if (inherits(cond, "warning")) {
[16:06:07.814]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:07.814]                       if (muffled) 
[16:06:07.814]                         invokeRestart("muffleWarning")
[16:06:07.814]                     }
[16:06:07.814]                     else if (inherits(cond, "condition")) {
[16:06:07.814]                       if (!is.null(pattern)) {
[16:06:07.814]                         computeRestarts <- base::computeRestarts
[16:06:07.814]                         grepl <- base::grepl
[16:06:07.814]                         restarts <- computeRestarts(cond)
[16:06:07.814]                         for (restart in restarts) {
[16:06:07.814]                           name <- restart$name
[16:06:07.814]                           if (is.null(name)) 
[16:06:07.814]                             next
[16:06:07.814]                           if (!grepl(pattern, name)) 
[16:06:07.814]                             next
[16:06:07.814]                           invokeRestart(restart)
[16:06:07.814]                           muffled <- TRUE
[16:06:07.814]                           break
[16:06:07.814]                         }
[16:06:07.814]                       }
[16:06:07.814]                     }
[16:06:07.814]                     invisible(muffled)
[16:06:07.814]                   }
[16:06:07.814]                   muffleCondition(cond)
[16:06:07.814]                 })
[16:06:07.814]             }))
[16:06:07.814]             future::FutureResult(value = ...future.value$value, 
[16:06:07.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.814]                   ...future.rng), globalenv = if (FALSE) 
[16:06:07.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:07.814]                     ...future.globalenv.names))
[16:06:07.814]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:07.814]         }, condition = base::local({
[16:06:07.814]             c <- base::c
[16:06:07.814]             inherits <- base::inherits
[16:06:07.814]             invokeRestart <- base::invokeRestart
[16:06:07.814]             length <- base::length
[16:06:07.814]             list <- base::list
[16:06:07.814]             seq.int <- base::seq.int
[16:06:07.814]             signalCondition <- base::signalCondition
[16:06:07.814]             sys.calls <- base::sys.calls
[16:06:07.814]             `[[` <- base::`[[`
[16:06:07.814]             `+` <- base::`+`
[16:06:07.814]             `<<-` <- base::`<<-`
[16:06:07.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:07.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:07.814]                   3L)]
[16:06:07.814]             }
[16:06:07.814]             function(cond) {
[16:06:07.814]                 is_error <- inherits(cond, "error")
[16:06:07.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:07.814]                   NULL)
[16:06:07.814]                 if (is_error) {
[16:06:07.814]                   sessionInformation <- function() {
[16:06:07.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:07.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:07.814]                       search = base::search(), system = base::Sys.info())
[16:06:07.814]                   }
[16:06:07.814]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:07.814]                     cond$call), session = sessionInformation(), 
[16:06:07.814]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:07.814]                   signalCondition(cond)
[16:06:07.814]                 }
[16:06:07.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:07.814]                 "immediateCondition"))) {
[16:06:07.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:07.814]                   ...future.conditions[[length(...future.conditions) + 
[16:06:07.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:07.814]                   if (TRUE && !signal) {
[16:06:07.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.814]                     {
[16:06:07.814]                       inherits <- base::inherits
[16:06:07.814]                       invokeRestart <- base::invokeRestart
[16:06:07.814]                       is.null <- base::is.null
[16:06:07.814]                       muffled <- FALSE
[16:06:07.814]                       if (inherits(cond, "message")) {
[16:06:07.814]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.814]                         if (muffled) 
[16:06:07.814]                           invokeRestart("muffleMessage")
[16:06:07.814]                       }
[16:06:07.814]                       else if (inherits(cond, "warning")) {
[16:06:07.814]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.814]                         if (muffled) 
[16:06:07.814]                           invokeRestart("muffleWarning")
[16:06:07.814]                       }
[16:06:07.814]                       else if (inherits(cond, "condition")) {
[16:06:07.814]                         if (!is.null(pattern)) {
[16:06:07.814]                           computeRestarts <- base::computeRestarts
[16:06:07.814]                           grepl <- base::grepl
[16:06:07.814]                           restarts <- computeRestarts(cond)
[16:06:07.814]                           for (restart in restarts) {
[16:06:07.814]                             name <- restart$name
[16:06:07.814]                             if (is.null(name)) 
[16:06:07.814]                               next
[16:06:07.814]                             if (!grepl(pattern, name)) 
[16:06:07.814]                               next
[16:06:07.814]                             invokeRestart(restart)
[16:06:07.814]                             muffled <- TRUE
[16:06:07.814]                             break
[16:06:07.814]                           }
[16:06:07.814]                         }
[16:06:07.814]                       }
[16:06:07.814]                       invisible(muffled)
[16:06:07.814]                     }
[16:06:07.814]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.814]                   }
[16:06:07.814]                 }
[16:06:07.814]                 else {
[16:06:07.814]                   if (TRUE) {
[16:06:07.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:07.814]                     {
[16:06:07.814]                       inherits <- base::inherits
[16:06:07.814]                       invokeRestart <- base::invokeRestart
[16:06:07.814]                       is.null <- base::is.null
[16:06:07.814]                       muffled <- FALSE
[16:06:07.814]                       if (inherits(cond, "message")) {
[16:06:07.814]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:07.814]                         if (muffled) 
[16:06:07.814]                           invokeRestart("muffleMessage")
[16:06:07.814]                       }
[16:06:07.814]                       else if (inherits(cond, "warning")) {
[16:06:07.814]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:07.814]                         if (muffled) 
[16:06:07.814]                           invokeRestart("muffleWarning")
[16:06:07.814]                       }
[16:06:07.814]                       else if (inherits(cond, "condition")) {
[16:06:07.814]                         if (!is.null(pattern)) {
[16:06:07.814]                           computeRestarts <- base::computeRestarts
[16:06:07.814]                           grepl <- base::grepl
[16:06:07.814]                           restarts <- computeRestarts(cond)
[16:06:07.814]                           for (restart in restarts) {
[16:06:07.814]                             name <- restart$name
[16:06:07.814]                             if (is.null(name)) 
[16:06:07.814]                               next
[16:06:07.814]                             if (!grepl(pattern, name)) 
[16:06:07.814]                               next
[16:06:07.814]                             invokeRestart(restart)
[16:06:07.814]                             muffled <- TRUE
[16:06:07.814]                             break
[16:06:07.814]                           }
[16:06:07.814]                         }
[16:06:07.814]                       }
[16:06:07.814]                       invisible(muffled)
[16:06:07.814]                     }
[16:06:07.814]                     muffleCondition(cond, pattern = "^muffle")
[16:06:07.814]                   }
[16:06:07.814]                 }
[16:06:07.814]             }
[16:06:07.814]         }))
[16:06:07.814]     }, error = function(ex) {
[16:06:07.814]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:07.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:07.814]                 ...future.rng), started = ...future.startTime, 
[16:06:07.814]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:07.814]             version = "1.8"), class = "FutureResult")
[16:06:07.814]     }, finally = {
[16:06:07.814]         if (!identical(...future.workdir, getwd())) 
[16:06:07.814]             setwd(...future.workdir)
[16:06:07.814]         {
[16:06:07.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:07.814]                 ...future.oldOptions$nwarnings <- NULL
[16:06:07.814]             }
[16:06:07.814]             base::options(...future.oldOptions)
[16:06:07.814]             if (.Platform$OS.type == "windows") {
[16:06:07.814]                 old_names <- names(...future.oldEnvVars)
[16:06:07.814]                 envs <- base::Sys.getenv()
[16:06:07.814]                 names <- names(envs)
[16:06:07.814]                 common <- intersect(names, old_names)
[16:06:07.814]                 added <- setdiff(names, old_names)
[16:06:07.814]                 removed <- setdiff(old_names, names)
[16:06:07.814]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:07.814]                   envs[common]]
[16:06:07.814]                 NAMES <- toupper(changed)
[16:06:07.814]                 args <- list()
[16:06:07.814]                 for (kk in seq_along(NAMES)) {
[16:06:07.814]                   name <- changed[[kk]]
[16:06:07.814]                   NAME <- NAMES[[kk]]
[16:06:07.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.814]                     next
[16:06:07.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.814]                 }
[16:06:07.814]                 NAMES <- toupper(added)
[16:06:07.814]                 for (kk in seq_along(NAMES)) {
[16:06:07.814]                   name <- added[[kk]]
[16:06:07.814]                   NAME <- NAMES[[kk]]
[16:06:07.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.814]                     next
[16:06:07.814]                   args[[name]] <- ""
[16:06:07.814]                 }
[16:06:07.814]                 NAMES <- toupper(removed)
[16:06:07.814]                 for (kk in seq_along(NAMES)) {
[16:06:07.814]                   name <- removed[[kk]]
[16:06:07.814]                   NAME <- NAMES[[kk]]
[16:06:07.814]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:07.814]                     next
[16:06:07.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:07.814]                 }
[16:06:07.814]                 if (length(args) > 0) 
[16:06:07.814]                   base::do.call(base::Sys.setenv, args = args)
[16:06:07.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:07.814]             }
[16:06:07.814]             else {
[16:06:07.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:07.814]             }
[16:06:07.814]             {
[16:06:07.814]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:07.814]                   0L) {
[16:06:07.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:07.814]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:07.814]                   base::options(opts)
[16:06:07.814]                 }
[16:06:07.814]                 {
[16:06:07.814]                   {
[16:06:07.814]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:07.814]                     NULL
[16:06:07.814]                   }
[16:06:07.814]                   options(future.plan = NULL)
[16:06:07.814]                   if (is.na(NA_character_)) 
[16:06:07.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:07.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:07.814]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:07.814]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:07.814]                     envir = parent.frame()) 
[16:06:07.814]                   {
[16:06:07.814]                     if (is.function(workers)) 
[16:06:07.814]                       workers <- workers()
[16:06:07.814]                     workers <- structure(as.integer(workers), 
[16:06:07.814]                       class = class(workers))
[16:06:07.814]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:07.814]                       workers >= 1)
[16:06:07.814]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:07.814]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:07.814]                     }
[16:06:07.814]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:07.814]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:07.814]                       envir = envir)
[16:06:07.814]                     if (!future$lazy) 
[16:06:07.814]                       future <- run(future)
[16:06:07.814]                     invisible(future)
[16:06:07.814]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:07.814]                 }
[16:06:07.814]             }
[16:06:07.814]         }
[16:06:07.814]     })
[16:06:07.814]     if (TRUE) {
[16:06:07.814]         base::sink(type = "output", split = FALSE)
[16:06:07.814]         if (TRUE) {
[16:06:07.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:07.814]         }
[16:06:07.814]         else {
[16:06:07.814]             ...future.result["stdout"] <- base::list(NULL)
[16:06:07.814]         }
[16:06:07.814]         base::close(...future.stdout)
[16:06:07.814]         ...future.stdout <- NULL
[16:06:07.814]     }
[16:06:07.814]     ...future.result$conditions <- ...future.conditions
[16:06:07.814]     ...future.result$finished <- base::Sys.time()
[16:06:07.814]     ...future.result
[16:06:07.814] }
[16:06:07.817] MultisessionFuture started
[16:06:07.817] - Launch lazy future ... done
[16:06:07.817] run() for ‘MultisessionFuture’ ... done
[16:06:08.375] receiveMessageFromWorker() for ClusterFuture ...
[16:06:08.375] - Validating connection of MultisessionFuture
[16:06:08.376] - received message: FutureResult
[16:06:08.376] - Received FutureResult
[16:06:08.376] - Erased future from FutureRegistry
[16:06:08.376] result() for ClusterFuture ...
[16:06:08.376] - result already collected: FutureResult
[16:06:08.376] result() for ClusterFuture ... done
[16:06:08.376] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:08.376] resolve() on list ...
[16:06:08.377]  recursive: 98
[16:06:08.377]  length: 2
[16:06:08.377]  elements: ‘a’, ‘b’
[16:06:08.377]  length: 1 (resolved future 1)
[16:06:08.377]  length: 0 (resolved future 2)
[16:06:08.377] resolve() on list ... DONE
[16:06:08.377] A MultisessionFuture was resolved (and resolved itself)
[16:06:08.377] getGlobalsAndPackages() ...
[16:06:08.377] Searching for globals...
[16:06:08.379] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:08.379] Searching for globals ... DONE
[16:06:08.379] Resolving globals: FALSE
[16:06:08.379] 
[16:06:08.379] 
[16:06:08.379] getGlobalsAndPackages() ... DONE
[16:06:08.380] run() for ‘Future’ ...
[16:06:08.380] - state: ‘created’
[16:06:08.380] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:08.406] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:08.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:08.406]   - Field: ‘node’
[16:06:08.406]   - Field: ‘label’
[16:06:08.406]   - Field: ‘local’
[16:06:08.406]   - Field: ‘owner’
[16:06:08.406]   - Field: ‘envir’
[16:06:08.407]   - Field: ‘workers’
[16:06:08.407]   - Field: ‘packages’
[16:06:08.407]   - Field: ‘gc’
[16:06:08.407]   - Field: ‘conditions’
[16:06:08.407]   - Field: ‘persistent’
[16:06:08.407]   - Field: ‘expr’
[16:06:08.407]   - Field: ‘uuid’
[16:06:08.407]   - Field: ‘seed’
[16:06:08.408]   - Field: ‘version’
[16:06:08.408]   - Field: ‘result’
[16:06:08.408]   - Field: ‘asynchronous’
[16:06:08.408]   - Field: ‘calls’
[16:06:08.408]   - Field: ‘globals’
[16:06:08.408]   - Field: ‘stdout’
[16:06:08.408]   - Field: ‘earlySignal’
[16:06:08.408]   - Field: ‘lazy’
[16:06:08.408]   - Field: ‘state’
[16:06:08.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:08.408] - Launch lazy future ...
[16:06:08.409] Packages needed by the future expression (n = 0): <none>
[16:06:08.409] Packages needed by future strategies (n = 0): <none>
[16:06:08.409] {
[16:06:08.409]     {
[16:06:08.409]         {
[16:06:08.409]             ...future.startTime <- base::Sys.time()
[16:06:08.409]             {
[16:06:08.409]                 {
[16:06:08.409]                   {
[16:06:08.409]                     {
[16:06:08.409]                       base::local({
[16:06:08.409]                         has_future <- base::requireNamespace("future", 
[16:06:08.409]                           quietly = TRUE)
[16:06:08.409]                         if (has_future) {
[16:06:08.409]                           ns <- base::getNamespace("future")
[16:06:08.409]                           version <- ns[[".package"]][["version"]]
[16:06:08.409]                           if (is.null(version)) 
[16:06:08.409]                             version <- utils::packageVersion("future")
[16:06:08.409]                         }
[16:06:08.409]                         else {
[16:06:08.409]                           version <- NULL
[16:06:08.409]                         }
[16:06:08.409]                         if (!has_future || version < "1.8.0") {
[16:06:08.409]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:08.409]                             "", base::R.version$version.string), 
[16:06:08.409]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:08.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:08.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:08.409]                               "release", "version")], collapse = " "), 
[16:06:08.409]                             hostname = base::Sys.info()[["nodename"]])
[16:06:08.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:08.409]                             info)
[16:06:08.409]                           info <- base::paste(info, collapse = "; ")
[16:06:08.409]                           if (!has_future) {
[16:06:08.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:08.409]                               info)
[16:06:08.409]                           }
[16:06:08.409]                           else {
[16:06:08.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:08.409]                               info, version)
[16:06:08.409]                           }
[16:06:08.409]                           base::stop(msg)
[16:06:08.409]                         }
[16:06:08.409]                       })
[16:06:08.409]                     }
[16:06:08.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:08.409]                     base::options(mc.cores = 1L)
[16:06:08.409]                   }
[16:06:08.409]                   options(future.plan = NULL)
[16:06:08.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:08.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:08.409]                 }
[16:06:08.409]                 ...future.workdir <- getwd()
[16:06:08.409]             }
[16:06:08.409]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:08.409]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:08.409]         }
[16:06:08.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:08.409]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:08.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:08.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:08.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:08.409]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:08.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:08.409]             base::names(...future.oldOptions))
[16:06:08.409]     }
[16:06:08.409]     if (FALSE) {
[16:06:08.409]     }
[16:06:08.409]     else {
[16:06:08.409]         if (TRUE) {
[16:06:08.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:08.409]                 open = "w")
[16:06:08.409]         }
[16:06:08.409]         else {
[16:06:08.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:08.409]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:08.409]         }
[16:06:08.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:08.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:08.409]             base::sink(type = "output", split = FALSE)
[16:06:08.409]             base::close(...future.stdout)
[16:06:08.409]         }, add = TRUE)
[16:06:08.409]     }
[16:06:08.409]     ...future.frame <- base::sys.nframe()
[16:06:08.409]     ...future.conditions <- base::list()
[16:06:08.409]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:08.409]     if (FALSE) {
[16:06:08.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:08.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:08.409]     }
[16:06:08.409]     ...future.result <- base::tryCatch({
[16:06:08.409]         base::withCallingHandlers({
[16:06:08.409]             ...future.value <- base::withVisible(base::local({
[16:06:08.409]                 ...future.makeSendCondition <- base::local({
[16:06:08.409]                   sendCondition <- NULL
[16:06:08.409]                   function(frame = 1L) {
[16:06:08.409]                     if (is.function(sendCondition)) 
[16:06:08.409]                       return(sendCondition)
[16:06:08.409]                     ns <- getNamespace("parallel")
[16:06:08.409]                     if (exists("sendData", mode = "function", 
[16:06:08.409]                       envir = ns)) {
[16:06:08.409]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:08.409]                         envir = ns)
[16:06:08.409]                       envir <- sys.frame(frame)
[16:06:08.409]                       master <- NULL
[16:06:08.409]                       while (!identical(envir, .GlobalEnv) && 
[16:06:08.409]                         !identical(envir, emptyenv())) {
[16:06:08.409]                         if (exists("master", mode = "list", envir = envir, 
[16:06:08.409]                           inherits = FALSE)) {
[16:06:08.409]                           master <- get("master", mode = "list", 
[16:06:08.409]                             envir = envir, inherits = FALSE)
[16:06:08.409]                           if (inherits(master, c("SOCKnode", 
[16:06:08.409]                             "SOCK0node"))) {
[16:06:08.409]                             sendCondition <<- function(cond) {
[16:06:08.409]                               data <- list(type = "VALUE", value = cond, 
[16:06:08.409]                                 success = TRUE)
[16:06:08.409]                               parallel_sendData(master, data)
[16:06:08.409]                             }
[16:06:08.409]                             return(sendCondition)
[16:06:08.409]                           }
[16:06:08.409]                         }
[16:06:08.409]                         frame <- frame + 1L
[16:06:08.409]                         envir <- sys.frame(frame)
[16:06:08.409]                       }
[16:06:08.409]                     }
[16:06:08.409]                     sendCondition <<- function(cond) NULL
[16:06:08.409]                   }
[16:06:08.409]                 })
[16:06:08.409]                 withCallingHandlers({
[16:06:08.409]                   {
[16:06:08.409]                     Sys.sleep(0.5)
[16:06:08.409]                     list(a = 1, b = 42L)
[16:06:08.409]                   }
[16:06:08.409]                 }, immediateCondition = function(cond) {
[16:06:08.409]                   sendCondition <- ...future.makeSendCondition()
[16:06:08.409]                   sendCondition(cond)
[16:06:08.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:08.409]                   {
[16:06:08.409]                     inherits <- base::inherits
[16:06:08.409]                     invokeRestart <- base::invokeRestart
[16:06:08.409]                     is.null <- base::is.null
[16:06:08.409]                     muffled <- FALSE
[16:06:08.409]                     if (inherits(cond, "message")) {
[16:06:08.409]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:08.409]                       if (muffled) 
[16:06:08.409]                         invokeRestart("muffleMessage")
[16:06:08.409]                     }
[16:06:08.409]                     else if (inherits(cond, "warning")) {
[16:06:08.409]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:08.409]                       if (muffled) 
[16:06:08.409]                         invokeRestart("muffleWarning")
[16:06:08.409]                     }
[16:06:08.409]                     else if (inherits(cond, "condition")) {
[16:06:08.409]                       if (!is.null(pattern)) {
[16:06:08.409]                         computeRestarts <- base::computeRestarts
[16:06:08.409]                         grepl <- base::grepl
[16:06:08.409]                         restarts <- computeRestarts(cond)
[16:06:08.409]                         for (restart in restarts) {
[16:06:08.409]                           name <- restart$name
[16:06:08.409]                           if (is.null(name)) 
[16:06:08.409]                             next
[16:06:08.409]                           if (!grepl(pattern, name)) 
[16:06:08.409]                             next
[16:06:08.409]                           invokeRestart(restart)
[16:06:08.409]                           muffled <- TRUE
[16:06:08.409]                           break
[16:06:08.409]                         }
[16:06:08.409]                       }
[16:06:08.409]                     }
[16:06:08.409]                     invisible(muffled)
[16:06:08.409]                   }
[16:06:08.409]                   muffleCondition(cond)
[16:06:08.409]                 })
[16:06:08.409]             }))
[16:06:08.409]             future::FutureResult(value = ...future.value$value, 
[16:06:08.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:08.409]                   ...future.rng), globalenv = if (FALSE) 
[16:06:08.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:08.409]                     ...future.globalenv.names))
[16:06:08.409]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:08.409]         }, condition = base::local({
[16:06:08.409]             c <- base::c
[16:06:08.409]             inherits <- base::inherits
[16:06:08.409]             invokeRestart <- base::invokeRestart
[16:06:08.409]             length <- base::length
[16:06:08.409]             list <- base::list
[16:06:08.409]             seq.int <- base::seq.int
[16:06:08.409]             signalCondition <- base::signalCondition
[16:06:08.409]             sys.calls <- base::sys.calls
[16:06:08.409]             `[[` <- base::`[[`
[16:06:08.409]             `+` <- base::`+`
[16:06:08.409]             `<<-` <- base::`<<-`
[16:06:08.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:08.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:08.409]                   3L)]
[16:06:08.409]             }
[16:06:08.409]             function(cond) {
[16:06:08.409]                 is_error <- inherits(cond, "error")
[16:06:08.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:08.409]                   NULL)
[16:06:08.409]                 if (is_error) {
[16:06:08.409]                   sessionInformation <- function() {
[16:06:08.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:08.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:08.409]                       search = base::search(), system = base::Sys.info())
[16:06:08.409]                   }
[16:06:08.409]                   ...future.conditions[[length(...future.conditions) + 
[16:06:08.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:08.409]                     cond$call), session = sessionInformation(), 
[16:06:08.409]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:08.409]                   signalCondition(cond)
[16:06:08.409]                 }
[16:06:08.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:08.409]                 "immediateCondition"))) {
[16:06:08.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:08.409]                   ...future.conditions[[length(...future.conditions) + 
[16:06:08.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:08.409]                   if (TRUE && !signal) {
[16:06:08.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:08.409]                     {
[16:06:08.409]                       inherits <- base::inherits
[16:06:08.409]                       invokeRestart <- base::invokeRestart
[16:06:08.409]                       is.null <- base::is.null
[16:06:08.409]                       muffled <- FALSE
[16:06:08.409]                       if (inherits(cond, "message")) {
[16:06:08.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:08.409]                         if (muffled) 
[16:06:08.409]                           invokeRestart("muffleMessage")
[16:06:08.409]                       }
[16:06:08.409]                       else if (inherits(cond, "warning")) {
[16:06:08.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:08.409]                         if (muffled) 
[16:06:08.409]                           invokeRestart("muffleWarning")
[16:06:08.409]                       }
[16:06:08.409]                       else if (inherits(cond, "condition")) {
[16:06:08.409]                         if (!is.null(pattern)) {
[16:06:08.409]                           computeRestarts <- base::computeRestarts
[16:06:08.409]                           grepl <- base::grepl
[16:06:08.409]                           restarts <- computeRestarts(cond)
[16:06:08.409]                           for (restart in restarts) {
[16:06:08.409]                             name <- restart$name
[16:06:08.409]                             if (is.null(name)) 
[16:06:08.409]                               next
[16:06:08.409]                             if (!grepl(pattern, name)) 
[16:06:08.409]                               next
[16:06:08.409]                             invokeRestart(restart)
[16:06:08.409]                             muffled <- TRUE
[16:06:08.409]                             break
[16:06:08.409]                           }
[16:06:08.409]                         }
[16:06:08.409]                       }
[16:06:08.409]                       invisible(muffled)
[16:06:08.409]                     }
[16:06:08.409]                     muffleCondition(cond, pattern = "^muffle")
[16:06:08.409]                   }
[16:06:08.409]                 }
[16:06:08.409]                 else {
[16:06:08.409]                   if (TRUE) {
[16:06:08.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:08.409]                     {
[16:06:08.409]                       inherits <- base::inherits
[16:06:08.409]                       invokeRestart <- base::invokeRestart
[16:06:08.409]                       is.null <- base::is.null
[16:06:08.409]                       muffled <- FALSE
[16:06:08.409]                       if (inherits(cond, "message")) {
[16:06:08.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:08.409]                         if (muffled) 
[16:06:08.409]                           invokeRestart("muffleMessage")
[16:06:08.409]                       }
[16:06:08.409]                       else if (inherits(cond, "warning")) {
[16:06:08.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:08.409]                         if (muffled) 
[16:06:08.409]                           invokeRestart("muffleWarning")
[16:06:08.409]                       }
[16:06:08.409]                       else if (inherits(cond, "condition")) {
[16:06:08.409]                         if (!is.null(pattern)) {
[16:06:08.409]                           computeRestarts <- base::computeRestarts
[16:06:08.409]                           grepl <- base::grepl
[16:06:08.409]                           restarts <- computeRestarts(cond)
[16:06:08.409]                           for (restart in restarts) {
[16:06:08.409]                             name <- restart$name
[16:06:08.409]                             if (is.null(name)) 
[16:06:08.409]                               next
[16:06:08.409]                             if (!grepl(pattern, name)) 
[16:06:08.409]                               next
[16:06:08.409]                             invokeRestart(restart)
[16:06:08.409]                             muffled <- TRUE
[16:06:08.409]                             break
[16:06:08.409]                           }
[16:06:08.409]                         }
[16:06:08.409]                       }
[16:06:08.409]                       invisible(muffled)
[16:06:08.409]                     }
[16:06:08.409]                     muffleCondition(cond, pattern = "^muffle")
[16:06:08.409]                   }
[16:06:08.409]                 }
[16:06:08.409]             }
[16:06:08.409]         }))
[16:06:08.409]     }, error = function(ex) {
[16:06:08.409]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:08.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:08.409]                 ...future.rng), started = ...future.startTime, 
[16:06:08.409]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:08.409]             version = "1.8"), class = "FutureResult")
[16:06:08.409]     }, finally = {
[16:06:08.409]         if (!identical(...future.workdir, getwd())) 
[16:06:08.409]             setwd(...future.workdir)
[16:06:08.409]         {
[16:06:08.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:08.409]                 ...future.oldOptions$nwarnings <- NULL
[16:06:08.409]             }
[16:06:08.409]             base::options(...future.oldOptions)
[16:06:08.409]             if (.Platform$OS.type == "windows") {
[16:06:08.409]                 old_names <- names(...future.oldEnvVars)
[16:06:08.409]                 envs <- base::Sys.getenv()
[16:06:08.409]                 names <- names(envs)
[16:06:08.409]                 common <- intersect(names, old_names)
[16:06:08.409]                 added <- setdiff(names, old_names)
[16:06:08.409]                 removed <- setdiff(old_names, names)
[16:06:08.409]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:08.409]                   envs[common]]
[16:06:08.409]                 NAMES <- toupper(changed)
[16:06:08.409]                 args <- list()
[16:06:08.409]                 for (kk in seq_along(NAMES)) {
[16:06:08.409]                   name <- changed[[kk]]
[16:06:08.409]                   NAME <- NAMES[[kk]]
[16:06:08.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:08.409]                     next
[16:06:08.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:08.409]                 }
[16:06:08.409]                 NAMES <- toupper(added)
[16:06:08.409]                 for (kk in seq_along(NAMES)) {
[16:06:08.409]                   name <- added[[kk]]
[16:06:08.409]                   NAME <- NAMES[[kk]]
[16:06:08.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:08.409]                     next
[16:06:08.409]                   args[[name]] <- ""
[16:06:08.409]                 }
[16:06:08.409]                 NAMES <- toupper(removed)
[16:06:08.409]                 for (kk in seq_along(NAMES)) {
[16:06:08.409]                   name <- removed[[kk]]
[16:06:08.409]                   NAME <- NAMES[[kk]]
[16:06:08.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:08.409]                     next
[16:06:08.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:08.409]                 }
[16:06:08.409]                 if (length(args) > 0) 
[16:06:08.409]                   base::do.call(base::Sys.setenv, args = args)
[16:06:08.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:08.409]             }
[16:06:08.409]             else {
[16:06:08.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:08.409]             }
[16:06:08.409]             {
[16:06:08.409]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:08.409]                   0L) {
[16:06:08.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:08.409]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:08.409]                   base::options(opts)
[16:06:08.409]                 }
[16:06:08.409]                 {
[16:06:08.409]                   {
[16:06:08.409]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:08.409]                     NULL
[16:06:08.409]                   }
[16:06:08.409]                   options(future.plan = NULL)
[16:06:08.409]                   if (is.na(NA_character_)) 
[16:06:08.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:08.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:08.409]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:08.409]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:08.409]                     envir = parent.frame()) 
[16:06:08.409]                   {
[16:06:08.409]                     if (is.function(workers)) 
[16:06:08.409]                       workers <- workers()
[16:06:08.409]                     workers <- structure(as.integer(workers), 
[16:06:08.409]                       class = class(workers))
[16:06:08.409]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:08.409]                       workers >= 1)
[16:06:08.409]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:08.409]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:08.409]                     }
[16:06:08.409]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:08.409]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:08.409]                       envir = envir)
[16:06:08.409]                     if (!future$lazy) 
[16:06:08.409]                       future <- run(future)
[16:06:08.409]                     invisible(future)
[16:06:08.409]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:08.409]                 }
[16:06:08.409]             }
[16:06:08.409]         }
[16:06:08.409]     })
[16:06:08.409]     if (TRUE) {
[16:06:08.409]         base::sink(type = "output", split = FALSE)
[16:06:08.409]         if (TRUE) {
[16:06:08.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:08.409]         }
[16:06:08.409]         else {
[16:06:08.409]             ...future.result["stdout"] <- base::list(NULL)
[16:06:08.409]         }
[16:06:08.409]         base::close(...future.stdout)
[16:06:08.409]         ...future.stdout <- NULL
[16:06:08.409]     }
[16:06:08.409]     ...future.result$conditions <- ...future.conditions
[16:06:08.409]     ...future.result$finished <- base::Sys.time()
[16:06:08.409]     ...future.result
[16:06:08.409] }
[16:06:08.412] MultisessionFuture started
[16:06:08.413] - Launch lazy future ... done
[16:06:08.413] run() for ‘MultisessionFuture’ ... done
[16:06:08.961] receiveMessageFromWorker() for ClusterFuture ...
[16:06:08.961] - Validating connection of MultisessionFuture
[16:06:08.961] - received message: FutureResult
[16:06:08.961] - Received FutureResult
[16:06:08.961] - Erased future from FutureRegistry
[16:06:08.961] result() for ClusterFuture ...
[16:06:08.962] - result already collected: FutureResult
[16:06:08.962] result() for ClusterFuture ... done
[16:06:08.962] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:08.962] resolve() on list ...
[16:06:08.962]  recursive: 98
[16:06:08.962]  length: 2
[16:06:08.962]  elements: ‘a’, ‘b’
[16:06:08.962]  length: 1 (resolved future 1)
[16:06:08.962]  length: 0 (resolved future 2)
[16:06:08.962] resolve() on list ... DONE
[16:06:08.963] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:06:08.963] getGlobalsAndPackages() ...
[16:06:08.963] Searching for globals...
[16:06:08.963] - globals found: [2] ‘list’, ‘stop’
[16:06:08.964] Searching for globals ... DONE
[16:06:08.964] Resolving globals: FALSE
[16:06:08.964] 
[16:06:08.964] 
[16:06:08.964] getGlobalsAndPackages() ... DONE
[16:06:08.964] run() for ‘Future’ ...
[16:06:08.965] - state: ‘created’
[16:06:08.965] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:08.978] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:08.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:08.979]   - Field: ‘node’
[16:06:08.979]   - Field: ‘label’
[16:06:08.979]   - Field: ‘local’
[16:06:08.979]   - Field: ‘owner’
[16:06:08.979]   - Field: ‘envir’
[16:06:08.979]   - Field: ‘workers’
[16:06:08.979]   - Field: ‘packages’
[16:06:08.979]   - Field: ‘gc’
[16:06:08.979]   - Field: ‘conditions’
[16:06:08.980]   - Field: ‘persistent’
[16:06:08.980]   - Field: ‘expr’
[16:06:08.980]   - Field: ‘uuid’
[16:06:08.980]   - Field: ‘seed’
[16:06:08.980]   - Field: ‘version’
[16:06:08.980]   - Field: ‘result’
[16:06:08.980]   - Field: ‘asynchronous’
[16:06:08.980]   - Field: ‘calls’
[16:06:08.980]   - Field: ‘globals’
[16:06:08.980]   - Field: ‘stdout’
[16:06:08.980]   - Field: ‘earlySignal’
[16:06:08.981]   - Field: ‘lazy’
[16:06:08.981]   - Field: ‘state’
[16:06:08.981] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:08.981] - Launch lazy future ...
[16:06:08.981] Packages needed by the future expression (n = 0): <none>
[16:06:08.981] Packages needed by future strategies (n = 0): <none>
[16:06:08.982] {
[16:06:08.982]     {
[16:06:08.982]         {
[16:06:08.982]             ...future.startTime <- base::Sys.time()
[16:06:08.982]             {
[16:06:08.982]                 {
[16:06:08.982]                   {
[16:06:08.982]                     {
[16:06:08.982]                       base::local({
[16:06:08.982]                         has_future <- base::requireNamespace("future", 
[16:06:08.982]                           quietly = TRUE)
[16:06:08.982]                         if (has_future) {
[16:06:08.982]                           ns <- base::getNamespace("future")
[16:06:08.982]                           version <- ns[[".package"]][["version"]]
[16:06:08.982]                           if (is.null(version)) 
[16:06:08.982]                             version <- utils::packageVersion("future")
[16:06:08.982]                         }
[16:06:08.982]                         else {
[16:06:08.982]                           version <- NULL
[16:06:08.982]                         }
[16:06:08.982]                         if (!has_future || version < "1.8.0") {
[16:06:08.982]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:08.982]                             "", base::R.version$version.string), 
[16:06:08.982]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:08.982]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:08.982]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:08.982]                               "release", "version")], collapse = " "), 
[16:06:08.982]                             hostname = base::Sys.info()[["nodename"]])
[16:06:08.982]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:08.982]                             info)
[16:06:08.982]                           info <- base::paste(info, collapse = "; ")
[16:06:08.982]                           if (!has_future) {
[16:06:08.982]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:08.982]                               info)
[16:06:08.982]                           }
[16:06:08.982]                           else {
[16:06:08.982]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:08.982]                               info, version)
[16:06:08.982]                           }
[16:06:08.982]                           base::stop(msg)
[16:06:08.982]                         }
[16:06:08.982]                       })
[16:06:08.982]                     }
[16:06:08.982]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:08.982]                     base::options(mc.cores = 1L)
[16:06:08.982]                   }
[16:06:08.982]                   options(future.plan = NULL)
[16:06:08.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:08.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:08.982]                 }
[16:06:08.982]                 ...future.workdir <- getwd()
[16:06:08.982]             }
[16:06:08.982]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:08.982]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:08.982]         }
[16:06:08.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:08.982]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:08.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:08.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:08.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:08.982]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:08.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:08.982]             base::names(...future.oldOptions))
[16:06:08.982]     }
[16:06:08.982]     if (FALSE) {
[16:06:08.982]     }
[16:06:08.982]     else {
[16:06:08.982]         if (TRUE) {
[16:06:08.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:08.982]                 open = "w")
[16:06:08.982]         }
[16:06:08.982]         else {
[16:06:08.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:08.982]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:08.982]         }
[16:06:08.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:08.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:08.982]             base::sink(type = "output", split = FALSE)
[16:06:08.982]             base::close(...future.stdout)
[16:06:08.982]         }, add = TRUE)
[16:06:08.982]     }
[16:06:08.982]     ...future.frame <- base::sys.nframe()
[16:06:08.982]     ...future.conditions <- base::list()
[16:06:08.982]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:08.982]     if (FALSE) {
[16:06:08.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:08.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:08.982]     }
[16:06:08.982]     ...future.result <- base::tryCatch({
[16:06:08.982]         base::withCallingHandlers({
[16:06:08.982]             ...future.value <- base::withVisible(base::local({
[16:06:08.982]                 ...future.makeSendCondition <- base::local({
[16:06:08.982]                   sendCondition <- NULL
[16:06:08.982]                   function(frame = 1L) {
[16:06:08.982]                     if (is.function(sendCondition)) 
[16:06:08.982]                       return(sendCondition)
[16:06:08.982]                     ns <- getNamespace("parallel")
[16:06:08.982]                     if (exists("sendData", mode = "function", 
[16:06:08.982]                       envir = ns)) {
[16:06:08.982]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:08.982]                         envir = ns)
[16:06:08.982]                       envir <- sys.frame(frame)
[16:06:08.982]                       master <- NULL
[16:06:08.982]                       while (!identical(envir, .GlobalEnv) && 
[16:06:08.982]                         !identical(envir, emptyenv())) {
[16:06:08.982]                         if (exists("master", mode = "list", envir = envir, 
[16:06:08.982]                           inherits = FALSE)) {
[16:06:08.982]                           master <- get("master", mode = "list", 
[16:06:08.982]                             envir = envir, inherits = FALSE)
[16:06:08.982]                           if (inherits(master, c("SOCKnode", 
[16:06:08.982]                             "SOCK0node"))) {
[16:06:08.982]                             sendCondition <<- function(cond) {
[16:06:08.982]                               data <- list(type = "VALUE", value = cond, 
[16:06:08.982]                                 success = TRUE)
[16:06:08.982]                               parallel_sendData(master, data)
[16:06:08.982]                             }
[16:06:08.982]                             return(sendCondition)
[16:06:08.982]                           }
[16:06:08.982]                         }
[16:06:08.982]                         frame <- frame + 1L
[16:06:08.982]                         envir <- sys.frame(frame)
[16:06:08.982]                       }
[16:06:08.982]                     }
[16:06:08.982]                     sendCondition <<- function(cond) NULL
[16:06:08.982]                   }
[16:06:08.982]                 })
[16:06:08.982]                 withCallingHandlers({
[16:06:08.982]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:08.982]                 }, immediateCondition = function(cond) {
[16:06:08.982]                   sendCondition <- ...future.makeSendCondition()
[16:06:08.982]                   sendCondition(cond)
[16:06:08.982]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:08.982]                   {
[16:06:08.982]                     inherits <- base::inherits
[16:06:08.982]                     invokeRestart <- base::invokeRestart
[16:06:08.982]                     is.null <- base::is.null
[16:06:08.982]                     muffled <- FALSE
[16:06:08.982]                     if (inherits(cond, "message")) {
[16:06:08.982]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:08.982]                       if (muffled) 
[16:06:08.982]                         invokeRestart("muffleMessage")
[16:06:08.982]                     }
[16:06:08.982]                     else if (inherits(cond, "warning")) {
[16:06:08.982]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:08.982]                       if (muffled) 
[16:06:08.982]                         invokeRestart("muffleWarning")
[16:06:08.982]                     }
[16:06:08.982]                     else if (inherits(cond, "condition")) {
[16:06:08.982]                       if (!is.null(pattern)) {
[16:06:08.982]                         computeRestarts <- base::computeRestarts
[16:06:08.982]                         grepl <- base::grepl
[16:06:08.982]                         restarts <- computeRestarts(cond)
[16:06:08.982]                         for (restart in restarts) {
[16:06:08.982]                           name <- restart$name
[16:06:08.982]                           if (is.null(name)) 
[16:06:08.982]                             next
[16:06:08.982]                           if (!grepl(pattern, name)) 
[16:06:08.982]                             next
[16:06:08.982]                           invokeRestart(restart)
[16:06:08.982]                           muffled <- TRUE
[16:06:08.982]                           break
[16:06:08.982]                         }
[16:06:08.982]                       }
[16:06:08.982]                     }
[16:06:08.982]                     invisible(muffled)
[16:06:08.982]                   }
[16:06:08.982]                   muffleCondition(cond)
[16:06:08.982]                 })
[16:06:08.982]             }))
[16:06:08.982]             future::FutureResult(value = ...future.value$value, 
[16:06:08.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:08.982]                   ...future.rng), globalenv = if (FALSE) 
[16:06:08.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:08.982]                     ...future.globalenv.names))
[16:06:08.982]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:08.982]         }, condition = base::local({
[16:06:08.982]             c <- base::c
[16:06:08.982]             inherits <- base::inherits
[16:06:08.982]             invokeRestart <- base::invokeRestart
[16:06:08.982]             length <- base::length
[16:06:08.982]             list <- base::list
[16:06:08.982]             seq.int <- base::seq.int
[16:06:08.982]             signalCondition <- base::signalCondition
[16:06:08.982]             sys.calls <- base::sys.calls
[16:06:08.982]             `[[` <- base::`[[`
[16:06:08.982]             `+` <- base::`+`
[16:06:08.982]             `<<-` <- base::`<<-`
[16:06:08.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:08.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:08.982]                   3L)]
[16:06:08.982]             }
[16:06:08.982]             function(cond) {
[16:06:08.982]                 is_error <- inherits(cond, "error")
[16:06:08.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:08.982]                   NULL)
[16:06:08.982]                 if (is_error) {
[16:06:08.982]                   sessionInformation <- function() {
[16:06:08.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:08.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:08.982]                       search = base::search(), system = base::Sys.info())
[16:06:08.982]                   }
[16:06:08.982]                   ...future.conditions[[length(...future.conditions) + 
[16:06:08.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:08.982]                     cond$call), session = sessionInformation(), 
[16:06:08.982]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:08.982]                   signalCondition(cond)
[16:06:08.982]                 }
[16:06:08.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:08.982]                 "immediateCondition"))) {
[16:06:08.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:08.982]                   ...future.conditions[[length(...future.conditions) + 
[16:06:08.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:08.982]                   if (TRUE && !signal) {
[16:06:08.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:08.982]                     {
[16:06:08.982]                       inherits <- base::inherits
[16:06:08.982]                       invokeRestart <- base::invokeRestart
[16:06:08.982]                       is.null <- base::is.null
[16:06:08.982]                       muffled <- FALSE
[16:06:08.982]                       if (inherits(cond, "message")) {
[16:06:08.982]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:08.982]                         if (muffled) 
[16:06:08.982]                           invokeRestart("muffleMessage")
[16:06:08.982]                       }
[16:06:08.982]                       else if (inherits(cond, "warning")) {
[16:06:08.982]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:08.982]                         if (muffled) 
[16:06:08.982]                           invokeRestart("muffleWarning")
[16:06:08.982]                       }
[16:06:08.982]                       else if (inherits(cond, "condition")) {
[16:06:08.982]                         if (!is.null(pattern)) {
[16:06:08.982]                           computeRestarts <- base::computeRestarts
[16:06:08.982]                           grepl <- base::grepl
[16:06:08.982]                           restarts <- computeRestarts(cond)
[16:06:08.982]                           for (restart in restarts) {
[16:06:08.982]                             name <- restart$name
[16:06:08.982]                             if (is.null(name)) 
[16:06:08.982]                               next
[16:06:08.982]                             if (!grepl(pattern, name)) 
[16:06:08.982]                               next
[16:06:08.982]                             invokeRestart(restart)
[16:06:08.982]                             muffled <- TRUE
[16:06:08.982]                             break
[16:06:08.982]                           }
[16:06:08.982]                         }
[16:06:08.982]                       }
[16:06:08.982]                       invisible(muffled)
[16:06:08.982]                     }
[16:06:08.982]                     muffleCondition(cond, pattern = "^muffle")
[16:06:08.982]                   }
[16:06:08.982]                 }
[16:06:08.982]                 else {
[16:06:08.982]                   if (TRUE) {
[16:06:08.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:08.982]                     {
[16:06:08.982]                       inherits <- base::inherits
[16:06:08.982]                       invokeRestart <- base::invokeRestart
[16:06:08.982]                       is.null <- base::is.null
[16:06:08.982]                       muffled <- FALSE
[16:06:08.982]                       if (inherits(cond, "message")) {
[16:06:08.982]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:08.982]                         if (muffled) 
[16:06:08.982]                           invokeRestart("muffleMessage")
[16:06:08.982]                       }
[16:06:08.982]                       else if (inherits(cond, "warning")) {
[16:06:08.982]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:08.982]                         if (muffled) 
[16:06:08.982]                           invokeRestart("muffleWarning")
[16:06:08.982]                       }
[16:06:08.982]                       else if (inherits(cond, "condition")) {
[16:06:08.982]                         if (!is.null(pattern)) {
[16:06:08.982]                           computeRestarts <- base::computeRestarts
[16:06:08.982]                           grepl <- base::grepl
[16:06:08.982]                           restarts <- computeRestarts(cond)
[16:06:08.982]                           for (restart in restarts) {
[16:06:08.982]                             name <- restart$name
[16:06:08.982]                             if (is.null(name)) 
[16:06:08.982]                               next
[16:06:08.982]                             if (!grepl(pattern, name)) 
[16:06:08.982]                               next
[16:06:08.982]                             invokeRestart(restart)
[16:06:08.982]                             muffled <- TRUE
[16:06:08.982]                             break
[16:06:08.982]                           }
[16:06:08.982]                         }
[16:06:08.982]                       }
[16:06:08.982]                       invisible(muffled)
[16:06:08.982]                     }
[16:06:08.982]                     muffleCondition(cond, pattern = "^muffle")
[16:06:08.982]                   }
[16:06:08.982]                 }
[16:06:08.982]             }
[16:06:08.982]         }))
[16:06:08.982]     }, error = function(ex) {
[16:06:08.982]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:08.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:08.982]                 ...future.rng), started = ...future.startTime, 
[16:06:08.982]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:08.982]             version = "1.8"), class = "FutureResult")
[16:06:08.982]     }, finally = {
[16:06:08.982]         if (!identical(...future.workdir, getwd())) 
[16:06:08.982]             setwd(...future.workdir)
[16:06:08.982]         {
[16:06:08.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:08.982]                 ...future.oldOptions$nwarnings <- NULL
[16:06:08.982]             }
[16:06:08.982]             base::options(...future.oldOptions)
[16:06:08.982]             if (.Platform$OS.type == "windows") {
[16:06:08.982]                 old_names <- names(...future.oldEnvVars)
[16:06:08.982]                 envs <- base::Sys.getenv()
[16:06:08.982]                 names <- names(envs)
[16:06:08.982]                 common <- intersect(names, old_names)
[16:06:08.982]                 added <- setdiff(names, old_names)
[16:06:08.982]                 removed <- setdiff(old_names, names)
[16:06:08.982]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:08.982]                   envs[common]]
[16:06:08.982]                 NAMES <- toupper(changed)
[16:06:08.982]                 args <- list()
[16:06:08.982]                 for (kk in seq_along(NAMES)) {
[16:06:08.982]                   name <- changed[[kk]]
[16:06:08.982]                   NAME <- NAMES[[kk]]
[16:06:08.982]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:08.982]                     next
[16:06:08.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:08.982]                 }
[16:06:08.982]                 NAMES <- toupper(added)
[16:06:08.982]                 for (kk in seq_along(NAMES)) {
[16:06:08.982]                   name <- added[[kk]]
[16:06:08.982]                   NAME <- NAMES[[kk]]
[16:06:08.982]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:08.982]                     next
[16:06:08.982]                   args[[name]] <- ""
[16:06:08.982]                 }
[16:06:08.982]                 NAMES <- toupper(removed)
[16:06:08.982]                 for (kk in seq_along(NAMES)) {
[16:06:08.982]                   name <- removed[[kk]]
[16:06:08.982]                   NAME <- NAMES[[kk]]
[16:06:08.982]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:08.982]                     next
[16:06:08.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:08.982]                 }
[16:06:08.982]                 if (length(args) > 0) 
[16:06:08.982]                   base::do.call(base::Sys.setenv, args = args)
[16:06:08.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:08.982]             }
[16:06:08.982]             else {
[16:06:08.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:08.982]             }
[16:06:08.982]             {
[16:06:08.982]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:08.982]                   0L) {
[16:06:08.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:08.982]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:08.982]                   base::options(opts)
[16:06:08.982]                 }
[16:06:08.982]                 {
[16:06:08.982]                   {
[16:06:08.982]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:08.982]                     NULL
[16:06:08.982]                   }
[16:06:08.982]                   options(future.plan = NULL)
[16:06:08.982]                   if (is.na(NA_character_)) 
[16:06:08.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:08.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:08.982]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:08.982]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:08.982]                     envir = parent.frame()) 
[16:06:08.982]                   {
[16:06:08.982]                     if (is.function(workers)) 
[16:06:08.982]                       workers <- workers()
[16:06:08.982]                     workers <- structure(as.integer(workers), 
[16:06:08.982]                       class = class(workers))
[16:06:08.982]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:08.982]                       workers >= 1)
[16:06:08.982]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:08.982]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:08.982]                     }
[16:06:08.982]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:08.982]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:08.982]                       envir = envir)
[16:06:08.982]                     if (!future$lazy) 
[16:06:08.982]                       future <- run(future)
[16:06:08.982]                     invisible(future)
[16:06:08.982]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:08.982]                 }
[16:06:08.982]             }
[16:06:08.982]         }
[16:06:08.982]     })
[16:06:08.982]     if (TRUE) {
[16:06:08.982]         base::sink(type = "output", split = FALSE)
[16:06:08.982]         if (TRUE) {
[16:06:08.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:08.982]         }
[16:06:08.982]         else {
[16:06:08.982]             ...future.result["stdout"] <- base::list(NULL)
[16:06:08.982]         }
[16:06:08.982]         base::close(...future.stdout)
[16:06:08.982]         ...future.stdout <- NULL
[16:06:08.982]     }
[16:06:08.982]     ...future.result$conditions <- ...future.conditions
[16:06:08.982]     ...future.result$finished <- base::Sys.time()
[16:06:08.982]     ...future.result
[16:06:08.982] }
[16:06:08.985] MultisessionFuture started
[16:06:08.985] - Launch lazy future ... done
[16:06:08.985] run() for ‘MultisessionFuture’ ... done
[16:06:09.032] receiveMessageFromWorker() for ClusterFuture ...
[16:06:09.032] - Validating connection of MultisessionFuture
[16:06:09.033] - received message: FutureResult
[16:06:09.033] - Received FutureResult
[16:06:09.033] - Erased future from FutureRegistry
[16:06:09.033] result() for ClusterFuture ...
[16:06:09.033] - result already collected: FutureResult
[16:06:09.033] result() for ClusterFuture ... done
[16:06:09.033] signalConditions() ...
[16:06:09.034]  - include = ‘immediateCondition’
[16:06:09.034]  - exclude = 
[16:06:09.034]  - resignal = FALSE
[16:06:09.034]  - Number of conditions: 1
[16:06:09.034] signalConditions() ... done
[16:06:09.034] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:09.034] A MultisessionFuture was resolved
[16:06:09.034] getGlobalsAndPackages() ...
[16:06:09.034] Searching for globals...
[16:06:09.035] - globals found: [2] ‘list’, ‘stop’
[16:06:09.035] Searching for globals ... DONE
[16:06:09.035] Resolving globals: FALSE
[16:06:09.036] 
[16:06:09.036] 
[16:06:09.036] getGlobalsAndPackages() ... DONE
[16:06:09.036] run() for ‘Future’ ...
[16:06:09.036] - state: ‘created’
[16:06:09.036] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:09.050] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:09.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:09.051]   - Field: ‘node’
[16:06:09.051]   - Field: ‘label’
[16:06:09.051]   - Field: ‘local’
[16:06:09.051]   - Field: ‘owner’
[16:06:09.051]   - Field: ‘envir’
[16:06:09.051]   - Field: ‘workers’
[16:06:09.051]   - Field: ‘packages’
[16:06:09.052]   - Field: ‘gc’
[16:06:09.052]   - Field: ‘conditions’
[16:06:09.052]   - Field: ‘persistent’
[16:06:09.052]   - Field: ‘expr’
[16:06:09.052]   - Field: ‘uuid’
[16:06:09.052]   - Field: ‘seed’
[16:06:09.052]   - Field: ‘version’
[16:06:09.052]   - Field: ‘result’
[16:06:09.052]   - Field: ‘asynchronous’
[16:06:09.052]   - Field: ‘calls’
[16:06:09.052]   - Field: ‘globals’
[16:06:09.053]   - Field: ‘stdout’
[16:06:09.053]   - Field: ‘earlySignal’
[16:06:09.053]   - Field: ‘lazy’
[16:06:09.053]   - Field: ‘state’
[16:06:09.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:09.053] - Launch lazy future ...
[16:06:09.053] Packages needed by the future expression (n = 0): <none>
[16:06:09.053] Packages needed by future strategies (n = 0): <none>
[16:06:09.054] {
[16:06:09.054]     {
[16:06:09.054]         {
[16:06:09.054]             ...future.startTime <- base::Sys.time()
[16:06:09.054]             {
[16:06:09.054]                 {
[16:06:09.054]                   {
[16:06:09.054]                     {
[16:06:09.054]                       base::local({
[16:06:09.054]                         has_future <- base::requireNamespace("future", 
[16:06:09.054]                           quietly = TRUE)
[16:06:09.054]                         if (has_future) {
[16:06:09.054]                           ns <- base::getNamespace("future")
[16:06:09.054]                           version <- ns[[".package"]][["version"]]
[16:06:09.054]                           if (is.null(version)) 
[16:06:09.054]                             version <- utils::packageVersion("future")
[16:06:09.054]                         }
[16:06:09.054]                         else {
[16:06:09.054]                           version <- NULL
[16:06:09.054]                         }
[16:06:09.054]                         if (!has_future || version < "1.8.0") {
[16:06:09.054]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:09.054]                             "", base::R.version$version.string), 
[16:06:09.054]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:09.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:09.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:09.054]                               "release", "version")], collapse = " "), 
[16:06:09.054]                             hostname = base::Sys.info()[["nodename"]])
[16:06:09.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:09.054]                             info)
[16:06:09.054]                           info <- base::paste(info, collapse = "; ")
[16:06:09.054]                           if (!has_future) {
[16:06:09.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:09.054]                               info)
[16:06:09.054]                           }
[16:06:09.054]                           else {
[16:06:09.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:09.054]                               info, version)
[16:06:09.054]                           }
[16:06:09.054]                           base::stop(msg)
[16:06:09.054]                         }
[16:06:09.054]                       })
[16:06:09.054]                     }
[16:06:09.054]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:09.054]                     base::options(mc.cores = 1L)
[16:06:09.054]                   }
[16:06:09.054]                   options(future.plan = NULL)
[16:06:09.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:09.054]                 }
[16:06:09.054]                 ...future.workdir <- getwd()
[16:06:09.054]             }
[16:06:09.054]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:09.054]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:09.054]         }
[16:06:09.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:09.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:09.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:09.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:09.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:09.054]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:09.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:09.054]             base::names(...future.oldOptions))
[16:06:09.054]     }
[16:06:09.054]     if (FALSE) {
[16:06:09.054]     }
[16:06:09.054]     else {
[16:06:09.054]         if (TRUE) {
[16:06:09.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:09.054]                 open = "w")
[16:06:09.054]         }
[16:06:09.054]         else {
[16:06:09.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:09.054]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:09.054]         }
[16:06:09.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:09.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:09.054]             base::sink(type = "output", split = FALSE)
[16:06:09.054]             base::close(...future.stdout)
[16:06:09.054]         }, add = TRUE)
[16:06:09.054]     }
[16:06:09.054]     ...future.frame <- base::sys.nframe()
[16:06:09.054]     ...future.conditions <- base::list()
[16:06:09.054]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:09.054]     if (FALSE) {
[16:06:09.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:09.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:09.054]     }
[16:06:09.054]     ...future.result <- base::tryCatch({
[16:06:09.054]         base::withCallingHandlers({
[16:06:09.054]             ...future.value <- base::withVisible(base::local({
[16:06:09.054]                 ...future.makeSendCondition <- base::local({
[16:06:09.054]                   sendCondition <- NULL
[16:06:09.054]                   function(frame = 1L) {
[16:06:09.054]                     if (is.function(sendCondition)) 
[16:06:09.054]                       return(sendCondition)
[16:06:09.054]                     ns <- getNamespace("parallel")
[16:06:09.054]                     if (exists("sendData", mode = "function", 
[16:06:09.054]                       envir = ns)) {
[16:06:09.054]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:09.054]                         envir = ns)
[16:06:09.054]                       envir <- sys.frame(frame)
[16:06:09.054]                       master <- NULL
[16:06:09.054]                       while (!identical(envir, .GlobalEnv) && 
[16:06:09.054]                         !identical(envir, emptyenv())) {
[16:06:09.054]                         if (exists("master", mode = "list", envir = envir, 
[16:06:09.054]                           inherits = FALSE)) {
[16:06:09.054]                           master <- get("master", mode = "list", 
[16:06:09.054]                             envir = envir, inherits = FALSE)
[16:06:09.054]                           if (inherits(master, c("SOCKnode", 
[16:06:09.054]                             "SOCK0node"))) {
[16:06:09.054]                             sendCondition <<- function(cond) {
[16:06:09.054]                               data <- list(type = "VALUE", value = cond, 
[16:06:09.054]                                 success = TRUE)
[16:06:09.054]                               parallel_sendData(master, data)
[16:06:09.054]                             }
[16:06:09.054]                             return(sendCondition)
[16:06:09.054]                           }
[16:06:09.054]                         }
[16:06:09.054]                         frame <- frame + 1L
[16:06:09.054]                         envir <- sys.frame(frame)
[16:06:09.054]                       }
[16:06:09.054]                     }
[16:06:09.054]                     sendCondition <<- function(cond) NULL
[16:06:09.054]                   }
[16:06:09.054]                 })
[16:06:09.054]                 withCallingHandlers({
[16:06:09.054]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:09.054]                 }, immediateCondition = function(cond) {
[16:06:09.054]                   sendCondition <- ...future.makeSendCondition()
[16:06:09.054]                   sendCondition(cond)
[16:06:09.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.054]                   {
[16:06:09.054]                     inherits <- base::inherits
[16:06:09.054]                     invokeRestart <- base::invokeRestart
[16:06:09.054]                     is.null <- base::is.null
[16:06:09.054]                     muffled <- FALSE
[16:06:09.054]                     if (inherits(cond, "message")) {
[16:06:09.054]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:09.054]                       if (muffled) 
[16:06:09.054]                         invokeRestart("muffleMessage")
[16:06:09.054]                     }
[16:06:09.054]                     else if (inherits(cond, "warning")) {
[16:06:09.054]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:09.054]                       if (muffled) 
[16:06:09.054]                         invokeRestart("muffleWarning")
[16:06:09.054]                     }
[16:06:09.054]                     else if (inherits(cond, "condition")) {
[16:06:09.054]                       if (!is.null(pattern)) {
[16:06:09.054]                         computeRestarts <- base::computeRestarts
[16:06:09.054]                         grepl <- base::grepl
[16:06:09.054]                         restarts <- computeRestarts(cond)
[16:06:09.054]                         for (restart in restarts) {
[16:06:09.054]                           name <- restart$name
[16:06:09.054]                           if (is.null(name)) 
[16:06:09.054]                             next
[16:06:09.054]                           if (!grepl(pattern, name)) 
[16:06:09.054]                             next
[16:06:09.054]                           invokeRestart(restart)
[16:06:09.054]                           muffled <- TRUE
[16:06:09.054]                           break
[16:06:09.054]                         }
[16:06:09.054]                       }
[16:06:09.054]                     }
[16:06:09.054]                     invisible(muffled)
[16:06:09.054]                   }
[16:06:09.054]                   muffleCondition(cond)
[16:06:09.054]                 })
[16:06:09.054]             }))
[16:06:09.054]             future::FutureResult(value = ...future.value$value, 
[16:06:09.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.054]                   ...future.rng), globalenv = if (FALSE) 
[16:06:09.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:09.054]                     ...future.globalenv.names))
[16:06:09.054]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:09.054]         }, condition = base::local({
[16:06:09.054]             c <- base::c
[16:06:09.054]             inherits <- base::inherits
[16:06:09.054]             invokeRestart <- base::invokeRestart
[16:06:09.054]             length <- base::length
[16:06:09.054]             list <- base::list
[16:06:09.054]             seq.int <- base::seq.int
[16:06:09.054]             signalCondition <- base::signalCondition
[16:06:09.054]             sys.calls <- base::sys.calls
[16:06:09.054]             `[[` <- base::`[[`
[16:06:09.054]             `+` <- base::`+`
[16:06:09.054]             `<<-` <- base::`<<-`
[16:06:09.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:09.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:09.054]                   3L)]
[16:06:09.054]             }
[16:06:09.054]             function(cond) {
[16:06:09.054]                 is_error <- inherits(cond, "error")
[16:06:09.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:09.054]                   NULL)
[16:06:09.054]                 if (is_error) {
[16:06:09.054]                   sessionInformation <- function() {
[16:06:09.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:09.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:09.054]                       search = base::search(), system = base::Sys.info())
[16:06:09.054]                   }
[16:06:09.054]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:09.054]                     cond$call), session = sessionInformation(), 
[16:06:09.054]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:09.054]                   signalCondition(cond)
[16:06:09.054]                 }
[16:06:09.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:09.054]                 "immediateCondition"))) {
[16:06:09.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:09.054]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:09.054]                   if (TRUE && !signal) {
[16:06:09.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.054]                     {
[16:06:09.054]                       inherits <- base::inherits
[16:06:09.054]                       invokeRestart <- base::invokeRestart
[16:06:09.054]                       is.null <- base::is.null
[16:06:09.054]                       muffled <- FALSE
[16:06:09.054]                       if (inherits(cond, "message")) {
[16:06:09.054]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.054]                         if (muffled) 
[16:06:09.054]                           invokeRestart("muffleMessage")
[16:06:09.054]                       }
[16:06:09.054]                       else if (inherits(cond, "warning")) {
[16:06:09.054]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.054]                         if (muffled) 
[16:06:09.054]                           invokeRestart("muffleWarning")
[16:06:09.054]                       }
[16:06:09.054]                       else if (inherits(cond, "condition")) {
[16:06:09.054]                         if (!is.null(pattern)) {
[16:06:09.054]                           computeRestarts <- base::computeRestarts
[16:06:09.054]                           grepl <- base::grepl
[16:06:09.054]                           restarts <- computeRestarts(cond)
[16:06:09.054]                           for (restart in restarts) {
[16:06:09.054]                             name <- restart$name
[16:06:09.054]                             if (is.null(name)) 
[16:06:09.054]                               next
[16:06:09.054]                             if (!grepl(pattern, name)) 
[16:06:09.054]                               next
[16:06:09.054]                             invokeRestart(restart)
[16:06:09.054]                             muffled <- TRUE
[16:06:09.054]                             break
[16:06:09.054]                           }
[16:06:09.054]                         }
[16:06:09.054]                       }
[16:06:09.054]                       invisible(muffled)
[16:06:09.054]                     }
[16:06:09.054]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.054]                   }
[16:06:09.054]                 }
[16:06:09.054]                 else {
[16:06:09.054]                   if (TRUE) {
[16:06:09.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.054]                     {
[16:06:09.054]                       inherits <- base::inherits
[16:06:09.054]                       invokeRestart <- base::invokeRestart
[16:06:09.054]                       is.null <- base::is.null
[16:06:09.054]                       muffled <- FALSE
[16:06:09.054]                       if (inherits(cond, "message")) {
[16:06:09.054]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.054]                         if (muffled) 
[16:06:09.054]                           invokeRestart("muffleMessage")
[16:06:09.054]                       }
[16:06:09.054]                       else if (inherits(cond, "warning")) {
[16:06:09.054]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.054]                         if (muffled) 
[16:06:09.054]                           invokeRestart("muffleWarning")
[16:06:09.054]                       }
[16:06:09.054]                       else if (inherits(cond, "condition")) {
[16:06:09.054]                         if (!is.null(pattern)) {
[16:06:09.054]                           computeRestarts <- base::computeRestarts
[16:06:09.054]                           grepl <- base::grepl
[16:06:09.054]                           restarts <- computeRestarts(cond)
[16:06:09.054]                           for (restart in restarts) {
[16:06:09.054]                             name <- restart$name
[16:06:09.054]                             if (is.null(name)) 
[16:06:09.054]                               next
[16:06:09.054]                             if (!grepl(pattern, name)) 
[16:06:09.054]                               next
[16:06:09.054]                             invokeRestart(restart)
[16:06:09.054]                             muffled <- TRUE
[16:06:09.054]                             break
[16:06:09.054]                           }
[16:06:09.054]                         }
[16:06:09.054]                       }
[16:06:09.054]                       invisible(muffled)
[16:06:09.054]                     }
[16:06:09.054]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.054]                   }
[16:06:09.054]                 }
[16:06:09.054]             }
[16:06:09.054]         }))
[16:06:09.054]     }, error = function(ex) {
[16:06:09.054]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:09.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.054]                 ...future.rng), started = ...future.startTime, 
[16:06:09.054]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:09.054]             version = "1.8"), class = "FutureResult")
[16:06:09.054]     }, finally = {
[16:06:09.054]         if (!identical(...future.workdir, getwd())) 
[16:06:09.054]             setwd(...future.workdir)
[16:06:09.054]         {
[16:06:09.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:09.054]                 ...future.oldOptions$nwarnings <- NULL
[16:06:09.054]             }
[16:06:09.054]             base::options(...future.oldOptions)
[16:06:09.054]             if (.Platform$OS.type == "windows") {
[16:06:09.054]                 old_names <- names(...future.oldEnvVars)
[16:06:09.054]                 envs <- base::Sys.getenv()
[16:06:09.054]                 names <- names(envs)
[16:06:09.054]                 common <- intersect(names, old_names)
[16:06:09.054]                 added <- setdiff(names, old_names)
[16:06:09.054]                 removed <- setdiff(old_names, names)
[16:06:09.054]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:09.054]                   envs[common]]
[16:06:09.054]                 NAMES <- toupper(changed)
[16:06:09.054]                 args <- list()
[16:06:09.054]                 for (kk in seq_along(NAMES)) {
[16:06:09.054]                   name <- changed[[kk]]
[16:06:09.054]                   NAME <- NAMES[[kk]]
[16:06:09.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.054]                     next
[16:06:09.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.054]                 }
[16:06:09.054]                 NAMES <- toupper(added)
[16:06:09.054]                 for (kk in seq_along(NAMES)) {
[16:06:09.054]                   name <- added[[kk]]
[16:06:09.054]                   NAME <- NAMES[[kk]]
[16:06:09.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.054]                     next
[16:06:09.054]                   args[[name]] <- ""
[16:06:09.054]                 }
[16:06:09.054]                 NAMES <- toupper(removed)
[16:06:09.054]                 for (kk in seq_along(NAMES)) {
[16:06:09.054]                   name <- removed[[kk]]
[16:06:09.054]                   NAME <- NAMES[[kk]]
[16:06:09.054]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.054]                     next
[16:06:09.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.054]                 }
[16:06:09.054]                 if (length(args) > 0) 
[16:06:09.054]                   base::do.call(base::Sys.setenv, args = args)
[16:06:09.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:09.054]             }
[16:06:09.054]             else {
[16:06:09.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:09.054]             }
[16:06:09.054]             {
[16:06:09.054]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:09.054]                   0L) {
[16:06:09.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:09.054]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:09.054]                   base::options(opts)
[16:06:09.054]                 }
[16:06:09.054]                 {
[16:06:09.054]                   {
[16:06:09.054]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:09.054]                     NULL
[16:06:09.054]                   }
[16:06:09.054]                   options(future.plan = NULL)
[16:06:09.054]                   if (is.na(NA_character_)) 
[16:06:09.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:09.054]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:09.054]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:09.054]                     envir = parent.frame()) 
[16:06:09.054]                   {
[16:06:09.054]                     if (is.function(workers)) 
[16:06:09.054]                       workers <- workers()
[16:06:09.054]                     workers <- structure(as.integer(workers), 
[16:06:09.054]                       class = class(workers))
[16:06:09.054]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:09.054]                       workers >= 1)
[16:06:09.054]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:09.054]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:09.054]                     }
[16:06:09.054]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:09.054]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:09.054]                       envir = envir)
[16:06:09.054]                     if (!future$lazy) 
[16:06:09.054]                       future <- run(future)
[16:06:09.054]                     invisible(future)
[16:06:09.054]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:09.054]                 }
[16:06:09.054]             }
[16:06:09.054]         }
[16:06:09.054]     })
[16:06:09.054]     if (TRUE) {
[16:06:09.054]         base::sink(type = "output", split = FALSE)
[16:06:09.054]         if (TRUE) {
[16:06:09.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:09.054]         }
[16:06:09.054]         else {
[16:06:09.054]             ...future.result["stdout"] <- base::list(NULL)
[16:06:09.054]         }
[16:06:09.054]         base::close(...future.stdout)
[16:06:09.054]         ...future.stdout <- NULL
[16:06:09.054]     }
[16:06:09.054]     ...future.result$conditions <- ...future.conditions
[16:06:09.054]     ...future.result$finished <- base::Sys.time()
[16:06:09.054]     ...future.result
[16:06:09.054] }
[16:06:09.057] MultisessionFuture started
[16:06:09.057] - Launch lazy future ... done
[16:06:09.057] run() for ‘MultisessionFuture’ ... done
[16:06:09.104] receiveMessageFromWorker() for ClusterFuture ...
[16:06:09.104] - Validating connection of MultisessionFuture
[16:06:09.105] - received message: FutureResult
[16:06:09.105] - Received FutureResult
[16:06:09.105] - Erased future from FutureRegistry
[16:06:09.105] result() for ClusterFuture ...
[16:06:09.105] - result already collected: FutureResult
[16:06:09.105] result() for ClusterFuture ... done
[16:06:09.105] signalConditions() ...
[16:06:09.106]  - include = ‘immediateCondition’
[16:06:09.106]  - exclude = 
[16:06:09.106]  - resignal = FALSE
[16:06:09.106]  - Number of conditions: 1
[16:06:09.106] signalConditions() ... done
[16:06:09.106] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:09.106] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[16:06:09.106] getGlobalsAndPackages() ...
[16:06:09.106] Searching for globals...
[16:06:09.108] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:09.108] Searching for globals ... DONE
[16:06:09.108] Resolving globals: FALSE
[16:06:09.108] 
[16:06:09.108] 
[16:06:09.108] getGlobalsAndPackages() ... DONE
[16:06:09.109] run() for ‘Future’ ...
[16:06:09.109] - state: ‘created’
[16:06:09.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:09.122] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:09.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:09.123]   - Field: ‘node’
[16:06:09.123]   - Field: ‘label’
[16:06:09.123]   - Field: ‘local’
[16:06:09.123]   - Field: ‘owner’
[16:06:09.123]   - Field: ‘envir’
[16:06:09.123]   - Field: ‘workers’
[16:06:09.123]   - Field: ‘packages’
[16:06:09.123]   - Field: ‘gc’
[16:06:09.123]   - Field: ‘conditions’
[16:06:09.124]   - Field: ‘persistent’
[16:06:09.124]   - Field: ‘expr’
[16:06:09.124]   - Field: ‘uuid’
[16:06:09.124]   - Field: ‘seed’
[16:06:09.124]   - Field: ‘version’
[16:06:09.124]   - Field: ‘result’
[16:06:09.124]   - Field: ‘asynchronous’
[16:06:09.124]   - Field: ‘calls’
[16:06:09.124]   - Field: ‘globals’
[16:06:09.124]   - Field: ‘stdout’
[16:06:09.124]   - Field: ‘earlySignal’
[16:06:09.125]   - Field: ‘lazy’
[16:06:09.125]   - Field: ‘state’
[16:06:09.125] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:09.125] - Launch lazy future ...
[16:06:09.125] Packages needed by the future expression (n = 0): <none>
[16:06:09.125] Packages needed by future strategies (n = 0): <none>
[16:06:09.126] {
[16:06:09.126]     {
[16:06:09.126]         {
[16:06:09.126]             ...future.startTime <- base::Sys.time()
[16:06:09.126]             {
[16:06:09.126]                 {
[16:06:09.126]                   {
[16:06:09.126]                     {
[16:06:09.126]                       base::local({
[16:06:09.126]                         has_future <- base::requireNamespace("future", 
[16:06:09.126]                           quietly = TRUE)
[16:06:09.126]                         if (has_future) {
[16:06:09.126]                           ns <- base::getNamespace("future")
[16:06:09.126]                           version <- ns[[".package"]][["version"]]
[16:06:09.126]                           if (is.null(version)) 
[16:06:09.126]                             version <- utils::packageVersion("future")
[16:06:09.126]                         }
[16:06:09.126]                         else {
[16:06:09.126]                           version <- NULL
[16:06:09.126]                         }
[16:06:09.126]                         if (!has_future || version < "1.8.0") {
[16:06:09.126]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:09.126]                             "", base::R.version$version.string), 
[16:06:09.126]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:09.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:09.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:09.126]                               "release", "version")], collapse = " "), 
[16:06:09.126]                             hostname = base::Sys.info()[["nodename"]])
[16:06:09.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:09.126]                             info)
[16:06:09.126]                           info <- base::paste(info, collapse = "; ")
[16:06:09.126]                           if (!has_future) {
[16:06:09.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:09.126]                               info)
[16:06:09.126]                           }
[16:06:09.126]                           else {
[16:06:09.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:09.126]                               info, version)
[16:06:09.126]                           }
[16:06:09.126]                           base::stop(msg)
[16:06:09.126]                         }
[16:06:09.126]                       })
[16:06:09.126]                     }
[16:06:09.126]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:09.126]                     base::options(mc.cores = 1L)
[16:06:09.126]                   }
[16:06:09.126]                   options(future.plan = NULL)
[16:06:09.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:09.126]                 }
[16:06:09.126]                 ...future.workdir <- getwd()
[16:06:09.126]             }
[16:06:09.126]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:09.126]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:09.126]         }
[16:06:09.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:09.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:09.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:09.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:09.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:09.126]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:09.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:09.126]             base::names(...future.oldOptions))
[16:06:09.126]     }
[16:06:09.126]     if (FALSE) {
[16:06:09.126]     }
[16:06:09.126]     else {
[16:06:09.126]         if (TRUE) {
[16:06:09.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:09.126]                 open = "w")
[16:06:09.126]         }
[16:06:09.126]         else {
[16:06:09.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:09.126]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:09.126]         }
[16:06:09.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:09.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:09.126]             base::sink(type = "output", split = FALSE)
[16:06:09.126]             base::close(...future.stdout)
[16:06:09.126]         }, add = TRUE)
[16:06:09.126]     }
[16:06:09.126]     ...future.frame <- base::sys.nframe()
[16:06:09.126]     ...future.conditions <- base::list()
[16:06:09.126]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:09.126]     if (FALSE) {
[16:06:09.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:09.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:09.126]     }
[16:06:09.126]     ...future.result <- base::tryCatch({
[16:06:09.126]         base::withCallingHandlers({
[16:06:09.126]             ...future.value <- base::withVisible(base::local({
[16:06:09.126]                 ...future.makeSendCondition <- base::local({
[16:06:09.126]                   sendCondition <- NULL
[16:06:09.126]                   function(frame = 1L) {
[16:06:09.126]                     if (is.function(sendCondition)) 
[16:06:09.126]                       return(sendCondition)
[16:06:09.126]                     ns <- getNamespace("parallel")
[16:06:09.126]                     if (exists("sendData", mode = "function", 
[16:06:09.126]                       envir = ns)) {
[16:06:09.126]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:09.126]                         envir = ns)
[16:06:09.126]                       envir <- sys.frame(frame)
[16:06:09.126]                       master <- NULL
[16:06:09.126]                       while (!identical(envir, .GlobalEnv) && 
[16:06:09.126]                         !identical(envir, emptyenv())) {
[16:06:09.126]                         if (exists("master", mode = "list", envir = envir, 
[16:06:09.126]                           inherits = FALSE)) {
[16:06:09.126]                           master <- get("master", mode = "list", 
[16:06:09.126]                             envir = envir, inherits = FALSE)
[16:06:09.126]                           if (inherits(master, c("SOCKnode", 
[16:06:09.126]                             "SOCK0node"))) {
[16:06:09.126]                             sendCondition <<- function(cond) {
[16:06:09.126]                               data <- list(type = "VALUE", value = cond, 
[16:06:09.126]                                 success = TRUE)
[16:06:09.126]                               parallel_sendData(master, data)
[16:06:09.126]                             }
[16:06:09.126]                             return(sendCondition)
[16:06:09.126]                           }
[16:06:09.126]                         }
[16:06:09.126]                         frame <- frame + 1L
[16:06:09.126]                         envir <- sys.frame(frame)
[16:06:09.126]                       }
[16:06:09.126]                     }
[16:06:09.126]                     sendCondition <<- function(cond) NULL
[16:06:09.126]                   }
[16:06:09.126]                 })
[16:06:09.126]                 withCallingHandlers({
[16:06:09.126]                   {
[16:06:09.126]                     Sys.sleep(0.5)
[16:06:09.126]                     list(a = 1, b = 42L)
[16:06:09.126]                   }
[16:06:09.126]                 }, immediateCondition = function(cond) {
[16:06:09.126]                   sendCondition <- ...future.makeSendCondition()
[16:06:09.126]                   sendCondition(cond)
[16:06:09.126]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.126]                   {
[16:06:09.126]                     inherits <- base::inherits
[16:06:09.126]                     invokeRestart <- base::invokeRestart
[16:06:09.126]                     is.null <- base::is.null
[16:06:09.126]                     muffled <- FALSE
[16:06:09.126]                     if (inherits(cond, "message")) {
[16:06:09.126]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:09.126]                       if (muffled) 
[16:06:09.126]                         invokeRestart("muffleMessage")
[16:06:09.126]                     }
[16:06:09.126]                     else if (inherits(cond, "warning")) {
[16:06:09.126]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:09.126]                       if (muffled) 
[16:06:09.126]                         invokeRestart("muffleWarning")
[16:06:09.126]                     }
[16:06:09.126]                     else if (inherits(cond, "condition")) {
[16:06:09.126]                       if (!is.null(pattern)) {
[16:06:09.126]                         computeRestarts <- base::computeRestarts
[16:06:09.126]                         grepl <- base::grepl
[16:06:09.126]                         restarts <- computeRestarts(cond)
[16:06:09.126]                         for (restart in restarts) {
[16:06:09.126]                           name <- restart$name
[16:06:09.126]                           if (is.null(name)) 
[16:06:09.126]                             next
[16:06:09.126]                           if (!grepl(pattern, name)) 
[16:06:09.126]                             next
[16:06:09.126]                           invokeRestart(restart)
[16:06:09.126]                           muffled <- TRUE
[16:06:09.126]                           break
[16:06:09.126]                         }
[16:06:09.126]                       }
[16:06:09.126]                     }
[16:06:09.126]                     invisible(muffled)
[16:06:09.126]                   }
[16:06:09.126]                   muffleCondition(cond)
[16:06:09.126]                 })
[16:06:09.126]             }))
[16:06:09.126]             future::FutureResult(value = ...future.value$value, 
[16:06:09.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.126]                   ...future.rng), globalenv = if (FALSE) 
[16:06:09.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:09.126]                     ...future.globalenv.names))
[16:06:09.126]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:09.126]         }, condition = base::local({
[16:06:09.126]             c <- base::c
[16:06:09.126]             inherits <- base::inherits
[16:06:09.126]             invokeRestart <- base::invokeRestart
[16:06:09.126]             length <- base::length
[16:06:09.126]             list <- base::list
[16:06:09.126]             seq.int <- base::seq.int
[16:06:09.126]             signalCondition <- base::signalCondition
[16:06:09.126]             sys.calls <- base::sys.calls
[16:06:09.126]             `[[` <- base::`[[`
[16:06:09.126]             `+` <- base::`+`
[16:06:09.126]             `<<-` <- base::`<<-`
[16:06:09.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:09.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:09.126]                   3L)]
[16:06:09.126]             }
[16:06:09.126]             function(cond) {
[16:06:09.126]                 is_error <- inherits(cond, "error")
[16:06:09.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:09.126]                   NULL)
[16:06:09.126]                 if (is_error) {
[16:06:09.126]                   sessionInformation <- function() {
[16:06:09.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:09.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:09.126]                       search = base::search(), system = base::Sys.info())
[16:06:09.126]                   }
[16:06:09.126]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:09.126]                     cond$call), session = sessionInformation(), 
[16:06:09.126]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:09.126]                   signalCondition(cond)
[16:06:09.126]                 }
[16:06:09.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:09.126]                 "immediateCondition"))) {
[16:06:09.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:09.126]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:09.126]                   if (TRUE && !signal) {
[16:06:09.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.126]                     {
[16:06:09.126]                       inherits <- base::inherits
[16:06:09.126]                       invokeRestart <- base::invokeRestart
[16:06:09.126]                       is.null <- base::is.null
[16:06:09.126]                       muffled <- FALSE
[16:06:09.126]                       if (inherits(cond, "message")) {
[16:06:09.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.126]                         if (muffled) 
[16:06:09.126]                           invokeRestart("muffleMessage")
[16:06:09.126]                       }
[16:06:09.126]                       else if (inherits(cond, "warning")) {
[16:06:09.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.126]                         if (muffled) 
[16:06:09.126]                           invokeRestart("muffleWarning")
[16:06:09.126]                       }
[16:06:09.126]                       else if (inherits(cond, "condition")) {
[16:06:09.126]                         if (!is.null(pattern)) {
[16:06:09.126]                           computeRestarts <- base::computeRestarts
[16:06:09.126]                           grepl <- base::grepl
[16:06:09.126]                           restarts <- computeRestarts(cond)
[16:06:09.126]                           for (restart in restarts) {
[16:06:09.126]                             name <- restart$name
[16:06:09.126]                             if (is.null(name)) 
[16:06:09.126]                               next
[16:06:09.126]                             if (!grepl(pattern, name)) 
[16:06:09.126]                               next
[16:06:09.126]                             invokeRestart(restart)
[16:06:09.126]                             muffled <- TRUE
[16:06:09.126]                             break
[16:06:09.126]                           }
[16:06:09.126]                         }
[16:06:09.126]                       }
[16:06:09.126]                       invisible(muffled)
[16:06:09.126]                     }
[16:06:09.126]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.126]                   }
[16:06:09.126]                 }
[16:06:09.126]                 else {
[16:06:09.126]                   if (TRUE) {
[16:06:09.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.126]                     {
[16:06:09.126]                       inherits <- base::inherits
[16:06:09.126]                       invokeRestart <- base::invokeRestart
[16:06:09.126]                       is.null <- base::is.null
[16:06:09.126]                       muffled <- FALSE
[16:06:09.126]                       if (inherits(cond, "message")) {
[16:06:09.126]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.126]                         if (muffled) 
[16:06:09.126]                           invokeRestart("muffleMessage")
[16:06:09.126]                       }
[16:06:09.126]                       else if (inherits(cond, "warning")) {
[16:06:09.126]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.126]                         if (muffled) 
[16:06:09.126]                           invokeRestart("muffleWarning")
[16:06:09.126]                       }
[16:06:09.126]                       else if (inherits(cond, "condition")) {
[16:06:09.126]                         if (!is.null(pattern)) {
[16:06:09.126]                           computeRestarts <- base::computeRestarts
[16:06:09.126]                           grepl <- base::grepl
[16:06:09.126]                           restarts <- computeRestarts(cond)
[16:06:09.126]                           for (restart in restarts) {
[16:06:09.126]                             name <- restart$name
[16:06:09.126]                             if (is.null(name)) 
[16:06:09.126]                               next
[16:06:09.126]                             if (!grepl(pattern, name)) 
[16:06:09.126]                               next
[16:06:09.126]                             invokeRestart(restart)
[16:06:09.126]                             muffled <- TRUE
[16:06:09.126]                             break
[16:06:09.126]                           }
[16:06:09.126]                         }
[16:06:09.126]                       }
[16:06:09.126]                       invisible(muffled)
[16:06:09.126]                     }
[16:06:09.126]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.126]                   }
[16:06:09.126]                 }
[16:06:09.126]             }
[16:06:09.126]         }))
[16:06:09.126]     }, error = function(ex) {
[16:06:09.126]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:09.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.126]                 ...future.rng), started = ...future.startTime, 
[16:06:09.126]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:09.126]             version = "1.8"), class = "FutureResult")
[16:06:09.126]     }, finally = {
[16:06:09.126]         if (!identical(...future.workdir, getwd())) 
[16:06:09.126]             setwd(...future.workdir)
[16:06:09.126]         {
[16:06:09.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:09.126]                 ...future.oldOptions$nwarnings <- NULL
[16:06:09.126]             }
[16:06:09.126]             base::options(...future.oldOptions)
[16:06:09.126]             if (.Platform$OS.type == "windows") {
[16:06:09.126]                 old_names <- names(...future.oldEnvVars)
[16:06:09.126]                 envs <- base::Sys.getenv()
[16:06:09.126]                 names <- names(envs)
[16:06:09.126]                 common <- intersect(names, old_names)
[16:06:09.126]                 added <- setdiff(names, old_names)
[16:06:09.126]                 removed <- setdiff(old_names, names)
[16:06:09.126]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:09.126]                   envs[common]]
[16:06:09.126]                 NAMES <- toupper(changed)
[16:06:09.126]                 args <- list()
[16:06:09.126]                 for (kk in seq_along(NAMES)) {
[16:06:09.126]                   name <- changed[[kk]]
[16:06:09.126]                   NAME <- NAMES[[kk]]
[16:06:09.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.126]                     next
[16:06:09.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.126]                 }
[16:06:09.126]                 NAMES <- toupper(added)
[16:06:09.126]                 for (kk in seq_along(NAMES)) {
[16:06:09.126]                   name <- added[[kk]]
[16:06:09.126]                   NAME <- NAMES[[kk]]
[16:06:09.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.126]                     next
[16:06:09.126]                   args[[name]] <- ""
[16:06:09.126]                 }
[16:06:09.126]                 NAMES <- toupper(removed)
[16:06:09.126]                 for (kk in seq_along(NAMES)) {
[16:06:09.126]                   name <- removed[[kk]]
[16:06:09.126]                   NAME <- NAMES[[kk]]
[16:06:09.126]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.126]                     next
[16:06:09.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.126]                 }
[16:06:09.126]                 if (length(args) > 0) 
[16:06:09.126]                   base::do.call(base::Sys.setenv, args = args)
[16:06:09.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:09.126]             }
[16:06:09.126]             else {
[16:06:09.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:09.126]             }
[16:06:09.126]             {
[16:06:09.126]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:09.126]                   0L) {
[16:06:09.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:09.126]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:09.126]                   base::options(opts)
[16:06:09.126]                 }
[16:06:09.126]                 {
[16:06:09.126]                   {
[16:06:09.126]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:09.126]                     NULL
[16:06:09.126]                   }
[16:06:09.126]                   options(future.plan = NULL)
[16:06:09.126]                   if (is.na(NA_character_)) 
[16:06:09.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:09.126]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:09.126]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:09.126]                     envir = parent.frame()) 
[16:06:09.126]                   {
[16:06:09.126]                     if (is.function(workers)) 
[16:06:09.126]                       workers <- workers()
[16:06:09.126]                     workers <- structure(as.integer(workers), 
[16:06:09.126]                       class = class(workers))
[16:06:09.126]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:09.126]                       workers >= 1)
[16:06:09.126]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:09.126]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:09.126]                     }
[16:06:09.126]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:09.126]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:09.126]                       envir = envir)
[16:06:09.126]                     if (!future$lazy) 
[16:06:09.126]                       future <- run(future)
[16:06:09.126]                     invisible(future)
[16:06:09.126]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:09.126]                 }
[16:06:09.126]             }
[16:06:09.126]         }
[16:06:09.126]     })
[16:06:09.126]     if (TRUE) {
[16:06:09.126]         base::sink(type = "output", split = FALSE)
[16:06:09.126]         if (TRUE) {
[16:06:09.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:09.126]         }
[16:06:09.126]         else {
[16:06:09.126]             ...future.result["stdout"] <- base::list(NULL)
[16:06:09.126]         }
[16:06:09.126]         base::close(...future.stdout)
[16:06:09.126]         ...future.stdout <- NULL
[16:06:09.126]     }
[16:06:09.126]     ...future.result$conditions <- ...future.conditions
[16:06:09.126]     ...future.result$finished <- base::Sys.time()
[16:06:09.126]     ...future.result
[16:06:09.126] }
[16:06:09.129] MultisessionFuture started
[16:06:09.129] - Launch lazy future ... done
[16:06:09.129] run() for ‘MultisessionFuture’ ... done
[16:06:09.129] getGlobalsAndPackages() ...
[16:06:09.129] Searching for globals...
[16:06:09.130] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:09.131] Searching for globals ... DONE
[16:06:09.131] Resolving globals: FALSE
[16:06:09.131] 
[16:06:09.131] 
[16:06:09.131] getGlobalsAndPackages() ... DONE
- w/ exception ...
[16:06:09.132] getGlobalsAndPackages() ...
[16:06:09.132] Searching for globals...
[16:06:09.132] - globals found: [2] ‘list’, ‘stop’
[16:06:09.132] Searching for globals ... DONE
[16:06:09.132] Resolving globals: FALSE
[16:06:09.133] 
[16:06:09.133] 
[16:06:09.133] getGlobalsAndPackages() ... DONE
[16:06:09.133] run() for ‘Future’ ...
[16:06:09.133] - state: ‘created’
[16:06:09.133] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:09.147] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:09.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:09.147]   - Field: ‘node’
[16:06:09.147]   - Field: ‘label’
[16:06:09.147]   - Field: ‘local’
[16:06:09.147]   - Field: ‘owner’
[16:06:09.148]   - Field: ‘envir’
[16:06:09.148]   - Field: ‘workers’
[16:06:09.148]   - Field: ‘packages’
[16:06:09.148]   - Field: ‘gc’
[16:06:09.148]   - Field: ‘conditions’
[16:06:09.148]   - Field: ‘persistent’
[16:06:09.148]   - Field: ‘expr’
[16:06:09.148]   - Field: ‘uuid’
[16:06:09.148]   - Field: ‘seed’
[16:06:09.148]   - Field: ‘version’
[16:06:09.148]   - Field: ‘result’
[16:06:09.149]   - Field: ‘asynchronous’
[16:06:09.149]   - Field: ‘calls’
[16:06:09.149]   - Field: ‘globals’
[16:06:09.149]   - Field: ‘stdout’
[16:06:09.149]   - Field: ‘earlySignal’
[16:06:09.149]   - Field: ‘lazy’
[16:06:09.149]   - Field: ‘state’
[16:06:09.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:09.149] - Launch lazy future ...
[16:06:09.150] Packages needed by the future expression (n = 0): <none>
[16:06:09.150] Packages needed by future strategies (n = 0): <none>
[16:06:09.150] {
[16:06:09.150]     {
[16:06:09.150]         {
[16:06:09.150]             ...future.startTime <- base::Sys.time()
[16:06:09.150]             {
[16:06:09.150]                 {
[16:06:09.150]                   {
[16:06:09.150]                     {
[16:06:09.150]                       base::local({
[16:06:09.150]                         has_future <- base::requireNamespace("future", 
[16:06:09.150]                           quietly = TRUE)
[16:06:09.150]                         if (has_future) {
[16:06:09.150]                           ns <- base::getNamespace("future")
[16:06:09.150]                           version <- ns[[".package"]][["version"]]
[16:06:09.150]                           if (is.null(version)) 
[16:06:09.150]                             version <- utils::packageVersion("future")
[16:06:09.150]                         }
[16:06:09.150]                         else {
[16:06:09.150]                           version <- NULL
[16:06:09.150]                         }
[16:06:09.150]                         if (!has_future || version < "1.8.0") {
[16:06:09.150]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:09.150]                             "", base::R.version$version.string), 
[16:06:09.150]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:09.150]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:09.150]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:09.150]                               "release", "version")], collapse = " "), 
[16:06:09.150]                             hostname = base::Sys.info()[["nodename"]])
[16:06:09.150]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:09.150]                             info)
[16:06:09.150]                           info <- base::paste(info, collapse = "; ")
[16:06:09.150]                           if (!has_future) {
[16:06:09.150]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:09.150]                               info)
[16:06:09.150]                           }
[16:06:09.150]                           else {
[16:06:09.150]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:09.150]                               info, version)
[16:06:09.150]                           }
[16:06:09.150]                           base::stop(msg)
[16:06:09.150]                         }
[16:06:09.150]                       })
[16:06:09.150]                     }
[16:06:09.150]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:09.150]                     base::options(mc.cores = 1L)
[16:06:09.150]                   }
[16:06:09.150]                   options(future.plan = NULL)
[16:06:09.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:09.150]                 }
[16:06:09.150]                 ...future.workdir <- getwd()
[16:06:09.150]             }
[16:06:09.150]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:09.150]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:09.150]         }
[16:06:09.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:09.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:09.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:09.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:09.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:09.150]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:09.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:09.150]             base::names(...future.oldOptions))
[16:06:09.150]     }
[16:06:09.150]     if (FALSE) {
[16:06:09.150]     }
[16:06:09.150]     else {
[16:06:09.150]         if (TRUE) {
[16:06:09.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:09.150]                 open = "w")
[16:06:09.150]         }
[16:06:09.150]         else {
[16:06:09.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:09.150]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:09.150]         }
[16:06:09.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:09.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:09.150]             base::sink(type = "output", split = FALSE)
[16:06:09.150]             base::close(...future.stdout)
[16:06:09.150]         }, add = TRUE)
[16:06:09.150]     }
[16:06:09.150]     ...future.frame <- base::sys.nframe()
[16:06:09.150]     ...future.conditions <- base::list()
[16:06:09.150]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:09.150]     if (FALSE) {
[16:06:09.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:09.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:09.150]     }
[16:06:09.150]     ...future.result <- base::tryCatch({
[16:06:09.150]         base::withCallingHandlers({
[16:06:09.150]             ...future.value <- base::withVisible(base::local({
[16:06:09.150]                 ...future.makeSendCondition <- base::local({
[16:06:09.150]                   sendCondition <- NULL
[16:06:09.150]                   function(frame = 1L) {
[16:06:09.150]                     if (is.function(sendCondition)) 
[16:06:09.150]                       return(sendCondition)
[16:06:09.150]                     ns <- getNamespace("parallel")
[16:06:09.150]                     if (exists("sendData", mode = "function", 
[16:06:09.150]                       envir = ns)) {
[16:06:09.150]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:09.150]                         envir = ns)
[16:06:09.150]                       envir <- sys.frame(frame)
[16:06:09.150]                       master <- NULL
[16:06:09.150]                       while (!identical(envir, .GlobalEnv) && 
[16:06:09.150]                         !identical(envir, emptyenv())) {
[16:06:09.150]                         if (exists("master", mode = "list", envir = envir, 
[16:06:09.150]                           inherits = FALSE)) {
[16:06:09.150]                           master <- get("master", mode = "list", 
[16:06:09.150]                             envir = envir, inherits = FALSE)
[16:06:09.150]                           if (inherits(master, c("SOCKnode", 
[16:06:09.150]                             "SOCK0node"))) {
[16:06:09.150]                             sendCondition <<- function(cond) {
[16:06:09.150]                               data <- list(type = "VALUE", value = cond, 
[16:06:09.150]                                 success = TRUE)
[16:06:09.150]                               parallel_sendData(master, data)
[16:06:09.150]                             }
[16:06:09.150]                             return(sendCondition)
[16:06:09.150]                           }
[16:06:09.150]                         }
[16:06:09.150]                         frame <- frame + 1L
[16:06:09.150]                         envir <- sys.frame(frame)
[16:06:09.150]                       }
[16:06:09.150]                     }
[16:06:09.150]                     sendCondition <<- function(cond) NULL
[16:06:09.150]                   }
[16:06:09.150]                 })
[16:06:09.150]                 withCallingHandlers({
[16:06:09.150]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:09.150]                 }, immediateCondition = function(cond) {
[16:06:09.150]                   sendCondition <- ...future.makeSendCondition()
[16:06:09.150]                   sendCondition(cond)
[16:06:09.150]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.150]                   {
[16:06:09.150]                     inherits <- base::inherits
[16:06:09.150]                     invokeRestart <- base::invokeRestart
[16:06:09.150]                     is.null <- base::is.null
[16:06:09.150]                     muffled <- FALSE
[16:06:09.150]                     if (inherits(cond, "message")) {
[16:06:09.150]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:09.150]                       if (muffled) 
[16:06:09.150]                         invokeRestart("muffleMessage")
[16:06:09.150]                     }
[16:06:09.150]                     else if (inherits(cond, "warning")) {
[16:06:09.150]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:09.150]                       if (muffled) 
[16:06:09.150]                         invokeRestart("muffleWarning")
[16:06:09.150]                     }
[16:06:09.150]                     else if (inherits(cond, "condition")) {
[16:06:09.150]                       if (!is.null(pattern)) {
[16:06:09.150]                         computeRestarts <- base::computeRestarts
[16:06:09.150]                         grepl <- base::grepl
[16:06:09.150]                         restarts <- computeRestarts(cond)
[16:06:09.150]                         for (restart in restarts) {
[16:06:09.150]                           name <- restart$name
[16:06:09.150]                           if (is.null(name)) 
[16:06:09.150]                             next
[16:06:09.150]                           if (!grepl(pattern, name)) 
[16:06:09.150]                             next
[16:06:09.150]                           invokeRestart(restart)
[16:06:09.150]                           muffled <- TRUE
[16:06:09.150]                           break
[16:06:09.150]                         }
[16:06:09.150]                       }
[16:06:09.150]                     }
[16:06:09.150]                     invisible(muffled)
[16:06:09.150]                   }
[16:06:09.150]                   muffleCondition(cond)
[16:06:09.150]                 })
[16:06:09.150]             }))
[16:06:09.150]             future::FutureResult(value = ...future.value$value, 
[16:06:09.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.150]                   ...future.rng), globalenv = if (FALSE) 
[16:06:09.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:09.150]                     ...future.globalenv.names))
[16:06:09.150]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:09.150]         }, condition = base::local({
[16:06:09.150]             c <- base::c
[16:06:09.150]             inherits <- base::inherits
[16:06:09.150]             invokeRestart <- base::invokeRestart
[16:06:09.150]             length <- base::length
[16:06:09.150]             list <- base::list
[16:06:09.150]             seq.int <- base::seq.int
[16:06:09.150]             signalCondition <- base::signalCondition
[16:06:09.150]             sys.calls <- base::sys.calls
[16:06:09.150]             `[[` <- base::`[[`
[16:06:09.150]             `+` <- base::`+`
[16:06:09.150]             `<<-` <- base::`<<-`
[16:06:09.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:09.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:09.150]                   3L)]
[16:06:09.150]             }
[16:06:09.150]             function(cond) {
[16:06:09.150]                 is_error <- inherits(cond, "error")
[16:06:09.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:09.150]                   NULL)
[16:06:09.150]                 if (is_error) {
[16:06:09.150]                   sessionInformation <- function() {
[16:06:09.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:09.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:09.150]                       search = base::search(), system = base::Sys.info())
[16:06:09.150]                   }
[16:06:09.150]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:09.150]                     cond$call), session = sessionInformation(), 
[16:06:09.150]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:09.150]                   signalCondition(cond)
[16:06:09.150]                 }
[16:06:09.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:09.150]                 "immediateCondition"))) {
[16:06:09.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:09.150]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:09.150]                   if (TRUE && !signal) {
[16:06:09.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.150]                     {
[16:06:09.150]                       inherits <- base::inherits
[16:06:09.150]                       invokeRestart <- base::invokeRestart
[16:06:09.150]                       is.null <- base::is.null
[16:06:09.150]                       muffled <- FALSE
[16:06:09.150]                       if (inherits(cond, "message")) {
[16:06:09.150]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.150]                         if (muffled) 
[16:06:09.150]                           invokeRestart("muffleMessage")
[16:06:09.150]                       }
[16:06:09.150]                       else if (inherits(cond, "warning")) {
[16:06:09.150]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.150]                         if (muffled) 
[16:06:09.150]                           invokeRestart("muffleWarning")
[16:06:09.150]                       }
[16:06:09.150]                       else if (inherits(cond, "condition")) {
[16:06:09.150]                         if (!is.null(pattern)) {
[16:06:09.150]                           computeRestarts <- base::computeRestarts
[16:06:09.150]                           grepl <- base::grepl
[16:06:09.150]                           restarts <- computeRestarts(cond)
[16:06:09.150]                           for (restart in restarts) {
[16:06:09.150]                             name <- restart$name
[16:06:09.150]                             if (is.null(name)) 
[16:06:09.150]                               next
[16:06:09.150]                             if (!grepl(pattern, name)) 
[16:06:09.150]                               next
[16:06:09.150]                             invokeRestart(restart)
[16:06:09.150]                             muffled <- TRUE
[16:06:09.150]                             break
[16:06:09.150]                           }
[16:06:09.150]                         }
[16:06:09.150]                       }
[16:06:09.150]                       invisible(muffled)
[16:06:09.150]                     }
[16:06:09.150]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.150]                   }
[16:06:09.150]                 }
[16:06:09.150]                 else {
[16:06:09.150]                   if (TRUE) {
[16:06:09.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.150]                     {
[16:06:09.150]                       inherits <- base::inherits
[16:06:09.150]                       invokeRestart <- base::invokeRestart
[16:06:09.150]                       is.null <- base::is.null
[16:06:09.150]                       muffled <- FALSE
[16:06:09.150]                       if (inherits(cond, "message")) {
[16:06:09.150]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.150]                         if (muffled) 
[16:06:09.150]                           invokeRestart("muffleMessage")
[16:06:09.150]                       }
[16:06:09.150]                       else if (inherits(cond, "warning")) {
[16:06:09.150]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.150]                         if (muffled) 
[16:06:09.150]                           invokeRestart("muffleWarning")
[16:06:09.150]                       }
[16:06:09.150]                       else if (inherits(cond, "condition")) {
[16:06:09.150]                         if (!is.null(pattern)) {
[16:06:09.150]                           computeRestarts <- base::computeRestarts
[16:06:09.150]                           grepl <- base::grepl
[16:06:09.150]                           restarts <- computeRestarts(cond)
[16:06:09.150]                           for (restart in restarts) {
[16:06:09.150]                             name <- restart$name
[16:06:09.150]                             if (is.null(name)) 
[16:06:09.150]                               next
[16:06:09.150]                             if (!grepl(pattern, name)) 
[16:06:09.150]                               next
[16:06:09.150]                             invokeRestart(restart)
[16:06:09.150]                             muffled <- TRUE
[16:06:09.150]                             break
[16:06:09.150]                           }
[16:06:09.150]                         }
[16:06:09.150]                       }
[16:06:09.150]                       invisible(muffled)
[16:06:09.150]                     }
[16:06:09.150]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.150]                   }
[16:06:09.150]                 }
[16:06:09.150]             }
[16:06:09.150]         }))
[16:06:09.150]     }, error = function(ex) {
[16:06:09.150]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:09.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.150]                 ...future.rng), started = ...future.startTime, 
[16:06:09.150]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:09.150]             version = "1.8"), class = "FutureResult")
[16:06:09.150]     }, finally = {
[16:06:09.150]         if (!identical(...future.workdir, getwd())) 
[16:06:09.150]             setwd(...future.workdir)
[16:06:09.150]         {
[16:06:09.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:09.150]                 ...future.oldOptions$nwarnings <- NULL
[16:06:09.150]             }
[16:06:09.150]             base::options(...future.oldOptions)
[16:06:09.150]             if (.Platform$OS.type == "windows") {
[16:06:09.150]                 old_names <- names(...future.oldEnvVars)
[16:06:09.150]                 envs <- base::Sys.getenv()
[16:06:09.150]                 names <- names(envs)
[16:06:09.150]                 common <- intersect(names, old_names)
[16:06:09.150]                 added <- setdiff(names, old_names)
[16:06:09.150]                 removed <- setdiff(old_names, names)
[16:06:09.150]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:09.150]                   envs[common]]
[16:06:09.150]                 NAMES <- toupper(changed)
[16:06:09.150]                 args <- list()
[16:06:09.150]                 for (kk in seq_along(NAMES)) {
[16:06:09.150]                   name <- changed[[kk]]
[16:06:09.150]                   NAME <- NAMES[[kk]]
[16:06:09.150]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.150]                     next
[16:06:09.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.150]                 }
[16:06:09.150]                 NAMES <- toupper(added)
[16:06:09.150]                 for (kk in seq_along(NAMES)) {
[16:06:09.150]                   name <- added[[kk]]
[16:06:09.150]                   NAME <- NAMES[[kk]]
[16:06:09.150]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.150]                     next
[16:06:09.150]                   args[[name]] <- ""
[16:06:09.150]                 }
[16:06:09.150]                 NAMES <- toupper(removed)
[16:06:09.150]                 for (kk in seq_along(NAMES)) {
[16:06:09.150]                   name <- removed[[kk]]
[16:06:09.150]                   NAME <- NAMES[[kk]]
[16:06:09.150]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.150]                     next
[16:06:09.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.150]                 }
[16:06:09.150]                 if (length(args) > 0) 
[16:06:09.150]                   base::do.call(base::Sys.setenv, args = args)
[16:06:09.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:09.150]             }
[16:06:09.150]             else {
[16:06:09.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:09.150]             }
[16:06:09.150]             {
[16:06:09.150]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:09.150]                   0L) {
[16:06:09.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:09.150]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:09.150]                   base::options(opts)
[16:06:09.150]                 }
[16:06:09.150]                 {
[16:06:09.150]                   {
[16:06:09.150]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:09.150]                     NULL
[16:06:09.150]                   }
[16:06:09.150]                   options(future.plan = NULL)
[16:06:09.150]                   if (is.na(NA_character_)) 
[16:06:09.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:09.150]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:09.150]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:09.150]                     envir = parent.frame()) 
[16:06:09.150]                   {
[16:06:09.150]                     if (is.function(workers)) 
[16:06:09.150]                       workers <- workers()
[16:06:09.150]                     workers <- structure(as.integer(workers), 
[16:06:09.150]                       class = class(workers))
[16:06:09.150]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:09.150]                       workers >= 1)
[16:06:09.150]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:09.150]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:09.150]                     }
[16:06:09.150]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:09.150]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:09.150]                       envir = envir)
[16:06:09.150]                     if (!future$lazy) 
[16:06:09.150]                       future <- run(future)
[16:06:09.150]                     invisible(future)
[16:06:09.150]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:09.150]                 }
[16:06:09.150]             }
[16:06:09.150]         }
[16:06:09.150]     })
[16:06:09.150]     if (TRUE) {
[16:06:09.150]         base::sink(type = "output", split = FALSE)
[16:06:09.150]         if (TRUE) {
[16:06:09.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:09.150]         }
[16:06:09.150]         else {
[16:06:09.150]             ...future.result["stdout"] <- base::list(NULL)
[16:06:09.150]         }
[16:06:09.150]         base::close(...future.stdout)
[16:06:09.150]         ...future.stdout <- NULL
[16:06:09.150]     }
[16:06:09.150]     ...future.result$conditions <- ...future.conditions
[16:06:09.150]     ...future.result$finished <- base::Sys.time()
[16:06:09.150]     ...future.result
[16:06:09.150] }
[16:06:09.152] Poll #1 (0): usedNodes() = 2, workers = 2
[16:06:09.163] receiveMessageFromWorker() for ClusterFuture ...
[16:06:09.163] - Validating connection of MultisessionFuture
[16:06:09.163] - received message: FutureResult
[16:06:09.164] - Received FutureResult
[16:06:09.164] - Erased future from FutureRegistry
[16:06:09.164] result() for ClusterFuture ...
[16:06:09.164] - result already collected: FutureResult
[16:06:09.164] result() for ClusterFuture ... done
[16:06:09.164] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:09.164] result() for ClusterFuture ...
[16:06:09.164] - result already collected: FutureResult
[16:06:09.164] result() for ClusterFuture ... done
[16:06:09.165] result() for ClusterFuture ...
[16:06:09.165] - result already collected: FutureResult
[16:06:09.165] result() for ClusterFuture ... done
[16:06:09.166] MultisessionFuture started
[16:06:09.166] - Launch lazy future ... done
[16:06:09.166] run() for ‘MultisessionFuture’ ... done
[16:06:09.166] getGlobalsAndPackages() ...
[16:06:09.166] Searching for globals...
[16:06:09.167] - globals found: [2] ‘list’, ‘stop’
[16:06:09.167] Searching for globals ... DONE
[16:06:09.167] Resolving globals: FALSE
[16:06:09.167] 
[16:06:09.168] 
[16:06:09.168] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[16:06:09.168] getGlobalsAndPackages() ...
[16:06:09.168] Searching for globals...
[16:06:09.169] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:09.169] Searching for globals ... DONE
[16:06:09.169] Resolving globals: FALSE
[16:06:09.170] 
[16:06:09.170] 
[16:06:09.170] getGlobalsAndPackages() ... DONE
[16:06:09.170] run() for ‘Future’ ...
[16:06:09.170] - state: ‘created’
[16:06:09.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:09.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:09.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:09.184]   - Field: ‘node’
[16:06:09.185]   - Field: ‘label’
[16:06:09.185]   - Field: ‘local’
[16:06:09.185]   - Field: ‘owner’
[16:06:09.185]   - Field: ‘envir’
[16:06:09.185]   - Field: ‘workers’
[16:06:09.185]   - Field: ‘packages’
[16:06:09.185]   - Field: ‘gc’
[16:06:09.185]   - Field: ‘conditions’
[16:06:09.185]   - Field: ‘persistent’
[16:06:09.185]   - Field: ‘expr’
[16:06:09.186]   - Field: ‘uuid’
[16:06:09.186]   - Field: ‘seed’
[16:06:09.186]   - Field: ‘version’
[16:06:09.186]   - Field: ‘result’
[16:06:09.186]   - Field: ‘asynchronous’
[16:06:09.186]   - Field: ‘calls’
[16:06:09.186]   - Field: ‘globals’
[16:06:09.186]   - Field: ‘stdout’
[16:06:09.186]   - Field: ‘earlySignal’
[16:06:09.186]   - Field: ‘lazy’
[16:06:09.186]   - Field: ‘state’
[16:06:09.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:09.187] - Launch lazy future ...
[16:06:09.187] Packages needed by the future expression (n = 0): <none>
[16:06:09.187] Packages needed by future strategies (n = 0): <none>
[16:06:09.190] {
[16:06:09.190]     {
[16:06:09.190]         {
[16:06:09.190]             ...future.startTime <- base::Sys.time()
[16:06:09.190]             {
[16:06:09.190]                 {
[16:06:09.190]                   {
[16:06:09.190]                     {
[16:06:09.190]                       base::local({
[16:06:09.190]                         has_future <- base::requireNamespace("future", 
[16:06:09.190]                           quietly = TRUE)
[16:06:09.190]                         if (has_future) {
[16:06:09.190]                           ns <- base::getNamespace("future")
[16:06:09.190]                           version <- ns[[".package"]][["version"]]
[16:06:09.190]                           if (is.null(version)) 
[16:06:09.190]                             version <- utils::packageVersion("future")
[16:06:09.190]                         }
[16:06:09.190]                         else {
[16:06:09.190]                           version <- NULL
[16:06:09.190]                         }
[16:06:09.190]                         if (!has_future || version < "1.8.0") {
[16:06:09.190]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:09.190]                             "", base::R.version$version.string), 
[16:06:09.190]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:09.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:09.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:09.190]                               "release", "version")], collapse = " "), 
[16:06:09.190]                             hostname = base::Sys.info()[["nodename"]])
[16:06:09.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:09.190]                             info)
[16:06:09.190]                           info <- base::paste(info, collapse = "; ")
[16:06:09.190]                           if (!has_future) {
[16:06:09.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:09.190]                               info)
[16:06:09.190]                           }
[16:06:09.190]                           else {
[16:06:09.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:09.190]                               info, version)
[16:06:09.190]                           }
[16:06:09.190]                           base::stop(msg)
[16:06:09.190]                         }
[16:06:09.190]                       })
[16:06:09.190]                     }
[16:06:09.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:09.190]                     base::options(mc.cores = 1L)
[16:06:09.190]                   }
[16:06:09.190]                   options(future.plan = NULL)
[16:06:09.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:09.190]                 }
[16:06:09.190]                 ...future.workdir <- getwd()
[16:06:09.190]             }
[16:06:09.190]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:09.190]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:09.190]         }
[16:06:09.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:09.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:09.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:09.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:09.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:09.190]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:09.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:09.190]             base::names(...future.oldOptions))
[16:06:09.190]     }
[16:06:09.190]     if (FALSE) {
[16:06:09.190]     }
[16:06:09.190]     else {
[16:06:09.190]         if (TRUE) {
[16:06:09.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:09.190]                 open = "w")
[16:06:09.190]         }
[16:06:09.190]         else {
[16:06:09.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:09.190]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:09.190]         }
[16:06:09.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:09.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:09.190]             base::sink(type = "output", split = FALSE)
[16:06:09.190]             base::close(...future.stdout)
[16:06:09.190]         }, add = TRUE)
[16:06:09.190]     }
[16:06:09.190]     ...future.frame <- base::sys.nframe()
[16:06:09.190]     ...future.conditions <- base::list()
[16:06:09.190]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:09.190]     if (FALSE) {
[16:06:09.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:09.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:09.190]     }
[16:06:09.190]     ...future.result <- base::tryCatch({
[16:06:09.190]         base::withCallingHandlers({
[16:06:09.190]             ...future.value <- base::withVisible(base::local({
[16:06:09.190]                 ...future.makeSendCondition <- base::local({
[16:06:09.190]                   sendCondition <- NULL
[16:06:09.190]                   function(frame = 1L) {
[16:06:09.190]                     if (is.function(sendCondition)) 
[16:06:09.190]                       return(sendCondition)
[16:06:09.190]                     ns <- getNamespace("parallel")
[16:06:09.190]                     if (exists("sendData", mode = "function", 
[16:06:09.190]                       envir = ns)) {
[16:06:09.190]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:09.190]                         envir = ns)
[16:06:09.190]                       envir <- sys.frame(frame)
[16:06:09.190]                       master <- NULL
[16:06:09.190]                       while (!identical(envir, .GlobalEnv) && 
[16:06:09.190]                         !identical(envir, emptyenv())) {
[16:06:09.190]                         if (exists("master", mode = "list", envir = envir, 
[16:06:09.190]                           inherits = FALSE)) {
[16:06:09.190]                           master <- get("master", mode = "list", 
[16:06:09.190]                             envir = envir, inherits = FALSE)
[16:06:09.190]                           if (inherits(master, c("SOCKnode", 
[16:06:09.190]                             "SOCK0node"))) {
[16:06:09.190]                             sendCondition <<- function(cond) {
[16:06:09.190]                               data <- list(type = "VALUE", value = cond, 
[16:06:09.190]                                 success = TRUE)
[16:06:09.190]                               parallel_sendData(master, data)
[16:06:09.190]                             }
[16:06:09.190]                             return(sendCondition)
[16:06:09.190]                           }
[16:06:09.190]                         }
[16:06:09.190]                         frame <- frame + 1L
[16:06:09.190]                         envir <- sys.frame(frame)
[16:06:09.190]                       }
[16:06:09.190]                     }
[16:06:09.190]                     sendCondition <<- function(cond) NULL
[16:06:09.190]                   }
[16:06:09.190]                 })
[16:06:09.190]                 withCallingHandlers({
[16:06:09.190]                   {
[16:06:09.190]                     Sys.sleep(0.5)
[16:06:09.190]                     list(a = 1, b = 42L)
[16:06:09.190]                   }
[16:06:09.190]                 }, immediateCondition = function(cond) {
[16:06:09.190]                   sendCondition <- ...future.makeSendCondition()
[16:06:09.190]                   sendCondition(cond)
[16:06:09.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.190]                   {
[16:06:09.190]                     inherits <- base::inherits
[16:06:09.190]                     invokeRestart <- base::invokeRestart
[16:06:09.190]                     is.null <- base::is.null
[16:06:09.190]                     muffled <- FALSE
[16:06:09.190]                     if (inherits(cond, "message")) {
[16:06:09.190]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:09.190]                       if (muffled) 
[16:06:09.190]                         invokeRestart("muffleMessage")
[16:06:09.190]                     }
[16:06:09.190]                     else if (inherits(cond, "warning")) {
[16:06:09.190]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:09.190]                       if (muffled) 
[16:06:09.190]                         invokeRestart("muffleWarning")
[16:06:09.190]                     }
[16:06:09.190]                     else if (inherits(cond, "condition")) {
[16:06:09.190]                       if (!is.null(pattern)) {
[16:06:09.190]                         computeRestarts <- base::computeRestarts
[16:06:09.190]                         grepl <- base::grepl
[16:06:09.190]                         restarts <- computeRestarts(cond)
[16:06:09.190]                         for (restart in restarts) {
[16:06:09.190]                           name <- restart$name
[16:06:09.190]                           if (is.null(name)) 
[16:06:09.190]                             next
[16:06:09.190]                           if (!grepl(pattern, name)) 
[16:06:09.190]                             next
[16:06:09.190]                           invokeRestart(restart)
[16:06:09.190]                           muffled <- TRUE
[16:06:09.190]                           break
[16:06:09.190]                         }
[16:06:09.190]                       }
[16:06:09.190]                     }
[16:06:09.190]                     invisible(muffled)
[16:06:09.190]                   }
[16:06:09.190]                   muffleCondition(cond)
[16:06:09.190]                 })
[16:06:09.190]             }))
[16:06:09.190]             future::FutureResult(value = ...future.value$value, 
[16:06:09.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.190]                   ...future.rng), globalenv = if (FALSE) 
[16:06:09.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:09.190]                     ...future.globalenv.names))
[16:06:09.190]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:09.190]         }, condition = base::local({
[16:06:09.190]             c <- base::c
[16:06:09.190]             inherits <- base::inherits
[16:06:09.190]             invokeRestart <- base::invokeRestart
[16:06:09.190]             length <- base::length
[16:06:09.190]             list <- base::list
[16:06:09.190]             seq.int <- base::seq.int
[16:06:09.190]             signalCondition <- base::signalCondition
[16:06:09.190]             sys.calls <- base::sys.calls
[16:06:09.190]             `[[` <- base::`[[`
[16:06:09.190]             `+` <- base::`+`
[16:06:09.190]             `<<-` <- base::`<<-`
[16:06:09.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:09.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:09.190]                   3L)]
[16:06:09.190]             }
[16:06:09.190]             function(cond) {
[16:06:09.190]                 is_error <- inherits(cond, "error")
[16:06:09.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:09.190]                   NULL)
[16:06:09.190]                 if (is_error) {
[16:06:09.190]                   sessionInformation <- function() {
[16:06:09.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:09.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:09.190]                       search = base::search(), system = base::Sys.info())
[16:06:09.190]                   }
[16:06:09.190]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:09.190]                     cond$call), session = sessionInformation(), 
[16:06:09.190]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:09.190]                   signalCondition(cond)
[16:06:09.190]                 }
[16:06:09.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:09.190]                 "immediateCondition"))) {
[16:06:09.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:09.190]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:09.190]                   if (TRUE && !signal) {
[16:06:09.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.190]                     {
[16:06:09.190]                       inherits <- base::inherits
[16:06:09.190]                       invokeRestart <- base::invokeRestart
[16:06:09.190]                       is.null <- base::is.null
[16:06:09.190]                       muffled <- FALSE
[16:06:09.190]                       if (inherits(cond, "message")) {
[16:06:09.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.190]                         if (muffled) 
[16:06:09.190]                           invokeRestart("muffleMessage")
[16:06:09.190]                       }
[16:06:09.190]                       else if (inherits(cond, "warning")) {
[16:06:09.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.190]                         if (muffled) 
[16:06:09.190]                           invokeRestart("muffleWarning")
[16:06:09.190]                       }
[16:06:09.190]                       else if (inherits(cond, "condition")) {
[16:06:09.190]                         if (!is.null(pattern)) {
[16:06:09.190]                           computeRestarts <- base::computeRestarts
[16:06:09.190]                           grepl <- base::grepl
[16:06:09.190]                           restarts <- computeRestarts(cond)
[16:06:09.190]                           for (restart in restarts) {
[16:06:09.190]                             name <- restart$name
[16:06:09.190]                             if (is.null(name)) 
[16:06:09.190]                               next
[16:06:09.190]                             if (!grepl(pattern, name)) 
[16:06:09.190]                               next
[16:06:09.190]                             invokeRestart(restart)
[16:06:09.190]                             muffled <- TRUE
[16:06:09.190]                             break
[16:06:09.190]                           }
[16:06:09.190]                         }
[16:06:09.190]                       }
[16:06:09.190]                       invisible(muffled)
[16:06:09.190]                     }
[16:06:09.190]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.190]                   }
[16:06:09.190]                 }
[16:06:09.190]                 else {
[16:06:09.190]                   if (TRUE) {
[16:06:09.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.190]                     {
[16:06:09.190]                       inherits <- base::inherits
[16:06:09.190]                       invokeRestart <- base::invokeRestart
[16:06:09.190]                       is.null <- base::is.null
[16:06:09.190]                       muffled <- FALSE
[16:06:09.190]                       if (inherits(cond, "message")) {
[16:06:09.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.190]                         if (muffled) 
[16:06:09.190]                           invokeRestart("muffleMessage")
[16:06:09.190]                       }
[16:06:09.190]                       else if (inherits(cond, "warning")) {
[16:06:09.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.190]                         if (muffled) 
[16:06:09.190]                           invokeRestart("muffleWarning")
[16:06:09.190]                       }
[16:06:09.190]                       else if (inherits(cond, "condition")) {
[16:06:09.190]                         if (!is.null(pattern)) {
[16:06:09.190]                           computeRestarts <- base::computeRestarts
[16:06:09.190]                           grepl <- base::grepl
[16:06:09.190]                           restarts <- computeRestarts(cond)
[16:06:09.190]                           for (restart in restarts) {
[16:06:09.190]                             name <- restart$name
[16:06:09.190]                             if (is.null(name)) 
[16:06:09.190]                               next
[16:06:09.190]                             if (!grepl(pattern, name)) 
[16:06:09.190]                               next
[16:06:09.190]                             invokeRestart(restart)
[16:06:09.190]                             muffled <- TRUE
[16:06:09.190]                             break
[16:06:09.190]                           }
[16:06:09.190]                         }
[16:06:09.190]                       }
[16:06:09.190]                       invisible(muffled)
[16:06:09.190]                     }
[16:06:09.190]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.190]                   }
[16:06:09.190]                 }
[16:06:09.190]             }
[16:06:09.190]         }))
[16:06:09.190]     }, error = function(ex) {
[16:06:09.190]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:09.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.190]                 ...future.rng), started = ...future.startTime, 
[16:06:09.190]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:09.190]             version = "1.8"), class = "FutureResult")
[16:06:09.190]     }, finally = {
[16:06:09.190]         if (!identical(...future.workdir, getwd())) 
[16:06:09.190]             setwd(...future.workdir)
[16:06:09.190]         {
[16:06:09.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:09.190]                 ...future.oldOptions$nwarnings <- NULL
[16:06:09.190]             }
[16:06:09.190]             base::options(...future.oldOptions)
[16:06:09.190]             if (.Platform$OS.type == "windows") {
[16:06:09.190]                 old_names <- names(...future.oldEnvVars)
[16:06:09.190]                 envs <- base::Sys.getenv()
[16:06:09.190]                 names <- names(envs)
[16:06:09.190]                 common <- intersect(names, old_names)
[16:06:09.190]                 added <- setdiff(names, old_names)
[16:06:09.190]                 removed <- setdiff(old_names, names)
[16:06:09.190]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:09.190]                   envs[common]]
[16:06:09.190]                 NAMES <- toupper(changed)
[16:06:09.190]                 args <- list()
[16:06:09.190]                 for (kk in seq_along(NAMES)) {
[16:06:09.190]                   name <- changed[[kk]]
[16:06:09.190]                   NAME <- NAMES[[kk]]
[16:06:09.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.190]                     next
[16:06:09.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.190]                 }
[16:06:09.190]                 NAMES <- toupper(added)
[16:06:09.190]                 for (kk in seq_along(NAMES)) {
[16:06:09.190]                   name <- added[[kk]]
[16:06:09.190]                   NAME <- NAMES[[kk]]
[16:06:09.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.190]                     next
[16:06:09.190]                   args[[name]] <- ""
[16:06:09.190]                 }
[16:06:09.190]                 NAMES <- toupper(removed)
[16:06:09.190]                 for (kk in seq_along(NAMES)) {
[16:06:09.190]                   name <- removed[[kk]]
[16:06:09.190]                   NAME <- NAMES[[kk]]
[16:06:09.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.190]                     next
[16:06:09.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.190]                 }
[16:06:09.190]                 if (length(args) > 0) 
[16:06:09.190]                   base::do.call(base::Sys.setenv, args = args)
[16:06:09.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:09.190]             }
[16:06:09.190]             else {
[16:06:09.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:09.190]             }
[16:06:09.190]             {
[16:06:09.190]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:09.190]                   0L) {
[16:06:09.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:09.190]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:09.190]                   base::options(opts)
[16:06:09.190]                 }
[16:06:09.190]                 {
[16:06:09.190]                   {
[16:06:09.190]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:09.190]                     NULL
[16:06:09.190]                   }
[16:06:09.190]                   options(future.plan = NULL)
[16:06:09.190]                   if (is.na(NA_character_)) 
[16:06:09.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:09.190]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:09.190]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:09.190]                     envir = parent.frame()) 
[16:06:09.190]                   {
[16:06:09.190]                     if (is.function(workers)) 
[16:06:09.190]                       workers <- workers()
[16:06:09.190]                     workers <- structure(as.integer(workers), 
[16:06:09.190]                       class = class(workers))
[16:06:09.190]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:09.190]                       workers >= 1)
[16:06:09.190]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:09.190]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:09.190]                     }
[16:06:09.190]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:09.190]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:09.190]                       envir = envir)
[16:06:09.190]                     if (!future$lazy) 
[16:06:09.190]                       future <- run(future)
[16:06:09.190]                     invisible(future)
[16:06:09.190]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:09.190]                 }
[16:06:09.190]             }
[16:06:09.190]         }
[16:06:09.190]     })
[16:06:09.190]     if (TRUE) {
[16:06:09.190]         base::sink(type = "output", split = FALSE)
[16:06:09.190]         if (TRUE) {
[16:06:09.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:09.190]         }
[16:06:09.190]         else {
[16:06:09.190]             ...future.result["stdout"] <- base::list(NULL)
[16:06:09.190]         }
[16:06:09.190]         base::close(...future.stdout)
[16:06:09.190]         ...future.stdout <- NULL
[16:06:09.190]     }
[16:06:09.190]     ...future.result$conditions <- ...future.conditions
[16:06:09.190]     ...future.result$finished <- base::Sys.time()
[16:06:09.190]     ...future.result
[16:06:09.190] }
[16:06:09.192] Poll #1 (0): usedNodes() = 2, workers = 2
[16:06:09.213] receiveMessageFromWorker() for ClusterFuture ...
[16:06:09.214] - Validating connection of MultisessionFuture
[16:06:09.214] - received message: FutureResult
[16:06:09.214] - Received FutureResult
[16:06:09.214] - Erased future from FutureRegistry
[16:06:09.215] result() for ClusterFuture ...
[16:06:09.215] - result already collected: FutureResult
[16:06:09.215] result() for ClusterFuture ... done
[16:06:09.215] signalConditions() ...
[16:06:09.215]  - include = ‘immediateCondition’
[16:06:09.215]  - exclude = 
[16:06:09.215]  - resignal = FALSE
[16:06:09.215]  - Number of conditions: 1
[16:06:09.215] signalConditions() ... done
[16:06:09.215] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:09.216] result() for ClusterFuture ...
[16:06:09.216] - result already collected: FutureResult
[16:06:09.216] result() for ClusterFuture ... done
[16:06:09.216] result() for ClusterFuture ...
[16:06:09.216] - result already collected: FutureResult
[16:06:09.216] result() for ClusterFuture ... done
[16:06:09.216] signalConditions() ...
[16:06:09.216]  - include = ‘immediateCondition’
[16:06:09.216]  - exclude = 
[16:06:09.216]  - resignal = FALSE
[16:06:09.216]  - Number of conditions: 1
[16:06:09.217] signalConditions() ... done
[16:06:09.217] MultisessionFuture started
[16:06:09.218] - Launch lazy future ... done
[16:06:09.218] run() for ‘MultisessionFuture’ ... done
[16:06:09.765] receiveMessageFromWorker() for ClusterFuture ...
[16:06:09.765] - Validating connection of MultisessionFuture
[16:06:09.765] - received message: FutureResult
[16:06:09.765] - Received FutureResult
[16:06:09.765] - Erased future from FutureRegistry
[16:06:09.766] result() for ClusterFuture ...
[16:06:09.766] - result already collected: FutureResult
[16:06:09.766] result() for ClusterFuture ... done
[16:06:09.766] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:09.766] A MultisessionFuture was resolved
[16:06:09.766] getGlobalsAndPackages() ...
[16:06:09.766] Searching for globals...
[16:06:09.767] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:09.767] Searching for globals ... DONE
[16:06:09.768] Resolving globals: FALSE
[16:06:09.768] 
[16:06:09.768] 
[16:06:09.768] getGlobalsAndPackages() ... DONE
[16:06:09.768] run() for ‘Future’ ...
[16:06:09.768] - state: ‘created’
[16:06:09.769] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:09.782] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:09.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:09.782]   - Field: ‘node’
[16:06:09.782]   - Field: ‘label’
[16:06:09.783]   - Field: ‘local’
[16:06:09.783]   - Field: ‘owner’
[16:06:09.783]   - Field: ‘envir’
[16:06:09.783]   - Field: ‘workers’
[16:06:09.783]   - Field: ‘packages’
[16:06:09.783]   - Field: ‘gc’
[16:06:09.783]   - Field: ‘conditions’
[16:06:09.783]   - Field: ‘persistent’
[16:06:09.783]   - Field: ‘expr’
[16:06:09.783]   - Field: ‘uuid’
[16:06:09.783]   - Field: ‘seed’
[16:06:09.784]   - Field: ‘version’
[16:06:09.784]   - Field: ‘result’
[16:06:09.784]   - Field: ‘asynchronous’
[16:06:09.784]   - Field: ‘calls’
[16:06:09.784]   - Field: ‘globals’
[16:06:09.784]   - Field: ‘stdout’
[16:06:09.784]   - Field: ‘earlySignal’
[16:06:09.784]   - Field: ‘lazy’
[16:06:09.784]   - Field: ‘state’
[16:06:09.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:09.784] - Launch lazy future ...
[16:06:09.785] Packages needed by the future expression (n = 0): <none>
[16:06:09.785] Packages needed by future strategies (n = 0): <none>
[16:06:09.785] {
[16:06:09.785]     {
[16:06:09.785]         {
[16:06:09.785]             ...future.startTime <- base::Sys.time()
[16:06:09.785]             {
[16:06:09.785]                 {
[16:06:09.785]                   {
[16:06:09.785]                     {
[16:06:09.785]                       base::local({
[16:06:09.785]                         has_future <- base::requireNamespace("future", 
[16:06:09.785]                           quietly = TRUE)
[16:06:09.785]                         if (has_future) {
[16:06:09.785]                           ns <- base::getNamespace("future")
[16:06:09.785]                           version <- ns[[".package"]][["version"]]
[16:06:09.785]                           if (is.null(version)) 
[16:06:09.785]                             version <- utils::packageVersion("future")
[16:06:09.785]                         }
[16:06:09.785]                         else {
[16:06:09.785]                           version <- NULL
[16:06:09.785]                         }
[16:06:09.785]                         if (!has_future || version < "1.8.0") {
[16:06:09.785]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:09.785]                             "", base::R.version$version.string), 
[16:06:09.785]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:09.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:09.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:09.785]                               "release", "version")], collapse = " "), 
[16:06:09.785]                             hostname = base::Sys.info()[["nodename"]])
[16:06:09.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:09.785]                             info)
[16:06:09.785]                           info <- base::paste(info, collapse = "; ")
[16:06:09.785]                           if (!has_future) {
[16:06:09.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:09.785]                               info)
[16:06:09.785]                           }
[16:06:09.785]                           else {
[16:06:09.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:09.785]                               info, version)
[16:06:09.785]                           }
[16:06:09.785]                           base::stop(msg)
[16:06:09.785]                         }
[16:06:09.785]                       })
[16:06:09.785]                     }
[16:06:09.785]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:09.785]                     base::options(mc.cores = 1L)
[16:06:09.785]                   }
[16:06:09.785]                   options(future.plan = NULL)
[16:06:09.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:09.785]                 }
[16:06:09.785]                 ...future.workdir <- getwd()
[16:06:09.785]             }
[16:06:09.785]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:09.785]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:09.785]         }
[16:06:09.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:09.785]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:09.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:09.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:09.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:09.785]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:09.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:09.785]             base::names(...future.oldOptions))
[16:06:09.785]     }
[16:06:09.785]     if (FALSE) {
[16:06:09.785]     }
[16:06:09.785]     else {
[16:06:09.785]         if (TRUE) {
[16:06:09.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:09.785]                 open = "w")
[16:06:09.785]         }
[16:06:09.785]         else {
[16:06:09.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:09.785]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:09.785]         }
[16:06:09.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:09.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:09.785]             base::sink(type = "output", split = FALSE)
[16:06:09.785]             base::close(...future.stdout)
[16:06:09.785]         }, add = TRUE)
[16:06:09.785]     }
[16:06:09.785]     ...future.frame <- base::sys.nframe()
[16:06:09.785]     ...future.conditions <- base::list()
[16:06:09.785]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:09.785]     if (FALSE) {
[16:06:09.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:09.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:09.785]     }
[16:06:09.785]     ...future.result <- base::tryCatch({
[16:06:09.785]         base::withCallingHandlers({
[16:06:09.785]             ...future.value <- base::withVisible(base::local({
[16:06:09.785]                 ...future.makeSendCondition <- base::local({
[16:06:09.785]                   sendCondition <- NULL
[16:06:09.785]                   function(frame = 1L) {
[16:06:09.785]                     if (is.function(sendCondition)) 
[16:06:09.785]                       return(sendCondition)
[16:06:09.785]                     ns <- getNamespace("parallel")
[16:06:09.785]                     if (exists("sendData", mode = "function", 
[16:06:09.785]                       envir = ns)) {
[16:06:09.785]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:09.785]                         envir = ns)
[16:06:09.785]                       envir <- sys.frame(frame)
[16:06:09.785]                       master <- NULL
[16:06:09.785]                       while (!identical(envir, .GlobalEnv) && 
[16:06:09.785]                         !identical(envir, emptyenv())) {
[16:06:09.785]                         if (exists("master", mode = "list", envir = envir, 
[16:06:09.785]                           inherits = FALSE)) {
[16:06:09.785]                           master <- get("master", mode = "list", 
[16:06:09.785]                             envir = envir, inherits = FALSE)
[16:06:09.785]                           if (inherits(master, c("SOCKnode", 
[16:06:09.785]                             "SOCK0node"))) {
[16:06:09.785]                             sendCondition <<- function(cond) {
[16:06:09.785]                               data <- list(type = "VALUE", value = cond, 
[16:06:09.785]                                 success = TRUE)
[16:06:09.785]                               parallel_sendData(master, data)
[16:06:09.785]                             }
[16:06:09.785]                             return(sendCondition)
[16:06:09.785]                           }
[16:06:09.785]                         }
[16:06:09.785]                         frame <- frame + 1L
[16:06:09.785]                         envir <- sys.frame(frame)
[16:06:09.785]                       }
[16:06:09.785]                     }
[16:06:09.785]                     sendCondition <<- function(cond) NULL
[16:06:09.785]                   }
[16:06:09.785]                 })
[16:06:09.785]                 withCallingHandlers({
[16:06:09.785]                   {
[16:06:09.785]                     Sys.sleep(0.5)
[16:06:09.785]                     list(a = 1, b = 42L)
[16:06:09.785]                   }
[16:06:09.785]                 }, immediateCondition = function(cond) {
[16:06:09.785]                   sendCondition <- ...future.makeSendCondition()
[16:06:09.785]                   sendCondition(cond)
[16:06:09.785]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.785]                   {
[16:06:09.785]                     inherits <- base::inherits
[16:06:09.785]                     invokeRestart <- base::invokeRestart
[16:06:09.785]                     is.null <- base::is.null
[16:06:09.785]                     muffled <- FALSE
[16:06:09.785]                     if (inherits(cond, "message")) {
[16:06:09.785]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:09.785]                       if (muffled) 
[16:06:09.785]                         invokeRestart("muffleMessage")
[16:06:09.785]                     }
[16:06:09.785]                     else if (inherits(cond, "warning")) {
[16:06:09.785]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:09.785]                       if (muffled) 
[16:06:09.785]                         invokeRestart("muffleWarning")
[16:06:09.785]                     }
[16:06:09.785]                     else if (inherits(cond, "condition")) {
[16:06:09.785]                       if (!is.null(pattern)) {
[16:06:09.785]                         computeRestarts <- base::computeRestarts
[16:06:09.785]                         grepl <- base::grepl
[16:06:09.785]                         restarts <- computeRestarts(cond)
[16:06:09.785]                         for (restart in restarts) {
[16:06:09.785]                           name <- restart$name
[16:06:09.785]                           if (is.null(name)) 
[16:06:09.785]                             next
[16:06:09.785]                           if (!grepl(pattern, name)) 
[16:06:09.785]                             next
[16:06:09.785]                           invokeRestart(restart)
[16:06:09.785]                           muffled <- TRUE
[16:06:09.785]                           break
[16:06:09.785]                         }
[16:06:09.785]                       }
[16:06:09.785]                     }
[16:06:09.785]                     invisible(muffled)
[16:06:09.785]                   }
[16:06:09.785]                   muffleCondition(cond)
[16:06:09.785]                 })
[16:06:09.785]             }))
[16:06:09.785]             future::FutureResult(value = ...future.value$value, 
[16:06:09.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.785]                   ...future.rng), globalenv = if (FALSE) 
[16:06:09.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:09.785]                     ...future.globalenv.names))
[16:06:09.785]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:09.785]         }, condition = base::local({
[16:06:09.785]             c <- base::c
[16:06:09.785]             inherits <- base::inherits
[16:06:09.785]             invokeRestart <- base::invokeRestart
[16:06:09.785]             length <- base::length
[16:06:09.785]             list <- base::list
[16:06:09.785]             seq.int <- base::seq.int
[16:06:09.785]             signalCondition <- base::signalCondition
[16:06:09.785]             sys.calls <- base::sys.calls
[16:06:09.785]             `[[` <- base::`[[`
[16:06:09.785]             `+` <- base::`+`
[16:06:09.785]             `<<-` <- base::`<<-`
[16:06:09.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:09.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:09.785]                   3L)]
[16:06:09.785]             }
[16:06:09.785]             function(cond) {
[16:06:09.785]                 is_error <- inherits(cond, "error")
[16:06:09.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:09.785]                   NULL)
[16:06:09.785]                 if (is_error) {
[16:06:09.785]                   sessionInformation <- function() {
[16:06:09.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:09.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:09.785]                       search = base::search(), system = base::Sys.info())
[16:06:09.785]                   }
[16:06:09.785]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:09.785]                     cond$call), session = sessionInformation(), 
[16:06:09.785]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:09.785]                   signalCondition(cond)
[16:06:09.785]                 }
[16:06:09.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:09.785]                 "immediateCondition"))) {
[16:06:09.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:09.785]                   ...future.conditions[[length(...future.conditions) + 
[16:06:09.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:09.785]                   if (TRUE && !signal) {
[16:06:09.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.785]                     {
[16:06:09.785]                       inherits <- base::inherits
[16:06:09.785]                       invokeRestart <- base::invokeRestart
[16:06:09.785]                       is.null <- base::is.null
[16:06:09.785]                       muffled <- FALSE
[16:06:09.785]                       if (inherits(cond, "message")) {
[16:06:09.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.785]                         if (muffled) 
[16:06:09.785]                           invokeRestart("muffleMessage")
[16:06:09.785]                       }
[16:06:09.785]                       else if (inherits(cond, "warning")) {
[16:06:09.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.785]                         if (muffled) 
[16:06:09.785]                           invokeRestart("muffleWarning")
[16:06:09.785]                       }
[16:06:09.785]                       else if (inherits(cond, "condition")) {
[16:06:09.785]                         if (!is.null(pattern)) {
[16:06:09.785]                           computeRestarts <- base::computeRestarts
[16:06:09.785]                           grepl <- base::grepl
[16:06:09.785]                           restarts <- computeRestarts(cond)
[16:06:09.785]                           for (restart in restarts) {
[16:06:09.785]                             name <- restart$name
[16:06:09.785]                             if (is.null(name)) 
[16:06:09.785]                               next
[16:06:09.785]                             if (!grepl(pattern, name)) 
[16:06:09.785]                               next
[16:06:09.785]                             invokeRestart(restart)
[16:06:09.785]                             muffled <- TRUE
[16:06:09.785]                             break
[16:06:09.785]                           }
[16:06:09.785]                         }
[16:06:09.785]                       }
[16:06:09.785]                       invisible(muffled)
[16:06:09.785]                     }
[16:06:09.785]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.785]                   }
[16:06:09.785]                 }
[16:06:09.785]                 else {
[16:06:09.785]                   if (TRUE) {
[16:06:09.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:09.785]                     {
[16:06:09.785]                       inherits <- base::inherits
[16:06:09.785]                       invokeRestart <- base::invokeRestart
[16:06:09.785]                       is.null <- base::is.null
[16:06:09.785]                       muffled <- FALSE
[16:06:09.785]                       if (inherits(cond, "message")) {
[16:06:09.785]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:09.785]                         if (muffled) 
[16:06:09.785]                           invokeRestart("muffleMessage")
[16:06:09.785]                       }
[16:06:09.785]                       else if (inherits(cond, "warning")) {
[16:06:09.785]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:09.785]                         if (muffled) 
[16:06:09.785]                           invokeRestart("muffleWarning")
[16:06:09.785]                       }
[16:06:09.785]                       else if (inherits(cond, "condition")) {
[16:06:09.785]                         if (!is.null(pattern)) {
[16:06:09.785]                           computeRestarts <- base::computeRestarts
[16:06:09.785]                           grepl <- base::grepl
[16:06:09.785]                           restarts <- computeRestarts(cond)
[16:06:09.785]                           for (restart in restarts) {
[16:06:09.785]                             name <- restart$name
[16:06:09.785]                             if (is.null(name)) 
[16:06:09.785]                               next
[16:06:09.785]                             if (!grepl(pattern, name)) 
[16:06:09.785]                               next
[16:06:09.785]                             invokeRestart(restart)
[16:06:09.785]                             muffled <- TRUE
[16:06:09.785]                             break
[16:06:09.785]                           }
[16:06:09.785]                         }
[16:06:09.785]                       }
[16:06:09.785]                       invisible(muffled)
[16:06:09.785]                     }
[16:06:09.785]                     muffleCondition(cond, pattern = "^muffle")
[16:06:09.785]                   }
[16:06:09.785]                 }
[16:06:09.785]             }
[16:06:09.785]         }))
[16:06:09.785]     }, error = function(ex) {
[16:06:09.785]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:09.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:09.785]                 ...future.rng), started = ...future.startTime, 
[16:06:09.785]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:09.785]             version = "1.8"), class = "FutureResult")
[16:06:09.785]     }, finally = {
[16:06:09.785]         if (!identical(...future.workdir, getwd())) 
[16:06:09.785]             setwd(...future.workdir)
[16:06:09.785]         {
[16:06:09.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:09.785]                 ...future.oldOptions$nwarnings <- NULL
[16:06:09.785]             }
[16:06:09.785]             base::options(...future.oldOptions)
[16:06:09.785]             if (.Platform$OS.type == "windows") {
[16:06:09.785]                 old_names <- names(...future.oldEnvVars)
[16:06:09.785]                 envs <- base::Sys.getenv()
[16:06:09.785]                 names <- names(envs)
[16:06:09.785]                 common <- intersect(names, old_names)
[16:06:09.785]                 added <- setdiff(names, old_names)
[16:06:09.785]                 removed <- setdiff(old_names, names)
[16:06:09.785]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:09.785]                   envs[common]]
[16:06:09.785]                 NAMES <- toupper(changed)
[16:06:09.785]                 args <- list()
[16:06:09.785]                 for (kk in seq_along(NAMES)) {
[16:06:09.785]                   name <- changed[[kk]]
[16:06:09.785]                   NAME <- NAMES[[kk]]
[16:06:09.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.785]                     next
[16:06:09.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.785]                 }
[16:06:09.785]                 NAMES <- toupper(added)
[16:06:09.785]                 for (kk in seq_along(NAMES)) {
[16:06:09.785]                   name <- added[[kk]]
[16:06:09.785]                   NAME <- NAMES[[kk]]
[16:06:09.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.785]                     next
[16:06:09.785]                   args[[name]] <- ""
[16:06:09.785]                 }
[16:06:09.785]                 NAMES <- toupper(removed)
[16:06:09.785]                 for (kk in seq_along(NAMES)) {
[16:06:09.785]                   name <- removed[[kk]]
[16:06:09.785]                   NAME <- NAMES[[kk]]
[16:06:09.785]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:09.785]                     next
[16:06:09.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:09.785]                 }
[16:06:09.785]                 if (length(args) > 0) 
[16:06:09.785]                   base::do.call(base::Sys.setenv, args = args)
[16:06:09.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:09.785]             }
[16:06:09.785]             else {
[16:06:09.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:09.785]             }
[16:06:09.785]             {
[16:06:09.785]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:09.785]                   0L) {
[16:06:09.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:09.785]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:09.785]                   base::options(opts)
[16:06:09.785]                 }
[16:06:09.785]                 {
[16:06:09.785]                   {
[16:06:09.785]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:09.785]                     NULL
[16:06:09.785]                   }
[16:06:09.785]                   options(future.plan = NULL)
[16:06:09.785]                   if (is.na(NA_character_)) 
[16:06:09.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:09.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:09.785]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:09.785]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:09.785]                     envir = parent.frame()) 
[16:06:09.785]                   {
[16:06:09.785]                     if (is.function(workers)) 
[16:06:09.785]                       workers <- workers()
[16:06:09.785]                     workers <- structure(as.integer(workers), 
[16:06:09.785]                       class = class(workers))
[16:06:09.785]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:09.785]                       workers >= 1)
[16:06:09.785]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:09.785]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:09.785]                     }
[16:06:09.785]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:09.785]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:09.785]                       envir = envir)
[16:06:09.785]                     if (!future$lazy) 
[16:06:09.785]                       future <- run(future)
[16:06:09.785]                     invisible(future)
[16:06:09.785]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:09.785]                 }
[16:06:09.785]             }
[16:06:09.785]         }
[16:06:09.785]     })
[16:06:09.785]     if (TRUE) {
[16:06:09.785]         base::sink(type = "output", split = FALSE)
[16:06:09.785]         if (TRUE) {
[16:06:09.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:09.785]         }
[16:06:09.785]         else {
[16:06:09.785]             ...future.result["stdout"] <- base::list(NULL)
[16:06:09.785]         }
[16:06:09.785]         base::close(...future.stdout)
[16:06:09.785]         ...future.stdout <- NULL
[16:06:09.785]     }
[16:06:09.785]     ...future.result$conditions <- ...future.conditions
[16:06:09.785]     ...future.result$finished <- base::Sys.time()
[16:06:09.785]     ...future.result
[16:06:09.785] }
[16:06:09.788] MultisessionFuture started
[16:06:09.789] - Launch lazy future ... done
[16:06:09.789] run() for ‘MultisessionFuture’ ... done
[16:06:10.337] receiveMessageFromWorker() for ClusterFuture ...
[16:06:10.337] - Validating connection of MultisessionFuture
[16:06:10.337] - received message: FutureResult
[16:06:10.337] - Received FutureResult
[16:06:10.338] - Erased future from FutureRegistry
[16:06:10.338] result() for ClusterFuture ...
[16:06:10.338] - result already collected: FutureResult
[16:06:10.338] result() for ClusterFuture ... done
[16:06:10.338] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:10.338] A MultisessionFuture was resolved
- w/ exception ...
[16:06:10.338] getGlobalsAndPackages() ...
[16:06:10.338] Searching for globals...
[16:06:10.339] - globals found: [2] ‘list’, ‘stop’
[16:06:10.339] Searching for globals ... DONE
[16:06:10.339] Resolving globals: FALSE
[16:06:10.340] 
[16:06:10.340] 
[16:06:10.340] getGlobalsAndPackages() ... DONE
[16:06:10.340] run() for ‘Future’ ...
[16:06:10.340] - state: ‘created’
[16:06:10.340] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:10.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:10.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:10.354]   - Field: ‘node’
[16:06:10.354]   - Field: ‘label’
[16:06:10.355]   - Field: ‘local’
[16:06:10.355]   - Field: ‘owner’
[16:06:10.355]   - Field: ‘envir’
[16:06:10.355]   - Field: ‘workers’
[16:06:10.355]   - Field: ‘packages’
[16:06:10.355]   - Field: ‘gc’
[16:06:10.355]   - Field: ‘conditions’
[16:06:10.355]   - Field: ‘persistent’
[16:06:10.355]   - Field: ‘expr’
[16:06:10.355]   - Field: ‘uuid’
[16:06:10.355]   - Field: ‘seed’
[16:06:10.356]   - Field: ‘version’
[16:06:10.356]   - Field: ‘result’
[16:06:10.356]   - Field: ‘asynchronous’
[16:06:10.356]   - Field: ‘calls’
[16:06:10.356]   - Field: ‘globals’
[16:06:10.356]   - Field: ‘stdout’
[16:06:10.356]   - Field: ‘earlySignal’
[16:06:10.356]   - Field: ‘lazy’
[16:06:10.356]   - Field: ‘state’
[16:06:10.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:10.357] - Launch lazy future ...
[16:06:10.357] Packages needed by the future expression (n = 0): <none>
[16:06:10.357] Packages needed by future strategies (n = 0): <none>
[16:06:10.357] {
[16:06:10.357]     {
[16:06:10.357]         {
[16:06:10.357]             ...future.startTime <- base::Sys.time()
[16:06:10.357]             {
[16:06:10.357]                 {
[16:06:10.357]                   {
[16:06:10.357]                     {
[16:06:10.357]                       base::local({
[16:06:10.357]                         has_future <- base::requireNamespace("future", 
[16:06:10.357]                           quietly = TRUE)
[16:06:10.357]                         if (has_future) {
[16:06:10.357]                           ns <- base::getNamespace("future")
[16:06:10.357]                           version <- ns[[".package"]][["version"]]
[16:06:10.357]                           if (is.null(version)) 
[16:06:10.357]                             version <- utils::packageVersion("future")
[16:06:10.357]                         }
[16:06:10.357]                         else {
[16:06:10.357]                           version <- NULL
[16:06:10.357]                         }
[16:06:10.357]                         if (!has_future || version < "1.8.0") {
[16:06:10.357]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:10.357]                             "", base::R.version$version.string), 
[16:06:10.357]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:10.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:10.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:10.357]                               "release", "version")], collapse = " "), 
[16:06:10.357]                             hostname = base::Sys.info()[["nodename"]])
[16:06:10.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:10.357]                             info)
[16:06:10.357]                           info <- base::paste(info, collapse = "; ")
[16:06:10.357]                           if (!has_future) {
[16:06:10.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:10.357]                               info)
[16:06:10.357]                           }
[16:06:10.357]                           else {
[16:06:10.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:10.357]                               info, version)
[16:06:10.357]                           }
[16:06:10.357]                           base::stop(msg)
[16:06:10.357]                         }
[16:06:10.357]                       })
[16:06:10.357]                     }
[16:06:10.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:10.357]                     base::options(mc.cores = 1L)
[16:06:10.357]                   }
[16:06:10.357]                   options(future.plan = NULL)
[16:06:10.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:10.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:10.357]                 }
[16:06:10.357]                 ...future.workdir <- getwd()
[16:06:10.357]             }
[16:06:10.357]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:10.357]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:10.357]         }
[16:06:10.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:10.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:10.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:10.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:10.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:10.357]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:10.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:10.357]             base::names(...future.oldOptions))
[16:06:10.357]     }
[16:06:10.357]     if (FALSE) {
[16:06:10.357]     }
[16:06:10.357]     else {
[16:06:10.357]         if (TRUE) {
[16:06:10.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:10.357]                 open = "w")
[16:06:10.357]         }
[16:06:10.357]         else {
[16:06:10.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:10.357]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:10.357]         }
[16:06:10.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:10.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:10.357]             base::sink(type = "output", split = FALSE)
[16:06:10.357]             base::close(...future.stdout)
[16:06:10.357]         }, add = TRUE)
[16:06:10.357]     }
[16:06:10.357]     ...future.frame <- base::sys.nframe()
[16:06:10.357]     ...future.conditions <- base::list()
[16:06:10.357]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:10.357]     if (FALSE) {
[16:06:10.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:10.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:10.357]     }
[16:06:10.357]     ...future.result <- base::tryCatch({
[16:06:10.357]         base::withCallingHandlers({
[16:06:10.357]             ...future.value <- base::withVisible(base::local({
[16:06:10.357]                 ...future.makeSendCondition <- base::local({
[16:06:10.357]                   sendCondition <- NULL
[16:06:10.357]                   function(frame = 1L) {
[16:06:10.357]                     if (is.function(sendCondition)) 
[16:06:10.357]                       return(sendCondition)
[16:06:10.357]                     ns <- getNamespace("parallel")
[16:06:10.357]                     if (exists("sendData", mode = "function", 
[16:06:10.357]                       envir = ns)) {
[16:06:10.357]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:10.357]                         envir = ns)
[16:06:10.357]                       envir <- sys.frame(frame)
[16:06:10.357]                       master <- NULL
[16:06:10.357]                       while (!identical(envir, .GlobalEnv) && 
[16:06:10.357]                         !identical(envir, emptyenv())) {
[16:06:10.357]                         if (exists("master", mode = "list", envir = envir, 
[16:06:10.357]                           inherits = FALSE)) {
[16:06:10.357]                           master <- get("master", mode = "list", 
[16:06:10.357]                             envir = envir, inherits = FALSE)
[16:06:10.357]                           if (inherits(master, c("SOCKnode", 
[16:06:10.357]                             "SOCK0node"))) {
[16:06:10.357]                             sendCondition <<- function(cond) {
[16:06:10.357]                               data <- list(type = "VALUE", value = cond, 
[16:06:10.357]                                 success = TRUE)
[16:06:10.357]                               parallel_sendData(master, data)
[16:06:10.357]                             }
[16:06:10.357]                             return(sendCondition)
[16:06:10.357]                           }
[16:06:10.357]                         }
[16:06:10.357]                         frame <- frame + 1L
[16:06:10.357]                         envir <- sys.frame(frame)
[16:06:10.357]                       }
[16:06:10.357]                     }
[16:06:10.357]                     sendCondition <<- function(cond) NULL
[16:06:10.357]                   }
[16:06:10.357]                 })
[16:06:10.357]                 withCallingHandlers({
[16:06:10.357]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:10.357]                 }, immediateCondition = function(cond) {
[16:06:10.357]                   sendCondition <- ...future.makeSendCondition()
[16:06:10.357]                   sendCondition(cond)
[16:06:10.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.357]                   {
[16:06:10.357]                     inherits <- base::inherits
[16:06:10.357]                     invokeRestart <- base::invokeRestart
[16:06:10.357]                     is.null <- base::is.null
[16:06:10.357]                     muffled <- FALSE
[16:06:10.357]                     if (inherits(cond, "message")) {
[16:06:10.357]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:10.357]                       if (muffled) 
[16:06:10.357]                         invokeRestart("muffleMessage")
[16:06:10.357]                     }
[16:06:10.357]                     else if (inherits(cond, "warning")) {
[16:06:10.357]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:10.357]                       if (muffled) 
[16:06:10.357]                         invokeRestart("muffleWarning")
[16:06:10.357]                     }
[16:06:10.357]                     else if (inherits(cond, "condition")) {
[16:06:10.357]                       if (!is.null(pattern)) {
[16:06:10.357]                         computeRestarts <- base::computeRestarts
[16:06:10.357]                         grepl <- base::grepl
[16:06:10.357]                         restarts <- computeRestarts(cond)
[16:06:10.357]                         for (restart in restarts) {
[16:06:10.357]                           name <- restart$name
[16:06:10.357]                           if (is.null(name)) 
[16:06:10.357]                             next
[16:06:10.357]                           if (!grepl(pattern, name)) 
[16:06:10.357]                             next
[16:06:10.357]                           invokeRestart(restart)
[16:06:10.357]                           muffled <- TRUE
[16:06:10.357]                           break
[16:06:10.357]                         }
[16:06:10.357]                       }
[16:06:10.357]                     }
[16:06:10.357]                     invisible(muffled)
[16:06:10.357]                   }
[16:06:10.357]                   muffleCondition(cond)
[16:06:10.357]                 })
[16:06:10.357]             }))
[16:06:10.357]             future::FutureResult(value = ...future.value$value, 
[16:06:10.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:10.357]                   ...future.rng), globalenv = if (FALSE) 
[16:06:10.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:10.357]                     ...future.globalenv.names))
[16:06:10.357]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:10.357]         }, condition = base::local({
[16:06:10.357]             c <- base::c
[16:06:10.357]             inherits <- base::inherits
[16:06:10.357]             invokeRestart <- base::invokeRestart
[16:06:10.357]             length <- base::length
[16:06:10.357]             list <- base::list
[16:06:10.357]             seq.int <- base::seq.int
[16:06:10.357]             signalCondition <- base::signalCondition
[16:06:10.357]             sys.calls <- base::sys.calls
[16:06:10.357]             `[[` <- base::`[[`
[16:06:10.357]             `+` <- base::`+`
[16:06:10.357]             `<<-` <- base::`<<-`
[16:06:10.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:10.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:10.357]                   3L)]
[16:06:10.357]             }
[16:06:10.357]             function(cond) {
[16:06:10.357]                 is_error <- inherits(cond, "error")
[16:06:10.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:10.357]                   NULL)
[16:06:10.357]                 if (is_error) {
[16:06:10.357]                   sessionInformation <- function() {
[16:06:10.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:10.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:10.357]                       search = base::search(), system = base::Sys.info())
[16:06:10.357]                   }
[16:06:10.357]                   ...future.conditions[[length(...future.conditions) + 
[16:06:10.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:10.357]                     cond$call), session = sessionInformation(), 
[16:06:10.357]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:10.357]                   signalCondition(cond)
[16:06:10.357]                 }
[16:06:10.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:10.357]                 "immediateCondition"))) {
[16:06:10.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:10.357]                   ...future.conditions[[length(...future.conditions) + 
[16:06:10.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:10.357]                   if (TRUE && !signal) {
[16:06:10.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.357]                     {
[16:06:10.357]                       inherits <- base::inherits
[16:06:10.357]                       invokeRestart <- base::invokeRestart
[16:06:10.357]                       is.null <- base::is.null
[16:06:10.357]                       muffled <- FALSE
[16:06:10.357]                       if (inherits(cond, "message")) {
[16:06:10.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:10.357]                         if (muffled) 
[16:06:10.357]                           invokeRestart("muffleMessage")
[16:06:10.357]                       }
[16:06:10.357]                       else if (inherits(cond, "warning")) {
[16:06:10.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:10.357]                         if (muffled) 
[16:06:10.357]                           invokeRestart("muffleWarning")
[16:06:10.357]                       }
[16:06:10.357]                       else if (inherits(cond, "condition")) {
[16:06:10.357]                         if (!is.null(pattern)) {
[16:06:10.357]                           computeRestarts <- base::computeRestarts
[16:06:10.357]                           grepl <- base::grepl
[16:06:10.357]                           restarts <- computeRestarts(cond)
[16:06:10.357]                           for (restart in restarts) {
[16:06:10.357]                             name <- restart$name
[16:06:10.357]                             if (is.null(name)) 
[16:06:10.357]                               next
[16:06:10.357]                             if (!grepl(pattern, name)) 
[16:06:10.357]                               next
[16:06:10.357]                             invokeRestart(restart)
[16:06:10.357]                             muffled <- TRUE
[16:06:10.357]                             break
[16:06:10.357]                           }
[16:06:10.357]                         }
[16:06:10.357]                       }
[16:06:10.357]                       invisible(muffled)
[16:06:10.357]                     }
[16:06:10.357]                     muffleCondition(cond, pattern = "^muffle")
[16:06:10.357]                   }
[16:06:10.357]                 }
[16:06:10.357]                 else {
[16:06:10.357]                   if (TRUE) {
[16:06:10.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.357]                     {
[16:06:10.357]                       inherits <- base::inherits
[16:06:10.357]                       invokeRestart <- base::invokeRestart
[16:06:10.357]                       is.null <- base::is.null
[16:06:10.357]                       muffled <- FALSE
[16:06:10.357]                       if (inherits(cond, "message")) {
[16:06:10.357]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:10.357]                         if (muffled) 
[16:06:10.357]                           invokeRestart("muffleMessage")
[16:06:10.357]                       }
[16:06:10.357]                       else if (inherits(cond, "warning")) {
[16:06:10.357]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:10.357]                         if (muffled) 
[16:06:10.357]                           invokeRestart("muffleWarning")
[16:06:10.357]                       }
[16:06:10.357]                       else if (inherits(cond, "condition")) {
[16:06:10.357]                         if (!is.null(pattern)) {
[16:06:10.357]                           computeRestarts <- base::computeRestarts
[16:06:10.357]                           grepl <- base::grepl
[16:06:10.357]                           restarts <- computeRestarts(cond)
[16:06:10.357]                           for (restart in restarts) {
[16:06:10.357]                             name <- restart$name
[16:06:10.357]                             if (is.null(name)) 
[16:06:10.357]                               next
[16:06:10.357]                             if (!grepl(pattern, name)) 
[16:06:10.357]                               next
[16:06:10.357]                             invokeRestart(restart)
[16:06:10.357]                             muffled <- TRUE
[16:06:10.357]                             break
[16:06:10.357]                           }
[16:06:10.357]                         }
[16:06:10.357]                       }
[16:06:10.357]                       invisible(muffled)
[16:06:10.357]                     }
[16:06:10.357]                     muffleCondition(cond, pattern = "^muffle")
[16:06:10.357]                   }
[16:06:10.357]                 }
[16:06:10.357]             }
[16:06:10.357]         }))
[16:06:10.357]     }, error = function(ex) {
[16:06:10.357]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:10.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:10.357]                 ...future.rng), started = ...future.startTime, 
[16:06:10.357]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:10.357]             version = "1.8"), class = "FutureResult")
[16:06:10.357]     }, finally = {
[16:06:10.357]         if (!identical(...future.workdir, getwd())) 
[16:06:10.357]             setwd(...future.workdir)
[16:06:10.357]         {
[16:06:10.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:10.357]                 ...future.oldOptions$nwarnings <- NULL
[16:06:10.357]             }
[16:06:10.357]             base::options(...future.oldOptions)
[16:06:10.357]             if (.Platform$OS.type == "windows") {
[16:06:10.357]                 old_names <- names(...future.oldEnvVars)
[16:06:10.357]                 envs <- base::Sys.getenv()
[16:06:10.357]                 names <- names(envs)
[16:06:10.357]                 common <- intersect(names, old_names)
[16:06:10.357]                 added <- setdiff(names, old_names)
[16:06:10.357]                 removed <- setdiff(old_names, names)
[16:06:10.357]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:10.357]                   envs[common]]
[16:06:10.357]                 NAMES <- toupper(changed)
[16:06:10.357]                 args <- list()
[16:06:10.357]                 for (kk in seq_along(NAMES)) {
[16:06:10.357]                   name <- changed[[kk]]
[16:06:10.357]                   NAME <- NAMES[[kk]]
[16:06:10.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.357]                     next
[16:06:10.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:10.357]                 }
[16:06:10.357]                 NAMES <- toupper(added)
[16:06:10.357]                 for (kk in seq_along(NAMES)) {
[16:06:10.357]                   name <- added[[kk]]
[16:06:10.357]                   NAME <- NAMES[[kk]]
[16:06:10.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.357]                     next
[16:06:10.357]                   args[[name]] <- ""
[16:06:10.357]                 }
[16:06:10.357]                 NAMES <- toupper(removed)
[16:06:10.357]                 for (kk in seq_along(NAMES)) {
[16:06:10.357]                   name <- removed[[kk]]
[16:06:10.357]                   NAME <- NAMES[[kk]]
[16:06:10.357]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.357]                     next
[16:06:10.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:10.357]                 }
[16:06:10.357]                 if (length(args) > 0) 
[16:06:10.357]                   base::do.call(base::Sys.setenv, args = args)
[16:06:10.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:10.357]             }
[16:06:10.357]             else {
[16:06:10.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:10.357]             }
[16:06:10.357]             {
[16:06:10.357]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:10.357]                   0L) {
[16:06:10.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:10.357]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:10.357]                   base::options(opts)
[16:06:10.357]                 }
[16:06:10.357]                 {
[16:06:10.357]                   {
[16:06:10.357]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:10.357]                     NULL
[16:06:10.357]                   }
[16:06:10.357]                   options(future.plan = NULL)
[16:06:10.357]                   if (is.na(NA_character_)) 
[16:06:10.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:10.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:10.357]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:10.357]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:10.357]                     envir = parent.frame()) 
[16:06:10.357]                   {
[16:06:10.357]                     if (is.function(workers)) 
[16:06:10.357]                       workers <- workers()
[16:06:10.357]                     workers <- structure(as.integer(workers), 
[16:06:10.357]                       class = class(workers))
[16:06:10.357]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:10.357]                       workers >= 1)
[16:06:10.357]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:10.357]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:10.357]                     }
[16:06:10.357]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:10.357]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:10.357]                       envir = envir)
[16:06:10.357]                     if (!future$lazy) 
[16:06:10.357]                       future <- run(future)
[16:06:10.357]                     invisible(future)
[16:06:10.357]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:10.357]                 }
[16:06:10.357]             }
[16:06:10.357]         }
[16:06:10.357]     })
[16:06:10.357]     if (TRUE) {
[16:06:10.357]         base::sink(type = "output", split = FALSE)
[16:06:10.357]         if (TRUE) {
[16:06:10.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:10.357]         }
[16:06:10.357]         else {
[16:06:10.357]             ...future.result["stdout"] <- base::list(NULL)
[16:06:10.357]         }
[16:06:10.357]         base::close(...future.stdout)
[16:06:10.357]         ...future.stdout <- NULL
[16:06:10.357]     }
[16:06:10.357]     ...future.result$conditions <- ...future.conditions
[16:06:10.357]     ...future.result$finished <- base::Sys.time()
[16:06:10.357]     ...future.result
[16:06:10.357] }
[16:06:10.360] MultisessionFuture started
[16:06:10.361] - Launch lazy future ... done
[16:06:10.361] run() for ‘MultisessionFuture’ ... done
[16:06:10.408] receiveMessageFromWorker() for ClusterFuture ...
[16:06:10.408] - Validating connection of MultisessionFuture
[16:06:10.409] - received message: FutureResult
[16:06:10.409] - Received FutureResult
[16:06:10.409] - Erased future from FutureRegistry
[16:06:10.409] result() for ClusterFuture ...
[16:06:10.409] - result already collected: FutureResult
[16:06:10.409] result() for ClusterFuture ... done
[16:06:10.409] signalConditions() ...
[16:06:10.410]  - include = ‘immediateCondition’
[16:06:10.410]  - exclude = 
[16:06:10.410]  - resignal = FALSE
[16:06:10.410]  - Number of conditions: 1
[16:06:10.410] signalConditions() ... done
[16:06:10.410] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:10.410] A MultisessionFuture was resolved
[16:06:10.410] getGlobalsAndPackages() ...
[16:06:10.410] Searching for globals...
[16:06:10.411] - globals found: [2] ‘list’, ‘stop’
[16:06:10.411] Searching for globals ... DONE
[16:06:10.411] Resolving globals: FALSE
[16:06:10.412] 
[16:06:10.412] 
[16:06:10.412] getGlobalsAndPackages() ... DONE
[16:06:10.412] run() for ‘Future’ ...
[16:06:10.412] - state: ‘created’
[16:06:10.412] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:10.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:10.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:10.426]   - Field: ‘node’
[16:06:10.426]   - Field: ‘label’
[16:06:10.426]   - Field: ‘local’
[16:06:10.426]   - Field: ‘owner’
[16:06:10.426]   - Field: ‘envir’
[16:06:10.427]   - Field: ‘workers’
[16:06:10.427]   - Field: ‘packages’
[16:06:10.427]   - Field: ‘gc’
[16:06:10.427]   - Field: ‘conditions’
[16:06:10.427]   - Field: ‘persistent’
[16:06:10.427]   - Field: ‘expr’
[16:06:10.427]   - Field: ‘uuid’
[16:06:10.427]   - Field: ‘seed’
[16:06:10.427]   - Field: ‘version’
[16:06:10.427]   - Field: ‘result’
[16:06:10.427]   - Field: ‘asynchronous’
[16:06:10.428]   - Field: ‘calls’
[16:06:10.428]   - Field: ‘globals’
[16:06:10.428]   - Field: ‘stdout’
[16:06:10.428]   - Field: ‘earlySignal’
[16:06:10.428]   - Field: ‘lazy’
[16:06:10.428]   - Field: ‘state’
[16:06:10.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:10.428] - Launch lazy future ...
[16:06:10.428] Packages needed by the future expression (n = 0): <none>
[16:06:10.429] Packages needed by future strategies (n = 0): <none>
[16:06:10.429] {
[16:06:10.429]     {
[16:06:10.429]         {
[16:06:10.429]             ...future.startTime <- base::Sys.time()
[16:06:10.429]             {
[16:06:10.429]                 {
[16:06:10.429]                   {
[16:06:10.429]                     {
[16:06:10.429]                       base::local({
[16:06:10.429]                         has_future <- base::requireNamespace("future", 
[16:06:10.429]                           quietly = TRUE)
[16:06:10.429]                         if (has_future) {
[16:06:10.429]                           ns <- base::getNamespace("future")
[16:06:10.429]                           version <- ns[[".package"]][["version"]]
[16:06:10.429]                           if (is.null(version)) 
[16:06:10.429]                             version <- utils::packageVersion("future")
[16:06:10.429]                         }
[16:06:10.429]                         else {
[16:06:10.429]                           version <- NULL
[16:06:10.429]                         }
[16:06:10.429]                         if (!has_future || version < "1.8.0") {
[16:06:10.429]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:10.429]                             "", base::R.version$version.string), 
[16:06:10.429]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:10.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:10.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:10.429]                               "release", "version")], collapse = " "), 
[16:06:10.429]                             hostname = base::Sys.info()[["nodename"]])
[16:06:10.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:10.429]                             info)
[16:06:10.429]                           info <- base::paste(info, collapse = "; ")
[16:06:10.429]                           if (!has_future) {
[16:06:10.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:10.429]                               info)
[16:06:10.429]                           }
[16:06:10.429]                           else {
[16:06:10.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:10.429]                               info, version)
[16:06:10.429]                           }
[16:06:10.429]                           base::stop(msg)
[16:06:10.429]                         }
[16:06:10.429]                       })
[16:06:10.429]                     }
[16:06:10.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:10.429]                     base::options(mc.cores = 1L)
[16:06:10.429]                   }
[16:06:10.429]                   options(future.plan = NULL)
[16:06:10.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:10.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:10.429]                 }
[16:06:10.429]                 ...future.workdir <- getwd()
[16:06:10.429]             }
[16:06:10.429]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:10.429]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:10.429]         }
[16:06:10.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:10.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:10.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:10.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:10.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:10.429]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:10.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:10.429]             base::names(...future.oldOptions))
[16:06:10.429]     }
[16:06:10.429]     if (FALSE) {
[16:06:10.429]     }
[16:06:10.429]     else {
[16:06:10.429]         if (TRUE) {
[16:06:10.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:10.429]                 open = "w")
[16:06:10.429]         }
[16:06:10.429]         else {
[16:06:10.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:10.429]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:10.429]         }
[16:06:10.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:10.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:10.429]             base::sink(type = "output", split = FALSE)
[16:06:10.429]             base::close(...future.stdout)
[16:06:10.429]         }, add = TRUE)
[16:06:10.429]     }
[16:06:10.429]     ...future.frame <- base::sys.nframe()
[16:06:10.429]     ...future.conditions <- base::list()
[16:06:10.429]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:10.429]     if (FALSE) {
[16:06:10.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:10.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:10.429]     }
[16:06:10.429]     ...future.result <- base::tryCatch({
[16:06:10.429]         base::withCallingHandlers({
[16:06:10.429]             ...future.value <- base::withVisible(base::local({
[16:06:10.429]                 ...future.makeSendCondition <- base::local({
[16:06:10.429]                   sendCondition <- NULL
[16:06:10.429]                   function(frame = 1L) {
[16:06:10.429]                     if (is.function(sendCondition)) 
[16:06:10.429]                       return(sendCondition)
[16:06:10.429]                     ns <- getNamespace("parallel")
[16:06:10.429]                     if (exists("sendData", mode = "function", 
[16:06:10.429]                       envir = ns)) {
[16:06:10.429]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:10.429]                         envir = ns)
[16:06:10.429]                       envir <- sys.frame(frame)
[16:06:10.429]                       master <- NULL
[16:06:10.429]                       while (!identical(envir, .GlobalEnv) && 
[16:06:10.429]                         !identical(envir, emptyenv())) {
[16:06:10.429]                         if (exists("master", mode = "list", envir = envir, 
[16:06:10.429]                           inherits = FALSE)) {
[16:06:10.429]                           master <- get("master", mode = "list", 
[16:06:10.429]                             envir = envir, inherits = FALSE)
[16:06:10.429]                           if (inherits(master, c("SOCKnode", 
[16:06:10.429]                             "SOCK0node"))) {
[16:06:10.429]                             sendCondition <<- function(cond) {
[16:06:10.429]                               data <- list(type = "VALUE", value = cond, 
[16:06:10.429]                                 success = TRUE)
[16:06:10.429]                               parallel_sendData(master, data)
[16:06:10.429]                             }
[16:06:10.429]                             return(sendCondition)
[16:06:10.429]                           }
[16:06:10.429]                         }
[16:06:10.429]                         frame <- frame + 1L
[16:06:10.429]                         envir <- sys.frame(frame)
[16:06:10.429]                       }
[16:06:10.429]                     }
[16:06:10.429]                     sendCondition <<- function(cond) NULL
[16:06:10.429]                   }
[16:06:10.429]                 })
[16:06:10.429]                 withCallingHandlers({
[16:06:10.429]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:10.429]                 }, immediateCondition = function(cond) {
[16:06:10.429]                   sendCondition <- ...future.makeSendCondition()
[16:06:10.429]                   sendCondition(cond)
[16:06:10.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.429]                   {
[16:06:10.429]                     inherits <- base::inherits
[16:06:10.429]                     invokeRestart <- base::invokeRestart
[16:06:10.429]                     is.null <- base::is.null
[16:06:10.429]                     muffled <- FALSE
[16:06:10.429]                     if (inherits(cond, "message")) {
[16:06:10.429]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:10.429]                       if (muffled) 
[16:06:10.429]                         invokeRestart("muffleMessage")
[16:06:10.429]                     }
[16:06:10.429]                     else if (inherits(cond, "warning")) {
[16:06:10.429]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:10.429]                       if (muffled) 
[16:06:10.429]                         invokeRestart("muffleWarning")
[16:06:10.429]                     }
[16:06:10.429]                     else if (inherits(cond, "condition")) {
[16:06:10.429]                       if (!is.null(pattern)) {
[16:06:10.429]                         computeRestarts <- base::computeRestarts
[16:06:10.429]                         grepl <- base::grepl
[16:06:10.429]                         restarts <- computeRestarts(cond)
[16:06:10.429]                         for (restart in restarts) {
[16:06:10.429]                           name <- restart$name
[16:06:10.429]                           if (is.null(name)) 
[16:06:10.429]                             next
[16:06:10.429]                           if (!grepl(pattern, name)) 
[16:06:10.429]                             next
[16:06:10.429]                           invokeRestart(restart)
[16:06:10.429]                           muffled <- TRUE
[16:06:10.429]                           break
[16:06:10.429]                         }
[16:06:10.429]                       }
[16:06:10.429]                     }
[16:06:10.429]                     invisible(muffled)
[16:06:10.429]                   }
[16:06:10.429]                   muffleCondition(cond)
[16:06:10.429]                 })
[16:06:10.429]             }))
[16:06:10.429]             future::FutureResult(value = ...future.value$value, 
[16:06:10.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:10.429]                   ...future.rng), globalenv = if (FALSE) 
[16:06:10.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:10.429]                     ...future.globalenv.names))
[16:06:10.429]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:10.429]         }, condition = base::local({
[16:06:10.429]             c <- base::c
[16:06:10.429]             inherits <- base::inherits
[16:06:10.429]             invokeRestart <- base::invokeRestart
[16:06:10.429]             length <- base::length
[16:06:10.429]             list <- base::list
[16:06:10.429]             seq.int <- base::seq.int
[16:06:10.429]             signalCondition <- base::signalCondition
[16:06:10.429]             sys.calls <- base::sys.calls
[16:06:10.429]             `[[` <- base::`[[`
[16:06:10.429]             `+` <- base::`+`
[16:06:10.429]             `<<-` <- base::`<<-`
[16:06:10.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:10.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:10.429]                   3L)]
[16:06:10.429]             }
[16:06:10.429]             function(cond) {
[16:06:10.429]                 is_error <- inherits(cond, "error")
[16:06:10.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:10.429]                   NULL)
[16:06:10.429]                 if (is_error) {
[16:06:10.429]                   sessionInformation <- function() {
[16:06:10.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:10.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:10.429]                       search = base::search(), system = base::Sys.info())
[16:06:10.429]                   }
[16:06:10.429]                   ...future.conditions[[length(...future.conditions) + 
[16:06:10.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:10.429]                     cond$call), session = sessionInformation(), 
[16:06:10.429]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:10.429]                   signalCondition(cond)
[16:06:10.429]                 }
[16:06:10.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:10.429]                 "immediateCondition"))) {
[16:06:10.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:10.429]                   ...future.conditions[[length(...future.conditions) + 
[16:06:10.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:10.429]                   if (TRUE && !signal) {
[16:06:10.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.429]                     {
[16:06:10.429]                       inherits <- base::inherits
[16:06:10.429]                       invokeRestart <- base::invokeRestart
[16:06:10.429]                       is.null <- base::is.null
[16:06:10.429]                       muffled <- FALSE
[16:06:10.429]                       if (inherits(cond, "message")) {
[16:06:10.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:10.429]                         if (muffled) 
[16:06:10.429]                           invokeRestart("muffleMessage")
[16:06:10.429]                       }
[16:06:10.429]                       else if (inherits(cond, "warning")) {
[16:06:10.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:10.429]                         if (muffled) 
[16:06:10.429]                           invokeRestart("muffleWarning")
[16:06:10.429]                       }
[16:06:10.429]                       else if (inherits(cond, "condition")) {
[16:06:10.429]                         if (!is.null(pattern)) {
[16:06:10.429]                           computeRestarts <- base::computeRestarts
[16:06:10.429]                           grepl <- base::grepl
[16:06:10.429]                           restarts <- computeRestarts(cond)
[16:06:10.429]                           for (restart in restarts) {
[16:06:10.429]                             name <- restart$name
[16:06:10.429]                             if (is.null(name)) 
[16:06:10.429]                               next
[16:06:10.429]                             if (!grepl(pattern, name)) 
[16:06:10.429]                               next
[16:06:10.429]                             invokeRestart(restart)
[16:06:10.429]                             muffled <- TRUE
[16:06:10.429]                             break
[16:06:10.429]                           }
[16:06:10.429]                         }
[16:06:10.429]                       }
[16:06:10.429]                       invisible(muffled)
[16:06:10.429]                     }
[16:06:10.429]                     muffleCondition(cond, pattern = "^muffle")
[16:06:10.429]                   }
[16:06:10.429]                 }
[16:06:10.429]                 else {
[16:06:10.429]                   if (TRUE) {
[16:06:10.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.429]                     {
[16:06:10.429]                       inherits <- base::inherits
[16:06:10.429]                       invokeRestart <- base::invokeRestart
[16:06:10.429]                       is.null <- base::is.null
[16:06:10.429]                       muffled <- FALSE
[16:06:10.429]                       if (inherits(cond, "message")) {
[16:06:10.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:10.429]                         if (muffled) 
[16:06:10.429]                           invokeRestart("muffleMessage")
[16:06:10.429]                       }
[16:06:10.429]                       else if (inherits(cond, "warning")) {
[16:06:10.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:10.429]                         if (muffled) 
[16:06:10.429]                           invokeRestart("muffleWarning")
[16:06:10.429]                       }
[16:06:10.429]                       else if (inherits(cond, "condition")) {
[16:06:10.429]                         if (!is.null(pattern)) {
[16:06:10.429]                           computeRestarts <- base::computeRestarts
[16:06:10.429]                           grepl <- base::grepl
[16:06:10.429]                           restarts <- computeRestarts(cond)
[16:06:10.429]                           for (restart in restarts) {
[16:06:10.429]                             name <- restart$name
[16:06:10.429]                             if (is.null(name)) 
[16:06:10.429]                               next
[16:06:10.429]                             if (!grepl(pattern, name)) 
[16:06:10.429]                               next
[16:06:10.429]                             invokeRestart(restart)
[16:06:10.429]                             muffled <- TRUE
[16:06:10.429]                             break
[16:06:10.429]                           }
[16:06:10.429]                         }
[16:06:10.429]                       }
[16:06:10.429]                       invisible(muffled)
[16:06:10.429]                     }
[16:06:10.429]                     muffleCondition(cond, pattern = "^muffle")
[16:06:10.429]                   }
[16:06:10.429]                 }
[16:06:10.429]             }
[16:06:10.429]         }))
[16:06:10.429]     }, error = function(ex) {
[16:06:10.429]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:10.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:10.429]                 ...future.rng), started = ...future.startTime, 
[16:06:10.429]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:10.429]             version = "1.8"), class = "FutureResult")
[16:06:10.429]     }, finally = {
[16:06:10.429]         if (!identical(...future.workdir, getwd())) 
[16:06:10.429]             setwd(...future.workdir)
[16:06:10.429]         {
[16:06:10.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:10.429]                 ...future.oldOptions$nwarnings <- NULL
[16:06:10.429]             }
[16:06:10.429]             base::options(...future.oldOptions)
[16:06:10.429]             if (.Platform$OS.type == "windows") {
[16:06:10.429]                 old_names <- names(...future.oldEnvVars)
[16:06:10.429]                 envs <- base::Sys.getenv()
[16:06:10.429]                 names <- names(envs)
[16:06:10.429]                 common <- intersect(names, old_names)
[16:06:10.429]                 added <- setdiff(names, old_names)
[16:06:10.429]                 removed <- setdiff(old_names, names)
[16:06:10.429]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:10.429]                   envs[common]]
[16:06:10.429]                 NAMES <- toupper(changed)
[16:06:10.429]                 args <- list()
[16:06:10.429]                 for (kk in seq_along(NAMES)) {
[16:06:10.429]                   name <- changed[[kk]]
[16:06:10.429]                   NAME <- NAMES[[kk]]
[16:06:10.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.429]                     next
[16:06:10.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:10.429]                 }
[16:06:10.429]                 NAMES <- toupper(added)
[16:06:10.429]                 for (kk in seq_along(NAMES)) {
[16:06:10.429]                   name <- added[[kk]]
[16:06:10.429]                   NAME <- NAMES[[kk]]
[16:06:10.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.429]                     next
[16:06:10.429]                   args[[name]] <- ""
[16:06:10.429]                 }
[16:06:10.429]                 NAMES <- toupper(removed)
[16:06:10.429]                 for (kk in seq_along(NAMES)) {
[16:06:10.429]                   name <- removed[[kk]]
[16:06:10.429]                   NAME <- NAMES[[kk]]
[16:06:10.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.429]                     next
[16:06:10.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:10.429]                 }
[16:06:10.429]                 if (length(args) > 0) 
[16:06:10.429]                   base::do.call(base::Sys.setenv, args = args)
[16:06:10.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:10.429]             }
[16:06:10.429]             else {
[16:06:10.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:10.429]             }
[16:06:10.429]             {
[16:06:10.429]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:10.429]                   0L) {
[16:06:10.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:10.429]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:10.429]                   base::options(opts)
[16:06:10.429]                 }
[16:06:10.429]                 {
[16:06:10.429]                   {
[16:06:10.429]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:10.429]                     NULL
[16:06:10.429]                   }
[16:06:10.429]                   options(future.plan = NULL)
[16:06:10.429]                   if (is.na(NA_character_)) 
[16:06:10.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:10.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:10.429]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:10.429]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:10.429]                     envir = parent.frame()) 
[16:06:10.429]                   {
[16:06:10.429]                     if (is.function(workers)) 
[16:06:10.429]                       workers <- workers()
[16:06:10.429]                     workers <- structure(as.integer(workers), 
[16:06:10.429]                       class = class(workers))
[16:06:10.429]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:10.429]                       workers >= 1)
[16:06:10.429]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:10.429]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:10.429]                     }
[16:06:10.429]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:10.429]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:10.429]                       envir = envir)
[16:06:10.429]                     if (!future$lazy) 
[16:06:10.429]                       future <- run(future)
[16:06:10.429]                     invisible(future)
[16:06:10.429]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:10.429]                 }
[16:06:10.429]             }
[16:06:10.429]         }
[16:06:10.429]     })
[16:06:10.429]     if (TRUE) {
[16:06:10.429]         base::sink(type = "output", split = FALSE)
[16:06:10.429]         if (TRUE) {
[16:06:10.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:10.429]         }
[16:06:10.429]         else {
[16:06:10.429]             ...future.result["stdout"] <- base::list(NULL)
[16:06:10.429]         }
[16:06:10.429]         base::close(...future.stdout)
[16:06:10.429]         ...future.stdout <- NULL
[16:06:10.429]     }
[16:06:10.429]     ...future.result$conditions <- ...future.conditions
[16:06:10.429]     ...future.result$finished <- base::Sys.time()
[16:06:10.429]     ...future.result
[16:06:10.429] }
[16:06:10.432] MultisessionFuture started
[16:06:10.432] - Launch lazy future ... done
[16:06:10.432] run() for ‘MultisessionFuture’ ... done
[16:06:10.480] receiveMessageFromWorker() for ClusterFuture ...
[16:06:10.480] - Validating connection of MultisessionFuture
[16:06:10.481] - received message: FutureResult
[16:06:10.481] - Received FutureResult
[16:06:10.481] - Erased future from FutureRegistry
[16:06:10.481] result() for ClusterFuture ...
[16:06:10.481] - result already collected: FutureResult
[16:06:10.481] result() for ClusterFuture ... done
[16:06:10.481] signalConditions() ...
[16:06:10.481]  - include = ‘immediateCondition’
[16:06:10.482]  - exclude = 
[16:06:10.482]  - resignal = FALSE
[16:06:10.482]  - Number of conditions: 1
[16:06:10.482] signalConditions() ... done
[16:06:10.482] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:10.482] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[16:06:10.482] getGlobalsAndPackages() ...
[16:06:10.482] Searching for globals...
[16:06:10.484] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:10.484] Searching for globals ... DONE
[16:06:10.484] Resolving globals: FALSE
[16:06:10.484] 
[16:06:10.484] 
[16:06:10.484] getGlobalsAndPackages() ... DONE
[16:06:10.485] run() for ‘Future’ ...
[16:06:10.485] - state: ‘created’
[16:06:10.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:10.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:10.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:10.499]   - Field: ‘node’
[16:06:10.499]   - Field: ‘label’
[16:06:10.499]   - Field: ‘local’
[16:06:10.499]   - Field: ‘owner’
[16:06:10.499]   - Field: ‘envir’
[16:06:10.499]   - Field: ‘workers’
[16:06:10.499]   - Field: ‘packages’
[16:06:10.500]   - Field: ‘gc’
[16:06:10.500]   - Field: ‘conditions’
[16:06:10.500]   - Field: ‘persistent’
[16:06:10.500]   - Field: ‘expr’
[16:06:10.500]   - Field: ‘uuid’
[16:06:10.500]   - Field: ‘seed’
[16:06:10.500]   - Field: ‘version’
[16:06:10.500]   - Field: ‘result’
[16:06:10.500]   - Field: ‘asynchronous’
[16:06:10.500]   - Field: ‘calls’
[16:06:10.500]   - Field: ‘globals’
[16:06:10.501]   - Field: ‘stdout’
[16:06:10.501]   - Field: ‘earlySignal’
[16:06:10.501]   - Field: ‘lazy’
[16:06:10.501]   - Field: ‘state’
[16:06:10.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:10.501] - Launch lazy future ...
[16:06:10.501] Packages needed by the future expression (n = 0): <none>
[16:06:10.501] Packages needed by future strategies (n = 0): <none>
[16:06:10.502] {
[16:06:10.502]     {
[16:06:10.502]         {
[16:06:10.502]             ...future.startTime <- base::Sys.time()
[16:06:10.502]             {
[16:06:10.502]                 {
[16:06:10.502]                   {
[16:06:10.502]                     {
[16:06:10.502]                       base::local({
[16:06:10.502]                         has_future <- base::requireNamespace("future", 
[16:06:10.502]                           quietly = TRUE)
[16:06:10.502]                         if (has_future) {
[16:06:10.502]                           ns <- base::getNamespace("future")
[16:06:10.502]                           version <- ns[[".package"]][["version"]]
[16:06:10.502]                           if (is.null(version)) 
[16:06:10.502]                             version <- utils::packageVersion("future")
[16:06:10.502]                         }
[16:06:10.502]                         else {
[16:06:10.502]                           version <- NULL
[16:06:10.502]                         }
[16:06:10.502]                         if (!has_future || version < "1.8.0") {
[16:06:10.502]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:10.502]                             "", base::R.version$version.string), 
[16:06:10.502]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:10.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:10.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:10.502]                               "release", "version")], collapse = " "), 
[16:06:10.502]                             hostname = base::Sys.info()[["nodename"]])
[16:06:10.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:10.502]                             info)
[16:06:10.502]                           info <- base::paste(info, collapse = "; ")
[16:06:10.502]                           if (!has_future) {
[16:06:10.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:10.502]                               info)
[16:06:10.502]                           }
[16:06:10.502]                           else {
[16:06:10.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:10.502]                               info, version)
[16:06:10.502]                           }
[16:06:10.502]                           base::stop(msg)
[16:06:10.502]                         }
[16:06:10.502]                       })
[16:06:10.502]                     }
[16:06:10.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:10.502]                     base::options(mc.cores = 1L)
[16:06:10.502]                   }
[16:06:10.502]                   options(future.plan = NULL)
[16:06:10.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:10.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:10.502]                 }
[16:06:10.502]                 ...future.workdir <- getwd()
[16:06:10.502]             }
[16:06:10.502]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:10.502]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:10.502]         }
[16:06:10.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:10.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:10.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:10.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:10.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:10.502]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:10.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:10.502]             base::names(...future.oldOptions))
[16:06:10.502]     }
[16:06:10.502]     if (FALSE) {
[16:06:10.502]     }
[16:06:10.502]     else {
[16:06:10.502]         if (TRUE) {
[16:06:10.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:10.502]                 open = "w")
[16:06:10.502]         }
[16:06:10.502]         else {
[16:06:10.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:10.502]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:10.502]         }
[16:06:10.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:10.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:10.502]             base::sink(type = "output", split = FALSE)
[16:06:10.502]             base::close(...future.stdout)
[16:06:10.502]         }, add = TRUE)
[16:06:10.502]     }
[16:06:10.502]     ...future.frame <- base::sys.nframe()
[16:06:10.502]     ...future.conditions <- base::list()
[16:06:10.502]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:10.502]     if (FALSE) {
[16:06:10.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:10.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:10.502]     }
[16:06:10.502]     ...future.result <- base::tryCatch({
[16:06:10.502]         base::withCallingHandlers({
[16:06:10.502]             ...future.value <- base::withVisible(base::local({
[16:06:10.502]                 ...future.makeSendCondition <- base::local({
[16:06:10.502]                   sendCondition <- NULL
[16:06:10.502]                   function(frame = 1L) {
[16:06:10.502]                     if (is.function(sendCondition)) 
[16:06:10.502]                       return(sendCondition)
[16:06:10.502]                     ns <- getNamespace("parallel")
[16:06:10.502]                     if (exists("sendData", mode = "function", 
[16:06:10.502]                       envir = ns)) {
[16:06:10.502]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:10.502]                         envir = ns)
[16:06:10.502]                       envir <- sys.frame(frame)
[16:06:10.502]                       master <- NULL
[16:06:10.502]                       while (!identical(envir, .GlobalEnv) && 
[16:06:10.502]                         !identical(envir, emptyenv())) {
[16:06:10.502]                         if (exists("master", mode = "list", envir = envir, 
[16:06:10.502]                           inherits = FALSE)) {
[16:06:10.502]                           master <- get("master", mode = "list", 
[16:06:10.502]                             envir = envir, inherits = FALSE)
[16:06:10.502]                           if (inherits(master, c("SOCKnode", 
[16:06:10.502]                             "SOCK0node"))) {
[16:06:10.502]                             sendCondition <<- function(cond) {
[16:06:10.502]                               data <- list(type = "VALUE", value = cond, 
[16:06:10.502]                                 success = TRUE)
[16:06:10.502]                               parallel_sendData(master, data)
[16:06:10.502]                             }
[16:06:10.502]                             return(sendCondition)
[16:06:10.502]                           }
[16:06:10.502]                         }
[16:06:10.502]                         frame <- frame + 1L
[16:06:10.502]                         envir <- sys.frame(frame)
[16:06:10.502]                       }
[16:06:10.502]                     }
[16:06:10.502]                     sendCondition <<- function(cond) NULL
[16:06:10.502]                   }
[16:06:10.502]                 })
[16:06:10.502]                 withCallingHandlers({
[16:06:10.502]                   {
[16:06:10.502]                     Sys.sleep(0.5)
[16:06:10.502]                     list(a = 1, b = 42L)
[16:06:10.502]                   }
[16:06:10.502]                 }, immediateCondition = function(cond) {
[16:06:10.502]                   sendCondition <- ...future.makeSendCondition()
[16:06:10.502]                   sendCondition(cond)
[16:06:10.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.502]                   {
[16:06:10.502]                     inherits <- base::inherits
[16:06:10.502]                     invokeRestart <- base::invokeRestart
[16:06:10.502]                     is.null <- base::is.null
[16:06:10.502]                     muffled <- FALSE
[16:06:10.502]                     if (inherits(cond, "message")) {
[16:06:10.502]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:10.502]                       if (muffled) 
[16:06:10.502]                         invokeRestart("muffleMessage")
[16:06:10.502]                     }
[16:06:10.502]                     else if (inherits(cond, "warning")) {
[16:06:10.502]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:10.502]                       if (muffled) 
[16:06:10.502]                         invokeRestart("muffleWarning")
[16:06:10.502]                     }
[16:06:10.502]                     else if (inherits(cond, "condition")) {
[16:06:10.502]                       if (!is.null(pattern)) {
[16:06:10.502]                         computeRestarts <- base::computeRestarts
[16:06:10.502]                         grepl <- base::grepl
[16:06:10.502]                         restarts <- computeRestarts(cond)
[16:06:10.502]                         for (restart in restarts) {
[16:06:10.502]                           name <- restart$name
[16:06:10.502]                           if (is.null(name)) 
[16:06:10.502]                             next
[16:06:10.502]                           if (!grepl(pattern, name)) 
[16:06:10.502]                             next
[16:06:10.502]                           invokeRestart(restart)
[16:06:10.502]                           muffled <- TRUE
[16:06:10.502]                           break
[16:06:10.502]                         }
[16:06:10.502]                       }
[16:06:10.502]                     }
[16:06:10.502]                     invisible(muffled)
[16:06:10.502]                   }
[16:06:10.502]                   muffleCondition(cond)
[16:06:10.502]                 })
[16:06:10.502]             }))
[16:06:10.502]             future::FutureResult(value = ...future.value$value, 
[16:06:10.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:10.502]                   ...future.rng), globalenv = if (FALSE) 
[16:06:10.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:10.502]                     ...future.globalenv.names))
[16:06:10.502]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:10.502]         }, condition = base::local({
[16:06:10.502]             c <- base::c
[16:06:10.502]             inherits <- base::inherits
[16:06:10.502]             invokeRestart <- base::invokeRestart
[16:06:10.502]             length <- base::length
[16:06:10.502]             list <- base::list
[16:06:10.502]             seq.int <- base::seq.int
[16:06:10.502]             signalCondition <- base::signalCondition
[16:06:10.502]             sys.calls <- base::sys.calls
[16:06:10.502]             `[[` <- base::`[[`
[16:06:10.502]             `+` <- base::`+`
[16:06:10.502]             `<<-` <- base::`<<-`
[16:06:10.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:10.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:10.502]                   3L)]
[16:06:10.502]             }
[16:06:10.502]             function(cond) {
[16:06:10.502]                 is_error <- inherits(cond, "error")
[16:06:10.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:10.502]                   NULL)
[16:06:10.502]                 if (is_error) {
[16:06:10.502]                   sessionInformation <- function() {
[16:06:10.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:10.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:10.502]                       search = base::search(), system = base::Sys.info())
[16:06:10.502]                   }
[16:06:10.502]                   ...future.conditions[[length(...future.conditions) + 
[16:06:10.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:10.502]                     cond$call), session = sessionInformation(), 
[16:06:10.502]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:10.502]                   signalCondition(cond)
[16:06:10.502]                 }
[16:06:10.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:10.502]                 "immediateCondition"))) {
[16:06:10.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:10.502]                   ...future.conditions[[length(...future.conditions) + 
[16:06:10.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:10.502]                   if (TRUE && !signal) {
[16:06:10.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.502]                     {
[16:06:10.502]                       inherits <- base::inherits
[16:06:10.502]                       invokeRestart <- base::invokeRestart
[16:06:10.502]                       is.null <- base::is.null
[16:06:10.502]                       muffled <- FALSE
[16:06:10.502]                       if (inherits(cond, "message")) {
[16:06:10.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:10.502]                         if (muffled) 
[16:06:10.502]                           invokeRestart("muffleMessage")
[16:06:10.502]                       }
[16:06:10.502]                       else if (inherits(cond, "warning")) {
[16:06:10.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:10.502]                         if (muffled) 
[16:06:10.502]                           invokeRestart("muffleWarning")
[16:06:10.502]                       }
[16:06:10.502]                       else if (inherits(cond, "condition")) {
[16:06:10.502]                         if (!is.null(pattern)) {
[16:06:10.502]                           computeRestarts <- base::computeRestarts
[16:06:10.502]                           grepl <- base::grepl
[16:06:10.502]                           restarts <- computeRestarts(cond)
[16:06:10.502]                           for (restart in restarts) {
[16:06:10.502]                             name <- restart$name
[16:06:10.502]                             if (is.null(name)) 
[16:06:10.502]                               next
[16:06:10.502]                             if (!grepl(pattern, name)) 
[16:06:10.502]                               next
[16:06:10.502]                             invokeRestart(restart)
[16:06:10.502]                             muffled <- TRUE
[16:06:10.502]                             break
[16:06:10.502]                           }
[16:06:10.502]                         }
[16:06:10.502]                       }
[16:06:10.502]                       invisible(muffled)
[16:06:10.502]                     }
[16:06:10.502]                     muffleCondition(cond, pattern = "^muffle")
[16:06:10.502]                   }
[16:06:10.502]                 }
[16:06:10.502]                 else {
[16:06:10.502]                   if (TRUE) {
[16:06:10.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:10.502]                     {
[16:06:10.502]                       inherits <- base::inherits
[16:06:10.502]                       invokeRestart <- base::invokeRestart
[16:06:10.502]                       is.null <- base::is.null
[16:06:10.502]                       muffled <- FALSE
[16:06:10.502]                       if (inherits(cond, "message")) {
[16:06:10.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:10.502]                         if (muffled) 
[16:06:10.502]                           invokeRestart("muffleMessage")
[16:06:10.502]                       }
[16:06:10.502]                       else if (inherits(cond, "warning")) {
[16:06:10.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:10.502]                         if (muffled) 
[16:06:10.502]                           invokeRestart("muffleWarning")
[16:06:10.502]                       }
[16:06:10.502]                       else if (inherits(cond, "condition")) {
[16:06:10.502]                         if (!is.null(pattern)) {
[16:06:10.502]                           computeRestarts <- base::computeRestarts
[16:06:10.502]                           grepl <- base::grepl
[16:06:10.502]                           restarts <- computeRestarts(cond)
[16:06:10.502]                           for (restart in restarts) {
[16:06:10.502]                             name <- restart$name
[16:06:10.502]                             if (is.null(name)) 
[16:06:10.502]                               next
[16:06:10.502]                             if (!grepl(pattern, name)) 
[16:06:10.502]                               next
[16:06:10.502]                             invokeRestart(restart)
[16:06:10.502]                             muffled <- TRUE
[16:06:10.502]                             break
[16:06:10.502]                           }
[16:06:10.502]                         }
[16:06:10.502]                       }
[16:06:10.502]                       invisible(muffled)
[16:06:10.502]                     }
[16:06:10.502]                     muffleCondition(cond, pattern = "^muffle")
[16:06:10.502]                   }
[16:06:10.502]                 }
[16:06:10.502]             }
[16:06:10.502]         }))
[16:06:10.502]     }, error = function(ex) {
[16:06:10.502]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:10.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:10.502]                 ...future.rng), started = ...future.startTime, 
[16:06:10.502]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:10.502]             version = "1.8"), class = "FutureResult")
[16:06:10.502]     }, finally = {
[16:06:10.502]         if (!identical(...future.workdir, getwd())) 
[16:06:10.502]             setwd(...future.workdir)
[16:06:10.502]         {
[16:06:10.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:10.502]                 ...future.oldOptions$nwarnings <- NULL
[16:06:10.502]             }
[16:06:10.502]             base::options(...future.oldOptions)
[16:06:10.502]             if (.Platform$OS.type == "windows") {
[16:06:10.502]                 old_names <- names(...future.oldEnvVars)
[16:06:10.502]                 envs <- base::Sys.getenv()
[16:06:10.502]                 names <- names(envs)
[16:06:10.502]                 common <- intersect(names, old_names)
[16:06:10.502]                 added <- setdiff(names, old_names)
[16:06:10.502]                 removed <- setdiff(old_names, names)
[16:06:10.502]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:10.502]                   envs[common]]
[16:06:10.502]                 NAMES <- toupper(changed)
[16:06:10.502]                 args <- list()
[16:06:10.502]                 for (kk in seq_along(NAMES)) {
[16:06:10.502]                   name <- changed[[kk]]
[16:06:10.502]                   NAME <- NAMES[[kk]]
[16:06:10.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.502]                     next
[16:06:10.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:10.502]                 }
[16:06:10.502]                 NAMES <- toupper(added)
[16:06:10.502]                 for (kk in seq_along(NAMES)) {
[16:06:10.502]                   name <- added[[kk]]
[16:06:10.502]                   NAME <- NAMES[[kk]]
[16:06:10.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.502]                     next
[16:06:10.502]                   args[[name]] <- ""
[16:06:10.502]                 }
[16:06:10.502]                 NAMES <- toupper(removed)
[16:06:10.502]                 for (kk in seq_along(NAMES)) {
[16:06:10.502]                   name <- removed[[kk]]
[16:06:10.502]                   NAME <- NAMES[[kk]]
[16:06:10.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:10.502]                     next
[16:06:10.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:10.502]                 }
[16:06:10.502]                 if (length(args) > 0) 
[16:06:10.502]                   base::do.call(base::Sys.setenv, args = args)
[16:06:10.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:10.502]             }
[16:06:10.502]             else {
[16:06:10.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:10.502]             }
[16:06:10.502]             {
[16:06:10.502]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:10.502]                   0L) {
[16:06:10.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:10.502]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:10.502]                   base::options(opts)
[16:06:10.502]                 }
[16:06:10.502]                 {
[16:06:10.502]                   {
[16:06:10.502]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:10.502]                     NULL
[16:06:10.502]                   }
[16:06:10.502]                   options(future.plan = NULL)
[16:06:10.502]                   if (is.na(NA_character_)) 
[16:06:10.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:10.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:10.502]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:10.502]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:10.502]                     envir = parent.frame()) 
[16:06:10.502]                   {
[16:06:10.502]                     if (is.function(workers)) 
[16:06:10.502]                       workers <- workers()
[16:06:10.502]                     workers <- structure(as.integer(workers), 
[16:06:10.502]                       class = class(workers))
[16:06:10.502]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:10.502]                       workers >= 1)
[16:06:10.502]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:10.502]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:10.502]                     }
[16:06:10.502]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:10.502]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:10.502]                       envir = envir)
[16:06:10.502]                     if (!future$lazy) 
[16:06:10.502]                       future <- run(future)
[16:06:10.502]                     invisible(future)
[16:06:10.502]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:10.502]                 }
[16:06:10.502]             }
[16:06:10.502]         }
[16:06:10.502]     })
[16:06:10.502]     if (TRUE) {
[16:06:10.502]         base::sink(type = "output", split = FALSE)
[16:06:10.502]         if (TRUE) {
[16:06:10.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:10.502]         }
[16:06:10.502]         else {
[16:06:10.502]             ...future.result["stdout"] <- base::list(NULL)
[16:06:10.502]         }
[16:06:10.502]         base::close(...future.stdout)
[16:06:10.502]         ...future.stdout <- NULL
[16:06:10.502]     }
[16:06:10.502]     ...future.result$conditions <- ...future.conditions
[16:06:10.502]     ...future.result$finished <- base::Sys.time()
[16:06:10.502]     ...future.result
[16:06:10.502] }
[16:06:10.505] MultisessionFuture started
[16:06:10.505] - Launch lazy future ... done
[16:06:10.505] run() for ‘MultisessionFuture’ ... done
[16:06:11.053] receiveMessageFromWorker() for ClusterFuture ...
[16:06:11.053] - Validating connection of MultisessionFuture
[16:06:11.053] - received message: FutureResult
[16:06:11.053] - Received FutureResult
[16:06:11.054] - Erased future from FutureRegistry
[16:06:11.054] result() for ClusterFuture ...
[16:06:11.054] - result already collected: FutureResult
[16:06:11.054] result() for ClusterFuture ... done
[16:06:11.054] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:11.054] resolve() on list ...
[16:06:11.054]  recursive: 0
[16:06:11.054]  length: 2
[16:06:11.054]  elements: ‘a’, ‘b’
[16:06:11.055]  length: 1 (resolved future 1)
[16:06:11.055]  length: 0 (resolved future 2)
[16:06:11.055] resolve() on list ... DONE
[16:06:11.055] A MultisessionFuture was resolved (and resolved itself)
[16:06:11.055] getGlobalsAndPackages() ...
[16:06:11.055] Searching for globals...
[16:06:11.056] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:11.056] Searching for globals ... DONE
[16:06:11.057] Resolving globals: FALSE
[16:06:11.057] 
[16:06:11.057] 
[16:06:11.057] getGlobalsAndPackages() ... DONE
[16:06:11.057] run() for ‘Future’ ...
[16:06:11.057] - state: ‘created’
[16:06:11.058] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:11.072] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:11.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:11.072]   - Field: ‘node’
[16:06:11.072]   - Field: ‘label’
[16:06:11.072]   - Field: ‘local’
[16:06:11.072]   - Field: ‘owner’
[16:06:11.072]   - Field: ‘envir’
[16:06:11.072]   - Field: ‘workers’
[16:06:11.072]   - Field: ‘packages’
[16:06:11.073]   - Field: ‘gc’
[16:06:11.073]   - Field: ‘conditions’
[16:06:11.073]   - Field: ‘persistent’
[16:06:11.073]   - Field: ‘expr’
[16:06:11.073]   - Field: ‘uuid’
[16:06:11.073]   - Field: ‘seed’
[16:06:11.073]   - Field: ‘version’
[16:06:11.073]   - Field: ‘result’
[16:06:11.073]   - Field: ‘asynchronous’
[16:06:11.073]   - Field: ‘calls’
[16:06:11.073]   - Field: ‘globals’
[16:06:11.073]   - Field: ‘stdout’
[16:06:11.074]   - Field: ‘earlySignal’
[16:06:11.074]   - Field: ‘lazy’
[16:06:11.074]   - Field: ‘state’
[16:06:11.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:11.074] - Launch lazy future ...
[16:06:11.074] Packages needed by the future expression (n = 0): <none>
[16:06:11.074] Packages needed by future strategies (n = 0): <none>
[16:06:11.075] {
[16:06:11.075]     {
[16:06:11.075]         {
[16:06:11.075]             ...future.startTime <- base::Sys.time()
[16:06:11.075]             {
[16:06:11.075]                 {
[16:06:11.075]                   {
[16:06:11.075]                     {
[16:06:11.075]                       base::local({
[16:06:11.075]                         has_future <- base::requireNamespace("future", 
[16:06:11.075]                           quietly = TRUE)
[16:06:11.075]                         if (has_future) {
[16:06:11.075]                           ns <- base::getNamespace("future")
[16:06:11.075]                           version <- ns[[".package"]][["version"]]
[16:06:11.075]                           if (is.null(version)) 
[16:06:11.075]                             version <- utils::packageVersion("future")
[16:06:11.075]                         }
[16:06:11.075]                         else {
[16:06:11.075]                           version <- NULL
[16:06:11.075]                         }
[16:06:11.075]                         if (!has_future || version < "1.8.0") {
[16:06:11.075]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:11.075]                             "", base::R.version$version.string), 
[16:06:11.075]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:11.075]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:11.075]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:11.075]                               "release", "version")], collapse = " "), 
[16:06:11.075]                             hostname = base::Sys.info()[["nodename"]])
[16:06:11.075]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:11.075]                             info)
[16:06:11.075]                           info <- base::paste(info, collapse = "; ")
[16:06:11.075]                           if (!has_future) {
[16:06:11.075]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:11.075]                               info)
[16:06:11.075]                           }
[16:06:11.075]                           else {
[16:06:11.075]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:11.075]                               info, version)
[16:06:11.075]                           }
[16:06:11.075]                           base::stop(msg)
[16:06:11.075]                         }
[16:06:11.075]                       })
[16:06:11.075]                     }
[16:06:11.075]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:11.075]                     base::options(mc.cores = 1L)
[16:06:11.075]                   }
[16:06:11.075]                   options(future.plan = NULL)
[16:06:11.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:11.075]                 }
[16:06:11.075]                 ...future.workdir <- getwd()
[16:06:11.075]             }
[16:06:11.075]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:11.075]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:11.075]         }
[16:06:11.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:11.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:11.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:11.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:11.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:11.075]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:11.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:11.075]             base::names(...future.oldOptions))
[16:06:11.075]     }
[16:06:11.075]     if (FALSE) {
[16:06:11.075]     }
[16:06:11.075]     else {
[16:06:11.075]         if (TRUE) {
[16:06:11.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:11.075]                 open = "w")
[16:06:11.075]         }
[16:06:11.075]         else {
[16:06:11.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:11.075]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:11.075]         }
[16:06:11.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:11.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:11.075]             base::sink(type = "output", split = FALSE)
[16:06:11.075]             base::close(...future.stdout)
[16:06:11.075]         }, add = TRUE)
[16:06:11.075]     }
[16:06:11.075]     ...future.frame <- base::sys.nframe()
[16:06:11.075]     ...future.conditions <- base::list()
[16:06:11.075]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:11.075]     if (FALSE) {
[16:06:11.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:11.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:11.075]     }
[16:06:11.075]     ...future.result <- base::tryCatch({
[16:06:11.075]         base::withCallingHandlers({
[16:06:11.075]             ...future.value <- base::withVisible(base::local({
[16:06:11.075]                 ...future.makeSendCondition <- base::local({
[16:06:11.075]                   sendCondition <- NULL
[16:06:11.075]                   function(frame = 1L) {
[16:06:11.075]                     if (is.function(sendCondition)) 
[16:06:11.075]                       return(sendCondition)
[16:06:11.075]                     ns <- getNamespace("parallel")
[16:06:11.075]                     if (exists("sendData", mode = "function", 
[16:06:11.075]                       envir = ns)) {
[16:06:11.075]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:11.075]                         envir = ns)
[16:06:11.075]                       envir <- sys.frame(frame)
[16:06:11.075]                       master <- NULL
[16:06:11.075]                       while (!identical(envir, .GlobalEnv) && 
[16:06:11.075]                         !identical(envir, emptyenv())) {
[16:06:11.075]                         if (exists("master", mode = "list", envir = envir, 
[16:06:11.075]                           inherits = FALSE)) {
[16:06:11.075]                           master <- get("master", mode = "list", 
[16:06:11.075]                             envir = envir, inherits = FALSE)
[16:06:11.075]                           if (inherits(master, c("SOCKnode", 
[16:06:11.075]                             "SOCK0node"))) {
[16:06:11.075]                             sendCondition <<- function(cond) {
[16:06:11.075]                               data <- list(type = "VALUE", value = cond, 
[16:06:11.075]                                 success = TRUE)
[16:06:11.075]                               parallel_sendData(master, data)
[16:06:11.075]                             }
[16:06:11.075]                             return(sendCondition)
[16:06:11.075]                           }
[16:06:11.075]                         }
[16:06:11.075]                         frame <- frame + 1L
[16:06:11.075]                         envir <- sys.frame(frame)
[16:06:11.075]                       }
[16:06:11.075]                     }
[16:06:11.075]                     sendCondition <<- function(cond) NULL
[16:06:11.075]                   }
[16:06:11.075]                 })
[16:06:11.075]                 withCallingHandlers({
[16:06:11.075]                   {
[16:06:11.075]                     Sys.sleep(0.5)
[16:06:11.075]                     list(a = 1, b = 42L)
[16:06:11.075]                   }
[16:06:11.075]                 }, immediateCondition = function(cond) {
[16:06:11.075]                   sendCondition <- ...future.makeSendCondition()
[16:06:11.075]                   sendCondition(cond)
[16:06:11.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.075]                   {
[16:06:11.075]                     inherits <- base::inherits
[16:06:11.075]                     invokeRestart <- base::invokeRestart
[16:06:11.075]                     is.null <- base::is.null
[16:06:11.075]                     muffled <- FALSE
[16:06:11.075]                     if (inherits(cond, "message")) {
[16:06:11.075]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:11.075]                       if (muffled) 
[16:06:11.075]                         invokeRestart("muffleMessage")
[16:06:11.075]                     }
[16:06:11.075]                     else if (inherits(cond, "warning")) {
[16:06:11.075]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:11.075]                       if (muffled) 
[16:06:11.075]                         invokeRestart("muffleWarning")
[16:06:11.075]                     }
[16:06:11.075]                     else if (inherits(cond, "condition")) {
[16:06:11.075]                       if (!is.null(pattern)) {
[16:06:11.075]                         computeRestarts <- base::computeRestarts
[16:06:11.075]                         grepl <- base::grepl
[16:06:11.075]                         restarts <- computeRestarts(cond)
[16:06:11.075]                         for (restart in restarts) {
[16:06:11.075]                           name <- restart$name
[16:06:11.075]                           if (is.null(name)) 
[16:06:11.075]                             next
[16:06:11.075]                           if (!grepl(pattern, name)) 
[16:06:11.075]                             next
[16:06:11.075]                           invokeRestart(restart)
[16:06:11.075]                           muffled <- TRUE
[16:06:11.075]                           break
[16:06:11.075]                         }
[16:06:11.075]                       }
[16:06:11.075]                     }
[16:06:11.075]                     invisible(muffled)
[16:06:11.075]                   }
[16:06:11.075]                   muffleCondition(cond)
[16:06:11.075]                 })
[16:06:11.075]             }))
[16:06:11.075]             future::FutureResult(value = ...future.value$value, 
[16:06:11.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.075]                   ...future.rng), globalenv = if (FALSE) 
[16:06:11.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:11.075]                     ...future.globalenv.names))
[16:06:11.075]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:11.075]         }, condition = base::local({
[16:06:11.075]             c <- base::c
[16:06:11.075]             inherits <- base::inherits
[16:06:11.075]             invokeRestart <- base::invokeRestart
[16:06:11.075]             length <- base::length
[16:06:11.075]             list <- base::list
[16:06:11.075]             seq.int <- base::seq.int
[16:06:11.075]             signalCondition <- base::signalCondition
[16:06:11.075]             sys.calls <- base::sys.calls
[16:06:11.075]             `[[` <- base::`[[`
[16:06:11.075]             `+` <- base::`+`
[16:06:11.075]             `<<-` <- base::`<<-`
[16:06:11.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:11.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:11.075]                   3L)]
[16:06:11.075]             }
[16:06:11.075]             function(cond) {
[16:06:11.075]                 is_error <- inherits(cond, "error")
[16:06:11.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:11.075]                   NULL)
[16:06:11.075]                 if (is_error) {
[16:06:11.075]                   sessionInformation <- function() {
[16:06:11.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:11.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:11.075]                       search = base::search(), system = base::Sys.info())
[16:06:11.075]                   }
[16:06:11.075]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:11.075]                     cond$call), session = sessionInformation(), 
[16:06:11.075]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:11.075]                   signalCondition(cond)
[16:06:11.075]                 }
[16:06:11.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:11.075]                 "immediateCondition"))) {
[16:06:11.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:11.075]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:11.075]                   if (TRUE && !signal) {
[16:06:11.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.075]                     {
[16:06:11.075]                       inherits <- base::inherits
[16:06:11.075]                       invokeRestart <- base::invokeRestart
[16:06:11.075]                       is.null <- base::is.null
[16:06:11.075]                       muffled <- FALSE
[16:06:11.075]                       if (inherits(cond, "message")) {
[16:06:11.075]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.075]                         if (muffled) 
[16:06:11.075]                           invokeRestart("muffleMessage")
[16:06:11.075]                       }
[16:06:11.075]                       else if (inherits(cond, "warning")) {
[16:06:11.075]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.075]                         if (muffled) 
[16:06:11.075]                           invokeRestart("muffleWarning")
[16:06:11.075]                       }
[16:06:11.075]                       else if (inherits(cond, "condition")) {
[16:06:11.075]                         if (!is.null(pattern)) {
[16:06:11.075]                           computeRestarts <- base::computeRestarts
[16:06:11.075]                           grepl <- base::grepl
[16:06:11.075]                           restarts <- computeRestarts(cond)
[16:06:11.075]                           for (restart in restarts) {
[16:06:11.075]                             name <- restart$name
[16:06:11.075]                             if (is.null(name)) 
[16:06:11.075]                               next
[16:06:11.075]                             if (!grepl(pattern, name)) 
[16:06:11.075]                               next
[16:06:11.075]                             invokeRestart(restart)
[16:06:11.075]                             muffled <- TRUE
[16:06:11.075]                             break
[16:06:11.075]                           }
[16:06:11.075]                         }
[16:06:11.075]                       }
[16:06:11.075]                       invisible(muffled)
[16:06:11.075]                     }
[16:06:11.075]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.075]                   }
[16:06:11.075]                 }
[16:06:11.075]                 else {
[16:06:11.075]                   if (TRUE) {
[16:06:11.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.075]                     {
[16:06:11.075]                       inherits <- base::inherits
[16:06:11.075]                       invokeRestart <- base::invokeRestart
[16:06:11.075]                       is.null <- base::is.null
[16:06:11.075]                       muffled <- FALSE
[16:06:11.075]                       if (inherits(cond, "message")) {
[16:06:11.075]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.075]                         if (muffled) 
[16:06:11.075]                           invokeRestart("muffleMessage")
[16:06:11.075]                       }
[16:06:11.075]                       else if (inherits(cond, "warning")) {
[16:06:11.075]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.075]                         if (muffled) 
[16:06:11.075]                           invokeRestart("muffleWarning")
[16:06:11.075]                       }
[16:06:11.075]                       else if (inherits(cond, "condition")) {
[16:06:11.075]                         if (!is.null(pattern)) {
[16:06:11.075]                           computeRestarts <- base::computeRestarts
[16:06:11.075]                           grepl <- base::grepl
[16:06:11.075]                           restarts <- computeRestarts(cond)
[16:06:11.075]                           for (restart in restarts) {
[16:06:11.075]                             name <- restart$name
[16:06:11.075]                             if (is.null(name)) 
[16:06:11.075]                               next
[16:06:11.075]                             if (!grepl(pattern, name)) 
[16:06:11.075]                               next
[16:06:11.075]                             invokeRestart(restart)
[16:06:11.075]                             muffled <- TRUE
[16:06:11.075]                             break
[16:06:11.075]                           }
[16:06:11.075]                         }
[16:06:11.075]                       }
[16:06:11.075]                       invisible(muffled)
[16:06:11.075]                     }
[16:06:11.075]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.075]                   }
[16:06:11.075]                 }
[16:06:11.075]             }
[16:06:11.075]         }))
[16:06:11.075]     }, error = function(ex) {
[16:06:11.075]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:11.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.075]                 ...future.rng), started = ...future.startTime, 
[16:06:11.075]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:11.075]             version = "1.8"), class = "FutureResult")
[16:06:11.075]     }, finally = {
[16:06:11.075]         if (!identical(...future.workdir, getwd())) 
[16:06:11.075]             setwd(...future.workdir)
[16:06:11.075]         {
[16:06:11.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:11.075]                 ...future.oldOptions$nwarnings <- NULL
[16:06:11.075]             }
[16:06:11.075]             base::options(...future.oldOptions)
[16:06:11.075]             if (.Platform$OS.type == "windows") {
[16:06:11.075]                 old_names <- names(...future.oldEnvVars)
[16:06:11.075]                 envs <- base::Sys.getenv()
[16:06:11.075]                 names <- names(envs)
[16:06:11.075]                 common <- intersect(names, old_names)
[16:06:11.075]                 added <- setdiff(names, old_names)
[16:06:11.075]                 removed <- setdiff(old_names, names)
[16:06:11.075]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:11.075]                   envs[common]]
[16:06:11.075]                 NAMES <- toupper(changed)
[16:06:11.075]                 args <- list()
[16:06:11.075]                 for (kk in seq_along(NAMES)) {
[16:06:11.075]                   name <- changed[[kk]]
[16:06:11.075]                   NAME <- NAMES[[kk]]
[16:06:11.075]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.075]                     next
[16:06:11.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.075]                 }
[16:06:11.075]                 NAMES <- toupper(added)
[16:06:11.075]                 for (kk in seq_along(NAMES)) {
[16:06:11.075]                   name <- added[[kk]]
[16:06:11.075]                   NAME <- NAMES[[kk]]
[16:06:11.075]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.075]                     next
[16:06:11.075]                   args[[name]] <- ""
[16:06:11.075]                 }
[16:06:11.075]                 NAMES <- toupper(removed)
[16:06:11.075]                 for (kk in seq_along(NAMES)) {
[16:06:11.075]                   name <- removed[[kk]]
[16:06:11.075]                   NAME <- NAMES[[kk]]
[16:06:11.075]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.075]                     next
[16:06:11.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.075]                 }
[16:06:11.075]                 if (length(args) > 0) 
[16:06:11.075]                   base::do.call(base::Sys.setenv, args = args)
[16:06:11.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:11.075]             }
[16:06:11.075]             else {
[16:06:11.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:11.075]             }
[16:06:11.075]             {
[16:06:11.075]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:11.075]                   0L) {
[16:06:11.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:11.075]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:11.075]                   base::options(opts)
[16:06:11.075]                 }
[16:06:11.075]                 {
[16:06:11.075]                   {
[16:06:11.075]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:11.075]                     NULL
[16:06:11.075]                   }
[16:06:11.075]                   options(future.plan = NULL)
[16:06:11.075]                   if (is.na(NA_character_)) 
[16:06:11.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:11.075]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:11.075]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:11.075]                     envir = parent.frame()) 
[16:06:11.075]                   {
[16:06:11.075]                     if (is.function(workers)) 
[16:06:11.075]                       workers <- workers()
[16:06:11.075]                     workers <- structure(as.integer(workers), 
[16:06:11.075]                       class = class(workers))
[16:06:11.075]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:11.075]                       workers >= 1)
[16:06:11.075]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:11.075]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:11.075]                     }
[16:06:11.075]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:11.075]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:11.075]                       envir = envir)
[16:06:11.075]                     if (!future$lazy) 
[16:06:11.075]                       future <- run(future)
[16:06:11.075]                     invisible(future)
[16:06:11.075]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:11.075]                 }
[16:06:11.075]             }
[16:06:11.075]         }
[16:06:11.075]     })
[16:06:11.075]     if (TRUE) {
[16:06:11.075]         base::sink(type = "output", split = FALSE)
[16:06:11.075]         if (TRUE) {
[16:06:11.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:11.075]         }
[16:06:11.075]         else {
[16:06:11.075]             ...future.result["stdout"] <- base::list(NULL)
[16:06:11.075]         }
[16:06:11.075]         base::close(...future.stdout)
[16:06:11.075]         ...future.stdout <- NULL
[16:06:11.075]     }
[16:06:11.075]     ...future.result$conditions <- ...future.conditions
[16:06:11.075]     ...future.result$finished <- base::Sys.time()
[16:06:11.075]     ...future.result
[16:06:11.075] }
[16:06:11.078] MultisessionFuture started
[16:06:11.078] - Launch lazy future ... done
[16:06:11.078] run() for ‘MultisessionFuture’ ... done
[16:06:11.637] receiveMessageFromWorker() for ClusterFuture ...
[16:06:11.637] - Validating connection of MultisessionFuture
[16:06:11.637] - received message: FutureResult
[16:06:11.637] - Received FutureResult
[16:06:11.638] - Erased future from FutureRegistry
[16:06:11.638] result() for ClusterFuture ...
[16:06:11.638] - result already collected: FutureResult
[16:06:11.638] result() for ClusterFuture ... done
[16:06:11.638] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:11.638] resolve() on list ...
[16:06:11.638]  recursive: 0
[16:06:11.638]  length: 2
[16:06:11.638]  elements: ‘a’, ‘b’
[16:06:11.639]  length: 1 (resolved future 1)
[16:06:11.639]  length: 0 (resolved future 2)
[16:06:11.639] resolve() on list ... DONE
[16:06:11.639] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:06:11.639] getGlobalsAndPackages() ...
[16:06:11.639] Searching for globals...
[16:06:11.640] - globals found: [2] ‘list’, ‘stop’
[16:06:11.640] Searching for globals ... DONE
[16:06:11.640] Resolving globals: FALSE
[16:06:11.640] 
[16:06:11.640] 
[16:06:11.641] getGlobalsAndPackages() ... DONE
[16:06:11.641] run() for ‘Future’ ...
[16:06:11.641] - state: ‘created’
[16:06:11.641] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:11.656] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:11.656] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:11.657]   - Field: ‘node’
[16:06:11.657]   - Field: ‘label’
[16:06:11.657]   - Field: ‘local’
[16:06:11.657]   - Field: ‘owner’
[16:06:11.657]   - Field: ‘envir’
[16:06:11.657]   - Field: ‘workers’
[16:06:11.657]   - Field: ‘packages’
[16:06:11.657]   - Field: ‘gc’
[16:06:11.657]   - Field: ‘conditions’
[16:06:11.657]   - Field: ‘persistent’
[16:06:11.658]   - Field: ‘expr’
[16:06:11.658]   - Field: ‘uuid’
[16:06:11.658]   - Field: ‘seed’
[16:06:11.658]   - Field: ‘version’
[16:06:11.658]   - Field: ‘result’
[16:06:11.658]   - Field: ‘asynchronous’
[16:06:11.658]   - Field: ‘calls’
[16:06:11.658]   - Field: ‘globals’
[16:06:11.658]   - Field: ‘stdout’
[16:06:11.658]   - Field: ‘earlySignal’
[16:06:11.658]   - Field: ‘lazy’
[16:06:11.659]   - Field: ‘state’
[16:06:11.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:11.659] - Launch lazy future ...
[16:06:11.659] Packages needed by the future expression (n = 0): <none>
[16:06:11.659] Packages needed by future strategies (n = 0): <none>
[16:06:11.660] {
[16:06:11.660]     {
[16:06:11.660]         {
[16:06:11.660]             ...future.startTime <- base::Sys.time()
[16:06:11.660]             {
[16:06:11.660]                 {
[16:06:11.660]                   {
[16:06:11.660]                     {
[16:06:11.660]                       base::local({
[16:06:11.660]                         has_future <- base::requireNamespace("future", 
[16:06:11.660]                           quietly = TRUE)
[16:06:11.660]                         if (has_future) {
[16:06:11.660]                           ns <- base::getNamespace("future")
[16:06:11.660]                           version <- ns[[".package"]][["version"]]
[16:06:11.660]                           if (is.null(version)) 
[16:06:11.660]                             version <- utils::packageVersion("future")
[16:06:11.660]                         }
[16:06:11.660]                         else {
[16:06:11.660]                           version <- NULL
[16:06:11.660]                         }
[16:06:11.660]                         if (!has_future || version < "1.8.0") {
[16:06:11.660]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:11.660]                             "", base::R.version$version.string), 
[16:06:11.660]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:11.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:11.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:11.660]                               "release", "version")], collapse = " "), 
[16:06:11.660]                             hostname = base::Sys.info()[["nodename"]])
[16:06:11.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:11.660]                             info)
[16:06:11.660]                           info <- base::paste(info, collapse = "; ")
[16:06:11.660]                           if (!has_future) {
[16:06:11.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:11.660]                               info)
[16:06:11.660]                           }
[16:06:11.660]                           else {
[16:06:11.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:11.660]                               info, version)
[16:06:11.660]                           }
[16:06:11.660]                           base::stop(msg)
[16:06:11.660]                         }
[16:06:11.660]                       })
[16:06:11.660]                     }
[16:06:11.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:11.660]                     base::options(mc.cores = 1L)
[16:06:11.660]                   }
[16:06:11.660]                   options(future.plan = NULL)
[16:06:11.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:11.660]                 }
[16:06:11.660]                 ...future.workdir <- getwd()
[16:06:11.660]             }
[16:06:11.660]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:11.660]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:11.660]         }
[16:06:11.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:11.660]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:11.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:11.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:11.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:11.660]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:11.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:11.660]             base::names(...future.oldOptions))
[16:06:11.660]     }
[16:06:11.660]     if (FALSE) {
[16:06:11.660]     }
[16:06:11.660]     else {
[16:06:11.660]         if (TRUE) {
[16:06:11.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:11.660]                 open = "w")
[16:06:11.660]         }
[16:06:11.660]         else {
[16:06:11.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:11.660]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:11.660]         }
[16:06:11.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:11.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:11.660]             base::sink(type = "output", split = FALSE)
[16:06:11.660]             base::close(...future.stdout)
[16:06:11.660]         }, add = TRUE)
[16:06:11.660]     }
[16:06:11.660]     ...future.frame <- base::sys.nframe()
[16:06:11.660]     ...future.conditions <- base::list()
[16:06:11.660]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:11.660]     if (FALSE) {
[16:06:11.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:11.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:11.660]     }
[16:06:11.660]     ...future.result <- base::tryCatch({
[16:06:11.660]         base::withCallingHandlers({
[16:06:11.660]             ...future.value <- base::withVisible(base::local({
[16:06:11.660]                 ...future.makeSendCondition <- base::local({
[16:06:11.660]                   sendCondition <- NULL
[16:06:11.660]                   function(frame = 1L) {
[16:06:11.660]                     if (is.function(sendCondition)) 
[16:06:11.660]                       return(sendCondition)
[16:06:11.660]                     ns <- getNamespace("parallel")
[16:06:11.660]                     if (exists("sendData", mode = "function", 
[16:06:11.660]                       envir = ns)) {
[16:06:11.660]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:11.660]                         envir = ns)
[16:06:11.660]                       envir <- sys.frame(frame)
[16:06:11.660]                       master <- NULL
[16:06:11.660]                       while (!identical(envir, .GlobalEnv) && 
[16:06:11.660]                         !identical(envir, emptyenv())) {
[16:06:11.660]                         if (exists("master", mode = "list", envir = envir, 
[16:06:11.660]                           inherits = FALSE)) {
[16:06:11.660]                           master <- get("master", mode = "list", 
[16:06:11.660]                             envir = envir, inherits = FALSE)
[16:06:11.660]                           if (inherits(master, c("SOCKnode", 
[16:06:11.660]                             "SOCK0node"))) {
[16:06:11.660]                             sendCondition <<- function(cond) {
[16:06:11.660]                               data <- list(type = "VALUE", value = cond, 
[16:06:11.660]                                 success = TRUE)
[16:06:11.660]                               parallel_sendData(master, data)
[16:06:11.660]                             }
[16:06:11.660]                             return(sendCondition)
[16:06:11.660]                           }
[16:06:11.660]                         }
[16:06:11.660]                         frame <- frame + 1L
[16:06:11.660]                         envir <- sys.frame(frame)
[16:06:11.660]                       }
[16:06:11.660]                     }
[16:06:11.660]                     sendCondition <<- function(cond) NULL
[16:06:11.660]                   }
[16:06:11.660]                 })
[16:06:11.660]                 withCallingHandlers({
[16:06:11.660]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:11.660]                 }, immediateCondition = function(cond) {
[16:06:11.660]                   sendCondition <- ...future.makeSendCondition()
[16:06:11.660]                   sendCondition(cond)
[16:06:11.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.660]                   {
[16:06:11.660]                     inherits <- base::inherits
[16:06:11.660]                     invokeRestart <- base::invokeRestart
[16:06:11.660]                     is.null <- base::is.null
[16:06:11.660]                     muffled <- FALSE
[16:06:11.660]                     if (inherits(cond, "message")) {
[16:06:11.660]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:11.660]                       if (muffled) 
[16:06:11.660]                         invokeRestart("muffleMessage")
[16:06:11.660]                     }
[16:06:11.660]                     else if (inherits(cond, "warning")) {
[16:06:11.660]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:11.660]                       if (muffled) 
[16:06:11.660]                         invokeRestart("muffleWarning")
[16:06:11.660]                     }
[16:06:11.660]                     else if (inherits(cond, "condition")) {
[16:06:11.660]                       if (!is.null(pattern)) {
[16:06:11.660]                         computeRestarts <- base::computeRestarts
[16:06:11.660]                         grepl <- base::grepl
[16:06:11.660]                         restarts <- computeRestarts(cond)
[16:06:11.660]                         for (restart in restarts) {
[16:06:11.660]                           name <- restart$name
[16:06:11.660]                           if (is.null(name)) 
[16:06:11.660]                             next
[16:06:11.660]                           if (!grepl(pattern, name)) 
[16:06:11.660]                             next
[16:06:11.660]                           invokeRestart(restart)
[16:06:11.660]                           muffled <- TRUE
[16:06:11.660]                           break
[16:06:11.660]                         }
[16:06:11.660]                       }
[16:06:11.660]                     }
[16:06:11.660]                     invisible(muffled)
[16:06:11.660]                   }
[16:06:11.660]                   muffleCondition(cond)
[16:06:11.660]                 })
[16:06:11.660]             }))
[16:06:11.660]             future::FutureResult(value = ...future.value$value, 
[16:06:11.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.660]                   ...future.rng), globalenv = if (FALSE) 
[16:06:11.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:11.660]                     ...future.globalenv.names))
[16:06:11.660]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:11.660]         }, condition = base::local({
[16:06:11.660]             c <- base::c
[16:06:11.660]             inherits <- base::inherits
[16:06:11.660]             invokeRestart <- base::invokeRestart
[16:06:11.660]             length <- base::length
[16:06:11.660]             list <- base::list
[16:06:11.660]             seq.int <- base::seq.int
[16:06:11.660]             signalCondition <- base::signalCondition
[16:06:11.660]             sys.calls <- base::sys.calls
[16:06:11.660]             `[[` <- base::`[[`
[16:06:11.660]             `+` <- base::`+`
[16:06:11.660]             `<<-` <- base::`<<-`
[16:06:11.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:11.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:11.660]                   3L)]
[16:06:11.660]             }
[16:06:11.660]             function(cond) {
[16:06:11.660]                 is_error <- inherits(cond, "error")
[16:06:11.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:11.660]                   NULL)
[16:06:11.660]                 if (is_error) {
[16:06:11.660]                   sessionInformation <- function() {
[16:06:11.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:11.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:11.660]                       search = base::search(), system = base::Sys.info())
[16:06:11.660]                   }
[16:06:11.660]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:11.660]                     cond$call), session = sessionInformation(), 
[16:06:11.660]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:11.660]                   signalCondition(cond)
[16:06:11.660]                 }
[16:06:11.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:11.660]                 "immediateCondition"))) {
[16:06:11.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:11.660]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:11.660]                   if (TRUE && !signal) {
[16:06:11.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.660]                     {
[16:06:11.660]                       inherits <- base::inherits
[16:06:11.660]                       invokeRestart <- base::invokeRestart
[16:06:11.660]                       is.null <- base::is.null
[16:06:11.660]                       muffled <- FALSE
[16:06:11.660]                       if (inherits(cond, "message")) {
[16:06:11.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.660]                         if (muffled) 
[16:06:11.660]                           invokeRestart("muffleMessage")
[16:06:11.660]                       }
[16:06:11.660]                       else if (inherits(cond, "warning")) {
[16:06:11.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.660]                         if (muffled) 
[16:06:11.660]                           invokeRestart("muffleWarning")
[16:06:11.660]                       }
[16:06:11.660]                       else if (inherits(cond, "condition")) {
[16:06:11.660]                         if (!is.null(pattern)) {
[16:06:11.660]                           computeRestarts <- base::computeRestarts
[16:06:11.660]                           grepl <- base::grepl
[16:06:11.660]                           restarts <- computeRestarts(cond)
[16:06:11.660]                           for (restart in restarts) {
[16:06:11.660]                             name <- restart$name
[16:06:11.660]                             if (is.null(name)) 
[16:06:11.660]                               next
[16:06:11.660]                             if (!grepl(pattern, name)) 
[16:06:11.660]                               next
[16:06:11.660]                             invokeRestart(restart)
[16:06:11.660]                             muffled <- TRUE
[16:06:11.660]                             break
[16:06:11.660]                           }
[16:06:11.660]                         }
[16:06:11.660]                       }
[16:06:11.660]                       invisible(muffled)
[16:06:11.660]                     }
[16:06:11.660]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.660]                   }
[16:06:11.660]                 }
[16:06:11.660]                 else {
[16:06:11.660]                   if (TRUE) {
[16:06:11.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.660]                     {
[16:06:11.660]                       inherits <- base::inherits
[16:06:11.660]                       invokeRestart <- base::invokeRestart
[16:06:11.660]                       is.null <- base::is.null
[16:06:11.660]                       muffled <- FALSE
[16:06:11.660]                       if (inherits(cond, "message")) {
[16:06:11.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.660]                         if (muffled) 
[16:06:11.660]                           invokeRestart("muffleMessage")
[16:06:11.660]                       }
[16:06:11.660]                       else if (inherits(cond, "warning")) {
[16:06:11.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.660]                         if (muffled) 
[16:06:11.660]                           invokeRestart("muffleWarning")
[16:06:11.660]                       }
[16:06:11.660]                       else if (inherits(cond, "condition")) {
[16:06:11.660]                         if (!is.null(pattern)) {
[16:06:11.660]                           computeRestarts <- base::computeRestarts
[16:06:11.660]                           grepl <- base::grepl
[16:06:11.660]                           restarts <- computeRestarts(cond)
[16:06:11.660]                           for (restart in restarts) {
[16:06:11.660]                             name <- restart$name
[16:06:11.660]                             if (is.null(name)) 
[16:06:11.660]                               next
[16:06:11.660]                             if (!grepl(pattern, name)) 
[16:06:11.660]                               next
[16:06:11.660]                             invokeRestart(restart)
[16:06:11.660]                             muffled <- TRUE
[16:06:11.660]                             break
[16:06:11.660]                           }
[16:06:11.660]                         }
[16:06:11.660]                       }
[16:06:11.660]                       invisible(muffled)
[16:06:11.660]                     }
[16:06:11.660]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.660]                   }
[16:06:11.660]                 }
[16:06:11.660]             }
[16:06:11.660]         }))
[16:06:11.660]     }, error = function(ex) {
[16:06:11.660]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:11.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.660]                 ...future.rng), started = ...future.startTime, 
[16:06:11.660]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:11.660]             version = "1.8"), class = "FutureResult")
[16:06:11.660]     }, finally = {
[16:06:11.660]         if (!identical(...future.workdir, getwd())) 
[16:06:11.660]             setwd(...future.workdir)
[16:06:11.660]         {
[16:06:11.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:11.660]                 ...future.oldOptions$nwarnings <- NULL
[16:06:11.660]             }
[16:06:11.660]             base::options(...future.oldOptions)
[16:06:11.660]             if (.Platform$OS.type == "windows") {
[16:06:11.660]                 old_names <- names(...future.oldEnvVars)
[16:06:11.660]                 envs <- base::Sys.getenv()
[16:06:11.660]                 names <- names(envs)
[16:06:11.660]                 common <- intersect(names, old_names)
[16:06:11.660]                 added <- setdiff(names, old_names)
[16:06:11.660]                 removed <- setdiff(old_names, names)
[16:06:11.660]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:11.660]                   envs[common]]
[16:06:11.660]                 NAMES <- toupper(changed)
[16:06:11.660]                 args <- list()
[16:06:11.660]                 for (kk in seq_along(NAMES)) {
[16:06:11.660]                   name <- changed[[kk]]
[16:06:11.660]                   NAME <- NAMES[[kk]]
[16:06:11.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.660]                     next
[16:06:11.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.660]                 }
[16:06:11.660]                 NAMES <- toupper(added)
[16:06:11.660]                 for (kk in seq_along(NAMES)) {
[16:06:11.660]                   name <- added[[kk]]
[16:06:11.660]                   NAME <- NAMES[[kk]]
[16:06:11.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.660]                     next
[16:06:11.660]                   args[[name]] <- ""
[16:06:11.660]                 }
[16:06:11.660]                 NAMES <- toupper(removed)
[16:06:11.660]                 for (kk in seq_along(NAMES)) {
[16:06:11.660]                   name <- removed[[kk]]
[16:06:11.660]                   NAME <- NAMES[[kk]]
[16:06:11.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.660]                     next
[16:06:11.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.660]                 }
[16:06:11.660]                 if (length(args) > 0) 
[16:06:11.660]                   base::do.call(base::Sys.setenv, args = args)
[16:06:11.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:11.660]             }
[16:06:11.660]             else {
[16:06:11.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:11.660]             }
[16:06:11.660]             {
[16:06:11.660]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:11.660]                   0L) {
[16:06:11.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:11.660]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:11.660]                   base::options(opts)
[16:06:11.660]                 }
[16:06:11.660]                 {
[16:06:11.660]                   {
[16:06:11.660]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:11.660]                     NULL
[16:06:11.660]                   }
[16:06:11.660]                   options(future.plan = NULL)
[16:06:11.660]                   if (is.na(NA_character_)) 
[16:06:11.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:11.660]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:11.660]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:11.660]                     envir = parent.frame()) 
[16:06:11.660]                   {
[16:06:11.660]                     if (is.function(workers)) 
[16:06:11.660]                       workers <- workers()
[16:06:11.660]                     workers <- structure(as.integer(workers), 
[16:06:11.660]                       class = class(workers))
[16:06:11.660]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:11.660]                       workers >= 1)
[16:06:11.660]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:11.660]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:11.660]                     }
[16:06:11.660]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:11.660]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:11.660]                       envir = envir)
[16:06:11.660]                     if (!future$lazy) 
[16:06:11.660]                       future <- run(future)
[16:06:11.660]                     invisible(future)
[16:06:11.660]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:11.660]                 }
[16:06:11.660]             }
[16:06:11.660]         }
[16:06:11.660]     })
[16:06:11.660]     if (TRUE) {
[16:06:11.660]         base::sink(type = "output", split = FALSE)
[16:06:11.660]         if (TRUE) {
[16:06:11.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:11.660]         }
[16:06:11.660]         else {
[16:06:11.660]             ...future.result["stdout"] <- base::list(NULL)
[16:06:11.660]         }
[16:06:11.660]         base::close(...future.stdout)
[16:06:11.660]         ...future.stdout <- NULL
[16:06:11.660]     }
[16:06:11.660]     ...future.result$conditions <- ...future.conditions
[16:06:11.660]     ...future.result$finished <- base::Sys.time()
[16:06:11.660]     ...future.result
[16:06:11.660] }
[16:06:11.663] MultisessionFuture started
[16:06:11.663] - Launch lazy future ... done
[16:06:11.663] run() for ‘MultisessionFuture’ ... done
[16:06:11.708] receiveMessageFromWorker() for ClusterFuture ...
[16:06:11.708] - Validating connection of MultisessionFuture
[16:06:11.709] - received message: FutureResult
[16:06:11.709] - Received FutureResult
[16:06:11.709] - Erased future from FutureRegistry
[16:06:11.709] result() for ClusterFuture ...
[16:06:11.709] - result already collected: FutureResult
[16:06:11.709] result() for ClusterFuture ... done
[16:06:11.709] signalConditions() ...
[16:06:11.709]  - include = ‘immediateCondition’
[16:06:11.709]  - exclude = 
[16:06:11.709]  - resignal = FALSE
[16:06:11.710]  - Number of conditions: 1
[16:06:11.710] signalConditions() ... done
[16:06:11.710] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:11.710] A MultisessionFuture was resolved
[16:06:11.710] getGlobalsAndPackages() ...
[16:06:11.710] Searching for globals...
[16:06:11.711] - globals found: [2] ‘list’, ‘stop’
[16:06:11.711] Searching for globals ... DONE
[16:06:11.711] Resolving globals: FALSE
[16:06:11.711] 
[16:06:11.711] 
[16:06:11.711] getGlobalsAndPackages() ... DONE
[16:06:11.712] run() for ‘Future’ ...
[16:06:11.712] - state: ‘created’
[16:06:11.712] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:11.726] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:11.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:11.726]   - Field: ‘node’
[16:06:11.726]   - Field: ‘label’
[16:06:11.726]   - Field: ‘local’
[16:06:11.726]   - Field: ‘owner’
[16:06:11.726]   - Field: ‘envir’
[16:06:11.726]   - Field: ‘workers’
[16:06:11.726]   - Field: ‘packages’
[16:06:11.726]   - Field: ‘gc’
[16:06:11.727]   - Field: ‘conditions’
[16:06:11.727]   - Field: ‘persistent’
[16:06:11.727]   - Field: ‘expr’
[16:06:11.727]   - Field: ‘uuid’
[16:06:11.727]   - Field: ‘seed’
[16:06:11.727]   - Field: ‘version’
[16:06:11.727]   - Field: ‘result’
[16:06:11.727]   - Field: ‘asynchronous’
[16:06:11.727]   - Field: ‘calls’
[16:06:11.727]   - Field: ‘globals’
[16:06:11.727]   - Field: ‘stdout’
[16:06:11.728]   - Field: ‘earlySignal’
[16:06:11.728]   - Field: ‘lazy’
[16:06:11.728]   - Field: ‘state’
[16:06:11.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:11.728] - Launch lazy future ...
[16:06:11.728] Packages needed by the future expression (n = 0): <none>
[16:06:11.728] Packages needed by future strategies (n = 0): <none>
[16:06:11.729] {
[16:06:11.729]     {
[16:06:11.729]         {
[16:06:11.729]             ...future.startTime <- base::Sys.time()
[16:06:11.729]             {
[16:06:11.729]                 {
[16:06:11.729]                   {
[16:06:11.729]                     {
[16:06:11.729]                       base::local({
[16:06:11.729]                         has_future <- base::requireNamespace("future", 
[16:06:11.729]                           quietly = TRUE)
[16:06:11.729]                         if (has_future) {
[16:06:11.729]                           ns <- base::getNamespace("future")
[16:06:11.729]                           version <- ns[[".package"]][["version"]]
[16:06:11.729]                           if (is.null(version)) 
[16:06:11.729]                             version <- utils::packageVersion("future")
[16:06:11.729]                         }
[16:06:11.729]                         else {
[16:06:11.729]                           version <- NULL
[16:06:11.729]                         }
[16:06:11.729]                         if (!has_future || version < "1.8.0") {
[16:06:11.729]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:11.729]                             "", base::R.version$version.string), 
[16:06:11.729]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:11.729]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:11.729]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:11.729]                               "release", "version")], collapse = " "), 
[16:06:11.729]                             hostname = base::Sys.info()[["nodename"]])
[16:06:11.729]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:11.729]                             info)
[16:06:11.729]                           info <- base::paste(info, collapse = "; ")
[16:06:11.729]                           if (!has_future) {
[16:06:11.729]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:11.729]                               info)
[16:06:11.729]                           }
[16:06:11.729]                           else {
[16:06:11.729]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:11.729]                               info, version)
[16:06:11.729]                           }
[16:06:11.729]                           base::stop(msg)
[16:06:11.729]                         }
[16:06:11.729]                       })
[16:06:11.729]                     }
[16:06:11.729]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:11.729]                     base::options(mc.cores = 1L)
[16:06:11.729]                   }
[16:06:11.729]                   options(future.plan = NULL)
[16:06:11.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:11.729]                 }
[16:06:11.729]                 ...future.workdir <- getwd()
[16:06:11.729]             }
[16:06:11.729]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:11.729]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:11.729]         }
[16:06:11.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:11.729]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:11.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:11.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:11.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:11.729]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:11.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:11.729]             base::names(...future.oldOptions))
[16:06:11.729]     }
[16:06:11.729]     if (FALSE) {
[16:06:11.729]     }
[16:06:11.729]     else {
[16:06:11.729]         if (TRUE) {
[16:06:11.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:11.729]                 open = "w")
[16:06:11.729]         }
[16:06:11.729]         else {
[16:06:11.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:11.729]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:11.729]         }
[16:06:11.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:11.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:11.729]             base::sink(type = "output", split = FALSE)
[16:06:11.729]             base::close(...future.stdout)
[16:06:11.729]         }, add = TRUE)
[16:06:11.729]     }
[16:06:11.729]     ...future.frame <- base::sys.nframe()
[16:06:11.729]     ...future.conditions <- base::list()
[16:06:11.729]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:11.729]     if (FALSE) {
[16:06:11.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:11.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:11.729]     }
[16:06:11.729]     ...future.result <- base::tryCatch({
[16:06:11.729]         base::withCallingHandlers({
[16:06:11.729]             ...future.value <- base::withVisible(base::local({
[16:06:11.729]                 ...future.makeSendCondition <- base::local({
[16:06:11.729]                   sendCondition <- NULL
[16:06:11.729]                   function(frame = 1L) {
[16:06:11.729]                     if (is.function(sendCondition)) 
[16:06:11.729]                       return(sendCondition)
[16:06:11.729]                     ns <- getNamespace("parallel")
[16:06:11.729]                     if (exists("sendData", mode = "function", 
[16:06:11.729]                       envir = ns)) {
[16:06:11.729]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:11.729]                         envir = ns)
[16:06:11.729]                       envir <- sys.frame(frame)
[16:06:11.729]                       master <- NULL
[16:06:11.729]                       while (!identical(envir, .GlobalEnv) && 
[16:06:11.729]                         !identical(envir, emptyenv())) {
[16:06:11.729]                         if (exists("master", mode = "list", envir = envir, 
[16:06:11.729]                           inherits = FALSE)) {
[16:06:11.729]                           master <- get("master", mode = "list", 
[16:06:11.729]                             envir = envir, inherits = FALSE)
[16:06:11.729]                           if (inherits(master, c("SOCKnode", 
[16:06:11.729]                             "SOCK0node"))) {
[16:06:11.729]                             sendCondition <<- function(cond) {
[16:06:11.729]                               data <- list(type = "VALUE", value = cond, 
[16:06:11.729]                                 success = TRUE)
[16:06:11.729]                               parallel_sendData(master, data)
[16:06:11.729]                             }
[16:06:11.729]                             return(sendCondition)
[16:06:11.729]                           }
[16:06:11.729]                         }
[16:06:11.729]                         frame <- frame + 1L
[16:06:11.729]                         envir <- sys.frame(frame)
[16:06:11.729]                       }
[16:06:11.729]                     }
[16:06:11.729]                     sendCondition <<- function(cond) NULL
[16:06:11.729]                   }
[16:06:11.729]                 })
[16:06:11.729]                 withCallingHandlers({
[16:06:11.729]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:11.729]                 }, immediateCondition = function(cond) {
[16:06:11.729]                   sendCondition <- ...future.makeSendCondition()
[16:06:11.729]                   sendCondition(cond)
[16:06:11.729]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.729]                   {
[16:06:11.729]                     inherits <- base::inherits
[16:06:11.729]                     invokeRestart <- base::invokeRestart
[16:06:11.729]                     is.null <- base::is.null
[16:06:11.729]                     muffled <- FALSE
[16:06:11.729]                     if (inherits(cond, "message")) {
[16:06:11.729]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:11.729]                       if (muffled) 
[16:06:11.729]                         invokeRestart("muffleMessage")
[16:06:11.729]                     }
[16:06:11.729]                     else if (inherits(cond, "warning")) {
[16:06:11.729]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:11.729]                       if (muffled) 
[16:06:11.729]                         invokeRestart("muffleWarning")
[16:06:11.729]                     }
[16:06:11.729]                     else if (inherits(cond, "condition")) {
[16:06:11.729]                       if (!is.null(pattern)) {
[16:06:11.729]                         computeRestarts <- base::computeRestarts
[16:06:11.729]                         grepl <- base::grepl
[16:06:11.729]                         restarts <- computeRestarts(cond)
[16:06:11.729]                         for (restart in restarts) {
[16:06:11.729]                           name <- restart$name
[16:06:11.729]                           if (is.null(name)) 
[16:06:11.729]                             next
[16:06:11.729]                           if (!grepl(pattern, name)) 
[16:06:11.729]                             next
[16:06:11.729]                           invokeRestart(restart)
[16:06:11.729]                           muffled <- TRUE
[16:06:11.729]                           break
[16:06:11.729]                         }
[16:06:11.729]                       }
[16:06:11.729]                     }
[16:06:11.729]                     invisible(muffled)
[16:06:11.729]                   }
[16:06:11.729]                   muffleCondition(cond)
[16:06:11.729]                 })
[16:06:11.729]             }))
[16:06:11.729]             future::FutureResult(value = ...future.value$value, 
[16:06:11.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.729]                   ...future.rng), globalenv = if (FALSE) 
[16:06:11.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:11.729]                     ...future.globalenv.names))
[16:06:11.729]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:11.729]         }, condition = base::local({
[16:06:11.729]             c <- base::c
[16:06:11.729]             inherits <- base::inherits
[16:06:11.729]             invokeRestart <- base::invokeRestart
[16:06:11.729]             length <- base::length
[16:06:11.729]             list <- base::list
[16:06:11.729]             seq.int <- base::seq.int
[16:06:11.729]             signalCondition <- base::signalCondition
[16:06:11.729]             sys.calls <- base::sys.calls
[16:06:11.729]             `[[` <- base::`[[`
[16:06:11.729]             `+` <- base::`+`
[16:06:11.729]             `<<-` <- base::`<<-`
[16:06:11.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:11.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:11.729]                   3L)]
[16:06:11.729]             }
[16:06:11.729]             function(cond) {
[16:06:11.729]                 is_error <- inherits(cond, "error")
[16:06:11.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:11.729]                   NULL)
[16:06:11.729]                 if (is_error) {
[16:06:11.729]                   sessionInformation <- function() {
[16:06:11.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:11.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:11.729]                       search = base::search(), system = base::Sys.info())
[16:06:11.729]                   }
[16:06:11.729]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:11.729]                     cond$call), session = sessionInformation(), 
[16:06:11.729]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:11.729]                   signalCondition(cond)
[16:06:11.729]                 }
[16:06:11.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:11.729]                 "immediateCondition"))) {
[16:06:11.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:11.729]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:11.729]                   if (TRUE && !signal) {
[16:06:11.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.729]                     {
[16:06:11.729]                       inherits <- base::inherits
[16:06:11.729]                       invokeRestart <- base::invokeRestart
[16:06:11.729]                       is.null <- base::is.null
[16:06:11.729]                       muffled <- FALSE
[16:06:11.729]                       if (inherits(cond, "message")) {
[16:06:11.729]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.729]                         if (muffled) 
[16:06:11.729]                           invokeRestart("muffleMessage")
[16:06:11.729]                       }
[16:06:11.729]                       else if (inherits(cond, "warning")) {
[16:06:11.729]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.729]                         if (muffled) 
[16:06:11.729]                           invokeRestart("muffleWarning")
[16:06:11.729]                       }
[16:06:11.729]                       else if (inherits(cond, "condition")) {
[16:06:11.729]                         if (!is.null(pattern)) {
[16:06:11.729]                           computeRestarts <- base::computeRestarts
[16:06:11.729]                           grepl <- base::grepl
[16:06:11.729]                           restarts <- computeRestarts(cond)
[16:06:11.729]                           for (restart in restarts) {
[16:06:11.729]                             name <- restart$name
[16:06:11.729]                             if (is.null(name)) 
[16:06:11.729]                               next
[16:06:11.729]                             if (!grepl(pattern, name)) 
[16:06:11.729]                               next
[16:06:11.729]                             invokeRestart(restart)
[16:06:11.729]                             muffled <- TRUE
[16:06:11.729]                             break
[16:06:11.729]                           }
[16:06:11.729]                         }
[16:06:11.729]                       }
[16:06:11.729]                       invisible(muffled)
[16:06:11.729]                     }
[16:06:11.729]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.729]                   }
[16:06:11.729]                 }
[16:06:11.729]                 else {
[16:06:11.729]                   if (TRUE) {
[16:06:11.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.729]                     {
[16:06:11.729]                       inherits <- base::inherits
[16:06:11.729]                       invokeRestart <- base::invokeRestart
[16:06:11.729]                       is.null <- base::is.null
[16:06:11.729]                       muffled <- FALSE
[16:06:11.729]                       if (inherits(cond, "message")) {
[16:06:11.729]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.729]                         if (muffled) 
[16:06:11.729]                           invokeRestart("muffleMessage")
[16:06:11.729]                       }
[16:06:11.729]                       else if (inherits(cond, "warning")) {
[16:06:11.729]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.729]                         if (muffled) 
[16:06:11.729]                           invokeRestart("muffleWarning")
[16:06:11.729]                       }
[16:06:11.729]                       else if (inherits(cond, "condition")) {
[16:06:11.729]                         if (!is.null(pattern)) {
[16:06:11.729]                           computeRestarts <- base::computeRestarts
[16:06:11.729]                           grepl <- base::grepl
[16:06:11.729]                           restarts <- computeRestarts(cond)
[16:06:11.729]                           for (restart in restarts) {
[16:06:11.729]                             name <- restart$name
[16:06:11.729]                             if (is.null(name)) 
[16:06:11.729]                               next
[16:06:11.729]                             if (!grepl(pattern, name)) 
[16:06:11.729]                               next
[16:06:11.729]                             invokeRestart(restart)
[16:06:11.729]                             muffled <- TRUE
[16:06:11.729]                             break
[16:06:11.729]                           }
[16:06:11.729]                         }
[16:06:11.729]                       }
[16:06:11.729]                       invisible(muffled)
[16:06:11.729]                     }
[16:06:11.729]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.729]                   }
[16:06:11.729]                 }
[16:06:11.729]             }
[16:06:11.729]         }))
[16:06:11.729]     }, error = function(ex) {
[16:06:11.729]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:11.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.729]                 ...future.rng), started = ...future.startTime, 
[16:06:11.729]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:11.729]             version = "1.8"), class = "FutureResult")
[16:06:11.729]     }, finally = {
[16:06:11.729]         if (!identical(...future.workdir, getwd())) 
[16:06:11.729]             setwd(...future.workdir)
[16:06:11.729]         {
[16:06:11.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:11.729]                 ...future.oldOptions$nwarnings <- NULL
[16:06:11.729]             }
[16:06:11.729]             base::options(...future.oldOptions)
[16:06:11.729]             if (.Platform$OS.type == "windows") {
[16:06:11.729]                 old_names <- names(...future.oldEnvVars)
[16:06:11.729]                 envs <- base::Sys.getenv()
[16:06:11.729]                 names <- names(envs)
[16:06:11.729]                 common <- intersect(names, old_names)
[16:06:11.729]                 added <- setdiff(names, old_names)
[16:06:11.729]                 removed <- setdiff(old_names, names)
[16:06:11.729]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:11.729]                   envs[common]]
[16:06:11.729]                 NAMES <- toupper(changed)
[16:06:11.729]                 args <- list()
[16:06:11.729]                 for (kk in seq_along(NAMES)) {
[16:06:11.729]                   name <- changed[[kk]]
[16:06:11.729]                   NAME <- NAMES[[kk]]
[16:06:11.729]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.729]                     next
[16:06:11.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.729]                 }
[16:06:11.729]                 NAMES <- toupper(added)
[16:06:11.729]                 for (kk in seq_along(NAMES)) {
[16:06:11.729]                   name <- added[[kk]]
[16:06:11.729]                   NAME <- NAMES[[kk]]
[16:06:11.729]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.729]                     next
[16:06:11.729]                   args[[name]] <- ""
[16:06:11.729]                 }
[16:06:11.729]                 NAMES <- toupper(removed)
[16:06:11.729]                 for (kk in seq_along(NAMES)) {
[16:06:11.729]                   name <- removed[[kk]]
[16:06:11.729]                   NAME <- NAMES[[kk]]
[16:06:11.729]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.729]                     next
[16:06:11.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.729]                 }
[16:06:11.729]                 if (length(args) > 0) 
[16:06:11.729]                   base::do.call(base::Sys.setenv, args = args)
[16:06:11.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:11.729]             }
[16:06:11.729]             else {
[16:06:11.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:11.729]             }
[16:06:11.729]             {
[16:06:11.729]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:11.729]                   0L) {
[16:06:11.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:11.729]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:11.729]                   base::options(opts)
[16:06:11.729]                 }
[16:06:11.729]                 {
[16:06:11.729]                   {
[16:06:11.729]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:11.729]                     NULL
[16:06:11.729]                   }
[16:06:11.729]                   options(future.plan = NULL)
[16:06:11.729]                   if (is.na(NA_character_)) 
[16:06:11.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:11.729]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:11.729]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:11.729]                     envir = parent.frame()) 
[16:06:11.729]                   {
[16:06:11.729]                     if (is.function(workers)) 
[16:06:11.729]                       workers <- workers()
[16:06:11.729]                     workers <- structure(as.integer(workers), 
[16:06:11.729]                       class = class(workers))
[16:06:11.729]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:11.729]                       workers >= 1)
[16:06:11.729]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:11.729]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:11.729]                     }
[16:06:11.729]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:11.729]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:11.729]                       envir = envir)
[16:06:11.729]                     if (!future$lazy) 
[16:06:11.729]                       future <- run(future)
[16:06:11.729]                     invisible(future)
[16:06:11.729]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:11.729]                 }
[16:06:11.729]             }
[16:06:11.729]         }
[16:06:11.729]     })
[16:06:11.729]     if (TRUE) {
[16:06:11.729]         base::sink(type = "output", split = FALSE)
[16:06:11.729]         if (TRUE) {
[16:06:11.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:11.729]         }
[16:06:11.729]         else {
[16:06:11.729]             ...future.result["stdout"] <- base::list(NULL)
[16:06:11.729]         }
[16:06:11.729]         base::close(...future.stdout)
[16:06:11.729]         ...future.stdout <- NULL
[16:06:11.729]     }
[16:06:11.729]     ...future.result$conditions <- ...future.conditions
[16:06:11.729]     ...future.result$finished <- base::Sys.time()
[16:06:11.729]     ...future.result
[16:06:11.729] }
[16:06:11.732] MultisessionFuture started
[16:06:11.732] - Launch lazy future ... done
[16:06:11.732] run() for ‘MultisessionFuture’ ... done
[16:06:11.780] receiveMessageFromWorker() for ClusterFuture ...
[16:06:11.780] - Validating connection of MultisessionFuture
[16:06:11.781] - received message: FutureResult
[16:06:11.781] - Received FutureResult
[16:06:11.781] - Erased future from FutureRegistry
[16:06:11.781] result() for ClusterFuture ...
[16:06:11.781] - result already collected: FutureResult
[16:06:11.781] result() for ClusterFuture ... done
[16:06:11.781] signalConditions() ...
[16:06:11.781]  - include = ‘immediateCondition’
[16:06:11.782]  - exclude = 
[16:06:11.782]  - resignal = FALSE
[16:06:11.782]  - Number of conditions: 1
[16:06:11.782] signalConditions() ... done
[16:06:11.782] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:11.782] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[16:06:11.782] getGlobalsAndPackages() ...
[16:06:11.782] Searching for globals...
[16:06:11.784] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:11.784] Searching for globals ... DONE
[16:06:11.784] Resolving globals: FALSE
[16:06:11.784] 
[16:06:11.784] 
[16:06:11.784] getGlobalsAndPackages() ... DONE
[16:06:11.785] run() for ‘Future’ ...
[16:06:11.785] - state: ‘created’
[16:06:11.785] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:11.798] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:11.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:11.799]   - Field: ‘node’
[16:06:11.799]   - Field: ‘label’
[16:06:11.799]   - Field: ‘local’
[16:06:11.799]   - Field: ‘owner’
[16:06:11.799]   - Field: ‘envir’
[16:06:11.799]   - Field: ‘workers’
[16:06:11.799]   - Field: ‘packages’
[16:06:11.799]   - Field: ‘gc’
[16:06:11.800]   - Field: ‘conditions’
[16:06:11.800]   - Field: ‘persistent’
[16:06:11.800]   - Field: ‘expr’
[16:06:11.800]   - Field: ‘uuid’
[16:06:11.800]   - Field: ‘seed’
[16:06:11.800]   - Field: ‘version’
[16:06:11.800]   - Field: ‘result’
[16:06:11.800]   - Field: ‘asynchronous’
[16:06:11.800]   - Field: ‘calls’
[16:06:11.800]   - Field: ‘globals’
[16:06:11.800]   - Field: ‘stdout’
[16:06:11.801]   - Field: ‘earlySignal’
[16:06:11.801]   - Field: ‘lazy’
[16:06:11.801]   - Field: ‘state’
[16:06:11.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:11.801] - Launch lazy future ...
[16:06:11.801] Packages needed by the future expression (n = 0): <none>
[16:06:11.801] Packages needed by future strategies (n = 0): <none>
[16:06:11.802] {
[16:06:11.802]     {
[16:06:11.802]         {
[16:06:11.802]             ...future.startTime <- base::Sys.time()
[16:06:11.802]             {
[16:06:11.802]                 {
[16:06:11.802]                   {
[16:06:11.802]                     {
[16:06:11.802]                       base::local({
[16:06:11.802]                         has_future <- base::requireNamespace("future", 
[16:06:11.802]                           quietly = TRUE)
[16:06:11.802]                         if (has_future) {
[16:06:11.802]                           ns <- base::getNamespace("future")
[16:06:11.802]                           version <- ns[[".package"]][["version"]]
[16:06:11.802]                           if (is.null(version)) 
[16:06:11.802]                             version <- utils::packageVersion("future")
[16:06:11.802]                         }
[16:06:11.802]                         else {
[16:06:11.802]                           version <- NULL
[16:06:11.802]                         }
[16:06:11.802]                         if (!has_future || version < "1.8.0") {
[16:06:11.802]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:11.802]                             "", base::R.version$version.string), 
[16:06:11.802]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:11.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:11.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:11.802]                               "release", "version")], collapse = " "), 
[16:06:11.802]                             hostname = base::Sys.info()[["nodename"]])
[16:06:11.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:11.802]                             info)
[16:06:11.802]                           info <- base::paste(info, collapse = "; ")
[16:06:11.802]                           if (!has_future) {
[16:06:11.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:11.802]                               info)
[16:06:11.802]                           }
[16:06:11.802]                           else {
[16:06:11.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:11.802]                               info, version)
[16:06:11.802]                           }
[16:06:11.802]                           base::stop(msg)
[16:06:11.802]                         }
[16:06:11.802]                       })
[16:06:11.802]                     }
[16:06:11.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:11.802]                     base::options(mc.cores = 1L)
[16:06:11.802]                   }
[16:06:11.802]                   options(future.plan = NULL)
[16:06:11.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:11.802]                 }
[16:06:11.802]                 ...future.workdir <- getwd()
[16:06:11.802]             }
[16:06:11.802]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:11.802]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:11.802]         }
[16:06:11.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:11.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:11.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:11.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:11.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:11.802]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:11.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:11.802]             base::names(...future.oldOptions))
[16:06:11.802]     }
[16:06:11.802]     if (FALSE) {
[16:06:11.802]     }
[16:06:11.802]     else {
[16:06:11.802]         if (TRUE) {
[16:06:11.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:11.802]                 open = "w")
[16:06:11.802]         }
[16:06:11.802]         else {
[16:06:11.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:11.802]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:11.802]         }
[16:06:11.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:11.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:11.802]             base::sink(type = "output", split = FALSE)
[16:06:11.802]             base::close(...future.stdout)
[16:06:11.802]         }, add = TRUE)
[16:06:11.802]     }
[16:06:11.802]     ...future.frame <- base::sys.nframe()
[16:06:11.802]     ...future.conditions <- base::list()
[16:06:11.802]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:11.802]     if (FALSE) {
[16:06:11.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:11.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:11.802]     }
[16:06:11.802]     ...future.result <- base::tryCatch({
[16:06:11.802]         base::withCallingHandlers({
[16:06:11.802]             ...future.value <- base::withVisible(base::local({
[16:06:11.802]                 ...future.makeSendCondition <- base::local({
[16:06:11.802]                   sendCondition <- NULL
[16:06:11.802]                   function(frame = 1L) {
[16:06:11.802]                     if (is.function(sendCondition)) 
[16:06:11.802]                       return(sendCondition)
[16:06:11.802]                     ns <- getNamespace("parallel")
[16:06:11.802]                     if (exists("sendData", mode = "function", 
[16:06:11.802]                       envir = ns)) {
[16:06:11.802]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:11.802]                         envir = ns)
[16:06:11.802]                       envir <- sys.frame(frame)
[16:06:11.802]                       master <- NULL
[16:06:11.802]                       while (!identical(envir, .GlobalEnv) && 
[16:06:11.802]                         !identical(envir, emptyenv())) {
[16:06:11.802]                         if (exists("master", mode = "list", envir = envir, 
[16:06:11.802]                           inherits = FALSE)) {
[16:06:11.802]                           master <- get("master", mode = "list", 
[16:06:11.802]                             envir = envir, inherits = FALSE)
[16:06:11.802]                           if (inherits(master, c("SOCKnode", 
[16:06:11.802]                             "SOCK0node"))) {
[16:06:11.802]                             sendCondition <<- function(cond) {
[16:06:11.802]                               data <- list(type = "VALUE", value = cond, 
[16:06:11.802]                                 success = TRUE)
[16:06:11.802]                               parallel_sendData(master, data)
[16:06:11.802]                             }
[16:06:11.802]                             return(sendCondition)
[16:06:11.802]                           }
[16:06:11.802]                         }
[16:06:11.802]                         frame <- frame + 1L
[16:06:11.802]                         envir <- sys.frame(frame)
[16:06:11.802]                       }
[16:06:11.802]                     }
[16:06:11.802]                     sendCondition <<- function(cond) NULL
[16:06:11.802]                   }
[16:06:11.802]                 })
[16:06:11.802]                 withCallingHandlers({
[16:06:11.802]                   {
[16:06:11.802]                     Sys.sleep(0.5)
[16:06:11.802]                     list(a = 1, b = 42L)
[16:06:11.802]                   }
[16:06:11.802]                 }, immediateCondition = function(cond) {
[16:06:11.802]                   sendCondition <- ...future.makeSendCondition()
[16:06:11.802]                   sendCondition(cond)
[16:06:11.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.802]                   {
[16:06:11.802]                     inherits <- base::inherits
[16:06:11.802]                     invokeRestart <- base::invokeRestart
[16:06:11.802]                     is.null <- base::is.null
[16:06:11.802]                     muffled <- FALSE
[16:06:11.802]                     if (inherits(cond, "message")) {
[16:06:11.802]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:11.802]                       if (muffled) 
[16:06:11.802]                         invokeRestart("muffleMessage")
[16:06:11.802]                     }
[16:06:11.802]                     else if (inherits(cond, "warning")) {
[16:06:11.802]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:11.802]                       if (muffled) 
[16:06:11.802]                         invokeRestart("muffleWarning")
[16:06:11.802]                     }
[16:06:11.802]                     else if (inherits(cond, "condition")) {
[16:06:11.802]                       if (!is.null(pattern)) {
[16:06:11.802]                         computeRestarts <- base::computeRestarts
[16:06:11.802]                         grepl <- base::grepl
[16:06:11.802]                         restarts <- computeRestarts(cond)
[16:06:11.802]                         for (restart in restarts) {
[16:06:11.802]                           name <- restart$name
[16:06:11.802]                           if (is.null(name)) 
[16:06:11.802]                             next
[16:06:11.802]                           if (!grepl(pattern, name)) 
[16:06:11.802]                             next
[16:06:11.802]                           invokeRestart(restart)
[16:06:11.802]                           muffled <- TRUE
[16:06:11.802]                           break
[16:06:11.802]                         }
[16:06:11.802]                       }
[16:06:11.802]                     }
[16:06:11.802]                     invisible(muffled)
[16:06:11.802]                   }
[16:06:11.802]                   muffleCondition(cond)
[16:06:11.802]                 })
[16:06:11.802]             }))
[16:06:11.802]             future::FutureResult(value = ...future.value$value, 
[16:06:11.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.802]                   ...future.rng), globalenv = if (FALSE) 
[16:06:11.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:11.802]                     ...future.globalenv.names))
[16:06:11.802]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:11.802]         }, condition = base::local({
[16:06:11.802]             c <- base::c
[16:06:11.802]             inherits <- base::inherits
[16:06:11.802]             invokeRestart <- base::invokeRestart
[16:06:11.802]             length <- base::length
[16:06:11.802]             list <- base::list
[16:06:11.802]             seq.int <- base::seq.int
[16:06:11.802]             signalCondition <- base::signalCondition
[16:06:11.802]             sys.calls <- base::sys.calls
[16:06:11.802]             `[[` <- base::`[[`
[16:06:11.802]             `+` <- base::`+`
[16:06:11.802]             `<<-` <- base::`<<-`
[16:06:11.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:11.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:11.802]                   3L)]
[16:06:11.802]             }
[16:06:11.802]             function(cond) {
[16:06:11.802]                 is_error <- inherits(cond, "error")
[16:06:11.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:11.802]                   NULL)
[16:06:11.802]                 if (is_error) {
[16:06:11.802]                   sessionInformation <- function() {
[16:06:11.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:11.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:11.802]                       search = base::search(), system = base::Sys.info())
[16:06:11.802]                   }
[16:06:11.802]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:11.802]                     cond$call), session = sessionInformation(), 
[16:06:11.802]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:11.802]                   signalCondition(cond)
[16:06:11.802]                 }
[16:06:11.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:11.802]                 "immediateCondition"))) {
[16:06:11.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:11.802]                   ...future.conditions[[length(...future.conditions) + 
[16:06:11.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:11.802]                   if (TRUE && !signal) {
[16:06:11.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.802]                     {
[16:06:11.802]                       inherits <- base::inherits
[16:06:11.802]                       invokeRestart <- base::invokeRestart
[16:06:11.802]                       is.null <- base::is.null
[16:06:11.802]                       muffled <- FALSE
[16:06:11.802]                       if (inherits(cond, "message")) {
[16:06:11.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.802]                         if (muffled) 
[16:06:11.802]                           invokeRestart("muffleMessage")
[16:06:11.802]                       }
[16:06:11.802]                       else if (inherits(cond, "warning")) {
[16:06:11.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.802]                         if (muffled) 
[16:06:11.802]                           invokeRestart("muffleWarning")
[16:06:11.802]                       }
[16:06:11.802]                       else if (inherits(cond, "condition")) {
[16:06:11.802]                         if (!is.null(pattern)) {
[16:06:11.802]                           computeRestarts <- base::computeRestarts
[16:06:11.802]                           grepl <- base::grepl
[16:06:11.802]                           restarts <- computeRestarts(cond)
[16:06:11.802]                           for (restart in restarts) {
[16:06:11.802]                             name <- restart$name
[16:06:11.802]                             if (is.null(name)) 
[16:06:11.802]                               next
[16:06:11.802]                             if (!grepl(pattern, name)) 
[16:06:11.802]                               next
[16:06:11.802]                             invokeRestart(restart)
[16:06:11.802]                             muffled <- TRUE
[16:06:11.802]                             break
[16:06:11.802]                           }
[16:06:11.802]                         }
[16:06:11.802]                       }
[16:06:11.802]                       invisible(muffled)
[16:06:11.802]                     }
[16:06:11.802]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.802]                   }
[16:06:11.802]                 }
[16:06:11.802]                 else {
[16:06:11.802]                   if (TRUE) {
[16:06:11.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:11.802]                     {
[16:06:11.802]                       inherits <- base::inherits
[16:06:11.802]                       invokeRestart <- base::invokeRestart
[16:06:11.802]                       is.null <- base::is.null
[16:06:11.802]                       muffled <- FALSE
[16:06:11.802]                       if (inherits(cond, "message")) {
[16:06:11.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:11.802]                         if (muffled) 
[16:06:11.802]                           invokeRestart("muffleMessage")
[16:06:11.802]                       }
[16:06:11.802]                       else if (inherits(cond, "warning")) {
[16:06:11.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:11.802]                         if (muffled) 
[16:06:11.802]                           invokeRestart("muffleWarning")
[16:06:11.802]                       }
[16:06:11.802]                       else if (inherits(cond, "condition")) {
[16:06:11.802]                         if (!is.null(pattern)) {
[16:06:11.802]                           computeRestarts <- base::computeRestarts
[16:06:11.802]                           grepl <- base::grepl
[16:06:11.802]                           restarts <- computeRestarts(cond)
[16:06:11.802]                           for (restart in restarts) {
[16:06:11.802]                             name <- restart$name
[16:06:11.802]                             if (is.null(name)) 
[16:06:11.802]                               next
[16:06:11.802]                             if (!grepl(pattern, name)) 
[16:06:11.802]                               next
[16:06:11.802]                             invokeRestart(restart)
[16:06:11.802]                             muffled <- TRUE
[16:06:11.802]                             break
[16:06:11.802]                           }
[16:06:11.802]                         }
[16:06:11.802]                       }
[16:06:11.802]                       invisible(muffled)
[16:06:11.802]                     }
[16:06:11.802]                     muffleCondition(cond, pattern = "^muffle")
[16:06:11.802]                   }
[16:06:11.802]                 }
[16:06:11.802]             }
[16:06:11.802]         }))
[16:06:11.802]     }, error = function(ex) {
[16:06:11.802]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:11.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:11.802]                 ...future.rng), started = ...future.startTime, 
[16:06:11.802]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:11.802]             version = "1.8"), class = "FutureResult")
[16:06:11.802]     }, finally = {
[16:06:11.802]         if (!identical(...future.workdir, getwd())) 
[16:06:11.802]             setwd(...future.workdir)
[16:06:11.802]         {
[16:06:11.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:11.802]                 ...future.oldOptions$nwarnings <- NULL
[16:06:11.802]             }
[16:06:11.802]             base::options(...future.oldOptions)
[16:06:11.802]             if (.Platform$OS.type == "windows") {
[16:06:11.802]                 old_names <- names(...future.oldEnvVars)
[16:06:11.802]                 envs <- base::Sys.getenv()
[16:06:11.802]                 names <- names(envs)
[16:06:11.802]                 common <- intersect(names, old_names)
[16:06:11.802]                 added <- setdiff(names, old_names)
[16:06:11.802]                 removed <- setdiff(old_names, names)
[16:06:11.802]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:11.802]                   envs[common]]
[16:06:11.802]                 NAMES <- toupper(changed)
[16:06:11.802]                 args <- list()
[16:06:11.802]                 for (kk in seq_along(NAMES)) {
[16:06:11.802]                   name <- changed[[kk]]
[16:06:11.802]                   NAME <- NAMES[[kk]]
[16:06:11.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.802]                     next
[16:06:11.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.802]                 }
[16:06:11.802]                 NAMES <- toupper(added)
[16:06:11.802]                 for (kk in seq_along(NAMES)) {
[16:06:11.802]                   name <- added[[kk]]
[16:06:11.802]                   NAME <- NAMES[[kk]]
[16:06:11.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.802]                     next
[16:06:11.802]                   args[[name]] <- ""
[16:06:11.802]                 }
[16:06:11.802]                 NAMES <- toupper(removed)
[16:06:11.802]                 for (kk in seq_along(NAMES)) {
[16:06:11.802]                   name <- removed[[kk]]
[16:06:11.802]                   NAME <- NAMES[[kk]]
[16:06:11.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:11.802]                     next
[16:06:11.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:11.802]                 }
[16:06:11.802]                 if (length(args) > 0) 
[16:06:11.802]                   base::do.call(base::Sys.setenv, args = args)
[16:06:11.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:11.802]             }
[16:06:11.802]             else {
[16:06:11.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:11.802]             }
[16:06:11.802]             {
[16:06:11.802]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:11.802]                   0L) {
[16:06:11.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:11.802]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:11.802]                   base::options(opts)
[16:06:11.802]                 }
[16:06:11.802]                 {
[16:06:11.802]                   {
[16:06:11.802]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:11.802]                     NULL
[16:06:11.802]                   }
[16:06:11.802]                   options(future.plan = NULL)
[16:06:11.802]                   if (is.na(NA_character_)) 
[16:06:11.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:11.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:11.802]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:11.802]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:11.802]                     envir = parent.frame()) 
[16:06:11.802]                   {
[16:06:11.802]                     if (is.function(workers)) 
[16:06:11.802]                       workers <- workers()
[16:06:11.802]                     workers <- structure(as.integer(workers), 
[16:06:11.802]                       class = class(workers))
[16:06:11.802]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:11.802]                       workers >= 1)
[16:06:11.802]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:11.802]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:11.802]                     }
[16:06:11.802]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:11.802]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:11.802]                       envir = envir)
[16:06:11.802]                     if (!future$lazy) 
[16:06:11.802]                       future <- run(future)
[16:06:11.802]                     invisible(future)
[16:06:11.802]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:11.802]                 }
[16:06:11.802]             }
[16:06:11.802]         }
[16:06:11.802]     })
[16:06:11.802]     if (TRUE) {
[16:06:11.802]         base::sink(type = "output", split = FALSE)
[16:06:11.802]         if (TRUE) {
[16:06:11.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:11.802]         }
[16:06:11.802]         else {
[16:06:11.802]             ...future.result["stdout"] <- base::list(NULL)
[16:06:11.802]         }
[16:06:11.802]         base::close(...future.stdout)
[16:06:11.802]         ...future.stdout <- NULL
[16:06:11.802]     }
[16:06:11.802]     ...future.result$conditions <- ...future.conditions
[16:06:11.802]     ...future.result$finished <- base::Sys.time()
[16:06:11.802]     ...future.result
[16:06:11.802] }
[16:06:11.805] MultisessionFuture started
[16:06:11.805] - Launch lazy future ... done
[16:06:11.805] run() for ‘MultisessionFuture’ ... done
[16:06:12.363] receiveMessageFromWorker() for ClusterFuture ...
[16:06:12.364] - Validating connection of MultisessionFuture
[16:06:12.364] - received message: FutureResult
[16:06:12.364] - Received FutureResult
[16:06:12.364] - Erased future from FutureRegistry
[16:06:12.364] result() for ClusterFuture ...
[16:06:12.364] - result already collected: FutureResult
[16:06:12.364] result() for ClusterFuture ... done
[16:06:12.364] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:12.364] resolve() on list ...
[16:06:12.365]  recursive: 1
[16:06:12.365]  length: 2
[16:06:12.365]  elements: ‘a’, ‘b’
[16:06:12.365]  length: 1 (resolved future 1)
[16:06:12.365]  length: 0 (resolved future 2)
[16:06:12.365] resolve() on list ... DONE
[16:06:12.365] A MultisessionFuture was resolved (and resolved itself)
[16:06:12.365] getGlobalsAndPackages() ...
[16:06:12.365] Searching for globals...
[16:06:12.366] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:12.367] Searching for globals ... DONE
[16:06:12.367] Resolving globals: FALSE
[16:06:12.367] 
[16:06:12.367] 
[16:06:12.367] getGlobalsAndPackages() ... DONE
[16:06:12.367] run() for ‘Future’ ...
[16:06:12.368] - state: ‘created’
[16:06:12.368] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:12.381] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:12.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:12.382]   - Field: ‘node’
[16:06:12.382]   - Field: ‘label’
[16:06:12.382]   - Field: ‘local’
[16:06:12.382]   - Field: ‘owner’
[16:06:12.382]   - Field: ‘envir’
[16:06:12.382]   - Field: ‘workers’
[16:06:12.382]   - Field: ‘packages’
[16:06:12.382]   - Field: ‘gc’
[16:06:12.382]   - Field: ‘conditions’
[16:06:12.382]   - Field: ‘persistent’
[16:06:12.383]   - Field: ‘expr’
[16:06:12.383]   - Field: ‘uuid’
[16:06:12.385]   - Field: ‘seed’
[16:06:12.385]   - Field: ‘version’
[16:06:12.385]   - Field: ‘result’
[16:06:12.385]   - Field: ‘asynchronous’
[16:06:12.386]   - Field: ‘calls’
[16:06:12.386]   - Field: ‘globals’
[16:06:12.386]   - Field: ‘stdout’
[16:06:12.386]   - Field: ‘earlySignal’
[16:06:12.386]   - Field: ‘lazy’
[16:06:12.386]   - Field: ‘state’
[16:06:12.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:12.386] - Launch lazy future ...
[16:06:12.387] Packages needed by the future expression (n = 0): <none>
[16:06:12.387] Packages needed by future strategies (n = 0): <none>
[16:06:12.387] {
[16:06:12.387]     {
[16:06:12.387]         {
[16:06:12.387]             ...future.startTime <- base::Sys.time()
[16:06:12.387]             {
[16:06:12.387]                 {
[16:06:12.387]                   {
[16:06:12.387]                     {
[16:06:12.387]                       base::local({
[16:06:12.387]                         has_future <- base::requireNamespace("future", 
[16:06:12.387]                           quietly = TRUE)
[16:06:12.387]                         if (has_future) {
[16:06:12.387]                           ns <- base::getNamespace("future")
[16:06:12.387]                           version <- ns[[".package"]][["version"]]
[16:06:12.387]                           if (is.null(version)) 
[16:06:12.387]                             version <- utils::packageVersion("future")
[16:06:12.387]                         }
[16:06:12.387]                         else {
[16:06:12.387]                           version <- NULL
[16:06:12.387]                         }
[16:06:12.387]                         if (!has_future || version < "1.8.0") {
[16:06:12.387]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:12.387]                             "", base::R.version$version.string), 
[16:06:12.387]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:12.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:12.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:12.387]                               "release", "version")], collapse = " "), 
[16:06:12.387]                             hostname = base::Sys.info()[["nodename"]])
[16:06:12.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:12.387]                             info)
[16:06:12.387]                           info <- base::paste(info, collapse = "; ")
[16:06:12.387]                           if (!has_future) {
[16:06:12.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:12.387]                               info)
[16:06:12.387]                           }
[16:06:12.387]                           else {
[16:06:12.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:12.387]                               info, version)
[16:06:12.387]                           }
[16:06:12.387]                           base::stop(msg)
[16:06:12.387]                         }
[16:06:12.387]                       })
[16:06:12.387]                     }
[16:06:12.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:12.387]                     base::options(mc.cores = 1L)
[16:06:12.387]                   }
[16:06:12.387]                   options(future.plan = NULL)
[16:06:12.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:12.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:12.387]                 }
[16:06:12.387]                 ...future.workdir <- getwd()
[16:06:12.387]             }
[16:06:12.387]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:12.387]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:12.387]         }
[16:06:12.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:12.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:12.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:12.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:12.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:12.387]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:12.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:12.387]             base::names(...future.oldOptions))
[16:06:12.387]     }
[16:06:12.387]     if (FALSE) {
[16:06:12.387]     }
[16:06:12.387]     else {
[16:06:12.387]         if (TRUE) {
[16:06:12.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:12.387]                 open = "w")
[16:06:12.387]         }
[16:06:12.387]         else {
[16:06:12.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:12.387]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:12.387]         }
[16:06:12.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:12.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:12.387]             base::sink(type = "output", split = FALSE)
[16:06:12.387]             base::close(...future.stdout)
[16:06:12.387]         }, add = TRUE)
[16:06:12.387]     }
[16:06:12.387]     ...future.frame <- base::sys.nframe()
[16:06:12.387]     ...future.conditions <- base::list()
[16:06:12.387]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:12.387]     if (FALSE) {
[16:06:12.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:12.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:12.387]     }
[16:06:12.387]     ...future.result <- base::tryCatch({
[16:06:12.387]         base::withCallingHandlers({
[16:06:12.387]             ...future.value <- base::withVisible(base::local({
[16:06:12.387]                 ...future.makeSendCondition <- base::local({
[16:06:12.387]                   sendCondition <- NULL
[16:06:12.387]                   function(frame = 1L) {
[16:06:12.387]                     if (is.function(sendCondition)) 
[16:06:12.387]                       return(sendCondition)
[16:06:12.387]                     ns <- getNamespace("parallel")
[16:06:12.387]                     if (exists("sendData", mode = "function", 
[16:06:12.387]                       envir = ns)) {
[16:06:12.387]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:12.387]                         envir = ns)
[16:06:12.387]                       envir <- sys.frame(frame)
[16:06:12.387]                       master <- NULL
[16:06:12.387]                       while (!identical(envir, .GlobalEnv) && 
[16:06:12.387]                         !identical(envir, emptyenv())) {
[16:06:12.387]                         if (exists("master", mode = "list", envir = envir, 
[16:06:12.387]                           inherits = FALSE)) {
[16:06:12.387]                           master <- get("master", mode = "list", 
[16:06:12.387]                             envir = envir, inherits = FALSE)
[16:06:12.387]                           if (inherits(master, c("SOCKnode", 
[16:06:12.387]                             "SOCK0node"))) {
[16:06:12.387]                             sendCondition <<- function(cond) {
[16:06:12.387]                               data <- list(type = "VALUE", value = cond, 
[16:06:12.387]                                 success = TRUE)
[16:06:12.387]                               parallel_sendData(master, data)
[16:06:12.387]                             }
[16:06:12.387]                             return(sendCondition)
[16:06:12.387]                           }
[16:06:12.387]                         }
[16:06:12.387]                         frame <- frame + 1L
[16:06:12.387]                         envir <- sys.frame(frame)
[16:06:12.387]                       }
[16:06:12.387]                     }
[16:06:12.387]                     sendCondition <<- function(cond) NULL
[16:06:12.387]                   }
[16:06:12.387]                 })
[16:06:12.387]                 withCallingHandlers({
[16:06:12.387]                   {
[16:06:12.387]                     Sys.sleep(0.5)
[16:06:12.387]                     list(a = 1, b = 42L)
[16:06:12.387]                   }
[16:06:12.387]                 }, immediateCondition = function(cond) {
[16:06:12.387]                   sendCondition <- ...future.makeSendCondition()
[16:06:12.387]                   sendCondition(cond)
[16:06:12.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:12.387]                   {
[16:06:12.387]                     inherits <- base::inherits
[16:06:12.387]                     invokeRestart <- base::invokeRestart
[16:06:12.387]                     is.null <- base::is.null
[16:06:12.387]                     muffled <- FALSE
[16:06:12.387]                     if (inherits(cond, "message")) {
[16:06:12.387]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:12.387]                       if (muffled) 
[16:06:12.387]                         invokeRestart("muffleMessage")
[16:06:12.387]                     }
[16:06:12.387]                     else if (inherits(cond, "warning")) {
[16:06:12.387]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:12.387]                       if (muffled) 
[16:06:12.387]                         invokeRestart("muffleWarning")
[16:06:12.387]                     }
[16:06:12.387]                     else if (inherits(cond, "condition")) {
[16:06:12.387]                       if (!is.null(pattern)) {
[16:06:12.387]                         computeRestarts <- base::computeRestarts
[16:06:12.387]                         grepl <- base::grepl
[16:06:12.387]                         restarts <- computeRestarts(cond)
[16:06:12.387]                         for (restart in restarts) {
[16:06:12.387]                           name <- restart$name
[16:06:12.387]                           if (is.null(name)) 
[16:06:12.387]                             next
[16:06:12.387]                           if (!grepl(pattern, name)) 
[16:06:12.387]                             next
[16:06:12.387]                           invokeRestart(restart)
[16:06:12.387]                           muffled <- TRUE
[16:06:12.387]                           break
[16:06:12.387]                         }
[16:06:12.387]                       }
[16:06:12.387]                     }
[16:06:12.387]                     invisible(muffled)
[16:06:12.387]                   }
[16:06:12.387]                   muffleCondition(cond)
[16:06:12.387]                 })
[16:06:12.387]             }))
[16:06:12.387]             future::FutureResult(value = ...future.value$value, 
[16:06:12.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:12.387]                   ...future.rng), globalenv = if (FALSE) 
[16:06:12.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:12.387]                     ...future.globalenv.names))
[16:06:12.387]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:12.387]         }, condition = base::local({
[16:06:12.387]             c <- base::c
[16:06:12.387]             inherits <- base::inherits
[16:06:12.387]             invokeRestart <- base::invokeRestart
[16:06:12.387]             length <- base::length
[16:06:12.387]             list <- base::list
[16:06:12.387]             seq.int <- base::seq.int
[16:06:12.387]             signalCondition <- base::signalCondition
[16:06:12.387]             sys.calls <- base::sys.calls
[16:06:12.387]             `[[` <- base::`[[`
[16:06:12.387]             `+` <- base::`+`
[16:06:12.387]             `<<-` <- base::`<<-`
[16:06:12.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:12.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:12.387]                   3L)]
[16:06:12.387]             }
[16:06:12.387]             function(cond) {
[16:06:12.387]                 is_error <- inherits(cond, "error")
[16:06:12.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:12.387]                   NULL)
[16:06:12.387]                 if (is_error) {
[16:06:12.387]                   sessionInformation <- function() {
[16:06:12.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:12.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:12.387]                       search = base::search(), system = base::Sys.info())
[16:06:12.387]                   }
[16:06:12.387]                   ...future.conditions[[length(...future.conditions) + 
[16:06:12.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:12.387]                     cond$call), session = sessionInformation(), 
[16:06:12.387]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:12.387]                   signalCondition(cond)
[16:06:12.387]                 }
[16:06:12.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:12.387]                 "immediateCondition"))) {
[16:06:12.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:12.387]                   ...future.conditions[[length(...future.conditions) + 
[16:06:12.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:12.387]                   if (TRUE && !signal) {
[16:06:12.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:12.387]                     {
[16:06:12.387]                       inherits <- base::inherits
[16:06:12.387]                       invokeRestart <- base::invokeRestart
[16:06:12.387]                       is.null <- base::is.null
[16:06:12.387]                       muffled <- FALSE
[16:06:12.387]                       if (inherits(cond, "message")) {
[16:06:12.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:12.387]                         if (muffled) 
[16:06:12.387]                           invokeRestart("muffleMessage")
[16:06:12.387]                       }
[16:06:12.387]                       else if (inherits(cond, "warning")) {
[16:06:12.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:12.387]                         if (muffled) 
[16:06:12.387]                           invokeRestart("muffleWarning")
[16:06:12.387]                       }
[16:06:12.387]                       else if (inherits(cond, "condition")) {
[16:06:12.387]                         if (!is.null(pattern)) {
[16:06:12.387]                           computeRestarts <- base::computeRestarts
[16:06:12.387]                           grepl <- base::grepl
[16:06:12.387]                           restarts <- computeRestarts(cond)
[16:06:12.387]                           for (restart in restarts) {
[16:06:12.387]                             name <- restart$name
[16:06:12.387]                             if (is.null(name)) 
[16:06:12.387]                               next
[16:06:12.387]                             if (!grepl(pattern, name)) 
[16:06:12.387]                               next
[16:06:12.387]                             invokeRestart(restart)
[16:06:12.387]                             muffled <- TRUE
[16:06:12.387]                             break
[16:06:12.387]                           }
[16:06:12.387]                         }
[16:06:12.387]                       }
[16:06:12.387]                       invisible(muffled)
[16:06:12.387]                     }
[16:06:12.387]                     muffleCondition(cond, pattern = "^muffle")
[16:06:12.387]                   }
[16:06:12.387]                 }
[16:06:12.387]                 else {
[16:06:12.387]                   if (TRUE) {
[16:06:12.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:12.387]                     {
[16:06:12.387]                       inherits <- base::inherits
[16:06:12.387]                       invokeRestart <- base::invokeRestart
[16:06:12.387]                       is.null <- base::is.null
[16:06:12.387]                       muffled <- FALSE
[16:06:12.387]                       if (inherits(cond, "message")) {
[16:06:12.387]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:12.387]                         if (muffled) 
[16:06:12.387]                           invokeRestart("muffleMessage")
[16:06:12.387]                       }
[16:06:12.387]                       else if (inherits(cond, "warning")) {
[16:06:12.387]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:12.387]                         if (muffled) 
[16:06:12.387]                           invokeRestart("muffleWarning")
[16:06:12.387]                       }
[16:06:12.387]                       else if (inherits(cond, "condition")) {
[16:06:12.387]                         if (!is.null(pattern)) {
[16:06:12.387]                           computeRestarts <- base::computeRestarts
[16:06:12.387]                           grepl <- base::grepl
[16:06:12.387]                           restarts <- computeRestarts(cond)
[16:06:12.387]                           for (restart in restarts) {
[16:06:12.387]                             name <- restart$name
[16:06:12.387]                             if (is.null(name)) 
[16:06:12.387]                               next
[16:06:12.387]                             if (!grepl(pattern, name)) 
[16:06:12.387]                               next
[16:06:12.387]                             invokeRestart(restart)
[16:06:12.387]                             muffled <- TRUE
[16:06:12.387]                             break
[16:06:12.387]                           }
[16:06:12.387]                         }
[16:06:12.387]                       }
[16:06:12.387]                       invisible(muffled)
[16:06:12.387]                     }
[16:06:12.387]                     muffleCondition(cond, pattern = "^muffle")
[16:06:12.387]                   }
[16:06:12.387]                 }
[16:06:12.387]             }
[16:06:12.387]         }))
[16:06:12.387]     }, error = function(ex) {
[16:06:12.387]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:12.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:12.387]                 ...future.rng), started = ...future.startTime, 
[16:06:12.387]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:12.387]             version = "1.8"), class = "FutureResult")
[16:06:12.387]     }, finally = {
[16:06:12.387]         if (!identical(...future.workdir, getwd())) 
[16:06:12.387]             setwd(...future.workdir)
[16:06:12.387]         {
[16:06:12.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:12.387]                 ...future.oldOptions$nwarnings <- NULL
[16:06:12.387]             }
[16:06:12.387]             base::options(...future.oldOptions)
[16:06:12.387]             if (.Platform$OS.type == "windows") {
[16:06:12.387]                 old_names <- names(...future.oldEnvVars)
[16:06:12.387]                 envs <- base::Sys.getenv()
[16:06:12.387]                 names <- names(envs)
[16:06:12.387]                 common <- intersect(names, old_names)
[16:06:12.387]                 added <- setdiff(names, old_names)
[16:06:12.387]                 removed <- setdiff(old_names, names)
[16:06:12.387]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:12.387]                   envs[common]]
[16:06:12.387]                 NAMES <- toupper(changed)
[16:06:12.387]                 args <- list()
[16:06:12.387]                 for (kk in seq_along(NAMES)) {
[16:06:12.387]                   name <- changed[[kk]]
[16:06:12.387]                   NAME <- NAMES[[kk]]
[16:06:12.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:12.387]                     next
[16:06:12.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:12.387]                 }
[16:06:12.387]                 NAMES <- toupper(added)
[16:06:12.387]                 for (kk in seq_along(NAMES)) {
[16:06:12.387]                   name <- added[[kk]]
[16:06:12.387]                   NAME <- NAMES[[kk]]
[16:06:12.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:12.387]                     next
[16:06:12.387]                   args[[name]] <- ""
[16:06:12.387]                 }
[16:06:12.387]                 NAMES <- toupper(removed)
[16:06:12.387]                 for (kk in seq_along(NAMES)) {
[16:06:12.387]                   name <- removed[[kk]]
[16:06:12.387]                   NAME <- NAMES[[kk]]
[16:06:12.387]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:12.387]                     next
[16:06:12.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:12.387]                 }
[16:06:12.387]                 if (length(args) > 0) 
[16:06:12.387]                   base::do.call(base::Sys.setenv, args = args)
[16:06:12.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:12.387]             }
[16:06:12.387]             else {
[16:06:12.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:12.387]             }
[16:06:12.387]             {
[16:06:12.387]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:12.387]                   0L) {
[16:06:12.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:12.387]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:12.387]                   base::options(opts)
[16:06:12.387]                 }
[16:06:12.387]                 {
[16:06:12.387]                   {
[16:06:12.387]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:12.387]                     NULL
[16:06:12.387]                   }
[16:06:12.387]                   options(future.plan = NULL)
[16:06:12.387]                   if (is.na(NA_character_)) 
[16:06:12.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:12.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:12.387]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:12.387]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:12.387]                     envir = parent.frame()) 
[16:06:12.387]                   {
[16:06:12.387]                     if (is.function(workers)) 
[16:06:12.387]                       workers <- workers()
[16:06:12.387]                     workers <- structure(as.integer(workers), 
[16:06:12.387]                       class = class(workers))
[16:06:12.387]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:12.387]                       workers >= 1)
[16:06:12.387]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:12.387]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:12.387]                     }
[16:06:12.387]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:12.387]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:12.387]                       envir = envir)
[16:06:12.387]                     if (!future$lazy) 
[16:06:12.387]                       future <- run(future)
[16:06:12.387]                     invisible(future)
[16:06:12.387]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:12.387]                 }
[16:06:12.387]             }
[16:06:12.387]         }
[16:06:12.387]     })
[16:06:12.387]     if (TRUE) {
[16:06:12.387]         base::sink(type = "output", split = FALSE)
[16:06:12.387]         if (TRUE) {
[16:06:12.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:12.387]         }
[16:06:12.387]         else {
[16:06:12.387]             ...future.result["stdout"] <- base::list(NULL)
[16:06:12.387]         }
[16:06:12.387]         base::close(...future.stdout)
[16:06:12.387]         ...future.stdout <- NULL
[16:06:12.387]     }
[16:06:12.387]     ...future.result$conditions <- ...future.conditions
[16:06:12.387]     ...future.result$finished <- base::Sys.time()
[16:06:12.387]     ...future.result
[16:06:12.387] }
[16:06:12.390] MultisessionFuture started
[16:06:12.391] - Launch lazy future ... done
[16:06:12.391] run() for ‘MultisessionFuture’ ... done
[16:06:12.937] receiveMessageFromWorker() for ClusterFuture ...
[16:06:12.937] - Validating connection of MultisessionFuture
[16:06:12.938] - received message: FutureResult
[16:06:12.938] - Received FutureResult
[16:06:12.938] - Erased future from FutureRegistry
[16:06:12.938] result() for ClusterFuture ...
[16:06:12.938] - result already collected: FutureResult
[16:06:12.938] result() for ClusterFuture ... done
[16:06:12.938] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:12.938] resolve() on list ...
[16:06:12.938]  recursive: 1
[16:06:12.939]  length: 2
[16:06:12.939]  elements: ‘a’, ‘b’
[16:06:12.939]  length: 1 (resolved future 1)
[16:06:12.939]  length: 0 (resolved future 2)
[16:06:12.939] resolve() on list ... DONE
[16:06:12.939] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:06:12.939] getGlobalsAndPackages() ...
[16:06:12.939] Searching for globals...
[16:06:12.940] - globals found: [2] ‘list’, ‘stop’
[16:06:12.940] Searching for globals ... DONE
[16:06:12.940] Resolving globals: FALSE
[16:06:12.941] 
[16:06:12.941] 
[16:06:12.941] getGlobalsAndPackages() ... DONE
[16:06:12.941] run() for ‘Future’ ...
[16:06:12.941] - state: ‘created’
[16:06:12.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:12.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:12.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:12.955]   - Field: ‘node’
[16:06:12.955]   - Field: ‘label’
[16:06:12.955]   - Field: ‘local’
[16:06:12.955]   - Field: ‘owner’
[16:06:12.956]   - Field: ‘envir’
[16:06:12.956]   - Field: ‘workers’
[16:06:12.956]   - Field: ‘packages’
[16:06:12.956]   - Field: ‘gc’
[16:06:12.956]   - Field: ‘conditions’
[16:06:12.956]   - Field: ‘persistent’
[16:06:12.956]   - Field: ‘expr’
[16:06:12.956]   - Field: ‘uuid’
[16:06:12.956]   - Field: ‘seed’
[16:06:12.956]   - Field: ‘version’
[16:06:12.956]   - Field: ‘result’
[16:06:12.957]   - Field: ‘asynchronous’
[16:06:12.957]   - Field: ‘calls’
[16:06:12.957]   - Field: ‘globals’
[16:06:12.957]   - Field: ‘stdout’
[16:06:12.957]   - Field: ‘earlySignal’
[16:06:12.957]   - Field: ‘lazy’
[16:06:12.957]   - Field: ‘state’
[16:06:12.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:12.957] - Launch lazy future ...
[16:06:12.958] Packages needed by the future expression (n = 0): <none>
[16:06:12.958] Packages needed by future strategies (n = 0): <none>
[16:06:12.958] {
[16:06:12.958]     {
[16:06:12.958]         {
[16:06:12.958]             ...future.startTime <- base::Sys.time()
[16:06:12.958]             {
[16:06:12.958]                 {
[16:06:12.958]                   {
[16:06:12.958]                     {
[16:06:12.958]                       base::local({
[16:06:12.958]                         has_future <- base::requireNamespace("future", 
[16:06:12.958]                           quietly = TRUE)
[16:06:12.958]                         if (has_future) {
[16:06:12.958]                           ns <- base::getNamespace("future")
[16:06:12.958]                           version <- ns[[".package"]][["version"]]
[16:06:12.958]                           if (is.null(version)) 
[16:06:12.958]                             version <- utils::packageVersion("future")
[16:06:12.958]                         }
[16:06:12.958]                         else {
[16:06:12.958]                           version <- NULL
[16:06:12.958]                         }
[16:06:12.958]                         if (!has_future || version < "1.8.0") {
[16:06:12.958]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:12.958]                             "", base::R.version$version.string), 
[16:06:12.958]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:12.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:12.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:12.958]                               "release", "version")], collapse = " "), 
[16:06:12.958]                             hostname = base::Sys.info()[["nodename"]])
[16:06:12.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:12.958]                             info)
[16:06:12.958]                           info <- base::paste(info, collapse = "; ")
[16:06:12.958]                           if (!has_future) {
[16:06:12.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:12.958]                               info)
[16:06:12.958]                           }
[16:06:12.958]                           else {
[16:06:12.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:12.958]                               info, version)
[16:06:12.958]                           }
[16:06:12.958]                           base::stop(msg)
[16:06:12.958]                         }
[16:06:12.958]                       })
[16:06:12.958]                     }
[16:06:12.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:12.958]                     base::options(mc.cores = 1L)
[16:06:12.958]                   }
[16:06:12.958]                   options(future.plan = NULL)
[16:06:12.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:12.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:12.958]                 }
[16:06:12.958]                 ...future.workdir <- getwd()
[16:06:12.958]             }
[16:06:12.958]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:12.958]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:12.958]         }
[16:06:12.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:12.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:12.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:12.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:12.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:12.958]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:12.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:12.958]             base::names(...future.oldOptions))
[16:06:12.958]     }
[16:06:12.958]     if (FALSE) {
[16:06:12.958]     }
[16:06:12.958]     else {
[16:06:12.958]         if (TRUE) {
[16:06:12.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:12.958]                 open = "w")
[16:06:12.958]         }
[16:06:12.958]         else {
[16:06:12.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:12.958]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:12.958]         }
[16:06:12.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:12.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:12.958]             base::sink(type = "output", split = FALSE)
[16:06:12.958]             base::close(...future.stdout)
[16:06:12.958]         }, add = TRUE)
[16:06:12.958]     }
[16:06:12.958]     ...future.frame <- base::sys.nframe()
[16:06:12.958]     ...future.conditions <- base::list()
[16:06:12.958]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:12.958]     if (FALSE) {
[16:06:12.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:12.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:12.958]     }
[16:06:12.958]     ...future.result <- base::tryCatch({
[16:06:12.958]         base::withCallingHandlers({
[16:06:12.958]             ...future.value <- base::withVisible(base::local({
[16:06:12.958]                 ...future.makeSendCondition <- base::local({
[16:06:12.958]                   sendCondition <- NULL
[16:06:12.958]                   function(frame = 1L) {
[16:06:12.958]                     if (is.function(sendCondition)) 
[16:06:12.958]                       return(sendCondition)
[16:06:12.958]                     ns <- getNamespace("parallel")
[16:06:12.958]                     if (exists("sendData", mode = "function", 
[16:06:12.958]                       envir = ns)) {
[16:06:12.958]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:12.958]                         envir = ns)
[16:06:12.958]                       envir <- sys.frame(frame)
[16:06:12.958]                       master <- NULL
[16:06:12.958]                       while (!identical(envir, .GlobalEnv) && 
[16:06:12.958]                         !identical(envir, emptyenv())) {
[16:06:12.958]                         if (exists("master", mode = "list", envir = envir, 
[16:06:12.958]                           inherits = FALSE)) {
[16:06:12.958]                           master <- get("master", mode = "list", 
[16:06:12.958]                             envir = envir, inherits = FALSE)
[16:06:12.958]                           if (inherits(master, c("SOCKnode", 
[16:06:12.958]                             "SOCK0node"))) {
[16:06:12.958]                             sendCondition <<- function(cond) {
[16:06:12.958]                               data <- list(type = "VALUE", value = cond, 
[16:06:12.958]                                 success = TRUE)
[16:06:12.958]                               parallel_sendData(master, data)
[16:06:12.958]                             }
[16:06:12.958]                             return(sendCondition)
[16:06:12.958]                           }
[16:06:12.958]                         }
[16:06:12.958]                         frame <- frame + 1L
[16:06:12.958]                         envir <- sys.frame(frame)
[16:06:12.958]                       }
[16:06:12.958]                     }
[16:06:12.958]                     sendCondition <<- function(cond) NULL
[16:06:12.958]                   }
[16:06:12.958]                 })
[16:06:12.958]                 withCallingHandlers({
[16:06:12.958]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:12.958]                 }, immediateCondition = function(cond) {
[16:06:12.958]                   sendCondition <- ...future.makeSendCondition()
[16:06:12.958]                   sendCondition(cond)
[16:06:12.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:12.958]                   {
[16:06:12.958]                     inherits <- base::inherits
[16:06:12.958]                     invokeRestart <- base::invokeRestart
[16:06:12.958]                     is.null <- base::is.null
[16:06:12.958]                     muffled <- FALSE
[16:06:12.958]                     if (inherits(cond, "message")) {
[16:06:12.958]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:12.958]                       if (muffled) 
[16:06:12.958]                         invokeRestart("muffleMessage")
[16:06:12.958]                     }
[16:06:12.958]                     else if (inherits(cond, "warning")) {
[16:06:12.958]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:12.958]                       if (muffled) 
[16:06:12.958]                         invokeRestart("muffleWarning")
[16:06:12.958]                     }
[16:06:12.958]                     else if (inherits(cond, "condition")) {
[16:06:12.958]                       if (!is.null(pattern)) {
[16:06:12.958]                         computeRestarts <- base::computeRestarts
[16:06:12.958]                         grepl <- base::grepl
[16:06:12.958]                         restarts <- computeRestarts(cond)
[16:06:12.958]                         for (restart in restarts) {
[16:06:12.958]                           name <- restart$name
[16:06:12.958]                           if (is.null(name)) 
[16:06:12.958]                             next
[16:06:12.958]                           if (!grepl(pattern, name)) 
[16:06:12.958]                             next
[16:06:12.958]                           invokeRestart(restart)
[16:06:12.958]                           muffled <- TRUE
[16:06:12.958]                           break
[16:06:12.958]                         }
[16:06:12.958]                       }
[16:06:12.958]                     }
[16:06:12.958]                     invisible(muffled)
[16:06:12.958]                   }
[16:06:12.958]                   muffleCondition(cond)
[16:06:12.958]                 })
[16:06:12.958]             }))
[16:06:12.958]             future::FutureResult(value = ...future.value$value, 
[16:06:12.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:12.958]                   ...future.rng), globalenv = if (FALSE) 
[16:06:12.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:12.958]                     ...future.globalenv.names))
[16:06:12.958]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:12.958]         }, condition = base::local({
[16:06:12.958]             c <- base::c
[16:06:12.958]             inherits <- base::inherits
[16:06:12.958]             invokeRestart <- base::invokeRestart
[16:06:12.958]             length <- base::length
[16:06:12.958]             list <- base::list
[16:06:12.958]             seq.int <- base::seq.int
[16:06:12.958]             signalCondition <- base::signalCondition
[16:06:12.958]             sys.calls <- base::sys.calls
[16:06:12.958]             `[[` <- base::`[[`
[16:06:12.958]             `+` <- base::`+`
[16:06:12.958]             `<<-` <- base::`<<-`
[16:06:12.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:12.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:12.958]                   3L)]
[16:06:12.958]             }
[16:06:12.958]             function(cond) {
[16:06:12.958]                 is_error <- inherits(cond, "error")
[16:06:12.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:12.958]                   NULL)
[16:06:12.958]                 if (is_error) {
[16:06:12.958]                   sessionInformation <- function() {
[16:06:12.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:12.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:12.958]                       search = base::search(), system = base::Sys.info())
[16:06:12.958]                   }
[16:06:12.958]                   ...future.conditions[[length(...future.conditions) + 
[16:06:12.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:12.958]                     cond$call), session = sessionInformation(), 
[16:06:12.958]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:12.958]                   signalCondition(cond)
[16:06:12.958]                 }
[16:06:12.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:12.958]                 "immediateCondition"))) {
[16:06:12.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:12.958]                   ...future.conditions[[length(...future.conditions) + 
[16:06:12.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:12.958]                   if (TRUE && !signal) {
[16:06:12.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:12.958]                     {
[16:06:12.958]                       inherits <- base::inherits
[16:06:12.958]                       invokeRestart <- base::invokeRestart
[16:06:12.958]                       is.null <- base::is.null
[16:06:12.958]                       muffled <- FALSE
[16:06:12.958]                       if (inherits(cond, "message")) {
[16:06:12.958]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:12.958]                         if (muffled) 
[16:06:12.958]                           invokeRestart("muffleMessage")
[16:06:12.958]                       }
[16:06:12.958]                       else if (inherits(cond, "warning")) {
[16:06:12.958]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:12.958]                         if (muffled) 
[16:06:12.958]                           invokeRestart("muffleWarning")
[16:06:12.958]                       }
[16:06:12.958]                       else if (inherits(cond, "condition")) {
[16:06:12.958]                         if (!is.null(pattern)) {
[16:06:12.958]                           computeRestarts <- base::computeRestarts
[16:06:12.958]                           grepl <- base::grepl
[16:06:12.958]                           restarts <- computeRestarts(cond)
[16:06:12.958]                           for (restart in restarts) {
[16:06:12.958]                             name <- restart$name
[16:06:12.958]                             if (is.null(name)) 
[16:06:12.958]                               next
[16:06:12.958]                             if (!grepl(pattern, name)) 
[16:06:12.958]                               next
[16:06:12.958]                             invokeRestart(restart)
[16:06:12.958]                             muffled <- TRUE
[16:06:12.958]                             break
[16:06:12.958]                           }
[16:06:12.958]                         }
[16:06:12.958]                       }
[16:06:12.958]                       invisible(muffled)
[16:06:12.958]                     }
[16:06:12.958]                     muffleCondition(cond, pattern = "^muffle")
[16:06:12.958]                   }
[16:06:12.958]                 }
[16:06:12.958]                 else {
[16:06:12.958]                   if (TRUE) {
[16:06:12.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:12.958]                     {
[16:06:12.958]                       inherits <- base::inherits
[16:06:12.958]                       invokeRestart <- base::invokeRestart
[16:06:12.958]                       is.null <- base::is.null
[16:06:12.958]                       muffled <- FALSE
[16:06:12.958]                       if (inherits(cond, "message")) {
[16:06:12.958]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:12.958]                         if (muffled) 
[16:06:12.958]                           invokeRestart("muffleMessage")
[16:06:12.958]                       }
[16:06:12.958]                       else if (inherits(cond, "warning")) {
[16:06:12.958]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:12.958]                         if (muffled) 
[16:06:12.958]                           invokeRestart("muffleWarning")
[16:06:12.958]                       }
[16:06:12.958]                       else if (inherits(cond, "condition")) {
[16:06:12.958]                         if (!is.null(pattern)) {
[16:06:12.958]                           computeRestarts <- base::computeRestarts
[16:06:12.958]                           grepl <- base::grepl
[16:06:12.958]                           restarts <- computeRestarts(cond)
[16:06:12.958]                           for (restart in restarts) {
[16:06:12.958]                             name <- restart$name
[16:06:12.958]                             if (is.null(name)) 
[16:06:12.958]                               next
[16:06:12.958]                             if (!grepl(pattern, name)) 
[16:06:12.958]                               next
[16:06:12.958]                             invokeRestart(restart)
[16:06:12.958]                             muffled <- TRUE
[16:06:12.958]                             break
[16:06:12.958]                           }
[16:06:12.958]                         }
[16:06:12.958]                       }
[16:06:12.958]                       invisible(muffled)
[16:06:12.958]                     }
[16:06:12.958]                     muffleCondition(cond, pattern = "^muffle")
[16:06:12.958]                   }
[16:06:12.958]                 }
[16:06:12.958]             }
[16:06:12.958]         }))
[16:06:12.958]     }, error = function(ex) {
[16:06:12.958]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:12.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:12.958]                 ...future.rng), started = ...future.startTime, 
[16:06:12.958]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:12.958]             version = "1.8"), class = "FutureResult")
[16:06:12.958]     }, finally = {
[16:06:12.958]         if (!identical(...future.workdir, getwd())) 
[16:06:12.958]             setwd(...future.workdir)
[16:06:12.958]         {
[16:06:12.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:12.958]                 ...future.oldOptions$nwarnings <- NULL
[16:06:12.958]             }
[16:06:12.958]             base::options(...future.oldOptions)
[16:06:12.958]             if (.Platform$OS.type == "windows") {
[16:06:12.958]                 old_names <- names(...future.oldEnvVars)
[16:06:12.958]                 envs <- base::Sys.getenv()
[16:06:12.958]                 names <- names(envs)
[16:06:12.958]                 common <- intersect(names, old_names)
[16:06:12.958]                 added <- setdiff(names, old_names)
[16:06:12.958]                 removed <- setdiff(old_names, names)
[16:06:12.958]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:12.958]                   envs[common]]
[16:06:12.958]                 NAMES <- toupper(changed)
[16:06:12.958]                 args <- list()
[16:06:12.958]                 for (kk in seq_along(NAMES)) {
[16:06:12.958]                   name <- changed[[kk]]
[16:06:12.958]                   NAME <- NAMES[[kk]]
[16:06:12.958]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:12.958]                     next
[16:06:12.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:12.958]                 }
[16:06:12.958]                 NAMES <- toupper(added)
[16:06:12.958]                 for (kk in seq_along(NAMES)) {
[16:06:12.958]                   name <- added[[kk]]
[16:06:12.958]                   NAME <- NAMES[[kk]]
[16:06:12.958]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:12.958]                     next
[16:06:12.958]                   args[[name]] <- ""
[16:06:12.958]                 }
[16:06:12.958]                 NAMES <- toupper(removed)
[16:06:12.958]                 for (kk in seq_along(NAMES)) {
[16:06:12.958]                   name <- removed[[kk]]
[16:06:12.958]                   NAME <- NAMES[[kk]]
[16:06:12.958]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:12.958]                     next
[16:06:12.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:12.958]                 }
[16:06:12.958]                 if (length(args) > 0) 
[16:06:12.958]                   base::do.call(base::Sys.setenv, args = args)
[16:06:12.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:12.958]             }
[16:06:12.958]             else {
[16:06:12.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:12.958]             }
[16:06:12.958]             {
[16:06:12.958]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:12.958]                   0L) {
[16:06:12.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:12.958]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:12.958]                   base::options(opts)
[16:06:12.958]                 }
[16:06:12.958]                 {
[16:06:12.958]                   {
[16:06:12.958]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:12.958]                     NULL
[16:06:12.958]                   }
[16:06:12.958]                   options(future.plan = NULL)
[16:06:12.958]                   if (is.na(NA_character_)) 
[16:06:12.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:12.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:12.958]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:12.958]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:12.958]                     envir = parent.frame()) 
[16:06:12.958]                   {
[16:06:12.958]                     if (is.function(workers)) 
[16:06:12.958]                       workers <- workers()
[16:06:12.958]                     workers <- structure(as.integer(workers), 
[16:06:12.958]                       class = class(workers))
[16:06:12.958]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:12.958]                       workers >= 1)
[16:06:12.958]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:12.958]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:12.958]                     }
[16:06:12.958]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:12.958]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:12.958]                       envir = envir)
[16:06:12.958]                     if (!future$lazy) 
[16:06:12.958]                       future <- run(future)
[16:06:12.958]                     invisible(future)
[16:06:12.958]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:12.958]                 }
[16:06:12.958]             }
[16:06:12.958]         }
[16:06:12.958]     })
[16:06:12.958]     if (TRUE) {
[16:06:12.958]         base::sink(type = "output", split = FALSE)
[16:06:12.958]         if (TRUE) {
[16:06:12.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:12.958]         }
[16:06:12.958]         else {
[16:06:12.958]             ...future.result["stdout"] <- base::list(NULL)
[16:06:12.958]         }
[16:06:12.958]         base::close(...future.stdout)
[16:06:12.958]         ...future.stdout <- NULL
[16:06:12.958]     }
[16:06:12.958]     ...future.result$conditions <- ...future.conditions
[16:06:12.958]     ...future.result$finished <- base::Sys.time()
[16:06:12.958]     ...future.result
[16:06:12.958] }
[16:06:12.961] MultisessionFuture started
[16:06:12.961] - Launch lazy future ... done
[16:06:12.961] run() for ‘MultisessionFuture’ ... done
[16:06:13.008] receiveMessageFromWorker() for ClusterFuture ...
[16:06:13.008] - Validating connection of MultisessionFuture
[16:06:13.008] - received message: FutureResult
[16:06:13.008] - Received FutureResult
[16:06:13.009] - Erased future from FutureRegistry
[16:06:13.009] result() for ClusterFuture ...
[16:06:13.009] - result already collected: FutureResult
[16:06:13.009] result() for ClusterFuture ... done
[16:06:13.009] signalConditions() ...
[16:06:13.009]  - include = ‘immediateCondition’
[16:06:13.009]  - exclude = 
[16:06:13.009]  - resignal = FALSE
[16:06:13.009]  - Number of conditions: 1
[16:06:13.009] signalConditions() ... done
[16:06:13.010] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:13.010] A MultisessionFuture was resolved
[16:06:13.010] getGlobalsAndPackages() ...
[16:06:13.010] Searching for globals...
[16:06:13.010] - globals found: [2] ‘list’, ‘stop’
[16:06:13.011] Searching for globals ... DONE
[16:06:13.011] Resolving globals: FALSE
[16:06:13.011] 
[16:06:13.011] 
[16:06:13.011] getGlobalsAndPackages() ... DONE
[16:06:13.011] run() for ‘Future’ ...
[16:06:13.012] - state: ‘created’
[16:06:13.012] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:13.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:13.026] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:13.026]   - Field: ‘node’
[16:06:13.026]   - Field: ‘label’
[16:06:13.026]   - Field: ‘local’
[16:06:13.026]   - Field: ‘owner’
[16:06:13.026]   - Field: ‘envir’
[16:06:13.026]   - Field: ‘workers’
[16:06:13.026]   - Field: ‘packages’
[16:06:13.026]   - Field: ‘gc’
[16:06:13.026]   - Field: ‘conditions’
[16:06:13.026]   - Field: ‘persistent’
[16:06:13.027]   - Field: ‘expr’
[16:06:13.027]   - Field: ‘uuid’
[16:06:13.027]   - Field: ‘seed’
[16:06:13.027]   - Field: ‘version’
[16:06:13.027]   - Field: ‘result’
[16:06:13.027]   - Field: ‘asynchronous’
[16:06:13.027]   - Field: ‘calls’
[16:06:13.027]   - Field: ‘globals’
[16:06:13.027]   - Field: ‘stdout’
[16:06:13.027]   - Field: ‘earlySignal’
[16:06:13.028]   - Field: ‘lazy’
[16:06:13.028]   - Field: ‘state’
[16:06:13.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:13.028] - Launch lazy future ...
[16:06:13.028] Packages needed by the future expression (n = 0): <none>
[16:06:13.028] Packages needed by future strategies (n = 0): <none>
[16:06:13.029] {
[16:06:13.029]     {
[16:06:13.029]         {
[16:06:13.029]             ...future.startTime <- base::Sys.time()
[16:06:13.029]             {
[16:06:13.029]                 {
[16:06:13.029]                   {
[16:06:13.029]                     {
[16:06:13.029]                       base::local({
[16:06:13.029]                         has_future <- base::requireNamespace("future", 
[16:06:13.029]                           quietly = TRUE)
[16:06:13.029]                         if (has_future) {
[16:06:13.029]                           ns <- base::getNamespace("future")
[16:06:13.029]                           version <- ns[[".package"]][["version"]]
[16:06:13.029]                           if (is.null(version)) 
[16:06:13.029]                             version <- utils::packageVersion("future")
[16:06:13.029]                         }
[16:06:13.029]                         else {
[16:06:13.029]                           version <- NULL
[16:06:13.029]                         }
[16:06:13.029]                         if (!has_future || version < "1.8.0") {
[16:06:13.029]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:13.029]                             "", base::R.version$version.string), 
[16:06:13.029]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:13.029]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:13.029]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:13.029]                               "release", "version")], collapse = " "), 
[16:06:13.029]                             hostname = base::Sys.info()[["nodename"]])
[16:06:13.029]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:13.029]                             info)
[16:06:13.029]                           info <- base::paste(info, collapse = "; ")
[16:06:13.029]                           if (!has_future) {
[16:06:13.029]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:13.029]                               info)
[16:06:13.029]                           }
[16:06:13.029]                           else {
[16:06:13.029]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:13.029]                               info, version)
[16:06:13.029]                           }
[16:06:13.029]                           base::stop(msg)
[16:06:13.029]                         }
[16:06:13.029]                       })
[16:06:13.029]                     }
[16:06:13.029]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:13.029]                     base::options(mc.cores = 1L)
[16:06:13.029]                   }
[16:06:13.029]                   options(future.plan = NULL)
[16:06:13.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:13.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:13.029]                 }
[16:06:13.029]                 ...future.workdir <- getwd()
[16:06:13.029]             }
[16:06:13.029]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:13.029]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:13.029]         }
[16:06:13.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:13.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:13.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:13.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:13.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:13.029]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:13.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:13.029]             base::names(...future.oldOptions))
[16:06:13.029]     }
[16:06:13.029]     if (FALSE) {
[16:06:13.029]     }
[16:06:13.029]     else {
[16:06:13.029]         if (TRUE) {
[16:06:13.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:13.029]                 open = "w")
[16:06:13.029]         }
[16:06:13.029]         else {
[16:06:13.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:13.029]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:13.029]         }
[16:06:13.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:13.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:13.029]             base::sink(type = "output", split = FALSE)
[16:06:13.029]             base::close(...future.stdout)
[16:06:13.029]         }, add = TRUE)
[16:06:13.029]     }
[16:06:13.029]     ...future.frame <- base::sys.nframe()
[16:06:13.029]     ...future.conditions <- base::list()
[16:06:13.029]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:13.029]     if (FALSE) {
[16:06:13.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:13.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:13.029]     }
[16:06:13.029]     ...future.result <- base::tryCatch({
[16:06:13.029]         base::withCallingHandlers({
[16:06:13.029]             ...future.value <- base::withVisible(base::local({
[16:06:13.029]                 ...future.makeSendCondition <- base::local({
[16:06:13.029]                   sendCondition <- NULL
[16:06:13.029]                   function(frame = 1L) {
[16:06:13.029]                     if (is.function(sendCondition)) 
[16:06:13.029]                       return(sendCondition)
[16:06:13.029]                     ns <- getNamespace("parallel")
[16:06:13.029]                     if (exists("sendData", mode = "function", 
[16:06:13.029]                       envir = ns)) {
[16:06:13.029]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:13.029]                         envir = ns)
[16:06:13.029]                       envir <- sys.frame(frame)
[16:06:13.029]                       master <- NULL
[16:06:13.029]                       while (!identical(envir, .GlobalEnv) && 
[16:06:13.029]                         !identical(envir, emptyenv())) {
[16:06:13.029]                         if (exists("master", mode = "list", envir = envir, 
[16:06:13.029]                           inherits = FALSE)) {
[16:06:13.029]                           master <- get("master", mode = "list", 
[16:06:13.029]                             envir = envir, inherits = FALSE)
[16:06:13.029]                           if (inherits(master, c("SOCKnode", 
[16:06:13.029]                             "SOCK0node"))) {
[16:06:13.029]                             sendCondition <<- function(cond) {
[16:06:13.029]                               data <- list(type = "VALUE", value = cond, 
[16:06:13.029]                                 success = TRUE)
[16:06:13.029]                               parallel_sendData(master, data)
[16:06:13.029]                             }
[16:06:13.029]                             return(sendCondition)
[16:06:13.029]                           }
[16:06:13.029]                         }
[16:06:13.029]                         frame <- frame + 1L
[16:06:13.029]                         envir <- sys.frame(frame)
[16:06:13.029]                       }
[16:06:13.029]                     }
[16:06:13.029]                     sendCondition <<- function(cond) NULL
[16:06:13.029]                   }
[16:06:13.029]                 })
[16:06:13.029]                 withCallingHandlers({
[16:06:13.029]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:13.029]                 }, immediateCondition = function(cond) {
[16:06:13.029]                   sendCondition <- ...future.makeSendCondition()
[16:06:13.029]                   sendCondition(cond)
[16:06:13.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.029]                   {
[16:06:13.029]                     inherits <- base::inherits
[16:06:13.029]                     invokeRestart <- base::invokeRestart
[16:06:13.029]                     is.null <- base::is.null
[16:06:13.029]                     muffled <- FALSE
[16:06:13.029]                     if (inherits(cond, "message")) {
[16:06:13.029]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:13.029]                       if (muffled) 
[16:06:13.029]                         invokeRestart("muffleMessage")
[16:06:13.029]                     }
[16:06:13.029]                     else if (inherits(cond, "warning")) {
[16:06:13.029]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:13.029]                       if (muffled) 
[16:06:13.029]                         invokeRestart("muffleWarning")
[16:06:13.029]                     }
[16:06:13.029]                     else if (inherits(cond, "condition")) {
[16:06:13.029]                       if (!is.null(pattern)) {
[16:06:13.029]                         computeRestarts <- base::computeRestarts
[16:06:13.029]                         grepl <- base::grepl
[16:06:13.029]                         restarts <- computeRestarts(cond)
[16:06:13.029]                         for (restart in restarts) {
[16:06:13.029]                           name <- restart$name
[16:06:13.029]                           if (is.null(name)) 
[16:06:13.029]                             next
[16:06:13.029]                           if (!grepl(pattern, name)) 
[16:06:13.029]                             next
[16:06:13.029]                           invokeRestart(restart)
[16:06:13.029]                           muffled <- TRUE
[16:06:13.029]                           break
[16:06:13.029]                         }
[16:06:13.029]                       }
[16:06:13.029]                     }
[16:06:13.029]                     invisible(muffled)
[16:06:13.029]                   }
[16:06:13.029]                   muffleCondition(cond)
[16:06:13.029]                 })
[16:06:13.029]             }))
[16:06:13.029]             future::FutureResult(value = ...future.value$value, 
[16:06:13.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:13.029]                   ...future.rng), globalenv = if (FALSE) 
[16:06:13.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:13.029]                     ...future.globalenv.names))
[16:06:13.029]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:13.029]         }, condition = base::local({
[16:06:13.029]             c <- base::c
[16:06:13.029]             inherits <- base::inherits
[16:06:13.029]             invokeRestart <- base::invokeRestart
[16:06:13.029]             length <- base::length
[16:06:13.029]             list <- base::list
[16:06:13.029]             seq.int <- base::seq.int
[16:06:13.029]             signalCondition <- base::signalCondition
[16:06:13.029]             sys.calls <- base::sys.calls
[16:06:13.029]             `[[` <- base::`[[`
[16:06:13.029]             `+` <- base::`+`
[16:06:13.029]             `<<-` <- base::`<<-`
[16:06:13.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:13.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:13.029]                   3L)]
[16:06:13.029]             }
[16:06:13.029]             function(cond) {
[16:06:13.029]                 is_error <- inherits(cond, "error")
[16:06:13.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:13.029]                   NULL)
[16:06:13.029]                 if (is_error) {
[16:06:13.029]                   sessionInformation <- function() {
[16:06:13.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:13.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:13.029]                       search = base::search(), system = base::Sys.info())
[16:06:13.029]                   }
[16:06:13.029]                   ...future.conditions[[length(...future.conditions) + 
[16:06:13.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:13.029]                     cond$call), session = sessionInformation(), 
[16:06:13.029]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:13.029]                   signalCondition(cond)
[16:06:13.029]                 }
[16:06:13.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:13.029]                 "immediateCondition"))) {
[16:06:13.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:13.029]                   ...future.conditions[[length(...future.conditions) + 
[16:06:13.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:13.029]                   if (TRUE && !signal) {
[16:06:13.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.029]                     {
[16:06:13.029]                       inherits <- base::inherits
[16:06:13.029]                       invokeRestart <- base::invokeRestart
[16:06:13.029]                       is.null <- base::is.null
[16:06:13.029]                       muffled <- FALSE
[16:06:13.029]                       if (inherits(cond, "message")) {
[16:06:13.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:13.029]                         if (muffled) 
[16:06:13.029]                           invokeRestart("muffleMessage")
[16:06:13.029]                       }
[16:06:13.029]                       else if (inherits(cond, "warning")) {
[16:06:13.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:13.029]                         if (muffled) 
[16:06:13.029]                           invokeRestart("muffleWarning")
[16:06:13.029]                       }
[16:06:13.029]                       else if (inherits(cond, "condition")) {
[16:06:13.029]                         if (!is.null(pattern)) {
[16:06:13.029]                           computeRestarts <- base::computeRestarts
[16:06:13.029]                           grepl <- base::grepl
[16:06:13.029]                           restarts <- computeRestarts(cond)
[16:06:13.029]                           for (restart in restarts) {
[16:06:13.029]                             name <- restart$name
[16:06:13.029]                             if (is.null(name)) 
[16:06:13.029]                               next
[16:06:13.029]                             if (!grepl(pattern, name)) 
[16:06:13.029]                               next
[16:06:13.029]                             invokeRestart(restart)
[16:06:13.029]                             muffled <- TRUE
[16:06:13.029]                             break
[16:06:13.029]                           }
[16:06:13.029]                         }
[16:06:13.029]                       }
[16:06:13.029]                       invisible(muffled)
[16:06:13.029]                     }
[16:06:13.029]                     muffleCondition(cond, pattern = "^muffle")
[16:06:13.029]                   }
[16:06:13.029]                 }
[16:06:13.029]                 else {
[16:06:13.029]                   if (TRUE) {
[16:06:13.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.029]                     {
[16:06:13.029]                       inherits <- base::inherits
[16:06:13.029]                       invokeRestart <- base::invokeRestart
[16:06:13.029]                       is.null <- base::is.null
[16:06:13.029]                       muffled <- FALSE
[16:06:13.029]                       if (inherits(cond, "message")) {
[16:06:13.029]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:13.029]                         if (muffled) 
[16:06:13.029]                           invokeRestart("muffleMessage")
[16:06:13.029]                       }
[16:06:13.029]                       else if (inherits(cond, "warning")) {
[16:06:13.029]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:13.029]                         if (muffled) 
[16:06:13.029]                           invokeRestart("muffleWarning")
[16:06:13.029]                       }
[16:06:13.029]                       else if (inherits(cond, "condition")) {
[16:06:13.029]                         if (!is.null(pattern)) {
[16:06:13.029]                           computeRestarts <- base::computeRestarts
[16:06:13.029]                           grepl <- base::grepl
[16:06:13.029]                           restarts <- computeRestarts(cond)
[16:06:13.029]                           for (restart in restarts) {
[16:06:13.029]                             name <- restart$name
[16:06:13.029]                             if (is.null(name)) 
[16:06:13.029]                               next
[16:06:13.029]                             if (!grepl(pattern, name)) 
[16:06:13.029]                               next
[16:06:13.029]                             invokeRestart(restart)
[16:06:13.029]                             muffled <- TRUE
[16:06:13.029]                             break
[16:06:13.029]                           }
[16:06:13.029]                         }
[16:06:13.029]                       }
[16:06:13.029]                       invisible(muffled)
[16:06:13.029]                     }
[16:06:13.029]                     muffleCondition(cond, pattern = "^muffle")
[16:06:13.029]                   }
[16:06:13.029]                 }
[16:06:13.029]             }
[16:06:13.029]         }))
[16:06:13.029]     }, error = function(ex) {
[16:06:13.029]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:13.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:13.029]                 ...future.rng), started = ...future.startTime, 
[16:06:13.029]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:13.029]             version = "1.8"), class = "FutureResult")
[16:06:13.029]     }, finally = {
[16:06:13.029]         if (!identical(...future.workdir, getwd())) 
[16:06:13.029]             setwd(...future.workdir)
[16:06:13.029]         {
[16:06:13.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:13.029]                 ...future.oldOptions$nwarnings <- NULL
[16:06:13.029]             }
[16:06:13.029]             base::options(...future.oldOptions)
[16:06:13.029]             if (.Platform$OS.type == "windows") {
[16:06:13.029]                 old_names <- names(...future.oldEnvVars)
[16:06:13.029]                 envs <- base::Sys.getenv()
[16:06:13.029]                 names <- names(envs)
[16:06:13.029]                 common <- intersect(names, old_names)
[16:06:13.029]                 added <- setdiff(names, old_names)
[16:06:13.029]                 removed <- setdiff(old_names, names)
[16:06:13.029]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:13.029]                   envs[common]]
[16:06:13.029]                 NAMES <- toupper(changed)
[16:06:13.029]                 args <- list()
[16:06:13.029]                 for (kk in seq_along(NAMES)) {
[16:06:13.029]                   name <- changed[[kk]]
[16:06:13.029]                   NAME <- NAMES[[kk]]
[16:06:13.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.029]                     next
[16:06:13.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:13.029]                 }
[16:06:13.029]                 NAMES <- toupper(added)
[16:06:13.029]                 for (kk in seq_along(NAMES)) {
[16:06:13.029]                   name <- added[[kk]]
[16:06:13.029]                   NAME <- NAMES[[kk]]
[16:06:13.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.029]                     next
[16:06:13.029]                   args[[name]] <- ""
[16:06:13.029]                 }
[16:06:13.029]                 NAMES <- toupper(removed)
[16:06:13.029]                 for (kk in seq_along(NAMES)) {
[16:06:13.029]                   name <- removed[[kk]]
[16:06:13.029]                   NAME <- NAMES[[kk]]
[16:06:13.029]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.029]                     next
[16:06:13.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:13.029]                 }
[16:06:13.029]                 if (length(args) > 0) 
[16:06:13.029]                   base::do.call(base::Sys.setenv, args = args)
[16:06:13.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:13.029]             }
[16:06:13.029]             else {
[16:06:13.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:13.029]             }
[16:06:13.029]             {
[16:06:13.029]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:13.029]                   0L) {
[16:06:13.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:13.029]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:13.029]                   base::options(opts)
[16:06:13.029]                 }
[16:06:13.029]                 {
[16:06:13.029]                   {
[16:06:13.029]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:13.029]                     NULL
[16:06:13.029]                   }
[16:06:13.029]                   options(future.plan = NULL)
[16:06:13.029]                   if (is.na(NA_character_)) 
[16:06:13.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:13.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:13.029]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:13.029]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:13.029]                     envir = parent.frame()) 
[16:06:13.029]                   {
[16:06:13.029]                     if (is.function(workers)) 
[16:06:13.029]                       workers <- workers()
[16:06:13.029]                     workers <- structure(as.integer(workers), 
[16:06:13.029]                       class = class(workers))
[16:06:13.029]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:13.029]                       workers >= 1)
[16:06:13.029]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:13.029]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:13.029]                     }
[16:06:13.029]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:13.029]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:13.029]                       envir = envir)
[16:06:13.029]                     if (!future$lazy) 
[16:06:13.029]                       future <- run(future)
[16:06:13.029]                     invisible(future)
[16:06:13.029]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:13.029]                 }
[16:06:13.029]             }
[16:06:13.029]         }
[16:06:13.029]     })
[16:06:13.029]     if (TRUE) {
[16:06:13.029]         base::sink(type = "output", split = FALSE)
[16:06:13.029]         if (TRUE) {
[16:06:13.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:13.029]         }
[16:06:13.029]         else {
[16:06:13.029]             ...future.result["stdout"] <- base::list(NULL)
[16:06:13.029]         }
[16:06:13.029]         base::close(...future.stdout)
[16:06:13.029]         ...future.stdout <- NULL
[16:06:13.029]     }
[16:06:13.029]     ...future.result$conditions <- ...future.conditions
[16:06:13.029]     ...future.result$finished <- base::Sys.time()
[16:06:13.029]     ...future.result
[16:06:13.029] }
[16:06:13.032] MultisessionFuture started
[16:06:13.032] - Launch lazy future ... done
[16:06:13.032] run() for ‘MultisessionFuture’ ... done
[16:06:13.081] receiveMessageFromWorker() for ClusterFuture ...
[16:06:13.081] - Validating connection of MultisessionFuture
[16:06:13.082] - received message: FutureResult
[16:06:13.082] - Received FutureResult
[16:06:13.083] - Erased future from FutureRegistry
[16:06:13.083] result() for ClusterFuture ...
[16:06:13.083] - result already collected: FutureResult
[16:06:13.083] result() for ClusterFuture ... done
[16:06:13.083] signalConditions() ...
[16:06:13.084]  - include = ‘immediateCondition’
[16:06:13.084]  - exclude = 
[16:06:13.084]  - resignal = FALSE
[16:06:13.084]  - Number of conditions: 1
[16:06:13.084] signalConditions() ... done
[16:06:13.084] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:13.085] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[16:06:13.085] getGlobalsAndPackages() ...
[16:06:13.085] Searching for globals...
[16:06:13.087] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:13.087] Searching for globals ... DONE
[16:06:13.088] Resolving globals: FALSE
[16:06:13.088] 
[16:06:13.088] 
[16:06:13.089] getGlobalsAndPackages() ... DONE
[16:06:13.089] run() for ‘Future’ ...
[16:06:13.089] - state: ‘created’
[16:06:13.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:13.104] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:13.104] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:13.104]   - Field: ‘node’
[16:06:13.105]   - Field: ‘label’
[16:06:13.105]   - Field: ‘local’
[16:06:13.105]   - Field: ‘owner’
[16:06:13.105]   - Field: ‘envir’
[16:06:13.105]   - Field: ‘workers’
[16:06:13.105]   - Field: ‘packages’
[16:06:13.105]   - Field: ‘gc’
[16:06:13.105]   - Field: ‘conditions’
[16:06:13.105]   - Field: ‘persistent’
[16:06:13.105]   - Field: ‘expr’
[16:06:13.105]   - Field: ‘uuid’
[16:06:13.106]   - Field: ‘seed’
[16:06:13.106]   - Field: ‘version’
[16:06:13.106]   - Field: ‘result’
[16:06:13.106]   - Field: ‘asynchronous’
[16:06:13.106]   - Field: ‘calls’
[16:06:13.106]   - Field: ‘globals’
[16:06:13.106]   - Field: ‘stdout’
[16:06:13.106]   - Field: ‘earlySignal’
[16:06:13.106]   - Field: ‘lazy’
[16:06:13.106]   - Field: ‘state’
[16:06:13.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:13.107] - Launch lazy future ...
[16:06:13.107] Packages needed by the future expression (n = 0): <none>
[16:06:13.107] Packages needed by future strategies (n = 0): <none>
[16:06:13.107] {
[16:06:13.107]     {
[16:06:13.107]         {
[16:06:13.107]             ...future.startTime <- base::Sys.time()
[16:06:13.107]             {
[16:06:13.107]                 {
[16:06:13.107]                   {
[16:06:13.107]                     {
[16:06:13.107]                       base::local({
[16:06:13.107]                         has_future <- base::requireNamespace("future", 
[16:06:13.107]                           quietly = TRUE)
[16:06:13.107]                         if (has_future) {
[16:06:13.107]                           ns <- base::getNamespace("future")
[16:06:13.107]                           version <- ns[[".package"]][["version"]]
[16:06:13.107]                           if (is.null(version)) 
[16:06:13.107]                             version <- utils::packageVersion("future")
[16:06:13.107]                         }
[16:06:13.107]                         else {
[16:06:13.107]                           version <- NULL
[16:06:13.107]                         }
[16:06:13.107]                         if (!has_future || version < "1.8.0") {
[16:06:13.107]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:13.107]                             "", base::R.version$version.string), 
[16:06:13.107]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:13.107]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:13.107]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:13.107]                               "release", "version")], collapse = " "), 
[16:06:13.107]                             hostname = base::Sys.info()[["nodename"]])
[16:06:13.107]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:13.107]                             info)
[16:06:13.107]                           info <- base::paste(info, collapse = "; ")
[16:06:13.107]                           if (!has_future) {
[16:06:13.107]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:13.107]                               info)
[16:06:13.107]                           }
[16:06:13.107]                           else {
[16:06:13.107]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:13.107]                               info, version)
[16:06:13.107]                           }
[16:06:13.107]                           base::stop(msg)
[16:06:13.107]                         }
[16:06:13.107]                       })
[16:06:13.107]                     }
[16:06:13.107]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:13.107]                     base::options(mc.cores = 1L)
[16:06:13.107]                   }
[16:06:13.107]                   options(future.plan = NULL)
[16:06:13.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:13.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:13.107]                 }
[16:06:13.107]                 ...future.workdir <- getwd()
[16:06:13.107]             }
[16:06:13.107]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:13.107]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:13.107]         }
[16:06:13.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:13.107]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:13.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:13.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:13.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:13.107]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:13.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:13.107]             base::names(...future.oldOptions))
[16:06:13.107]     }
[16:06:13.107]     if (FALSE) {
[16:06:13.107]     }
[16:06:13.107]     else {
[16:06:13.107]         if (TRUE) {
[16:06:13.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:13.107]                 open = "w")
[16:06:13.107]         }
[16:06:13.107]         else {
[16:06:13.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:13.107]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:13.107]         }
[16:06:13.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:13.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:13.107]             base::sink(type = "output", split = FALSE)
[16:06:13.107]             base::close(...future.stdout)
[16:06:13.107]         }, add = TRUE)
[16:06:13.107]     }
[16:06:13.107]     ...future.frame <- base::sys.nframe()
[16:06:13.107]     ...future.conditions <- base::list()
[16:06:13.107]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:13.107]     if (FALSE) {
[16:06:13.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:13.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:13.107]     }
[16:06:13.107]     ...future.result <- base::tryCatch({
[16:06:13.107]         base::withCallingHandlers({
[16:06:13.107]             ...future.value <- base::withVisible(base::local({
[16:06:13.107]                 ...future.makeSendCondition <- base::local({
[16:06:13.107]                   sendCondition <- NULL
[16:06:13.107]                   function(frame = 1L) {
[16:06:13.107]                     if (is.function(sendCondition)) 
[16:06:13.107]                       return(sendCondition)
[16:06:13.107]                     ns <- getNamespace("parallel")
[16:06:13.107]                     if (exists("sendData", mode = "function", 
[16:06:13.107]                       envir = ns)) {
[16:06:13.107]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:13.107]                         envir = ns)
[16:06:13.107]                       envir <- sys.frame(frame)
[16:06:13.107]                       master <- NULL
[16:06:13.107]                       while (!identical(envir, .GlobalEnv) && 
[16:06:13.107]                         !identical(envir, emptyenv())) {
[16:06:13.107]                         if (exists("master", mode = "list", envir = envir, 
[16:06:13.107]                           inherits = FALSE)) {
[16:06:13.107]                           master <- get("master", mode = "list", 
[16:06:13.107]                             envir = envir, inherits = FALSE)
[16:06:13.107]                           if (inherits(master, c("SOCKnode", 
[16:06:13.107]                             "SOCK0node"))) {
[16:06:13.107]                             sendCondition <<- function(cond) {
[16:06:13.107]                               data <- list(type = "VALUE", value = cond, 
[16:06:13.107]                                 success = TRUE)
[16:06:13.107]                               parallel_sendData(master, data)
[16:06:13.107]                             }
[16:06:13.107]                             return(sendCondition)
[16:06:13.107]                           }
[16:06:13.107]                         }
[16:06:13.107]                         frame <- frame + 1L
[16:06:13.107]                         envir <- sys.frame(frame)
[16:06:13.107]                       }
[16:06:13.107]                     }
[16:06:13.107]                     sendCondition <<- function(cond) NULL
[16:06:13.107]                   }
[16:06:13.107]                 })
[16:06:13.107]                 withCallingHandlers({
[16:06:13.107]                   {
[16:06:13.107]                     Sys.sleep(0.5)
[16:06:13.107]                     list(a = 1, b = 42L)
[16:06:13.107]                   }
[16:06:13.107]                 }, immediateCondition = function(cond) {
[16:06:13.107]                   sendCondition <- ...future.makeSendCondition()
[16:06:13.107]                   sendCondition(cond)
[16:06:13.107]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.107]                   {
[16:06:13.107]                     inherits <- base::inherits
[16:06:13.107]                     invokeRestart <- base::invokeRestart
[16:06:13.107]                     is.null <- base::is.null
[16:06:13.107]                     muffled <- FALSE
[16:06:13.107]                     if (inherits(cond, "message")) {
[16:06:13.107]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:13.107]                       if (muffled) 
[16:06:13.107]                         invokeRestart("muffleMessage")
[16:06:13.107]                     }
[16:06:13.107]                     else if (inherits(cond, "warning")) {
[16:06:13.107]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:13.107]                       if (muffled) 
[16:06:13.107]                         invokeRestart("muffleWarning")
[16:06:13.107]                     }
[16:06:13.107]                     else if (inherits(cond, "condition")) {
[16:06:13.107]                       if (!is.null(pattern)) {
[16:06:13.107]                         computeRestarts <- base::computeRestarts
[16:06:13.107]                         grepl <- base::grepl
[16:06:13.107]                         restarts <- computeRestarts(cond)
[16:06:13.107]                         for (restart in restarts) {
[16:06:13.107]                           name <- restart$name
[16:06:13.107]                           if (is.null(name)) 
[16:06:13.107]                             next
[16:06:13.107]                           if (!grepl(pattern, name)) 
[16:06:13.107]                             next
[16:06:13.107]                           invokeRestart(restart)
[16:06:13.107]                           muffled <- TRUE
[16:06:13.107]                           break
[16:06:13.107]                         }
[16:06:13.107]                       }
[16:06:13.107]                     }
[16:06:13.107]                     invisible(muffled)
[16:06:13.107]                   }
[16:06:13.107]                   muffleCondition(cond)
[16:06:13.107]                 })
[16:06:13.107]             }))
[16:06:13.107]             future::FutureResult(value = ...future.value$value, 
[16:06:13.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:13.107]                   ...future.rng), globalenv = if (FALSE) 
[16:06:13.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:13.107]                     ...future.globalenv.names))
[16:06:13.107]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:13.107]         }, condition = base::local({
[16:06:13.107]             c <- base::c
[16:06:13.107]             inherits <- base::inherits
[16:06:13.107]             invokeRestart <- base::invokeRestart
[16:06:13.107]             length <- base::length
[16:06:13.107]             list <- base::list
[16:06:13.107]             seq.int <- base::seq.int
[16:06:13.107]             signalCondition <- base::signalCondition
[16:06:13.107]             sys.calls <- base::sys.calls
[16:06:13.107]             `[[` <- base::`[[`
[16:06:13.107]             `+` <- base::`+`
[16:06:13.107]             `<<-` <- base::`<<-`
[16:06:13.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:13.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:13.107]                   3L)]
[16:06:13.107]             }
[16:06:13.107]             function(cond) {
[16:06:13.107]                 is_error <- inherits(cond, "error")
[16:06:13.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:13.107]                   NULL)
[16:06:13.107]                 if (is_error) {
[16:06:13.107]                   sessionInformation <- function() {
[16:06:13.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:13.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:13.107]                       search = base::search(), system = base::Sys.info())
[16:06:13.107]                   }
[16:06:13.107]                   ...future.conditions[[length(...future.conditions) + 
[16:06:13.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:13.107]                     cond$call), session = sessionInformation(), 
[16:06:13.107]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:13.107]                   signalCondition(cond)
[16:06:13.107]                 }
[16:06:13.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:13.107]                 "immediateCondition"))) {
[16:06:13.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:13.107]                   ...future.conditions[[length(...future.conditions) + 
[16:06:13.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:13.107]                   if (TRUE && !signal) {
[16:06:13.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.107]                     {
[16:06:13.107]                       inherits <- base::inherits
[16:06:13.107]                       invokeRestart <- base::invokeRestart
[16:06:13.107]                       is.null <- base::is.null
[16:06:13.107]                       muffled <- FALSE
[16:06:13.107]                       if (inherits(cond, "message")) {
[16:06:13.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:13.107]                         if (muffled) 
[16:06:13.107]                           invokeRestart("muffleMessage")
[16:06:13.107]                       }
[16:06:13.107]                       else if (inherits(cond, "warning")) {
[16:06:13.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:13.107]                         if (muffled) 
[16:06:13.107]                           invokeRestart("muffleWarning")
[16:06:13.107]                       }
[16:06:13.107]                       else if (inherits(cond, "condition")) {
[16:06:13.107]                         if (!is.null(pattern)) {
[16:06:13.107]                           computeRestarts <- base::computeRestarts
[16:06:13.107]                           grepl <- base::grepl
[16:06:13.107]                           restarts <- computeRestarts(cond)
[16:06:13.107]                           for (restart in restarts) {
[16:06:13.107]                             name <- restart$name
[16:06:13.107]                             if (is.null(name)) 
[16:06:13.107]                               next
[16:06:13.107]                             if (!grepl(pattern, name)) 
[16:06:13.107]                               next
[16:06:13.107]                             invokeRestart(restart)
[16:06:13.107]                             muffled <- TRUE
[16:06:13.107]                             break
[16:06:13.107]                           }
[16:06:13.107]                         }
[16:06:13.107]                       }
[16:06:13.107]                       invisible(muffled)
[16:06:13.107]                     }
[16:06:13.107]                     muffleCondition(cond, pattern = "^muffle")
[16:06:13.107]                   }
[16:06:13.107]                 }
[16:06:13.107]                 else {
[16:06:13.107]                   if (TRUE) {
[16:06:13.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.107]                     {
[16:06:13.107]                       inherits <- base::inherits
[16:06:13.107]                       invokeRestart <- base::invokeRestart
[16:06:13.107]                       is.null <- base::is.null
[16:06:13.107]                       muffled <- FALSE
[16:06:13.107]                       if (inherits(cond, "message")) {
[16:06:13.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:13.107]                         if (muffled) 
[16:06:13.107]                           invokeRestart("muffleMessage")
[16:06:13.107]                       }
[16:06:13.107]                       else if (inherits(cond, "warning")) {
[16:06:13.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:13.107]                         if (muffled) 
[16:06:13.107]                           invokeRestart("muffleWarning")
[16:06:13.107]                       }
[16:06:13.107]                       else if (inherits(cond, "condition")) {
[16:06:13.107]                         if (!is.null(pattern)) {
[16:06:13.107]                           computeRestarts <- base::computeRestarts
[16:06:13.107]                           grepl <- base::grepl
[16:06:13.107]                           restarts <- computeRestarts(cond)
[16:06:13.107]                           for (restart in restarts) {
[16:06:13.107]                             name <- restart$name
[16:06:13.107]                             if (is.null(name)) 
[16:06:13.107]                               next
[16:06:13.107]                             if (!grepl(pattern, name)) 
[16:06:13.107]                               next
[16:06:13.107]                             invokeRestart(restart)
[16:06:13.107]                             muffled <- TRUE
[16:06:13.107]                             break
[16:06:13.107]                           }
[16:06:13.107]                         }
[16:06:13.107]                       }
[16:06:13.107]                       invisible(muffled)
[16:06:13.107]                     }
[16:06:13.107]                     muffleCondition(cond, pattern = "^muffle")
[16:06:13.107]                   }
[16:06:13.107]                 }
[16:06:13.107]             }
[16:06:13.107]         }))
[16:06:13.107]     }, error = function(ex) {
[16:06:13.107]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:13.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:13.107]                 ...future.rng), started = ...future.startTime, 
[16:06:13.107]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:13.107]             version = "1.8"), class = "FutureResult")
[16:06:13.107]     }, finally = {
[16:06:13.107]         if (!identical(...future.workdir, getwd())) 
[16:06:13.107]             setwd(...future.workdir)
[16:06:13.107]         {
[16:06:13.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:13.107]                 ...future.oldOptions$nwarnings <- NULL
[16:06:13.107]             }
[16:06:13.107]             base::options(...future.oldOptions)
[16:06:13.107]             if (.Platform$OS.type == "windows") {
[16:06:13.107]                 old_names <- names(...future.oldEnvVars)
[16:06:13.107]                 envs <- base::Sys.getenv()
[16:06:13.107]                 names <- names(envs)
[16:06:13.107]                 common <- intersect(names, old_names)
[16:06:13.107]                 added <- setdiff(names, old_names)
[16:06:13.107]                 removed <- setdiff(old_names, names)
[16:06:13.107]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:13.107]                   envs[common]]
[16:06:13.107]                 NAMES <- toupper(changed)
[16:06:13.107]                 args <- list()
[16:06:13.107]                 for (kk in seq_along(NAMES)) {
[16:06:13.107]                   name <- changed[[kk]]
[16:06:13.107]                   NAME <- NAMES[[kk]]
[16:06:13.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.107]                     next
[16:06:13.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:13.107]                 }
[16:06:13.107]                 NAMES <- toupper(added)
[16:06:13.107]                 for (kk in seq_along(NAMES)) {
[16:06:13.107]                   name <- added[[kk]]
[16:06:13.107]                   NAME <- NAMES[[kk]]
[16:06:13.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.107]                     next
[16:06:13.107]                   args[[name]] <- ""
[16:06:13.107]                 }
[16:06:13.107]                 NAMES <- toupper(removed)
[16:06:13.107]                 for (kk in seq_along(NAMES)) {
[16:06:13.107]                   name <- removed[[kk]]
[16:06:13.107]                   NAME <- NAMES[[kk]]
[16:06:13.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.107]                     next
[16:06:13.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:13.107]                 }
[16:06:13.107]                 if (length(args) > 0) 
[16:06:13.107]                   base::do.call(base::Sys.setenv, args = args)
[16:06:13.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:13.107]             }
[16:06:13.107]             else {
[16:06:13.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:13.107]             }
[16:06:13.107]             {
[16:06:13.107]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:13.107]                   0L) {
[16:06:13.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:13.107]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:13.107]                   base::options(opts)
[16:06:13.107]                 }
[16:06:13.107]                 {
[16:06:13.107]                   {
[16:06:13.107]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:13.107]                     NULL
[16:06:13.107]                   }
[16:06:13.107]                   options(future.plan = NULL)
[16:06:13.107]                   if (is.na(NA_character_)) 
[16:06:13.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:13.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:13.107]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:13.107]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:13.107]                     envir = parent.frame()) 
[16:06:13.107]                   {
[16:06:13.107]                     if (is.function(workers)) 
[16:06:13.107]                       workers <- workers()
[16:06:13.107]                     workers <- structure(as.integer(workers), 
[16:06:13.107]                       class = class(workers))
[16:06:13.107]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:13.107]                       workers >= 1)
[16:06:13.107]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:13.107]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:13.107]                     }
[16:06:13.107]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:13.107]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:13.107]                       envir = envir)
[16:06:13.107]                     if (!future$lazy) 
[16:06:13.107]                       future <- run(future)
[16:06:13.107]                     invisible(future)
[16:06:13.107]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:13.107]                 }
[16:06:13.107]             }
[16:06:13.107]         }
[16:06:13.107]     })
[16:06:13.107]     if (TRUE) {
[16:06:13.107]         base::sink(type = "output", split = FALSE)
[16:06:13.107]         if (TRUE) {
[16:06:13.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:13.107]         }
[16:06:13.107]         else {
[16:06:13.107]             ...future.result["stdout"] <- base::list(NULL)
[16:06:13.107]         }
[16:06:13.107]         base::close(...future.stdout)
[16:06:13.107]         ...future.stdout <- NULL
[16:06:13.107]     }
[16:06:13.107]     ...future.result$conditions <- ...future.conditions
[16:06:13.107]     ...future.result$finished <- base::Sys.time()
[16:06:13.107]     ...future.result
[16:06:13.107] }
[16:06:13.111] MultisessionFuture started
[16:06:13.111] - Launch lazy future ... done
[16:06:13.111] run() for ‘MultisessionFuture’ ... done
[16:06:13.668] receiveMessageFromWorker() for ClusterFuture ...
[16:06:13.668] - Validating connection of MultisessionFuture
[16:06:13.668] - received message: FutureResult
[16:06:13.669] - Received FutureResult
[16:06:13.669] - Erased future from FutureRegistry
[16:06:13.669] result() for ClusterFuture ...
[16:06:13.669] - result already collected: FutureResult
[16:06:13.669] result() for ClusterFuture ... done
[16:06:13.669] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:13.669] resolve() on list ...
[16:06:13.669]  recursive: Inf
[16:06:13.669]  length: 2
[16:06:13.670]  elements: ‘a’, ‘b’
[16:06:13.670]  length: 1 (resolved future 1)
[16:06:13.670]  length: 0 (resolved future 2)
[16:06:13.670] resolve() on list ... DONE
[16:06:13.670] A MultisessionFuture was resolved (and resolved itself)
[16:06:13.670] getGlobalsAndPackages() ...
[16:06:13.670] Searching for globals...
[16:06:13.671] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[16:06:13.672] Searching for globals ... DONE
[16:06:13.672] Resolving globals: FALSE
[16:06:13.672] 
[16:06:13.672] 
[16:06:13.672] getGlobalsAndPackages() ... DONE
[16:06:13.672] run() for ‘Future’ ...
[16:06:13.673] - state: ‘created’
[16:06:13.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:13.686] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:13.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:13.687]   - Field: ‘node’
[16:06:13.687]   - Field: ‘label’
[16:06:13.687]   - Field: ‘local’
[16:06:13.687]   - Field: ‘owner’
[16:06:13.687]   - Field: ‘envir’
[16:06:13.687]   - Field: ‘workers’
[16:06:13.687]   - Field: ‘packages’
[16:06:13.687]   - Field: ‘gc’
[16:06:13.687]   - Field: ‘conditions’
[16:06:13.688]   - Field: ‘persistent’
[16:06:13.688]   - Field: ‘expr’
[16:06:13.688]   - Field: ‘uuid’
[16:06:13.688]   - Field: ‘seed’
[16:06:13.688]   - Field: ‘version’
[16:06:13.688]   - Field: ‘result’
[16:06:13.688]   - Field: ‘asynchronous’
[16:06:13.688]   - Field: ‘calls’
[16:06:13.688]   - Field: ‘globals’
[16:06:13.688]   - Field: ‘stdout’
[16:06:13.688]   - Field: ‘earlySignal’
[16:06:13.689]   - Field: ‘lazy’
[16:06:13.689]   - Field: ‘state’
[16:06:13.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:13.689] - Launch lazy future ...
[16:06:13.689] Packages needed by the future expression (n = 0): <none>
[16:06:13.689] Packages needed by future strategies (n = 0): <none>
[16:06:13.690] {
[16:06:13.690]     {
[16:06:13.690]         {
[16:06:13.690]             ...future.startTime <- base::Sys.time()
[16:06:13.690]             {
[16:06:13.690]                 {
[16:06:13.690]                   {
[16:06:13.690]                     {
[16:06:13.690]                       base::local({
[16:06:13.690]                         has_future <- base::requireNamespace("future", 
[16:06:13.690]                           quietly = TRUE)
[16:06:13.690]                         if (has_future) {
[16:06:13.690]                           ns <- base::getNamespace("future")
[16:06:13.690]                           version <- ns[[".package"]][["version"]]
[16:06:13.690]                           if (is.null(version)) 
[16:06:13.690]                             version <- utils::packageVersion("future")
[16:06:13.690]                         }
[16:06:13.690]                         else {
[16:06:13.690]                           version <- NULL
[16:06:13.690]                         }
[16:06:13.690]                         if (!has_future || version < "1.8.0") {
[16:06:13.690]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:13.690]                             "", base::R.version$version.string), 
[16:06:13.690]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:13.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:13.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:13.690]                               "release", "version")], collapse = " "), 
[16:06:13.690]                             hostname = base::Sys.info()[["nodename"]])
[16:06:13.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:13.690]                             info)
[16:06:13.690]                           info <- base::paste(info, collapse = "; ")
[16:06:13.690]                           if (!has_future) {
[16:06:13.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:13.690]                               info)
[16:06:13.690]                           }
[16:06:13.690]                           else {
[16:06:13.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:13.690]                               info, version)
[16:06:13.690]                           }
[16:06:13.690]                           base::stop(msg)
[16:06:13.690]                         }
[16:06:13.690]                       })
[16:06:13.690]                     }
[16:06:13.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:13.690]                     base::options(mc.cores = 1L)
[16:06:13.690]                   }
[16:06:13.690]                   options(future.plan = NULL)
[16:06:13.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:13.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:13.690]                 }
[16:06:13.690]                 ...future.workdir <- getwd()
[16:06:13.690]             }
[16:06:13.690]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:13.690]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:13.690]         }
[16:06:13.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:13.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:13.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:13.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:13.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:13.690]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:13.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:13.690]             base::names(...future.oldOptions))
[16:06:13.690]     }
[16:06:13.690]     if (FALSE) {
[16:06:13.690]     }
[16:06:13.690]     else {
[16:06:13.690]         if (TRUE) {
[16:06:13.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:13.690]                 open = "w")
[16:06:13.690]         }
[16:06:13.690]         else {
[16:06:13.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:13.690]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:13.690]         }
[16:06:13.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:13.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:13.690]             base::sink(type = "output", split = FALSE)
[16:06:13.690]             base::close(...future.stdout)
[16:06:13.690]         }, add = TRUE)
[16:06:13.690]     }
[16:06:13.690]     ...future.frame <- base::sys.nframe()
[16:06:13.690]     ...future.conditions <- base::list()
[16:06:13.690]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:13.690]     if (FALSE) {
[16:06:13.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:13.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:13.690]     }
[16:06:13.690]     ...future.result <- base::tryCatch({
[16:06:13.690]         base::withCallingHandlers({
[16:06:13.690]             ...future.value <- base::withVisible(base::local({
[16:06:13.690]                 ...future.makeSendCondition <- base::local({
[16:06:13.690]                   sendCondition <- NULL
[16:06:13.690]                   function(frame = 1L) {
[16:06:13.690]                     if (is.function(sendCondition)) 
[16:06:13.690]                       return(sendCondition)
[16:06:13.690]                     ns <- getNamespace("parallel")
[16:06:13.690]                     if (exists("sendData", mode = "function", 
[16:06:13.690]                       envir = ns)) {
[16:06:13.690]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:13.690]                         envir = ns)
[16:06:13.690]                       envir <- sys.frame(frame)
[16:06:13.690]                       master <- NULL
[16:06:13.690]                       while (!identical(envir, .GlobalEnv) && 
[16:06:13.690]                         !identical(envir, emptyenv())) {
[16:06:13.690]                         if (exists("master", mode = "list", envir = envir, 
[16:06:13.690]                           inherits = FALSE)) {
[16:06:13.690]                           master <- get("master", mode = "list", 
[16:06:13.690]                             envir = envir, inherits = FALSE)
[16:06:13.690]                           if (inherits(master, c("SOCKnode", 
[16:06:13.690]                             "SOCK0node"))) {
[16:06:13.690]                             sendCondition <<- function(cond) {
[16:06:13.690]                               data <- list(type = "VALUE", value = cond, 
[16:06:13.690]                                 success = TRUE)
[16:06:13.690]                               parallel_sendData(master, data)
[16:06:13.690]                             }
[16:06:13.690]                             return(sendCondition)
[16:06:13.690]                           }
[16:06:13.690]                         }
[16:06:13.690]                         frame <- frame + 1L
[16:06:13.690]                         envir <- sys.frame(frame)
[16:06:13.690]                       }
[16:06:13.690]                     }
[16:06:13.690]                     sendCondition <<- function(cond) NULL
[16:06:13.690]                   }
[16:06:13.690]                 })
[16:06:13.690]                 withCallingHandlers({
[16:06:13.690]                   {
[16:06:13.690]                     Sys.sleep(0.5)
[16:06:13.690]                     list(a = 1, b = 42L)
[16:06:13.690]                   }
[16:06:13.690]                 }, immediateCondition = function(cond) {
[16:06:13.690]                   sendCondition <- ...future.makeSendCondition()
[16:06:13.690]                   sendCondition(cond)
[16:06:13.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.690]                   {
[16:06:13.690]                     inherits <- base::inherits
[16:06:13.690]                     invokeRestart <- base::invokeRestart
[16:06:13.690]                     is.null <- base::is.null
[16:06:13.690]                     muffled <- FALSE
[16:06:13.690]                     if (inherits(cond, "message")) {
[16:06:13.690]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:13.690]                       if (muffled) 
[16:06:13.690]                         invokeRestart("muffleMessage")
[16:06:13.690]                     }
[16:06:13.690]                     else if (inherits(cond, "warning")) {
[16:06:13.690]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:13.690]                       if (muffled) 
[16:06:13.690]                         invokeRestart("muffleWarning")
[16:06:13.690]                     }
[16:06:13.690]                     else if (inherits(cond, "condition")) {
[16:06:13.690]                       if (!is.null(pattern)) {
[16:06:13.690]                         computeRestarts <- base::computeRestarts
[16:06:13.690]                         grepl <- base::grepl
[16:06:13.690]                         restarts <- computeRestarts(cond)
[16:06:13.690]                         for (restart in restarts) {
[16:06:13.690]                           name <- restart$name
[16:06:13.690]                           if (is.null(name)) 
[16:06:13.690]                             next
[16:06:13.690]                           if (!grepl(pattern, name)) 
[16:06:13.690]                             next
[16:06:13.690]                           invokeRestart(restart)
[16:06:13.690]                           muffled <- TRUE
[16:06:13.690]                           break
[16:06:13.690]                         }
[16:06:13.690]                       }
[16:06:13.690]                     }
[16:06:13.690]                     invisible(muffled)
[16:06:13.690]                   }
[16:06:13.690]                   muffleCondition(cond)
[16:06:13.690]                 })
[16:06:13.690]             }))
[16:06:13.690]             future::FutureResult(value = ...future.value$value, 
[16:06:13.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:13.690]                   ...future.rng), globalenv = if (FALSE) 
[16:06:13.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:13.690]                     ...future.globalenv.names))
[16:06:13.690]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:13.690]         }, condition = base::local({
[16:06:13.690]             c <- base::c
[16:06:13.690]             inherits <- base::inherits
[16:06:13.690]             invokeRestart <- base::invokeRestart
[16:06:13.690]             length <- base::length
[16:06:13.690]             list <- base::list
[16:06:13.690]             seq.int <- base::seq.int
[16:06:13.690]             signalCondition <- base::signalCondition
[16:06:13.690]             sys.calls <- base::sys.calls
[16:06:13.690]             `[[` <- base::`[[`
[16:06:13.690]             `+` <- base::`+`
[16:06:13.690]             `<<-` <- base::`<<-`
[16:06:13.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:13.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:13.690]                   3L)]
[16:06:13.690]             }
[16:06:13.690]             function(cond) {
[16:06:13.690]                 is_error <- inherits(cond, "error")
[16:06:13.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:13.690]                   NULL)
[16:06:13.690]                 if (is_error) {
[16:06:13.690]                   sessionInformation <- function() {
[16:06:13.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:13.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:13.690]                       search = base::search(), system = base::Sys.info())
[16:06:13.690]                   }
[16:06:13.690]                   ...future.conditions[[length(...future.conditions) + 
[16:06:13.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:13.690]                     cond$call), session = sessionInformation(), 
[16:06:13.690]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:13.690]                   signalCondition(cond)
[16:06:13.690]                 }
[16:06:13.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:13.690]                 "immediateCondition"))) {
[16:06:13.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:13.690]                   ...future.conditions[[length(...future.conditions) + 
[16:06:13.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:13.690]                   if (TRUE && !signal) {
[16:06:13.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.690]                     {
[16:06:13.690]                       inherits <- base::inherits
[16:06:13.690]                       invokeRestart <- base::invokeRestart
[16:06:13.690]                       is.null <- base::is.null
[16:06:13.690]                       muffled <- FALSE
[16:06:13.690]                       if (inherits(cond, "message")) {
[16:06:13.690]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:13.690]                         if (muffled) 
[16:06:13.690]                           invokeRestart("muffleMessage")
[16:06:13.690]                       }
[16:06:13.690]                       else if (inherits(cond, "warning")) {
[16:06:13.690]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:13.690]                         if (muffled) 
[16:06:13.690]                           invokeRestart("muffleWarning")
[16:06:13.690]                       }
[16:06:13.690]                       else if (inherits(cond, "condition")) {
[16:06:13.690]                         if (!is.null(pattern)) {
[16:06:13.690]                           computeRestarts <- base::computeRestarts
[16:06:13.690]                           grepl <- base::grepl
[16:06:13.690]                           restarts <- computeRestarts(cond)
[16:06:13.690]                           for (restart in restarts) {
[16:06:13.690]                             name <- restart$name
[16:06:13.690]                             if (is.null(name)) 
[16:06:13.690]                               next
[16:06:13.690]                             if (!grepl(pattern, name)) 
[16:06:13.690]                               next
[16:06:13.690]                             invokeRestart(restart)
[16:06:13.690]                             muffled <- TRUE
[16:06:13.690]                             break
[16:06:13.690]                           }
[16:06:13.690]                         }
[16:06:13.690]                       }
[16:06:13.690]                       invisible(muffled)
[16:06:13.690]                     }
[16:06:13.690]                     muffleCondition(cond, pattern = "^muffle")
[16:06:13.690]                   }
[16:06:13.690]                 }
[16:06:13.690]                 else {
[16:06:13.690]                   if (TRUE) {
[16:06:13.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:13.690]                     {
[16:06:13.690]                       inherits <- base::inherits
[16:06:13.690]                       invokeRestart <- base::invokeRestart
[16:06:13.690]                       is.null <- base::is.null
[16:06:13.690]                       muffled <- FALSE
[16:06:13.690]                       if (inherits(cond, "message")) {
[16:06:13.690]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:13.690]                         if (muffled) 
[16:06:13.690]                           invokeRestart("muffleMessage")
[16:06:13.690]                       }
[16:06:13.690]                       else if (inherits(cond, "warning")) {
[16:06:13.690]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:13.690]                         if (muffled) 
[16:06:13.690]                           invokeRestart("muffleWarning")
[16:06:13.690]                       }
[16:06:13.690]                       else if (inherits(cond, "condition")) {
[16:06:13.690]                         if (!is.null(pattern)) {
[16:06:13.690]                           computeRestarts <- base::computeRestarts
[16:06:13.690]                           grepl <- base::grepl
[16:06:13.690]                           restarts <- computeRestarts(cond)
[16:06:13.690]                           for (restart in restarts) {
[16:06:13.690]                             name <- restart$name
[16:06:13.690]                             if (is.null(name)) 
[16:06:13.690]                               next
[16:06:13.690]                             if (!grepl(pattern, name)) 
[16:06:13.690]                               next
[16:06:13.690]                             invokeRestart(restart)
[16:06:13.690]                             muffled <- TRUE
[16:06:13.690]                             break
[16:06:13.690]                           }
[16:06:13.690]                         }
[16:06:13.690]                       }
[16:06:13.690]                       invisible(muffled)
[16:06:13.690]                     }
[16:06:13.690]                     muffleCondition(cond, pattern = "^muffle")
[16:06:13.690]                   }
[16:06:13.690]                 }
[16:06:13.690]             }
[16:06:13.690]         }))
[16:06:13.690]     }, error = function(ex) {
[16:06:13.690]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:13.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:13.690]                 ...future.rng), started = ...future.startTime, 
[16:06:13.690]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:13.690]             version = "1.8"), class = "FutureResult")
[16:06:13.690]     }, finally = {
[16:06:13.690]         if (!identical(...future.workdir, getwd())) 
[16:06:13.690]             setwd(...future.workdir)
[16:06:13.690]         {
[16:06:13.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:13.690]                 ...future.oldOptions$nwarnings <- NULL
[16:06:13.690]             }
[16:06:13.690]             base::options(...future.oldOptions)
[16:06:13.690]             if (.Platform$OS.type == "windows") {
[16:06:13.690]                 old_names <- names(...future.oldEnvVars)
[16:06:13.690]                 envs <- base::Sys.getenv()
[16:06:13.690]                 names <- names(envs)
[16:06:13.690]                 common <- intersect(names, old_names)
[16:06:13.690]                 added <- setdiff(names, old_names)
[16:06:13.690]                 removed <- setdiff(old_names, names)
[16:06:13.690]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:13.690]                   envs[common]]
[16:06:13.690]                 NAMES <- toupper(changed)
[16:06:13.690]                 args <- list()
[16:06:13.690]                 for (kk in seq_along(NAMES)) {
[16:06:13.690]                   name <- changed[[kk]]
[16:06:13.690]                   NAME <- NAMES[[kk]]
[16:06:13.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.690]                     next
[16:06:13.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:13.690]                 }
[16:06:13.690]                 NAMES <- toupper(added)
[16:06:13.690]                 for (kk in seq_along(NAMES)) {
[16:06:13.690]                   name <- added[[kk]]
[16:06:13.690]                   NAME <- NAMES[[kk]]
[16:06:13.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.690]                     next
[16:06:13.690]                   args[[name]] <- ""
[16:06:13.690]                 }
[16:06:13.690]                 NAMES <- toupper(removed)
[16:06:13.690]                 for (kk in seq_along(NAMES)) {
[16:06:13.690]                   name <- removed[[kk]]
[16:06:13.690]                   NAME <- NAMES[[kk]]
[16:06:13.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:13.690]                     next
[16:06:13.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:13.690]                 }
[16:06:13.690]                 if (length(args) > 0) 
[16:06:13.690]                   base::do.call(base::Sys.setenv, args = args)
[16:06:13.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:13.690]             }
[16:06:13.690]             else {
[16:06:13.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:13.690]             }
[16:06:13.690]             {
[16:06:13.690]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:13.690]                   0L) {
[16:06:13.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:13.690]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:13.690]                   base::options(opts)
[16:06:13.690]                 }
[16:06:13.690]                 {
[16:06:13.690]                   {
[16:06:13.690]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:13.690]                     NULL
[16:06:13.690]                   }
[16:06:13.690]                   options(future.plan = NULL)
[16:06:13.690]                   if (is.na(NA_character_)) 
[16:06:13.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:13.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:13.690]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:13.690]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:13.690]                     envir = parent.frame()) 
[16:06:13.690]                   {
[16:06:13.690]                     if (is.function(workers)) 
[16:06:13.690]                       workers <- workers()
[16:06:13.690]                     workers <- structure(as.integer(workers), 
[16:06:13.690]                       class = class(workers))
[16:06:13.690]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:13.690]                       workers >= 1)
[16:06:13.690]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:13.690]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:13.690]                     }
[16:06:13.690]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:13.690]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:13.690]                       envir = envir)
[16:06:13.690]                     if (!future$lazy) 
[16:06:13.690]                       future <- run(future)
[16:06:13.690]                     invisible(future)
[16:06:13.690]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:13.690]                 }
[16:06:13.690]             }
[16:06:13.690]         }
[16:06:13.690]     })
[16:06:13.690]     if (TRUE) {
[16:06:13.690]         base::sink(type = "output", split = FALSE)
[16:06:13.690]         if (TRUE) {
[16:06:13.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:13.690]         }
[16:06:13.690]         else {
[16:06:13.690]             ...future.result["stdout"] <- base::list(NULL)
[16:06:13.690]         }
[16:06:13.690]         base::close(...future.stdout)
[16:06:13.690]         ...future.stdout <- NULL
[16:06:13.690]     }
[16:06:13.690]     ...future.result$conditions <- ...future.conditions
[16:06:13.690]     ...future.result$finished <- base::Sys.time()
[16:06:13.690]     ...future.result
[16:06:13.690] }
[16:06:13.693] MultisessionFuture started
[16:06:13.693] - Launch lazy future ... done
[16:06:13.693] run() for ‘MultisessionFuture’ ... done
[16:06:14.241] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.241] - Validating connection of MultisessionFuture
[16:06:14.241] - received message: FutureResult
[16:06:14.241] - Received FutureResult
[16:06:14.241] - Erased future from FutureRegistry
[16:06:14.242] result() for ClusterFuture ...
[16:06:14.242] - result already collected: FutureResult
[16:06:14.242] result() for ClusterFuture ... done
[16:06:14.242] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.242] resolve() on list ...
[16:06:14.242]  recursive: Inf
[16:06:14.242]  length: 2
[16:06:14.242]  elements: ‘a’, ‘b’
[16:06:14.242]  length: 1 (resolved future 1)
[16:06:14.243]  length: 0 (resolved future 2)
[16:06:14.243] resolve() on list ... DONE
[16:06:14.243] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[16:06:14.243] getGlobalsAndPackages() ...
[16:06:14.243] Searching for globals...
[16:06:14.244] - globals found: [2] ‘list’, ‘stop’
[16:06:14.244] Searching for globals ... DONE
[16:06:14.244] Resolving globals: FALSE
[16:06:14.244] 
[16:06:14.244] 
[16:06:14.244] getGlobalsAndPackages() ... DONE
[16:06:14.245] run() for ‘Future’ ...
[16:06:14.245] - state: ‘created’
[16:06:14.245] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.258] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.259] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.259]   - Field: ‘node’
[16:06:14.259]   - Field: ‘label’
[16:06:14.259]   - Field: ‘local’
[16:06:14.259]   - Field: ‘owner’
[16:06:14.259]   - Field: ‘envir’
[16:06:14.259]   - Field: ‘workers’
[16:06:14.259]   - Field: ‘packages’
[16:06:14.259]   - Field: ‘gc’
[16:06:14.259]   - Field: ‘conditions’
[16:06:14.260]   - Field: ‘persistent’
[16:06:14.260]   - Field: ‘expr’
[16:06:14.260]   - Field: ‘uuid’
[16:06:14.260]   - Field: ‘seed’
[16:06:14.260]   - Field: ‘version’
[16:06:14.260]   - Field: ‘result’
[16:06:14.260]   - Field: ‘asynchronous’
[16:06:14.260]   - Field: ‘calls’
[16:06:14.260]   - Field: ‘globals’
[16:06:14.260]   - Field: ‘stdout’
[16:06:14.260]   - Field: ‘earlySignal’
[16:06:14.260]   - Field: ‘lazy’
[16:06:14.261]   - Field: ‘state’
[16:06:14.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.261] - Launch lazy future ...
[16:06:14.261] Packages needed by the future expression (n = 0): <none>
[16:06:14.261] Packages needed by future strategies (n = 0): <none>
[16:06:14.262] {
[16:06:14.262]     {
[16:06:14.262]         {
[16:06:14.262]             ...future.startTime <- base::Sys.time()
[16:06:14.262]             {
[16:06:14.262]                 {
[16:06:14.262]                   {
[16:06:14.262]                     {
[16:06:14.262]                       base::local({
[16:06:14.262]                         has_future <- base::requireNamespace("future", 
[16:06:14.262]                           quietly = TRUE)
[16:06:14.262]                         if (has_future) {
[16:06:14.262]                           ns <- base::getNamespace("future")
[16:06:14.262]                           version <- ns[[".package"]][["version"]]
[16:06:14.262]                           if (is.null(version)) 
[16:06:14.262]                             version <- utils::packageVersion("future")
[16:06:14.262]                         }
[16:06:14.262]                         else {
[16:06:14.262]                           version <- NULL
[16:06:14.262]                         }
[16:06:14.262]                         if (!has_future || version < "1.8.0") {
[16:06:14.262]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.262]                             "", base::R.version$version.string), 
[16:06:14.262]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.262]                               "release", "version")], collapse = " "), 
[16:06:14.262]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.262]                             info)
[16:06:14.262]                           info <- base::paste(info, collapse = "; ")
[16:06:14.262]                           if (!has_future) {
[16:06:14.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.262]                               info)
[16:06:14.262]                           }
[16:06:14.262]                           else {
[16:06:14.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.262]                               info, version)
[16:06:14.262]                           }
[16:06:14.262]                           base::stop(msg)
[16:06:14.262]                         }
[16:06:14.262]                       })
[16:06:14.262]                     }
[16:06:14.262]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.262]                     base::options(mc.cores = 1L)
[16:06:14.262]                   }
[16:06:14.262]                   options(future.plan = NULL)
[16:06:14.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.262]                 }
[16:06:14.262]                 ...future.workdir <- getwd()
[16:06:14.262]             }
[16:06:14.262]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.262]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.262]         }
[16:06:14.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.262]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.262]             base::names(...future.oldOptions))
[16:06:14.262]     }
[16:06:14.262]     if (FALSE) {
[16:06:14.262]     }
[16:06:14.262]     else {
[16:06:14.262]         if (TRUE) {
[16:06:14.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.262]                 open = "w")
[16:06:14.262]         }
[16:06:14.262]         else {
[16:06:14.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.262]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.262]         }
[16:06:14.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.262]             base::sink(type = "output", split = FALSE)
[16:06:14.262]             base::close(...future.stdout)
[16:06:14.262]         }, add = TRUE)
[16:06:14.262]     }
[16:06:14.262]     ...future.frame <- base::sys.nframe()
[16:06:14.262]     ...future.conditions <- base::list()
[16:06:14.262]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.262]     if (FALSE) {
[16:06:14.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.262]     }
[16:06:14.262]     ...future.result <- base::tryCatch({
[16:06:14.262]         base::withCallingHandlers({
[16:06:14.262]             ...future.value <- base::withVisible(base::local({
[16:06:14.262]                 ...future.makeSendCondition <- base::local({
[16:06:14.262]                   sendCondition <- NULL
[16:06:14.262]                   function(frame = 1L) {
[16:06:14.262]                     if (is.function(sendCondition)) 
[16:06:14.262]                       return(sendCondition)
[16:06:14.262]                     ns <- getNamespace("parallel")
[16:06:14.262]                     if (exists("sendData", mode = "function", 
[16:06:14.262]                       envir = ns)) {
[16:06:14.262]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.262]                         envir = ns)
[16:06:14.262]                       envir <- sys.frame(frame)
[16:06:14.262]                       master <- NULL
[16:06:14.262]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.262]                         !identical(envir, emptyenv())) {
[16:06:14.262]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.262]                           inherits = FALSE)) {
[16:06:14.262]                           master <- get("master", mode = "list", 
[16:06:14.262]                             envir = envir, inherits = FALSE)
[16:06:14.262]                           if (inherits(master, c("SOCKnode", 
[16:06:14.262]                             "SOCK0node"))) {
[16:06:14.262]                             sendCondition <<- function(cond) {
[16:06:14.262]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.262]                                 success = TRUE)
[16:06:14.262]                               parallel_sendData(master, data)
[16:06:14.262]                             }
[16:06:14.262]                             return(sendCondition)
[16:06:14.262]                           }
[16:06:14.262]                         }
[16:06:14.262]                         frame <- frame + 1L
[16:06:14.262]                         envir <- sys.frame(frame)
[16:06:14.262]                       }
[16:06:14.262]                     }
[16:06:14.262]                     sendCondition <<- function(cond) NULL
[16:06:14.262]                   }
[16:06:14.262]                 })
[16:06:14.262]                 withCallingHandlers({
[16:06:14.262]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:14.262]                 }, immediateCondition = function(cond) {
[16:06:14.262]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.262]                   sendCondition(cond)
[16:06:14.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.262]                   {
[16:06:14.262]                     inherits <- base::inherits
[16:06:14.262]                     invokeRestart <- base::invokeRestart
[16:06:14.262]                     is.null <- base::is.null
[16:06:14.262]                     muffled <- FALSE
[16:06:14.262]                     if (inherits(cond, "message")) {
[16:06:14.262]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.262]                       if (muffled) 
[16:06:14.262]                         invokeRestart("muffleMessage")
[16:06:14.262]                     }
[16:06:14.262]                     else if (inherits(cond, "warning")) {
[16:06:14.262]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.262]                       if (muffled) 
[16:06:14.262]                         invokeRestart("muffleWarning")
[16:06:14.262]                     }
[16:06:14.262]                     else if (inherits(cond, "condition")) {
[16:06:14.262]                       if (!is.null(pattern)) {
[16:06:14.262]                         computeRestarts <- base::computeRestarts
[16:06:14.262]                         grepl <- base::grepl
[16:06:14.262]                         restarts <- computeRestarts(cond)
[16:06:14.262]                         for (restart in restarts) {
[16:06:14.262]                           name <- restart$name
[16:06:14.262]                           if (is.null(name)) 
[16:06:14.262]                             next
[16:06:14.262]                           if (!grepl(pattern, name)) 
[16:06:14.262]                             next
[16:06:14.262]                           invokeRestart(restart)
[16:06:14.262]                           muffled <- TRUE
[16:06:14.262]                           break
[16:06:14.262]                         }
[16:06:14.262]                       }
[16:06:14.262]                     }
[16:06:14.262]                     invisible(muffled)
[16:06:14.262]                   }
[16:06:14.262]                   muffleCondition(cond)
[16:06:14.262]                 })
[16:06:14.262]             }))
[16:06:14.262]             future::FutureResult(value = ...future.value$value, 
[16:06:14.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.262]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.262]                     ...future.globalenv.names))
[16:06:14.262]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.262]         }, condition = base::local({
[16:06:14.262]             c <- base::c
[16:06:14.262]             inherits <- base::inherits
[16:06:14.262]             invokeRestart <- base::invokeRestart
[16:06:14.262]             length <- base::length
[16:06:14.262]             list <- base::list
[16:06:14.262]             seq.int <- base::seq.int
[16:06:14.262]             signalCondition <- base::signalCondition
[16:06:14.262]             sys.calls <- base::sys.calls
[16:06:14.262]             `[[` <- base::`[[`
[16:06:14.262]             `+` <- base::`+`
[16:06:14.262]             `<<-` <- base::`<<-`
[16:06:14.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.262]                   3L)]
[16:06:14.262]             }
[16:06:14.262]             function(cond) {
[16:06:14.262]                 is_error <- inherits(cond, "error")
[16:06:14.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.262]                   NULL)
[16:06:14.262]                 if (is_error) {
[16:06:14.262]                   sessionInformation <- function() {
[16:06:14.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.262]                       search = base::search(), system = base::Sys.info())
[16:06:14.262]                   }
[16:06:14.262]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.262]                     cond$call), session = sessionInformation(), 
[16:06:14.262]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.262]                   signalCondition(cond)
[16:06:14.262]                 }
[16:06:14.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.262]                 "immediateCondition"))) {
[16:06:14.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.262]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.262]                   if (TRUE && !signal) {
[16:06:14.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.262]                     {
[16:06:14.262]                       inherits <- base::inherits
[16:06:14.262]                       invokeRestart <- base::invokeRestart
[16:06:14.262]                       is.null <- base::is.null
[16:06:14.262]                       muffled <- FALSE
[16:06:14.262]                       if (inherits(cond, "message")) {
[16:06:14.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.262]                         if (muffled) 
[16:06:14.262]                           invokeRestart("muffleMessage")
[16:06:14.262]                       }
[16:06:14.262]                       else if (inherits(cond, "warning")) {
[16:06:14.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.262]                         if (muffled) 
[16:06:14.262]                           invokeRestart("muffleWarning")
[16:06:14.262]                       }
[16:06:14.262]                       else if (inherits(cond, "condition")) {
[16:06:14.262]                         if (!is.null(pattern)) {
[16:06:14.262]                           computeRestarts <- base::computeRestarts
[16:06:14.262]                           grepl <- base::grepl
[16:06:14.262]                           restarts <- computeRestarts(cond)
[16:06:14.262]                           for (restart in restarts) {
[16:06:14.262]                             name <- restart$name
[16:06:14.262]                             if (is.null(name)) 
[16:06:14.262]                               next
[16:06:14.262]                             if (!grepl(pattern, name)) 
[16:06:14.262]                               next
[16:06:14.262]                             invokeRestart(restart)
[16:06:14.262]                             muffled <- TRUE
[16:06:14.262]                             break
[16:06:14.262]                           }
[16:06:14.262]                         }
[16:06:14.262]                       }
[16:06:14.262]                       invisible(muffled)
[16:06:14.262]                     }
[16:06:14.262]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.262]                   }
[16:06:14.262]                 }
[16:06:14.262]                 else {
[16:06:14.262]                   if (TRUE) {
[16:06:14.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.262]                     {
[16:06:14.262]                       inherits <- base::inherits
[16:06:14.262]                       invokeRestart <- base::invokeRestart
[16:06:14.262]                       is.null <- base::is.null
[16:06:14.262]                       muffled <- FALSE
[16:06:14.262]                       if (inherits(cond, "message")) {
[16:06:14.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.262]                         if (muffled) 
[16:06:14.262]                           invokeRestart("muffleMessage")
[16:06:14.262]                       }
[16:06:14.262]                       else if (inherits(cond, "warning")) {
[16:06:14.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.262]                         if (muffled) 
[16:06:14.262]                           invokeRestart("muffleWarning")
[16:06:14.262]                       }
[16:06:14.262]                       else if (inherits(cond, "condition")) {
[16:06:14.262]                         if (!is.null(pattern)) {
[16:06:14.262]                           computeRestarts <- base::computeRestarts
[16:06:14.262]                           grepl <- base::grepl
[16:06:14.262]                           restarts <- computeRestarts(cond)
[16:06:14.262]                           for (restart in restarts) {
[16:06:14.262]                             name <- restart$name
[16:06:14.262]                             if (is.null(name)) 
[16:06:14.262]                               next
[16:06:14.262]                             if (!grepl(pattern, name)) 
[16:06:14.262]                               next
[16:06:14.262]                             invokeRestart(restart)
[16:06:14.262]                             muffled <- TRUE
[16:06:14.262]                             break
[16:06:14.262]                           }
[16:06:14.262]                         }
[16:06:14.262]                       }
[16:06:14.262]                       invisible(muffled)
[16:06:14.262]                     }
[16:06:14.262]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.262]                   }
[16:06:14.262]                 }
[16:06:14.262]             }
[16:06:14.262]         }))
[16:06:14.262]     }, error = function(ex) {
[16:06:14.262]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.262]                 ...future.rng), started = ...future.startTime, 
[16:06:14.262]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.262]             version = "1.8"), class = "FutureResult")
[16:06:14.262]     }, finally = {
[16:06:14.262]         if (!identical(...future.workdir, getwd())) 
[16:06:14.262]             setwd(...future.workdir)
[16:06:14.262]         {
[16:06:14.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.262]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.262]             }
[16:06:14.262]             base::options(...future.oldOptions)
[16:06:14.262]             if (.Platform$OS.type == "windows") {
[16:06:14.262]                 old_names <- names(...future.oldEnvVars)
[16:06:14.262]                 envs <- base::Sys.getenv()
[16:06:14.262]                 names <- names(envs)
[16:06:14.262]                 common <- intersect(names, old_names)
[16:06:14.262]                 added <- setdiff(names, old_names)
[16:06:14.262]                 removed <- setdiff(old_names, names)
[16:06:14.262]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.262]                   envs[common]]
[16:06:14.262]                 NAMES <- toupper(changed)
[16:06:14.262]                 args <- list()
[16:06:14.262]                 for (kk in seq_along(NAMES)) {
[16:06:14.262]                   name <- changed[[kk]]
[16:06:14.262]                   NAME <- NAMES[[kk]]
[16:06:14.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.262]                     next
[16:06:14.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.262]                 }
[16:06:14.262]                 NAMES <- toupper(added)
[16:06:14.262]                 for (kk in seq_along(NAMES)) {
[16:06:14.262]                   name <- added[[kk]]
[16:06:14.262]                   NAME <- NAMES[[kk]]
[16:06:14.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.262]                     next
[16:06:14.262]                   args[[name]] <- ""
[16:06:14.262]                 }
[16:06:14.262]                 NAMES <- toupper(removed)
[16:06:14.262]                 for (kk in seq_along(NAMES)) {
[16:06:14.262]                   name <- removed[[kk]]
[16:06:14.262]                   NAME <- NAMES[[kk]]
[16:06:14.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.262]                     next
[16:06:14.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.262]                 }
[16:06:14.262]                 if (length(args) > 0) 
[16:06:14.262]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.262]             }
[16:06:14.262]             else {
[16:06:14.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.262]             }
[16:06:14.262]             {
[16:06:14.262]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.262]                   0L) {
[16:06:14.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.262]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.262]                   base::options(opts)
[16:06:14.262]                 }
[16:06:14.262]                 {
[16:06:14.262]                   {
[16:06:14.262]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.262]                     NULL
[16:06:14.262]                   }
[16:06:14.262]                   options(future.plan = NULL)
[16:06:14.262]                   if (is.na(NA_character_)) 
[16:06:14.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.262]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.262]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.262]                     envir = parent.frame()) 
[16:06:14.262]                   {
[16:06:14.262]                     if (is.function(workers)) 
[16:06:14.262]                       workers <- workers()
[16:06:14.262]                     workers <- structure(as.integer(workers), 
[16:06:14.262]                       class = class(workers))
[16:06:14.262]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.262]                       workers >= 1)
[16:06:14.262]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.262]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.262]                     }
[16:06:14.262]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.262]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.262]                       envir = envir)
[16:06:14.262]                     if (!future$lazy) 
[16:06:14.262]                       future <- run(future)
[16:06:14.262]                     invisible(future)
[16:06:14.262]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.262]                 }
[16:06:14.262]             }
[16:06:14.262]         }
[16:06:14.262]     })
[16:06:14.262]     if (TRUE) {
[16:06:14.262]         base::sink(type = "output", split = FALSE)
[16:06:14.262]         if (TRUE) {
[16:06:14.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.262]         }
[16:06:14.262]         else {
[16:06:14.262]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.262]         }
[16:06:14.262]         base::close(...future.stdout)
[16:06:14.262]         ...future.stdout <- NULL
[16:06:14.262]     }
[16:06:14.262]     ...future.result$conditions <- ...future.conditions
[16:06:14.262]     ...future.result$finished <- base::Sys.time()
[16:06:14.262]     ...future.result
[16:06:14.262] }
[16:06:14.265] MultisessionFuture started
[16:06:14.265] - Launch lazy future ... done
[16:06:14.265] run() for ‘MultisessionFuture’ ... done
[16:06:14.316] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.316] - Validating connection of MultisessionFuture
[16:06:14.316] - received message: FutureResult
[16:06:14.317] - Received FutureResult
[16:06:14.317] - Erased future from FutureRegistry
[16:06:14.317] result() for ClusterFuture ...
[16:06:14.317] - result already collected: FutureResult
[16:06:14.317] result() for ClusterFuture ... done
[16:06:14.317] signalConditions() ...
[16:06:14.317]  - include = ‘immediateCondition’
[16:06:14.317]  - exclude = 
[16:06:14.317]  - resignal = FALSE
[16:06:14.317]  - Number of conditions: 1
[16:06:14.318] signalConditions() ... done
[16:06:14.318] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.318] A MultisessionFuture was resolved
[16:06:14.318] getGlobalsAndPackages() ...
[16:06:14.318] Searching for globals...
[16:06:14.319] - globals found: [2] ‘list’, ‘stop’
[16:06:14.319] Searching for globals ... DONE
[16:06:14.319] Resolving globals: FALSE
[16:06:14.319] 
[16:06:14.319] 
[16:06:14.319] getGlobalsAndPackages() ... DONE
[16:06:14.320] run() for ‘Future’ ...
[16:06:14.320] - state: ‘created’
[16:06:14.320] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.333] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.334]   - Field: ‘node’
[16:06:14.334]   - Field: ‘label’
[16:06:14.334]   - Field: ‘local’
[16:06:14.334]   - Field: ‘owner’
[16:06:14.334]   - Field: ‘envir’
[16:06:14.334]   - Field: ‘workers’
[16:06:14.334]   - Field: ‘packages’
[16:06:14.334]   - Field: ‘gc’
[16:06:14.334]   - Field: ‘conditions’
[16:06:14.334]   - Field: ‘persistent’
[16:06:14.335]   - Field: ‘expr’
[16:06:14.335]   - Field: ‘uuid’
[16:06:14.335]   - Field: ‘seed’
[16:06:14.335]   - Field: ‘version’
[16:06:14.335]   - Field: ‘result’
[16:06:14.335]   - Field: ‘asynchronous’
[16:06:14.335]   - Field: ‘calls’
[16:06:14.335]   - Field: ‘globals’
[16:06:14.335]   - Field: ‘stdout’
[16:06:14.335]   - Field: ‘earlySignal’
[16:06:14.335]   - Field: ‘lazy’
[16:06:14.336]   - Field: ‘state’
[16:06:14.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.336] - Launch lazy future ...
[16:06:14.336] Packages needed by the future expression (n = 0): <none>
[16:06:14.336] Packages needed by future strategies (n = 0): <none>
[16:06:14.337] {
[16:06:14.337]     {
[16:06:14.337]         {
[16:06:14.337]             ...future.startTime <- base::Sys.time()
[16:06:14.337]             {
[16:06:14.337]                 {
[16:06:14.337]                   {
[16:06:14.337]                     {
[16:06:14.337]                       base::local({
[16:06:14.337]                         has_future <- base::requireNamespace("future", 
[16:06:14.337]                           quietly = TRUE)
[16:06:14.337]                         if (has_future) {
[16:06:14.337]                           ns <- base::getNamespace("future")
[16:06:14.337]                           version <- ns[[".package"]][["version"]]
[16:06:14.337]                           if (is.null(version)) 
[16:06:14.337]                             version <- utils::packageVersion("future")
[16:06:14.337]                         }
[16:06:14.337]                         else {
[16:06:14.337]                           version <- NULL
[16:06:14.337]                         }
[16:06:14.337]                         if (!has_future || version < "1.8.0") {
[16:06:14.337]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.337]                             "", base::R.version$version.string), 
[16:06:14.337]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.337]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.337]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.337]                               "release", "version")], collapse = " "), 
[16:06:14.337]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.337]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.337]                             info)
[16:06:14.337]                           info <- base::paste(info, collapse = "; ")
[16:06:14.337]                           if (!has_future) {
[16:06:14.337]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.337]                               info)
[16:06:14.337]                           }
[16:06:14.337]                           else {
[16:06:14.337]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.337]                               info, version)
[16:06:14.337]                           }
[16:06:14.337]                           base::stop(msg)
[16:06:14.337]                         }
[16:06:14.337]                       })
[16:06:14.337]                     }
[16:06:14.337]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.337]                     base::options(mc.cores = 1L)
[16:06:14.337]                   }
[16:06:14.337]                   options(future.plan = NULL)
[16:06:14.337]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.337]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.337]                 }
[16:06:14.337]                 ...future.workdir <- getwd()
[16:06:14.337]             }
[16:06:14.337]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.337]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.337]         }
[16:06:14.337]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.337]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.337]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.337]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.337]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.337]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.337]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.337]             base::names(...future.oldOptions))
[16:06:14.337]     }
[16:06:14.337]     if (FALSE) {
[16:06:14.337]     }
[16:06:14.337]     else {
[16:06:14.337]         if (TRUE) {
[16:06:14.337]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.337]                 open = "w")
[16:06:14.337]         }
[16:06:14.337]         else {
[16:06:14.337]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.337]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.337]         }
[16:06:14.337]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.337]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.337]             base::sink(type = "output", split = FALSE)
[16:06:14.337]             base::close(...future.stdout)
[16:06:14.337]         }, add = TRUE)
[16:06:14.337]     }
[16:06:14.337]     ...future.frame <- base::sys.nframe()
[16:06:14.337]     ...future.conditions <- base::list()
[16:06:14.337]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.337]     if (FALSE) {
[16:06:14.337]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.337]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.337]     }
[16:06:14.337]     ...future.result <- base::tryCatch({
[16:06:14.337]         base::withCallingHandlers({
[16:06:14.337]             ...future.value <- base::withVisible(base::local({
[16:06:14.337]                 ...future.makeSendCondition <- base::local({
[16:06:14.337]                   sendCondition <- NULL
[16:06:14.337]                   function(frame = 1L) {
[16:06:14.337]                     if (is.function(sendCondition)) 
[16:06:14.337]                       return(sendCondition)
[16:06:14.337]                     ns <- getNamespace("parallel")
[16:06:14.337]                     if (exists("sendData", mode = "function", 
[16:06:14.337]                       envir = ns)) {
[16:06:14.337]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.337]                         envir = ns)
[16:06:14.337]                       envir <- sys.frame(frame)
[16:06:14.337]                       master <- NULL
[16:06:14.337]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.337]                         !identical(envir, emptyenv())) {
[16:06:14.337]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.337]                           inherits = FALSE)) {
[16:06:14.337]                           master <- get("master", mode = "list", 
[16:06:14.337]                             envir = envir, inherits = FALSE)
[16:06:14.337]                           if (inherits(master, c("SOCKnode", 
[16:06:14.337]                             "SOCK0node"))) {
[16:06:14.337]                             sendCondition <<- function(cond) {
[16:06:14.337]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.337]                                 success = TRUE)
[16:06:14.337]                               parallel_sendData(master, data)
[16:06:14.337]                             }
[16:06:14.337]                             return(sendCondition)
[16:06:14.337]                           }
[16:06:14.337]                         }
[16:06:14.337]                         frame <- frame + 1L
[16:06:14.337]                         envir <- sys.frame(frame)
[16:06:14.337]                       }
[16:06:14.337]                     }
[16:06:14.337]                     sendCondition <<- function(cond) NULL
[16:06:14.337]                   }
[16:06:14.337]                 })
[16:06:14.337]                 withCallingHandlers({
[16:06:14.337]                   list(a = 1, b = 42L, c = stop("Nah!"))
[16:06:14.337]                 }, immediateCondition = function(cond) {
[16:06:14.337]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.337]                   sendCondition(cond)
[16:06:14.337]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.337]                   {
[16:06:14.337]                     inherits <- base::inherits
[16:06:14.337]                     invokeRestart <- base::invokeRestart
[16:06:14.337]                     is.null <- base::is.null
[16:06:14.337]                     muffled <- FALSE
[16:06:14.337]                     if (inherits(cond, "message")) {
[16:06:14.337]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.337]                       if (muffled) 
[16:06:14.337]                         invokeRestart("muffleMessage")
[16:06:14.337]                     }
[16:06:14.337]                     else if (inherits(cond, "warning")) {
[16:06:14.337]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.337]                       if (muffled) 
[16:06:14.337]                         invokeRestart("muffleWarning")
[16:06:14.337]                     }
[16:06:14.337]                     else if (inherits(cond, "condition")) {
[16:06:14.337]                       if (!is.null(pattern)) {
[16:06:14.337]                         computeRestarts <- base::computeRestarts
[16:06:14.337]                         grepl <- base::grepl
[16:06:14.337]                         restarts <- computeRestarts(cond)
[16:06:14.337]                         for (restart in restarts) {
[16:06:14.337]                           name <- restart$name
[16:06:14.337]                           if (is.null(name)) 
[16:06:14.337]                             next
[16:06:14.337]                           if (!grepl(pattern, name)) 
[16:06:14.337]                             next
[16:06:14.337]                           invokeRestart(restart)
[16:06:14.337]                           muffled <- TRUE
[16:06:14.337]                           break
[16:06:14.337]                         }
[16:06:14.337]                       }
[16:06:14.337]                     }
[16:06:14.337]                     invisible(muffled)
[16:06:14.337]                   }
[16:06:14.337]                   muffleCondition(cond)
[16:06:14.337]                 })
[16:06:14.337]             }))
[16:06:14.337]             future::FutureResult(value = ...future.value$value, 
[16:06:14.337]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.337]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.337]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.337]                     ...future.globalenv.names))
[16:06:14.337]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.337]         }, condition = base::local({
[16:06:14.337]             c <- base::c
[16:06:14.337]             inherits <- base::inherits
[16:06:14.337]             invokeRestart <- base::invokeRestart
[16:06:14.337]             length <- base::length
[16:06:14.337]             list <- base::list
[16:06:14.337]             seq.int <- base::seq.int
[16:06:14.337]             signalCondition <- base::signalCondition
[16:06:14.337]             sys.calls <- base::sys.calls
[16:06:14.337]             `[[` <- base::`[[`
[16:06:14.337]             `+` <- base::`+`
[16:06:14.337]             `<<-` <- base::`<<-`
[16:06:14.337]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.337]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.337]                   3L)]
[16:06:14.337]             }
[16:06:14.337]             function(cond) {
[16:06:14.337]                 is_error <- inherits(cond, "error")
[16:06:14.337]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.337]                   NULL)
[16:06:14.337]                 if (is_error) {
[16:06:14.337]                   sessionInformation <- function() {
[16:06:14.337]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.337]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.337]                       search = base::search(), system = base::Sys.info())
[16:06:14.337]                   }
[16:06:14.337]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.337]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.337]                     cond$call), session = sessionInformation(), 
[16:06:14.337]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.337]                   signalCondition(cond)
[16:06:14.337]                 }
[16:06:14.337]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.337]                 "immediateCondition"))) {
[16:06:14.337]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.337]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.337]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.337]                   if (TRUE && !signal) {
[16:06:14.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.337]                     {
[16:06:14.337]                       inherits <- base::inherits
[16:06:14.337]                       invokeRestart <- base::invokeRestart
[16:06:14.337]                       is.null <- base::is.null
[16:06:14.337]                       muffled <- FALSE
[16:06:14.337]                       if (inherits(cond, "message")) {
[16:06:14.337]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.337]                         if (muffled) 
[16:06:14.337]                           invokeRestart("muffleMessage")
[16:06:14.337]                       }
[16:06:14.337]                       else if (inherits(cond, "warning")) {
[16:06:14.337]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.337]                         if (muffled) 
[16:06:14.337]                           invokeRestart("muffleWarning")
[16:06:14.337]                       }
[16:06:14.337]                       else if (inherits(cond, "condition")) {
[16:06:14.337]                         if (!is.null(pattern)) {
[16:06:14.337]                           computeRestarts <- base::computeRestarts
[16:06:14.337]                           grepl <- base::grepl
[16:06:14.337]                           restarts <- computeRestarts(cond)
[16:06:14.337]                           for (restart in restarts) {
[16:06:14.337]                             name <- restart$name
[16:06:14.337]                             if (is.null(name)) 
[16:06:14.337]                               next
[16:06:14.337]                             if (!grepl(pattern, name)) 
[16:06:14.337]                               next
[16:06:14.337]                             invokeRestart(restart)
[16:06:14.337]                             muffled <- TRUE
[16:06:14.337]                             break
[16:06:14.337]                           }
[16:06:14.337]                         }
[16:06:14.337]                       }
[16:06:14.337]                       invisible(muffled)
[16:06:14.337]                     }
[16:06:14.337]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.337]                   }
[16:06:14.337]                 }
[16:06:14.337]                 else {
[16:06:14.337]                   if (TRUE) {
[16:06:14.337]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.337]                     {
[16:06:14.337]                       inherits <- base::inherits
[16:06:14.337]                       invokeRestart <- base::invokeRestart
[16:06:14.337]                       is.null <- base::is.null
[16:06:14.337]                       muffled <- FALSE
[16:06:14.337]                       if (inherits(cond, "message")) {
[16:06:14.337]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.337]                         if (muffled) 
[16:06:14.337]                           invokeRestart("muffleMessage")
[16:06:14.337]                       }
[16:06:14.337]                       else if (inherits(cond, "warning")) {
[16:06:14.337]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.337]                         if (muffled) 
[16:06:14.337]                           invokeRestart("muffleWarning")
[16:06:14.337]                       }
[16:06:14.337]                       else if (inherits(cond, "condition")) {
[16:06:14.337]                         if (!is.null(pattern)) {
[16:06:14.337]                           computeRestarts <- base::computeRestarts
[16:06:14.337]                           grepl <- base::grepl
[16:06:14.337]                           restarts <- computeRestarts(cond)
[16:06:14.337]                           for (restart in restarts) {
[16:06:14.337]                             name <- restart$name
[16:06:14.337]                             if (is.null(name)) 
[16:06:14.337]                               next
[16:06:14.337]                             if (!grepl(pattern, name)) 
[16:06:14.337]                               next
[16:06:14.337]                             invokeRestart(restart)
[16:06:14.337]                             muffled <- TRUE
[16:06:14.337]                             break
[16:06:14.337]                           }
[16:06:14.337]                         }
[16:06:14.337]                       }
[16:06:14.337]                       invisible(muffled)
[16:06:14.337]                     }
[16:06:14.337]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.337]                   }
[16:06:14.337]                 }
[16:06:14.337]             }
[16:06:14.337]         }))
[16:06:14.337]     }, error = function(ex) {
[16:06:14.337]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.337]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.337]                 ...future.rng), started = ...future.startTime, 
[16:06:14.337]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.337]             version = "1.8"), class = "FutureResult")
[16:06:14.337]     }, finally = {
[16:06:14.337]         if (!identical(...future.workdir, getwd())) 
[16:06:14.337]             setwd(...future.workdir)
[16:06:14.337]         {
[16:06:14.337]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.337]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.337]             }
[16:06:14.337]             base::options(...future.oldOptions)
[16:06:14.337]             if (.Platform$OS.type == "windows") {
[16:06:14.337]                 old_names <- names(...future.oldEnvVars)
[16:06:14.337]                 envs <- base::Sys.getenv()
[16:06:14.337]                 names <- names(envs)
[16:06:14.337]                 common <- intersect(names, old_names)
[16:06:14.337]                 added <- setdiff(names, old_names)
[16:06:14.337]                 removed <- setdiff(old_names, names)
[16:06:14.337]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.337]                   envs[common]]
[16:06:14.337]                 NAMES <- toupper(changed)
[16:06:14.337]                 args <- list()
[16:06:14.337]                 for (kk in seq_along(NAMES)) {
[16:06:14.337]                   name <- changed[[kk]]
[16:06:14.337]                   NAME <- NAMES[[kk]]
[16:06:14.337]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.337]                     next
[16:06:14.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.337]                 }
[16:06:14.337]                 NAMES <- toupper(added)
[16:06:14.337]                 for (kk in seq_along(NAMES)) {
[16:06:14.337]                   name <- added[[kk]]
[16:06:14.337]                   NAME <- NAMES[[kk]]
[16:06:14.337]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.337]                     next
[16:06:14.337]                   args[[name]] <- ""
[16:06:14.337]                 }
[16:06:14.337]                 NAMES <- toupper(removed)
[16:06:14.337]                 for (kk in seq_along(NAMES)) {
[16:06:14.337]                   name <- removed[[kk]]
[16:06:14.337]                   NAME <- NAMES[[kk]]
[16:06:14.337]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.337]                     next
[16:06:14.337]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.337]                 }
[16:06:14.337]                 if (length(args) > 0) 
[16:06:14.337]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.337]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.337]             }
[16:06:14.337]             else {
[16:06:14.337]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.337]             }
[16:06:14.337]             {
[16:06:14.337]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.337]                   0L) {
[16:06:14.337]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.337]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.337]                   base::options(opts)
[16:06:14.337]                 }
[16:06:14.337]                 {
[16:06:14.337]                   {
[16:06:14.337]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.337]                     NULL
[16:06:14.337]                   }
[16:06:14.337]                   options(future.plan = NULL)
[16:06:14.337]                   if (is.na(NA_character_)) 
[16:06:14.337]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.337]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.337]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.337]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.337]                     envir = parent.frame()) 
[16:06:14.337]                   {
[16:06:14.337]                     if (is.function(workers)) 
[16:06:14.337]                       workers <- workers()
[16:06:14.337]                     workers <- structure(as.integer(workers), 
[16:06:14.337]                       class = class(workers))
[16:06:14.337]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.337]                       workers >= 1)
[16:06:14.337]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.337]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.337]                     }
[16:06:14.337]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.337]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.337]                       envir = envir)
[16:06:14.337]                     if (!future$lazy) 
[16:06:14.337]                       future <- run(future)
[16:06:14.337]                     invisible(future)
[16:06:14.337]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.337]                 }
[16:06:14.337]             }
[16:06:14.337]         }
[16:06:14.337]     })
[16:06:14.337]     if (TRUE) {
[16:06:14.337]         base::sink(type = "output", split = FALSE)
[16:06:14.337]         if (TRUE) {
[16:06:14.337]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.337]         }
[16:06:14.337]         else {
[16:06:14.337]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.337]         }
[16:06:14.337]         base::close(...future.stdout)
[16:06:14.337]         ...future.stdout <- NULL
[16:06:14.337]     }
[16:06:14.337]     ...future.result$conditions <- ...future.conditions
[16:06:14.337]     ...future.result$finished <- base::Sys.time()
[16:06:14.337]     ...future.result
[16:06:14.337] }
[16:06:14.340] MultisessionFuture started
[16:06:14.340] - Launch lazy future ... done
[16:06:14.340] run() for ‘MultisessionFuture’ ... done
[16:06:14.388] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.388] - Validating connection of MultisessionFuture
[16:06:14.389] - received message: FutureResult
[16:06:14.389] - Received FutureResult
[16:06:14.389] - Erased future from FutureRegistry
[16:06:14.389] result() for ClusterFuture ...
[16:06:14.389] - result already collected: FutureResult
[16:06:14.389] result() for ClusterFuture ... done
[16:06:14.389] signalConditions() ...
[16:06:14.389]  - include = ‘immediateCondition’
[16:06:14.389]  - exclude = 
[16:06:14.390]  - resignal = FALSE
[16:06:14.390]  - Number of conditions: 1
[16:06:14.390] signalConditions() ... done
[16:06:14.390] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.390] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[16:06:14.390] resolve() on list ...
[16:06:14.390]  recursive: 0
[16:06:14.390]  length: 2
[16:06:14.391]  elements: ‘a’, ‘b’
[16:06:14.391]  length: 1 (resolved future 1)
[16:06:14.391]  length: 0 (resolved future 2)
[16:06:14.391] resolve() on list ... DONE
[16:06:14.391] getGlobalsAndPackages() ...
[16:06:14.391] Searching for globals...
[16:06:14.391] 
[16:06:14.392] Searching for globals ... DONE
[16:06:14.392] - globals: [0] <none>
[16:06:14.392] getGlobalsAndPackages() ... DONE
[16:06:14.392] run() for ‘Future’ ...
[16:06:14.392] - state: ‘created’
[16:06:14.392] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.406] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.406]   - Field: ‘node’
[16:06:14.406]   - Field: ‘label’
[16:06:14.406]   - Field: ‘local’
[16:06:14.406]   - Field: ‘owner’
[16:06:14.407]   - Field: ‘envir’
[16:06:14.407]   - Field: ‘workers’
[16:06:14.407]   - Field: ‘packages’
[16:06:14.407]   - Field: ‘gc’
[16:06:14.407]   - Field: ‘conditions’
[16:06:14.407]   - Field: ‘persistent’
[16:06:14.407]   - Field: ‘expr’
[16:06:14.407]   - Field: ‘uuid’
[16:06:14.407]   - Field: ‘seed’
[16:06:14.407]   - Field: ‘version’
[16:06:14.408]   - Field: ‘result’
[16:06:14.408]   - Field: ‘asynchronous’
[16:06:14.408]   - Field: ‘calls’
[16:06:14.408]   - Field: ‘globals’
[16:06:14.408]   - Field: ‘stdout’
[16:06:14.408]   - Field: ‘earlySignal’
[16:06:14.408]   - Field: ‘lazy’
[16:06:14.408]   - Field: ‘state’
[16:06:14.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.408] - Launch lazy future ...
[16:06:14.409] Packages needed by the future expression (n = 0): <none>
[16:06:14.409] Packages needed by future strategies (n = 0): <none>
[16:06:14.409] {
[16:06:14.409]     {
[16:06:14.409]         {
[16:06:14.409]             ...future.startTime <- base::Sys.time()
[16:06:14.409]             {
[16:06:14.409]                 {
[16:06:14.409]                   {
[16:06:14.409]                     {
[16:06:14.409]                       base::local({
[16:06:14.409]                         has_future <- base::requireNamespace("future", 
[16:06:14.409]                           quietly = TRUE)
[16:06:14.409]                         if (has_future) {
[16:06:14.409]                           ns <- base::getNamespace("future")
[16:06:14.409]                           version <- ns[[".package"]][["version"]]
[16:06:14.409]                           if (is.null(version)) 
[16:06:14.409]                             version <- utils::packageVersion("future")
[16:06:14.409]                         }
[16:06:14.409]                         else {
[16:06:14.409]                           version <- NULL
[16:06:14.409]                         }
[16:06:14.409]                         if (!has_future || version < "1.8.0") {
[16:06:14.409]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.409]                             "", base::R.version$version.string), 
[16:06:14.409]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.409]                               "release", "version")], collapse = " "), 
[16:06:14.409]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.409]                             info)
[16:06:14.409]                           info <- base::paste(info, collapse = "; ")
[16:06:14.409]                           if (!has_future) {
[16:06:14.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.409]                               info)
[16:06:14.409]                           }
[16:06:14.409]                           else {
[16:06:14.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.409]                               info, version)
[16:06:14.409]                           }
[16:06:14.409]                           base::stop(msg)
[16:06:14.409]                         }
[16:06:14.409]                       })
[16:06:14.409]                     }
[16:06:14.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.409]                     base::options(mc.cores = 1L)
[16:06:14.409]                   }
[16:06:14.409]                   options(future.plan = NULL)
[16:06:14.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.409]                 }
[16:06:14.409]                 ...future.workdir <- getwd()
[16:06:14.409]             }
[16:06:14.409]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.409]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.409]         }
[16:06:14.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.409]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.409]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.409]             base::names(...future.oldOptions))
[16:06:14.409]     }
[16:06:14.409]     if (FALSE) {
[16:06:14.409]     }
[16:06:14.409]     else {
[16:06:14.409]         if (TRUE) {
[16:06:14.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.409]                 open = "w")
[16:06:14.409]         }
[16:06:14.409]         else {
[16:06:14.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.409]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.409]         }
[16:06:14.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.409]             base::sink(type = "output", split = FALSE)
[16:06:14.409]             base::close(...future.stdout)
[16:06:14.409]         }, add = TRUE)
[16:06:14.409]     }
[16:06:14.409]     ...future.frame <- base::sys.nframe()
[16:06:14.409]     ...future.conditions <- base::list()
[16:06:14.409]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.409]     if (FALSE) {
[16:06:14.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.409]     }
[16:06:14.409]     ...future.result <- base::tryCatch({
[16:06:14.409]         base::withCallingHandlers({
[16:06:14.409]             ...future.value <- base::withVisible(base::local({
[16:06:14.409]                 ...future.makeSendCondition <- base::local({
[16:06:14.409]                   sendCondition <- NULL
[16:06:14.409]                   function(frame = 1L) {
[16:06:14.409]                     if (is.function(sendCondition)) 
[16:06:14.409]                       return(sendCondition)
[16:06:14.409]                     ns <- getNamespace("parallel")
[16:06:14.409]                     if (exists("sendData", mode = "function", 
[16:06:14.409]                       envir = ns)) {
[16:06:14.409]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.409]                         envir = ns)
[16:06:14.409]                       envir <- sys.frame(frame)
[16:06:14.409]                       master <- NULL
[16:06:14.409]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.409]                         !identical(envir, emptyenv())) {
[16:06:14.409]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.409]                           inherits = FALSE)) {
[16:06:14.409]                           master <- get("master", mode = "list", 
[16:06:14.409]                             envir = envir, inherits = FALSE)
[16:06:14.409]                           if (inherits(master, c("SOCKnode", 
[16:06:14.409]                             "SOCK0node"))) {
[16:06:14.409]                             sendCondition <<- function(cond) {
[16:06:14.409]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.409]                                 success = TRUE)
[16:06:14.409]                               parallel_sendData(master, data)
[16:06:14.409]                             }
[16:06:14.409]                             return(sendCondition)
[16:06:14.409]                           }
[16:06:14.409]                         }
[16:06:14.409]                         frame <- frame + 1L
[16:06:14.409]                         envir <- sys.frame(frame)
[16:06:14.409]                       }
[16:06:14.409]                     }
[16:06:14.409]                     sendCondition <<- function(cond) NULL
[16:06:14.409]                   }
[16:06:14.409]                 })
[16:06:14.409]                 withCallingHandlers({
[16:06:14.409]                   1
[16:06:14.409]                 }, immediateCondition = function(cond) {
[16:06:14.409]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.409]                   sendCondition(cond)
[16:06:14.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.409]                   {
[16:06:14.409]                     inherits <- base::inherits
[16:06:14.409]                     invokeRestart <- base::invokeRestart
[16:06:14.409]                     is.null <- base::is.null
[16:06:14.409]                     muffled <- FALSE
[16:06:14.409]                     if (inherits(cond, "message")) {
[16:06:14.409]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.409]                       if (muffled) 
[16:06:14.409]                         invokeRestart("muffleMessage")
[16:06:14.409]                     }
[16:06:14.409]                     else if (inherits(cond, "warning")) {
[16:06:14.409]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.409]                       if (muffled) 
[16:06:14.409]                         invokeRestart("muffleWarning")
[16:06:14.409]                     }
[16:06:14.409]                     else if (inherits(cond, "condition")) {
[16:06:14.409]                       if (!is.null(pattern)) {
[16:06:14.409]                         computeRestarts <- base::computeRestarts
[16:06:14.409]                         grepl <- base::grepl
[16:06:14.409]                         restarts <- computeRestarts(cond)
[16:06:14.409]                         for (restart in restarts) {
[16:06:14.409]                           name <- restart$name
[16:06:14.409]                           if (is.null(name)) 
[16:06:14.409]                             next
[16:06:14.409]                           if (!grepl(pattern, name)) 
[16:06:14.409]                             next
[16:06:14.409]                           invokeRestart(restart)
[16:06:14.409]                           muffled <- TRUE
[16:06:14.409]                           break
[16:06:14.409]                         }
[16:06:14.409]                       }
[16:06:14.409]                     }
[16:06:14.409]                     invisible(muffled)
[16:06:14.409]                   }
[16:06:14.409]                   muffleCondition(cond)
[16:06:14.409]                 })
[16:06:14.409]             }))
[16:06:14.409]             future::FutureResult(value = ...future.value$value, 
[16:06:14.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.409]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.409]                     ...future.globalenv.names))
[16:06:14.409]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.409]         }, condition = base::local({
[16:06:14.409]             c <- base::c
[16:06:14.409]             inherits <- base::inherits
[16:06:14.409]             invokeRestart <- base::invokeRestart
[16:06:14.409]             length <- base::length
[16:06:14.409]             list <- base::list
[16:06:14.409]             seq.int <- base::seq.int
[16:06:14.409]             signalCondition <- base::signalCondition
[16:06:14.409]             sys.calls <- base::sys.calls
[16:06:14.409]             `[[` <- base::`[[`
[16:06:14.409]             `+` <- base::`+`
[16:06:14.409]             `<<-` <- base::`<<-`
[16:06:14.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.409]                   3L)]
[16:06:14.409]             }
[16:06:14.409]             function(cond) {
[16:06:14.409]                 is_error <- inherits(cond, "error")
[16:06:14.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.409]                   NULL)
[16:06:14.409]                 if (is_error) {
[16:06:14.409]                   sessionInformation <- function() {
[16:06:14.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.409]                       search = base::search(), system = base::Sys.info())
[16:06:14.409]                   }
[16:06:14.409]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.409]                     cond$call), session = sessionInformation(), 
[16:06:14.409]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.409]                   signalCondition(cond)
[16:06:14.409]                 }
[16:06:14.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.409]                 "immediateCondition"))) {
[16:06:14.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.409]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.409]                   if (TRUE && !signal) {
[16:06:14.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.409]                     {
[16:06:14.409]                       inherits <- base::inherits
[16:06:14.409]                       invokeRestart <- base::invokeRestart
[16:06:14.409]                       is.null <- base::is.null
[16:06:14.409]                       muffled <- FALSE
[16:06:14.409]                       if (inherits(cond, "message")) {
[16:06:14.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.409]                         if (muffled) 
[16:06:14.409]                           invokeRestart("muffleMessage")
[16:06:14.409]                       }
[16:06:14.409]                       else if (inherits(cond, "warning")) {
[16:06:14.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.409]                         if (muffled) 
[16:06:14.409]                           invokeRestart("muffleWarning")
[16:06:14.409]                       }
[16:06:14.409]                       else if (inherits(cond, "condition")) {
[16:06:14.409]                         if (!is.null(pattern)) {
[16:06:14.409]                           computeRestarts <- base::computeRestarts
[16:06:14.409]                           grepl <- base::grepl
[16:06:14.409]                           restarts <- computeRestarts(cond)
[16:06:14.409]                           for (restart in restarts) {
[16:06:14.409]                             name <- restart$name
[16:06:14.409]                             if (is.null(name)) 
[16:06:14.409]                               next
[16:06:14.409]                             if (!grepl(pattern, name)) 
[16:06:14.409]                               next
[16:06:14.409]                             invokeRestart(restart)
[16:06:14.409]                             muffled <- TRUE
[16:06:14.409]                             break
[16:06:14.409]                           }
[16:06:14.409]                         }
[16:06:14.409]                       }
[16:06:14.409]                       invisible(muffled)
[16:06:14.409]                     }
[16:06:14.409]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.409]                   }
[16:06:14.409]                 }
[16:06:14.409]                 else {
[16:06:14.409]                   if (TRUE) {
[16:06:14.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.409]                     {
[16:06:14.409]                       inherits <- base::inherits
[16:06:14.409]                       invokeRestart <- base::invokeRestart
[16:06:14.409]                       is.null <- base::is.null
[16:06:14.409]                       muffled <- FALSE
[16:06:14.409]                       if (inherits(cond, "message")) {
[16:06:14.409]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.409]                         if (muffled) 
[16:06:14.409]                           invokeRestart("muffleMessage")
[16:06:14.409]                       }
[16:06:14.409]                       else if (inherits(cond, "warning")) {
[16:06:14.409]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.409]                         if (muffled) 
[16:06:14.409]                           invokeRestart("muffleWarning")
[16:06:14.409]                       }
[16:06:14.409]                       else if (inherits(cond, "condition")) {
[16:06:14.409]                         if (!is.null(pattern)) {
[16:06:14.409]                           computeRestarts <- base::computeRestarts
[16:06:14.409]                           grepl <- base::grepl
[16:06:14.409]                           restarts <- computeRestarts(cond)
[16:06:14.409]                           for (restart in restarts) {
[16:06:14.409]                             name <- restart$name
[16:06:14.409]                             if (is.null(name)) 
[16:06:14.409]                               next
[16:06:14.409]                             if (!grepl(pattern, name)) 
[16:06:14.409]                               next
[16:06:14.409]                             invokeRestart(restart)
[16:06:14.409]                             muffled <- TRUE
[16:06:14.409]                             break
[16:06:14.409]                           }
[16:06:14.409]                         }
[16:06:14.409]                       }
[16:06:14.409]                       invisible(muffled)
[16:06:14.409]                     }
[16:06:14.409]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.409]                   }
[16:06:14.409]                 }
[16:06:14.409]             }
[16:06:14.409]         }))
[16:06:14.409]     }, error = function(ex) {
[16:06:14.409]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.409]                 ...future.rng), started = ...future.startTime, 
[16:06:14.409]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.409]             version = "1.8"), class = "FutureResult")
[16:06:14.409]     }, finally = {
[16:06:14.409]         if (!identical(...future.workdir, getwd())) 
[16:06:14.409]             setwd(...future.workdir)
[16:06:14.409]         {
[16:06:14.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.409]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.409]             }
[16:06:14.409]             base::options(...future.oldOptions)
[16:06:14.409]             if (.Platform$OS.type == "windows") {
[16:06:14.409]                 old_names <- names(...future.oldEnvVars)
[16:06:14.409]                 envs <- base::Sys.getenv()
[16:06:14.409]                 names <- names(envs)
[16:06:14.409]                 common <- intersect(names, old_names)
[16:06:14.409]                 added <- setdiff(names, old_names)
[16:06:14.409]                 removed <- setdiff(old_names, names)
[16:06:14.409]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.409]                   envs[common]]
[16:06:14.409]                 NAMES <- toupper(changed)
[16:06:14.409]                 args <- list()
[16:06:14.409]                 for (kk in seq_along(NAMES)) {
[16:06:14.409]                   name <- changed[[kk]]
[16:06:14.409]                   NAME <- NAMES[[kk]]
[16:06:14.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.409]                     next
[16:06:14.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.409]                 }
[16:06:14.409]                 NAMES <- toupper(added)
[16:06:14.409]                 for (kk in seq_along(NAMES)) {
[16:06:14.409]                   name <- added[[kk]]
[16:06:14.409]                   NAME <- NAMES[[kk]]
[16:06:14.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.409]                     next
[16:06:14.409]                   args[[name]] <- ""
[16:06:14.409]                 }
[16:06:14.409]                 NAMES <- toupper(removed)
[16:06:14.409]                 for (kk in seq_along(NAMES)) {
[16:06:14.409]                   name <- removed[[kk]]
[16:06:14.409]                   NAME <- NAMES[[kk]]
[16:06:14.409]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.409]                     next
[16:06:14.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.409]                 }
[16:06:14.409]                 if (length(args) > 0) 
[16:06:14.409]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.409]             }
[16:06:14.409]             else {
[16:06:14.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.409]             }
[16:06:14.409]             {
[16:06:14.409]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.409]                   0L) {
[16:06:14.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.409]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.409]                   base::options(opts)
[16:06:14.409]                 }
[16:06:14.409]                 {
[16:06:14.409]                   {
[16:06:14.409]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.409]                     NULL
[16:06:14.409]                   }
[16:06:14.409]                   options(future.plan = NULL)
[16:06:14.409]                   if (is.na(NA_character_)) 
[16:06:14.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.409]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.409]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.409]                     envir = parent.frame()) 
[16:06:14.409]                   {
[16:06:14.409]                     if (is.function(workers)) 
[16:06:14.409]                       workers <- workers()
[16:06:14.409]                     workers <- structure(as.integer(workers), 
[16:06:14.409]                       class = class(workers))
[16:06:14.409]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.409]                       workers >= 1)
[16:06:14.409]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.409]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.409]                     }
[16:06:14.409]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.409]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.409]                       envir = envir)
[16:06:14.409]                     if (!future$lazy) 
[16:06:14.409]                       future <- run(future)
[16:06:14.409]                     invisible(future)
[16:06:14.409]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.409]                 }
[16:06:14.409]             }
[16:06:14.409]         }
[16:06:14.409]     })
[16:06:14.409]     if (TRUE) {
[16:06:14.409]         base::sink(type = "output", split = FALSE)
[16:06:14.409]         if (TRUE) {
[16:06:14.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.409]         }
[16:06:14.409]         else {
[16:06:14.409]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.409]         }
[16:06:14.409]         base::close(...future.stdout)
[16:06:14.409]         ...future.stdout <- NULL
[16:06:14.409]     }
[16:06:14.409]     ...future.result$conditions <- ...future.conditions
[16:06:14.409]     ...future.result$finished <- base::Sys.time()
[16:06:14.409]     ...future.result
[16:06:14.409] }
[16:06:14.412] MultisessionFuture started
[16:06:14.412] - Launch lazy future ... done
[16:06:14.413] run() for ‘MultisessionFuture’ ... done
[16:06:14.413] getGlobalsAndPackages() ...
[16:06:14.413] Searching for globals...
[16:06:14.413] 
[16:06:14.413] Searching for globals ... DONE
[16:06:14.413] - globals: [0] <none>
[16:06:14.413] getGlobalsAndPackages() ... DONE
[16:06:14.414] run() for ‘Future’ ...
[16:06:14.414] - state: ‘created’
[16:06:14.414] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.428]   - Field: ‘node’
[16:06:14.428]   - Field: ‘label’
[16:06:14.428]   - Field: ‘local’
[16:06:14.428]   - Field: ‘owner’
[16:06:14.428]   - Field: ‘envir’
[16:06:14.428]   - Field: ‘workers’
[16:06:14.428]   - Field: ‘packages’
[16:06:14.428]   - Field: ‘gc’
[16:06:14.428]   - Field: ‘conditions’
[16:06:14.428]   - Field: ‘persistent’
[16:06:14.428]   - Field: ‘expr’
[16:06:14.429]   - Field: ‘uuid’
[16:06:14.429]   - Field: ‘seed’
[16:06:14.429]   - Field: ‘version’
[16:06:14.429]   - Field: ‘result’
[16:06:14.429]   - Field: ‘asynchronous’
[16:06:14.429]   - Field: ‘calls’
[16:06:14.429]   - Field: ‘globals’
[16:06:14.429]   - Field: ‘stdout’
[16:06:14.429]   - Field: ‘earlySignal’
[16:06:14.429]   - Field: ‘lazy’
[16:06:14.429]   - Field: ‘state’
[16:06:14.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.430] - Launch lazy future ...
[16:06:14.430] Packages needed by the future expression (n = 0): <none>
[16:06:14.430] Packages needed by future strategies (n = 0): <none>
[16:06:14.430] {
[16:06:14.430]     {
[16:06:14.430]         {
[16:06:14.430]             ...future.startTime <- base::Sys.time()
[16:06:14.430]             {
[16:06:14.430]                 {
[16:06:14.430]                   {
[16:06:14.430]                     {
[16:06:14.430]                       base::local({
[16:06:14.430]                         has_future <- base::requireNamespace("future", 
[16:06:14.430]                           quietly = TRUE)
[16:06:14.430]                         if (has_future) {
[16:06:14.430]                           ns <- base::getNamespace("future")
[16:06:14.430]                           version <- ns[[".package"]][["version"]]
[16:06:14.430]                           if (is.null(version)) 
[16:06:14.430]                             version <- utils::packageVersion("future")
[16:06:14.430]                         }
[16:06:14.430]                         else {
[16:06:14.430]                           version <- NULL
[16:06:14.430]                         }
[16:06:14.430]                         if (!has_future || version < "1.8.0") {
[16:06:14.430]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.430]                             "", base::R.version$version.string), 
[16:06:14.430]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.430]                               "release", "version")], collapse = " "), 
[16:06:14.430]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.430]                             info)
[16:06:14.430]                           info <- base::paste(info, collapse = "; ")
[16:06:14.430]                           if (!has_future) {
[16:06:14.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.430]                               info)
[16:06:14.430]                           }
[16:06:14.430]                           else {
[16:06:14.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.430]                               info, version)
[16:06:14.430]                           }
[16:06:14.430]                           base::stop(msg)
[16:06:14.430]                         }
[16:06:14.430]                       })
[16:06:14.430]                     }
[16:06:14.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.430]                     base::options(mc.cores = 1L)
[16:06:14.430]                   }
[16:06:14.430]                   options(future.plan = NULL)
[16:06:14.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.430]                 }
[16:06:14.430]                 ...future.workdir <- getwd()
[16:06:14.430]             }
[16:06:14.430]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.430]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.430]         }
[16:06:14.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.430]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.430]             base::names(...future.oldOptions))
[16:06:14.430]     }
[16:06:14.430]     if (FALSE) {
[16:06:14.430]     }
[16:06:14.430]     else {
[16:06:14.430]         if (TRUE) {
[16:06:14.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.430]                 open = "w")
[16:06:14.430]         }
[16:06:14.430]         else {
[16:06:14.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.430]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.430]         }
[16:06:14.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.430]             base::sink(type = "output", split = FALSE)
[16:06:14.430]             base::close(...future.stdout)
[16:06:14.430]         }, add = TRUE)
[16:06:14.430]     }
[16:06:14.430]     ...future.frame <- base::sys.nframe()
[16:06:14.430]     ...future.conditions <- base::list()
[16:06:14.430]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.430]     if (FALSE) {
[16:06:14.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.430]     }
[16:06:14.430]     ...future.result <- base::tryCatch({
[16:06:14.430]         base::withCallingHandlers({
[16:06:14.430]             ...future.value <- base::withVisible(base::local({
[16:06:14.430]                 ...future.makeSendCondition <- base::local({
[16:06:14.430]                   sendCondition <- NULL
[16:06:14.430]                   function(frame = 1L) {
[16:06:14.430]                     if (is.function(sendCondition)) 
[16:06:14.430]                       return(sendCondition)
[16:06:14.430]                     ns <- getNamespace("parallel")
[16:06:14.430]                     if (exists("sendData", mode = "function", 
[16:06:14.430]                       envir = ns)) {
[16:06:14.430]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.430]                         envir = ns)
[16:06:14.430]                       envir <- sys.frame(frame)
[16:06:14.430]                       master <- NULL
[16:06:14.430]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.430]                         !identical(envir, emptyenv())) {
[16:06:14.430]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.430]                           inherits = FALSE)) {
[16:06:14.430]                           master <- get("master", mode = "list", 
[16:06:14.430]                             envir = envir, inherits = FALSE)
[16:06:14.430]                           if (inherits(master, c("SOCKnode", 
[16:06:14.430]                             "SOCK0node"))) {
[16:06:14.430]                             sendCondition <<- function(cond) {
[16:06:14.430]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.430]                                 success = TRUE)
[16:06:14.430]                               parallel_sendData(master, data)
[16:06:14.430]                             }
[16:06:14.430]                             return(sendCondition)
[16:06:14.430]                           }
[16:06:14.430]                         }
[16:06:14.430]                         frame <- frame + 1L
[16:06:14.430]                         envir <- sys.frame(frame)
[16:06:14.430]                       }
[16:06:14.430]                     }
[16:06:14.430]                     sendCondition <<- function(cond) NULL
[16:06:14.430]                   }
[16:06:14.430]                 })
[16:06:14.430]                 withCallingHandlers({
[16:06:14.430]                   2
[16:06:14.430]                 }, immediateCondition = function(cond) {
[16:06:14.430]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.430]                   sendCondition(cond)
[16:06:14.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.430]                   {
[16:06:14.430]                     inherits <- base::inherits
[16:06:14.430]                     invokeRestart <- base::invokeRestart
[16:06:14.430]                     is.null <- base::is.null
[16:06:14.430]                     muffled <- FALSE
[16:06:14.430]                     if (inherits(cond, "message")) {
[16:06:14.430]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.430]                       if (muffled) 
[16:06:14.430]                         invokeRestart("muffleMessage")
[16:06:14.430]                     }
[16:06:14.430]                     else if (inherits(cond, "warning")) {
[16:06:14.430]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.430]                       if (muffled) 
[16:06:14.430]                         invokeRestart("muffleWarning")
[16:06:14.430]                     }
[16:06:14.430]                     else if (inherits(cond, "condition")) {
[16:06:14.430]                       if (!is.null(pattern)) {
[16:06:14.430]                         computeRestarts <- base::computeRestarts
[16:06:14.430]                         grepl <- base::grepl
[16:06:14.430]                         restarts <- computeRestarts(cond)
[16:06:14.430]                         for (restart in restarts) {
[16:06:14.430]                           name <- restart$name
[16:06:14.430]                           if (is.null(name)) 
[16:06:14.430]                             next
[16:06:14.430]                           if (!grepl(pattern, name)) 
[16:06:14.430]                             next
[16:06:14.430]                           invokeRestart(restart)
[16:06:14.430]                           muffled <- TRUE
[16:06:14.430]                           break
[16:06:14.430]                         }
[16:06:14.430]                       }
[16:06:14.430]                     }
[16:06:14.430]                     invisible(muffled)
[16:06:14.430]                   }
[16:06:14.430]                   muffleCondition(cond)
[16:06:14.430]                 })
[16:06:14.430]             }))
[16:06:14.430]             future::FutureResult(value = ...future.value$value, 
[16:06:14.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.430]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.430]                     ...future.globalenv.names))
[16:06:14.430]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.430]         }, condition = base::local({
[16:06:14.430]             c <- base::c
[16:06:14.430]             inherits <- base::inherits
[16:06:14.430]             invokeRestart <- base::invokeRestart
[16:06:14.430]             length <- base::length
[16:06:14.430]             list <- base::list
[16:06:14.430]             seq.int <- base::seq.int
[16:06:14.430]             signalCondition <- base::signalCondition
[16:06:14.430]             sys.calls <- base::sys.calls
[16:06:14.430]             `[[` <- base::`[[`
[16:06:14.430]             `+` <- base::`+`
[16:06:14.430]             `<<-` <- base::`<<-`
[16:06:14.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.430]                   3L)]
[16:06:14.430]             }
[16:06:14.430]             function(cond) {
[16:06:14.430]                 is_error <- inherits(cond, "error")
[16:06:14.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.430]                   NULL)
[16:06:14.430]                 if (is_error) {
[16:06:14.430]                   sessionInformation <- function() {
[16:06:14.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.430]                       search = base::search(), system = base::Sys.info())
[16:06:14.430]                   }
[16:06:14.430]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.430]                     cond$call), session = sessionInformation(), 
[16:06:14.430]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.430]                   signalCondition(cond)
[16:06:14.430]                 }
[16:06:14.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.430]                 "immediateCondition"))) {
[16:06:14.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.430]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.430]                   if (TRUE && !signal) {
[16:06:14.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.430]                     {
[16:06:14.430]                       inherits <- base::inherits
[16:06:14.430]                       invokeRestart <- base::invokeRestart
[16:06:14.430]                       is.null <- base::is.null
[16:06:14.430]                       muffled <- FALSE
[16:06:14.430]                       if (inherits(cond, "message")) {
[16:06:14.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.430]                         if (muffled) 
[16:06:14.430]                           invokeRestart("muffleMessage")
[16:06:14.430]                       }
[16:06:14.430]                       else if (inherits(cond, "warning")) {
[16:06:14.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.430]                         if (muffled) 
[16:06:14.430]                           invokeRestart("muffleWarning")
[16:06:14.430]                       }
[16:06:14.430]                       else if (inherits(cond, "condition")) {
[16:06:14.430]                         if (!is.null(pattern)) {
[16:06:14.430]                           computeRestarts <- base::computeRestarts
[16:06:14.430]                           grepl <- base::grepl
[16:06:14.430]                           restarts <- computeRestarts(cond)
[16:06:14.430]                           for (restart in restarts) {
[16:06:14.430]                             name <- restart$name
[16:06:14.430]                             if (is.null(name)) 
[16:06:14.430]                               next
[16:06:14.430]                             if (!grepl(pattern, name)) 
[16:06:14.430]                               next
[16:06:14.430]                             invokeRestart(restart)
[16:06:14.430]                             muffled <- TRUE
[16:06:14.430]                             break
[16:06:14.430]                           }
[16:06:14.430]                         }
[16:06:14.430]                       }
[16:06:14.430]                       invisible(muffled)
[16:06:14.430]                     }
[16:06:14.430]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.430]                   }
[16:06:14.430]                 }
[16:06:14.430]                 else {
[16:06:14.430]                   if (TRUE) {
[16:06:14.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.430]                     {
[16:06:14.430]                       inherits <- base::inherits
[16:06:14.430]                       invokeRestart <- base::invokeRestart
[16:06:14.430]                       is.null <- base::is.null
[16:06:14.430]                       muffled <- FALSE
[16:06:14.430]                       if (inherits(cond, "message")) {
[16:06:14.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.430]                         if (muffled) 
[16:06:14.430]                           invokeRestart("muffleMessage")
[16:06:14.430]                       }
[16:06:14.430]                       else if (inherits(cond, "warning")) {
[16:06:14.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.430]                         if (muffled) 
[16:06:14.430]                           invokeRestart("muffleWarning")
[16:06:14.430]                       }
[16:06:14.430]                       else if (inherits(cond, "condition")) {
[16:06:14.430]                         if (!is.null(pattern)) {
[16:06:14.430]                           computeRestarts <- base::computeRestarts
[16:06:14.430]                           grepl <- base::grepl
[16:06:14.430]                           restarts <- computeRestarts(cond)
[16:06:14.430]                           for (restart in restarts) {
[16:06:14.430]                             name <- restart$name
[16:06:14.430]                             if (is.null(name)) 
[16:06:14.430]                               next
[16:06:14.430]                             if (!grepl(pattern, name)) 
[16:06:14.430]                               next
[16:06:14.430]                             invokeRestart(restart)
[16:06:14.430]                             muffled <- TRUE
[16:06:14.430]                             break
[16:06:14.430]                           }
[16:06:14.430]                         }
[16:06:14.430]                       }
[16:06:14.430]                       invisible(muffled)
[16:06:14.430]                     }
[16:06:14.430]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.430]                   }
[16:06:14.430]                 }
[16:06:14.430]             }
[16:06:14.430]         }))
[16:06:14.430]     }, error = function(ex) {
[16:06:14.430]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.430]                 ...future.rng), started = ...future.startTime, 
[16:06:14.430]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.430]             version = "1.8"), class = "FutureResult")
[16:06:14.430]     }, finally = {
[16:06:14.430]         if (!identical(...future.workdir, getwd())) 
[16:06:14.430]             setwd(...future.workdir)
[16:06:14.430]         {
[16:06:14.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.430]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.430]             }
[16:06:14.430]             base::options(...future.oldOptions)
[16:06:14.430]             if (.Platform$OS.type == "windows") {
[16:06:14.430]                 old_names <- names(...future.oldEnvVars)
[16:06:14.430]                 envs <- base::Sys.getenv()
[16:06:14.430]                 names <- names(envs)
[16:06:14.430]                 common <- intersect(names, old_names)
[16:06:14.430]                 added <- setdiff(names, old_names)
[16:06:14.430]                 removed <- setdiff(old_names, names)
[16:06:14.430]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.430]                   envs[common]]
[16:06:14.430]                 NAMES <- toupper(changed)
[16:06:14.430]                 args <- list()
[16:06:14.430]                 for (kk in seq_along(NAMES)) {
[16:06:14.430]                   name <- changed[[kk]]
[16:06:14.430]                   NAME <- NAMES[[kk]]
[16:06:14.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.430]                     next
[16:06:14.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.430]                 }
[16:06:14.430]                 NAMES <- toupper(added)
[16:06:14.430]                 for (kk in seq_along(NAMES)) {
[16:06:14.430]                   name <- added[[kk]]
[16:06:14.430]                   NAME <- NAMES[[kk]]
[16:06:14.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.430]                     next
[16:06:14.430]                   args[[name]] <- ""
[16:06:14.430]                 }
[16:06:14.430]                 NAMES <- toupper(removed)
[16:06:14.430]                 for (kk in seq_along(NAMES)) {
[16:06:14.430]                   name <- removed[[kk]]
[16:06:14.430]                   NAME <- NAMES[[kk]]
[16:06:14.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.430]                     next
[16:06:14.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.430]                 }
[16:06:14.430]                 if (length(args) > 0) 
[16:06:14.430]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.430]             }
[16:06:14.430]             else {
[16:06:14.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.430]             }
[16:06:14.430]             {
[16:06:14.430]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.430]                   0L) {
[16:06:14.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.430]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.430]                   base::options(opts)
[16:06:14.430]                 }
[16:06:14.430]                 {
[16:06:14.430]                   {
[16:06:14.430]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.430]                     NULL
[16:06:14.430]                   }
[16:06:14.430]                   options(future.plan = NULL)
[16:06:14.430]                   if (is.na(NA_character_)) 
[16:06:14.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.430]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.430]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.430]                     envir = parent.frame()) 
[16:06:14.430]                   {
[16:06:14.430]                     if (is.function(workers)) 
[16:06:14.430]                       workers <- workers()
[16:06:14.430]                     workers <- structure(as.integer(workers), 
[16:06:14.430]                       class = class(workers))
[16:06:14.430]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.430]                       workers >= 1)
[16:06:14.430]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.430]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.430]                     }
[16:06:14.430]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.430]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.430]                       envir = envir)
[16:06:14.430]                     if (!future$lazy) 
[16:06:14.430]                       future <- run(future)
[16:06:14.430]                     invisible(future)
[16:06:14.430]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.430]                 }
[16:06:14.430]             }
[16:06:14.430]         }
[16:06:14.430]     })
[16:06:14.430]     if (TRUE) {
[16:06:14.430]         base::sink(type = "output", split = FALSE)
[16:06:14.430]         if (TRUE) {
[16:06:14.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.430]         }
[16:06:14.430]         else {
[16:06:14.430]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.430]         }
[16:06:14.430]         base::close(...future.stdout)
[16:06:14.430]         ...future.stdout <- NULL
[16:06:14.430]     }
[16:06:14.430]     ...future.result$conditions <- ...future.conditions
[16:06:14.430]     ...future.result$finished <- base::Sys.time()
[16:06:14.430]     ...future.result
[16:06:14.430] }
[16:06:14.433] Poll #1 (0): usedNodes() = 2, workers = 2
[16:06:14.443] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.444] - Validating connection of MultisessionFuture
[16:06:14.444] - received message: FutureResult
[16:06:14.444] - Received FutureResult
[16:06:14.444] - Erased future from FutureRegistry
[16:06:14.444] result() for ClusterFuture ...
[16:06:14.444] - result already collected: FutureResult
[16:06:14.444] result() for ClusterFuture ... done
[16:06:14.444] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.444] result() for ClusterFuture ...
[16:06:14.445] - result already collected: FutureResult
[16:06:14.445] result() for ClusterFuture ... done
[16:06:14.445] result() for ClusterFuture ...
[16:06:14.445] - result already collected: FutureResult
[16:06:14.445] result() for ClusterFuture ... done
[16:06:14.446] MultisessionFuture started
[16:06:14.446] - Launch lazy future ... done
[16:06:14.446] run() for ‘MultisessionFuture’ ... done
[16:06:14.446] resolve() on list ...
[16:06:14.446]  recursive: 0
[16:06:14.446]  length: 3
[16:06:14.447]  elements: ‘a’, ‘b’, ‘’
[16:06:14.468]  length: 2 (resolved future 3)
[16:06:14.478] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.478] - Validating connection of MultisessionFuture
[16:06:14.479] - received message: FutureResult
[16:06:14.479] - Received FutureResult
[16:06:14.479] - Erased future from FutureRegistry
[16:06:14.479] result() for ClusterFuture ...
[16:06:14.479] - result already collected: FutureResult
[16:06:14.479] result() for ClusterFuture ... done
[16:06:14.479] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.479] Future #1
[16:06:14.479]  length: 1 (resolved future 1)
[16:06:14.500] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.501] - Validating connection of MultisessionFuture
[16:06:14.501] - received message: FutureResult
[16:06:14.501] - Received FutureResult
[16:06:14.501] - Erased future from FutureRegistry
[16:06:14.501] result() for ClusterFuture ...
[16:06:14.501] - result already collected: FutureResult
[16:06:14.501] result() for ClusterFuture ... done
[16:06:14.501] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.502] Future #2
[16:06:14.502]  length: 0 (resolved future 2)
[16:06:14.502] resolve() on list ... DONE
[16:06:14.502] getGlobalsAndPackages() ...
[16:06:14.502] Searching for globals...
[16:06:14.502] 
[16:06:14.502] Searching for globals ... DONE
[16:06:14.503] - globals: [0] <none>
[16:06:14.503] getGlobalsAndPackages() ... DONE
[16:06:14.503] getGlobalsAndPackages() ...
[16:06:14.503] Searching for globals...
[16:06:14.503] 
[16:06:14.503] Searching for globals ... DONE
[16:06:14.503] - globals: [0] <none>
[16:06:14.504] getGlobalsAndPackages() ... DONE
[16:06:14.504] run() for ‘Future’ ...
[16:06:14.504] - state: ‘created’
[16:06:14.504] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.518] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.518]   - Field: ‘node’
[16:06:14.518]   - Field: ‘label’
[16:06:14.518]   - Field: ‘local’
[16:06:14.518]   - Field: ‘owner’
[16:06:14.519]   - Field: ‘envir’
[16:06:14.519]   - Field: ‘workers’
[16:06:14.519]   - Field: ‘packages’
[16:06:14.519]   - Field: ‘gc’
[16:06:14.519]   - Field: ‘conditions’
[16:06:14.519]   - Field: ‘persistent’
[16:06:14.519]   - Field: ‘expr’
[16:06:14.519]   - Field: ‘uuid’
[16:06:14.519]   - Field: ‘seed’
[16:06:14.519]   - Field: ‘version’
[16:06:14.519]   - Field: ‘result’
[16:06:14.520]   - Field: ‘asynchronous’
[16:06:14.520]   - Field: ‘calls’
[16:06:14.520]   - Field: ‘globals’
[16:06:14.520]   - Field: ‘stdout’
[16:06:14.520]   - Field: ‘earlySignal’
[16:06:14.520]   - Field: ‘lazy’
[16:06:14.520]   - Field: ‘state’
[16:06:14.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.520] - Launch lazy future ...
[16:06:14.521] Packages needed by the future expression (n = 0): <none>
[16:06:14.521] Packages needed by future strategies (n = 0): <none>
[16:06:14.521] {
[16:06:14.521]     {
[16:06:14.521]         {
[16:06:14.521]             ...future.startTime <- base::Sys.time()
[16:06:14.521]             {
[16:06:14.521]                 {
[16:06:14.521]                   {
[16:06:14.521]                     {
[16:06:14.521]                       base::local({
[16:06:14.521]                         has_future <- base::requireNamespace("future", 
[16:06:14.521]                           quietly = TRUE)
[16:06:14.521]                         if (has_future) {
[16:06:14.521]                           ns <- base::getNamespace("future")
[16:06:14.521]                           version <- ns[[".package"]][["version"]]
[16:06:14.521]                           if (is.null(version)) 
[16:06:14.521]                             version <- utils::packageVersion("future")
[16:06:14.521]                         }
[16:06:14.521]                         else {
[16:06:14.521]                           version <- NULL
[16:06:14.521]                         }
[16:06:14.521]                         if (!has_future || version < "1.8.0") {
[16:06:14.521]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.521]                             "", base::R.version$version.string), 
[16:06:14.521]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.521]                               "release", "version")], collapse = " "), 
[16:06:14.521]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.521]                             info)
[16:06:14.521]                           info <- base::paste(info, collapse = "; ")
[16:06:14.521]                           if (!has_future) {
[16:06:14.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.521]                               info)
[16:06:14.521]                           }
[16:06:14.521]                           else {
[16:06:14.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.521]                               info, version)
[16:06:14.521]                           }
[16:06:14.521]                           base::stop(msg)
[16:06:14.521]                         }
[16:06:14.521]                       })
[16:06:14.521]                     }
[16:06:14.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.521]                     base::options(mc.cores = 1L)
[16:06:14.521]                   }
[16:06:14.521]                   options(future.plan = NULL)
[16:06:14.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.521]                 }
[16:06:14.521]                 ...future.workdir <- getwd()
[16:06:14.521]             }
[16:06:14.521]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.521]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.521]         }
[16:06:14.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.521]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.521]             base::names(...future.oldOptions))
[16:06:14.521]     }
[16:06:14.521]     if (FALSE) {
[16:06:14.521]     }
[16:06:14.521]     else {
[16:06:14.521]         if (TRUE) {
[16:06:14.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.521]                 open = "w")
[16:06:14.521]         }
[16:06:14.521]         else {
[16:06:14.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.521]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.521]         }
[16:06:14.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.521]             base::sink(type = "output", split = FALSE)
[16:06:14.521]             base::close(...future.stdout)
[16:06:14.521]         }, add = TRUE)
[16:06:14.521]     }
[16:06:14.521]     ...future.frame <- base::sys.nframe()
[16:06:14.521]     ...future.conditions <- base::list()
[16:06:14.521]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.521]     if (FALSE) {
[16:06:14.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.521]     }
[16:06:14.521]     ...future.result <- base::tryCatch({
[16:06:14.521]         base::withCallingHandlers({
[16:06:14.521]             ...future.value <- base::withVisible(base::local({
[16:06:14.521]                 ...future.makeSendCondition <- base::local({
[16:06:14.521]                   sendCondition <- NULL
[16:06:14.521]                   function(frame = 1L) {
[16:06:14.521]                     if (is.function(sendCondition)) 
[16:06:14.521]                       return(sendCondition)
[16:06:14.521]                     ns <- getNamespace("parallel")
[16:06:14.521]                     if (exists("sendData", mode = "function", 
[16:06:14.521]                       envir = ns)) {
[16:06:14.521]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.521]                         envir = ns)
[16:06:14.521]                       envir <- sys.frame(frame)
[16:06:14.521]                       master <- NULL
[16:06:14.521]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.521]                         !identical(envir, emptyenv())) {
[16:06:14.521]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.521]                           inherits = FALSE)) {
[16:06:14.521]                           master <- get("master", mode = "list", 
[16:06:14.521]                             envir = envir, inherits = FALSE)
[16:06:14.521]                           if (inherits(master, c("SOCKnode", 
[16:06:14.521]                             "SOCK0node"))) {
[16:06:14.521]                             sendCondition <<- function(cond) {
[16:06:14.521]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.521]                                 success = TRUE)
[16:06:14.521]                               parallel_sendData(master, data)
[16:06:14.521]                             }
[16:06:14.521]                             return(sendCondition)
[16:06:14.521]                           }
[16:06:14.521]                         }
[16:06:14.521]                         frame <- frame + 1L
[16:06:14.521]                         envir <- sys.frame(frame)
[16:06:14.521]                       }
[16:06:14.521]                     }
[16:06:14.521]                     sendCondition <<- function(cond) NULL
[16:06:14.521]                   }
[16:06:14.521]                 })
[16:06:14.521]                 withCallingHandlers({
[16:06:14.521]                   2
[16:06:14.521]                 }, immediateCondition = function(cond) {
[16:06:14.521]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.521]                   sendCondition(cond)
[16:06:14.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.521]                   {
[16:06:14.521]                     inherits <- base::inherits
[16:06:14.521]                     invokeRestart <- base::invokeRestart
[16:06:14.521]                     is.null <- base::is.null
[16:06:14.521]                     muffled <- FALSE
[16:06:14.521]                     if (inherits(cond, "message")) {
[16:06:14.521]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.521]                       if (muffled) 
[16:06:14.521]                         invokeRestart("muffleMessage")
[16:06:14.521]                     }
[16:06:14.521]                     else if (inherits(cond, "warning")) {
[16:06:14.521]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.521]                       if (muffled) 
[16:06:14.521]                         invokeRestart("muffleWarning")
[16:06:14.521]                     }
[16:06:14.521]                     else if (inherits(cond, "condition")) {
[16:06:14.521]                       if (!is.null(pattern)) {
[16:06:14.521]                         computeRestarts <- base::computeRestarts
[16:06:14.521]                         grepl <- base::grepl
[16:06:14.521]                         restarts <- computeRestarts(cond)
[16:06:14.521]                         for (restart in restarts) {
[16:06:14.521]                           name <- restart$name
[16:06:14.521]                           if (is.null(name)) 
[16:06:14.521]                             next
[16:06:14.521]                           if (!grepl(pattern, name)) 
[16:06:14.521]                             next
[16:06:14.521]                           invokeRestart(restart)
[16:06:14.521]                           muffled <- TRUE
[16:06:14.521]                           break
[16:06:14.521]                         }
[16:06:14.521]                       }
[16:06:14.521]                     }
[16:06:14.521]                     invisible(muffled)
[16:06:14.521]                   }
[16:06:14.521]                   muffleCondition(cond)
[16:06:14.521]                 })
[16:06:14.521]             }))
[16:06:14.521]             future::FutureResult(value = ...future.value$value, 
[16:06:14.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.521]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.521]                     ...future.globalenv.names))
[16:06:14.521]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.521]         }, condition = base::local({
[16:06:14.521]             c <- base::c
[16:06:14.521]             inherits <- base::inherits
[16:06:14.521]             invokeRestart <- base::invokeRestart
[16:06:14.521]             length <- base::length
[16:06:14.521]             list <- base::list
[16:06:14.521]             seq.int <- base::seq.int
[16:06:14.521]             signalCondition <- base::signalCondition
[16:06:14.521]             sys.calls <- base::sys.calls
[16:06:14.521]             `[[` <- base::`[[`
[16:06:14.521]             `+` <- base::`+`
[16:06:14.521]             `<<-` <- base::`<<-`
[16:06:14.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.521]                   3L)]
[16:06:14.521]             }
[16:06:14.521]             function(cond) {
[16:06:14.521]                 is_error <- inherits(cond, "error")
[16:06:14.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.521]                   NULL)
[16:06:14.521]                 if (is_error) {
[16:06:14.521]                   sessionInformation <- function() {
[16:06:14.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.521]                       search = base::search(), system = base::Sys.info())
[16:06:14.521]                   }
[16:06:14.521]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.521]                     cond$call), session = sessionInformation(), 
[16:06:14.521]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.521]                   signalCondition(cond)
[16:06:14.521]                 }
[16:06:14.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.521]                 "immediateCondition"))) {
[16:06:14.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.521]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.521]                   if (TRUE && !signal) {
[16:06:14.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.521]                     {
[16:06:14.521]                       inherits <- base::inherits
[16:06:14.521]                       invokeRestart <- base::invokeRestart
[16:06:14.521]                       is.null <- base::is.null
[16:06:14.521]                       muffled <- FALSE
[16:06:14.521]                       if (inherits(cond, "message")) {
[16:06:14.521]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.521]                         if (muffled) 
[16:06:14.521]                           invokeRestart("muffleMessage")
[16:06:14.521]                       }
[16:06:14.521]                       else if (inherits(cond, "warning")) {
[16:06:14.521]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.521]                         if (muffled) 
[16:06:14.521]                           invokeRestart("muffleWarning")
[16:06:14.521]                       }
[16:06:14.521]                       else if (inherits(cond, "condition")) {
[16:06:14.521]                         if (!is.null(pattern)) {
[16:06:14.521]                           computeRestarts <- base::computeRestarts
[16:06:14.521]                           grepl <- base::grepl
[16:06:14.521]                           restarts <- computeRestarts(cond)
[16:06:14.521]                           for (restart in restarts) {
[16:06:14.521]                             name <- restart$name
[16:06:14.521]                             if (is.null(name)) 
[16:06:14.521]                               next
[16:06:14.521]                             if (!grepl(pattern, name)) 
[16:06:14.521]                               next
[16:06:14.521]                             invokeRestart(restart)
[16:06:14.521]                             muffled <- TRUE
[16:06:14.521]                             break
[16:06:14.521]                           }
[16:06:14.521]                         }
[16:06:14.521]                       }
[16:06:14.521]                       invisible(muffled)
[16:06:14.521]                     }
[16:06:14.521]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.521]                   }
[16:06:14.521]                 }
[16:06:14.521]                 else {
[16:06:14.521]                   if (TRUE) {
[16:06:14.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.521]                     {
[16:06:14.521]                       inherits <- base::inherits
[16:06:14.521]                       invokeRestart <- base::invokeRestart
[16:06:14.521]                       is.null <- base::is.null
[16:06:14.521]                       muffled <- FALSE
[16:06:14.521]                       if (inherits(cond, "message")) {
[16:06:14.521]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.521]                         if (muffled) 
[16:06:14.521]                           invokeRestart("muffleMessage")
[16:06:14.521]                       }
[16:06:14.521]                       else if (inherits(cond, "warning")) {
[16:06:14.521]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.521]                         if (muffled) 
[16:06:14.521]                           invokeRestart("muffleWarning")
[16:06:14.521]                       }
[16:06:14.521]                       else if (inherits(cond, "condition")) {
[16:06:14.521]                         if (!is.null(pattern)) {
[16:06:14.521]                           computeRestarts <- base::computeRestarts
[16:06:14.521]                           grepl <- base::grepl
[16:06:14.521]                           restarts <- computeRestarts(cond)
[16:06:14.521]                           for (restart in restarts) {
[16:06:14.521]                             name <- restart$name
[16:06:14.521]                             if (is.null(name)) 
[16:06:14.521]                               next
[16:06:14.521]                             if (!grepl(pattern, name)) 
[16:06:14.521]                               next
[16:06:14.521]                             invokeRestart(restart)
[16:06:14.521]                             muffled <- TRUE
[16:06:14.521]                             break
[16:06:14.521]                           }
[16:06:14.521]                         }
[16:06:14.521]                       }
[16:06:14.521]                       invisible(muffled)
[16:06:14.521]                     }
[16:06:14.521]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.521]                   }
[16:06:14.521]                 }
[16:06:14.521]             }
[16:06:14.521]         }))
[16:06:14.521]     }, error = function(ex) {
[16:06:14.521]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.521]                 ...future.rng), started = ...future.startTime, 
[16:06:14.521]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.521]             version = "1.8"), class = "FutureResult")
[16:06:14.521]     }, finally = {
[16:06:14.521]         if (!identical(...future.workdir, getwd())) 
[16:06:14.521]             setwd(...future.workdir)
[16:06:14.521]         {
[16:06:14.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.521]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.521]             }
[16:06:14.521]             base::options(...future.oldOptions)
[16:06:14.521]             if (.Platform$OS.type == "windows") {
[16:06:14.521]                 old_names <- names(...future.oldEnvVars)
[16:06:14.521]                 envs <- base::Sys.getenv()
[16:06:14.521]                 names <- names(envs)
[16:06:14.521]                 common <- intersect(names, old_names)
[16:06:14.521]                 added <- setdiff(names, old_names)
[16:06:14.521]                 removed <- setdiff(old_names, names)
[16:06:14.521]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.521]                   envs[common]]
[16:06:14.521]                 NAMES <- toupper(changed)
[16:06:14.521]                 args <- list()
[16:06:14.521]                 for (kk in seq_along(NAMES)) {
[16:06:14.521]                   name <- changed[[kk]]
[16:06:14.521]                   NAME <- NAMES[[kk]]
[16:06:14.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.521]                     next
[16:06:14.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.521]                 }
[16:06:14.521]                 NAMES <- toupper(added)
[16:06:14.521]                 for (kk in seq_along(NAMES)) {
[16:06:14.521]                   name <- added[[kk]]
[16:06:14.521]                   NAME <- NAMES[[kk]]
[16:06:14.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.521]                     next
[16:06:14.521]                   args[[name]] <- ""
[16:06:14.521]                 }
[16:06:14.521]                 NAMES <- toupper(removed)
[16:06:14.521]                 for (kk in seq_along(NAMES)) {
[16:06:14.521]                   name <- removed[[kk]]
[16:06:14.521]                   NAME <- NAMES[[kk]]
[16:06:14.521]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.521]                     next
[16:06:14.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.521]                 }
[16:06:14.521]                 if (length(args) > 0) 
[16:06:14.521]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.521]             }
[16:06:14.521]             else {
[16:06:14.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.521]             }
[16:06:14.521]             {
[16:06:14.521]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.521]                   0L) {
[16:06:14.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.521]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.521]                   base::options(opts)
[16:06:14.521]                 }
[16:06:14.521]                 {
[16:06:14.521]                   {
[16:06:14.521]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.521]                     NULL
[16:06:14.521]                   }
[16:06:14.521]                   options(future.plan = NULL)
[16:06:14.521]                   if (is.na(NA_character_)) 
[16:06:14.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.521]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.521]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.521]                     envir = parent.frame()) 
[16:06:14.521]                   {
[16:06:14.521]                     if (is.function(workers)) 
[16:06:14.521]                       workers <- workers()
[16:06:14.521]                     workers <- structure(as.integer(workers), 
[16:06:14.521]                       class = class(workers))
[16:06:14.521]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.521]                       workers >= 1)
[16:06:14.521]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.521]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.521]                     }
[16:06:14.521]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.521]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.521]                       envir = envir)
[16:06:14.521]                     if (!future$lazy) 
[16:06:14.521]                       future <- run(future)
[16:06:14.521]                     invisible(future)
[16:06:14.521]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.521]                 }
[16:06:14.521]             }
[16:06:14.521]         }
[16:06:14.521]     })
[16:06:14.521]     if (TRUE) {
[16:06:14.521]         base::sink(type = "output", split = FALSE)
[16:06:14.521]         if (TRUE) {
[16:06:14.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.521]         }
[16:06:14.521]         else {
[16:06:14.521]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.521]         }
[16:06:14.521]         base::close(...future.stdout)
[16:06:14.521]         ...future.stdout <- NULL
[16:06:14.521]     }
[16:06:14.521]     ...future.result$conditions <- ...future.conditions
[16:06:14.521]     ...future.result$finished <- base::Sys.time()
[16:06:14.521]     ...future.result
[16:06:14.521] }
[16:06:14.524] MultisessionFuture started
[16:06:14.525] - Launch lazy future ... done
[16:06:14.525] run() for ‘MultisessionFuture’ ... done
[16:06:14.525] resolve() on list ...
[16:06:14.525]  recursive: 0
[16:06:14.525]  length: 3
[16:06:14.525]  elements: ‘a’, ‘b’, ‘’
[16:06:14.525] run() for ‘Future’ ...
[16:06:14.525] - state: ‘created’
[16:06:14.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.540] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.540]   - Field: ‘node’
[16:06:14.540]   - Field: ‘label’
[16:06:14.540]   - Field: ‘local’
[16:06:14.540]   - Field: ‘owner’
[16:06:14.540]   - Field: ‘envir’
[16:06:14.540]   - Field: ‘workers’
[16:06:14.540]   - Field: ‘packages’
[16:06:14.540]   - Field: ‘gc’
[16:06:14.541]   - Field: ‘conditions’
[16:06:14.541]   - Field: ‘persistent’
[16:06:14.541]   - Field: ‘expr’
[16:06:14.541]   - Field: ‘uuid’
[16:06:14.541]   - Field: ‘seed’
[16:06:14.541]   - Field: ‘version’
[16:06:14.541]   - Field: ‘result’
[16:06:14.541]   - Field: ‘asynchronous’
[16:06:14.541]   - Field: ‘calls’
[16:06:14.541]   - Field: ‘globals’
[16:06:14.541]   - Field: ‘stdout’
[16:06:14.542]   - Field: ‘earlySignal’
[16:06:14.542]   - Field: ‘lazy’
[16:06:14.542]   - Field: ‘state’
[16:06:14.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.542] - Launch lazy future ...
[16:06:14.542] Packages needed by the future expression (n = 0): <none>
[16:06:14.542] Packages needed by future strategies (n = 0): <none>
[16:06:14.543] {
[16:06:14.543]     {
[16:06:14.543]         {
[16:06:14.543]             ...future.startTime <- base::Sys.time()
[16:06:14.543]             {
[16:06:14.543]                 {
[16:06:14.543]                   {
[16:06:14.543]                     {
[16:06:14.543]                       base::local({
[16:06:14.543]                         has_future <- base::requireNamespace("future", 
[16:06:14.543]                           quietly = TRUE)
[16:06:14.543]                         if (has_future) {
[16:06:14.543]                           ns <- base::getNamespace("future")
[16:06:14.543]                           version <- ns[[".package"]][["version"]]
[16:06:14.543]                           if (is.null(version)) 
[16:06:14.543]                             version <- utils::packageVersion("future")
[16:06:14.543]                         }
[16:06:14.543]                         else {
[16:06:14.543]                           version <- NULL
[16:06:14.543]                         }
[16:06:14.543]                         if (!has_future || version < "1.8.0") {
[16:06:14.543]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.543]                             "", base::R.version$version.string), 
[16:06:14.543]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.543]                               "release", "version")], collapse = " "), 
[16:06:14.543]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.543]                             info)
[16:06:14.543]                           info <- base::paste(info, collapse = "; ")
[16:06:14.543]                           if (!has_future) {
[16:06:14.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.543]                               info)
[16:06:14.543]                           }
[16:06:14.543]                           else {
[16:06:14.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.543]                               info, version)
[16:06:14.543]                           }
[16:06:14.543]                           base::stop(msg)
[16:06:14.543]                         }
[16:06:14.543]                       })
[16:06:14.543]                     }
[16:06:14.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.543]                     base::options(mc.cores = 1L)
[16:06:14.543]                   }
[16:06:14.543]                   options(future.plan = NULL)
[16:06:14.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.543]                 }
[16:06:14.543]                 ...future.workdir <- getwd()
[16:06:14.543]             }
[16:06:14.543]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.543]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.543]         }
[16:06:14.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.543]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.543]             base::names(...future.oldOptions))
[16:06:14.543]     }
[16:06:14.543]     if (FALSE) {
[16:06:14.543]     }
[16:06:14.543]     else {
[16:06:14.543]         if (TRUE) {
[16:06:14.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.543]                 open = "w")
[16:06:14.543]         }
[16:06:14.543]         else {
[16:06:14.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.543]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.543]         }
[16:06:14.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.543]             base::sink(type = "output", split = FALSE)
[16:06:14.543]             base::close(...future.stdout)
[16:06:14.543]         }, add = TRUE)
[16:06:14.543]     }
[16:06:14.543]     ...future.frame <- base::sys.nframe()
[16:06:14.543]     ...future.conditions <- base::list()
[16:06:14.543]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.543]     if (FALSE) {
[16:06:14.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.543]     }
[16:06:14.543]     ...future.result <- base::tryCatch({
[16:06:14.543]         base::withCallingHandlers({
[16:06:14.543]             ...future.value <- base::withVisible(base::local({
[16:06:14.543]                 ...future.makeSendCondition <- base::local({
[16:06:14.543]                   sendCondition <- NULL
[16:06:14.543]                   function(frame = 1L) {
[16:06:14.543]                     if (is.function(sendCondition)) 
[16:06:14.543]                       return(sendCondition)
[16:06:14.543]                     ns <- getNamespace("parallel")
[16:06:14.543]                     if (exists("sendData", mode = "function", 
[16:06:14.543]                       envir = ns)) {
[16:06:14.543]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.543]                         envir = ns)
[16:06:14.543]                       envir <- sys.frame(frame)
[16:06:14.543]                       master <- NULL
[16:06:14.543]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.543]                         !identical(envir, emptyenv())) {
[16:06:14.543]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.543]                           inherits = FALSE)) {
[16:06:14.543]                           master <- get("master", mode = "list", 
[16:06:14.543]                             envir = envir, inherits = FALSE)
[16:06:14.543]                           if (inherits(master, c("SOCKnode", 
[16:06:14.543]                             "SOCK0node"))) {
[16:06:14.543]                             sendCondition <<- function(cond) {
[16:06:14.543]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.543]                                 success = TRUE)
[16:06:14.543]                               parallel_sendData(master, data)
[16:06:14.543]                             }
[16:06:14.543]                             return(sendCondition)
[16:06:14.543]                           }
[16:06:14.543]                         }
[16:06:14.543]                         frame <- frame + 1L
[16:06:14.543]                         envir <- sys.frame(frame)
[16:06:14.543]                       }
[16:06:14.543]                     }
[16:06:14.543]                     sendCondition <<- function(cond) NULL
[16:06:14.543]                   }
[16:06:14.543]                 })
[16:06:14.543]                 withCallingHandlers({
[16:06:14.543]                   1
[16:06:14.543]                 }, immediateCondition = function(cond) {
[16:06:14.543]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.543]                   sendCondition(cond)
[16:06:14.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.543]                   {
[16:06:14.543]                     inherits <- base::inherits
[16:06:14.543]                     invokeRestart <- base::invokeRestart
[16:06:14.543]                     is.null <- base::is.null
[16:06:14.543]                     muffled <- FALSE
[16:06:14.543]                     if (inherits(cond, "message")) {
[16:06:14.543]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.543]                       if (muffled) 
[16:06:14.543]                         invokeRestart("muffleMessage")
[16:06:14.543]                     }
[16:06:14.543]                     else if (inherits(cond, "warning")) {
[16:06:14.543]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.543]                       if (muffled) 
[16:06:14.543]                         invokeRestart("muffleWarning")
[16:06:14.543]                     }
[16:06:14.543]                     else if (inherits(cond, "condition")) {
[16:06:14.543]                       if (!is.null(pattern)) {
[16:06:14.543]                         computeRestarts <- base::computeRestarts
[16:06:14.543]                         grepl <- base::grepl
[16:06:14.543]                         restarts <- computeRestarts(cond)
[16:06:14.543]                         for (restart in restarts) {
[16:06:14.543]                           name <- restart$name
[16:06:14.543]                           if (is.null(name)) 
[16:06:14.543]                             next
[16:06:14.543]                           if (!grepl(pattern, name)) 
[16:06:14.543]                             next
[16:06:14.543]                           invokeRestart(restart)
[16:06:14.543]                           muffled <- TRUE
[16:06:14.543]                           break
[16:06:14.543]                         }
[16:06:14.543]                       }
[16:06:14.543]                     }
[16:06:14.543]                     invisible(muffled)
[16:06:14.543]                   }
[16:06:14.543]                   muffleCondition(cond)
[16:06:14.543]                 })
[16:06:14.543]             }))
[16:06:14.543]             future::FutureResult(value = ...future.value$value, 
[16:06:14.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.543]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.543]                     ...future.globalenv.names))
[16:06:14.543]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.543]         }, condition = base::local({
[16:06:14.543]             c <- base::c
[16:06:14.543]             inherits <- base::inherits
[16:06:14.543]             invokeRestart <- base::invokeRestart
[16:06:14.543]             length <- base::length
[16:06:14.543]             list <- base::list
[16:06:14.543]             seq.int <- base::seq.int
[16:06:14.543]             signalCondition <- base::signalCondition
[16:06:14.543]             sys.calls <- base::sys.calls
[16:06:14.543]             `[[` <- base::`[[`
[16:06:14.543]             `+` <- base::`+`
[16:06:14.543]             `<<-` <- base::`<<-`
[16:06:14.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.543]                   3L)]
[16:06:14.543]             }
[16:06:14.543]             function(cond) {
[16:06:14.543]                 is_error <- inherits(cond, "error")
[16:06:14.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.543]                   NULL)
[16:06:14.543]                 if (is_error) {
[16:06:14.543]                   sessionInformation <- function() {
[16:06:14.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.543]                       search = base::search(), system = base::Sys.info())
[16:06:14.543]                   }
[16:06:14.543]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.543]                     cond$call), session = sessionInformation(), 
[16:06:14.543]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.543]                   signalCondition(cond)
[16:06:14.543]                 }
[16:06:14.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.543]                 "immediateCondition"))) {
[16:06:14.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.543]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.543]                   if (TRUE && !signal) {
[16:06:14.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.543]                     {
[16:06:14.543]                       inherits <- base::inherits
[16:06:14.543]                       invokeRestart <- base::invokeRestart
[16:06:14.543]                       is.null <- base::is.null
[16:06:14.543]                       muffled <- FALSE
[16:06:14.543]                       if (inherits(cond, "message")) {
[16:06:14.543]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.543]                         if (muffled) 
[16:06:14.543]                           invokeRestart("muffleMessage")
[16:06:14.543]                       }
[16:06:14.543]                       else if (inherits(cond, "warning")) {
[16:06:14.543]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.543]                         if (muffled) 
[16:06:14.543]                           invokeRestart("muffleWarning")
[16:06:14.543]                       }
[16:06:14.543]                       else if (inherits(cond, "condition")) {
[16:06:14.543]                         if (!is.null(pattern)) {
[16:06:14.543]                           computeRestarts <- base::computeRestarts
[16:06:14.543]                           grepl <- base::grepl
[16:06:14.543]                           restarts <- computeRestarts(cond)
[16:06:14.543]                           for (restart in restarts) {
[16:06:14.543]                             name <- restart$name
[16:06:14.543]                             if (is.null(name)) 
[16:06:14.543]                               next
[16:06:14.543]                             if (!grepl(pattern, name)) 
[16:06:14.543]                               next
[16:06:14.543]                             invokeRestart(restart)
[16:06:14.543]                             muffled <- TRUE
[16:06:14.543]                             break
[16:06:14.543]                           }
[16:06:14.543]                         }
[16:06:14.543]                       }
[16:06:14.543]                       invisible(muffled)
[16:06:14.543]                     }
[16:06:14.543]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.543]                   }
[16:06:14.543]                 }
[16:06:14.543]                 else {
[16:06:14.543]                   if (TRUE) {
[16:06:14.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.543]                     {
[16:06:14.543]                       inherits <- base::inherits
[16:06:14.543]                       invokeRestart <- base::invokeRestart
[16:06:14.543]                       is.null <- base::is.null
[16:06:14.543]                       muffled <- FALSE
[16:06:14.543]                       if (inherits(cond, "message")) {
[16:06:14.543]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.543]                         if (muffled) 
[16:06:14.543]                           invokeRestart("muffleMessage")
[16:06:14.543]                       }
[16:06:14.543]                       else if (inherits(cond, "warning")) {
[16:06:14.543]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.543]                         if (muffled) 
[16:06:14.543]                           invokeRestart("muffleWarning")
[16:06:14.543]                       }
[16:06:14.543]                       else if (inherits(cond, "condition")) {
[16:06:14.543]                         if (!is.null(pattern)) {
[16:06:14.543]                           computeRestarts <- base::computeRestarts
[16:06:14.543]                           grepl <- base::grepl
[16:06:14.543]                           restarts <- computeRestarts(cond)
[16:06:14.543]                           for (restart in restarts) {
[16:06:14.543]                             name <- restart$name
[16:06:14.543]                             if (is.null(name)) 
[16:06:14.543]                               next
[16:06:14.543]                             if (!grepl(pattern, name)) 
[16:06:14.543]                               next
[16:06:14.543]                             invokeRestart(restart)
[16:06:14.543]                             muffled <- TRUE
[16:06:14.543]                             break
[16:06:14.543]                           }
[16:06:14.543]                         }
[16:06:14.543]                       }
[16:06:14.543]                       invisible(muffled)
[16:06:14.543]                     }
[16:06:14.543]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.543]                   }
[16:06:14.543]                 }
[16:06:14.543]             }
[16:06:14.543]         }))
[16:06:14.543]     }, error = function(ex) {
[16:06:14.543]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.543]                 ...future.rng), started = ...future.startTime, 
[16:06:14.543]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.543]             version = "1.8"), class = "FutureResult")
[16:06:14.543]     }, finally = {
[16:06:14.543]         if (!identical(...future.workdir, getwd())) 
[16:06:14.543]             setwd(...future.workdir)
[16:06:14.543]         {
[16:06:14.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.543]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.543]             }
[16:06:14.543]             base::options(...future.oldOptions)
[16:06:14.543]             if (.Platform$OS.type == "windows") {
[16:06:14.543]                 old_names <- names(...future.oldEnvVars)
[16:06:14.543]                 envs <- base::Sys.getenv()
[16:06:14.543]                 names <- names(envs)
[16:06:14.543]                 common <- intersect(names, old_names)
[16:06:14.543]                 added <- setdiff(names, old_names)
[16:06:14.543]                 removed <- setdiff(old_names, names)
[16:06:14.543]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.543]                   envs[common]]
[16:06:14.543]                 NAMES <- toupper(changed)
[16:06:14.543]                 args <- list()
[16:06:14.543]                 for (kk in seq_along(NAMES)) {
[16:06:14.543]                   name <- changed[[kk]]
[16:06:14.543]                   NAME <- NAMES[[kk]]
[16:06:14.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.543]                     next
[16:06:14.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.543]                 }
[16:06:14.543]                 NAMES <- toupper(added)
[16:06:14.543]                 for (kk in seq_along(NAMES)) {
[16:06:14.543]                   name <- added[[kk]]
[16:06:14.543]                   NAME <- NAMES[[kk]]
[16:06:14.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.543]                     next
[16:06:14.543]                   args[[name]] <- ""
[16:06:14.543]                 }
[16:06:14.543]                 NAMES <- toupper(removed)
[16:06:14.543]                 for (kk in seq_along(NAMES)) {
[16:06:14.543]                   name <- removed[[kk]]
[16:06:14.543]                   NAME <- NAMES[[kk]]
[16:06:14.543]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.543]                     next
[16:06:14.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.543]                 }
[16:06:14.543]                 if (length(args) > 0) 
[16:06:14.543]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.543]             }
[16:06:14.543]             else {
[16:06:14.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.543]             }
[16:06:14.543]             {
[16:06:14.543]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.543]                   0L) {
[16:06:14.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.543]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.543]                   base::options(opts)
[16:06:14.543]                 }
[16:06:14.543]                 {
[16:06:14.543]                   {
[16:06:14.543]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.543]                     NULL
[16:06:14.543]                   }
[16:06:14.543]                   options(future.plan = NULL)
[16:06:14.543]                   if (is.na(NA_character_)) 
[16:06:14.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.543]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.543]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.543]                     envir = parent.frame()) 
[16:06:14.543]                   {
[16:06:14.543]                     if (is.function(workers)) 
[16:06:14.543]                       workers <- workers()
[16:06:14.543]                     workers <- structure(as.integer(workers), 
[16:06:14.543]                       class = class(workers))
[16:06:14.543]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.543]                       workers >= 1)
[16:06:14.543]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.543]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.543]                     }
[16:06:14.543]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.543]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.543]                       envir = envir)
[16:06:14.543]                     if (!future$lazy) 
[16:06:14.543]                       future <- run(future)
[16:06:14.543]                     invisible(future)
[16:06:14.543]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.543]                 }
[16:06:14.543]             }
[16:06:14.543]         }
[16:06:14.543]     })
[16:06:14.543]     if (TRUE) {
[16:06:14.543]         base::sink(type = "output", split = FALSE)
[16:06:14.543]         if (TRUE) {
[16:06:14.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.543]         }
[16:06:14.543]         else {
[16:06:14.543]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.543]         }
[16:06:14.543]         base::close(...future.stdout)
[16:06:14.543]         ...future.stdout <- NULL
[16:06:14.543]     }
[16:06:14.543]     ...future.result$conditions <- ...future.conditions
[16:06:14.543]     ...future.result$finished <- base::Sys.time()
[16:06:14.543]     ...future.result
[16:06:14.543] }
[16:06:14.546] MultisessionFuture started
[16:06:14.546] - Launch lazy future ... done
[16:06:14.546] run() for ‘MultisessionFuture’ ... done
[16:06:14.567]  length: 2 (resolved future 3)
[16:06:14.588] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.589] - Validating connection of MultisessionFuture
[16:06:14.589] - received message: FutureResult
[16:06:14.589] - Received FutureResult
[16:06:14.589] - Erased future from FutureRegistry
[16:06:14.590] result() for ClusterFuture ...
[16:06:14.590] - result already collected: FutureResult
[16:06:14.590] result() for ClusterFuture ... done
[16:06:14.590] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.590] Future #2
[16:06:14.590]  length: 1 (resolved future 2)
[16:06:14.604] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.604] - Validating connection of MultisessionFuture
[16:06:14.604] - received message: FutureResult
[16:06:14.604] - Received FutureResult
[16:06:14.604] - Erased future from FutureRegistry
[16:06:14.605] result() for ClusterFuture ...
[16:06:14.605] - result already collected: FutureResult
[16:06:14.605] result() for ClusterFuture ... done
[16:06:14.605] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.605] Future #1
[16:06:14.605]  length: 0 (resolved future 1)
[16:06:14.605] resolve() on list ... DONE
[16:06:14.605] getGlobalsAndPackages() ...
[16:06:14.606] Searching for globals...
[16:06:14.606] 
[16:06:14.606] Searching for globals ... DONE
[16:06:14.606] - globals: [0] <none>
[16:06:14.606] getGlobalsAndPackages() ... DONE
[16:06:14.606] getGlobalsAndPackages() ...
[16:06:14.607] Searching for globals...
[16:06:14.607] 
[16:06:14.607] Searching for globals ... DONE
[16:06:14.607] - globals: [0] <none>
[16:06:14.607] getGlobalsAndPackages() ... DONE
[16:06:14.607] resolve() on list ...
[16:06:14.607]  recursive: 0
[16:06:14.608]  length: 3
[16:06:14.608]  elements: ‘a’, ‘b’, ‘’
[16:06:14.608] run() for ‘Future’ ...
[16:06:14.608] - state: ‘created’
[16:06:14.608] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.622] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.622]   - Field: ‘node’
[16:06:14.622]   - Field: ‘label’
[16:06:14.622]   - Field: ‘local’
[16:06:14.622]   - Field: ‘owner’
[16:06:14.622]   - Field: ‘envir’
[16:06:14.622]   - Field: ‘workers’
[16:06:14.622]   - Field: ‘packages’
[16:06:14.622]   - Field: ‘gc’
[16:06:14.623]   - Field: ‘conditions’
[16:06:14.623]   - Field: ‘persistent’
[16:06:14.623]   - Field: ‘expr’
[16:06:14.623]   - Field: ‘uuid’
[16:06:14.623]   - Field: ‘seed’
[16:06:14.623]   - Field: ‘version’
[16:06:14.623]   - Field: ‘result’
[16:06:14.623]   - Field: ‘asynchronous’
[16:06:14.623]   - Field: ‘calls’
[16:06:14.623]   - Field: ‘globals’
[16:06:14.623]   - Field: ‘stdout’
[16:06:14.624]   - Field: ‘earlySignal’
[16:06:14.624]   - Field: ‘lazy’
[16:06:14.624]   - Field: ‘state’
[16:06:14.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.624] - Launch lazy future ...
[16:06:14.624] Packages needed by the future expression (n = 0): <none>
[16:06:14.624] Packages needed by future strategies (n = 0): <none>
[16:06:14.625] {
[16:06:14.625]     {
[16:06:14.625]         {
[16:06:14.625]             ...future.startTime <- base::Sys.time()
[16:06:14.625]             {
[16:06:14.625]                 {
[16:06:14.625]                   {
[16:06:14.625]                     {
[16:06:14.625]                       base::local({
[16:06:14.625]                         has_future <- base::requireNamespace("future", 
[16:06:14.625]                           quietly = TRUE)
[16:06:14.625]                         if (has_future) {
[16:06:14.625]                           ns <- base::getNamespace("future")
[16:06:14.625]                           version <- ns[[".package"]][["version"]]
[16:06:14.625]                           if (is.null(version)) 
[16:06:14.625]                             version <- utils::packageVersion("future")
[16:06:14.625]                         }
[16:06:14.625]                         else {
[16:06:14.625]                           version <- NULL
[16:06:14.625]                         }
[16:06:14.625]                         if (!has_future || version < "1.8.0") {
[16:06:14.625]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.625]                             "", base::R.version$version.string), 
[16:06:14.625]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.625]                               "release", "version")], collapse = " "), 
[16:06:14.625]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.625]                             info)
[16:06:14.625]                           info <- base::paste(info, collapse = "; ")
[16:06:14.625]                           if (!has_future) {
[16:06:14.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.625]                               info)
[16:06:14.625]                           }
[16:06:14.625]                           else {
[16:06:14.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.625]                               info, version)
[16:06:14.625]                           }
[16:06:14.625]                           base::stop(msg)
[16:06:14.625]                         }
[16:06:14.625]                       })
[16:06:14.625]                     }
[16:06:14.625]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.625]                     base::options(mc.cores = 1L)
[16:06:14.625]                   }
[16:06:14.625]                   options(future.plan = NULL)
[16:06:14.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.625]                 }
[16:06:14.625]                 ...future.workdir <- getwd()
[16:06:14.625]             }
[16:06:14.625]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.625]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.625]         }
[16:06:14.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.625]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.625]             base::names(...future.oldOptions))
[16:06:14.625]     }
[16:06:14.625]     if (FALSE) {
[16:06:14.625]     }
[16:06:14.625]     else {
[16:06:14.625]         if (TRUE) {
[16:06:14.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.625]                 open = "w")
[16:06:14.625]         }
[16:06:14.625]         else {
[16:06:14.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.625]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.625]         }
[16:06:14.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.625]             base::sink(type = "output", split = FALSE)
[16:06:14.625]             base::close(...future.stdout)
[16:06:14.625]         }, add = TRUE)
[16:06:14.625]     }
[16:06:14.625]     ...future.frame <- base::sys.nframe()
[16:06:14.625]     ...future.conditions <- base::list()
[16:06:14.625]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.625]     if (FALSE) {
[16:06:14.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.625]     }
[16:06:14.625]     ...future.result <- base::tryCatch({
[16:06:14.625]         base::withCallingHandlers({
[16:06:14.625]             ...future.value <- base::withVisible(base::local({
[16:06:14.625]                 ...future.makeSendCondition <- base::local({
[16:06:14.625]                   sendCondition <- NULL
[16:06:14.625]                   function(frame = 1L) {
[16:06:14.625]                     if (is.function(sendCondition)) 
[16:06:14.625]                       return(sendCondition)
[16:06:14.625]                     ns <- getNamespace("parallel")
[16:06:14.625]                     if (exists("sendData", mode = "function", 
[16:06:14.625]                       envir = ns)) {
[16:06:14.625]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.625]                         envir = ns)
[16:06:14.625]                       envir <- sys.frame(frame)
[16:06:14.625]                       master <- NULL
[16:06:14.625]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.625]                         !identical(envir, emptyenv())) {
[16:06:14.625]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.625]                           inherits = FALSE)) {
[16:06:14.625]                           master <- get("master", mode = "list", 
[16:06:14.625]                             envir = envir, inherits = FALSE)
[16:06:14.625]                           if (inherits(master, c("SOCKnode", 
[16:06:14.625]                             "SOCK0node"))) {
[16:06:14.625]                             sendCondition <<- function(cond) {
[16:06:14.625]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.625]                                 success = TRUE)
[16:06:14.625]                               parallel_sendData(master, data)
[16:06:14.625]                             }
[16:06:14.625]                             return(sendCondition)
[16:06:14.625]                           }
[16:06:14.625]                         }
[16:06:14.625]                         frame <- frame + 1L
[16:06:14.625]                         envir <- sys.frame(frame)
[16:06:14.625]                       }
[16:06:14.625]                     }
[16:06:14.625]                     sendCondition <<- function(cond) NULL
[16:06:14.625]                   }
[16:06:14.625]                 })
[16:06:14.625]                 withCallingHandlers({
[16:06:14.625]                   1
[16:06:14.625]                 }, immediateCondition = function(cond) {
[16:06:14.625]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.625]                   sendCondition(cond)
[16:06:14.625]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.625]                   {
[16:06:14.625]                     inherits <- base::inherits
[16:06:14.625]                     invokeRestart <- base::invokeRestart
[16:06:14.625]                     is.null <- base::is.null
[16:06:14.625]                     muffled <- FALSE
[16:06:14.625]                     if (inherits(cond, "message")) {
[16:06:14.625]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.625]                       if (muffled) 
[16:06:14.625]                         invokeRestart("muffleMessage")
[16:06:14.625]                     }
[16:06:14.625]                     else if (inherits(cond, "warning")) {
[16:06:14.625]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.625]                       if (muffled) 
[16:06:14.625]                         invokeRestart("muffleWarning")
[16:06:14.625]                     }
[16:06:14.625]                     else if (inherits(cond, "condition")) {
[16:06:14.625]                       if (!is.null(pattern)) {
[16:06:14.625]                         computeRestarts <- base::computeRestarts
[16:06:14.625]                         grepl <- base::grepl
[16:06:14.625]                         restarts <- computeRestarts(cond)
[16:06:14.625]                         for (restart in restarts) {
[16:06:14.625]                           name <- restart$name
[16:06:14.625]                           if (is.null(name)) 
[16:06:14.625]                             next
[16:06:14.625]                           if (!grepl(pattern, name)) 
[16:06:14.625]                             next
[16:06:14.625]                           invokeRestart(restart)
[16:06:14.625]                           muffled <- TRUE
[16:06:14.625]                           break
[16:06:14.625]                         }
[16:06:14.625]                       }
[16:06:14.625]                     }
[16:06:14.625]                     invisible(muffled)
[16:06:14.625]                   }
[16:06:14.625]                   muffleCondition(cond)
[16:06:14.625]                 })
[16:06:14.625]             }))
[16:06:14.625]             future::FutureResult(value = ...future.value$value, 
[16:06:14.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.625]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.625]                     ...future.globalenv.names))
[16:06:14.625]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.625]         }, condition = base::local({
[16:06:14.625]             c <- base::c
[16:06:14.625]             inherits <- base::inherits
[16:06:14.625]             invokeRestart <- base::invokeRestart
[16:06:14.625]             length <- base::length
[16:06:14.625]             list <- base::list
[16:06:14.625]             seq.int <- base::seq.int
[16:06:14.625]             signalCondition <- base::signalCondition
[16:06:14.625]             sys.calls <- base::sys.calls
[16:06:14.625]             `[[` <- base::`[[`
[16:06:14.625]             `+` <- base::`+`
[16:06:14.625]             `<<-` <- base::`<<-`
[16:06:14.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.625]                   3L)]
[16:06:14.625]             }
[16:06:14.625]             function(cond) {
[16:06:14.625]                 is_error <- inherits(cond, "error")
[16:06:14.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.625]                   NULL)
[16:06:14.625]                 if (is_error) {
[16:06:14.625]                   sessionInformation <- function() {
[16:06:14.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.625]                       search = base::search(), system = base::Sys.info())
[16:06:14.625]                   }
[16:06:14.625]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.625]                     cond$call), session = sessionInformation(), 
[16:06:14.625]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.625]                   signalCondition(cond)
[16:06:14.625]                 }
[16:06:14.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.625]                 "immediateCondition"))) {
[16:06:14.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.625]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.625]                   if (TRUE && !signal) {
[16:06:14.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.625]                     {
[16:06:14.625]                       inherits <- base::inherits
[16:06:14.625]                       invokeRestart <- base::invokeRestart
[16:06:14.625]                       is.null <- base::is.null
[16:06:14.625]                       muffled <- FALSE
[16:06:14.625]                       if (inherits(cond, "message")) {
[16:06:14.625]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.625]                         if (muffled) 
[16:06:14.625]                           invokeRestart("muffleMessage")
[16:06:14.625]                       }
[16:06:14.625]                       else if (inherits(cond, "warning")) {
[16:06:14.625]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.625]                         if (muffled) 
[16:06:14.625]                           invokeRestart("muffleWarning")
[16:06:14.625]                       }
[16:06:14.625]                       else if (inherits(cond, "condition")) {
[16:06:14.625]                         if (!is.null(pattern)) {
[16:06:14.625]                           computeRestarts <- base::computeRestarts
[16:06:14.625]                           grepl <- base::grepl
[16:06:14.625]                           restarts <- computeRestarts(cond)
[16:06:14.625]                           for (restart in restarts) {
[16:06:14.625]                             name <- restart$name
[16:06:14.625]                             if (is.null(name)) 
[16:06:14.625]                               next
[16:06:14.625]                             if (!grepl(pattern, name)) 
[16:06:14.625]                               next
[16:06:14.625]                             invokeRestart(restart)
[16:06:14.625]                             muffled <- TRUE
[16:06:14.625]                             break
[16:06:14.625]                           }
[16:06:14.625]                         }
[16:06:14.625]                       }
[16:06:14.625]                       invisible(muffled)
[16:06:14.625]                     }
[16:06:14.625]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.625]                   }
[16:06:14.625]                 }
[16:06:14.625]                 else {
[16:06:14.625]                   if (TRUE) {
[16:06:14.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.625]                     {
[16:06:14.625]                       inherits <- base::inherits
[16:06:14.625]                       invokeRestart <- base::invokeRestart
[16:06:14.625]                       is.null <- base::is.null
[16:06:14.625]                       muffled <- FALSE
[16:06:14.625]                       if (inherits(cond, "message")) {
[16:06:14.625]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.625]                         if (muffled) 
[16:06:14.625]                           invokeRestart("muffleMessage")
[16:06:14.625]                       }
[16:06:14.625]                       else if (inherits(cond, "warning")) {
[16:06:14.625]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.625]                         if (muffled) 
[16:06:14.625]                           invokeRestart("muffleWarning")
[16:06:14.625]                       }
[16:06:14.625]                       else if (inherits(cond, "condition")) {
[16:06:14.625]                         if (!is.null(pattern)) {
[16:06:14.625]                           computeRestarts <- base::computeRestarts
[16:06:14.625]                           grepl <- base::grepl
[16:06:14.625]                           restarts <- computeRestarts(cond)
[16:06:14.625]                           for (restart in restarts) {
[16:06:14.625]                             name <- restart$name
[16:06:14.625]                             if (is.null(name)) 
[16:06:14.625]                               next
[16:06:14.625]                             if (!grepl(pattern, name)) 
[16:06:14.625]                               next
[16:06:14.625]                             invokeRestart(restart)
[16:06:14.625]                             muffled <- TRUE
[16:06:14.625]                             break
[16:06:14.625]                           }
[16:06:14.625]                         }
[16:06:14.625]                       }
[16:06:14.625]                       invisible(muffled)
[16:06:14.625]                     }
[16:06:14.625]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.625]                   }
[16:06:14.625]                 }
[16:06:14.625]             }
[16:06:14.625]         }))
[16:06:14.625]     }, error = function(ex) {
[16:06:14.625]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.625]                 ...future.rng), started = ...future.startTime, 
[16:06:14.625]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.625]             version = "1.8"), class = "FutureResult")
[16:06:14.625]     }, finally = {
[16:06:14.625]         if (!identical(...future.workdir, getwd())) 
[16:06:14.625]             setwd(...future.workdir)
[16:06:14.625]         {
[16:06:14.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.625]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.625]             }
[16:06:14.625]             base::options(...future.oldOptions)
[16:06:14.625]             if (.Platform$OS.type == "windows") {
[16:06:14.625]                 old_names <- names(...future.oldEnvVars)
[16:06:14.625]                 envs <- base::Sys.getenv()
[16:06:14.625]                 names <- names(envs)
[16:06:14.625]                 common <- intersect(names, old_names)
[16:06:14.625]                 added <- setdiff(names, old_names)
[16:06:14.625]                 removed <- setdiff(old_names, names)
[16:06:14.625]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.625]                   envs[common]]
[16:06:14.625]                 NAMES <- toupper(changed)
[16:06:14.625]                 args <- list()
[16:06:14.625]                 for (kk in seq_along(NAMES)) {
[16:06:14.625]                   name <- changed[[kk]]
[16:06:14.625]                   NAME <- NAMES[[kk]]
[16:06:14.625]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.625]                     next
[16:06:14.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.625]                 }
[16:06:14.625]                 NAMES <- toupper(added)
[16:06:14.625]                 for (kk in seq_along(NAMES)) {
[16:06:14.625]                   name <- added[[kk]]
[16:06:14.625]                   NAME <- NAMES[[kk]]
[16:06:14.625]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.625]                     next
[16:06:14.625]                   args[[name]] <- ""
[16:06:14.625]                 }
[16:06:14.625]                 NAMES <- toupper(removed)
[16:06:14.625]                 for (kk in seq_along(NAMES)) {
[16:06:14.625]                   name <- removed[[kk]]
[16:06:14.625]                   NAME <- NAMES[[kk]]
[16:06:14.625]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.625]                     next
[16:06:14.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.625]                 }
[16:06:14.625]                 if (length(args) > 0) 
[16:06:14.625]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.625]             }
[16:06:14.625]             else {
[16:06:14.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.625]             }
[16:06:14.625]             {
[16:06:14.625]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.625]                   0L) {
[16:06:14.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.625]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.625]                   base::options(opts)
[16:06:14.625]                 }
[16:06:14.625]                 {
[16:06:14.625]                   {
[16:06:14.625]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.625]                     NULL
[16:06:14.625]                   }
[16:06:14.625]                   options(future.plan = NULL)
[16:06:14.625]                   if (is.na(NA_character_)) 
[16:06:14.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.625]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.625]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.625]                     envir = parent.frame()) 
[16:06:14.625]                   {
[16:06:14.625]                     if (is.function(workers)) 
[16:06:14.625]                       workers <- workers()
[16:06:14.625]                     workers <- structure(as.integer(workers), 
[16:06:14.625]                       class = class(workers))
[16:06:14.625]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.625]                       workers >= 1)
[16:06:14.625]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.625]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.625]                     }
[16:06:14.625]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.625]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.625]                       envir = envir)
[16:06:14.625]                     if (!future$lazy) 
[16:06:14.625]                       future <- run(future)
[16:06:14.625]                     invisible(future)
[16:06:14.625]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.625]                 }
[16:06:14.625]             }
[16:06:14.625]         }
[16:06:14.625]     })
[16:06:14.625]     if (TRUE) {
[16:06:14.625]         base::sink(type = "output", split = FALSE)
[16:06:14.625]         if (TRUE) {
[16:06:14.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.625]         }
[16:06:14.625]         else {
[16:06:14.625]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.625]         }
[16:06:14.625]         base::close(...future.stdout)
[16:06:14.625]         ...future.stdout <- NULL
[16:06:14.625]     }
[16:06:14.625]     ...future.result$conditions <- ...future.conditions
[16:06:14.625]     ...future.result$finished <- base::Sys.time()
[16:06:14.625]     ...future.result
[16:06:14.625] }
[16:06:14.628] MultisessionFuture started
[16:06:14.628] - Launch lazy future ... done
[16:06:14.628] run() for ‘MultisessionFuture’ ... done
[16:06:14.639] run() for ‘Future’ ...
[16:06:14.639] - state: ‘created’
[16:06:14.639] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.652] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.652]   - Field: ‘node’
[16:06:14.652]   - Field: ‘label’
[16:06:14.653]   - Field: ‘local’
[16:06:14.653]   - Field: ‘owner’
[16:06:14.653]   - Field: ‘envir’
[16:06:14.653]   - Field: ‘workers’
[16:06:14.653]   - Field: ‘packages’
[16:06:14.653]   - Field: ‘gc’
[16:06:14.653]   - Field: ‘conditions’
[16:06:14.653]   - Field: ‘persistent’
[16:06:14.653]   - Field: ‘expr’
[16:06:14.653]   - Field: ‘uuid’
[16:06:14.653]   - Field: ‘seed’
[16:06:14.654]   - Field: ‘version’
[16:06:14.654]   - Field: ‘result’
[16:06:14.654]   - Field: ‘asynchronous’
[16:06:14.654]   - Field: ‘calls’
[16:06:14.654]   - Field: ‘globals’
[16:06:14.654]   - Field: ‘stdout’
[16:06:14.654]   - Field: ‘earlySignal’
[16:06:14.654]   - Field: ‘lazy’
[16:06:14.654]   - Field: ‘state’
[16:06:14.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.654] - Launch lazy future ...
[16:06:14.655] Packages needed by the future expression (n = 0): <none>
[16:06:14.655] Packages needed by future strategies (n = 0): <none>
[16:06:14.655] {
[16:06:14.655]     {
[16:06:14.655]         {
[16:06:14.655]             ...future.startTime <- base::Sys.time()
[16:06:14.655]             {
[16:06:14.655]                 {
[16:06:14.655]                   {
[16:06:14.655]                     {
[16:06:14.655]                       base::local({
[16:06:14.655]                         has_future <- base::requireNamespace("future", 
[16:06:14.655]                           quietly = TRUE)
[16:06:14.655]                         if (has_future) {
[16:06:14.655]                           ns <- base::getNamespace("future")
[16:06:14.655]                           version <- ns[[".package"]][["version"]]
[16:06:14.655]                           if (is.null(version)) 
[16:06:14.655]                             version <- utils::packageVersion("future")
[16:06:14.655]                         }
[16:06:14.655]                         else {
[16:06:14.655]                           version <- NULL
[16:06:14.655]                         }
[16:06:14.655]                         if (!has_future || version < "1.8.0") {
[16:06:14.655]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.655]                             "", base::R.version$version.string), 
[16:06:14.655]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.655]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.655]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.655]                               "release", "version")], collapse = " "), 
[16:06:14.655]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.655]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.655]                             info)
[16:06:14.655]                           info <- base::paste(info, collapse = "; ")
[16:06:14.655]                           if (!has_future) {
[16:06:14.655]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.655]                               info)
[16:06:14.655]                           }
[16:06:14.655]                           else {
[16:06:14.655]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.655]                               info, version)
[16:06:14.655]                           }
[16:06:14.655]                           base::stop(msg)
[16:06:14.655]                         }
[16:06:14.655]                       })
[16:06:14.655]                     }
[16:06:14.655]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.655]                     base::options(mc.cores = 1L)
[16:06:14.655]                   }
[16:06:14.655]                   options(future.plan = NULL)
[16:06:14.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.655]                 }
[16:06:14.655]                 ...future.workdir <- getwd()
[16:06:14.655]             }
[16:06:14.655]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.655]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.655]         }
[16:06:14.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.655]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.655]             base::names(...future.oldOptions))
[16:06:14.655]     }
[16:06:14.655]     if (FALSE) {
[16:06:14.655]     }
[16:06:14.655]     else {
[16:06:14.655]         if (TRUE) {
[16:06:14.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.655]                 open = "w")
[16:06:14.655]         }
[16:06:14.655]         else {
[16:06:14.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.655]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.655]         }
[16:06:14.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.655]             base::sink(type = "output", split = FALSE)
[16:06:14.655]             base::close(...future.stdout)
[16:06:14.655]         }, add = TRUE)
[16:06:14.655]     }
[16:06:14.655]     ...future.frame <- base::sys.nframe()
[16:06:14.655]     ...future.conditions <- base::list()
[16:06:14.655]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.655]     if (FALSE) {
[16:06:14.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.655]     }
[16:06:14.655]     ...future.result <- base::tryCatch({
[16:06:14.655]         base::withCallingHandlers({
[16:06:14.655]             ...future.value <- base::withVisible(base::local({
[16:06:14.655]                 ...future.makeSendCondition <- base::local({
[16:06:14.655]                   sendCondition <- NULL
[16:06:14.655]                   function(frame = 1L) {
[16:06:14.655]                     if (is.function(sendCondition)) 
[16:06:14.655]                       return(sendCondition)
[16:06:14.655]                     ns <- getNamespace("parallel")
[16:06:14.655]                     if (exists("sendData", mode = "function", 
[16:06:14.655]                       envir = ns)) {
[16:06:14.655]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.655]                         envir = ns)
[16:06:14.655]                       envir <- sys.frame(frame)
[16:06:14.655]                       master <- NULL
[16:06:14.655]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.655]                         !identical(envir, emptyenv())) {
[16:06:14.655]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.655]                           inherits = FALSE)) {
[16:06:14.655]                           master <- get("master", mode = "list", 
[16:06:14.655]                             envir = envir, inherits = FALSE)
[16:06:14.655]                           if (inherits(master, c("SOCKnode", 
[16:06:14.655]                             "SOCK0node"))) {
[16:06:14.655]                             sendCondition <<- function(cond) {
[16:06:14.655]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.655]                                 success = TRUE)
[16:06:14.655]                               parallel_sendData(master, data)
[16:06:14.655]                             }
[16:06:14.655]                             return(sendCondition)
[16:06:14.655]                           }
[16:06:14.655]                         }
[16:06:14.655]                         frame <- frame + 1L
[16:06:14.655]                         envir <- sys.frame(frame)
[16:06:14.655]                       }
[16:06:14.655]                     }
[16:06:14.655]                     sendCondition <<- function(cond) NULL
[16:06:14.655]                   }
[16:06:14.655]                 })
[16:06:14.655]                 withCallingHandlers({
[16:06:14.655]                   2
[16:06:14.655]                 }, immediateCondition = function(cond) {
[16:06:14.655]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.655]                   sendCondition(cond)
[16:06:14.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.655]                   {
[16:06:14.655]                     inherits <- base::inherits
[16:06:14.655]                     invokeRestart <- base::invokeRestart
[16:06:14.655]                     is.null <- base::is.null
[16:06:14.655]                     muffled <- FALSE
[16:06:14.655]                     if (inherits(cond, "message")) {
[16:06:14.655]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.655]                       if (muffled) 
[16:06:14.655]                         invokeRestart("muffleMessage")
[16:06:14.655]                     }
[16:06:14.655]                     else if (inherits(cond, "warning")) {
[16:06:14.655]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.655]                       if (muffled) 
[16:06:14.655]                         invokeRestart("muffleWarning")
[16:06:14.655]                     }
[16:06:14.655]                     else if (inherits(cond, "condition")) {
[16:06:14.655]                       if (!is.null(pattern)) {
[16:06:14.655]                         computeRestarts <- base::computeRestarts
[16:06:14.655]                         grepl <- base::grepl
[16:06:14.655]                         restarts <- computeRestarts(cond)
[16:06:14.655]                         for (restart in restarts) {
[16:06:14.655]                           name <- restart$name
[16:06:14.655]                           if (is.null(name)) 
[16:06:14.655]                             next
[16:06:14.655]                           if (!grepl(pattern, name)) 
[16:06:14.655]                             next
[16:06:14.655]                           invokeRestart(restart)
[16:06:14.655]                           muffled <- TRUE
[16:06:14.655]                           break
[16:06:14.655]                         }
[16:06:14.655]                       }
[16:06:14.655]                     }
[16:06:14.655]                     invisible(muffled)
[16:06:14.655]                   }
[16:06:14.655]                   muffleCondition(cond)
[16:06:14.655]                 })
[16:06:14.655]             }))
[16:06:14.655]             future::FutureResult(value = ...future.value$value, 
[16:06:14.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.655]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.655]                     ...future.globalenv.names))
[16:06:14.655]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.655]         }, condition = base::local({
[16:06:14.655]             c <- base::c
[16:06:14.655]             inherits <- base::inherits
[16:06:14.655]             invokeRestart <- base::invokeRestart
[16:06:14.655]             length <- base::length
[16:06:14.655]             list <- base::list
[16:06:14.655]             seq.int <- base::seq.int
[16:06:14.655]             signalCondition <- base::signalCondition
[16:06:14.655]             sys.calls <- base::sys.calls
[16:06:14.655]             `[[` <- base::`[[`
[16:06:14.655]             `+` <- base::`+`
[16:06:14.655]             `<<-` <- base::`<<-`
[16:06:14.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.655]                   3L)]
[16:06:14.655]             }
[16:06:14.655]             function(cond) {
[16:06:14.655]                 is_error <- inherits(cond, "error")
[16:06:14.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.655]                   NULL)
[16:06:14.655]                 if (is_error) {
[16:06:14.655]                   sessionInformation <- function() {
[16:06:14.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.655]                       search = base::search(), system = base::Sys.info())
[16:06:14.655]                   }
[16:06:14.655]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.655]                     cond$call), session = sessionInformation(), 
[16:06:14.655]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.655]                   signalCondition(cond)
[16:06:14.655]                 }
[16:06:14.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.655]                 "immediateCondition"))) {
[16:06:14.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.655]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.655]                   if (TRUE && !signal) {
[16:06:14.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.655]                     {
[16:06:14.655]                       inherits <- base::inherits
[16:06:14.655]                       invokeRestart <- base::invokeRestart
[16:06:14.655]                       is.null <- base::is.null
[16:06:14.655]                       muffled <- FALSE
[16:06:14.655]                       if (inherits(cond, "message")) {
[16:06:14.655]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.655]                         if (muffled) 
[16:06:14.655]                           invokeRestart("muffleMessage")
[16:06:14.655]                       }
[16:06:14.655]                       else if (inherits(cond, "warning")) {
[16:06:14.655]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.655]                         if (muffled) 
[16:06:14.655]                           invokeRestart("muffleWarning")
[16:06:14.655]                       }
[16:06:14.655]                       else if (inherits(cond, "condition")) {
[16:06:14.655]                         if (!is.null(pattern)) {
[16:06:14.655]                           computeRestarts <- base::computeRestarts
[16:06:14.655]                           grepl <- base::grepl
[16:06:14.655]                           restarts <- computeRestarts(cond)
[16:06:14.655]                           for (restart in restarts) {
[16:06:14.655]                             name <- restart$name
[16:06:14.655]                             if (is.null(name)) 
[16:06:14.655]                               next
[16:06:14.655]                             if (!grepl(pattern, name)) 
[16:06:14.655]                               next
[16:06:14.655]                             invokeRestart(restart)
[16:06:14.655]                             muffled <- TRUE
[16:06:14.655]                             break
[16:06:14.655]                           }
[16:06:14.655]                         }
[16:06:14.655]                       }
[16:06:14.655]                       invisible(muffled)
[16:06:14.655]                     }
[16:06:14.655]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.655]                   }
[16:06:14.655]                 }
[16:06:14.655]                 else {
[16:06:14.655]                   if (TRUE) {
[16:06:14.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.655]                     {
[16:06:14.655]                       inherits <- base::inherits
[16:06:14.655]                       invokeRestart <- base::invokeRestart
[16:06:14.655]                       is.null <- base::is.null
[16:06:14.655]                       muffled <- FALSE
[16:06:14.655]                       if (inherits(cond, "message")) {
[16:06:14.655]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.655]                         if (muffled) 
[16:06:14.655]                           invokeRestart("muffleMessage")
[16:06:14.655]                       }
[16:06:14.655]                       else if (inherits(cond, "warning")) {
[16:06:14.655]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.655]                         if (muffled) 
[16:06:14.655]                           invokeRestart("muffleWarning")
[16:06:14.655]                       }
[16:06:14.655]                       else if (inherits(cond, "condition")) {
[16:06:14.655]                         if (!is.null(pattern)) {
[16:06:14.655]                           computeRestarts <- base::computeRestarts
[16:06:14.655]                           grepl <- base::grepl
[16:06:14.655]                           restarts <- computeRestarts(cond)
[16:06:14.655]                           for (restart in restarts) {
[16:06:14.655]                             name <- restart$name
[16:06:14.655]                             if (is.null(name)) 
[16:06:14.655]                               next
[16:06:14.655]                             if (!grepl(pattern, name)) 
[16:06:14.655]                               next
[16:06:14.655]                             invokeRestart(restart)
[16:06:14.655]                             muffled <- TRUE
[16:06:14.655]                             break
[16:06:14.655]                           }
[16:06:14.655]                         }
[16:06:14.655]                       }
[16:06:14.655]                       invisible(muffled)
[16:06:14.655]                     }
[16:06:14.655]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.655]                   }
[16:06:14.655]                 }
[16:06:14.655]             }
[16:06:14.655]         }))
[16:06:14.655]     }, error = function(ex) {
[16:06:14.655]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.655]                 ...future.rng), started = ...future.startTime, 
[16:06:14.655]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.655]             version = "1.8"), class = "FutureResult")
[16:06:14.655]     }, finally = {
[16:06:14.655]         if (!identical(...future.workdir, getwd())) 
[16:06:14.655]             setwd(...future.workdir)
[16:06:14.655]         {
[16:06:14.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.655]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.655]             }
[16:06:14.655]             base::options(...future.oldOptions)
[16:06:14.655]             if (.Platform$OS.type == "windows") {
[16:06:14.655]                 old_names <- names(...future.oldEnvVars)
[16:06:14.655]                 envs <- base::Sys.getenv()
[16:06:14.655]                 names <- names(envs)
[16:06:14.655]                 common <- intersect(names, old_names)
[16:06:14.655]                 added <- setdiff(names, old_names)
[16:06:14.655]                 removed <- setdiff(old_names, names)
[16:06:14.655]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.655]                   envs[common]]
[16:06:14.655]                 NAMES <- toupper(changed)
[16:06:14.655]                 args <- list()
[16:06:14.655]                 for (kk in seq_along(NAMES)) {
[16:06:14.655]                   name <- changed[[kk]]
[16:06:14.655]                   NAME <- NAMES[[kk]]
[16:06:14.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.655]                     next
[16:06:14.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.655]                 }
[16:06:14.655]                 NAMES <- toupper(added)
[16:06:14.655]                 for (kk in seq_along(NAMES)) {
[16:06:14.655]                   name <- added[[kk]]
[16:06:14.655]                   NAME <- NAMES[[kk]]
[16:06:14.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.655]                     next
[16:06:14.655]                   args[[name]] <- ""
[16:06:14.655]                 }
[16:06:14.655]                 NAMES <- toupper(removed)
[16:06:14.655]                 for (kk in seq_along(NAMES)) {
[16:06:14.655]                   name <- removed[[kk]]
[16:06:14.655]                   NAME <- NAMES[[kk]]
[16:06:14.655]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.655]                     next
[16:06:14.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.655]                 }
[16:06:14.655]                 if (length(args) > 0) 
[16:06:14.655]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.655]             }
[16:06:14.655]             else {
[16:06:14.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.655]             }
[16:06:14.655]             {
[16:06:14.655]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.655]                   0L) {
[16:06:14.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.655]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.655]                   base::options(opts)
[16:06:14.655]                 }
[16:06:14.655]                 {
[16:06:14.655]                   {
[16:06:14.655]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.655]                     NULL
[16:06:14.655]                   }
[16:06:14.655]                   options(future.plan = NULL)
[16:06:14.655]                   if (is.na(NA_character_)) 
[16:06:14.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.655]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.655]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.655]                     envir = parent.frame()) 
[16:06:14.655]                   {
[16:06:14.655]                     if (is.function(workers)) 
[16:06:14.655]                       workers <- workers()
[16:06:14.655]                     workers <- structure(as.integer(workers), 
[16:06:14.655]                       class = class(workers))
[16:06:14.655]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.655]                       workers >= 1)
[16:06:14.655]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.655]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.655]                     }
[16:06:14.655]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.655]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.655]                       envir = envir)
[16:06:14.655]                     if (!future$lazy) 
[16:06:14.655]                       future <- run(future)
[16:06:14.655]                     invisible(future)
[16:06:14.655]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.655]                 }
[16:06:14.655]             }
[16:06:14.655]         }
[16:06:14.655]     })
[16:06:14.655]     if (TRUE) {
[16:06:14.655]         base::sink(type = "output", split = FALSE)
[16:06:14.655]         if (TRUE) {
[16:06:14.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.655]         }
[16:06:14.655]         else {
[16:06:14.655]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.655]         }
[16:06:14.655]         base::close(...future.stdout)
[16:06:14.655]         ...future.stdout <- NULL
[16:06:14.655]     }
[16:06:14.655]     ...future.result$conditions <- ...future.conditions
[16:06:14.655]     ...future.result$finished <- base::Sys.time()
[16:06:14.655]     ...future.result
[16:06:14.655] }
[16:06:14.658] MultisessionFuture started
[16:06:14.658] - Launch lazy future ... done
[16:06:14.658] run() for ‘MultisessionFuture’ ... done
[16:06:14.669]  length: 2 (resolved future 3)
[16:06:14.680] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.680] - Validating connection of MultisessionFuture
[16:06:14.680] - received message: FutureResult
[16:06:14.680] - Received FutureResult
[16:06:14.680] - Erased future from FutureRegistry
[16:06:14.680] result() for ClusterFuture ...
[16:06:14.680] - result already collected: FutureResult
[16:06:14.680] result() for ClusterFuture ... done
[16:06:14.681] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.681] Future #1
[16:06:14.681]  length: 1 (resolved future 1)
[16:06:14.703] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.704] - Validating connection of MultisessionFuture
[16:06:14.704] - received message: FutureResult
[16:06:14.704] - Received FutureResult
[16:06:14.704] - Erased future from FutureRegistry
[16:06:14.704] result() for ClusterFuture ...
[16:06:14.704] - result already collected: FutureResult
[16:06:14.704] result() for ClusterFuture ... done
[16:06:14.704] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.704] Future #2
[16:06:14.705]  length: 0 (resolved future 2)
[16:06:14.705] resolve() on list ... DONE
[16:06:14.705] getGlobalsAndPackages() ...
[16:06:14.705] Searching for globals...
[16:06:14.705] 
[16:06:14.705] Searching for globals ... DONE
[16:06:14.705] - globals: [0] <none>
[16:06:14.705] getGlobalsAndPackages() ... DONE
[16:06:14.706] run() for ‘Future’ ...
[16:06:14.706] - state: ‘created’
[16:06:14.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.720] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.721]   - Field: ‘node’
[16:06:14.721]   - Field: ‘label’
[16:06:14.721]   - Field: ‘local’
[16:06:14.721]   - Field: ‘owner’
[16:06:14.721]   - Field: ‘envir’
[16:06:14.721]   - Field: ‘workers’
[16:06:14.721]   - Field: ‘packages’
[16:06:14.721]   - Field: ‘gc’
[16:06:14.722]   - Field: ‘conditions’
[16:06:14.722]   - Field: ‘persistent’
[16:06:14.722]   - Field: ‘expr’
[16:06:14.722]   - Field: ‘uuid’
[16:06:14.722]   - Field: ‘seed’
[16:06:14.722]   - Field: ‘version’
[16:06:14.722]   - Field: ‘result’
[16:06:14.722]   - Field: ‘asynchronous’
[16:06:14.722]   - Field: ‘calls’
[16:06:14.722]   - Field: ‘globals’
[16:06:14.722]   - Field: ‘stdout’
[16:06:14.723]   - Field: ‘earlySignal’
[16:06:14.723]   - Field: ‘lazy’
[16:06:14.723]   - Field: ‘state’
[16:06:14.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.723] - Launch lazy future ...
[16:06:14.723] Packages needed by the future expression (n = 0): <none>
[16:06:14.723] Packages needed by future strategies (n = 0): <none>
[16:06:14.724] {
[16:06:14.724]     {
[16:06:14.724]         {
[16:06:14.724]             ...future.startTime <- base::Sys.time()
[16:06:14.724]             {
[16:06:14.724]                 {
[16:06:14.724]                   {
[16:06:14.724]                     {
[16:06:14.724]                       base::local({
[16:06:14.724]                         has_future <- base::requireNamespace("future", 
[16:06:14.724]                           quietly = TRUE)
[16:06:14.724]                         if (has_future) {
[16:06:14.724]                           ns <- base::getNamespace("future")
[16:06:14.724]                           version <- ns[[".package"]][["version"]]
[16:06:14.724]                           if (is.null(version)) 
[16:06:14.724]                             version <- utils::packageVersion("future")
[16:06:14.724]                         }
[16:06:14.724]                         else {
[16:06:14.724]                           version <- NULL
[16:06:14.724]                         }
[16:06:14.724]                         if (!has_future || version < "1.8.0") {
[16:06:14.724]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.724]                             "", base::R.version$version.string), 
[16:06:14.724]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.724]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.724]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.724]                               "release", "version")], collapse = " "), 
[16:06:14.724]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.724]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.724]                             info)
[16:06:14.724]                           info <- base::paste(info, collapse = "; ")
[16:06:14.724]                           if (!has_future) {
[16:06:14.724]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.724]                               info)
[16:06:14.724]                           }
[16:06:14.724]                           else {
[16:06:14.724]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.724]                               info, version)
[16:06:14.724]                           }
[16:06:14.724]                           base::stop(msg)
[16:06:14.724]                         }
[16:06:14.724]                       })
[16:06:14.724]                     }
[16:06:14.724]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.724]                     base::options(mc.cores = 1L)
[16:06:14.724]                   }
[16:06:14.724]                   options(future.plan = NULL)
[16:06:14.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.724]                 }
[16:06:14.724]                 ...future.workdir <- getwd()
[16:06:14.724]             }
[16:06:14.724]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.724]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.724]         }
[16:06:14.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.724]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.724]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.724]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.724]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.724]             base::names(...future.oldOptions))
[16:06:14.724]     }
[16:06:14.724]     if (FALSE) {
[16:06:14.724]     }
[16:06:14.724]     else {
[16:06:14.724]         if (TRUE) {
[16:06:14.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.724]                 open = "w")
[16:06:14.724]         }
[16:06:14.724]         else {
[16:06:14.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.724]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.724]         }
[16:06:14.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.724]             base::sink(type = "output", split = FALSE)
[16:06:14.724]             base::close(...future.stdout)
[16:06:14.724]         }, add = TRUE)
[16:06:14.724]     }
[16:06:14.724]     ...future.frame <- base::sys.nframe()
[16:06:14.724]     ...future.conditions <- base::list()
[16:06:14.724]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.724]     if (FALSE) {
[16:06:14.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.724]     }
[16:06:14.724]     ...future.result <- base::tryCatch({
[16:06:14.724]         base::withCallingHandlers({
[16:06:14.724]             ...future.value <- base::withVisible(base::local({
[16:06:14.724]                 ...future.makeSendCondition <- base::local({
[16:06:14.724]                   sendCondition <- NULL
[16:06:14.724]                   function(frame = 1L) {
[16:06:14.724]                     if (is.function(sendCondition)) 
[16:06:14.724]                       return(sendCondition)
[16:06:14.724]                     ns <- getNamespace("parallel")
[16:06:14.724]                     if (exists("sendData", mode = "function", 
[16:06:14.724]                       envir = ns)) {
[16:06:14.724]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.724]                         envir = ns)
[16:06:14.724]                       envir <- sys.frame(frame)
[16:06:14.724]                       master <- NULL
[16:06:14.724]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.724]                         !identical(envir, emptyenv())) {
[16:06:14.724]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.724]                           inherits = FALSE)) {
[16:06:14.724]                           master <- get("master", mode = "list", 
[16:06:14.724]                             envir = envir, inherits = FALSE)
[16:06:14.724]                           if (inherits(master, c("SOCKnode", 
[16:06:14.724]                             "SOCK0node"))) {
[16:06:14.724]                             sendCondition <<- function(cond) {
[16:06:14.724]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.724]                                 success = TRUE)
[16:06:14.724]                               parallel_sendData(master, data)
[16:06:14.724]                             }
[16:06:14.724]                             return(sendCondition)
[16:06:14.724]                           }
[16:06:14.724]                         }
[16:06:14.724]                         frame <- frame + 1L
[16:06:14.724]                         envir <- sys.frame(frame)
[16:06:14.724]                       }
[16:06:14.724]                     }
[16:06:14.724]                     sendCondition <<- function(cond) NULL
[16:06:14.724]                   }
[16:06:14.724]                 })
[16:06:14.724]                 withCallingHandlers({
[16:06:14.724]                   1
[16:06:14.724]                 }, immediateCondition = function(cond) {
[16:06:14.724]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.724]                   sendCondition(cond)
[16:06:14.724]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.724]                   {
[16:06:14.724]                     inherits <- base::inherits
[16:06:14.724]                     invokeRestart <- base::invokeRestart
[16:06:14.724]                     is.null <- base::is.null
[16:06:14.724]                     muffled <- FALSE
[16:06:14.724]                     if (inherits(cond, "message")) {
[16:06:14.724]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.724]                       if (muffled) 
[16:06:14.724]                         invokeRestart("muffleMessage")
[16:06:14.724]                     }
[16:06:14.724]                     else if (inherits(cond, "warning")) {
[16:06:14.724]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.724]                       if (muffled) 
[16:06:14.724]                         invokeRestart("muffleWarning")
[16:06:14.724]                     }
[16:06:14.724]                     else if (inherits(cond, "condition")) {
[16:06:14.724]                       if (!is.null(pattern)) {
[16:06:14.724]                         computeRestarts <- base::computeRestarts
[16:06:14.724]                         grepl <- base::grepl
[16:06:14.724]                         restarts <- computeRestarts(cond)
[16:06:14.724]                         for (restart in restarts) {
[16:06:14.724]                           name <- restart$name
[16:06:14.724]                           if (is.null(name)) 
[16:06:14.724]                             next
[16:06:14.724]                           if (!grepl(pattern, name)) 
[16:06:14.724]                             next
[16:06:14.724]                           invokeRestart(restart)
[16:06:14.724]                           muffled <- TRUE
[16:06:14.724]                           break
[16:06:14.724]                         }
[16:06:14.724]                       }
[16:06:14.724]                     }
[16:06:14.724]                     invisible(muffled)
[16:06:14.724]                   }
[16:06:14.724]                   muffleCondition(cond)
[16:06:14.724]                 })
[16:06:14.724]             }))
[16:06:14.724]             future::FutureResult(value = ...future.value$value, 
[16:06:14.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.724]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.724]                     ...future.globalenv.names))
[16:06:14.724]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.724]         }, condition = base::local({
[16:06:14.724]             c <- base::c
[16:06:14.724]             inherits <- base::inherits
[16:06:14.724]             invokeRestart <- base::invokeRestart
[16:06:14.724]             length <- base::length
[16:06:14.724]             list <- base::list
[16:06:14.724]             seq.int <- base::seq.int
[16:06:14.724]             signalCondition <- base::signalCondition
[16:06:14.724]             sys.calls <- base::sys.calls
[16:06:14.724]             `[[` <- base::`[[`
[16:06:14.724]             `+` <- base::`+`
[16:06:14.724]             `<<-` <- base::`<<-`
[16:06:14.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.724]                   3L)]
[16:06:14.724]             }
[16:06:14.724]             function(cond) {
[16:06:14.724]                 is_error <- inherits(cond, "error")
[16:06:14.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.724]                   NULL)
[16:06:14.724]                 if (is_error) {
[16:06:14.724]                   sessionInformation <- function() {
[16:06:14.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.724]                       search = base::search(), system = base::Sys.info())
[16:06:14.724]                   }
[16:06:14.724]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.724]                     cond$call), session = sessionInformation(), 
[16:06:14.724]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.724]                   signalCondition(cond)
[16:06:14.724]                 }
[16:06:14.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.724]                 "immediateCondition"))) {
[16:06:14.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.724]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.724]                   if (TRUE && !signal) {
[16:06:14.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.724]                     {
[16:06:14.724]                       inherits <- base::inherits
[16:06:14.724]                       invokeRestart <- base::invokeRestart
[16:06:14.724]                       is.null <- base::is.null
[16:06:14.724]                       muffled <- FALSE
[16:06:14.724]                       if (inherits(cond, "message")) {
[16:06:14.724]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.724]                         if (muffled) 
[16:06:14.724]                           invokeRestart("muffleMessage")
[16:06:14.724]                       }
[16:06:14.724]                       else if (inherits(cond, "warning")) {
[16:06:14.724]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.724]                         if (muffled) 
[16:06:14.724]                           invokeRestart("muffleWarning")
[16:06:14.724]                       }
[16:06:14.724]                       else if (inherits(cond, "condition")) {
[16:06:14.724]                         if (!is.null(pattern)) {
[16:06:14.724]                           computeRestarts <- base::computeRestarts
[16:06:14.724]                           grepl <- base::grepl
[16:06:14.724]                           restarts <- computeRestarts(cond)
[16:06:14.724]                           for (restart in restarts) {
[16:06:14.724]                             name <- restart$name
[16:06:14.724]                             if (is.null(name)) 
[16:06:14.724]                               next
[16:06:14.724]                             if (!grepl(pattern, name)) 
[16:06:14.724]                               next
[16:06:14.724]                             invokeRestart(restart)
[16:06:14.724]                             muffled <- TRUE
[16:06:14.724]                             break
[16:06:14.724]                           }
[16:06:14.724]                         }
[16:06:14.724]                       }
[16:06:14.724]                       invisible(muffled)
[16:06:14.724]                     }
[16:06:14.724]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.724]                   }
[16:06:14.724]                 }
[16:06:14.724]                 else {
[16:06:14.724]                   if (TRUE) {
[16:06:14.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.724]                     {
[16:06:14.724]                       inherits <- base::inherits
[16:06:14.724]                       invokeRestart <- base::invokeRestart
[16:06:14.724]                       is.null <- base::is.null
[16:06:14.724]                       muffled <- FALSE
[16:06:14.724]                       if (inherits(cond, "message")) {
[16:06:14.724]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.724]                         if (muffled) 
[16:06:14.724]                           invokeRestart("muffleMessage")
[16:06:14.724]                       }
[16:06:14.724]                       else if (inherits(cond, "warning")) {
[16:06:14.724]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.724]                         if (muffled) 
[16:06:14.724]                           invokeRestart("muffleWarning")
[16:06:14.724]                       }
[16:06:14.724]                       else if (inherits(cond, "condition")) {
[16:06:14.724]                         if (!is.null(pattern)) {
[16:06:14.724]                           computeRestarts <- base::computeRestarts
[16:06:14.724]                           grepl <- base::grepl
[16:06:14.724]                           restarts <- computeRestarts(cond)
[16:06:14.724]                           for (restart in restarts) {
[16:06:14.724]                             name <- restart$name
[16:06:14.724]                             if (is.null(name)) 
[16:06:14.724]                               next
[16:06:14.724]                             if (!grepl(pattern, name)) 
[16:06:14.724]                               next
[16:06:14.724]                             invokeRestart(restart)
[16:06:14.724]                             muffled <- TRUE
[16:06:14.724]                             break
[16:06:14.724]                           }
[16:06:14.724]                         }
[16:06:14.724]                       }
[16:06:14.724]                       invisible(muffled)
[16:06:14.724]                     }
[16:06:14.724]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.724]                   }
[16:06:14.724]                 }
[16:06:14.724]             }
[16:06:14.724]         }))
[16:06:14.724]     }, error = function(ex) {
[16:06:14.724]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.724]                 ...future.rng), started = ...future.startTime, 
[16:06:14.724]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.724]             version = "1.8"), class = "FutureResult")
[16:06:14.724]     }, finally = {
[16:06:14.724]         if (!identical(...future.workdir, getwd())) 
[16:06:14.724]             setwd(...future.workdir)
[16:06:14.724]         {
[16:06:14.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.724]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.724]             }
[16:06:14.724]             base::options(...future.oldOptions)
[16:06:14.724]             if (.Platform$OS.type == "windows") {
[16:06:14.724]                 old_names <- names(...future.oldEnvVars)
[16:06:14.724]                 envs <- base::Sys.getenv()
[16:06:14.724]                 names <- names(envs)
[16:06:14.724]                 common <- intersect(names, old_names)
[16:06:14.724]                 added <- setdiff(names, old_names)
[16:06:14.724]                 removed <- setdiff(old_names, names)
[16:06:14.724]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.724]                   envs[common]]
[16:06:14.724]                 NAMES <- toupper(changed)
[16:06:14.724]                 args <- list()
[16:06:14.724]                 for (kk in seq_along(NAMES)) {
[16:06:14.724]                   name <- changed[[kk]]
[16:06:14.724]                   NAME <- NAMES[[kk]]
[16:06:14.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.724]                     next
[16:06:14.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.724]                 }
[16:06:14.724]                 NAMES <- toupper(added)
[16:06:14.724]                 for (kk in seq_along(NAMES)) {
[16:06:14.724]                   name <- added[[kk]]
[16:06:14.724]                   NAME <- NAMES[[kk]]
[16:06:14.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.724]                     next
[16:06:14.724]                   args[[name]] <- ""
[16:06:14.724]                 }
[16:06:14.724]                 NAMES <- toupper(removed)
[16:06:14.724]                 for (kk in seq_along(NAMES)) {
[16:06:14.724]                   name <- removed[[kk]]
[16:06:14.724]                   NAME <- NAMES[[kk]]
[16:06:14.724]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.724]                     next
[16:06:14.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.724]                 }
[16:06:14.724]                 if (length(args) > 0) 
[16:06:14.724]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.724]             }
[16:06:14.724]             else {
[16:06:14.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.724]             }
[16:06:14.724]             {
[16:06:14.724]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.724]                   0L) {
[16:06:14.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.724]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.724]                   base::options(opts)
[16:06:14.724]                 }
[16:06:14.724]                 {
[16:06:14.724]                   {
[16:06:14.724]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.724]                     NULL
[16:06:14.724]                   }
[16:06:14.724]                   options(future.plan = NULL)
[16:06:14.724]                   if (is.na(NA_character_)) 
[16:06:14.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.724]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.724]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.724]                     envir = parent.frame()) 
[16:06:14.724]                   {
[16:06:14.724]                     if (is.function(workers)) 
[16:06:14.724]                       workers <- workers()
[16:06:14.724]                     workers <- structure(as.integer(workers), 
[16:06:14.724]                       class = class(workers))
[16:06:14.724]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.724]                       workers >= 1)
[16:06:14.724]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.724]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.724]                     }
[16:06:14.724]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.724]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.724]                       envir = envir)
[16:06:14.724]                     if (!future$lazy) 
[16:06:14.724]                       future <- run(future)
[16:06:14.724]                     invisible(future)
[16:06:14.724]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.724]                 }
[16:06:14.724]             }
[16:06:14.724]         }
[16:06:14.724]     })
[16:06:14.724]     if (TRUE) {
[16:06:14.724]         base::sink(type = "output", split = FALSE)
[16:06:14.724]         if (TRUE) {
[16:06:14.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.724]         }
[16:06:14.724]         else {
[16:06:14.724]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.724]         }
[16:06:14.724]         base::close(...future.stdout)
[16:06:14.724]         ...future.stdout <- NULL
[16:06:14.724]     }
[16:06:14.724]     ...future.result$conditions <- ...future.conditions
[16:06:14.724]     ...future.result$finished <- base::Sys.time()
[16:06:14.724]     ...future.result
[16:06:14.724] }
[16:06:14.727] MultisessionFuture started
[16:06:14.727] - Launch lazy future ... done
[16:06:14.727] run() for ‘MultisessionFuture’ ... done
[16:06:14.727] getGlobalsAndPackages() ...
[16:06:14.727] Searching for globals...
[16:06:14.728] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:06:14.728] Searching for globals ... DONE
[16:06:14.728] Resolving globals: FALSE
[16:06:14.729] 
[16:06:14.729] 
[16:06:14.729] getGlobalsAndPackages() ... DONE
[16:06:14.729] run() for ‘Future’ ...
[16:06:14.729] - state: ‘created’
[16:06:14.729] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:14.742] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:14.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:14.743]   - Field: ‘node’
[16:06:14.743]   - Field: ‘label’
[16:06:14.743]   - Field: ‘local’
[16:06:14.743]   - Field: ‘owner’
[16:06:14.743]   - Field: ‘envir’
[16:06:14.743]   - Field: ‘workers’
[16:06:14.743]   - Field: ‘packages’
[16:06:14.743]   - Field: ‘gc’
[16:06:14.744]   - Field: ‘conditions’
[16:06:14.744]   - Field: ‘persistent’
[16:06:14.744]   - Field: ‘expr’
[16:06:14.744]   - Field: ‘uuid’
[16:06:14.744]   - Field: ‘seed’
[16:06:14.744]   - Field: ‘version’
[16:06:14.744]   - Field: ‘result’
[16:06:14.744]   - Field: ‘asynchronous’
[16:06:14.744]   - Field: ‘calls’
[16:06:14.744]   - Field: ‘globals’
[16:06:14.744]   - Field: ‘stdout’
[16:06:14.745]   - Field: ‘earlySignal’
[16:06:14.745]   - Field: ‘lazy’
[16:06:14.745]   - Field: ‘state’
[16:06:14.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:14.745] - Launch lazy future ...
[16:06:14.745] Packages needed by the future expression (n = 0): <none>
[16:06:14.745] Packages needed by future strategies (n = 0): <none>
[16:06:14.746] {
[16:06:14.746]     {
[16:06:14.746]         {
[16:06:14.746]             ...future.startTime <- base::Sys.time()
[16:06:14.746]             {
[16:06:14.746]                 {
[16:06:14.746]                   {
[16:06:14.746]                     {
[16:06:14.746]                       base::local({
[16:06:14.746]                         has_future <- base::requireNamespace("future", 
[16:06:14.746]                           quietly = TRUE)
[16:06:14.746]                         if (has_future) {
[16:06:14.746]                           ns <- base::getNamespace("future")
[16:06:14.746]                           version <- ns[[".package"]][["version"]]
[16:06:14.746]                           if (is.null(version)) 
[16:06:14.746]                             version <- utils::packageVersion("future")
[16:06:14.746]                         }
[16:06:14.746]                         else {
[16:06:14.746]                           version <- NULL
[16:06:14.746]                         }
[16:06:14.746]                         if (!has_future || version < "1.8.0") {
[16:06:14.746]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:14.746]                             "", base::R.version$version.string), 
[16:06:14.746]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:14.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:14.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:14.746]                               "release", "version")], collapse = " "), 
[16:06:14.746]                             hostname = base::Sys.info()[["nodename"]])
[16:06:14.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:14.746]                             info)
[16:06:14.746]                           info <- base::paste(info, collapse = "; ")
[16:06:14.746]                           if (!has_future) {
[16:06:14.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:14.746]                               info)
[16:06:14.746]                           }
[16:06:14.746]                           else {
[16:06:14.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:14.746]                               info, version)
[16:06:14.746]                           }
[16:06:14.746]                           base::stop(msg)
[16:06:14.746]                         }
[16:06:14.746]                       })
[16:06:14.746]                     }
[16:06:14.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:14.746]                     base::options(mc.cores = 1L)
[16:06:14.746]                   }
[16:06:14.746]                   options(future.plan = NULL)
[16:06:14.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:14.746]                 }
[16:06:14.746]                 ...future.workdir <- getwd()
[16:06:14.746]             }
[16:06:14.746]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:14.746]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:14.746]         }
[16:06:14.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:14.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:14.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:14.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:14.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:14.746]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:14.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:14.746]             base::names(...future.oldOptions))
[16:06:14.746]     }
[16:06:14.746]     if (FALSE) {
[16:06:14.746]     }
[16:06:14.746]     else {
[16:06:14.746]         if (TRUE) {
[16:06:14.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:14.746]                 open = "w")
[16:06:14.746]         }
[16:06:14.746]         else {
[16:06:14.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:14.746]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:14.746]         }
[16:06:14.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:14.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:14.746]             base::sink(type = "output", split = FALSE)
[16:06:14.746]             base::close(...future.stdout)
[16:06:14.746]         }, add = TRUE)
[16:06:14.746]     }
[16:06:14.746]     ...future.frame <- base::sys.nframe()
[16:06:14.746]     ...future.conditions <- base::list()
[16:06:14.746]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:14.746]     if (FALSE) {
[16:06:14.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:14.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:14.746]     }
[16:06:14.746]     ...future.result <- base::tryCatch({
[16:06:14.746]         base::withCallingHandlers({
[16:06:14.746]             ...future.value <- base::withVisible(base::local({
[16:06:14.746]                 ...future.makeSendCondition <- base::local({
[16:06:14.746]                   sendCondition <- NULL
[16:06:14.746]                   function(frame = 1L) {
[16:06:14.746]                     if (is.function(sendCondition)) 
[16:06:14.746]                       return(sendCondition)
[16:06:14.746]                     ns <- getNamespace("parallel")
[16:06:14.746]                     if (exists("sendData", mode = "function", 
[16:06:14.746]                       envir = ns)) {
[16:06:14.746]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:14.746]                         envir = ns)
[16:06:14.746]                       envir <- sys.frame(frame)
[16:06:14.746]                       master <- NULL
[16:06:14.746]                       while (!identical(envir, .GlobalEnv) && 
[16:06:14.746]                         !identical(envir, emptyenv())) {
[16:06:14.746]                         if (exists("master", mode = "list", envir = envir, 
[16:06:14.746]                           inherits = FALSE)) {
[16:06:14.746]                           master <- get("master", mode = "list", 
[16:06:14.746]                             envir = envir, inherits = FALSE)
[16:06:14.746]                           if (inherits(master, c("SOCKnode", 
[16:06:14.746]                             "SOCK0node"))) {
[16:06:14.746]                             sendCondition <<- function(cond) {
[16:06:14.746]                               data <- list(type = "VALUE", value = cond, 
[16:06:14.746]                                 success = TRUE)
[16:06:14.746]                               parallel_sendData(master, data)
[16:06:14.746]                             }
[16:06:14.746]                             return(sendCondition)
[16:06:14.746]                           }
[16:06:14.746]                         }
[16:06:14.746]                         frame <- frame + 1L
[16:06:14.746]                         envir <- sys.frame(frame)
[16:06:14.746]                       }
[16:06:14.746]                     }
[16:06:14.746]                     sendCondition <<- function(cond) NULL
[16:06:14.746]                   }
[16:06:14.746]                 })
[16:06:14.746]                 withCallingHandlers({
[16:06:14.746]                   {
[16:06:14.746]                     Sys.sleep(0.5)
[16:06:14.746]                     2
[16:06:14.746]                   }
[16:06:14.746]                 }, immediateCondition = function(cond) {
[16:06:14.746]                   sendCondition <- ...future.makeSendCondition()
[16:06:14.746]                   sendCondition(cond)
[16:06:14.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.746]                   {
[16:06:14.746]                     inherits <- base::inherits
[16:06:14.746]                     invokeRestart <- base::invokeRestart
[16:06:14.746]                     is.null <- base::is.null
[16:06:14.746]                     muffled <- FALSE
[16:06:14.746]                     if (inherits(cond, "message")) {
[16:06:14.746]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:14.746]                       if (muffled) 
[16:06:14.746]                         invokeRestart("muffleMessage")
[16:06:14.746]                     }
[16:06:14.746]                     else if (inherits(cond, "warning")) {
[16:06:14.746]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:14.746]                       if (muffled) 
[16:06:14.746]                         invokeRestart("muffleWarning")
[16:06:14.746]                     }
[16:06:14.746]                     else if (inherits(cond, "condition")) {
[16:06:14.746]                       if (!is.null(pattern)) {
[16:06:14.746]                         computeRestarts <- base::computeRestarts
[16:06:14.746]                         grepl <- base::grepl
[16:06:14.746]                         restarts <- computeRestarts(cond)
[16:06:14.746]                         for (restart in restarts) {
[16:06:14.746]                           name <- restart$name
[16:06:14.746]                           if (is.null(name)) 
[16:06:14.746]                             next
[16:06:14.746]                           if (!grepl(pattern, name)) 
[16:06:14.746]                             next
[16:06:14.746]                           invokeRestart(restart)
[16:06:14.746]                           muffled <- TRUE
[16:06:14.746]                           break
[16:06:14.746]                         }
[16:06:14.746]                       }
[16:06:14.746]                     }
[16:06:14.746]                     invisible(muffled)
[16:06:14.746]                   }
[16:06:14.746]                   muffleCondition(cond)
[16:06:14.746]                 })
[16:06:14.746]             }))
[16:06:14.746]             future::FutureResult(value = ...future.value$value, 
[16:06:14.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.746]                   ...future.rng), globalenv = if (FALSE) 
[16:06:14.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:14.746]                     ...future.globalenv.names))
[16:06:14.746]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:14.746]         }, condition = base::local({
[16:06:14.746]             c <- base::c
[16:06:14.746]             inherits <- base::inherits
[16:06:14.746]             invokeRestart <- base::invokeRestart
[16:06:14.746]             length <- base::length
[16:06:14.746]             list <- base::list
[16:06:14.746]             seq.int <- base::seq.int
[16:06:14.746]             signalCondition <- base::signalCondition
[16:06:14.746]             sys.calls <- base::sys.calls
[16:06:14.746]             `[[` <- base::`[[`
[16:06:14.746]             `+` <- base::`+`
[16:06:14.746]             `<<-` <- base::`<<-`
[16:06:14.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:14.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:14.746]                   3L)]
[16:06:14.746]             }
[16:06:14.746]             function(cond) {
[16:06:14.746]                 is_error <- inherits(cond, "error")
[16:06:14.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:14.746]                   NULL)
[16:06:14.746]                 if (is_error) {
[16:06:14.746]                   sessionInformation <- function() {
[16:06:14.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:14.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:14.746]                       search = base::search(), system = base::Sys.info())
[16:06:14.746]                   }
[16:06:14.746]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:14.746]                     cond$call), session = sessionInformation(), 
[16:06:14.746]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:14.746]                   signalCondition(cond)
[16:06:14.746]                 }
[16:06:14.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:14.746]                 "immediateCondition"))) {
[16:06:14.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:14.746]                   ...future.conditions[[length(...future.conditions) + 
[16:06:14.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:14.746]                   if (TRUE && !signal) {
[16:06:14.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.746]                     {
[16:06:14.746]                       inherits <- base::inherits
[16:06:14.746]                       invokeRestart <- base::invokeRestart
[16:06:14.746]                       is.null <- base::is.null
[16:06:14.746]                       muffled <- FALSE
[16:06:14.746]                       if (inherits(cond, "message")) {
[16:06:14.746]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.746]                         if (muffled) 
[16:06:14.746]                           invokeRestart("muffleMessage")
[16:06:14.746]                       }
[16:06:14.746]                       else if (inherits(cond, "warning")) {
[16:06:14.746]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.746]                         if (muffled) 
[16:06:14.746]                           invokeRestart("muffleWarning")
[16:06:14.746]                       }
[16:06:14.746]                       else if (inherits(cond, "condition")) {
[16:06:14.746]                         if (!is.null(pattern)) {
[16:06:14.746]                           computeRestarts <- base::computeRestarts
[16:06:14.746]                           grepl <- base::grepl
[16:06:14.746]                           restarts <- computeRestarts(cond)
[16:06:14.746]                           for (restart in restarts) {
[16:06:14.746]                             name <- restart$name
[16:06:14.746]                             if (is.null(name)) 
[16:06:14.746]                               next
[16:06:14.746]                             if (!grepl(pattern, name)) 
[16:06:14.746]                               next
[16:06:14.746]                             invokeRestart(restart)
[16:06:14.746]                             muffled <- TRUE
[16:06:14.746]                             break
[16:06:14.746]                           }
[16:06:14.746]                         }
[16:06:14.746]                       }
[16:06:14.746]                       invisible(muffled)
[16:06:14.746]                     }
[16:06:14.746]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.746]                   }
[16:06:14.746]                 }
[16:06:14.746]                 else {
[16:06:14.746]                   if (TRUE) {
[16:06:14.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:14.746]                     {
[16:06:14.746]                       inherits <- base::inherits
[16:06:14.746]                       invokeRestart <- base::invokeRestart
[16:06:14.746]                       is.null <- base::is.null
[16:06:14.746]                       muffled <- FALSE
[16:06:14.746]                       if (inherits(cond, "message")) {
[16:06:14.746]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:14.746]                         if (muffled) 
[16:06:14.746]                           invokeRestart("muffleMessage")
[16:06:14.746]                       }
[16:06:14.746]                       else if (inherits(cond, "warning")) {
[16:06:14.746]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:14.746]                         if (muffled) 
[16:06:14.746]                           invokeRestart("muffleWarning")
[16:06:14.746]                       }
[16:06:14.746]                       else if (inherits(cond, "condition")) {
[16:06:14.746]                         if (!is.null(pattern)) {
[16:06:14.746]                           computeRestarts <- base::computeRestarts
[16:06:14.746]                           grepl <- base::grepl
[16:06:14.746]                           restarts <- computeRestarts(cond)
[16:06:14.746]                           for (restart in restarts) {
[16:06:14.746]                             name <- restart$name
[16:06:14.746]                             if (is.null(name)) 
[16:06:14.746]                               next
[16:06:14.746]                             if (!grepl(pattern, name)) 
[16:06:14.746]                               next
[16:06:14.746]                             invokeRestart(restart)
[16:06:14.746]                             muffled <- TRUE
[16:06:14.746]                             break
[16:06:14.746]                           }
[16:06:14.746]                         }
[16:06:14.746]                       }
[16:06:14.746]                       invisible(muffled)
[16:06:14.746]                     }
[16:06:14.746]                     muffleCondition(cond, pattern = "^muffle")
[16:06:14.746]                   }
[16:06:14.746]                 }
[16:06:14.746]             }
[16:06:14.746]         }))
[16:06:14.746]     }, error = function(ex) {
[16:06:14.746]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:14.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:14.746]                 ...future.rng), started = ...future.startTime, 
[16:06:14.746]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:14.746]             version = "1.8"), class = "FutureResult")
[16:06:14.746]     }, finally = {
[16:06:14.746]         if (!identical(...future.workdir, getwd())) 
[16:06:14.746]             setwd(...future.workdir)
[16:06:14.746]         {
[16:06:14.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:14.746]                 ...future.oldOptions$nwarnings <- NULL
[16:06:14.746]             }
[16:06:14.746]             base::options(...future.oldOptions)
[16:06:14.746]             if (.Platform$OS.type == "windows") {
[16:06:14.746]                 old_names <- names(...future.oldEnvVars)
[16:06:14.746]                 envs <- base::Sys.getenv()
[16:06:14.746]                 names <- names(envs)
[16:06:14.746]                 common <- intersect(names, old_names)
[16:06:14.746]                 added <- setdiff(names, old_names)
[16:06:14.746]                 removed <- setdiff(old_names, names)
[16:06:14.746]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:14.746]                   envs[common]]
[16:06:14.746]                 NAMES <- toupper(changed)
[16:06:14.746]                 args <- list()
[16:06:14.746]                 for (kk in seq_along(NAMES)) {
[16:06:14.746]                   name <- changed[[kk]]
[16:06:14.746]                   NAME <- NAMES[[kk]]
[16:06:14.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.746]                     next
[16:06:14.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.746]                 }
[16:06:14.746]                 NAMES <- toupper(added)
[16:06:14.746]                 for (kk in seq_along(NAMES)) {
[16:06:14.746]                   name <- added[[kk]]
[16:06:14.746]                   NAME <- NAMES[[kk]]
[16:06:14.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.746]                     next
[16:06:14.746]                   args[[name]] <- ""
[16:06:14.746]                 }
[16:06:14.746]                 NAMES <- toupper(removed)
[16:06:14.746]                 for (kk in seq_along(NAMES)) {
[16:06:14.746]                   name <- removed[[kk]]
[16:06:14.746]                   NAME <- NAMES[[kk]]
[16:06:14.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:14.746]                     next
[16:06:14.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:14.746]                 }
[16:06:14.746]                 if (length(args) > 0) 
[16:06:14.746]                   base::do.call(base::Sys.setenv, args = args)
[16:06:14.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:14.746]             }
[16:06:14.746]             else {
[16:06:14.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:14.746]             }
[16:06:14.746]             {
[16:06:14.746]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:14.746]                   0L) {
[16:06:14.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:14.746]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:14.746]                   base::options(opts)
[16:06:14.746]                 }
[16:06:14.746]                 {
[16:06:14.746]                   {
[16:06:14.746]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:14.746]                     NULL
[16:06:14.746]                   }
[16:06:14.746]                   options(future.plan = NULL)
[16:06:14.746]                   if (is.na(NA_character_)) 
[16:06:14.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:14.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:14.746]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:14.746]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:14.746]                     envir = parent.frame()) 
[16:06:14.746]                   {
[16:06:14.746]                     if (is.function(workers)) 
[16:06:14.746]                       workers <- workers()
[16:06:14.746]                     workers <- structure(as.integer(workers), 
[16:06:14.746]                       class = class(workers))
[16:06:14.746]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:14.746]                       workers >= 1)
[16:06:14.746]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:14.746]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:14.746]                     }
[16:06:14.746]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:14.746]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:14.746]                       envir = envir)
[16:06:14.746]                     if (!future$lazy) 
[16:06:14.746]                       future <- run(future)
[16:06:14.746]                     invisible(future)
[16:06:14.746]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:14.746]                 }
[16:06:14.746]             }
[16:06:14.746]         }
[16:06:14.746]     })
[16:06:14.746]     if (TRUE) {
[16:06:14.746]         base::sink(type = "output", split = FALSE)
[16:06:14.746]         if (TRUE) {
[16:06:14.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:14.746]         }
[16:06:14.746]         else {
[16:06:14.746]             ...future.result["stdout"] <- base::list(NULL)
[16:06:14.746]         }
[16:06:14.746]         base::close(...future.stdout)
[16:06:14.746]         ...future.stdout <- NULL
[16:06:14.746]     }
[16:06:14.746]     ...future.result$conditions <- ...future.conditions
[16:06:14.746]     ...future.result$finished <- base::Sys.time()
[16:06:14.746]     ...future.result
[16:06:14.746] }
[16:06:14.749] MultisessionFuture started
[16:06:14.749] - Launch lazy future ... done
[16:06:14.749] run() for ‘MultisessionFuture’ ... done
[16:06:14.749] resolve() on list ...
[16:06:14.749]  recursive: 0
[16:06:14.749]  length: 1
[16:06:14.750] 
[16:06:14.775] receiveMessageFromWorker() for ClusterFuture ...
[16:06:14.775] - Validating connection of MultisessionFuture
[16:06:14.776] - received message: FutureResult
[16:06:14.776] - Received FutureResult
[16:06:14.776] - Erased future from FutureRegistry
[16:06:14.776] result() for ClusterFuture ...
[16:06:14.776] - result already collected: FutureResult
[16:06:14.776] result() for ClusterFuture ... done
[16:06:14.776] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:14.776] Future #1
[16:06:14.776]  length: 0 (resolved future 1)
[16:06:14.776] resolve() on list ... DONE
[16:06:14.777] resolve() on list ...
[16:06:14.777]  recursive: 0
[16:06:14.777]  length: 1
[16:06:14.777] 
[16:06:15.297] receiveMessageFromWorker() for ClusterFuture ...
[16:06:15.297] - Validating connection of MultisessionFuture
[16:06:15.297] - received message: FutureResult
[16:06:15.297] - Received FutureResult
[16:06:15.297] - Erased future from FutureRegistry
[16:06:15.298] result() for ClusterFuture ...
[16:06:15.298] - result already collected: FutureResult
[16:06:15.298] result() for ClusterFuture ... done
[16:06:15.298] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:15.298] Future #1
[16:06:15.298]  length: 0 (resolved future 1)
[16:06:15.298] resolve() on list ... DONE
[16:06:15.298] resolve() on list ...
[16:06:15.298]  recursive: 0
[16:06:15.299]  length: 1
[16:06:15.299] 
[16:06:15.299]  length: 0 (resolved future 1)
[16:06:15.299] resolve() on list ... DONE
[16:06:15.299] resolve() on list ...
[16:06:15.299]  recursive: 0
[16:06:15.299]  length: 4
[16:06:15.299] 
[16:06:15.299] Future #1
[16:06:15.300]  length: 3 (resolved future 1)
[16:06:15.300] Future #2
[16:06:15.300]  length: 2 (resolved future 2)
[16:06:15.300]  length: 1 (resolved future 3)
[16:06:15.300]  length: 0 (resolved future 4)
[16:06:15.300] resolve() on list ... DONE
[16:06:15.300] resolve() on list ...
[16:06:15.300]  recursive: 0
[16:06:15.300]  length: 4
[16:06:15.300] 
[16:06:15.301] Future #1
[16:06:15.301]  length: 3 (resolved future 1)
[16:06:15.301] Future #2
[16:06:15.301]  length: 2 (resolved future 2)
[16:06:15.301]  length: 1 (resolved future 3)
[16:06:15.301]  length: 0 (resolved future 4)
[16:06:15.301] resolve() on list ... DONE
[16:06:15.301] resolve() on list ...
[16:06:15.301]  recursive: 0
[16:06:15.302]  length: 1
[16:06:15.302] 
[16:06:15.302]  length: 0 (resolved future 1)
[16:06:15.302] resolve() on list ... DONE
[16:06:15.302] getGlobalsAndPackages() ...
[16:06:15.302] Searching for globals...
[16:06:15.303] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:06:15.303] Searching for globals ... DONE
[16:06:15.303] Resolving globals: FALSE
[16:06:15.304] The total size of the 1 globals is 56 bytes (56 bytes)
[16:06:15.304] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:06:15.304] - globals: [1] ‘kk’
[16:06:15.304] 
[16:06:15.304] getGlobalsAndPackages() ... DONE
[16:06:15.305] run() for ‘Future’ ...
[16:06:15.305] - state: ‘created’
[16:06:15.305] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:15.319] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:15.319] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:15.319]   - Field: ‘node’
[16:06:15.319]   - Field: ‘label’
[16:06:15.319]   - Field: ‘local’
[16:06:15.319]   - Field: ‘owner’
[16:06:15.319]   - Field: ‘envir’
[16:06:15.319]   - Field: ‘workers’
[16:06:15.319]   - Field: ‘packages’
[16:06:15.320]   - Field: ‘gc’
[16:06:15.320]   - Field: ‘conditions’
[16:06:15.320]   - Field: ‘persistent’
[16:06:15.320]   - Field: ‘expr’
[16:06:15.320]   - Field: ‘uuid’
[16:06:15.320]   - Field: ‘seed’
[16:06:15.320]   - Field: ‘version’
[16:06:15.320]   - Field: ‘result’
[16:06:15.320]   - Field: ‘asynchronous’
[16:06:15.320]   - Field: ‘calls’
[16:06:15.320]   - Field: ‘globals’
[16:06:15.321]   - Field: ‘stdout’
[16:06:15.321]   - Field: ‘earlySignal’
[16:06:15.321]   - Field: ‘lazy’
[16:06:15.321]   - Field: ‘state’
[16:06:15.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:15.321] - Launch lazy future ...
[16:06:15.321] Packages needed by the future expression (n = 0): <none>
[16:06:15.321] Packages needed by future strategies (n = 0): <none>
[16:06:15.322] {
[16:06:15.322]     {
[16:06:15.322]         {
[16:06:15.322]             ...future.startTime <- base::Sys.time()
[16:06:15.322]             {
[16:06:15.322]                 {
[16:06:15.322]                   {
[16:06:15.322]                     {
[16:06:15.322]                       base::local({
[16:06:15.322]                         has_future <- base::requireNamespace("future", 
[16:06:15.322]                           quietly = TRUE)
[16:06:15.322]                         if (has_future) {
[16:06:15.322]                           ns <- base::getNamespace("future")
[16:06:15.322]                           version <- ns[[".package"]][["version"]]
[16:06:15.322]                           if (is.null(version)) 
[16:06:15.322]                             version <- utils::packageVersion("future")
[16:06:15.322]                         }
[16:06:15.322]                         else {
[16:06:15.322]                           version <- NULL
[16:06:15.322]                         }
[16:06:15.322]                         if (!has_future || version < "1.8.0") {
[16:06:15.322]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:15.322]                             "", base::R.version$version.string), 
[16:06:15.322]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:15.322]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:15.322]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:15.322]                               "release", "version")], collapse = " "), 
[16:06:15.322]                             hostname = base::Sys.info()[["nodename"]])
[16:06:15.322]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:15.322]                             info)
[16:06:15.322]                           info <- base::paste(info, collapse = "; ")
[16:06:15.322]                           if (!has_future) {
[16:06:15.322]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:15.322]                               info)
[16:06:15.322]                           }
[16:06:15.322]                           else {
[16:06:15.322]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:15.322]                               info, version)
[16:06:15.322]                           }
[16:06:15.322]                           base::stop(msg)
[16:06:15.322]                         }
[16:06:15.322]                       })
[16:06:15.322]                     }
[16:06:15.322]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:15.322]                     base::options(mc.cores = 1L)
[16:06:15.322]                   }
[16:06:15.322]                   options(future.plan = NULL)
[16:06:15.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:15.322]                 }
[16:06:15.322]                 ...future.workdir <- getwd()
[16:06:15.322]             }
[16:06:15.322]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:15.322]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:15.322]         }
[16:06:15.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:15.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:15.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:15.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:15.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:15.322]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:15.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:15.322]             base::names(...future.oldOptions))
[16:06:15.322]     }
[16:06:15.322]     if (FALSE) {
[16:06:15.322]     }
[16:06:15.322]     else {
[16:06:15.322]         if (TRUE) {
[16:06:15.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:15.322]                 open = "w")
[16:06:15.322]         }
[16:06:15.322]         else {
[16:06:15.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:15.322]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:15.322]         }
[16:06:15.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:15.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:15.322]             base::sink(type = "output", split = FALSE)
[16:06:15.322]             base::close(...future.stdout)
[16:06:15.322]         }, add = TRUE)
[16:06:15.322]     }
[16:06:15.322]     ...future.frame <- base::sys.nframe()
[16:06:15.322]     ...future.conditions <- base::list()
[16:06:15.322]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:15.322]     if (FALSE) {
[16:06:15.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:15.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:15.322]     }
[16:06:15.322]     ...future.result <- base::tryCatch({
[16:06:15.322]         base::withCallingHandlers({
[16:06:15.322]             ...future.value <- base::withVisible(base::local({
[16:06:15.322]                 ...future.makeSendCondition <- base::local({
[16:06:15.322]                   sendCondition <- NULL
[16:06:15.322]                   function(frame = 1L) {
[16:06:15.322]                     if (is.function(sendCondition)) 
[16:06:15.322]                       return(sendCondition)
[16:06:15.322]                     ns <- getNamespace("parallel")
[16:06:15.322]                     if (exists("sendData", mode = "function", 
[16:06:15.322]                       envir = ns)) {
[16:06:15.322]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:15.322]                         envir = ns)
[16:06:15.322]                       envir <- sys.frame(frame)
[16:06:15.322]                       master <- NULL
[16:06:15.322]                       while (!identical(envir, .GlobalEnv) && 
[16:06:15.322]                         !identical(envir, emptyenv())) {
[16:06:15.322]                         if (exists("master", mode = "list", envir = envir, 
[16:06:15.322]                           inherits = FALSE)) {
[16:06:15.322]                           master <- get("master", mode = "list", 
[16:06:15.322]                             envir = envir, inherits = FALSE)
[16:06:15.322]                           if (inherits(master, c("SOCKnode", 
[16:06:15.322]                             "SOCK0node"))) {
[16:06:15.322]                             sendCondition <<- function(cond) {
[16:06:15.322]                               data <- list(type = "VALUE", value = cond, 
[16:06:15.322]                                 success = TRUE)
[16:06:15.322]                               parallel_sendData(master, data)
[16:06:15.322]                             }
[16:06:15.322]                             return(sendCondition)
[16:06:15.322]                           }
[16:06:15.322]                         }
[16:06:15.322]                         frame <- frame + 1L
[16:06:15.322]                         envir <- sys.frame(frame)
[16:06:15.322]                       }
[16:06:15.322]                     }
[16:06:15.322]                     sendCondition <<- function(cond) NULL
[16:06:15.322]                   }
[16:06:15.322]                 })
[16:06:15.322]                 withCallingHandlers({
[16:06:15.322]                   {
[16:06:15.322]                     Sys.sleep(0.1)
[16:06:15.322]                     kk
[16:06:15.322]                   }
[16:06:15.322]                 }, immediateCondition = function(cond) {
[16:06:15.322]                   sendCondition <- ...future.makeSendCondition()
[16:06:15.322]                   sendCondition(cond)
[16:06:15.322]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.322]                   {
[16:06:15.322]                     inherits <- base::inherits
[16:06:15.322]                     invokeRestart <- base::invokeRestart
[16:06:15.322]                     is.null <- base::is.null
[16:06:15.322]                     muffled <- FALSE
[16:06:15.322]                     if (inherits(cond, "message")) {
[16:06:15.322]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:15.322]                       if (muffled) 
[16:06:15.322]                         invokeRestart("muffleMessage")
[16:06:15.322]                     }
[16:06:15.322]                     else if (inherits(cond, "warning")) {
[16:06:15.322]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:15.322]                       if (muffled) 
[16:06:15.322]                         invokeRestart("muffleWarning")
[16:06:15.322]                     }
[16:06:15.322]                     else if (inherits(cond, "condition")) {
[16:06:15.322]                       if (!is.null(pattern)) {
[16:06:15.322]                         computeRestarts <- base::computeRestarts
[16:06:15.322]                         grepl <- base::grepl
[16:06:15.322]                         restarts <- computeRestarts(cond)
[16:06:15.322]                         for (restart in restarts) {
[16:06:15.322]                           name <- restart$name
[16:06:15.322]                           if (is.null(name)) 
[16:06:15.322]                             next
[16:06:15.322]                           if (!grepl(pattern, name)) 
[16:06:15.322]                             next
[16:06:15.322]                           invokeRestart(restart)
[16:06:15.322]                           muffled <- TRUE
[16:06:15.322]                           break
[16:06:15.322]                         }
[16:06:15.322]                       }
[16:06:15.322]                     }
[16:06:15.322]                     invisible(muffled)
[16:06:15.322]                   }
[16:06:15.322]                   muffleCondition(cond)
[16:06:15.322]                 })
[16:06:15.322]             }))
[16:06:15.322]             future::FutureResult(value = ...future.value$value, 
[16:06:15.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.322]                   ...future.rng), globalenv = if (FALSE) 
[16:06:15.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:15.322]                     ...future.globalenv.names))
[16:06:15.322]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:15.322]         }, condition = base::local({
[16:06:15.322]             c <- base::c
[16:06:15.322]             inherits <- base::inherits
[16:06:15.322]             invokeRestart <- base::invokeRestart
[16:06:15.322]             length <- base::length
[16:06:15.322]             list <- base::list
[16:06:15.322]             seq.int <- base::seq.int
[16:06:15.322]             signalCondition <- base::signalCondition
[16:06:15.322]             sys.calls <- base::sys.calls
[16:06:15.322]             `[[` <- base::`[[`
[16:06:15.322]             `+` <- base::`+`
[16:06:15.322]             `<<-` <- base::`<<-`
[16:06:15.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:15.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:15.322]                   3L)]
[16:06:15.322]             }
[16:06:15.322]             function(cond) {
[16:06:15.322]                 is_error <- inherits(cond, "error")
[16:06:15.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:15.322]                   NULL)
[16:06:15.322]                 if (is_error) {
[16:06:15.322]                   sessionInformation <- function() {
[16:06:15.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:15.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:15.322]                       search = base::search(), system = base::Sys.info())
[16:06:15.322]                   }
[16:06:15.322]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:15.322]                     cond$call), session = sessionInformation(), 
[16:06:15.322]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:15.322]                   signalCondition(cond)
[16:06:15.322]                 }
[16:06:15.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:15.322]                 "immediateCondition"))) {
[16:06:15.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:15.322]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:15.322]                   if (TRUE && !signal) {
[16:06:15.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.322]                     {
[16:06:15.322]                       inherits <- base::inherits
[16:06:15.322]                       invokeRestart <- base::invokeRestart
[16:06:15.322]                       is.null <- base::is.null
[16:06:15.322]                       muffled <- FALSE
[16:06:15.322]                       if (inherits(cond, "message")) {
[16:06:15.322]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.322]                         if (muffled) 
[16:06:15.322]                           invokeRestart("muffleMessage")
[16:06:15.322]                       }
[16:06:15.322]                       else if (inherits(cond, "warning")) {
[16:06:15.322]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.322]                         if (muffled) 
[16:06:15.322]                           invokeRestart("muffleWarning")
[16:06:15.322]                       }
[16:06:15.322]                       else if (inherits(cond, "condition")) {
[16:06:15.322]                         if (!is.null(pattern)) {
[16:06:15.322]                           computeRestarts <- base::computeRestarts
[16:06:15.322]                           grepl <- base::grepl
[16:06:15.322]                           restarts <- computeRestarts(cond)
[16:06:15.322]                           for (restart in restarts) {
[16:06:15.322]                             name <- restart$name
[16:06:15.322]                             if (is.null(name)) 
[16:06:15.322]                               next
[16:06:15.322]                             if (!grepl(pattern, name)) 
[16:06:15.322]                               next
[16:06:15.322]                             invokeRestart(restart)
[16:06:15.322]                             muffled <- TRUE
[16:06:15.322]                             break
[16:06:15.322]                           }
[16:06:15.322]                         }
[16:06:15.322]                       }
[16:06:15.322]                       invisible(muffled)
[16:06:15.322]                     }
[16:06:15.322]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.322]                   }
[16:06:15.322]                 }
[16:06:15.322]                 else {
[16:06:15.322]                   if (TRUE) {
[16:06:15.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.322]                     {
[16:06:15.322]                       inherits <- base::inherits
[16:06:15.322]                       invokeRestart <- base::invokeRestart
[16:06:15.322]                       is.null <- base::is.null
[16:06:15.322]                       muffled <- FALSE
[16:06:15.322]                       if (inherits(cond, "message")) {
[16:06:15.322]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.322]                         if (muffled) 
[16:06:15.322]                           invokeRestart("muffleMessage")
[16:06:15.322]                       }
[16:06:15.322]                       else if (inherits(cond, "warning")) {
[16:06:15.322]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.322]                         if (muffled) 
[16:06:15.322]                           invokeRestart("muffleWarning")
[16:06:15.322]                       }
[16:06:15.322]                       else if (inherits(cond, "condition")) {
[16:06:15.322]                         if (!is.null(pattern)) {
[16:06:15.322]                           computeRestarts <- base::computeRestarts
[16:06:15.322]                           grepl <- base::grepl
[16:06:15.322]                           restarts <- computeRestarts(cond)
[16:06:15.322]                           for (restart in restarts) {
[16:06:15.322]                             name <- restart$name
[16:06:15.322]                             if (is.null(name)) 
[16:06:15.322]                               next
[16:06:15.322]                             if (!grepl(pattern, name)) 
[16:06:15.322]                               next
[16:06:15.322]                             invokeRestart(restart)
[16:06:15.322]                             muffled <- TRUE
[16:06:15.322]                             break
[16:06:15.322]                           }
[16:06:15.322]                         }
[16:06:15.322]                       }
[16:06:15.322]                       invisible(muffled)
[16:06:15.322]                     }
[16:06:15.322]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.322]                   }
[16:06:15.322]                 }
[16:06:15.322]             }
[16:06:15.322]         }))
[16:06:15.322]     }, error = function(ex) {
[16:06:15.322]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:15.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.322]                 ...future.rng), started = ...future.startTime, 
[16:06:15.322]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:15.322]             version = "1.8"), class = "FutureResult")
[16:06:15.322]     }, finally = {
[16:06:15.322]         if (!identical(...future.workdir, getwd())) 
[16:06:15.322]             setwd(...future.workdir)
[16:06:15.322]         {
[16:06:15.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:15.322]                 ...future.oldOptions$nwarnings <- NULL
[16:06:15.322]             }
[16:06:15.322]             base::options(...future.oldOptions)
[16:06:15.322]             if (.Platform$OS.type == "windows") {
[16:06:15.322]                 old_names <- names(...future.oldEnvVars)
[16:06:15.322]                 envs <- base::Sys.getenv()
[16:06:15.322]                 names <- names(envs)
[16:06:15.322]                 common <- intersect(names, old_names)
[16:06:15.322]                 added <- setdiff(names, old_names)
[16:06:15.322]                 removed <- setdiff(old_names, names)
[16:06:15.322]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:15.322]                   envs[common]]
[16:06:15.322]                 NAMES <- toupper(changed)
[16:06:15.322]                 args <- list()
[16:06:15.322]                 for (kk in seq_along(NAMES)) {
[16:06:15.322]                   name <- changed[[kk]]
[16:06:15.322]                   NAME <- NAMES[[kk]]
[16:06:15.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.322]                     next
[16:06:15.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.322]                 }
[16:06:15.322]                 NAMES <- toupper(added)
[16:06:15.322]                 for (kk in seq_along(NAMES)) {
[16:06:15.322]                   name <- added[[kk]]
[16:06:15.322]                   NAME <- NAMES[[kk]]
[16:06:15.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.322]                     next
[16:06:15.322]                   args[[name]] <- ""
[16:06:15.322]                 }
[16:06:15.322]                 NAMES <- toupper(removed)
[16:06:15.322]                 for (kk in seq_along(NAMES)) {
[16:06:15.322]                   name <- removed[[kk]]
[16:06:15.322]                   NAME <- NAMES[[kk]]
[16:06:15.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.322]                     next
[16:06:15.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.322]                 }
[16:06:15.322]                 if (length(args) > 0) 
[16:06:15.322]                   base::do.call(base::Sys.setenv, args = args)
[16:06:15.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:15.322]             }
[16:06:15.322]             else {
[16:06:15.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:15.322]             }
[16:06:15.322]             {
[16:06:15.322]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:15.322]                   0L) {
[16:06:15.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:15.322]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:15.322]                   base::options(opts)
[16:06:15.322]                 }
[16:06:15.322]                 {
[16:06:15.322]                   {
[16:06:15.322]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:15.322]                     NULL
[16:06:15.322]                   }
[16:06:15.322]                   options(future.plan = NULL)
[16:06:15.322]                   if (is.na(NA_character_)) 
[16:06:15.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:15.322]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:15.322]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:15.322]                     envir = parent.frame()) 
[16:06:15.322]                   {
[16:06:15.322]                     if (is.function(workers)) 
[16:06:15.322]                       workers <- workers()
[16:06:15.322]                     workers <- structure(as.integer(workers), 
[16:06:15.322]                       class = class(workers))
[16:06:15.322]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:15.322]                       workers >= 1)
[16:06:15.322]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:15.322]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:15.322]                     }
[16:06:15.322]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:15.322]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:15.322]                       envir = envir)
[16:06:15.322]                     if (!future$lazy) 
[16:06:15.322]                       future <- run(future)
[16:06:15.322]                     invisible(future)
[16:06:15.322]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:15.322]                 }
[16:06:15.322]             }
[16:06:15.322]         }
[16:06:15.322]     })
[16:06:15.322]     if (TRUE) {
[16:06:15.322]         base::sink(type = "output", split = FALSE)
[16:06:15.322]         if (TRUE) {
[16:06:15.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:15.322]         }
[16:06:15.322]         else {
[16:06:15.322]             ...future.result["stdout"] <- base::list(NULL)
[16:06:15.322]         }
[16:06:15.322]         base::close(...future.stdout)
[16:06:15.322]         ...future.stdout <- NULL
[16:06:15.322]     }
[16:06:15.322]     ...future.result$conditions <- ...future.conditions
[16:06:15.322]     ...future.result$finished <- base::Sys.time()
[16:06:15.322]     ...future.result
[16:06:15.322] }
[16:06:15.325] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:06:15.325] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:06:15.325] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:06:15.325] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:06:15.326] MultisessionFuture started
[16:06:15.326] - Launch lazy future ... done
[16:06:15.326] run() for ‘MultisessionFuture’ ... done
[16:06:15.326] getGlobalsAndPackages() ...
[16:06:15.326] Searching for globals...
[16:06:15.327] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:06:15.327] Searching for globals ... DONE
[16:06:15.327] Resolving globals: FALSE
[16:06:15.328] The total size of the 1 globals is 56 bytes (56 bytes)
[16:06:15.328] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:06:15.328] - globals: [1] ‘kk’
[16:06:15.328] 
[16:06:15.328] getGlobalsAndPackages() ... DONE
[16:06:15.328] run() for ‘Future’ ...
[16:06:15.329] - state: ‘created’
[16:06:15.329] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:15.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:15.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:15.349]   - Field: ‘node’
[16:06:15.349]   - Field: ‘label’
[16:06:15.349]   - Field: ‘local’
[16:06:15.349]   - Field: ‘owner’
[16:06:15.349]   - Field: ‘envir’
[16:06:15.350]   - Field: ‘workers’
[16:06:15.350]   - Field: ‘packages’
[16:06:15.350]   - Field: ‘gc’
[16:06:15.350]   - Field: ‘conditions’
[16:06:15.350]   - Field: ‘persistent’
[16:06:15.350]   - Field: ‘expr’
[16:06:15.350]   - Field: ‘uuid’
[16:06:15.350]   - Field: ‘seed’
[16:06:15.350]   - Field: ‘version’
[16:06:15.350]   - Field: ‘result’
[16:06:15.350]   - Field: ‘asynchronous’
[16:06:15.351]   - Field: ‘calls’
[16:06:15.351]   - Field: ‘globals’
[16:06:15.351]   - Field: ‘stdout’
[16:06:15.351]   - Field: ‘earlySignal’
[16:06:15.351]   - Field: ‘lazy’
[16:06:15.351]   - Field: ‘state’
[16:06:15.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:15.351] - Launch lazy future ...
[16:06:15.351] Packages needed by the future expression (n = 0): <none>
[16:06:15.352] Packages needed by future strategies (n = 0): <none>
[16:06:15.352] {
[16:06:15.352]     {
[16:06:15.352]         {
[16:06:15.352]             ...future.startTime <- base::Sys.time()
[16:06:15.352]             {
[16:06:15.352]                 {
[16:06:15.352]                   {
[16:06:15.352]                     {
[16:06:15.352]                       base::local({
[16:06:15.352]                         has_future <- base::requireNamespace("future", 
[16:06:15.352]                           quietly = TRUE)
[16:06:15.352]                         if (has_future) {
[16:06:15.352]                           ns <- base::getNamespace("future")
[16:06:15.352]                           version <- ns[[".package"]][["version"]]
[16:06:15.352]                           if (is.null(version)) 
[16:06:15.352]                             version <- utils::packageVersion("future")
[16:06:15.352]                         }
[16:06:15.352]                         else {
[16:06:15.352]                           version <- NULL
[16:06:15.352]                         }
[16:06:15.352]                         if (!has_future || version < "1.8.0") {
[16:06:15.352]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:15.352]                             "", base::R.version$version.string), 
[16:06:15.352]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:15.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:15.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:15.352]                               "release", "version")], collapse = " "), 
[16:06:15.352]                             hostname = base::Sys.info()[["nodename"]])
[16:06:15.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:15.352]                             info)
[16:06:15.352]                           info <- base::paste(info, collapse = "; ")
[16:06:15.352]                           if (!has_future) {
[16:06:15.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:15.352]                               info)
[16:06:15.352]                           }
[16:06:15.352]                           else {
[16:06:15.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:15.352]                               info, version)
[16:06:15.352]                           }
[16:06:15.352]                           base::stop(msg)
[16:06:15.352]                         }
[16:06:15.352]                       })
[16:06:15.352]                     }
[16:06:15.352]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:15.352]                     base::options(mc.cores = 1L)
[16:06:15.352]                   }
[16:06:15.352]                   options(future.plan = NULL)
[16:06:15.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:15.352]                 }
[16:06:15.352]                 ...future.workdir <- getwd()
[16:06:15.352]             }
[16:06:15.352]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:15.352]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:15.352]         }
[16:06:15.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:15.352]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:15.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:15.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:15.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:15.352]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:15.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:15.352]             base::names(...future.oldOptions))
[16:06:15.352]     }
[16:06:15.352]     if (FALSE) {
[16:06:15.352]     }
[16:06:15.352]     else {
[16:06:15.352]         if (TRUE) {
[16:06:15.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:15.352]                 open = "w")
[16:06:15.352]         }
[16:06:15.352]         else {
[16:06:15.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:15.352]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:15.352]         }
[16:06:15.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:15.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:15.352]             base::sink(type = "output", split = FALSE)
[16:06:15.352]             base::close(...future.stdout)
[16:06:15.352]         }, add = TRUE)
[16:06:15.352]     }
[16:06:15.352]     ...future.frame <- base::sys.nframe()
[16:06:15.352]     ...future.conditions <- base::list()
[16:06:15.352]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:15.352]     if (FALSE) {
[16:06:15.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:15.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:15.352]     }
[16:06:15.352]     ...future.result <- base::tryCatch({
[16:06:15.352]         base::withCallingHandlers({
[16:06:15.352]             ...future.value <- base::withVisible(base::local({
[16:06:15.352]                 ...future.makeSendCondition <- base::local({
[16:06:15.352]                   sendCondition <- NULL
[16:06:15.352]                   function(frame = 1L) {
[16:06:15.352]                     if (is.function(sendCondition)) 
[16:06:15.352]                       return(sendCondition)
[16:06:15.352]                     ns <- getNamespace("parallel")
[16:06:15.352]                     if (exists("sendData", mode = "function", 
[16:06:15.352]                       envir = ns)) {
[16:06:15.352]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:15.352]                         envir = ns)
[16:06:15.352]                       envir <- sys.frame(frame)
[16:06:15.352]                       master <- NULL
[16:06:15.352]                       while (!identical(envir, .GlobalEnv) && 
[16:06:15.352]                         !identical(envir, emptyenv())) {
[16:06:15.352]                         if (exists("master", mode = "list", envir = envir, 
[16:06:15.352]                           inherits = FALSE)) {
[16:06:15.352]                           master <- get("master", mode = "list", 
[16:06:15.352]                             envir = envir, inherits = FALSE)
[16:06:15.352]                           if (inherits(master, c("SOCKnode", 
[16:06:15.352]                             "SOCK0node"))) {
[16:06:15.352]                             sendCondition <<- function(cond) {
[16:06:15.352]                               data <- list(type = "VALUE", value = cond, 
[16:06:15.352]                                 success = TRUE)
[16:06:15.352]                               parallel_sendData(master, data)
[16:06:15.352]                             }
[16:06:15.352]                             return(sendCondition)
[16:06:15.352]                           }
[16:06:15.352]                         }
[16:06:15.352]                         frame <- frame + 1L
[16:06:15.352]                         envir <- sys.frame(frame)
[16:06:15.352]                       }
[16:06:15.352]                     }
[16:06:15.352]                     sendCondition <<- function(cond) NULL
[16:06:15.352]                   }
[16:06:15.352]                 })
[16:06:15.352]                 withCallingHandlers({
[16:06:15.352]                   {
[16:06:15.352]                     Sys.sleep(0.1)
[16:06:15.352]                     kk
[16:06:15.352]                   }
[16:06:15.352]                 }, immediateCondition = function(cond) {
[16:06:15.352]                   sendCondition <- ...future.makeSendCondition()
[16:06:15.352]                   sendCondition(cond)
[16:06:15.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.352]                   {
[16:06:15.352]                     inherits <- base::inherits
[16:06:15.352]                     invokeRestart <- base::invokeRestart
[16:06:15.352]                     is.null <- base::is.null
[16:06:15.352]                     muffled <- FALSE
[16:06:15.352]                     if (inherits(cond, "message")) {
[16:06:15.352]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:15.352]                       if (muffled) 
[16:06:15.352]                         invokeRestart("muffleMessage")
[16:06:15.352]                     }
[16:06:15.352]                     else if (inherits(cond, "warning")) {
[16:06:15.352]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:15.352]                       if (muffled) 
[16:06:15.352]                         invokeRestart("muffleWarning")
[16:06:15.352]                     }
[16:06:15.352]                     else if (inherits(cond, "condition")) {
[16:06:15.352]                       if (!is.null(pattern)) {
[16:06:15.352]                         computeRestarts <- base::computeRestarts
[16:06:15.352]                         grepl <- base::grepl
[16:06:15.352]                         restarts <- computeRestarts(cond)
[16:06:15.352]                         for (restart in restarts) {
[16:06:15.352]                           name <- restart$name
[16:06:15.352]                           if (is.null(name)) 
[16:06:15.352]                             next
[16:06:15.352]                           if (!grepl(pattern, name)) 
[16:06:15.352]                             next
[16:06:15.352]                           invokeRestart(restart)
[16:06:15.352]                           muffled <- TRUE
[16:06:15.352]                           break
[16:06:15.352]                         }
[16:06:15.352]                       }
[16:06:15.352]                     }
[16:06:15.352]                     invisible(muffled)
[16:06:15.352]                   }
[16:06:15.352]                   muffleCondition(cond)
[16:06:15.352]                 })
[16:06:15.352]             }))
[16:06:15.352]             future::FutureResult(value = ...future.value$value, 
[16:06:15.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.352]                   ...future.rng), globalenv = if (FALSE) 
[16:06:15.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:15.352]                     ...future.globalenv.names))
[16:06:15.352]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:15.352]         }, condition = base::local({
[16:06:15.352]             c <- base::c
[16:06:15.352]             inherits <- base::inherits
[16:06:15.352]             invokeRestart <- base::invokeRestart
[16:06:15.352]             length <- base::length
[16:06:15.352]             list <- base::list
[16:06:15.352]             seq.int <- base::seq.int
[16:06:15.352]             signalCondition <- base::signalCondition
[16:06:15.352]             sys.calls <- base::sys.calls
[16:06:15.352]             `[[` <- base::`[[`
[16:06:15.352]             `+` <- base::`+`
[16:06:15.352]             `<<-` <- base::`<<-`
[16:06:15.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:15.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:15.352]                   3L)]
[16:06:15.352]             }
[16:06:15.352]             function(cond) {
[16:06:15.352]                 is_error <- inherits(cond, "error")
[16:06:15.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:15.352]                   NULL)
[16:06:15.352]                 if (is_error) {
[16:06:15.352]                   sessionInformation <- function() {
[16:06:15.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:15.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:15.352]                       search = base::search(), system = base::Sys.info())
[16:06:15.352]                   }
[16:06:15.352]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:15.352]                     cond$call), session = sessionInformation(), 
[16:06:15.352]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:15.352]                   signalCondition(cond)
[16:06:15.352]                 }
[16:06:15.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:15.352]                 "immediateCondition"))) {
[16:06:15.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:15.352]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:15.352]                   if (TRUE && !signal) {
[16:06:15.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.352]                     {
[16:06:15.352]                       inherits <- base::inherits
[16:06:15.352]                       invokeRestart <- base::invokeRestart
[16:06:15.352]                       is.null <- base::is.null
[16:06:15.352]                       muffled <- FALSE
[16:06:15.352]                       if (inherits(cond, "message")) {
[16:06:15.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.352]                         if (muffled) 
[16:06:15.352]                           invokeRestart("muffleMessage")
[16:06:15.352]                       }
[16:06:15.352]                       else if (inherits(cond, "warning")) {
[16:06:15.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.352]                         if (muffled) 
[16:06:15.352]                           invokeRestart("muffleWarning")
[16:06:15.352]                       }
[16:06:15.352]                       else if (inherits(cond, "condition")) {
[16:06:15.352]                         if (!is.null(pattern)) {
[16:06:15.352]                           computeRestarts <- base::computeRestarts
[16:06:15.352]                           grepl <- base::grepl
[16:06:15.352]                           restarts <- computeRestarts(cond)
[16:06:15.352]                           for (restart in restarts) {
[16:06:15.352]                             name <- restart$name
[16:06:15.352]                             if (is.null(name)) 
[16:06:15.352]                               next
[16:06:15.352]                             if (!grepl(pattern, name)) 
[16:06:15.352]                               next
[16:06:15.352]                             invokeRestart(restart)
[16:06:15.352]                             muffled <- TRUE
[16:06:15.352]                             break
[16:06:15.352]                           }
[16:06:15.352]                         }
[16:06:15.352]                       }
[16:06:15.352]                       invisible(muffled)
[16:06:15.352]                     }
[16:06:15.352]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.352]                   }
[16:06:15.352]                 }
[16:06:15.352]                 else {
[16:06:15.352]                   if (TRUE) {
[16:06:15.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.352]                     {
[16:06:15.352]                       inherits <- base::inherits
[16:06:15.352]                       invokeRestart <- base::invokeRestart
[16:06:15.352]                       is.null <- base::is.null
[16:06:15.352]                       muffled <- FALSE
[16:06:15.352]                       if (inherits(cond, "message")) {
[16:06:15.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.352]                         if (muffled) 
[16:06:15.352]                           invokeRestart("muffleMessage")
[16:06:15.352]                       }
[16:06:15.352]                       else if (inherits(cond, "warning")) {
[16:06:15.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.352]                         if (muffled) 
[16:06:15.352]                           invokeRestart("muffleWarning")
[16:06:15.352]                       }
[16:06:15.352]                       else if (inherits(cond, "condition")) {
[16:06:15.352]                         if (!is.null(pattern)) {
[16:06:15.352]                           computeRestarts <- base::computeRestarts
[16:06:15.352]                           grepl <- base::grepl
[16:06:15.352]                           restarts <- computeRestarts(cond)
[16:06:15.352]                           for (restart in restarts) {
[16:06:15.352]                             name <- restart$name
[16:06:15.352]                             if (is.null(name)) 
[16:06:15.352]                               next
[16:06:15.352]                             if (!grepl(pattern, name)) 
[16:06:15.352]                               next
[16:06:15.352]                             invokeRestart(restart)
[16:06:15.352]                             muffled <- TRUE
[16:06:15.352]                             break
[16:06:15.352]                           }
[16:06:15.352]                         }
[16:06:15.352]                       }
[16:06:15.352]                       invisible(muffled)
[16:06:15.352]                     }
[16:06:15.352]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.352]                   }
[16:06:15.352]                 }
[16:06:15.352]             }
[16:06:15.352]         }))
[16:06:15.352]     }, error = function(ex) {
[16:06:15.352]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:15.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.352]                 ...future.rng), started = ...future.startTime, 
[16:06:15.352]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:15.352]             version = "1.8"), class = "FutureResult")
[16:06:15.352]     }, finally = {
[16:06:15.352]         if (!identical(...future.workdir, getwd())) 
[16:06:15.352]             setwd(...future.workdir)
[16:06:15.352]         {
[16:06:15.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:15.352]                 ...future.oldOptions$nwarnings <- NULL
[16:06:15.352]             }
[16:06:15.352]             base::options(...future.oldOptions)
[16:06:15.352]             if (.Platform$OS.type == "windows") {
[16:06:15.352]                 old_names <- names(...future.oldEnvVars)
[16:06:15.352]                 envs <- base::Sys.getenv()
[16:06:15.352]                 names <- names(envs)
[16:06:15.352]                 common <- intersect(names, old_names)
[16:06:15.352]                 added <- setdiff(names, old_names)
[16:06:15.352]                 removed <- setdiff(old_names, names)
[16:06:15.352]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:15.352]                   envs[common]]
[16:06:15.352]                 NAMES <- toupper(changed)
[16:06:15.352]                 args <- list()
[16:06:15.352]                 for (kk in seq_along(NAMES)) {
[16:06:15.352]                   name <- changed[[kk]]
[16:06:15.352]                   NAME <- NAMES[[kk]]
[16:06:15.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.352]                     next
[16:06:15.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.352]                 }
[16:06:15.352]                 NAMES <- toupper(added)
[16:06:15.352]                 for (kk in seq_along(NAMES)) {
[16:06:15.352]                   name <- added[[kk]]
[16:06:15.352]                   NAME <- NAMES[[kk]]
[16:06:15.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.352]                     next
[16:06:15.352]                   args[[name]] <- ""
[16:06:15.352]                 }
[16:06:15.352]                 NAMES <- toupper(removed)
[16:06:15.352]                 for (kk in seq_along(NAMES)) {
[16:06:15.352]                   name <- removed[[kk]]
[16:06:15.352]                   NAME <- NAMES[[kk]]
[16:06:15.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.352]                     next
[16:06:15.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.352]                 }
[16:06:15.352]                 if (length(args) > 0) 
[16:06:15.352]                   base::do.call(base::Sys.setenv, args = args)
[16:06:15.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:15.352]             }
[16:06:15.352]             else {
[16:06:15.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:15.352]             }
[16:06:15.352]             {
[16:06:15.352]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:15.352]                   0L) {
[16:06:15.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:15.352]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:15.352]                   base::options(opts)
[16:06:15.352]                 }
[16:06:15.352]                 {
[16:06:15.352]                   {
[16:06:15.352]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:15.352]                     NULL
[16:06:15.352]                   }
[16:06:15.352]                   options(future.plan = NULL)
[16:06:15.352]                   if (is.na(NA_character_)) 
[16:06:15.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:15.352]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:15.352]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:15.352]                     envir = parent.frame()) 
[16:06:15.352]                   {
[16:06:15.352]                     if (is.function(workers)) 
[16:06:15.352]                       workers <- workers()
[16:06:15.352]                     workers <- structure(as.integer(workers), 
[16:06:15.352]                       class = class(workers))
[16:06:15.352]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:15.352]                       workers >= 1)
[16:06:15.352]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:15.352]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:15.352]                     }
[16:06:15.352]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:15.352]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:15.352]                       envir = envir)
[16:06:15.352]                     if (!future$lazy) 
[16:06:15.352]                       future <- run(future)
[16:06:15.352]                     invisible(future)
[16:06:15.352]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:15.352]                 }
[16:06:15.352]             }
[16:06:15.352]         }
[16:06:15.352]     })
[16:06:15.352]     if (TRUE) {
[16:06:15.352]         base::sink(type = "output", split = FALSE)
[16:06:15.352]         if (TRUE) {
[16:06:15.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:15.352]         }
[16:06:15.352]         else {
[16:06:15.352]             ...future.result["stdout"] <- base::list(NULL)
[16:06:15.352]         }
[16:06:15.352]         base::close(...future.stdout)
[16:06:15.352]         ...future.stdout <- NULL
[16:06:15.352]     }
[16:06:15.352]     ...future.result$conditions <- ...future.conditions
[16:06:15.352]     ...future.result$finished <- base::Sys.time()
[16:06:15.352]     ...future.result
[16:06:15.352] }
[16:06:15.355] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:06:15.355] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[16:06:15.355] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[16:06:15.355] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:06:15.356] MultisessionFuture started
[16:06:15.356] - Launch lazy future ... done
[16:06:15.356] run() for ‘MultisessionFuture’ ... done
[16:06:15.356] getGlobalsAndPackages() ...
[16:06:15.356] Searching for globals...
[16:06:15.357] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:06:15.357] Searching for globals ... DONE
[16:06:15.358] Resolving globals: FALSE
[16:06:15.358] The total size of the 1 globals is 56 bytes (56 bytes)
[16:06:15.358] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:06:15.358] - globals: [1] ‘kk’
[16:06:15.358] 
[16:06:15.359] getGlobalsAndPackages() ... DONE
[16:06:15.359] run() for ‘Future’ ...
[16:06:15.359] - state: ‘created’
[16:06:15.359] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:15.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:15.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:15.373]   - Field: ‘node’
[16:06:15.373]   - Field: ‘label’
[16:06:15.373]   - Field: ‘local’
[16:06:15.373]   - Field: ‘owner’
[16:06:15.373]   - Field: ‘envir’
[16:06:15.373]   - Field: ‘workers’
[16:06:15.373]   - Field: ‘packages’
[16:06:15.373]   - Field: ‘gc’
[16:06:15.373]   - Field: ‘conditions’
[16:06:15.373]   - Field: ‘persistent’
[16:06:15.373]   - Field: ‘expr’
[16:06:15.374]   - Field: ‘uuid’
[16:06:15.374]   - Field: ‘seed’
[16:06:15.374]   - Field: ‘version’
[16:06:15.374]   - Field: ‘result’
[16:06:15.374]   - Field: ‘asynchronous’
[16:06:15.374]   - Field: ‘calls’
[16:06:15.374]   - Field: ‘globals’
[16:06:15.374]   - Field: ‘stdout’
[16:06:15.374]   - Field: ‘earlySignal’
[16:06:15.374]   - Field: ‘lazy’
[16:06:15.374]   - Field: ‘state’
[16:06:15.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:15.375] - Launch lazy future ...
[16:06:15.375] Packages needed by the future expression (n = 0): <none>
[16:06:15.375] Packages needed by future strategies (n = 0): <none>
[16:06:15.375] {
[16:06:15.375]     {
[16:06:15.375]         {
[16:06:15.375]             ...future.startTime <- base::Sys.time()
[16:06:15.375]             {
[16:06:15.375]                 {
[16:06:15.375]                   {
[16:06:15.375]                     {
[16:06:15.375]                       base::local({
[16:06:15.375]                         has_future <- base::requireNamespace("future", 
[16:06:15.375]                           quietly = TRUE)
[16:06:15.375]                         if (has_future) {
[16:06:15.375]                           ns <- base::getNamespace("future")
[16:06:15.375]                           version <- ns[[".package"]][["version"]]
[16:06:15.375]                           if (is.null(version)) 
[16:06:15.375]                             version <- utils::packageVersion("future")
[16:06:15.375]                         }
[16:06:15.375]                         else {
[16:06:15.375]                           version <- NULL
[16:06:15.375]                         }
[16:06:15.375]                         if (!has_future || version < "1.8.0") {
[16:06:15.375]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:15.375]                             "", base::R.version$version.string), 
[16:06:15.375]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:15.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:15.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:15.375]                               "release", "version")], collapse = " "), 
[16:06:15.375]                             hostname = base::Sys.info()[["nodename"]])
[16:06:15.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:15.375]                             info)
[16:06:15.375]                           info <- base::paste(info, collapse = "; ")
[16:06:15.375]                           if (!has_future) {
[16:06:15.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:15.375]                               info)
[16:06:15.375]                           }
[16:06:15.375]                           else {
[16:06:15.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:15.375]                               info, version)
[16:06:15.375]                           }
[16:06:15.375]                           base::stop(msg)
[16:06:15.375]                         }
[16:06:15.375]                       })
[16:06:15.375]                     }
[16:06:15.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:15.375]                     base::options(mc.cores = 1L)
[16:06:15.375]                   }
[16:06:15.375]                   options(future.plan = NULL)
[16:06:15.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:15.375]                 }
[16:06:15.375]                 ...future.workdir <- getwd()
[16:06:15.375]             }
[16:06:15.375]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:15.375]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:15.375]         }
[16:06:15.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:15.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:15.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:15.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:15.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:15.375]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:15.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:15.375]             base::names(...future.oldOptions))
[16:06:15.375]     }
[16:06:15.375]     if (FALSE) {
[16:06:15.375]     }
[16:06:15.375]     else {
[16:06:15.375]         if (TRUE) {
[16:06:15.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:15.375]                 open = "w")
[16:06:15.375]         }
[16:06:15.375]         else {
[16:06:15.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:15.375]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:15.375]         }
[16:06:15.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:15.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:15.375]             base::sink(type = "output", split = FALSE)
[16:06:15.375]             base::close(...future.stdout)
[16:06:15.375]         }, add = TRUE)
[16:06:15.375]     }
[16:06:15.375]     ...future.frame <- base::sys.nframe()
[16:06:15.375]     ...future.conditions <- base::list()
[16:06:15.375]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:15.375]     if (FALSE) {
[16:06:15.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:15.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:15.375]     }
[16:06:15.375]     ...future.result <- base::tryCatch({
[16:06:15.375]         base::withCallingHandlers({
[16:06:15.375]             ...future.value <- base::withVisible(base::local({
[16:06:15.375]                 ...future.makeSendCondition <- base::local({
[16:06:15.375]                   sendCondition <- NULL
[16:06:15.375]                   function(frame = 1L) {
[16:06:15.375]                     if (is.function(sendCondition)) 
[16:06:15.375]                       return(sendCondition)
[16:06:15.375]                     ns <- getNamespace("parallel")
[16:06:15.375]                     if (exists("sendData", mode = "function", 
[16:06:15.375]                       envir = ns)) {
[16:06:15.375]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:15.375]                         envir = ns)
[16:06:15.375]                       envir <- sys.frame(frame)
[16:06:15.375]                       master <- NULL
[16:06:15.375]                       while (!identical(envir, .GlobalEnv) && 
[16:06:15.375]                         !identical(envir, emptyenv())) {
[16:06:15.375]                         if (exists("master", mode = "list", envir = envir, 
[16:06:15.375]                           inherits = FALSE)) {
[16:06:15.375]                           master <- get("master", mode = "list", 
[16:06:15.375]                             envir = envir, inherits = FALSE)
[16:06:15.375]                           if (inherits(master, c("SOCKnode", 
[16:06:15.375]                             "SOCK0node"))) {
[16:06:15.375]                             sendCondition <<- function(cond) {
[16:06:15.375]                               data <- list(type = "VALUE", value = cond, 
[16:06:15.375]                                 success = TRUE)
[16:06:15.375]                               parallel_sendData(master, data)
[16:06:15.375]                             }
[16:06:15.375]                             return(sendCondition)
[16:06:15.375]                           }
[16:06:15.375]                         }
[16:06:15.375]                         frame <- frame + 1L
[16:06:15.375]                         envir <- sys.frame(frame)
[16:06:15.375]                       }
[16:06:15.375]                     }
[16:06:15.375]                     sendCondition <<- function(cond) NULL
[16:06:15.375]                   }
[16:06:15.375]                 })
[16:06:15.375]                 withCallingHandlers({
[16:06:15.375]                   {
[16:06:15.375]                     Sys.sleep(0.1)
[16:06:15.375]                     kk
[16:06:15.375]                   }
[16:06:15.375]                 }, immediateCondition = function(cond) {
[16:06:15.375]                   sendCondition <- ...future.makeSendCondition()
[16:06:15.375]                   sendCondition(cond)
[16:06:15.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.375]                   {
[16:06:15.375]                     inherits <- base::inherits
[16:06:15.375]                     invokeRestart <- base::invokeRestart
[16:06:15.375]                     is.null <- base::is.null
[16:06:15.375]                     muffled <- FALSE
[16:06:15.375]                     if (inherits(cond, "message")) {
[16:06:15.375]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:15.375]                       if (muffled) 
[16:06:15.375]                         invokeRestart("muffleMessage")
[16:06:15.375]                     }
[16:06:15.375]                     else if (inherits(cond, "warning")) {
[16:06:15.375]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:15.375]                       if (muffled) 
[16:06:15.375]                         invokeRestart("muffleWarning")
[16:06:15.375]                     }
[16:06:15.375]                     else if (inherits(cond, "condition")) {
[16:06:15.375]                       if (!is.null(pattern)) {
[16:06:15.375]                         computeRestarts <- base::computeRestarts
[16:06:15.375]                         grepl <- base::grepl
[16:06:15.375]                         restarts <- computeRestarts(cond)
[16:06:15.375]                         for (restart in restarts) {
[16:06:15.375]                           name <- restart$name
[16:06:15.375]                           if (is.null(name)) 
[16:06:15.375]                             next
[16:06:15.375]                           if (!grepl(pattern, name)) 
[16:06:15.375]                             next
[16:06:15.375]                           invokeRestart(restart)
[16:06:15.375]                           muffled <- TRUE
[16:06:15.375]                           break
[16:06:15.375]                         }
[16:06:15.375]                       }
[16:06:15.375]                     }
[16:06:15.375]                     invisible(muffled)
[16:06:15.375]                   }
[16:06:15.375]                   muffleCondition(cond)
[16:06:15.375]                 })
[16:06:15.375]             }))
[16:06:15.375]             future::FutureResult(value = ...future.value$value, 
[16:06:15.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.375]                   ...future.rng), globalenv = if (FALSE) 
[16:06:15.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:15.375]                     ...future.globalenv.names))
[16:06:15.375]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:15.375]         }, condition = base::local({
[16:06:15.375]             c <- base::c
[16:06:15.375]             inherits <- base::inherits
[16:06:15.375]             invokeRestart <- base::invokeRestart
[16:06:15.375]             length <- base::length
[16:06:15.375]             list <- base::list
[16:06:15.375]             seq.int <- base::seq.int
[16:06:15.375]             signalCondition <- base::signalCondition
[16:06:15.375]             sys.calls <- base::sys.calls
[16:06:15.375]             `[[` <- base::`[[`
[16:06:15.375]             `+` <- base::`+`
[16:06:15.375]             `<<-` <- base::`<<-`
[16:06:15.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:15.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:15.375]                   3L)]
[16:06:15.375]             }
[16:06:15.375]             function(cond) {
[16:06:15.375]                 is_error <- inherits(cond, "error")
[16:06:15.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:15.375]                   NULL)
[16:06:15.375]                 if (is_error) {
[16:06:15.375]                   sessionInformation <- function() {
[16:06:15.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:15.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:15.375]                       search = base::search(), system = base::Sys.info())
[16:06:15.375]                   }
[16:06:15.375]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:15.375]                     cond$call), session = sessionInformation(), 
[16:06:15.375]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:15.375]                   signalCondition(cond)
[16:06:15.375]                 }
[16:06:15.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:15.375]                 "immediateCondition"))) {
[16:06:15.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:15.375]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:15.375]                   if (TRUE && !signal) {
[16:06:15.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.375]                     {
[16:06:15.375]                       inherits <- base::inherits
[16:06:15.375]                       invokeRestart <- base::invokeRestart
[16:06:15.375]                       is.null <- base::is.null
[16:06:15.375]                       muffled <- FALSE
[16:06:15.375]                       if (inherits(cond, "message")) {
[16:06:15.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.375]                         if (muffled) 
[16:06:15.375]                           invokeRestart("muffleMessage")
[16:06:15.375]                       }
[16:06:15.375]                       else if (inherits(cond, "warning")) {
[16:06:15.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.375]                         if (muffled) 
[16:06:15.375]                           invokeRestart("muffleWarning")
[16:06:15.375]                       }
[16:06:15.375]                       else if (inherits(cond, "condition")) {
[16:06:15.375]                         if (!is.null(pattern)) {
[16:06:15.375]                           computeRestarts <- base::computeRestarts
[16:06:15.375]                           grepl <- base::grepl
[16:06:15.375]                           restarts <- computeRestarts(cond)
[16:06:15.375]                           for (restart in restarts) {
[16:06:15.375]                             name <- restart$name
[16:06:15.375]                             if (is.null(name)) 
[16:06:15.375]                               next
[16:06:15.375]                             if (!grepl(pattern, name)) 
[16:06:15.375]                               next
[16:06:15.375]                             invokeRestart(restart)
[16:06:15.375]                             muffled <- TRUE
[16:06:15.375]                             break
[16:06:15.375]                           }
[16:06:15.375]                         }
[16:06:15.375]                       }
[16:06:15.375]                       invisible(muffled)
[16:06:15.375]                     }
[16:06:15.375]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.375]                   }
[16:06:15.375]                 }
[16:06:15.375]                 else {
[16:06:15.375]                   if (TRUE) {
[16:06:15.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.375]                     {
[16:06:15.375]                       inherits <- base::inherits
[16:06:15.375]                       invokeRestart <- base::invokeRestart
[16:06:15.375]                       is.null <- base::is.null
[16:06:15.375]                       muffled <- FALSE
[16:06:15.375]                       if (inherits(cond, "message")) {
[16:06:15.375]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.375]                         if (muffled) 
[16:06:15.375]                           invokeRestart("muffleMessage")
[16:06:15.375]                       }
[16:06:15.375]                       else if (inherits(cond, "warning")) {
[16:06:15.375]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.375]                         if (muffled) 
[16:06:15.375]                           invokeRestart("muffleWarning")
[16:06:15.375]                       }
[16:06:15.375]                       else if (inherits(cond, "condition")) {
[16:06:15.375]                         if (!is.null(pattern)) {
[16:06:15.375]                           computeRestarts <- base::computeRestarts
[16:06:15.375]                           grepl <- base::grepl
[16:06:15.375]                           restarts <- computeRestarts(cond)
[16:06:15.375]                           for (restart in restarts) {
[16:06:15.375]                             name <- restart$name
[16:06:15.375]                             if (is.null(name)) 
[16:06:15.375]                               next
[16:06:15.375]                             if (!grepl(pattern, name)) 
[16:06:15.375]                               next
[16:06:15.375]                             invokeRestart(restart)
[16:06:15.375]                             muffled <- TRUE
[16:06:15.375]                             break
[16:06:15.375]                           }
[16:06:15.375]                         }
[16:06:15.375]                       }
[16:06:15.375]                       invisible(muffled)
[16:06:15.375]                     }
[16:06:15.375]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.375]                   }
[16:06:15.375]                 }
[16:06:15.375]             }
[16:06:15.375]         }))
[16:06:15.375]     }, error = function(ex) {
[16:06:15.375]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:15.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.375]                 ...future.rng), started = ...future.startTime, 
[16:06:15.375]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:15.375]             version = "1.8"), class = "FutureResult")
[16:06:15.375]     }, finally = {
[16:06:15.375]         if (!identical(...future.workdir, getwd())) 
[16:06:15.375]             setwd(...future.workdir)
[16:06:15.375]         {
[16:06:15.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:15.375]                 ...future.oldOptions$nwarnings <- NULL
[16:06:15.375]             }
[16:06:15.375]             base::options(...future.oldOptions)
[16:06:15.375]             if (.Platform$OS.type == "windows") {
[16:06:15.375]                 old_names <- names(...future.oldEnvVars)
[16:06:15.375]                 envs <- base::Sys.getenv()
[16:06:15.375]                 names <- names(envs)
[16:06:15.375]                 common <- intersect(names, old_names)
[16:06:15.375]                 added <- setdiff(names, old_names)
[16:06:15.375]                 removed <- setdiff(old_names, names)
[16:06:15.375]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:15.375]                   envs[common]]
[16:06:15.375]                 NAMES <- toupper(changed)
[16:06:15.375]                 args <- list()
[16:06:15.375]                 for (kk in seq_along(NAMES)) {
[16:06:15.375]                   name <- changed[[kk]]
[16:06:15.375]                   NAME <- NAMES[[kk]]
[16:06:15.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.375]                     next
[16:06:15.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.375]                 }
[16:06:15.375]                 NAMES <- toupper(added)
[16:06:15.375]                 for (kk in seq_along(NAMES)) {
[16:06:15.375]                   name <- added[[kk]]
[16:06:15.375]                   NAME <- NAMES[[kk]]
[16:06:15.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.375]                     next
[16:06:15.375]                   args[[name]] <- ""
[16:06:15.375]                 }
[16:06:15.375]                 NAMES <- toupper(removed)
[16:06:15.375]                 for (kk in seq_along(NAMES)) {
[16:06:15.375]                   name <- removed[[kk]]
[16:06:15.375]                   NAME <- NAMES[[kk]]
[16:06:15.375]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.375]                     next
[16:06:15.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.375]                 }
[16:06:15.375]                 if (length(args) > 0) 
[16:06:15.375]                   base::do.call(base::Sys.setenv, args = args)
[16:06:15.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:15.375]             }
[16:06:15.375]             else {
[16:06:15.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:15.375]             }
[16:06:15.375]             {
[16:06:15.375]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:15.375]                   0L) {
[16:06:15.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:15.375]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:15.375]                   base::options(opts)
[16:06:15.375]                 }
[16:06:15.375]                 {
[16:06:15.375]                   {
[16:06:15.375]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:15.375]                     NULL
[16:06:15.375]                   }
[16:06:15.375]                   options(future.plan = NULL)
[16:06:15.375]                   if (is.na(NA_character_)) 
[16:06:15.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:15.375]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:15.375]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:15.375]                     envir = parent.frame()) 
[16:06:15.375]                   {
[16:06:15.375]                     if (is.function(workers)) 
[16:06:15.375]                       workers <- workers()
[16:06:15.375]                     workers <- structure(as.integer(workers), 
[16:06:15.375]                       class = class(workers))
[16:06:15.375]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:15.375]                       workers >= 1)
[16:06:15.375]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:15.375]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:15.375]                     }
[16:06:15.375]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:15.375]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:15.375]                       envir = envir)
[16:06:15.375]                     if (!future$lazy) 
[16:06:15.375]                       future <- run(future)
[16:06:15.375]                     invisible(future)
[16:06:15.375]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:15.375]                 }
[16:06:15.375]             }
[16:06:15.375]         }
[16:06:15.375]     })
[16:06:15.375]     if (TRUE) {
[16:06:15.375]         base::sink(type = "output", split = FALSE)
[16:06:15.375]         if (TRUE) {
[16:06:15.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:15.375]         }
[16:06:15.375]         else {
[16:06:15.375]             ...future.result["stdout"] <- base::list(NULL)
[16:06:15.375]         }
[16:06:15.375]         base::close(...future.stdout)
[16:06:15.375]         ...future.stdout <- NULL
[16:06:15.375]     }
[16:06:15.375]     ...future.result$conditions <- ...future.conditions
[16:06:15.375]     ...future.result$finished <- base::Sys.time()
[16:06:15.375]     ...future.result
[16:06:15.375] }
[16:06:15.378] Poll #1 (0): usedNodes() = 2, workers = 2
[16:06:15.409] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[16:06:15.440] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[16:06:15.472] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[16:06:15.483] receiveMessageFromWorker() for ClusterFuture ...
[16:06:15.483] - Validating connection of MultisessionFuture
[16:06:15.483] - received message: FutureResult
[16:06:15.483] - Received FutureResult
[16:06:15.483] - Erased future from FutureRegistry
[16:06:15.484] result() for ClusterFuture ...
[16:06:15.484] - result already collected: FutureResult
[16:06:15.484] result() for ClusterFuture ... done
[16:06:15.484] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:15.484] result() for ClusterFuture ...
[16:06:15.484] - result already collected: FutureResult
[16:06:15.484] result() for ClusterFuture ... done
[16:06:15.484] result() for ClusterFuture ...
[16:06:15.484] - result already collected: FutureResult
[16:06:15.484] result() for ClusterFuture ... done
[16:06:15.485] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:06:15.485] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:06:15.485] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:06:15.485] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:06:15.486] MultisessionFuture started
[16:06:15.486] - Launch lazy future ... done
[16:06:15.486] run() for ‘MultisessionFuture’ ... done
[16:06:15.486] resolve() on list ...
[16:06:15.486]  recursive: 0
[16:06:15.486]  length: 3
[16:06:15.487] 
[16:06:15.487] Future #1
[16:06:15.487]  length: 2 (resolved future 1)
[16:06:15.518] receiveMessageFromWorker() for ClusterFuture ...
[16:06:15.518] - Validating connection of MultisessionFuture
[16:06:15.519] - received message: FutureResult
[16:06:15.519] - Received FutureResult
[16:06:15.519] - Erased future from FutureRegistry
[16:06:15.519] result() for ClusterFuture ...
[16:06:15.519] - result already collected: FutureResult
[16:06:15.519] result() for ClusterFuture ... done
[16:06:15.519] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:15.520] Future #2
[16:06:15.520]  length: 1 (resolved future 2)
[16:06:15.632] receiveMessageFromWorker() for ClusterFuture ...
[16:06:15.632] - Validating connection of MultisessionFuture
[16:06:15.632] - received message: FutureResult
[16:06:15.632] - Received FutureResult
[16:06:15.632] - Erased future from FutureRegistry
[16:06:15.633] result() for ClusterFuture ...
[16:06:15.633] - result already collected: FutureResult
[16:06:15.633] result() for ClusterFuture ... done
[16:06:15.633] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:15.633] Future #3
[16:06:15.633]  length: 0 (resolved future 3)
[16:06:15.633] resolve() on list ... DONE
[16:06:15.633] getGlobalsAndPackages() ...
[16:06:15.633] Searching for globals...
[16:06:15.634] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:06:15.635] Searching for globals ... DONE
[16:06:15.635] Resolving globals: FALSE
[16:06:15.635] The total size of the 1 globals is 56 bytes (56 bytes)
[16:06:15.635] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:06:15.636] - globals: [1] ‘kk’
[16:06:15.636] 
[16:06:15.636] getGlobalsAndPackages() ... DONE
[16:06:15.636] getGlobalsAndPackages() ...
[16:06:15.636] Searching for globals...
[16:06:15.637] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:06:15.637] Searching for globals ... DONE
[16:06:15.637] Resolving globals: FALSE
[16:06:15.638] The total size of the 1 globals is 56 bytes (56 bytes)
[16:06:15.638] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:06:15.638] - globals: [1] ‘kk’
[16:06:15.638] 
[16:06:15.638] getGlobalsAndPackages() ... DONE
[16:06:15.638] getGlobalsAndPackages() ...
[16:06:15.639] Searching for globals...
[16:06:15.639] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[16:06:15.640] Searching for globals ... DONE
[16:06:15.640] Resolving globals: FALSE
[16:06:15.640] The total size of the 1 globals is 56 bytes (56 bytes)
[16:06:15.640] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[16:06:15.640] - globals: [1] ‘kk’
[16:06:15.641] 
[16:06:15.641] getGlobalsAndPackages() ... DONE
[16:06:15.641] resolve() on list ...
[16:06:15.641]  recursive: 0
[16:06:15.641]  length: 3
[16:06:15.641] 
[16:06:15.641] run() for ‘Future’ ...
[16:06:15.641] - state: ‘created’
[16:06:15.641] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:15.655] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:15.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:15.655]   - Field: ‘node’
[16:06:15.655]   - Field: ‘label’
[16:06:15.656]   - Field: ‘local’
[16:06:15.656]   - Field: ‘owner’
[16:06:15.656]   - Field: ‘envir’
[16:06:15.656]   - Field: ‘workers’
[16:06:15.656]   - Field: ‘packages’
[16:06:15.656]   - Field: ‘gc’
[16:06:15.656]   - Field: ‘conditions’
[16:06:15.656]   - Field: ‘persistent’
[16:06:15.656]   - Field: ‘expr’
[16:06:15.656]   - Field: ‘uuid’
[16:06:15.656]   - Field: ‘seed’
[16:06:15.657]   - Field: ‘version’
[16:06:15.657]   - Field: ‘result’
[16:06:15.657]   - Field: ‘asynchronous’
[16:06:15.657]   - Field: ‘calls’
[16:06:15.657]   - Field: ‘globals’
[16:06:15.657]   - Field: ‘stdout’
[16:06:15.657]   - Field: ‘earlySignal’
[16:06:15.657]   - Field: ‘lazy’
[16:06:15.657]   - Field: ‘state’
[16:06:15.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:15.657] - Launch lazy future ...
[16:06:15.658] Packages needed by the future expression (n = 0): <none>
[16:06:15.658] Packages needed by future strategies (n = 0): <none>
[16:06:15.658] {
[16:06:15.658]     {
[16:06:15.658]         {
[16:06:15.658]             ...future.startTime <- base::Sys.time()
[16:06:15.658]             {
[16:06:15.658]                 {
[16:06:15.658]                   {
[16:06:15.658]                     {
[16:06:15.658]                       base::local({
[16:06:15.658]                         has_future <- base::requireNamespace("future", 
[16:06:15.658]                           quietly = TRUE)
[16:06:15.658]                         if (has_future) {
[16:06:15.658]                           ns <- base::getNamespace("future")
[16:06:15.658]                           version <- ns[[".package"]][["version"]]
[16:06:15.658]                           if (is.null(version)) 
[16:06:15.658]                             version <- utils::packageVersion("future")
[16:06:15.658]                         }
[16:06:15.658]                         else {
[16:06:15.658]                           version <- NULL
[16:06:15.658]                         }
[16:06:15.658]                         if (!has_future || version < "1.8.0") {
[16:06:15.658]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:15.658]                             "", base::R.version$version.string), 
[16:06:15.658]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:15.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:15.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:15.658]                               "release", "version")], collapse = " "), 
[16:06:15.658]                             hostname = base::Sys.info()[["nodename"]])
[16:06:15.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:15.658]                             info)
[16:06:15.658]                           info <- base::paste(info, collapse = "; ")
[16:06:15.658]                           if (!has_future) {
[16:06:15.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:15.658]                               info)
[16:06:15.658]                           }
[16:06:15.658]                           else {
[16:06:15.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:15.658]                               info, version)
[16:06:15.658]                           }
[16:06:15.658]                           base::stop(msg)
[16:06:15.658]                         }
[16:06:15.658]                       })
[16:06:15.658]                     }
[16:06:15.658]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:15.658]                     base::options(mc.cores = 1L)
[16:06:15.658]                   }
[16:06:15.658]                   options(future.plan = NULL)
[16:06:15.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:15.658]                 }
[16:06:15.658]                 ...future.workdir <- getwd()
[16:06:15.658]             }
[16:06:15.658]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:15.658]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:15.658]         }
[16:06:15.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:15.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:15.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:15.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:15.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:15.658]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:15.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:15.658]             base::names(...future.oldOptions))
[16:06:15.658]     }
[16:06:15.658]     if (FALSE) {
[16:06:15.658]     }
[16:06:15.658]     else {
[16:06:15.658]         if (TRUE) {
[16:06:15.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:15.658]                 open = "w")
[16:06:15.658]         }
[16:06:15.658]         else {
[16:06:15.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:15.658]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:15.658]         }
[16:06:15.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:15.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:15.658]             base::sink(type = "output", split = FALSE)
[16:06:15.658]             base::close(...future.stdout)
[16:06:15.658]         }, add = TRUE)
[16:06:15.658]     }
[16:06:15.658]     ...future.frame <- base::sys.nframe()
[16:06:15.658]     ...future.conditions <- base::list()
[16:06:15.658]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:15.658]     if (FALSE) {
[16:06:15.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:15.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:15.658]     }
[16:06:15.658]     ...future.result <- base::tryCatch({
[16:06:15.658]         base::withCallingHandlers({
[16:06:15.658]             ...future.value <- base::withVisible(base::local({
[16:06:15.658]                 ...future.makeSendCondition <- base::local({
[16:06:15.658]                   sendCondition <- NULL
[16:06:15.658]                   function(frame = 1L) {
[16:06:15.658]                     if (is.function(sendCondition)) 
[16:06:15.658]                       return(sendCondition)
[16:06:15.658]                     ns <- getNamespace("parallel")
[16:06:15.658]                     if (exists("sendData", mode = "function", 
[16:06:15.658]                       envir = ns)) {
[16:06:15.658]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:15.658]                         envir = ns)
[16:06:15.658]                       envir <- sys.frame(frame)
[16:06:15.658]                       master <- NULL
[16:06:15.658]                       while (!identical(envir, .GlobalEnv) && 
[16:06:15.658]                         !identical(envir, emptyenv())) {
[16:06:15.658]                         if (exists("master", mode = "list", envir = envir, 
[16:06:15.658]                           inherits = FALSE)) {
[16:06:15.658]                           master <- get("master", mode = "list", 
[16:06:15.658]                             envir = envir, inherits = FALSE)
[16:06:15.658]                           if (inherits(master, c("SOCKnode", 
[16:06:15.658]                             "SOCK0node"))) {
[16:06:15.658]                             sendCondition <<- function(cond) {
[16:06:15.658]                               data <- list(type = "VALUE", value = cond, 
[16:06:15.658]                                 success = TRUE)
[16:06:15.658]                               parallel_sendData(master, data)
[16:06:15.658]                             }
[16:06:15.658]                             return(sendCondition)
[16:06:15.658]                           }
[16:06:15.658]                         }
[16:06:15.658]                         frame <- frame + 1L
[16:06:15.658]                         envir <- sys.frame(frame)
[16:06:15.658]                       }
[16:06:15.658]                     }
[16:06:15.658]                     sendCondition <<- function(cond) NULL
[16:06:15.658]                   }
[16:06:15.658]                 })
[16:06:15.658]                 withCallingHandlers({
[16:06:15.658]                   {
[16:06:15.658]                     Sys.sleep(0.1)
[16:06:15.658]                     kk
[16:06:15.658]                   }
[16:06:15.658]                 }, immediateCondition = function(cond) {
[16:06:15.658]                   sendCondition <- ...future.makeSendCondition()
[16:06:15.658]                   sendCondition(cond)
[16:06:15.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.658]                   {
[16:06:15.658]                     inherits <- base::inherits
[16:06:15.658]                     invokeRestart <- base::invokeRestart
[16:06:15.658]                     is.null <- base::is.null
[16:06:15.658]                     muffled <- FALSE
[16:06:15.658]                     if (inherits(cond, "message")) {
[16:06:15.658]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:15.658]                       if (muffled) 
[16:06:15.658]                         invokeRestart("muffleMessage")
[16:06:15.658]                     }
[16:06:15.658]                     else if (inherits(cond, "warning")) {
[16:06:15.658]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:15.658]                       if (muffled) 
[16:06:15.658]                         invokeRestart("muffleWarning")
[16:06:15.658]                     }
[16:06:15.658]                     else if (inherits(cond, "condition")) {
[16:06:15.658]                       if (!is.null(pattern)) {
[16:06:15.658]                         computeRestarts <- base::computeRestarts
[16:06:15.658]                         grepl <- base::grepl
[16:06:15.658]                         restarts <- computeRestarts(cond)
[16:06:15.658]                         for (restart in restarts) {
[16:06:15.658]                           name <- restart$name
[16:06:15.658]                           if (is.null(name)) 
[16:06:15.658]                             next
[16:06:15.658]                           if (!grepl(pattern, name)) 
[16:06:15.658]                             next
[16:06:15.658]                           invokeRestart(restart)
[16:06:15.658]                           muffled <- TRUE
[16:06:15.658]                           break
[16:06:15.658]                         }
[16:06:15.658]                       }
[16:06:15.658]                     }
[16:06:15.658]                     invisible(muffled)
[16:06:15.658]                   }
[16:06:15.658]                   muffleCondition(cond)
[16:06:15.658]                 })
[16:06:15.658]             }))
[16:06:15.658]             future::FutureResult(value = ...future.value$value, 
[16:06:15.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.658]                   ...future.rng), globalenv = if (FALSE) 
[16:06:15.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:15.658]                     ...future.globalenv.names))
[16:06:15.658]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:15.658]         }, condition = base::local({
[16:06:15.658]             c <- base::c
[16:06:15.658]             inherits <- base::inherits
[16:06:15.658]             invokeRestart <- base::invokeRestart
[16:06:15.658]             length <- base::length
[16:06:15.658]             list <- base::list
[16:06:15.658]             seq.int <- base::seq.int
[16:06:15.658]             signalCondition <- base::signalCondition
[16:06:15.658]             sys.calls <- base::sys.calls
[16:06:15.658]             `[[` <- base::`[[`
[16:06:15.658]             `+` <- base::`+`
[16:06:15.658]             `<<-` <- base::`<<-`
[16:06:15.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:15.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:15.658]                   3L)]
[16:06:15.658]             }
[16:06:15.658]             function(cond) {
[16:06:15.658]                 is_error <- inherits(cond, "error")
[16:06:15.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:15.658]                   NULL)
[16:06:15.658]                 if (is_error) {
[16:06:15.658]                   sessionInformation <- function() {
[16:06:15.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:15.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:15.658]                       search = base::search(), system = base::Sys.info())
[16:06:15.658]                   }
[16:06:15.658]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:15.658]                     cond$call), session = sessionInformation(), 
[16:06:15.658]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:15.658]                   signalCondition(cond)
[16:06:15.658]                 }
[16:06:15.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:15.658]                 "immediateCondition"))) {
[16:06:15.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:15.658]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:15.658]                   if (TRUE && !signal) {
[16:06:15.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.658]                     {
[16:06:15.658]                       inherits <- base::inherits
[16:06:15.658]                       invokeRestart <- base::invokeRestart
[16:06:15.658]                       is.null <- base::is.null
[16:06:15.658]                       muffled <- FALSE
[16:06:15.658]                       if (inherits(cond, "message")) {
[16:06:15.658]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.658]                         if (muffled) 
[16:06:15.658]                           invokeRestart("muffleMessage")
[16:06:15.658]                       }
[16:06:15.658]                       else if (inherits(cond, "warning")) {
[16:06:15.658]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.658]                         if (muffled) 
[16:06:15.658]                           invokeRestart("muffleWarning")
[16:06:15.658]                       }
[16:06:15.658]                       else if (inherits(cond, "condition")) {
[16:06:15.658]                         if (!is.null(pattern)) {
[16:06:15.658]                           computeRestarts <- base::computeRestarts
[16:06:15.658]                           grepl <- base::grepl
[16:06:15.658]                           restarts <- computeRestarts(cond)
[16:06:15.658]                           for (restart in restarts) {
[16:06:15.658]                             name <- restart$name
[16:06:15.658]                             if (is.null(name)) 
[16:06:15.658]                               next
[16:06:15.658]                             if (!grepl(pattern, name)) 
[16:06:15.658]                               next
[16:06:15.658]                             invokeRestart(restart)
[16:06:15.658]                             muffled <- TRUE
[16:06:15.658]                             break
[16:06:15.658]                           }
[16:06:15.658]                         }
[16:06:15.658]                       }
[16:06:15.658]                       invisible(muffled)
[16:06:15.658]                     }
[16:06:15.658]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.658]                   }
[16:06:15.658]                 }
[16:06:15.658]                 else {
[16:06:15.658]                   if (TRUE) {
[16:06:15.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.658]                     {
[16:06:15.658]                       inherits <- base::inherits
[16:06:15.658]                       invokeRestart <- base::invokeRestart
[16:06:15.658]                       is.null <- base::is.null
[16:06:15.658]                       muffled <- FALSE
[16:06:15.658]                       if (inherits(cond, "message")) {
[16:06:15.658]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.658]                         if (muffled) 
[16:06:15.658]                           invokeRestart("muffleMessage")
[16:06:15.658]                       }
[16:06:15.658]                       else if (inherits(cond, "warning")) {
[16:06:15.658]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.658]                         if (muffled) 
[16:06:15.658]                           invokeRestart("muffleWarning")
[16:06:15.658]                       }
[16:06:15.658]                       else if (inherits(cond, "condition")) {
[16:06:15.658]                         if (!is.null(pattern)) {
[16:06:15.658]                           computeRestarts <- base::computeRestarts
[16:06:15.658]                           grepl <- base::grepl
[16:06:15.658]                           restarts <- computeRestarts(cond)
[16:06:15.658]                           for (restart in restarts) {
[16:06:15.658]                             name <- restart$name
[16:06:15.658]                             if (is.null(name)) 
[16:06:15.658]                               next
[16:06:15.658]                             if (!grepl(pattern, name)) 
[16:06:15.658]                               next
[16:06:15.658]                             invokeRestart(restart)
[16:06:15.658]                             muffled <- TRUE
[16:06:15.658]                             break
[16:06:15.658]                           }
[16:06:15.658]                         }
[16:06:15.658]                       }
[16:06:15.658]                       invisible(muffled)
[16:06:15.658]                     }
[16:06:15.658]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.658]                   }
[16:06:15.658]                 }
[16:06:15.658]             }
[16:06:15.658]         }))
[16:06:15.658]     }, error = function(ex) {
[16:06:15.658]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:15.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.658]                 ...future.rng), started = ...future.startTime, 
[16:06:15.658]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:15.658]             version = "1.8"), class = "FutureResult")
[16:06:15.658]     }, finally = {
[16:06:15.658]         if (!identical(...future.workdir, getwd())) 
[16:06:15.658]             setwd(...future.workdir)
[16:06:15.658]         {
[16:06:15.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:15.658]                 ...future.oldOptions$nwarnings <- NULL
[16:06:15.658]             }
[16:06:15.658]             base::options(...future.oldOptions)
[16:06:15.658]             if (.Platform$OS.type == "windows") {
[16:06:15.658]                 old_names <- names(...future.oldEnvVars)
[16:06:15.658]                 envs <- base::Sys.getenv()
[16:06:15.658]                 names <- names(envs)
[16:06:15.658]                 common <- intersect(names, old_names)
[16:06:15.658]                 added <- setdiff(names, old_names)
[16:06:15.658]                 removed <- setdiff(old_names, names)
[16:06:15.658]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:15.658]                   envs[common]]
[16:06:15.658]                 NAMES <- toupper(changed)
[16:06:15.658]                 args <- list()
[16:06:15.658]                 for (kk in seq_along(NAMES)) {
[16:06:15.658]                   name <- changed[[kk]]
[16:06:15.658]                   NAME <- NAMES[[kk]]
[16:06:15.658]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.658]                     next
[16:06:15.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.658]                 }
[16:06:15.658]                 NAMES <- toupper(added)
[16:06:15.658]                 for (kk in seq_along(NAMES)) {
[16:06:15.658]                   name <- added[[kk]]
[16:06:15.658]                   NAME <- NAMES[[kk]]
[16:06:15.658]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.658]                     next
[16:06:15.658]                   args[[name]] <- ""
[16:06:15.658]                 }
[16:06:15.658]                 NAMES <- toupper(removed)
[16:06:15.658]                 for (kk in seq_along(NAMES)) {
[16:06:15.658]                   name <- removed[[kk]]
[16:06:15.658]                   NAME <- NAMES[[kk]]
[16:06:15.658]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.658]                     next
[16:06:15.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.658]                 }
[16:06:15.658]                 if (length(args) > 0) 
[16:06:15.658]                   base::do.call(base::Sys.setenv, args = args)
[16:06:15.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:15.658]             }
[16:06:15.658]             else {
[16:06:15.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:15.658]             }
[16:06:15.658]             {
[16:06:15.658]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:15.658]                   0L) {
[16:06:15.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:15.658]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:15.658]                   base::options(opts)
[16:06:15.658]                 }
[16:06:15.658]                 {
[16:06:15.658]                   {
[16:06:15.658]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:15.658]                     NULL
[16:06:15.658]                   }
[16:06:15.658]                   options(future.plan = NULL)
[16:06:15.658]                   if (is.na(NA_character_)) 
[16:06:15.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:15.658]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:15.658]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:15.658]                     envir = parent.frame()) 
[16:06:15.658]                   {
[16:06:15.658]                     if (is.function(workers)) 
[16:06:15.658]                       workers <- workers()
[16:06:15.658]                     workers <- structure(as.integer(workers), 
[16:06:15.658]                       class = class(workers))
[16:06:15.658]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:15.658]                       workers >= 1)
[16:06:15.658]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:15.658]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:15.658]                     }
[16:06:15.658]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:15.658]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:15.658]                       envir = envir)
[16:06:15.658]                     if (!future$lazy) 
[16:06:15.658]                       future <- run(future)
[16:06:15.658]                     invisible(future)
[16:06:15.658]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:15.658]                 }
[16:06:15.658]             }
[16:06:15.658]         }
[16:06:15.658]     })
[16:06:15.658]     if (TRUE) {
[16:06:15.658]         base::sink(type = "output", split = FALSE)
[16:06:15.658]         if (TRUE) {
[16:06:15.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:15.658]         }
[16:06:15.658]         else {
[16:06:15.658]             ...future.result["stdout"] <- base::list(NULL)
[16:06:15.658]         }
[16:06:15.658]         base::close(...future.stdout)
[16:06:15.658]         ...future.stdout <- NULL
[16:06:15.658]     }
[16:06:15.658]     ...future.result$conditions <- ...future.conditions
[16:06:15.658]     ...future.result$finished <- base::Sys.time()
[16:06:15.658]     ...future.result
[16:06:15.658] }
[16:06:15.661] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:06:15.661] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:06:15.661] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:06:15.662] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:06:15.662] MultisessionFuture started
[16:06:15.662] - Launch lazy future ... done
[16:06:15.662] run() for ‘MultisessionFuture’ ... done
[16:06:15.673] run() for ‘Future’ ...
[16:06:15.673] - state: ‘created’
[16:06:15.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:15.687] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:15.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:15.687]   - Field: ‘node’
[16:06:15.687]   - Field: ‘label’
[16:06:15.687]   - Field: ‘local’
[16:06:15.687]   - Field: ‘owner’
[16:06:15.687]   - Field: ‘envir’
[16:06:15.687]   - Field: ‘workers’
[16:06:15.687]   - Field: ‘packages’
[16:06:15.688]   - Field: ‘gc’
[16:06:15.688]   - Field: ‘conditions’
[16:06:15.688]   - Field: ‘persistent’
[16:06:15.688]   - Field: ‘expr’
[16:06:15.688]   - Field: ‘uuid’
[16:06:15.688]   - Field: ‘seed’
[16:06:15.688]   - Field: ‘version’
[16:06:15.688]   - Field: ‘result’
[16:06:15.688]   - Field: ‘asynchronous’
[16:06:15.688]   - Field: ‘calls’
[16:06:15.688]   - Field: ‘globals’
[16:06:15.689]   - Field: ‘stdout’
[16:06:15.689]   - Field: ‘earlySignal’
[16:06:15.689]   - Field: ‘lazy’
[16:06:15.689]   - Field: ‘state’
[16:06:15.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:15.689] - Launch lazy future ...
[16:06:15.689] Packages needed by the future expression (n = 0): <none>
[16:06:15.689] Packages needed by future strategies (n = 0): <none>
[16:06:15.690] {
[16:06:15.690]     {
[16:06:15.690]         {
[16:06:15.690]             ...future.startTime <- base::Sys.time()
[16:06:15.690]             {
[16:06:15.690]                 {
[16:06:15.690]                   {
[16:06:15.690]                     {
[16:06:15.690]                       base::local({
[16:06:15.690]                         has_future <- base::requireNamespace("future", 
[16:06:15.690]                           quietly = TRUE)
[16:06:15.690]                         if (has_future) {
[16:06:15.690]                           ns <- base::getNamespace("future")
[16:06:15.690]                           version <- ns[[".package"]][["version"]]
[16:06:15.690]                           if (is.null(version)) 
[16:06:15.690]                             version <- utils::packageVersion("future")
[16:06:15.690]                         }
[16:06:15.690]                         else {
[16:06:15.690]                           version <- NULL
[16:06:15.690]                         }
[16:06:15.690]                         if (!has_future || version < "1.8.0") {
[16:06:15.690]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:15.690]                             "", base::R.version$version.string), 
[16:06:15.690]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:15.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:15.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:15.690]                               "release", "version")], collapse = " "), 
[16:06:15.690]                             hostname = base::Sys.info()[["nodename"]])
[16:06:15.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:15.690]                             info)
[16:06:15.690]                           info <- base::paste(info, collapse = "; ")
[16:06:15.690]                           if (!has_future) {
[16:06:15.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:15.690]                               info)
[16:06:15.690]                           }
[16:06:15.690]                           else {
[16:06:15.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:15.690]                               info, version)
[16:06:15.690]                           }
[16:06:15.690]                           base::stop(msg)
[16:06:15.690]                         }
[16:06:15.690]                       })
[16:06:15.690]                     }
[16:06:15.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:15.690]                     base::options(mc.cores = 1L)
[16:06:15.690]                   }
[16:06:15.690]                   options(future.plan = NULL)
[16:06:15.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:15.690]                 }
[16:06:15.690]                 ...future.workdir <- getwd()
[16:06:15.690]             }
[16:06:15.690]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:15.690]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:15.690]         }
[16:06:15.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:15.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:15.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:15.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:15.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:15.690]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:15.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:15.690]             base::names(...future.oldOptions))
[16:06:15.690]     }
[16:06:15.690]     if (FALSE) {
[16:06:15.690]     }
[16:06:15.690]     else {
[16:06:15.690]         if (TRUE) {
[16:06:15.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:15.690]                 open = "w")
[16:06:15.690]         }
[16:06:15.690]         else {
[16:06:15.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:15.690]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:15.690]         }
[16:06:15.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:15.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:15.690]             base::sink(type = "output", split = FALSE)
[16:06:15.690]             base::close(...future.stdout)
[16:06:15.690]         }, add = TRUE)
[16:06:15.690]     }
[16:06:15.690]     ...future.frame <- base::sys.nframe()
[16:06:15.690]     ...future.conditions <- base::list()
[16:06:15.690]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:15.690]     if (FALSE) {
[16:06:15.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:15.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:15.690]     }
[16:06:15.690]     ...future.result <- base::tryCatch({
[16:06:15.690]         base::withCallingHandlers({
[16:06:15.690]             ...future.value <- base::withVisible(base::local({
[16:06:15.690]                 ...future.makeSendCondition <- base::local({
[16:06:15.690]                   sendCondition <- NULL
[16:06:15.690]                   function(frame = 1L) {
[16:06:15.690]                     if (is.function(sendCondition)) 
[16:06:15.690]                       return(sendCondition)
[16:06:15.690]                     ns <- getNamespace("parallel")
[16:06:15.690]                     if (exists("sendData", mode = "function", 
[16:06:15.690]                       envir = ns)) {
[16:06:15.690]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:15.690]                         envir = ns)
[16:06:15.690]                       envir <- sys.frame(frame)
[16:06:15.690]                       master <- NULL
[16:06:15.690]                       while (!identical(envir, .GlobalEnv) && 
[16:06:15.690]                         !identical(envir, emptyenv())) {
[16:06:15.690]                         if (exists("master", mode = "list", envir = envir, 
[16:06:15.690]                           inherits = FALSE)) {
[16:06:15.690]                           master <- get("master", mode = "list", 
[16:06:15.690]                             envir = envir, inherits = FALSE)
[16:06:15.690]                           if (inherits(master, c("SOCKnode", 
[16:06:15.690]                             "SOCK0node"))) {
[16:06:15.690]                             sendCondition <<- function(cond) {
[16:06:15.690]                               data <- list(type = "VALUE", value = cond, 
[16:06:15.690]                                 success = TRUE)
[16:06:15.690]                               parallel_sendData(master, data)
[16:06:15.690]                             }
[16:06:15.690]                             return(sendCondition)
[16:06:15.690]                           }
[16:06:15.690]                         }
[16:06:15.690]                         frame <- frame + 1L
[16:06:15.690]                         envir <- sys.frame(frame)
[16:06:15.690]                       }
[16:06:15.690]                     }
[16:06:15.690]                     sendCondition <<- function(cond) NULL
[16:06:15.690]                   }
[16:06:15.690]                 })
[16:06:15.690]                 withCallingHandlers({
[16:06:15.690]                   {
[16:06:15.690]                     Sys.sleep(0.1)
[16:06:15.690]                     kk
[16:06:15.690]                   }
[16:06:15.690]                 }, immediateCondition = function(cond) {
[16:06:15.690]                   sendCondition <- ...future.makeSendCondition()
[16:06:15.690]                   sendCondition(cond)
[16:06:15.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.690]                   {
[16:06:15.690]                     inherits <- base::inherits
[16:06:15.690]                     invokeRestart <- base::invokeRestart
[16:06:15.690]                     is.null <- base::is.null
[16:06:15.690]                     muffled <- FALSE
[16:06:15.690]                     if (inherits(cond, "message")) {
[16:06:15.690]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:15.690]                       if (muffled) 
[16:06:15.690]                         invokeRestart("muffleMessage")
[16:06:15.690]                     }
[16:06:15.690]                     else if (inherits(cond, "warning")) {
[16:06:15.690]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:15.690]                       if (muffled) 
[16:06:15.690]                         invokeRestart("muffleWarning")
[16:06:15.690]                     }
[16:06:15.690]                     else if (inherits(cond, "condition")) {
[16:06:15.690]                       if (!is.null(pattern)) {
[16:06:15.690]                         computeRestarts <- base::computeRestarts
[16:06:15.690]                         grepl <- base::grepl
[16:06:15.690]                         restarts <- computeRestarts(cond)
[16:06:15.690]                         for (restart in restarts) {
[16:06:15.690]                           name <- restart$name
[16:06:15.690]                           if (is.null(name)) 
[16:06:15.690]                             next
[16:06:15.690]                           if (!grepl(pattern, name)) 
[16:06:15.690]                             next
[16:06:15.690]                           invokeRestart(restart)
[16:06:15.690]                           muffled <- TRUE
[16:06:15.690]                           break
[16:06:15.690]                         }
[16:06:15.690]                       }
[16:06:15.690]                     }
[16:06:15.690]                     invisible(muffled)
[16:06:15.690]                   }
[16:06:15.690]                   muffleCondition(cond)
[16:06:15.690]                 })
[16:06:15.690]             }))
[16:06:15.690]             future::FutureResult(value = ...future.value$value, 
[16:06:15.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.690]                   ...future.rng), globalenv = if (FALSE) 
[16:06:15.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:15.690]                     ...future.globalenv.names))
[16:06:15.690]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:15.690]         }, condition = base::local({
[16:06:15.690]             c <- base::c
[16:06:15.690]             inherits <- base::inherits
[16:06:15.690]             invokeRestart <- base::invokeRestart
[16:06:15.690]             length <- base::length
[16:06:15.690]             list <- base::list
[16:06:15.690]             seq.int <- base::seq.int
[16:06:15.690]             signalCondition <- base::signalCondition
[16:06:15.690]             sys.calls <- base::sys.calls
[16:06:15.690]             `[[` <- base::`[[`
[16:06:15.690]             `+` <- base::`+`
[16:06:15.690]             `<<-` <- base::`<<-`
[16:06:15.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:15.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:15.690]                   3L)]
[16:06:15.690]             }
[16:06:15.690]             function(cond) {
[16:06:15.690]                 is_error <- inherits(cond, "error")
[16:06:15.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:15.690]                   NULL)
[16:06:15.690]                 if (is_error) {
[16:06:15.690]                   sessionInformation <- function() {
[16:06:15.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:15.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:15.690]                       search = base::search(), system = base::Sys.info())
[16:06:15.690]                   }
[16:06:15.690]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:15.690]                     cond$call), session = sessionInformation(), 
[16:06:15.690]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:15.690]                   signalCondition(cond)
[16:06:15.690]                 }
[16:06:15.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:15.690]                 "immediateCondition"))) {
[16:06:15.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:15.690]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:15.690]                   if (TRUE && !signal) {
[16:06:15.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.690]                     {
[16:06:15.690]                       inherits <- base::inherits
[16:06:15.690]                       invokeRestart <- base::invokeRestart
[16:06:15.690]                       is.null <- base::is.null
[16:06:15.690]                       muffled <- FALSE
[16:06:15.690]                       if (inherits(cond, "message")) {
[16:06:15.690]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.690]                         if (muffled) 
[16:06:15.690]                           invokeRestart("muffleMessage")
[16:06:15.690]                       }
[16:06:15.690]                       else if (inherits(cond, "warning")) {
[16:06:15.690]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.690]                         if (muffled) 
[16:06:15.690]                           invokeRestart("muffleWarning")
[16:06:15.690]                       }
[16:06:15.690]                       else if (inherits(cond, "condition")) {
[16:06:15.690]                         if (!is.null(pattern)) {
[16:06:15.690]                           computeRestarts <- base::computeRestarts
[16:06:15.690]                           grepl <- base::grepl
[16:06:15.690]                           restarts <- computeRestarts(cond)
[16:06:15.690]                           for (restart in restarts) {
[16:06:15.690]                             name <- restart$name
[16:06:15.690]                             if (is.null(name)) 
[16:06:15.690]                               next
[16:06:15.690]                             if (!grepl(pattern, name)) 
[16:06:15.690]                               next
[16:06:15.690]                             invokeRestart(restart)
[16:06:15.690]                             muffled <- TRUE
[16:06:15.690]                             break
[16:06:15.690]                           }
[16:06:15.690]                         }
[16:06:15.690]                       }
[16:06:15.690]                       invisible(muffled)
[16:06:15.690]                     }
[16:06:15.690]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.690]                   }
[16:06:15.690]                 }
[16:06:15.690]                 else {
[16:06:15.690]                   if (TRUE) {
[16:06:15.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.690]                     {
[16:06:15.690]                       inherits <- base::inherits
[16:06:15.690]                       invokeRestart <- base::invokeRestart
[16:06:15.690]                       is.null <- base::is.null
[16:06:15.690]                       muffled <- FALSE
[16:06:15.690]                       if (inherits(cond, "message")) {
[16:06:15.690]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.690]                         if (muffled) 
[16:06:15.690]                           invokeRestart("muffleMessage")
[16:06:15.690]                       }
[16:06:15.690]                       else if (inherits(cond, "warning")) {
[16:06:15.690]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.690]                         if (muffled) 
[16:06:15.690]                           invokeRestart("muffleWarning")
[16:06:15.690]                       }
[16:06:15.690]                       else if (inherits(cond, "condition")) {
[16:06:15.690]                         if (!is.null(pattern)) {
[16:06:15.690]                           computeRestarts <- base::computeRestarts
[16:06:15.690]                           grepl <- base::grepl
[16:06:15.690]                           restarts <- computeRestarts(cond)
[16:06:15.690]                           for (restart in restarts) {
[16:06:15.690]                             name <- restart$name
[16:06:15.690]                             if (is.null(name)) 
[16:06:15.690]                               next
[16:06:15.690]                             if (!grepl(pattern, name)) 
[16:06:15.690]                               next
[16:06:15.690]                             invokeRestart(restart)
[16:06:15.690]                             muffled <- TRUE
[16:06:15.690]                             break
[16:06:15.690]                           }
[16:06:15.690]                         }
[16:06:15.690]                       }
[16:06:15.690]                       invisible(muffled)
[16:06:15.690]                     }
[16:06:15.690]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.690]                   }
[16:06:15.690]                 }
[16:06:15.690]             }
[16:06:15.690]         }))
[16:06:15.690]     }, error = function(ex) {
[16:06:15.690]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:15.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.690]                 ...future.rng), started = ...future.startTime, 
[16:06:15.690]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:15.690]             version = "1.8"), class = "FutureResult")
[16:06:15.690]     }, finally = {
[16:06:15.690]         if (!identical(...future.workdir, getwd())) 
[16:06:15.690]             setwd(...future.workdir)
[16:06:15.690]         {
[16:06:15.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:15.690]                 ...future.oldOptions$nwarnings <- NULL
[16:06:15.690]             }
[16:06:15.690]             base::options(...future.oldOptions)
[16:06:15.690]             if (.Platform$OS.type == "windows") {
[16:06:15.690]                 old_names <- names(...future.oldEnvVars)
[16:06:15.690]                 envs <- base::Sys.getenv()
[16:06:15.690]                 names <- names(envs)
[16:06:15.690]                 common <- intersect(names, old_names)
[16:06:15.690]                 added <- setdiff(names, old_names)
[16:06:15.690]                 removed <- setdiff(old_names, names)
[16:06:15.690]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:15.690]                   envs[common]]
[16:06:15.690]                 NAMES <- toupper(changed)
[16:06:15.690]                 args <- list()
[16:06:15.690]                 for (kk in seq_along(NAMES)) {
[16:06:15.690]                   name <- changed[[kk]]
[16:06:15.690]                   NAME <- NAMES[[kk]]
[16:06:15.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.690]                     next
[16:06:15.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.690]                 }
[16:06:15.690]                 NAMES <- toupper(added)
[16:06:15.690]                 for (kk in seq_along(NAMES)) {
[16:06:15.690]                   name <- added[[kk]]
[16:06:15.690]                   NAME <- NAMES[[kk]]
[16:06:15.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.690]                     next
[16:06:15.690]                   args[[name]] <- ""
[16:06:15.690]                 }
[16:06:15.690]                 NAMES <- toupper(removed)
[16:06:15.690]                 for (kk in seq_along(NAMES)) {
[16:06:15.690]                   name <- removed[[kk]]
[16:06:15.690]                   NAME <- NAMES[[kk]]
[16:06:15.690]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.690]                     next
[16:06:15.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.690]                 }
[16:06:15.690]                 if (length(args) > 0) 
[16:06:15.690]                   base::do.call(base::Sys.setenv, args = args)
[16:06:15.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:15.690]             }
[16:06:15.690]             else {
[16:06:15.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:15.690]             }
[16:06:15.690]             {
[16:06:15.690]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:15.690]                   0L) {
[16:06:15.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:15.690]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:15.690]                   base::options(opts)
[16:06:15.690]                 }
[16:06:15.690]                 {
[16:06:15.690]                   {
[16:06:15.690]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:15.690]                     NULL
[16:06:15.690]                   }
[16:06:15.690]                   options(future.plan = NULL)
[16:06:15.690]                   if (is.na(NA_character_)) 
[16:06:15.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:15.690]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:15.690]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:15.690]                     envir = parent.frame()) 
[16:06:15.690]                   {
[16:06:15.690]                     if (is.function(workers)) 
[16:06:15.690]                       workers <- workers()
[16:06:15.690]                     workers <- structure(as.integer(workers), 
[16:06:15.690]                       class = class(workers))
[16:06:15.690]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:15.690]                       workers >= 1)
[16:06:15.690]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:15.690]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:15.690]                     }
[16:06:15.690]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:15.690]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:15.690]                       envir = envir)
[16:06:15.690]                     if (!future$lazy) 
[16:06:15.690]                       future <- run(future)
[16:06:15.690]                     invisible(future)
[16:06:15.690]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:15.690]                 }
[16:06:15.690]             }
[16:06:15.690]         }
[16:06:15.690]     })
[16:06:15.690]     if (TRUE) {
[16:06:15.690]         base::sink(type = "output", split = FALSE)
[16:06:15.690]         if (TRUE) {
[16:06:15.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:15.690]         }
[16:06:15.690]         else {
[16:06:15.690]             ...future.result["stdout"] <- base::list(NULL)
[16:06:15.690]         }
[16:06:15.690]         base::close(...future.stdout)
[16:06:15.690]         ...future.stdout <- NULL
[16:06:15.690]     }
[16:06:15.690]     ...future.result$conditions <- ...future.conditions
[16:06:15.690]     ...future.result$finished <- base::Sys.time()
[16:06:15.690]     ...future.result
[16:06:15.690] }
[16:06:15.692] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[16:06:15.693] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[16:06:15.693] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[16:06:15.693] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[16:06:15.694] MultisessionFuture started
[16:06:15.694] - Launch lazy future ... done
[16:06:15.694] run() for ‘MultisessionFuture’ ... done
[16:06:15.704] run() for ‘Future’ ...
[16:06:15.704] - state: ‘created’
[16:06:15.704] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:15.718] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:15.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:15.718]   - Field: ‘node’
[16:06:15.718]   - Field: ‘label’
[16:06:15.718]   - Field: ‘local’
[16:06:15.719]   - Field: ‘owner’
[16:06:15.719]   - Field: ‘envir’
[16:06:15.719]   - Field: ‘workers’
[16:06:15.719]   - Field: ‘packages’
[16:06:15.719]   - Field: ‘gc’
[16:06:15.719]   - Field: ‘conditions’
[16:06:15.719]   - Field: ‘persistent’
[16:06:15.719]   - Field: ‘expr’
[16:06:15.719]   - Field: ‘uuid’
[16:06:15.719]   - Field: ‘seed’
[16:06:15.719]   - Field: ‘version’
[16:06:15.720]   - Field: ‘result’
[16:06:15.720]   - Field: ‘asynchronous’
[16:06:15.720]   - Field: ‘calls’
[16:06:15.720]   - Field: ‘globals’
[16:06:15.720]   - Field: ‘stdout’
[16:06:15.720]   - Field: ‘earlySignal’
[16:06:15.720]   - Field: ‘lazy’
[16:06:15.720]   - Field: ‘state’
[16:06:15.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:15.720] - Launch lazy future ...
[16:06:15.721] Packages needed by the future expression (n = 0): <none>
[16:06:15.721] Packages needed by future strategies (n = 0): <none>
[16:06:15.721] {
[16:06:15.721]     {
[16:06:15.721]         {
[16:06:15.721]             ...future.startTime <- base::Sys.time()
[16:06:15.721]             {
[16:06:15.721]                 {
[16:06:15.721]                   {
[16:06:15.721]                     {
[16:06:15.721]                       base::local({
[16:06:15.721]                         has_future <- base::requireNamespace("future", 
[16:06:15.721]                           quietly = TRUE)
[16:06:15.721]                         if (has_future) {
[16:06:15.721]                           ns <- base::getNamespace("future")
[16:06:15.721]                           version <- ns[[".package"]][["version"]]
[16:06:15.721]                           if (is.null(version)) 
[16:06:15.721]                             version <- utils::packageVersion("future")
[16:06:15.721]                         }
[16:06:15.721]                         else {
[16:06:15.721]                           version <- NULL
[16:06:15.721]                         }
[16:06:15.721]                         if (!has_future || version < "1.8.0") {
[16:06:15.721]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:15.721]                             "", base::R.version$version.string), 
[16:06:15.721]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:15.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:15.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:15.721]                               "release", "version")], collapse = " "), 
[16:06:15.721]                             hostname = base::Sys.info()[["nodename"]])
[16:06:15.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:15.721]                             info)
[16:06:15.721]                           info <- base::paste(info, collapse = "; ")
[16:06:15.721]                           if (!has_future) {
[16:06:15.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:15.721]                               info)
[16:06:15.721]                           }
[16:06:15.721]                           else {
[16:06:15.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:15.721]                               info, version)
[16:06:15.721]                           }
[16:06:15.721]                           base::stop(msg)
[16:06:15.721]                         }
[16:06:15.721]                       })
[16:06:15.721]                     }
[16:06:15.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:15.721]                     base::options(mc.cores = 1L)
[16:06:15.721]                   }
[16:06:15.721]                   options(future.plan = NULL)
[16:06:15.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:15.721]                 }
[16:06:15.721]                 ...future.workdir <- getwd()
[16:06:15.721]             }
[16:06:15.721]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:15.721]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:15.721]         }
[16:06:15.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:15.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:15.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:15.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:15.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:15.721]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:15.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:15.721]             base::names(...future.oldOptions))
[16:06:15.721]     }
[16:06:15.721]     if (FALSE) {
[16:06:15.721]     }
[16:06:15.721]     else {
[16:06:15.721]         if (TRUE) {
[16:06:15.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:15.721]                 open = "w")
[16:06:15.721]         }
[16:06:15.721]         else {
[16:06:15.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:15.721]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:15.721]         }
[16:06:15.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:15.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:15.721]             base::sink(type = "output", split = FALSE)
[16:06:15.721]             base::close(...future.stdout)
[16:06:15.721]         }, add = TRUE)
[16:06:15.721]     }
[16:06:15.721]     ...future.frame <- base::sys.nframe()
[16:06:15.721]     ...future.conditions <- base::list()
[16:06:15.721]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:15.721]     if (FALSE) {
[16:06:15.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:15.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:15.721]     }
[16:06:15.721]     ...future.result <- base::tryCatch({
[16:06:15.721]         base::withCallingHandlers({
[16:06:15.721]             ...future.value <- base::withVisible(base::local({
[16:06:15.721]                 ...future.makeSendCondition <- base::local({
[16:06:15.721]                   sendCondition <- NULL
[16:06:15.721]                   function(frame = 1L) {
[16:06:15.721]                     if (is.function(sendCondition)) 
[16:06:15.721]                       return(sendCondition)
[16:06:15.721]                     ns <- getNamespace("parallel")
[16:06:15.721]                     if (exists("sendData", mode = "function", 
[16:06:15.721]                       envir = ns)) {
[16:06:15.721]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:15.721]                         envir = ns)
[16:06:15.721]                       envir <- sys.frame(frame)
[16:06:15.721]                       master <- NULL
[16:06:15.721]                       while (!identical(envir, .GlobalEnv) && 
[16:06:15.721]                         !identical(envir, emptyenv())) {
[16:06:15.721]                         if (exists("master", mode = "list", envir = envir, 
[16:06:15.721]                           inherits = FALSE)) {
[16:06:15.721]                           master <- get("master", mode = "list", 
[16:06:15.721]                             envir = envir, inherits = FALSE)
[16:06:15.721]                           if (inherits(master, c("SOCKnode", 
[16:06:15.721]                             "SOCK0node"))) {
[16:06:15.721]                             sendCondition <<- function(cond) {
[16:06:15.721]                               data <- list(type = "VALUE", value = cond, 
[16:06:15.721]                                 success = TRUE)
[16:06:15.721]                               parallel_sendData(master, data)
[16:06:15.721]                             }
[16:06:15.721]                             return(sendCondition)
[16:06:15.721]                           }
[16:06:15.721]                         }
[16:06:15.721]                         frame <- frame + 1L
[16:06:15.721]                         envir <- sys.frame(frame)
[16:06:15.721]                       }
[16:06:15.721]                     }
[16:06:15.721]                     sendCondition <<- function(cond) NULL
[16:06:15.721]                   }
[16:06:15.721]                 })
[16:06:15.721]                 withCallingHandlers({
[16:06:15.721]                   {
[16:06:15.721]                     Sys.sleep(0.1)
[16:06:15.721]                     kk
[16:06:15.721]                   }
[16:06:15.721]                 }, immediateCondition = function(cond) {
[16:06:15.721]                   sendCondition <- ...future.makeSendCondition()
[16:06:15.721]                   sendCondition(cond)
[16:06:15.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.721]                   {
[16:06:15.721]                     inherits <- base::inherits
[16:06:15.721]                     invokeRestart <- base::invokeRestart
[16:06:15.721]                     is.null <- base::is.null
[16:06:15.721]                     muffled <- FALSE
[16:06:15.721]                     if (inherits(cond, "message")) {
[16:06:15.721]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:15.721]                       if (muffled) 
[16:06:15.721]                         invokeRestart("muffleMessage")
[16:06:15.721]                     }
[16:06:15.721]                     else if (inherits(cond, "warning")) {
[16:06:15.721]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:15.721]                       if (muffled) 
[16:06:15.721]                         invokeRestart("muffleWarning")
[16:06:15.721]                     }
[16:06:15.721]                     else if (inherits(cond, "condition")) {
[16:06:15.721]                       if (!is.null(pattern)) {
[16:06:15.721]                         computeRestarts <- base::computeRestarts
[16:06:15.721]                         grepl <- base::grepl
[16:06:15.721]                         restarts <- computeRestarts(cond)
[16:06:15.721]                         for (restart in restarts) {
[16:06:15.721]                           name <- restart$name
[16:06:15.721]                           if (is.null(name)) 
[16:06:15.721]                             next
[16:06:15.721]                           if (!grepl(pattern, name)) 
[16:06:15.721]                             next
[16:06:15.721]                           invokeRestart(restart)
[16:06:15.721]                           muffled <- TRUE
[16:06:15.721]                           break
[16:06:15.721]                         }
[16:06:15.721]                       }
[16:06:15.721]                     }
[16:06:15.721]                     invisible(muffled)
[16:06:15.721]                   }
[16:06:15.721]                   muffleCondition(cond)
[16:06:15.721]                 })
[16:06:15.721]             }))
[16:06:15.721]             future::FutureResult(value = ...future.value$value, 
[16:06:15.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.721]                   ...future.rng), globalenv = if (FALSE) 
[16:06:15.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:15.721]                     ...future.globalenv.names))
[16:06:15.721]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:15.721]         }, condition = base::local({
[16:06:15.721]             c <- base::c
[16:06:15.721]             inherits <- base::inherits
[16:06:15.721]             invokeRestart <- base::invokeRestart
[16:06:15.721]             length <- base::length
[16:06:15.721]             list <- base::list
[16:06:15.721]             seq.int <- base::seq.int
[16:06:15.721]             signalCondition <- base::signalCondition
[16:06:15.721]             sys.calls <- base::sys.calls
[16:06:15.721]             `[[` <- base::`[[`
[16:06:15.721]             `+` <- base::`+`
[16:06:15.721]             `<<-` <- base::`<<-`
[16:06:15.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:15.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:15.721]                   3L)]
[16:06:15.721]             }
[16:06:15.721]             function(cond) {
[16:06:15.721]                 is_error <- inherits(cond, "error")
[16:06:15.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:15.721]                   NULL)
[16:06:15.721]                 if (is_error) {
[16:06:15.721]                   sessionInformation <- function() {
[16:06:15.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:15.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:15.721]                       search = base::search(), system = base::Sys.info())
[16:06:15.721]                   }
[16:06:15.721]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:15.721]                     cond$call), session = sessionInformation(), 
[16:06:15.721]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:15.721]                   signalCondition(cond)
[16:06:15.721]                 }
[16:06:15.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:15.721]                 "immediateCondition"))) {
[16:06:15.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:15.721]                   ...future.conditions[[length(...future.conditions) + 
[16:06:15.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:15.721]                   if (TRUE && !signal) {
[16:06:15.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.721]                     {
[16:06:15.721]                       inherits <- base::inherits
[16:06:15.721]                       invokeRestart <- base::invokeRestart
[16:06:15.721]                       is.null <- base::is.null
[16:06:15.721]                       muffled <- FALSE
[16:06:15.721]                       if (inherits(cond, "message")) {
[16:06:15.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.721]                         if (muffled) 
[16:06:15.721]                           invokeRestart("muffleMessage")
[16:06:15.721]                       }
[16:06:15.721]                       else if (inherits(cond, "warning")) {
[16:06:15.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.721]                         if (muffled) 
[16:06:15.721]                           invokeRestart("muffleWarning")
[16:06:15.721]                       }
[16:06:15.721]                       else if (inherits(cond, "condition")) {
[16:06:15.721]                         if (!is.null(pattern)) {
[16:06:15.721]                           computeRestarts <- base::computeRestarts
[16:06:15.721]                           grepl <- base::grepl
[16:06:15.721]                           restarts <- computeRestarts(cond)
[16:06:15.721]                           for (restart in restarts) {
[16:06:15.721]                             name <- restart$name
[16:06:15.721]                             if (is.null(name)) 
[16:06:15.721]                               next
[16:06:15.721]                             if (!grepl(pattern, name)) 
[16:06:15.721]                               next
[16:06:15.721]                             invokeRestart(restart)
[16:06:15.721]                             muffled <- TRUE
[16:06:15.721]                             break
[16:06:15.721]                           }
[16:06:15.721]                         }
[16:06:15.721]                       }
[16:06:15.721]                       invisible(muffled)
[16:06:15.721]                     }
[16:06:15.721]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.721]                   }
[16:06:15.721]                 }
[16:06:15.721]                 else {
[16:06:15.721]                   if (TRUE) {
[16:06:15.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:15.721]                     {
[16:06:15.721]                       inherits <- base::inherits
[16:06:15.721]                       invokeRestart <- base::invokeRestart
[16:06:15.721]                       is.null <- base::is.null
[16:06:15.721]                       muffled <- FALSE
[16:06:15.721]                       if (inherits(cond, "message")) {
[16:06:15.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:15.721]                         if (muffled) 
[16:06:15.721]                           invokeRestart("muffleMessage")
[16:06:15.721]                       }
[16:06:15.721]                       else if (inherits(cond, "warning")) {
[16:06:15.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:15.721]                         if (muffled) 
[16:06:15.721]                           invokeRestart("muffleWarning")
[16:06:15.721]                       }
[16:06:15.721]                       else if (inherits(cond, "condition")) {
[16:06:15.721]                         if (!is.null(pattern)) {
[16:06:15.721]                           computeRestarts <- base::computeRestarts
[16:06:15.721]                           grepl <- base::grepl
[16:06:15.721]                           restarts <- computeRestarts(cond)
[16:06:15.721]                           for (restart in restarts) {
[16:06:15.721]                             name <- restart$name
[16:06:15.721]                             if (is.null(name)) 
[16:06:15.721]                               next
[16:06:15.721]                             if (!grepl(pattern, name)) 
[16:06:15.721]                               next
[16:06:15.721]                             invokeRestart(restart)
[16:06:15.721]                             muffled <- TRUE
[16:06:15.721]                             break
[16:06:15.721]                           }
[16:06:15.721]                         }
[16:06:15.721]                       }
[16:06:15.721]                       invisible(muffled)
[16:06:15.721]                     }
[16:06:15.721]                     muffleCondition(cond, pattern = "^muffle")
[16:06:15.721]                   }
[16:06:15.721]                 }
[16:06:15.721]             }
[16:06:15.721]         }))
[16:06:15.721]     }, error = function(ex) {
[16:06:15.721]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:15.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:15.721]                 ...future.rng), started = ...future.startTime, 
[16:06:15.721]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:15.721]             version = "1.8"), class = "FutureResult")
[16:06:15.721]     }, finally = {
[16:06:15.721]         if (!identical(...future.workdir, getwd())) 
[16:06:15.721]             setwd(...future.workdir)
[16:06:15.721]         {
[16:06:15.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:15.721]                 ...future.oldOptions$nwarnings <- NULL
[16:06:15.721]             }
[16:06:15.721]             base::options(...future.oldOptions)
[16:06:15.721]             if (.Platform$OS.type == "windows") {
[16:06:15.721]                 old_names <- names(...future.oldEnvVars)
[16:06:15.721]                 envs <- base::Sys.getenv()
[16:06:15.721]                 names <- names(envs)
[16:06:15.721]                 common <- intersect(names, old_names)
[16:06:15.721]                 added <- setdiff(names, old_names)
[16:06:15.721]                 removed <- setdiff(old_names, names)
[16:06:15.721]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:15.721]                   envs[common]]
[16:06:15.721]                 NAMES <- toupper(changed)
[16:06:15.721]                 args <- list()
[16:06:15.721]                 for (kk in seq_along(NAMES)) {
[16:06:15.721]                   name <- changed[[kk]]
[16:06:15.721]                   NAME <- NAMES[[kk]]
[16:06:15.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.721]                     next
[16:06:15.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.721]                 }
[16:06:15.721]                 NAMES <- toupper(added)
[16:06:15.721]                 for (kk in seq_along(NAMES)) {
[16:06:15.721]                   name <- added[[kk]]
[16:06:15.721]                   NAME <- NAMES[[kk]]
[16:06:15.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.721]                     next
[16:06:15.721]                   args[[name]] <- ""
[16:06:15.721]                 }
[16:06:15.721]                 NAMES <- toupper(removed)
[16:06:15.721]                 for (kk in seq_along(NAMES)) {
[16:06:15.721]                   name <- removed[[kk]]
[16:06:15.721]                   NAME <- NAMES[[kk]]
[16:06:15.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:15.721]                     next
[16:06:15.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:15.721]                 }
[16:06:15.721]                 if (length(args) > 0) 
[16:06:15.721]                   base::do.call(base::Sys.setenv, args = args)
[16:06:15.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:15.721]             }
[16:06:15.721]             else {
[16:06:15.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:15.721]             }
[16:06:15.721]             {
[16:06:15.721]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:15.721]                   0L) {
[16:06:15.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:15.721]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:15.721]                   base::options(opts)
[16:06:15.721]                 }
[16:06:15.721]                 {
[16:06:15.721]                   {
[16:06:15.721]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:15.721]                     NULL
[16:06:15.721]                   }
[16:06:15.721]                   options(future.plan = NULL)
[16:06:15.721]                   if (is.na(NA_character_)) 
[16:06:15.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:15.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:15.721]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:15.721]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:15.721]                     envir = parent.frame()) 
[16:06:15.721]                   {
[16:06:15.721]                     if (is.function(workers)) 
[16:06:15.721]                       workers <- workers()
[16:06:15.721]                     workers <- structure(as.integer(workers), 
[16:06:15.721]                       class = class(workers))
[16:06:15.721]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:15.721]                       workers >= 1)
[16:06:15.721]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:15.721]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:15.721]                     }
[16:06:15.721]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:15.721]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:15.721]                       envir = envir)
[16:06:15.721]                     if (!future$lazy) 
[16:06:15.721]                       future <- run(future)
[16:06:15.721]                     invisible(future)
[16:06:15.721]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:15.721]                 }
[16:06:15.721]             }
[16:06:15.721]         }
[16:06:15.721]     })
[16:06:15.721]     if (TRUE) {
[16:06:15.721]         base::sink(type = "output", split = FALSE)
[16:06:15.721]         if (TRUE) {
[16:06:15.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:15.721]         }
[16:06:15.721]         else {
[16:06:15.721]             ...future.result["stdout"] <- base::list(NULL)
[16:06:15.721]         }
[16:06:15.721]         base::close(...future.stdout)
[16:06:15.721]         ...future.stdout <- NULL
[16:06:15.721]     }
[16:06:15.721]     ...future.result$conditions <- ...future.conditions
[16:06:15.721]     ...future.result$finished <- base::Sys.time()
[16:06:15.721]     ...future.result
[16:06:15.721] }
[16:06:15.723] Poll #1 (0): usedNodes() = 2, workers = 2
[16:06:15.755] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[16:06:15.786] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[16:06:15.818] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[16:06:15.829] receiveMessageFromWorker() for ClusterFuture ...
[16:06:15.829] - Validating connection of MultisessionFuture
[16:06:15.829] - received message: FutureResult
[16:06:15.829] - Received FutureResult
[16:06:15.829] - Erased future from FutureRegistry
[16:06:15.829] result() for ClusterFuture ...
[16:06:15.829] - result already collected: FutureResult
[16:06:15.829] result() for ClusterFuture ... done
[16:06:15.829] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:15.830] result() for ClusterFuture ...
[16:06:15.830] - result already collected: FutureResult
[16:06:15.830] result() for ClusterFuture ... done
[16:06:15.830] result() for ClusterFuture ...
[16:06:15.830] - result already collected: FutureResult
[16:06:15.830] result() for ClusterFuture ... done
[16:06:15.831] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[16:06:15.831] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[16:06:15.831] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[16:06:15.831] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[16:06:15.832] MultisessionFuture started
[16:06:15.832] - Launch lazy future ... done
[16:06:15.832] run() for ‘MultisessionFuture’ ... done
[16:06:15.853] Future #1
[16:06:15.853]  length: 2 (resolved future 1)
[16:06:15.853] receiveMessageFromWorker() for ClusterFuture ...
[16:06:15.853] - Validating connection of MultisessionFuture
[16:06:15.854] - received message: FutureResult
[16:06:15.854] - Received FutureResult
[16:06:15.854] - Erased future from FutureRegistry
[16:06:15.854] result() for ClusterFuture ...
[16:06:15.854] - result already collected: FutureResult
[16:06:15.854] result() for ClusterFuture ... done
[16:06:15.854] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:15.854] Future #2
[16:06:15.855]  length: 1 (resolved future 2)
[16:06:15.980] receiveMessageFromWorker() for ClusterFuture ...
[16:06:15.980] - Validating connection of MultisessionFuture
[16:06:15.980] - received message: FutureResult
[16:06:15.983] - Received FutureResult
[16:06:15.983] - Erased future from FutureRegistry
[16:06:15.983] result() for ClusterFuture ...
[16:06:15.983] - result already collected: FutureResult
[16:06:15.983] result() for ClusterFuture ... done
[16:06:15.984] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:15.984] Future #3
[16:06:15.984]  length: 0 (resolved future 3)
[16:06:15.984] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[16:06:15.985] resolve() on environment ...
[16:06:15.985]  recursive: 0
[16:06:15.985]  elements: [2] ‘a’, ‘b’
[16:06:15.985]  length: 1 (resolved future 1)
[16:06:15.986]  length: 0 (resolved future 2)
[16:06:15.986] resolve() on environment ... DONE
[16:06:15.986] getGlobalsAndPackages() ...
[16:06:15.986] Searching for globals...
[16:06:15.986] 
[16:06:15.987] Searching for globals ... DONE
[16:06:15.987] - globals: [0] <none>
[16:06:15.987] getGlobalsAndPackages() ... DONE
[16:06:15.987] run() for ‘Future’ ...
[16:06:15.987] - state: ‘created’
[16:06:15.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.001] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.001]   - Field: ‘node’
[16:06:16.001]   - Field: ‘label’
[16:06:16.001]   - Field: ‘local’
[16:06:16.001]   - Field: ‘owner’
[16:06:16.001]   - Field: ‘envir’
[16:06:16.001]   - Field: ‘workers’
[16:06:16.002]   - Field: ‘packages’
[16:06:16.002]   - Field: ‘gc’
[16:06:16.002]   - Field: ‘conditions’
[16:06:16.002]   - Field: ‘persistent’
[16:06:16.002]   - Field: ‘expr’
[16:06:16.002]   - Field: ‘uuid’
[16:06:16.002]   - Field: ‘seed’
[16:06:16.002]   - Field: ‘version’
[16:06:16.002]   - Field: ‘result’
[16:06:16.002]   - Field: ‘asynchronous’
[16:06:16.002]   - Field: ‘calls’
[16:06:16.003]   - Field: ‘globals’
[16:06:16.003]   - Field: ‘stdout’
[16:06:16.003]   - Field: ‘earlySignal’
[16:06:16.003]   - Field: ‘lazy’
[16:06:16.003]   - Field: ‘state’
[16:06:16.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.003] - Launch lazy future ...
[16:06:16.003] Packages needed by the future expression (n = 0): <none>
[16:06:16.004] Packages needed by future strategies (n = 0): <none>
[16:06:16.004] {
[16:06:16.004]     {
[16:06:16.004]         {
[16:06:16.004]             ...future.startTime <- base::Sys.time()
[16:06:16.004]             {
[16:06:16.004]                 {
[16:06:16.004]                   {
[16:06:16.004]                     {
[16:06:16.004]                       base::local({
[16:06:16.004]                         has_future <- base::requireNamespace("future", 
[16:06:16.004]                           quietly = TRUE)
[16:06:16.004]                         if (has_future) {
[16:06:16.004]                           ns <- base::getNamespace("future")
[16:06:16.004]                           version <- ns[[".package"]][["version"]]
[16:06:16.004]                           if (is.null(version)) 
[16:06:16.004]                             version <- utils::packageVersion("future")
[16:06:16.004]                         }
[16:06:16.004]                         else {
[16:06:16.004]                           version <- NULL
[16:06:16.004]                         }
[16:06:16.004]                         if (!has_future || version < "1.8.0") {
[16:06:16.004]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.004]                             "", base::R.version$version.string), 
[16:06:16.004]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.004]                               "release", "version")], collapse = " "), 
[16:06:16.004]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.004]                             info)
[16:06:16.004]                           info <- base::paste(info, collapse = "; ")
[16:06:16.004]                           if (!has_future) {
[16:06:16.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.004]                               info)
[16:06:16.004]                           }
[16:06:16.004]                           else {
[16:06:16.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.004]                               info, version)
[16:06:16.004]                           }
[16:06:16.004]                           base::stop(msg)
[16:06:16.004]                         }
[16:06:16.004]                       })
[16:06:16.004]                     }
[16:06:16.004]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.004]                     base::options(mc.cores = 1L)
[16:06:16.004]                   }
[16:06:16.004]                   options(future.plan = NULL)
[16:06:16.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.004]                 }
[16:06:16.004]                 ...future.workdir <- getwd()
[16:06:16.004]             }
[16:06:16.004]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.004]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.004]         }
[16:06:16.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.004]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.004]             base::names(...future.oldOptions))
[16:06:16.004]     }
[16:06:16.004]     if (FALSE) {
[16:06:16.004]     }
[16:06:16.004]     else {
[16:06:16.004]         if (TRUE) {
[16:06:16.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.004]                 open = "w")
[16:06:16.004]         }
[16:06:16.004]         else {
[16:06:16.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.004]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.004]         }
[16:06:16.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.004]             base::sink(type = "output", split = FALSE)
[16:06:16.004]             base::close(...future.stdout)
[16:06:16.004]         }, add = TRUE)
[16:06:16.004]     }
[16:06:16.004]     ...future.frame <- base::sys.nframe()
[16:06:16.004]     ...future.conditions <- base::list()
[16:06:16.004]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.004]     if (FALSE) {
[16:06:16.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.004]     }
[16:06:16.004]     ...future.result <- base::tryCatch({
[16:06:16.004]         base::withCallingHandlers({
[16:06:16.004]             ...future.value <- base::withVisible(base::local({
[16:06:16.004]                 ...future.makeSendCondition <- base::local({
[16:06:16.004]                   sendCondition <- NULL
[16:06:16.004]                   function(frame = 1L) {
[16:06:16.004]                     if (is.function(sendCondition)) 
[16:06:16.004]                       return(sendCondition)
[16:06:16.004]                     ns <- getNamespace("parallel")
[16:06:16.004]                     if (exists("sendData", mode = "function", 
[16:06:16.004]                       envir = ns)) {
[16:06:16.004]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.004]                         envir = ns)
[16:06:16.004]                       envir <- sys.frame(frame)
[16:06:16.004]                       master <- NULL
[16:06:16.004]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.004]                         !identical(envir, emptyenv())) {
[16:06:16.004]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.004]                           inherits = FALSE)) {
[16:06:16.004]                           master <- get("master", mode = "list", 
[16:06:16.004]                             envir = envir, inherits = FALSE)
[16:06:16.004]                           if (inherits(master, c("SOCKnode", 
[16:06:16.004]                             "SOCK0node"))) {
[16:06:16.004]                             sendCondition <<- function(cond) {
[16:06:16.004]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.004]                                 success = TRUE)
[16:06:16.004]                               parallel_sendData(master, data)
[16:06:16.004]                             }
[16:06:16.004]                             return(sendCondition)
[16:06:16.004]                           }
[16:06:16.004]                         }
[16:06:16.004]                         frame <- frame + 1L
[16:06:16.004]                         envir <- sys.frame(frame)
[16:06:16.004]                       }
[16:06:16.004]                     }
[16:06:16.004]                     sendCondition <<- function(cond) NULL
[16:06:16.004]                   }
[16:06:16.004]                 })
[16:06:16.004]                 withCallingHandlers({
[16:06:16.004]                   1
[16:06:16.004]                 }, immediateCondition = function(cond) {
[16:06:16.004]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.004]                   sendCondition(cond)
[16:06:16.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.004]                   {
[16:06:16.004]                     inherits <- base::inherits
[16:06:16.004]                     invokeRestart <- base::invokeRestart
[16:06:16.004]                     is.null <- base::is.null
[16:06:16.004]                     muffled <- FALSE
[16:06:16.004]                     if (inherits(cond, "message")) {
[16:06:16.004]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.004]                       if (muffled) 
[16:06:16.004]                         invokeRestart("muffleMessage")
[16:06:16.004]                     }
[16:06:16.004]                     else if (inherits(cond, "warning")) {
[16:06:16.004]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.004]                       if (muffled) 
[16:06:16.004]                         invokeRestart("muffleWarning")
[16:06:16.004]                     }
[16:06:16.004]                     else if (inherits(cond, "condition")) {
[16:06:16.004]                       if (!is.null(pattern)) {
[16:06:16.004]                         computeRestarts <- base::computeRestarts
[16:06:16.004]                         grepl <- base::grepl
[16:06:16.004]                         restarts <- computeRestarts(cond)
[16:06:16.004]                         for (restart in restarts) {
[16:06:16.004]                           name <- restart$name
[16:06:16.004]                           if (is.null(name)) 
[16:06:16.004]                             next
[16:06:16.004]                           if (!grepl(pattern, name)) 
[16:06:16.004]                             next
[16:06:16.004]                           invokeRestart(restart)
[16:06:16.004]                           muffled <- TRUE
[16:06:16.004]                           break
[16:06:16.004]                         }
[16:06:16.004]                       }
[16:06:16.004]                     }
[16:06:16.004]                     invisible(muffled)
[16:06:16.004]                   }
[16:06:16.004]                   muffleCondition(cond)
[16:06:16.004]                 })
[16:06:16.004]             }))
[16:06:16.004]             future::FutureResult(value = ...future.value$value, 
[16:06:16.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.004]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.004]                     ...future.globalenv.names))
[16:06:16.004]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.004]         }, condition = base::local({
[16:06:16.004]             c <- base::c
[16:06:16.004]             inherits <- base::inherits
[16:06:16.004]             invokeRestart <- base::invokeRestart
[16:06:16.004]             length <- base::length
[16:06:16.004]             list <- base::list
[16:06:16.004]             seq.int <- base::seq.int
[16:06:16.004]             signalCondition <- base::signalCondition
[16:06:16.004]             sys.calls <- base::sys.calls
[16:06:16.004]             `[[` <- base::`[[`
[16:06:16.004]             `+` <- base::`+`
[16:06:16.004]             `<<-` <- base::`<<-`
[16:06:16.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.004]                   3L)]
[16:06:16.004]             }
[16:06:16.004]             function(cond) {
[16:06:16.004]                 is_error <- inherits(cond, "error")
[16:06:16.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.004]                   NULL)
[16:06:16.004]                 if (is_error) {
[16:06:16.004]                   sessionInformation <- function() {
[16:06:16.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.004]                       search = base::search(), system = base::Sys.info())
[16:06:16.004]                   }
[16:06:16.004]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.004]                     cond$call), session = sessionInformation(), 
[16:06:16.004]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.004]                   signalCondition(cond)
[16:06:16.004]                 }
[16:06:16.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.004]                 "immediateCondition"))) {
[16:06:16.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.004]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.004]                   if (TRUE && !signal) {
[16:06:16.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.004]                     {
[16:06:16.004]                       inherits <- base::inherits
[16:06:16.004]                       invokeRestart <- base::invokeRestart
[16:06:16.004]                       is.null <- base::is.null
[16:06:16.004]                       muffled <- FALSE
[16:06:16.004]                       if (inherits(cond, "message")) {
[16:06:16.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.004]                         if (muffled) 
[16:06:16.004]                           invokeRestart("muffleMessage")
[16:06:16.004]                       }
[16:06:16.004]                       else if (inherits(cond, "warning")) {
[16:06:16.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.004]                         if (muffled) 
[16:06:16.004]                           invokeRestart("muffleWarning")
[16:06:16.004]                       }
[16:06:16.004]                       else if (inherits(cond, "condition")) {
[16:06:16.004]                         if (!is.null(pattern)) {
[16:06:16.004]                           computeRestarts <- base::computeRestarts
[16:06:16.004]                           grepl <- base::grepl
[16:06:16.004]                           restarts <- computeRestarts(cond)
[16:06:16.004]                           for (restart in restarts) {
[16:06:16.004]                             name <- restart$name
[16:06:16.004]                             if (is.null(name)) 
[16:06:16.004]                               next
[16:06:16.004]                             if (!grepl(pattern, name)) 
[16:06:16.004]                               next
[16:06:16.004]                             invokeRestart(restart)
[16:06:16.004]                             muffled <- TRUE
[16:06:16.004]                             break
[16:06:16.004]                           }
[16:06:16.004]                         }
[16:06:16.004]                       }
[16:06:16.004]                       invisible(muffled)
[16:06:16.004]                     }
[16:06:16.004]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.004]                   }
[16:06:16.004]                 }
[16:06:16.004]                 else {
[16:06:16.004]                   if (TRUE) {
[16:06:16.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.004]                     {
[16:06:16.004]                       inherits <- base::inherits
[16:06:16.004]                       invokeRestart <- base::invokeRestart
[16:06:16.004]                       is.null <- base::is.null
[16:06:16.004]                       muffled <- FALSE
[16:06:16.004]                       if (inherits(cond, "message")) {
[16:06:16.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.004]                         if (muffled) 
[16:06:16.004]                           invokeRestart("muffleMessage")
[16:06:16.004]                       }
[16:06:16.004]                       else if (inherits(cond, "warning")) {
[16:06:16.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.004]                         if (muffled) 
[16:06:16.004]                           invokeRestart("muffleWarning")
[16:06:16.004]                       }
[16:06:16.004]                       else if (inherits(cond, "condition")) {
[16:06:16.004]                         if (!is.null(pattern)) {
[16:06:16.004]                           computeRestarts <- base::computeRestarts
[16:06:16.004]                           grepl <- base::grepl
[16:06:16.004]                           restarts <- computeRestarts(cond)
[16:06:16.004]                           for (restart in restarts) {
[16:06:16.004]                             name <- restart$name
[16:06:16.004]                             if (is.null(name)) 
[16:06:16.004]                               next
[16:06:16.004]                             if (!grepl(pattern, name)) 
[16:06:16.004]                               next
[16:06:16.004]                             invokeRestart(restart)
[16:06:16.004]                             muffled <- TRUE
[16:06:16.004]                             break
[16:06:16.004]                           }
[16:06:16.004]                         }
[16:06:16.004]                       }
[16:06:16.004]                       invisible(muffled)
[16:06:16.004]                     }
[16:06:16.004]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.004]                   }
[16:06:16.004]                 }
[16:06:16.004]             }
[16:06:16.004]         }))
[16:06:16.004]     }, error = function(ex) {
[16:06:16.004]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.004]                 ...future.rng), started = ...future.startTime, 
[16:06:16.004]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.004]             version = "1.8"), class = "FutureResult")
[16:06:16.004]     }, finally = {
[16:06:16.004]         if (!identical(...future.workdir, getwd())) 
[16:06:16.004]             setwd(...future.workdir)
[16:06:16.004]         {
[16:06:16.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.004]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.004]             }
[16:06:16.004]             base::options(...future.oldOptions)
[16:06:16.004]             if (.Platform$OS.type == "windows") {
[16:06:16.004]                 old_names <- names(...future.oldEnvVars)
[16:06:16.004]                 envs <- base::Sys.getenv()
[16:06:16.004]                 names <- names(envs)
[16:06:16.004]                 common <- intersect(names, old_names)
[16:06:16.004]                 added <- setdiff(names, old_names)
[16:06:16.004]                 removed <- setdiff(old_names, names)
[16:06:16.004]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.004]                   envs[common]]
[16:06:16.004]                 NAMES <- toupper(changed)
[16:06:16.004]                 args <- list()
[16:06:16.004]                 for (kk in seq_along(NAMES)) {
[16:06:16.004]                   name <- changed[[kk]]
[16:06:16.004]                   NAME <- NAMES[[kk]]
[16:06:16.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.004]                     next
[16:06:16.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.004]                 }
[16:06:16.004]                 NAMES <- toupper(added)
[16:06:16.004]                 for (kk in seq_along(NAMES)) {
[16:06:16.004]                   name <- added[[kk]]
[16:06:16.004]                   NAME <- NAMES[[kk]]
[16:06:16.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.004]                     next
[16:06:16.004]                   args[[name]] <- ""
[16:06:16.004]                 }
[16:06:16.004]                 NAMES <- toupper(removed)
[16:06:16.004]                 for (kk in seq_along(NAMES)) {
[16:06:16.004]                   name <- removed[[kk]]
[16:06:16.004]                   NAME <- NAMES[[kk]]
[16:06:16.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.004]                     next
[16:06:16.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.004]                 }
[16:06:16.004]                 if (length(args) > 0) 
[16:06:16.004]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.004]             }
[16:06:16.004]             else {
[16:06:16.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.004]             }
[16:06:16.004]             {
[16:06:16.004]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.004]                   0L) {
[16:06:16.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.004]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.004]                   base::options(opts)
[16:06:16.004]                 }
[16:06:16.004]                 {
[16:06:16.004]                   {
[16:06:16.004]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.004]                     NULL
[16:06:16.004]                   }
[16:06:16.004]                   options(future.plan = NULL)
[16:06:16.004]                   if (is.na(NA_character_)) 
[16:06:16.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.004]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.004]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.004]                     envir = parent.frame()) 
[16:06:16.004]                   {
[16:06:16.004]                     if (is.function(workers)) 
[16:06:16.004]                       workers <- workers()
[16:06:16.004]                     workers <- structure(as.integer(workers), 
[16:06:16.004]                       class = class(workers))
[16:06:16.004]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.004]                       workers >= 1)
[16:06:16.004]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.004]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.004]                     }
[16:06:16.004]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.004]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.004]                       envir = envir)
[16:06:16.004]                     if (!future$lazy) 
[16:06:16.004]                       future <- run(future)
[16:06:16.004]                     invisible(future)
[16:06:16.004]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.004]                 }
[16:06:16.004]             }
[16:06:16.004]         }
[16:06:16.004]     })
[16:06:16.004]     if (TRUE) {
[16:06:16.004]         base::sink(type = "output", split = FALSE)
[16:06:16.004]         if (TRUE) {
[16:06:16.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.004]         }
[16:06:16.004]         else {
[16:06:16.004]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.004]         }
[16:06:16.004]         base::close(...future.stdout)
[16:06:16.004]         ...future.stdout <- NULL
[16:06:16.004]     }
[16:06:16.004]     ...future.result$conditions <- ...future.conditions
[16:06:16.004]     ...future.result$finished <- base::Sys.time()
[16:06:16.004]     ...future.result
[16:06:16.004] }
[16:06:16.007] MultisessionFuture started
[16:06:16.007] - Launch lazy future ... done
[16:06:16.007] run() for ‘MultisessionFuture’ ... done
[16:06:16.007] getGlobalsAndPackages() ...
[16:06:16.007] Searching for globals...
[16:06:16.008] 
[16:06:16.008] Searching for globals ... DONE
[16:06:16.008] - globals: [0] <none>
[16:06:16.008] getGlobalsAndPackages() ... DONE
[16:06:16.008] run() for ‘Future’ ...
[16:06:16.008] - state: ‘created’
[16:06:16.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.022]   - Field: ‘node’
[16:06:16.022]   - Field: ‘label’
[16:06:16.022]   - Field: ‘local’
[16:06:16.022]   - Field: ‘owner’
[16:06:16.023]   - Field: ‘envir’
[16:06:16.023]   - Field: ‘workers’
[16:06:16.023]   - Field: ‘packages’
[16:06:16.023]   - Field: ‘gc’
[16:06:16.023]   - Field: ‘conditions’
[16:06:16.023]   - Field: ‘persistent’
[16:06:16.023]   - Field: ‘expr’
[16:06:16.023]   - Field: ‘uuid’
[16:06:16.023]   - Field: ‘seed’
[16:06:16.023]   - Field: ‘version’
[16:06:16.023]   - Field: ‘result’
[16:06:16.024]   - Field: ‘asynchronous’
[16:06:16.024]   - Field: ‘calls’
[16:06:16.024]   - Field: ‘globals’
[16:06:16.024]   - Field: ‘stdout’
[16:06:16.024]   - Field: ‘earlySignal’
[16:06:16.024]   - Field: ‘lazy’
[16:06:16.024]   - Field: ‘state’
[16:06:16.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.024] - Launch lazy future ...
[16:06:16.025] Packages needed by the future expression (n = 0): <none>
[16:06:16.025] Packages needed by future strategies (n = 0): <none>
[16:06:16.025] {
[16:06:16.025]     {
[16:06:16.025]         {
[16:06:16.025]             ...future.startTime <- base::Sys.time()
[16:06:16.025]             {
[16:06:16.025]                 {
[16:06:16.025]                   {
[16:06:16.025]                     {
[16:06:16.025]                       base::local({
[16:06:16.025]                         has_future <- base::requireNamespace("future", 
[16:06:16.025]                           quietly = TRUE)
[16:06:16.025]                         if (has_future) {
[16:06:16.025]                           ns <- base::getNamespace("future")
[16:06:16.025]                           version <- ns[[".package"]][["version"]]
[16:06:16.025]                           if (is.null(version)) 
[16:06:16.025]                             version <- utils::packageVersion("future")
[16:06:16.025]                         }
[16:06:16.025]                         else {
[16:06:16.025]                           version <- NULL
[16:06:16.025]                         }
[16:06:16.025]                         if (!has_future || version < "1.8.0") {
[16:06:16.025]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.025]                             "", base::R.version$version.string), 
[16:06:16.025]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.025]                               "release", "version")], collapse = " "), 
[16:06:16.025]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.025]                             info)
[16:06:16.025]                           info <- base::paste(info, collapse = "; ")
[16:06:16.025]                           if (!has_future) {
[16:06:16.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.025]                               info)
[16:06:16.025]                           }
[16:06:16.025]                           else {
[16:06:16.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.025]                               info, version)
[16:06:16.025]                           }
[16:06:16.025]                           base::stop(msg)
[16:06:16.025]                         }
[16:06:16.025]                       })
[16:06:16.025]                     }
[16:06:16.025]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.025]                     base::options(mc.cores = 1L)
[16:06:16.025]                   }
[16:06:16.025]                   options(future.plan = NULL)
[16:06:16.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.025]                 }
[16:06:16.025]                 ...future.workdir <- getwd()
[16:06:16.025]             }
[16:06:16.025]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.025]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.025]         }
[16:06:16.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.025]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.025]             base::names(...future.oldOptions))
[16:06:16.025]     }
[16:06:16.025]     if (FALSE) {
[16:06:16.025]     }
[16:06:16.025]     else {
[16:06:16.025]         if (TRUE) {
[16:06:16.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.025]                 open = "w")
[16:06:16.025]         }
[16:06:16.025]         else {
[16:06:16.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.025]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.025]         }
[16:06:16.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.025]             base::sink(type = "output", split = FALSE)
[16:06:16.025]             base::close(...future.stdout)
[16:06:16.025]         }, add = TRUE)
[16:06:16.025]     }
[16:06:16.025]     ...future.frame <- base::sys.nframe()
[16:06:16.025]     ...future.conditions <- base::list()
[16:06:16.025]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.025]     if (FALSE) {
[16:06:16.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.025]     }
[16:06:16.025]     ...future.result <- base::tryCatch({
[16:06:16.025]         base::withCallingHandlers({
[16:06:16.025]             ...future.value <- base::withVisible(base::local({
[16:06:16.025]                 ...future.makeSendCondition <- base::local({
[16:06:16.025]                   sendCondition <- NULL
[16:06:16.025]                   function(frame = 1L) {
[16:06:16.025]                     if (is.function(sendCondition)) 
[16:06:16.025]                       return(sendCondition)
[16:06:16.025]                     ns <- getNamespace("parallel")
[16:06:16.025]                     if (exists("sendData", mode = "function", 
[16:06:16.025]                       envir = ns)) {
[16:06:16.025]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.025]                         envir = ns)
[16:06:16.025]                       envir <- sys.frame(frame)
[16:06:16.025]                       master <- NULL
[16:06:16.025]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.025]                         !identical(envir, emptyenv())) {
[16:06:16.025]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.025]                           inherits = FALSE)) {
[16:06:16.025]                           master <- get("master", mode = "list", 
[16:06:16.025]                             envir = envir, inherits = FALSE)
[16:06:16.025]                           if (inherits(master, c("SOCKnode", 
[16:06:16.025]                             "SOCK0node"))) {
[16:06:16.025]                             sendCondition <<- function(cond) {
[16:06:16.025]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.025]                                 success = TRUE)
[16:06:16.025]                               parallel_sendData(master, data)
[16:06:16.025]                             }
[16:06:16.025]                             return(sendCondition)
[16:06:16.025]                           }
[16:06:16.025]                         }
[16:06:16.025]                         frame <- frame + 1L
[16:06:16.025]                         envir <- sys.frame(frame)
[16:06:16.025]                       }
[16:06:16.025]                     }
[16:06:16.025]                     sendCondition <<- function(cond) NULL
[16:06:16.025]                   }
[16:06:16.025]                 })
[16:06:16.025]                 withCallingHandlers({
[16:06:16.025]                   2
[16:06:16.025]                 }, immediateCondition = function(cond) {
[16:06:16.025]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.025]                   sendCondition(cond)
[16:06:16.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.025]                   {
[16:06:16.025]                     inherits <- base::inherits
[16:06:16.025]                     invokeRestart <- base::invokeRestart
[16:06:16.025]                     is.null <- base::is.null
[16:06:16.025]                     muffled <- FALSE
[16:06:16.025]                     if (inherits(cond, "message")) {
[16:06:16.025]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.025]                       if (muffled) 
[16:06:16.025]                         invokeRestart("muffleMessage")
[16:06:16.025]                     }
[16:06:16.025]                     else if (inherits(cond, "warning")) {
[16:06:16.025]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.025]                       if (muffled) 
[16:06:16.025]                         invokeRestart("muffleWarning")
[16:06:16.025]                     }
[16:06:16.025]                     else if (inherits(cond, "condition")) {
[16:06:16.025]                       if (!is.null(pattern)) {
[16:06:16.025]                         computeRestarts <- base::computeRestarts
[16:06:16.025]                         grepl <- base::grepl
[16:06:16.025]                         restarts <- computeRestarts(cond)
[16:06:16.025]                         for (restart in restarts) {
[16:06:16.025]                           name <- restart$name
[16:06:16.025]                           if (is.null(name)) 
[16:06:16.025]                             next
[16:06:16.025]                           if (!grepl(pattern, name)) 
[16:06:16.025]                             next
[16:06:16.025]                           invokeRestart(restart)
[16:06:16.025]                           muffled <- TRUE
[16:06:16.025]                           break
[16:06:16.025]                         }
[16:06:16.025]                       }
[16:06:16.025]                     }
[16:06:16.025]                     invisible(muffled)
[16:06:16.025]                   }
[16:06:16.025]                   muffleCondition(cond)
[16:06:16.025]                 })
[16:06:16.025]             }))
[16:06:16.025]             future::FutureResult(value = ...future.value$value, 
[16:06:16.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.025]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.025]                     ...future.globalenv.names))
[16:06:16.025]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.025]         }, condition = base::local({
[16:06:16.025]             c <- base::c
[16:06:16.025]             inherits <- base::inherits
[16:06:16.025]             invokeRestart <- base::invokeRestart
[16:06:16.025]             length <- base::length
[16:06:16.025]             list <- base::list
[16:06:16.025]             seq.int <- base::seq.int
[16:06:16.025]             signalCondition <- base::signalCondition
[16:06:16.025]             sys.calls <- base::sys.calls
[16:06:16.025]             `[[` <- base::`[[`
[16:06:16.025]             `+` <- base::`+`
[16:06:16.025]             `<<-` <- base::`<<-`
[16:06:16.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.025]                   3L)]
[16:06:16.025]             }
[16:06:16.025]             function(cond) {
[16:06:16.025]                 is_error <- inherits(cond, "error")
[16:06:16.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.025]                   NULL)
[16:06:16.025]                 if (is_error) {
[16:06:16.025]                   sessionInformation <- function() {
[16:06:16.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.025]                       search = base::search(), system = base::Sys.info())
[16:06:16.025]                   }
[16:06:16.025]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.025]                     cond$call), session = sessionInformation(), 
[16:06:16.025]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.025]                   signalCondition(cond)
[16:06:16.025]                 }
[16:06:16.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.025]                 "immediateCondition"))) {
[16:06:16.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.025]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.025]                   if (TRUE && !signal) {
[16:06:16.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.025]                     {
[16:06:16.025]                       inherits <- base::inherits
[16:06:16.025]                       invokeRestart <- base::invokeRestart
[16:06:16.025]                       is.null <- base::is.null
[16:06:16.025]                       muffled <- FALSE
[16:06:16.025]                       if (inherits(cond, "message")) {
[16:06:16.025]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.025]                         if (muffled) 
[16:06:16.025]                           invokeRestart("muffleMessage")
[16:06:16.025]                       }
[16:06:16.025]                       else if (inherits(cond, "warning")) {
[16:06:16.025]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.025]                         if (muffled) 
[16:06:16.025]                           invokeRestart("muffleWarning")
[16:06:16.025]                       }
[16:06:16.025]                       else if (inherits(cond, "condition")) {
[16:06:16.025]                         if (!is.null(pattern)) {
[16:06:16.025]                           computeRestarts <- base::computeRestarts
[16:06:16.025]                           grepl <- base::grepl
[16:06:16.025]                           restarts <- computeRestarts(cond)
[16:06:16.025]                           for (restart in restarts) {
[16:06:16.025]                             name <- restart$name
[16:06:16.025]                             if (is.null(name)) 
[16:06:16.025]                               next
[16:06:16.025]                             if (!grepl(pattern, name)) 
[16:06:16.025]                               next
[16:06:16.025]                             invokeRestart(restart)
[16:06:16.025]                             muffled <- TRUE
[16:06:16.025]                             break
[16:06:16.025]                           }
[16:06:16.025]                         }
[16:06:16.025]                       }
[16:06:16.025]                       invisible(muffled)
[16:06:16.025]                     }
[16:06:16.025]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.025]                   }
[16:06:16.025]                 }
[16:06:16.025]                 else {
[16:06:16.025]                   if (TRUE) {
[16:06:16.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.025]                     {
[16:06:16.025]                       inherits <- base::inherits
[16:06:16.025]                       invokeRestart <- base::invokeRestart
[16:06:16.025]                       is.null <- base::is.null
[16:06:16.025]                       muffled <- FALSE
[16:06:16.025]                       if (inherits(cond, "message")) {
[16:06:16.025]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.025]                         if (muffled) 
[16:06:16.025]                           invokeRestart("muffleMessage")
[16:06:16.025]                       }
[16:06:16.025]                       else if (inherits(cond, "warning")) {
[16:06:16.025]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.025]                         if (muffled) 
[16:06:16.025]                           invokeRestart("muffleWarning")
[16:06:16.025]                       }
[16:06:16.025]                       else if (inherits(cond, "condition")) {
[16:06:16.025]                         if (!is.null(pattern)) {
[16:06:16.025]                           computeRestarts <- base::computeRestarts
[16:06:16.025]                           grepl <- base::grepl
[16:06:16.025]                           restarts <- computeRestarts(cond)
[16:06:16.025]                           for (restart in restarts) {
[16:06:16.025]                             name <- restart$name
[16:06:16.025]                             if (is.null(name)) 
[16:06:16.025]                               next
[16:06:16.025]                             if (!grepl(pattern, name)) 
[16:06:16.025]                               next
[16:06:16.025]                             invokeRestart(restart)
[16:06:16.025]                             muffled <- TRUE
[16:06:16.025]                             break
[16:06:16.025]                           }
[16:06:16.025]                         }
[16:06:16.025]                       }
[16:06:16.025]                       invisible(muffled)
[16:06:16.025]                     }
[16:06:16.025]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.025]                   }
[16:06:16.025]                 }
[16:06:16.025]             }
[16:06:16.025]         }))
[16:06:16.025]     }, error = function(ex) {
[16:06:16.025]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.025]                 ...future.rng), started = ...future.startTime, 
[16:06:16.025]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.025]             version = "1.8"), class = "FutureResult")
[16:06:16.025]     }, finally = {
[16:06:16.025]         if (!identical(...future.workdir, getwd())) 
[16:06:16.025]             setwd(...future.workdir)
[16:06:16.025]         {
[16:06:16.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.025]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.025]             }
[16:06:16.025]             base::options(...future.oldOptions)
[16:06:16.025]             if (.Platform$OS.type == "windows") {
[16:06:16.025]                 old_names <- names(...future.oldEnvVars)
[16:06:16.025]                 envs <- base::Sys.getenv()
[16:06:16.025]                 names <- names(envs)
[16:06:16.025]                 common <- intersect(names, old_names)
[16:06:16.025]                 added <- setdiff(names, old_names)
[16:06:16.025]                 removed <- setdiff(old_names, names)
[16:06:16.025]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.025]                   envs[common]]
[16:06:16.025]                 NAMES <- toupper(changed)
[16:06:16.025]                 args <- list()
[16:06:16.025]                 for (kk in seq_along(NAMES)) {
[16:06:16.025]                   name <- changed[[kk]]
[16:06:16.025]                   NAME <- NAMES[[kk]]
[16:06:16.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.025]                     next
[16:06:16.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.025]                 }
[16:06:16.025]                 NAMES <- toupper(added)
[16:06:16.025]                 for (kk in seq_along(NAMES)) {
[16:06:16.025]                   name <- added[[kk]]
[16:06:16.025]                   NAME <- NAMES[[kk]]
[16:06:16.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.025]                     next
[16:06:16.025]                   args[[name]] <- ""
[16:06:16.025]                 }
[16:06:16.025]                 NAMES <- toupper(removed)
[16:06:16.025]                 for (kk in seq_along(NAMES)) {
[16:06:16.025]                   name <- removed[[kk]]
[16:06:16.025]                   NAME <- NAMES[[kk]]
[16:06:16.025]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.025]                     next
[16:06:16.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.025]                 }
[16:06:16.025]                 if (length(args) > 0) 
[16:06:16.025]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.025]             }
[16:06:16.025]             else {
[16:06:16.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.025]             }
[16:06:16.025]             {
[16:06:16.025]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.025]                   0L) {
[16:06:16.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.025]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.025]                   base::options(opts)
[16:06:16.025]                 }
[16:06:16.025]                 {
[16:06:16.025]                   {
[16:06:16.025]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.025]                     NULL
[16:06:16.025]                   }
[16:06:16.025]                   options(future.plan = NULL)
[16:06:16.025]                   if (is.na(NA_character_)) 
[16:06:16.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.025]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.025]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.025]                     envir = parent.frame()) 
[16:06:16.025]                   {
[16:06:16.025]                     if (is.function(workers)) 
[16:06:16.025]                       workers <- workers()
[16:06:16.025]                     workers <- structure(as.integer(workers), 
[16:06:16.025]                       class = class(workers))
[16:06:16.025]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.025]                       workers >= 1)
[16:06:16.025]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.025]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.025]                     }
[16:06:16.025]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.025]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.025]                       envir = envir)
[16:06:16.025]                     if (!future$lazy) 
[16:06:16.025]                       future <- run(future)
[16:06:16.025]                     invisible(future)
[16:06:16.025]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.025]                 }
[16:06:16.025]             }
[16:06:16.025]         }
[16:06:16.025]     })
[16:06:16.025]     if (TRUE) {
[16:06:16.025]         base::sink(type = "output", split = FALSE)
[16:06:16.025]         if (TRUE) {
[16:06:16.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.025]         }
[16:06:16.025]         else {
[16:06:16.025]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.025]         }
[16:06:16.025]         base::close(...future.stdout)
[16:06:16.025]         ...future.stdout <- NULL
[16:06:16.025]     }
[16:06:16.025]     ...future.result$conditions <- ...future.conditions
[16:06:16.025]     ...future.result$finished <- base::Sys.time()
[16:06:16.025]     ...future.result
[16:06:16.025] }
[16:06:16.028] MultisessionFuture started
[16:06:16.028] - Launch lazy future ... done
[16:06:16.028] run() for ‘MultisessionFuture’ ... done
[16:06:16.029] resolve() on environment ...
[16:06:16.029]  recursive: 0
[16:06:16.030]  elements: [3] ‘a’, ‘b’, ‘c’
[16:06:16.050]  length: 2 (resolved future 3)
[16:06:16.061] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.061] - Validating connection of MultisessionFuture
[16:06:16.062] - received message: FutureResult
[16:06:16.062] - Received FutureResult
[16:06:16.062] - Erased future from FutureRegistry
[16:06:16.062] result() for ClusterFuture ...
[16:06:16.062] - result already collected: FutureResult
[16:06:16.062] result() for ClusterFuture ... done
[16:06:16.062] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.062] Future #1
[16:06:16.062]  length: 1 (resolved future 1)
[16:06:16.083] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.084] - Validating connection of MultisessionFuture
[16:06:16.084] - received message: FutureResult
[16:06:16.084] - Received FutureResult
[16:06:16.084] - Erased future from FutureRegistry
[16:06:16.084] result() for ClusterFuture ...
[16:06:16.084] - result already collected: FutureResult
[16:06:16.084] result() for ClusterFuture ... done
[16:06:16.084] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.084] Future #2
[16:06:16.084]  length: 0 (resolved future 2)
[16:06:16.085] resolve() on environment ... DONE
[16:06:16.085] getGlobalsAndPackages() ...
[16:06:16.085] Searching for globals...
[16:06:16.086] - globals found: [1] ‘{’
[16:06:16.086] Searching for globals ... DONE
[16:06:16.086] Resolving globals: FALSE
[16:06:16.086] 
[16:06:16.086] 
[16:06:16.087] getGlobalsAndPackages() ... DONE
[16:06:16.087] run() for ‘Future’ ...
[16:06:16.087] - state: ‘created’
[16:06:16.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.101]   - Field: ‘node’
[16:06:16.101]   - Field: ‘label’
[16:06:16.101]   - Field: ‘local’
[16:06:16.101]   - Field: ‘owner’
[16:06:16.101]   - Field: ‘envir’
[16:06:16.101]   - Field: ‘workers’
[16:06:16.101]   - Field: ‘packages’
[16:06:16.101]   - Field: ‘gc’
[16:06:16.101]   - Field: ‘conditions’
[16:06:16.101]   - Field: ‘persistent’
[16:06:16.101]   - Field: ‘expr’
[16:06:16.102]   - Field: ‘uuid’
[16:06:16.102]   - Field: ‘seed’
[16:06:16.102]   - Field: ‘version’
[16:06:16.102]   - Field: ‘result’
[16:06:16.102]   - Field: ‘asynchronous’
[16:06:16.102]   - Field: ‘calls’
[16:06:16.102]   - Field: ‘globals’
[16:06:16.102]   - Field: ‘stdout’
[16:06:16.102]   - Field: ‘earlySignal’
[16:06:16.102]   - Field: ‘lazy’
[16:06:16.102]   - Field: ‘state’
[16:06:16.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.103] - Launch lazy future ...
[16:06:16.103] Packages needed by the future expression (n = 0): <none>
[16:06:16.103] Packages needed by future strategies (n = 0): <none>
[16:06:16.104] {
[16:06:16.104]     {
[16:06:16.104]         {
[16:06:16.104]             ...future.startTime <- base::Sys.time()
[16:06:16.104]             {
[16:06:16.104]                 {
[16:06:16.104]                   {
[16:06:16.104]                     {
[16:06:16.104]                       base::local({
[16:06:16.104]                         has_future <- base::requireNamespace("future", 
[16:06:16.104]                           quietly = TRUE)
[16:06:16.104]                         if (has_future) {
[16:06:16.104]                           ns <- base::getNamespace("future")
[16:06:16.104]                           version <- ns[[".package"]][["version"]]
[16:06:16.104]                           if (is.null(version)) 
[16:06:16.104]                             version <- utils::packageVersion("future")
[16:06:16.104]                         }
[16:06:16.104]                         else {
[16:06:16.104]                           version <- NULL
[16:06:16.104]                         }
[16:06:16.104]                         if (!has_future || version < "1.8.0") {
[16:06:16.104]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.104]                             "", base::R.version$version.string), 
[16:06:16.104]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.104]                               "release", "version")], collapse = " "), 
[16:06:16.104]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.104]                             info)
[16:06:16.104]                           info <- base::paste(info, collapse = "; ")
[16:06:16.104]                           if (!has_future) {
[16:06:16.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.104]                               info)
[16:06:16.104]                           }
[16:06:16.104]                           else {
[16:06:16.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.104]                               info, version)
[16:06:16.104]                           }
[16:06:16.104]                           base::stop(msg)
[16:06:16.104]                         }
[16:06:16.104]                       })
[16:06:16.104]                     }
[16:06:16.104]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.104]                     base::options(mc.cores = 1L)
[16:06:16.104]                   }
[16:06:16.104]                   options(future.plan = NULL)
[16:06:16.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.104]                 }
[16:06:16.104]                 ...future.workdir <- getwd()
[16:06:16.104]             }
[16:06:16.104]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.104]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.104]         }
[16:06:16.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.104]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.104]             base::names(...future.oldOptions))
[16:06:16.104]     }
[16:06:16.104]     if (FALSE) {
[16:06:16.104]     }
[16:06:16.104]     else {
[16:06:16.104]         if (TRUE) {
[16:06:16.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.104]                 open = "w")
[16:06:16.104]         }
[16:06:16.104]         else {
[16:06:16.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.104]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.104]         }
[16:06:16.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.104]             base::sink(type = "output", split = FALSE)
[16:06:16.104]             base::close(...future.stdout)
[16:06:16.104]         }, add = TRUE)
[16:06:16.104]     }
[16:06:16.104]     ...future.frame <- base::sys.nframe()
[16:06:16.104]     ...future.conditions <- base::list()
[16:06:16.104]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.104]     if (FALSE) {
[16:06:16.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.104]     }
[16:06:16.104]     ...future.result <- base::tryCatch({
[16:06:16.104]         base::withCallingHandlers({
[16:06:16.104]             ...future.value <- base::withVisible(base::local({
[16:06:16.104]                 ...future.makeSendCondition <- base::local({
[16:06:16.104]                   sendCondition <- NULL
[16:06:16.104]                   function(frame = 1L) {
[16:06:16.104]                     if (is.function(sendCondition)) 
[16:06:16.104]                       return(sendCondition)
[16:06:16.104]                     ns <- getNamespace("parallel")
[16:06:16.104]                     if (exists("sendData", mode = "function", 
[16:06:16.104]                       envir = ns)) {
[16:06:16.104]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.104]                         envir = ns)
[16:06:16.104]                       envir <- sys.frame(frame)
[16:06:16.104]                       master <- NULL
[16:06:16.104]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.104]                         !identical(envir, emptyenv())) {
[16:06:16.104]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.104]                           inherits = FALSE)) {
[16:06:16.104]                           master <- get("master", mode = "list", 
[16:06:16.104]                             envir = envir, inherits = FALSE)
[16:06:16.104]                           if (inherits(master, c("SOCKnode", 
[16:06:16.104]                             "SOCK0node"))) {
[16:06:16.104]                             sendCondition <<- function(cond) {
[16:06:16.104]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.104]                                 success = TRUE)
[16:06:16.104]                               parallel_sendData(master, data)
[16:06:16.104]                             }
[16:06:16.104]                             return(sendCondition)
[16:06:16.104]                           }
[16:06:16.104]                         }
[16:06:16.104]                         frame <- frame + 1L
[16:06:16.104]                         envir <- sys.frame(frame)
[16:06:16.104]                       }
[16:06:16.104]                     }
[16:06:16.104]                     sendCondition <<- function(cond) NULL
[16:06:16.104]                   }
[16:06:16.104]                 })
[16:06:16.104]                 withCallingHandlers({
[16:06:16.104]                   {
[16:06:16.104]                     1
[16:06:16.104]                   }
[16:06:16.104]                 }, immediateCondition = function(cond) {
[16:06:16.104]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.104]                   sendCondition(cond)
[16:06:16.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.104]                   {
[16:06:16.104]                     inherits <- base::inherits
[16:06:16.104]                     invokeRestart <- base::invokeRestart
[16:06:16.104]                     is.null <- base::is.null
[16:06:16.104]                     muffled <- FALSE
[16:06:16.104]                     if (inherits(cond, "message")) {
[16:06:16.104]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.104]                       if (muffled) 
[16:06:16.104]                         invokeRestart("muffleMessage")
[16:06:16.104]                     }
[16:06:16.104]                     else if (inherits(cond, "warning")) {
[16:06:16.104]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.104]                       if (muffled) 
[16:06:16.104]                         invokeRestart("muffleWarning")
[16:06:16.104]                     }
[16:06:16.104]                     else if (inherits(cond, "condition")) {
[16:06:16.104]                       if (!is.null(pattern)) {
[16:06:16.104]                         computeRestarts <- base::computeRestarts
[16:06:16.104]                         grepl <- base::grepl
[16:06:16.104]                         restarts <- computeRestarts(cond)
[16:06:16.104]                         for (restart in restarts) {
[16:06:16.104]                           name <- restart$name
[16:06:16.104]                           if (is.null(name)) 
[16:06:16.104]                             next
[16:06:16.104]                           if (!grepl(pattern, name)) 
[16:06:16.104]                             next
[16:06:16.104]                           invokeRestart(restart)
[16:06:16.104]                           muffled <- TRUE
[16:06:16.104]                           break
[16:06:16.104]                         }
[16:06:16.104]                       }
[16:06:16.104]                     }
[16:06:16.104]                     invisible(muffled)
[16:06:16.104]                   }
[16:06:16.104]                   muffleCondition(cond)
[16:06:16.104]                 })
[16:06:16.104]             }))
[16:06:16.104]             future::FutureResult(value = ...future.value$value, 
[16:06:16.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.104]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.104]                     ...future.globalenv.names))
[16:06:16.104]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.104]         }, condition = base::local({
[16:06:16.104]             c <- base::c
[16:06:16.104]             inherits <- base::inherits
[16:06:16.104]             invokeRestart <- base::invokeRestart
[16:06:16.104]             length <- base::length
[16:06:16.104]             list <- base::list
[16:06:16.104]             seq.int <- base::seq.int
[16:06:16.104]             signalCondition <- base::signalCondition
[16:06:16.104]             sys.calls <- base::sys.calls
[16:06:16.104]             `[[` <- base::`[[`
[16:06:16.104]             `+` <- base::`+`
[16:06:16.104]             `<<-` <- base::`<<-`
[16:06:16.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.104]                   3L)]
[16:06:16.104]             }
[16:06:16.104]             function(cond) {
[16:06:16.104]                 is_error <- inherits(cond, "error")
[16:06:16.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.104]                   NULL)
[16:06:16.104]                 if (is_error) {
[16:06:16.104]                   sessionInformation <- function() {
[16:06:16.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.104]                       search = base::search(), system = base::Sys.info())
[16:06:16.104]                   }
[16:06:16.104]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.104]                     cond$call), session = sessionInformation(), 
[16:06:16.104]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.104]                   signalCondition(cond)
[16:06:16.104]                 }
[16:06:16.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.104]                 "immediateCondition"))) {
[16:06:16.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.104]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.104]                   if (TRUE && !signal) {
[16:06:16.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.104]                     {
[16:06:16.104]                       inherits <- base::inherits
[16:06:16.104]                       invokeRestart <- base::invokeRestart
[16:06:16.104]                       is.null <- base::is.null
[16:06:16.104]                       muffled <- FALSE
[16:06:16.104]                       if (inherits(cond, "message")) {
[16:06:16.104]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.104]                         if (muffled) 
[16:06:16.104]                           invokeRestart("muffleMessage")
[16:06:16.104]                       }
[16:06:16.104]                       else if (inherits(cond, "warning")) {
[16:06:16.104]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.104]                         if (muffled) 
[16:06:16.104]                           invokeRestart("muffleWarning")
[16:06:16.104]                       }
[16:06:16.104]                       else if (inherits(cond, "condition")) {
[16:06:16.104]                         if (!is.null(pattern)) {
[16:06:16.104]                           computeRestarts <- base::computeRestarts
[16:06:16.104]                           grepl <- base::grepl
[16:06:16.104]                           restarts <- computeRestarts(cond)
[16:06:16.104]                           for (restart in restarts) {
[16:06:16.104]                             name <- restart$name
[16:06:16.104]                             if (is.null(name)) 
[16:06:16.104]                               next
[16:06:16.104]                             if (!grepl(pattern, name)) 
[16:06:16.104]                               next
[16:06:16.104]                             invokeRestart(restart)
[16:06:16.104]                             muffled <- TRUE
[16:06:16.104]                             break
[16:06:16.104]                           }
[16:06:16.104]                         }
[16:06:16.104]                       }
[16:06:16.104]                       invisible(muffled)
[16:06:16.104]                     }
[16:06:16.104]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.104]                   }
[16:06:16.104]                 }
[16:06:16.104]                 else {
[16:06:16.104]                   if (TRUE) {
[16:06:16.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.104]                     {
[16:06:16.104]                       inherits <- base::inherits
[16:06:16.104]                       invokeRestart <- base::invokeRestart
[16:06:16.104]                       is.null <- base::is.null
[16:06:16.104]                       muffled <- FALSE
[16:06:16.104]                       if (inherits(cond, "message")) {
[16:06:16.104]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.104]                         if (muffled) 
[16:06:16.104]                           invokeRestart("muffleMessage")
[16:06:16.104]                       }
[16:06:16.104]                       else if (inherits(cond, "warning")) {
[16:06:16.104]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.104]                         if (muffled) 
[16:06:16.104]                           invokeRestart("muffleWarning")
[16:06:16.104]                       }
[16:06:16.104]                       else if (inherits(cond, "condition")) {
[16:06:16.104]                         if (!is.null(pattern)) {
[16:06:16.104]                           computeRestarts <- base::computeRestarts
[16:06:16.104]                           grepl <- base::grepl
[16:06:16.104]                           restarts <- computeRestarts(cond)
[16:06:16.104]                           for (restart in restarts) {
[16:06:16.104]                             name <- restart$name
[16:06:16.104]                             if (is.null(name)) 
[16:06:16.104]                               next
[16:06:16.104]                             if (!grepl(pattern, name)) 
[16:06:16.104]                               next
[16:06:16.104]                             invokeRestart(restart)
[16:06:16.104]                             muffled <- TRUE
[16:06:16.104]                             break
[16:06:16.104]                           }
[16:06:16.104]                         }
[16:06:16.104]                       }
[16:06:16.104]                       invisible(muffled)
[16:06:16.104]                     }
[16:06:16.104]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.104]                   }
[16:06:16.104]                 }
[16:06:16.104]             }
[16:06:16.104]         }))
[16:06:16.104]     }, error = function(ex) {
[16:06:16.104]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.104]                 ...future.rng), started = ...future.startTime, 
[16:06:16.104]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.104]             version = "1.8"), class = "FutureResult")
[16:06:16.104]     }, finally = {
[16:06:16.104]         if (!identical(...future.workdir, getwd())) 
[16:06:16.104]             setwd(...future.workdir)
[16:06:16.104]         {
[16:06:16.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.104]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.104]             }
[16:06:16.104]             base::options(...future.oldOptions)
[16:06:16.104]             if (.Platform$OS.type == "windows") {
[16:06:16.104]                 old_names <- names(...future.oldEnvVars)
[16:06:16.104]                 envs <- base::Sys.getenv()
[16:06:16.104]                 names <- names(envs)
[16:06:16.104]                 common <- intersect(names, old_names)
[16:06:16.104]                 added <- setdiff(names, old_names)
[16:06:16.104]                 removed <- setdiff(old_names, names)
[16:06:16.104]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.104]                   envs[common]]
[16:06:16.104]                 NAMES <- toupper(changed)
[16:06:16.104]                 args <- list()
[16:06:16.104]                 for (kk in seq_along(NAMES)) {
[16:06:16.104]                   name <- changed[[kk]]
[16:06:16.104]                   NAME <- NAMES[[kk]]
[16:06:16.104]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.104]                     next
[16:06:16.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.104]                 }
[16:06:16.104]                 NAMES <- toupper(added)
[16:06:16.104]                 for (kk in seq_along(NAMES)) {
[16:06:16.104]                   name <- added[[kk]]
[16:06:16.104]                   NAME <- NAMES[[kk]]
[16:06:16.104]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.104]                     next
[16:06:16.104]                   args[[name]] <- ""
[16:06:16.104]                 }
[16:06:16.104]                 NAMES <- toupper(removed)
[16:06:16.104]                 for (kk in seq_along(NAMES)) {
[16:06:16.104]                   name <- removed[[kk]]
[16:06:16.104]                   NAME <- NAMES[[kk]]
[16:06:16.104]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.104]                     next
[16:06:16.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.104]                 }
[16:06:16.104]                 if (length(args) > 0) 
[16:06:16.104]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.104]             }
[16:06:16.104]             else {
[16:06:16.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.104]             }
[16:06:16.104]             {
[16:06:16.104]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.104]                   0L) {
[16:06:16.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.104]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.104]                   base::options(opts)
[16:06:16.104]                 }
[16:06:16.104]                 {
[16:06:16.104]                   {
[16:06:16.104]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.104]                     NULL
[16:06:16.104]                   }
[16:06:16.104]                   options(future.plan = NULL)
[16:06:16.104]                   if (is.na(NA_character_)) 
[16:06:16.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.104]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.104]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.104]                     envir = parent.frame()) 
[16:06:16.104]                   {
[16:06:16.104]                     if (is.function(workers)) 
[16:06:16.104]                       workers <- workers()
[16:06:16.104]                     workers <- structure(as.integer(workers), 
[16:06:16.104]                       class = class(workers))
[16:06:16.104]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.104]                       workers >= 1)
[16:06:16.104]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.104]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.104]                     }
[16:06:16.104]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.104]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.104]                       envir = envir)
[16:06:16.104]                     if (!future$lazy) 
[16:06:16.104]                       future <- run(future)
[16:06:16.104]                     invisible(future)
[16:06:16.104]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.104]                 }
[16:06:16.104]             }
[16:06:16.104]         }
[16:06:16.104]     })
[16:06:16.104]     if (TRUE) {
[16:06:16.104]         base::sink(type = "output", split = FALSE)
[16:06:16.104]         if (TRUE) {
[16:06:16.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.104]         }
[16:06:16.104]         else {
[16:06:16.104]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.104]         }
[16:06:16.104]         base::close(...future.stdout)
[16:06:16.104]         ...future.stdout <- NULL
[16:06:16.104]     }
[16:06:16.104]     ...future.result$conditions <- ...future.conditions
[16:06:16.104]     ...future.result$finished <- base::Sys.time()
[16:06:16.104]     ...future.result
[16:06:16.104] }
[16:06:16.107] MultisessionFuture started
[16:06:16.107] - Launch lazy future ... done
[16:06:16.107] run() for ‘MultisessionFuture’ ... done
[16:06:16.107] getGlobalsAndPackages() ...
[16:06:16.107] Searching for globals...
[16:06:16.108] - globals found: [1] ‘{’
[16:06:16.108] Searching for globals ... DONE
[16:06:16.108] Resolving globals: FALSE
[16:06:16.108] 
[16:06:16.108] 
[16:06:16.109] getGlobalsAndPackages() ... DONE
[16:06:16.109] run() for ‘Future’ ...
[16:06:16.109] - state: ‘created’
[16:06:16.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.122] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.123]   - Field: ‘node’
[16:06:16.123]   - Field: ‘label’
[16:06:16.123]   - Field: ‘local’
[16:06:16.123]   - Field: ‘owner’
[16:06:16.123]   - Field: ‘envir’
[16:06:16.123]   - Field: ‘workers’
[16:06:16.123]   - Field: ‘packages’
[16:06:16.123]   - Field: ‘gc’
[16:06:16.123]   - Field: ‘conditions’
[16:06:16.123]   - Field: ‘persistent’
[16:06:16.123]   - Field: ‘expr’
[16:06:16.124]   - Field: ‘uuid’
[16:06:16.124]   - Field: ‘seed’
[16:06:16.124]   - Field: ‘version’
[16:06:16.124]   - Field: ‘result’
[16:06:16.124]   - Field: ‘asynchronous’
[16:06:16.124]   - Field: ‘calls’
[16:06:16.124]   - Field: ‘globals’
[16:06:16.124]   - Field: ‘stdout’
[16:06:16.124]   - Field: ‘earlySignal’
[16:06:16.124]   - Field: ‘lazy’
[16:06:16.124]   - Field: ‘state’
[16:06:16.125] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.125] - Launch lazy future ...
[16:06:16.125] Packages needed by the future expression (n = 0): <none>
[16:06:16.125] Packages needed by future strategies (n = 0): <none>
[16:06:16.125] {
[16:06:16.125]     {
[16:06:16.125]         {
[16:06:16.125]             ...future.startTime <- base::Sys.time()
[16:06:16.125]             {
[16:06:16.125]                 {
[16:06:16.125]                   {
[16:06:16.125]                     {
[16:06:16.125]                       base::local({
[16:06:16.125]                         has_future <- base::requireNamespace("future", 
[16:06:16.125]                           quietly = TRUE)
[16:06:16.125]                         if (has_future) {
[16:06:16.125]                           ns <- base::getNamespace("future")
[16:06:16.125]                           version <- ns[[".package"]][["version"]]
[16:06:16.125]                           if (is.null(version)) 
[16:06:16.125]                             version <- utils::packageVersion("future")
[16:06:16.125]                         }
[16:06:16.125]                         else {
[16:06:16.125]                           version <- NULL
[16:06:16.125]                         }
[16:06:16.125]                         if (!has_future || version < "1.8.0") {
[16:06:16.125]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.125]                             "", base::R.version$version.string), 
[16:06:16.125]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.125]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.125]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.125]                               "release", "version")], collapse = " "), 
[16:06:16.125]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.125]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.125]                             info)
[16:06:16.125]                           info <- base::paste(info, collapse = "; ")
[16:06:16.125]                           if (!has_future) {
[16:06:16.125]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.125]                               info)
[16:06:16.125]                           }
[16:06:16.125]                           else {
[16:06:16.125]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.125]                               info, version)
[16:06:16.125]                           }
[16:06:16.125]                           base::stop(msg)
[16:06:16.125]                         }
[16:06:16.125]                       })
[16:06:16.125]                     }
[16:06:16.125]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.125]                     base::options(mc.cores = 1L)
[16:06:16.125]                   }
[16:06:16.125]                   options(future.plan = NULL)
[16:06:16.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.125]                 }
[16:06:16.125]                 ...future.workdir <- getwd()
[16:06:16.125]             }
[16:06:16.125]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.125]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.125]         }
[16:06:16.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.125]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.125]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.125]             base::names(...future.oldOptions))
[16:06:16.125]     }
[16:06:16.125]     if (FALSE) {
[16:06:16.125]     }
[16:06:16.125]     else {
[16:06:16.125]         if (TRUE) {
[16:06:16.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.125]                 open = "w")
[16:06:16.125]         }
[16:06:16.125]         else {
[16:06:16.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.125]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.125]         }
[16:06:16.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.125]             base::sink(type = "output", split = FALSE)
[16:06:16.125]             base::close(...future.stdout)
[16:06:16.125]         }, add = TRUE)
[16:06:16.125]     }
[16:06:16.125]     ...future.frame <- base::sys.nframe()
[16:06:16.125]     ...future.conditions <- base::list()
[16:06:16.125]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.125]     if (FALSE) {
[16:06:16.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.125]     }
[16:06:16.125]     ...future.result <- base::tryCatch({
[16:06:16.125]         base::withCallingHandlers({
[16:06:16.125]             ...future.value <- base::withVisible(base::local({
[16:06:16.125]                 ...future.makeSendCondition <- base::local({
[16:06:16.125]                   sendCondition <- NULL
[16:06:16.125]                   function(frame = 1L) {
[16:06:16.125]                     if (is.function(sendCondition)) 
[16:06:16.125]                       return(sendCondition)
[16:06:16.125]                     ns <- getNamespace("parallel")
[16:06:16.125]                     if (exists("sendData", mode = "function", 
[16:06:16.125]                       envir = ns)) {
[16:06:16.125]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.125]                         envir = ns)
[16:06:16.125]                       envir <- sys.frame(frame)
[16:06:16.125]                       master <- NULL
[16:06:16.125]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.125]                         !identical(envir, emptyenv())) {
[16:06:16.125]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.125]                           inherits = FALSE)) {
[16:06:16.125]                           master <- get("master", mode = "list", 
[16:06:16.125]                             envir = envir, inherits = FALSE)
[16:06:16.125]                           if (inherits(master, c("SOCKnode", 
[16:06:16.125]                             "SOCK0node"))) {
[16:06:16.125]                             sendCondition <<- function(cond) {
[16:06:16.125]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.125]                                 success = TRUE)
[16:06:16.125]                               parallel_sendData(master, data)
[16:06:16.125]                             }
[16:06:16.125]                             return(sendCondition)
[16:06:16.125]                           }
[16:06:16.125]                         }
[16:06:16.125]                         frame <- frame + 1L
[16:06:16.125]                         envir <- sys.frame(frame)
[16:06:16.125]                       }
[16:06:16.125]                     }
[16:06:16.125]                     sendCondition <<- function(cond) NULL
[16:06:16.125]                   }
[16:06:16.125]                 })
[16:06:16.125]                 withCallingHandlers({
[16:06:16.125]                   {
[16:06:16.125]                     2
[16:06:16.125]                   }
[16:06:16.125]                 }, immediateCondition = function(cond) {
[16:06:16.125]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.125]                   sendCondition(cond)
[16:06:16.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.125]                   {
[16:06:16.125]                     inherits <- base::inherits
[16:06:16.125]                     invokeRestart <- base::invokeRestart
[16:06:16.125]                     is.null <- base::is.null
[16:06:16.125]                     muffled <- FALSE
[16:06:16.125]                     if (inherits(cond, "message")) {
[16:06:16.125]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.125]                       if (muffled) 
[16:06:16.125]                         invokeRestart("muffleMessage")
[16:06:16.125]                     }
[16:06:16.125]                     else if (inherits(cond, "warning")) {
[16:06:16.125]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.125]                       if (muffled) 
[16:06:16.125]                         invokeRestart("muffleWarning")
[16:06:16.125]                     }
[16:06:16.125]                     else if (inherits(cond, "condition")) {
[16:06:16.125]                       if (!is.null(pattern)) {
[16:06:16.125]                         computeRestarts <- base::computeRestarts
[16:06:16.125]                         grepl <- base::grepl
[16:06:16.125]                         restarts <- computeRestarts(cond)
[16:06:16.125]                         for (restart in restarts) {
[16:06:16.125]                           name <- restart$name
[16:06:16.125]                           if (is.null(name)) 
[16:06:16.125]                             next
[16:06:16.125]                           if (!grepl(pattern, name)) 
[16:06:16.125]                             next
[16:06:16.125]                           invokeRestart(restart)
[16:06:16.125]                           muffled <- TRUE
[16:06:16.125]                           break
[16:06:16.125]                         }
[16:06:16.125]                       }
[16:06:16.125]                     }
[16:06:16.125]                     invisible(muffled)
[16:06:16.125]                   }
[16:06:16.125]                   muffleCondition(cond)
[16:06:16.125]                 })
[16:06:16.125]             }))
[16:06:16.125]             future::FutureResult(value = ...future.value$value, 
[16:06:16.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.125]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.125]                     ...future.globalenv.names))
[16:06:16.125]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.125]         }, condition = base::local({
[16:06:16.125]             c <- base::c
[16:06:16.125]             inherits <- base::inherits
[16:06:16.125]             invokeRestart <- base::invokeRestart
[16:06:16.125]             length <- base::length
[16:06:16.125]             list <- base::list
[16:06:16.125]             seq.int <- base::seq.int
[16:06:16.125]             signalCondition <- base::signalCondition
[16:06:16.125]             sys.calls <- base::sys.calls
[16:06:16.125]             `[[` <- base::`[[`
[16:06:16.125]             `+` <- base::`+`
[16:06:16.125]             `<<-` <- base::`<<-`
[16:06:16.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.125]                   3L)]
[16:06:16.125]             }
[16:06:16.125]             function(cond) {
[16:06:16.125]                 is_error <- inherits(cond, "error")
[16:06:16.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.125]                   NULL)
[16:06:16.125]                 if (is_error) {
[16:06:16.125]                   sessionInformation <- function() {
[16:06:16.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.125]                       search = base::search(), system = base::Sys.info())
[16:06:16.125]                   }
[16:06:16.125]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.125]                     cond$call), session = sessionInformation(), 
[16:06:16.125]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.125]                   signalCondition(cond)
[16:06:16.125]                 }
[16:06:16.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.125]                 "immediateCondition"))) {
[16:06:16.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.125]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.125]                   if (TRUE && !signal) {
[16:06:16.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.125]                     {
[16:06:16.125]                       inherits <- base::inherits
[16:06:16.125]                       invokeRestart <- base::invokeRestart
[16:06:16.125]                       is.null <- base::is.null
[16:06:16.125]                       muffled <- FALSE
[16:06:16.125]                       if (inherits(cond, "message")) {
[16:06:16.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.125]                         if (muffled) 
[16:06:16.125]                           invokeRestart("muffleMessage")
[16:06:16.125]                       }
[16:06:16.125]                       else if (inherits(cond, "warning")) {
[16:06:16.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.125]                         if (muffled) 
[16:06:16.125]                           invokeRestart("muffleWarning")
[16:06:16.125]                       }
[16:06:16.125]                       else if (inherits(cond, "condition")) {
[16:06:16.125]                         if (!is.null(pattern)) {
[16:06:16.125]                           computeRestarts <- base::computeRestarts
[16:06:16.125]                           grepl <- base::grepl
[16:06:16.125]                           restarts <- computeRestarts(cond)
[16:06:16.125]                           for (restart in restarts) {
[16:06:16.125]                             name <- restart$name
[16:06:16.125]                             if (is.null(name)) 
[16:06:16.125]                               next
[16:06:16.125]                             if (!grepl(pattern, name)) 
[16:06:16.125]                               next
[16:06:16.125]                             invokeRestart(restart)
[16:06:16.125]                             muffled <- TRUE
[16:06:16.125]                             break
[16:06:16.125]                           }
[16:06:16.125]                         }
[16:06:16.125]                       }
[16:06:16.125]                       invisible(muffled)
[16:06:16.125]                     }
[16:06:16.125]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.125]                   }
[16:06:16.125]                 }
[16:06:16.125]                 else {
[16:06:16.125]                   if (TRUE) {
[16:06:16.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.125]                     {
[16:06:16.125]                       inherits <- base::inherits
[16:06:16.125]                       invokeRestart <- base::invokeRestart
[16:06:16.125]                       is.null <- base::is.null
[16:06:16.125]                       muffled <- FALSE
[16:06:16.125]                       if (inherits(cond, "message")) {
[16:06:16.125]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.125]                         if (muffled) 
[16:06:16.125]                           invokeRestart("muffleMessage")
[16:06:16.125]                       }
[16:06:16.125]                       else if (inherits(cond, "warning")) {
[16:06:16.125]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.125]                         if (muffled) 
[16:06:16.125]                           invokeRestart("muffleWarning")
[16:06:16.125]                       }
[16:06:16.125]                       else if (inherits(cond, "condition")) {
[16:06:16.125]                         if (!is.null(pattern)) {
[16:06:16.125]                           computeRestarts <- base::computeRestarts
[16:06:16.125]                           grepl <- base::grepl
[16:06:16.125]                           restarts <- computeRestarts(cond)
[16:06:16.125]                           for (restart in restarts) {
[16:06:16.125]                             name <- restart$name
[16:06:16.125]                             if (is.null(name)) 
[16:06:16.125]                               next
[16:06:16.125]                             if (!grepl(pattern, name)) 
[16:06:16.125]                               next
[16:06:16.125]                             invokeRestart(restart)
[16:06:16.125]                             muffled <- TRUE
[16:06:16.125]                             break
[16:06:16.125]                           }
[16:06:16.125]                         }
[16:06:16.125]                       }
[16:06:16.125]                       invisible(muffled)
[16:06:16.125]                     }
[16:06:16.125]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.125]                   }
[16:06:16.125]                 }
[16:06:16.125]             }
[16:06:16.125]         }))
[16:06:16.125]     }, error = function(ex) {
[16:06:16.125]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.125]                 ...future.rng), started = ...future.startTime, 
[16:06:16.125]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.125]             version = "1.8"), class = "FutureResult")
[16:06:16.125]     }, finally = {
[16:06:16.125]         if (!identical(...future.workdir, getwd())) 
[16:06:16.125]             setwd(...future.workdir)
[16:06:16.125]         {
[16:06:16.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.125]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.125]             }
[16:06:16.125]             base::options(...future.oldOptions)
[16:06:16.125]             if (.Platform$OS.type == "windows") {
[16:06:16.125]                 old_names <- names(...future.oldEnvVars)
[16:06:16.125]                 envs <- base::Sys.getenv()
[16:06:16.125]                 names <- names(envs)
[16:06:16.125]                 common <- intersect(names, old_names)
[16:06:16.125]                 added <- setdiff(names, old_names)
[16:06:16.125]                 removed <- setdiff(old_names, names)
[16:06:16.125]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.125]                   envs[common]]
[16:06:16.125]                 NAMES <- toupper(changed)
[16:06:16.125]                 args <- list()
[16:06:16.125]                 for (kk in seq_along(NAMES)) {
[16:06:16.125]                   name <- changed[[kk]]
[16:06:16.125]                   NAME <- NAMES[[kk]]
[16:06:16.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.125]                     next
[16:06:16.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.125]                 }
[16:06:16.125]                 NAMES <- toupper(added)
[16:06:16.125]                 for (kk in seq_along(NAMES)) {
[16:06:16.125]                   name <- added[[kk]]
[16:06:16.125]                   NAME <- NAMES[[kk]]
[16:06:16.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.125]                     next
[16:06:16.125]                   args[[name]] <- ""
[16:06:16.125]                 }
[16:06:16.125]                 NAMES <- toupper(removed)
[16:06:16.125]                 for (kk in seq_along(NAMES)) {
[16:06:16.125]                   name <- removed[[kk]]
[16:06:16.125]                   NAME <- NAMES[[kk]]
[16:06:16.125]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.125]                     next
[16:06:16.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.125]                 }
[16:06:16.125]                 if (length(args) > 0) 
[16:06:16.125]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.125]             }
[16:06:16.125]             else {
[16:06:16.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.125]             }
[16:06:16.125]             {
[16:06:16.125]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.125]                   0L) {
[16:06:16.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.125]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.125]                   base::options(opts)
[16:06:16.125]                 }
[16:06:16.125]                 {
[16:06:16.125]                   {
[16:06:16.125]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.125]                     NULL
[16:06:16.125]                   }
[16:06:16.125]                   options(future.plan = NULL)
[16:06:16.125]                   if (is.na(NA_character_)) 
[16:06:16.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.125]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.125]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.125]                     envir = parent.frame()) 
[16:06:16.125]                   {
[16:06:16.125]                     if (is.function(workers)) 
[16:06:16.125]                       workers <- workers()
[16:06:16.125]                     workers <- structure(as.integer(workers), 
[16:06:16.125]                       class = class(workers))
[16:06:16.125]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.125]                       workers >= 1)
[16:06:16.125]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.125]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.125]                     }
[16:06:16.125]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.125]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.125]                       envir = envir)
[16:06:16.125]                     if (!future$lazy) 
[16:06:16.125]                       future <- run(future)
[16:06:16.125]                     invisible(future)
[16:06:16.125]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.125]                 }
[16:06:16.125]             }
[16:06:16.125]         }
[16:06:16.125]     })
[16:06:16.125]     if (TRUE) {
[16:06:16.125]         base::sink(type = "output", split = FALSE)
[16:06:16.125]         if (TRUE) {
[16:06:16.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.125]         }
[16:06:16.125]         else {
[16:06:16.125]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.125]         }
[16:06:16.125]         base::close(...future.stdout)
[16:06:16.125]         ...future.stdout <- NULL
[16:06:16.125]     }
[16:06:16.125]     ...future.result$conditions <- ...future.conditions
[16:06:16.125]     ...future.result$finished <- base::Sys.time()
[16:06:16.125]     ...future.result
[16:06:16.125] }
[16:06:16.128] MultisessionFuture started
[16:06:16.129] - Launch lazy future ... done
[16:06:16.129] run() for ‘MultisessionFuture’ ... done
[16:06:16.129] resolve() on environment ...
[16:06:16.129]  recursive: 0
[16:06:16.130]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:06:16.151]  length: 2 (resolved future 3)
[16:06:16.161] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.162] - Validating connection of MultisessionFuture
[16:06:16.162] - received message: FutureResult
[16:06:16.162] - Received FutureResult
[16:06:16.162] - Erased future from FutureRegistry
[16:06:16.162] result() for ClusterFuture ...
[16:06:16.162] - result already collected: FutureResult
[16:06:16.162] result() for ClusterFuture ... done
[16:06:16.162] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.162] Future #1
[16:06:16.163]  length: 1 (resolved future 1)
[16:06:16.184] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.184] - Validating connection of MultisessionFuture
[16:06:16.184] - received message: FutureResult
[16:06:16.184] - Received FutureResult
[16:06:16.184] - Erased future from FutureRegistry
[16:06:16.184] result() for ClusterFuture ...
[16:06:16.184] - result already collected: FutureResult
[16:06:16.184] result() for ClusterFuture ... done
[16:06:16.185] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.185] Future #2
[16:06:16.185]  length: 0 (resolved future 2)
[16:06:16.185] resolve() on environment ... DONE
[16:06:16.185] getGlobalsAndPackages() ...
[16:06:16.185] Searching for globals...
[16:06:16.186] - globals found: [1] ‘{’
[16:06:16.186] Searching for globals ... DONE
[16:06:16.186] Resolving globals: FALSE
[16:06:16.186] 
[16:06:16.186] 
[16:06:16.187] getGlobalsAndPackages() ... DONE
[16:06:16.187] run() for ‘Future’ ...
[16:06:16.187] - state: ‘created’
[16:06:16.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.201]   - Field: ‘node’
[16:06:16.201]   - Field: ‘label’
[16:06:16.201]   - Field: ‘local’
[16:06:16.201]   - Field: ‘owner’
[16:06:16.201]   - Field: ‘envir’
[16:06:16.201]   - Field: ‘workers’
[16:06:16.201]   - Field: ‘packages’
[16:06:16.201]   - Field: ‘gc’
[16:06:16.201]   - Field: ‘conditions’
[16:06:16.201]   - Field: ‘persistent’
[16:06:16.201]   - Field: ‘expr’
[16:06:16.202]   - Field: ‘uuid’
[16:06:16.202]   - Field: ‘seed’
[16:06:16.202]   - Field: ‘version’
[16:06:16.202]   - Field: ‘result’
[16:06:16.202]   - Field: ‘asynchronous’
[16:06:16.202]   - Field: ‘calls’
[16:06:16.202]   - Field: ‘globals’
[16:06:16.202]   - Field: ‘stdout’
[16:06:16.202]   - Field: ‘earlySignal’
[16:06:16.202]   - Field: ‘lazy’
[16:06:16.202]   - Field: ‘state’
[16:06:16.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.203] - Launch lazy future ...
[16:06:16.203] Packages needed by the future expression (n = 0): <none>
[16:06:16.203] Packages needed by future strategies (n = 0): <none>
[16:06:16.203] {
[16:06:16.203]     {
[16:06:16.203]         {
[16:06:16.203]             ...future.startTime <- base::Sys.time()
[16:06:16.203]             {
[16:06:16.203]                 {
[16:06:16.203]                   {
[16:06:16.203]                     {
[16:06:16.203]                       base::local({
[16:06:16.203]                         has_future <- base::requireNamespace("future", 
[16:06:16.203]                           quietly = TRUE)
[16:06:16.203]                         if (has_future) {
[16:06:16.203]                           ns <- base::getNamespace("future")
[16:06:16.203]                           version <- ns[[".package"]][["version"]]
[16:06:16.203]                           if (is.null(version)) 
[16:06:16.203]                             version <- utils::packageVersion("future")
[16:06:16.203]                         }
[16:06:16.203]                         else {
[16:06:16.203]                           version <- NULL
[16:06:16.203]                         }
[16:06:16.203]                         if (!has_future || version < "1.8.0") {
[16:06:16.203]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.203]                             "", base::R.version$version.string), 
[16:06:16.203]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.203]                               "release", "version")], collapse = " "), 
[16:06:16.203]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.203]                             info)
[16:06:16.203]                           info <- base::paste(info, collapse = "; ")
[16:06:16.203]                           if (!has_future) {
[16:06:16.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.203]                               info)
[16:06:16.203]                           }
[16:06:16.203]                           else {
[16:06:16.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.203]                               info, version)
[16:06:16.203]                           }
[16:06:16.203]                           base::stop(msg)
[16:06:16.203]                         }
[16:06:16.203]                       })
[16:06:16.203]                     }
[16:06:16.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.203]                     base::options(mc.cores = 1L)
[16:06:16.203]                   }
[16:06:16.203]                   options(future.plan = NULL)
[16:06:16.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.203]                 }
[16:06:16.203]                 ...future.workdir <- getwd()
[16:06:16.203]             }
[16:06:16.203]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.203]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.203]         }
[16:06:16.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.203]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.203]             base::names(...future.oldOptions))
[16:06:16.203]     }
[16:06:16.203]     if (FALSE) {
[16:06:16.203]     }
[16:06:16.203]     else {
[16:06:16.203]         if (TRUE) {
[16:06:16.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.203]                 open = "w")
[16:06:16.203]         }
[16:06:16.203]         else {
[16:06:16.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.203]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.203]         }
[16:06:16.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.203]             base::sink(type = "output", split = FALSE)
[16:06:16.203]             base::close(...future.stdout)
[16:06:16.203]         }, add = TRUE)
[16:06:16.203]     }
[16:06:16.203]     ...future.frame <- base::sys.nframe()
[16:06:16.203]     ...future.conditions <- base::list()
[16:06:16.203]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.203]     if (FALSE) {
[16:06:16.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.203]     }
[16:06:16.203]     ...future.result <- base::tryCatch({
[16:06:16.203]         base::withCallingHandlers({
[16:06:16.203]             ...future.value <- base::withVisible(base::local({
[16:06:16.203]                 ...future.makeSendCondition <- base::local({
[16:06:16.203]                   sendCondition <- NULL
[16:06:16.203]                   function(frame = 1L) {
[16:06:16.203]                     if (is.function(sendCondition)) 
[16:06:16.203]                       return(sendCondition)
[16:06:16.203]                     ns <- getNamespace("parallel")
[16:06:16.203]                     if (exists("sendData", mode = "function", 
[16:06:16.203]                       envir = ns)) {
[16:06:16.203]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.203]                         envir = ns)
[16:06:16.203]                       envir <- sys.frame(frame)
[16:06:16.203]                       master <- NULL
[16:06:16.203]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.203]                         !identical(envir, emptyenv())) {
[16:06:16.203]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.203]                           inherits = FALSE)) {
[16:06:16.203]                           master <- get("master", mode = "list", 
[16:06:16.203]                             envir = envir, inherits = FALSE)
[16:06:16.203]                           if (inherits(master, c("SOCKnode", 
[16:06:16.203]                             "SOCK0node"))) {
[16:06:16.203]                             sendCondition <<- function(cond) {
[16:06:16.203]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.203]                                 success = TRUE)
[16:06:16.203]                               parallel_sendData(master, data)
[16:06:16.203]                             }
[16:06:16.203]                             return(sendCondition)
[16:06:16.203]                           }
[16:06:16.203]                         }
[16:06:16.203]                         frame <- frame + 1L
[16:06:16.203]                         envir <- sys.frame(frame)
[16:06:16.203]                       }
[16:06:16.203]                     }
[16:06:16.203]                     sendCondition <<- function(cond) NULL
[16:06:16.203]                   }
[16:06:16.203]                 })
[16:06:16.203]                 withCallingHandlers({
[16:06:16.203]                   {
[16:06:16.203]                     1
[16:06:16.203]                   }
[16:06:16.203]                 }, immediateCondition = function(cond) {
[16:06:16.203]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.203]                   sendCondition(cond)
[16:06:16.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.203]                   {
[16:06:16.203]                     inherits <- base::inherits
[16:06:16.203]                     invokeRestart <- base::invokeRestart
[16:06:16.203]                     is.null <- base::is.null
[16:06:16.203]                     muffled <- FALSE
[16:06:16.203]                     if (inherits(cond, "message")) {
[16:06:16.203]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.203]                       if (muffled) 
[16:06:16.203]                         invokeRestart("muffleMessage")
[16:06:16.203]                     }
[16:06:16.203]                     else if (inherits(cond, "warning")) {
[16:06:16.203]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.203]                       if (muffled) 
[16:06:16.203]                         invokeRestart("muffleWarning")
[16:06:16.203]                     }
[16:06:16.203]                     else if (inherits(cond, "condition")) {
[16:06:16.203]                       if (!is.null(pattern)) {
[16:06:16.203]                         computeRestarts <- base::computeRestarts
[16:06:16.203]                         grepl <- base::grepl
[16:06:16.203]                         restarts <- computeRestarts(cond)
[16:06:16.203]                         for (restart in restarts) {
[16:06:16.203]                           name <- restart$name
[16:06:16.203]                           if (is.null(name)) 
[16:06:16.203]                             next
[16:06:16.203]                           if (!grepl(pattern, name)) 
[16:06:16.203]                             next
[16:06:16.203]                           invokeRestart(restart)
[16:06:16.203]                           muffled <- TRUE
[16:06:16.203]                           break
[16:06:16.203]                         }
[16:06:16.203]                       }
[16:06:16.203]                     }
[16:06:16.203]                     invisible(muffled)
[16:06:16.203]                   }
[16:06:16.203]                   muffleCondition(cond)
[16:06:16.203]                 })
[16:06:16.203]             }))
[16:06:16.203]             future::FutureResult(value = ...future.value$value, 
[16:06:16.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.203]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.203]                     ...future.globalenv.names))
[16:06:16.203]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.203]         }, condition = base::local({
[16:06:16.203]             c <- base::c
[16:06:16.203]             inherits <- base::inherits
[16:06:16.203]             invokeRestart <- base::invokeRestart
[16:06:16.203]             length <- base::length
[16:06:16.203]             list <- base::list
[16:06:16.203]             seq.int <- base::seq.int
[16:06:16.203]             signalCondition <- base::signalCondition
[16:06:16.203]             sys.calls <- base::sys.calls
[16:06:16.203]             `[[` <- base::`[[`
[16:06:16.203]             `+` <- base::`+`
[16:06:16.203]             `<<-` <- base::`<<-`
[16:06:16.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.203]                   3L)]
[16:06:16.203]             }
[16:06:16.203]             function(cond) {
[16:06:16.203]                 is_error <- inherits(cond, "error")
[16:06:16.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.203]                   NULL)
[16:06:16.203]                 if (is_error) {
[16:06:16.203]                   sessionInformation <- function() {
[16:06:16.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.203]                       search = base::search(), system = base::Sys.info())
[16:06:16.203]                   }
[16:06:16.203]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.203]                     cond$call), session = sessionInformation(), 
[16:06:16.203]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.203]                   signalCondition(cond)
[16:06:16.203]                 }
[16:06:16.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.203]                 "immediateCondition"))) {
[16:06:16.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.203]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.203]                   if (TRUE && !signal) {
[16:06:16.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.203]                     {
[16:06:16.203]                       inherits <- base::inherits
[16:06:16.203]                       invokeRestart <- base::invokeRestart
[16:06:16.203]                       is.null <- base::is.null
[16:06:16.203]                       muffled <- FALSE
[16:06:16.203]                       if (inherits(cond, "message")) {
[16:06:16.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.203]                         if (muffled) 
[16:06:16.203]                           invokeRestart("muffleMessage")
[16:06:16.203]                       }
[16:06:16.203]                       else if (inherits(cond, "warning")) {
[16:06:16.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.203]                         if (muffled) 
[16:06:16.203]                           invokeRestart("muffleWarning")
[16:06:16.203]                       }
[16:06:16.203]                       else if (inherits(cond, "condition")) {
[16:06:16.203]                         if (!is.null(pattern)) {
[16:06:16.203]                           computeRestarts <- base::computeRestarts
[16:06:16.203]                           grepl <- base::grepl
[16:06:16.203]                           restarts <- computeRestarts(cond)
[16:06:16.203]                           for (restart in restarts) {
[16:06:16.203]                             name <- restart$name
[16:06:16.203]                             if (is.null(name)) 
[16:06:16.203]                               next
[16:06:16.203]                             if (!grepl(pattern, name)) 
[16:06:16.203]                               next
[16:06:16.203]                             invokeRestart(restart)
[16:06:16.203]                             muffled <- TRUE
[16:06:16.203]                             break
[16:06:16.203]                           }
[16:06:16.203]                         }
[16:06:16.203]                       }
[16:06:16.203]                       invisible(muffled)
[16:06:16.203]                     }
[16:06:16.203]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.203]                   }
[16:06:16.203]                 }
[16:06:16.203]                 else {
[16:06:16.203]                   if (TRUE) {
[16:06:16.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.203]                     {
[16:06:16.203]                       inherits <- base::inherits
[16:06:16.203]                       invokeRestart <- base::invokeRestart
[16:06:16.203]                       is.null <- base::is.null
[16:06:16.203]                       muffled <- FALSE
[16:06:16.203]                       if (inherits(cond, "message")) {
[16:06:16.203]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.203]                         if (muffled) 
[16:06:16.203]                           invokeRestart("muffleMessage")
[16:06:16.203]                       }
[16:06:16.203]                       else if (inherits(cond, "warning")) {
[16:06:16.203]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.203]                         if (muffled) 
[16:06:16.203]                           invokeRestart("muffleWarning")
[16:06:16.203]                       }
[16:06:16.203]                       else if (inherits(cond, "condition")) {
[16:06:16.203]                         if (!is.null(pattern)) {
[16:06:16.203]                           computeRestarts <- base::computeRestarts
[16:06:16.203]                           grepl <- base::grepl
[16:06:16.203]                           restarts <- computeRestarts(cond)
[16:06:16.203]                           for (restart in restarts) {
[16:06:16.203]                             name <- restart$name
[16:06:16.203]                             if (is.null(name)) 
[16:06:16.203]                               next
[16:06:16.203]                             if (!grepl(pattern, name)) 
[16:06:16.203]                               next
[16:06:16.203]                             invokeRestart(restart)
[16:06:16.203]                             muffled <- TRUE
[16:06:16.203]                             break
[16:06:16.203]                           }
[16:06:16.203]                         }
[16:06:16.203]                       }
[16:06:16.203]                       invisible(muffled)
[16:06:16.203]                     }
[16:06:16.203]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.203]                   }
[16:06:16.203]                 }
[16:06:16.203]             }
[16:06:16.203]         }))
[16:06:16.203]     }, error = function(ex) {
[16:06:16.203]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.203]                 ...future.rng), started = ...future.startTime, 
[16:06:16.203]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.203]             version = "1.8"), class = "FutureResult")
[16:06:16.203]     }, finally = {
[16:06:16.203]         if (!identical(...future.workdir, getwd())) 
[16:06:16.203]             setwd(...future.workdir)
[16:06:16.203]         {
[16:06:16.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.203]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.203]             }
[16:06:16.203]             base::options(...future.oldOptions)
[16:06:16.203]             if (.Platform$OS.type == "windows") {
[16:06:16.203]                 old_names <- names(...future.oldEnvVars)
[16:06:16.203]                 envs <- base::Sys.getenv()
[16:06:16.203]                 names <- names(envs)
[16:06:16.203]                 common <- intersect(names, old_names)
[16:06:16.203]                 added <- setdiff(names, old_names)
[16:06:16.203]                 removed <- setdiff(old_names, names)
[16:06:16.203]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.203]                   envs[common]]
[16:06:16.203]                 NAMES <- toupper(changed)
[16:06:16.203]                 args <- list()
[16:06:16.203]                 for (kk in seq_along(NAMES)) {
[16:06:16.203]                   name <- changed[[kk]]
[16:06:16.203]                   NAME <- NAMES[[kk]]
[16:06:16.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.203]                     next
[16:06:16.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.203]                 }
[16:06:16.203]                 NAMES <- toupper(added)
[16:06:16.203]                 for (kk in seq_along(NAMES)) {
[16:06:16.203]                   name <- added[[kk]]
[16:06:16.203]                   NAME <- NAMES[[kk]]
[16:06:16.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.203]                     next
[16:06:16.203]                   args[[name]] <- ""
[16:06:16.203]                 }
[16:06:16.203]                 NAMES <- toupper(removed)
[16:06:16.203]                 for (kk in seq_along(NAMES)) {
[16:06:16.203]                   name <- removed[[kk]]
[16:06:16.203]                   NAME <- NAMES[[kk]]
[16:06:16.203]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.203]                     next
[16:06:16.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.203]                 }
[16:06:16.203]                 if (length(args) > 0) 
[16:06:16.203]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.203]             }
[16:06:16.203]             else {
[16:06:16.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.203]             }
[16:06:16.203]             {
[16:06:16.203]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.203]                   0L) {
[16:06:16.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.203]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.203]                   base::options(opts)
[16:06:16.203]                 }
[16:06:16.203]                 {
[16:06:16.203]                   {
[16:06:16.203]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.203]                     NULL
[16:06:16.203]                   }
[16:06:16.203]                   options(future.plan = NULL)
[16:06:16.203]                   if (is.na(NA_character_)) 
[16:06:16.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.203]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.203]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.203]                     envir = parent.frame()) 
[16:06:16.203]                   {
[16:06:16.203]                     if (is.function(workers)) 
[16:06:16.203]                       workers <- workers()
[16:06:16.203]                     workers <- structure(as.integer(workers), 
[16:06:16.203]                       class = class(workers))
[16:06:16.203]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.203]                       workers >= 1)
[16:06:16.203]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.203]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.203]                     }
[16:06:16.203]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.203]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.203]                       envir = envir)
[16:06:16.203]                     if (!future$lazy) 
[16:06:16.203]                       future <- run(future)
[16:06:16.203]                     invisible(future)
[16:06:16.203]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.203]                 }
[16:06:16.203]             }
[16:06:16.203]         }
[16:06:16.203]     })
[16:06:16.203]     if (TRUE) {
[16:06:16.203]         base::sink(type = "output", split = FALSE)
[16:06:16.203]         if (TRUE) {
[16:06:16.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.203]         }
[16:06:16.203]         else {
[16:06:16.203]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.203]         }
[16:06:16.203]         base::close(...future.stdout)
[16:06:16.203]         ...future.stdout <- NULL
[16:06:16.203]     }
[16:06:16.203]     ...future.result$conditions <- ...future.conditions
[16:06:16.203]     ...future.result$finished <- base::Sys.time()
[16:06:16.203]     ...future.result
[16:06:16.203] }
[16:06:16.206] MultisessionFuture started
[16:06:16.207] - Launch lazy future ... done
[16:06:16.207] run() for ‘MultisessionFuture’ ... done
[16:06:16.207] getGlobalsAndPackages() ...
[16:06:16.207] Searching for globals...
[16:06:16.208] - globals found: [1] ‘{’
[16:06:16.208] Searching for globals ... DONE
[16:06:16.208] Resolving globals: FALSE
[16:06:16.208] 
[16:06:16.208] 
[16:06:16.208] getGlobalsAndPackages() ... DONE
[16:06:16.208] run() for ‘Future’ ...
[16:06:16.209] - state: ‘created’
[16:06:16.209] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.223]   - Field: ‘node’
[16:06:16.223]   - Field: ‘label’
[16:06:16.223]   - Field: ‘local’
[16:06:16.223]   - Field: ‘owner’
[16:06:16.223]   - Field: ‘envir’
[16:06:16.223]   - Field: ‘workers’
[16:06:16.223]   - Field: ‘packages’
[16:06:16.223]   - Field: ‘gc’
[16:06:16.223]   - Field: ‘conditions’
[16:06:16.223]   - Field: ‘persistent’
[16:06:16.223]   - Field: ‘expr’
[16:06:16.224]   - Field: ‘uuid’
[16:06:16.224]   - Field: ‘seed’
[16:06:16.224]   - Field: ‘version’
[16:06:16.224]   - Field: ‘result’
[16:06:16.224]   - Field: ‘asynchronous’
[16:06:16.224]   - Field: ‘calls’
[16:06:16.224]   - Field: ‘globals’
[16:06:16.224]   - Field: ‘stdout’
[16:06:16.224]   - Field: ‘earlySignal’
[16:06:16.224]   - Field: ‘lazy’
[16:06:16.224]   - Field: ‘state’
[16:06:16.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.225] - Launch lazy future ...
[16:06:16.225] Packages needed by the future expression (n = 0): <none>
[16:06:16.225] Packages needed by future strategies (n = 0): <none>
[16:06:16.225] {
[16:06:16.225]     {
[16:06:16.225]         {
[16:06:16.225]             ...future.startTime <- base::Sys.time()
[16:06:16.225]             {
[16:06:16.225]                 {
[16:06:16.225]                   {
[16:06:16.225]                     {
[16:06:16.225]                       base::local({
[16:06:16.225]                         has_future <- base::requireNamespace("future", 
[16:06:16.225]                           quietly = TRUE)
[16:06:16.225]                         if (has_future) {
[16:06:16.225]                           ns <- base::getNamespace("future")
[16:06:16.225]                           version <- ns[[".package"]][["version"]]
[16:06:16.225]                           if (is.null(version)) 
[16:06:16.225]                             version <- utils::packageVersion("future")
[16:06:16.225]                         }
[16:06:16.225]                         else {
[16:06:16.225]                           version <- NULL
[16:06:16.225]                         }
[16:06:16.225]                         if (!has_future || version < "1.8.0") {
[16:06:16.225]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.225]                             "", base::R.version$version.string), 
[16:06:16.225]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.225]                               "release", "version")], collapse = " "), 
[16:06:16.225]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.225]                             info)
[16:06:16.225]                           info <- base::paste(info, collapse = "; ")
[16:06:16.225]                           if (!has_future) {
[16:06:16.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.225]                               info)
[16:06:16.225]                           }
[16:06:16.225]                           else {
[16:06:16.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.225]                               info, version)
[16:06:16.225]                           }
[16:06:16.225]                           base::stop(msg)
[16:06:16.225]                         }
[16:06:16.225]                       })
[16:06:16.225]                     }
[16:06:16.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.225]                     base::options(mc.cores = 1L)
[16:06:16.225]                   }
[16:06:16.225]                   options(future.plan = NULL)
[16:06:16.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.225]                 }
[16:06:16.225]                 ...future.workdir <- getwd()
[16:06:16.225]             }
[16:06:16.225]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.225]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.225]         }
[16:06:16.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.225]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.225]             base::names(...future.oldOptions))
[16:06:16.225]     }
[16:06:16.225]     if (FALSE) {
[16:06:16.225]     }
[16:06:16.225]     else {
[16:06:16.225]         if (TRUE) {
[16:06:16.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.225]                 open = "w")
[16:06:16.225]         }
[16:06:16.225]         else {
[16:06:16.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.225]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.225]         }
[16:06:16.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.225]             base::sink(type = "output", split = FALSE)
[16:06:16.225]             base::close(...future.stdout)
[16:06:16.225]         }, add = TRUE)
[16:06:16.225]     }
[16:06:16.225]     ...future.frame <- base::sys.nframe()
[16:06:16.225]     ...future.conditions <- base::list()
[16:06:16.225]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.225]     if (FALSE) {
[16:06:16.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.225]     }
[16:06:16.225]     ...future.result <- base::tryCatch({
[16:06:16.225]         base::withCallingHandlers({
[16:06:16.225]             ...future.value <- base::withVisible(base::local({
[16:06:16.225]                 ...future.makeSendCondition <- base::local({
[16:06:16.225]                   sendCondition <- NULL
[16:06:16.225]                   function(frame = 1L) {
[16:06:16.225]                     if (is.function(sendCondition)) 
[16:06:16.225]                       return(sendCondition)
[16:06:16.225]                     ns <- getNamespace("parallel")
[16:06:16.225]                     if (exists("sendData", mode = "function", 
[16:06:16.225]                       envir = ns)) {
[16:06:16.225]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.225]                         envir = ns)
[16:06:16.225]                       envir <- sys.frame(frame)
[16:06:16.225]                       master <- NULL
[16:06:16.225]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.225]                         !identical(envir, emptyenv())) {
[16:06:16.225]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.225]                           inherits = FALSE)) {
[16:06:16.225]                           master <- get("master", mode = "list", 
[16:06:16.225]                             envir = envir, inherits = FALSE)
[16:06:16.225]                           if (inherits(master, c("SOCKnode", 
[16:06:16.225]                             "SOCK0node"))) {
[16:06:16.225]                             sendCondition <<- function(cond) {
[16:06:16.225]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.225]                                 success = TRUE)
[16:06:16.225]                               parallel_sendData(master, data)
[16:06:16.225]                             }
[16:06:16.225]                             return(sendCondition)
[16:06:16.225]                           }
[16:06:16.225]                         }
[16:06:16.225]                         frame <- frame + 1L
[16:06:16.225]                         envir <- sys.frame(frame)
[16:06:16.225]                       }
[16:06:16.225]                     }
[16:06:16.225]                     sendCondition <<- function(cond) NULL
[16:06:16.225]                   }
[16:06:16.225]                 })
[16:06:16.225]                 withCallingHandlers({
[16:06:16.225]                   {
[16:06:16.225]                     2
[16:06:16.225]                   }
[16:06:16.225]                 }, immediateCondition = function(cond) {
[16:06:16.225]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.225]                   sendCondition(cond)
[16:06:16.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.225]                   {
[16:06:16.225]                     inherits <- base::inherits
[16:06:16.225]                     invokeRestart <- base::invokeRestart
[16:06:16.225]                     is.null <- base::is.null
[16:06:16.225]                     muffled <- FALSE
[16:06:16.225]                     if (inherits(cond, "message")) {
[16:06:16.225]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.225]                       if (muffled) 
[16:06:16.225]                         invokeRestart("muffleMessage")
[16:06:16.225]                     }
[16:06:16.225]                     else if (inherits(cond, "warning")) {
[16:06:16.225]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.225]                       if (muffled) 
[16:06:16.225]                         invokeRestart("muffleWarning")
[16:06:16.225]                     }
[16:06:16.225]                     else if (inherits(cond, "condition")) {
[16:06:16.225]                       if (!is.null(pattern)) {
[16:06:16.225]                         computeRestarts <- base::computeRestarts
[16:06:16.225]                         grepl <- base::grepl
[16:06:16.225]                         restarts <- computeRestarts(cond)
[16:06:16.225]                         for (restart in restarts) {
[16:06:16.225]                           name <- restart$name
[16:06:16.225]                           if (is.null(name)) 
[16:06:16.225]                             next
[16:06:16.225]                           if (!grepl(pattern, name)) 
[16:06:16.225]                             next
[16:06:16.225]                           invokeRestart(restart)
[16:06:16.225]                           muffled <- TRUE
[16:06:16.225]                           break
[16:06:16.225]                         }
[16:06:16.225]                       }
[16:06:16.225]                     }
[16:06:16.225]                     invisible(muffled)
[16:06:16.225]                   }
[16:06:16.225]                   muffleCondition(cond)
[16:06:16.225]                 })
[16:06:16.225]             }))
[16:06:16.225]             future::FutureResult(value = ...future.value$value, 
[16:06:16.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.225]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.225]                     ...future.globalenv.names))
[16:06:16.225]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.225]         }, condition = base::local({
[16:06:16.225]             c <- base::c
[16:06:16.225]             inherits <- base::inherits
[16:06:16.225]             invokeRestart <- base::invokeRestart
[16:06:16.225]             length <- base::length
[16:06:16.225]             list <- base::list
[16:06:16.225]             seq.int <- base::seq.int
[16:06:16.225]             signalCondition <- base::signalCondition
[16:06:16.225]             sys.calls <- base::sys.calls
[16:06:16.225]             `[[` <- base::`[[`
[16:06:16.225]             `+` <- base::`+`
[16:06:16.225]             `<<-` <- base::`<<-`
[16:06:16.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.225]                   3L)]
[16:06:16.225]             }
[16:06:16.225]             function(cond) {
[16:06:16.225]                 is_error <- inherits(cond, "error")
[16:06:16.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.225]                   NULL)
[16:06:16.225]                 if (is_error) {
[16:06:16.225]                   sessionInformation <- function() {
[16:06:16.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.225]                       search = base::search(), system = base::Sys.info())
[16:06:16.225]                   }
[16:06:16.225]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.225]                     cond$call), session = sessionInformation(), 
[16:06:16.225]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.225]                   signalCondition(cond)
[16:06:16.225]                 }
[16:06:16.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.225]                 "immediateCondition"))) {
[16:06:16.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.225]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.225]                   if (TRUE && !signal) {
[16:06:16.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.225]                     {
[16:06:16.225]                       inherits <- base::inherits
[16:06:16.225]                       invokeRestart <- base::invokeRestart
[16:06:16.225]                       is.null <- base::is.null
[16:06:16.225]                       muffled <- FALSE
[16:06:16.225]                       if (inherits(cond, "message")) {
[16:06:16.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.225]                         if (muffled) 
[16:06:16.225]                           invokeRestart("muffleMessage")
[16:06:16.225]                       }
[16:06:16.225]                       else if (inherits(cond, "warning")) {
[16:06:16.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.225]                         if (muffled) 
[16:06:16.225]                           invokeRestart("muffleWarning")
[16:06:16.225]                       }
[16:06:16.225]                       else if (inherits(cond, "condition")) {
[16:06:16.225]                         if (!is.null(pattern)) {
[16:06:16.225]                           computeRestarts <- base::computeRestarts
[16:06:16.225]                           grepl <- base::grepl
[16:06:16.225]                           restarts <- computeRestarts(cond)
[16:06:16.225]                           for (restart in restarts) {
[16:06:16.225]                             name <- restart$name
[16:06:16.225]                             if (is.null(name)) 
[16:06:16.225]                               next
[16:06:16.225]                             if (!grepl(pattern, name)) 
[16:06:16.225]                               next
[16:06:16.225]                             invokeRestart(restart)
[16:06:16.225]                             muffled <- TRUE
[16:06:16.225]                             break
[16:06:16.225]                           }
[16:06:16.225]                         }
[16:06:16.225]                       }
[16:06:16.225]                       invisible(muffled)
[16:06:16.225]                     }
[16:06:16.225]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.225]                   }
[16:06:16.225]                 }
[16:06:16.225]                 else {
[16:06:16.225]                   if (TRUE) {
[16:06:16.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.225]                     {
[16:06:16.225]                       inherits <- base::inherits
[16:06:16.225]                       invokeRestart <- base::invokeRestart
[16:06:16.225]                       is.null <- base::is.null
[16:06:16.225]                       muffled <- FALSE
[16:06:16.225]                       if (inherits(cond, "message")) {
[16:06:16.225]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.225]                         if (muffled) 
[16:06:16.225]                           invokeRestart("muffleMessage")
[16:06:16.225]                       }
[16:06:16.225]                       else if (inherits(cond, "warning")) {
[16:06:16.225]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.225]                         if (muffled) 
[16:06:16.225]                           invokeRestart("muffleWarning")
[16:06:16.225]                       }
[16:06:16.225]                       else if (inherits(cond, "condition")) {
[16:06:16.225]                         if (!is.null(pattern)) {
[16:06:16.225]                           computeRestarts <- base::computeRestarts
[16:06:16.225]                           grepl <- base::grepl
[16:06:16.225]                           restarts <- computeRestarts(cond)
[16:06:16.225]                           for (restart in restarts) {
[16:06:16.225]                             name <- restart$name
[16:06:16.225]                             if (is.null(name)) 
[16:06:16.225]                               next
[16:06:16.225]                             if (!grepl(pattern, name)) 
[16:06:16.225]                               next
[16:06:16.225]                             invokeRestart(restart)
[16:06:16.225]                             muffled <- TRUE
[16:06:16.225]                             break
[16:06:16.225]                           }
[16:06:16.225]                         }
[16:06:16.225]                       }
[16:06:16.225]                       invisible(muffled)
[16:06:16.225]                     }
[16:06:16.225]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.225]                   }
[16:06:16.225]                 }
[16:06:16.225]             }
[16:06:16.225]         }))
[16:06:16.225]     }, error = function(ex) {
[16:06:16.225]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.225]                 ...future.rng), started = ...future.startTime, 
[16:06:16.225]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.225]             version = "1.8"), class = "FutureResult")
[16:06:16.225]     }, finally = {
[16:06:16.225]         if (!identical(...future.workdir, getwd())) 
[16:06:16.225]             setwd(...future.workdir)
[16:06:16.225]         {
[16:06:16.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.225]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.225]             }
[16:06:16.225]             base::options(...future.oldOptions)
[16:06:16.225]             if (.Platform$OS.type == "windows") {
[16:06:16.225]                 old_names <- names(...future.oldEnvVars)
[16:06:16.225]                 envs <- base::Sys.getenv()
[16:06:16.225]                 names <- names(envs)
[16:06:16.225]                 common <- intersect(names, old_names)
[16:06:16.225]                 added <- setdiff(names, old_names)
[16:06:16.225]                 removed <- setdiff(old_names, names)
[16:06:16.225]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.225]                   envs[common]]
[16:06:16.225]                 NAMES <- toupper(changed)
[16:06:16.225]                 args <- list()
[16:06:16.225]                 for (kk in seq_along(NAMES)) {
[16:06:16.225]                   name <- changed[[kk]]
[16:06:16.225]                   NAME <- NAMES[[kk]]
[16:06:16.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.225]                     next
[16:06:16.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.225]                 }
[16:06:16.225]                 NAMES <- toupper(added)
[16:06:16.225]                 for (kk in seq_along(NAMES)) {
[16:06:16.225]                   name <- added[[kk]]
[16:06:16.225]                   NAME <- NAMES[[kk]]
[16:06:16.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.225]                     next
[16:06:16.225]                   args[[name]] <- ""
[16:06:16.225]                 }
[16:06:16.225]                 NAMES <- toupper(removed)
[16:06:16.225]                 for (kk in seq_along(NAMES)) {
[16:06:16.225]                   name <- removed[[kk]]
[16:06:16.225]                   NAME <- NAMES[[kk]]
[16:06:16.225]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.225]                     next
[16:06:16.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.225]                 }
[16:06:16.225]                 if (length(args) > 0) 
[16:06:16.225]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.225]             }
[16:06:16.225]             else {
[16:06:16.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.225]             }
[16:06:16.225]             {
[16:06:16.225]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.225]                   0L) {
[16:06:16.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.225]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.225]                   base::options(opts)
[16:06:16.225]                 }
[16:06:16.225]                 {
[16:06:16.225]                   {
[16:06:16.225]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.225]                     NULL
[16:06:16.225]                   }
[16:06:16.225]                   options(future.plan = NULL)
[16:06:16.225]                   if (is.na(NA_character_)) 
[16:06:16.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.225]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.225]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.225]                     envir = parent.frame()) 
[16:06:16.225]                   {
[16:06:16.225]                     if (is.function(workers)) 
[16:06:16.225]                       workers <- workers()
[16:06:16.225]                     workers <- structure(as.integer(workers), 
[16:06:16.225]                       class = class(workers))
[16:06:16.225]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.225]                       workers >= 1)
[16:06:16.225]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.225]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.225]                     }
[16:06:16.225]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.225]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.225]                       envir = envir)
[16:06:16.225]                     if (!future$lazy) 
[16:06:16.225]                       future <- run(future)
[16:06:16.225]                     invisible(future)
[16:06:16.225]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.225]                 }
[16:06:16.225]             }
[16:06:16.225]         }
[16:06:16.225]     })
[16:06:16.225]     if (TRUE) {
[16:06:16.225]         base::sink(type = "output", split = FALSE)
[16:06:16.225]         if (TRUE) {
[16:06:16.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.225]         }
[16:06:16.225]         else {
[16:06:16.225]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.225]         }
[16:06:16.225]         base::close(...future.stdout)
[16:06:16.225]         ...future.stdout <- NULL
[16:06:16.225]     }
[16:06:16.225]     ...future.result$conditions <- ...future.conditions
[16:06:16.225]     ...future.result$finished <- base::Sys.time()
[16:06:16.225]     ...future.result
[16:06:16.225] }
[16:06:16.229] MultisessionFuture started
[16:06:16.229] - Launch lazy future ... done
[16:06:16.229] run() for ‘MultisessionFuture’ ... done
[16:06:16.229] resolve() on environment ...
[16:06:16.229]  recursive: 0
[16:06:16.230]  elements: [3] ‘a’
[16:06:16.254]  length: 2 (resolved future 3)
[16:06:16.265] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.265] - Validating connection of MultisessionFuture
[16:06:16.265] - received message: FutureResult
[16:06:16.265] - Received FutureResult
[16:06:16.265] - Erased future from FutureRegistry
[16:06:16.265] result() for ClusterFuture ...
[16:06:16.265] - result already collected: FutureResult
[16:06:16.266] result() for ClusterFuture ... done
[16:06:16.266] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.266] Future #1
[16:06:16.266]  length: 1 (resolved future 1)
[16:06:16.275] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.275] - Validating connection of MultisessionFuture
[16:06:16.275] - received message: FutureResult
[16:06:16.276] - Received FutureResult
[16:06:16.276] - Erased future from FutureRegistry
[16:06:16.276] result() for ClusterFuture ...
[16:06:16.276] - result already collected: FutureResult
[16:06:16.276] result() for ClusterFuture ... done
[16:06:16.276] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.276] Future #2
[16:06:16.276]  length: 0 (resolved future 2)
[16:06:16.276] resolve() on environment ... DONE
[16:06:16.277] resolve() on environment ...
[16:06:16.277]  recursive: 0
[16:06:16.277]  elements: [3] ‘b’
[16:06:16.278] Future #1
[16:06:16.278]  length: 2 (resolved future 1)
[16:06:16.278] Future #2
[16:06:16.278]  length: 1 (resolved future 2)
[16:06:16.278]  length: 0 (resolved future 3)
[16:06:16.278] resolve() on environment ... DONE
[16:06:16.278] resolve() on environment ...
[16:06:16.279]  recursive: 0
[16:06:16.279]  elements: [3] ‘c’
[16:06:16.279] Future #1
[16:06:16.279]  length: 2 (resolved future 1)
[16:06:16.279] Future #2
[16:06:16.279]  length: 1 (resolved future 2)
[16:06:16.280]  length: 0 (resolved future 3)
[16:06:16.280] resolve() on environment ... DONE
[16:06:16.280] resolve() on environment ...
[16:06:16.280]  recursive: 0
[16:06:16.281]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[16:06:16.281] Future #1
[16:06:16.281] result() for ClusterFuture ...
[16:06:16.281] - result already collected: FutureResult
[16:06:16.281] result() for ClusterFuture ... done
[16:06:16.281] result() for ClusterFuture ...
[16:06:16.281] - result already collected: FutureResult
[16:06:16.281] result() for ClusterFuture ... done
[16:06:16.281]  length: 2 (resolved future 1)
[16:06:16.281] Future #2
[16:06:16.282] result() for ClusterFuture ...
[16:06:16.282] - result already collected: FutureResult
[16:06:16.282] result() for ClusterFuture ... done
[16:06:16.282] result() for ClusterFuture ...
[16:06:16.282] - result already collected: FutureResult
[16:06:16.282] result() for ClusterFuture ... done
[16:06:16.282]  length: 1 (resolved future 2)
[16:06:16.282]  length: 0 (resolved future 3)
[16:06:16.282] resolve() on environment ... DONE
[16:06:16.283] resolve() on environment ...
[16:06:16.283]  recursive: 99
[16:06:16.283]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[16:06:16.283] Future #1
[16:06:16.283] result() for ClusterFuture ...
[16:06:16.284] - result already collected: FutureResult
[16:06:16.284] result() for ClusterFuture ... done
[16:06:16.284] result() for ClusterFuture ...
[16:06:16.284] - result already collected: FutureResult
[16:06:16.284] result() for ClusterFuture ... done
[16:06:16.284] A MultisessionFuture was resolved
[16:06:16.284]  length: 2 (resolved future 1)
[16:06:16.284] Future #2
[16:06:16.284] result() for ClusterFuture ...
[16:06:16.284] - result already collected: FutureResult
[16:06:16.284] result() for ClusterFuture ... done
[16:06:16.285] result() for ClusterFuture ...
[16:06:16.285] - result already collected: FutureResult
[16:06:16.285] result() for ClusterFuture ... done
[16:06:16.285] A MultisessionFuture was resolved
[16:06:16.285]  length: 1 (resolved future 2)
[16:06:16.285]  length: 0 (resolved future 3)
[16:06:16.285] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[16:06:16.286] resolve() on list environment ...
[16:06:16.286]  recursive: 0
[16:06:16.286]  length: 2
[16:06:16.286]  elements: ‘a’, ‘b’
[16:06:16.287]  length: 1 (resolved future 1)
[16:06:16.287]  length: 0 (resolved future 2)
[16:06:16.287] resolve() on list environment ... DONE
[16:06:16.287] getGlobalsAndPackages() ...
[16:06:16.287] Searching for globals...
[16:06:16.287] 
[16:06:16.287] Searching for globals ... DONE
[16:06:16.288] - globals: [0] <none>
[16:06:16.288] getGlobalsAndPackages() ... DONE
[16:06:16.288] run() for ‘Future’ ...
[16:06:16.288] - state: ‘created’
[16:06:16.288] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.302] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.302]   - Field: ‘node’
[16:06:16.302]   - Field: ‘label’
[16:06:16.302]   - Field: ‘local’
[16:06:16.302]   - Field: ‘owner’
[16:06:16.302]   - Field: ‘envir’
[16:06:16.302]   - Field: ‘workers’
[16:06:16.302]   - Field: ‘packages’
[16:06:16.302]   - Field: ‘gc’
[16:06:16.303]   - Field: ‘conditions’
[16:06:16.303]   - Field: ‘persistent’
[16:06:16.303]   - Field: ‘expr’
[16:06:16.303]   - Field: ‘uuid’
[16:06:16.303]   - Field: ‘seed’
[16:06:16.303]   - Field: ‘version’
[16:06:16.303]   - Field: ‘result’
[16:06:16.303]   - Field: ‘asynchronous’
[16:06:16.303]   - Field: ‘calls’
[16:06:16.303]   - Field: ‘globals’
[16:06:16.304]   - Field: ‘stdout’
[16:06:16.304]   - Field: ‘earlySignal’
[16:06:16.304]   - Field: ‘lazy’
[16:06:16.304]   - Field: ‘state’
[16:06:16.304] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.304] - Launch lazy future ...
[16:06:16.304] Packages needed by the future expression (n = 0): <none>
[16:06:16.304] Packages needed by future strategies (n = 0): <none>
[16:06:16.305] {
[16:06:16.305]     {
[16:06:16.305]         {
[16:06:16.305]             ...future.startTime <- base::Sys.time()
[16:06:16.305]             {
[16:06:16.305]                 {
[16:06:16.305]                   {
[16:06:16.305]                     {
[16:06:16.305]                       base::local({
[16:06:16.305]                         has_future <- base::requireNamespace("future", 
[16:06:16.305]                           quietly = TRUE)
[16:06:16.305]                         if (has_future) {
[16:06:16.305]                           ns <- base::getNamespace("future")
[16:06:16.305]                           version <- ns[[".package"]][["version"]]
[16:06:16.305]                           if (is.null(version)) 
[16:06:16.305]                             version <- utils::packageVersion("future")
[16:06:16.305]                         }
[16:06:16.305]                         else {
[16:06:16.305]                           version <- NULL
[16:06:16.305]                         }
[16:06:16.305]                         if (!has_future || version < "1.8.0") {
[16:06:16.305]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.305]                             "", base::R.version$version.string), 
[16:06:16.305]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.305]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.305]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.305]                               "release", "version")], collapse = " "), 
[16:06:16.305]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.305]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.305]                             info)
[16:06:16.305]                           info <- base::paste(info, collapse = "; ")
[16:06:16.305]                           if (!has_future) {
[16:06:16.305]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.305]                               info)
[16:06:16.305]                           }
[16:06:16.305]                           else {
[16:06:16.305]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.305]                               info, version)
[16:06:16.305]                           }
[16:06:16.305]                           base::stop(msg)
[16:06:16.305]                         }
[16:06:16.305]                       })
[16:06:16.305]                     }
[16:06:16.305]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.305]                     base::options(mc.cores = 1L)
[16:06:16.305]                   }
[16:06:16.305]                   options(future.plan = NULL)
[16:06:16.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.305]                 }
[16:06:16.305]                 ...future.workdir <- getwd()
[16:06:16.305]             }
[16:06:16.305]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.305]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.305]         }
[16:06:16.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.305]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.305]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.305]             base::names(...future.oldOptions))
[16:06:16.305]     }
[16:06:16.305]     if (FALSE) {
[16:06:16.305]     }
[16:06:16.305]     else {
[16:06:16.305]         if (TRUE) {
[16:06:16.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.305]                 open = "w")
[16:06:16.305]         }
[16:06:16.305]         else {
[16:06:16.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.305]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.305]         }
[16:06:16.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.305]             base::sink(type = "output", split = FALSE)
[16:06:16.305]             base::close(...future.stdout)
[16:06:16.305]         }, add = TRUE)
[16:06:16.305]     }
[16:06:16.305]     ...future.frame <- base::sys.nframe()
[16:06:16.305]     ...future.conditions <- base::list()
[16:06:16.305]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.305]     if (FALSE) {
[16:06:16.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.305]     }
[16:06:16.305]     ...future.result <- base::tryCatch({
[16:06:16.305]         base::withCallingHandlers({
[16:06:16.305]             ...future.value <- base::withVisible(base::local({
[16:06:16.305]                 ...future.makeSendCondition <- base::local({
[16:06:16.305]                   sendCondition <- NULL
[16:06:16.305]                   function(frame = 1L) {
[16:06:16.305]                     if (is.function(sendCondition)) 
[16:06:16.305]                       return(sendCondition)
[16:06:16.305]                     ns <- getNamespace("parallel")
[16:06:16.305]                     if (exists("sendData", mode = "function", 
[16:06:16.305]                       envir = ns)) {
[16:06:16.305]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.305]                         envir = ns)
[16:06:16.305]                       envir <- sys.frame(frame)
[16:06:16.305]                       master <- NULL
[16:06:16.305]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.305]                         !identical(envir, emptyenv())) {
[16:06:16.305]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.305]                           inherits = FALSE)) {
[16:06:16.305]                           master <- get("master", mode = "list", 
[16:06:16.305]                             envir = envir, inherits = FALSE)
[16:06:16.305]                           if (inherits(master, c("SOCKnode", 
[16:06:16.305]                             "SOCK0node"))) {
[16:06:16.305]                             sendCondition <<- function(cond) {
[16:06:16.305]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.305]                                 success = TRUE)
[16:06:16.305]                               parallel_sendData(master, data)
[16:06:16.305]                             }
[16:06:16.305]                             return(sendCondition)
[16:06:16.305]                           }
[16:06:16.305]                         }
[16:06:16.305]                         frame <- frame + 1L
[16:06:16.305]                         envir <- sys.frame(frame)
[16:06:16.305]                       }
[16:06:16.305]                     }
[16:06:16.305]                     sendCondition <<- function(cond) NULL
[16:06:16.305]                   }
[16:06:16.305]                 })
[16:06:16.305]                 withCallingHandlers({
[16:06:16.305]                   1
[16:06:16.305]                 }, immediateCondition = function(cond) {
[16:06:16.305]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.305]                   sendCondition(cond)
[16:06:16.305]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.305]                   {
[16:06:16.305]                     inherits <- base::inherits
[16:06:16.305]                     invokeRestart <- base::invokeRestart
[16:06:16.305]                     is.null <- base::is.null
[16:06:16.305]                     muffled <- FALSE
[16:06:16.305]                     if (inherits(cond, "message")) {
[16:06:16.305]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.305]                       if (muffled) 
[16:06:16.305]                         invokeRestart("muffleMessage")
[16:06:16.305]                     }
[16:06:16.305]                     else if (inherits(cond, "warning")) {
[16:06:16.305]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.305]                       if (muffled) 
[16:06:16.305]                         invokeRestart("muffleWarning")
[16:06:16.305]                     }
[16:06:16.305]                     else if (inherits(cond, "condition")) {
[16:06:16.305]                       if (!is.null(pattern)) {
[16:06:16.305]                         computeRestarts <- base::computeRestarts
[16:06:16.305]                         grepl <- base::grepl
[16:06:16.305]                         restarts <- computeRestarts(cond)
[16:06:16.305]                         for (restart in restarts) {
[16:06:16.305]                           name <- restart$name
[16:06:16.305]                           if (is.null(name)) 
[16:06:16.305]                             next
[16:06:16.305]                           if (!grepl(pattern, name)) 
[16:06:16.305]                             next
[16:06:16.305]                           invokeRestart(restart)
[16:06:16.305]                           muffled <- TRUE
[16:06:16.305]                           break
[16:06:16.305]                         }
[16:06:16.305]                       }
[16:06:16.305]                     }
[16:06:16.305]                     invisible(muffled)
[16:06:16.305]                   }
[16:06:16.305]                   muffleCondition(cond)
[16:06:16.305]                 })
[16:06:16.305]             }))
[16:06:16.305]             future::FutureResult(value = ...future.value$value, 
[16:06:16.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.305]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.305]                     ...future.globalenv.names))
[16:06:16.305]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.305]         }, condition = base::local({
[16:06:16.305]             c <- base::c
[16:06:16.305]             inherits <- base::inherits
[16:06:16.305]             invokeRestart <- base::invokeRestart
[16:06:16.305]             length <- base::length
[16:06:16.305]             list <- base::list
[16:06:16.305]             seq.int <- base::seq.int
[16:06:16.305]             signalCondition <- base::signalCondition
[16:06:16.305]             sys.calls <- base::sys.calls
[16:06:16.305]             `[[` <- base::`[[`
[16:06:16.305]             `+` <- base::`+`
[16:06:16.305]             `<<-` <- base::`<<-`
[16:06:16.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.305]                   3L)]
[16:06:16.305]             }
[16:06:16.305]             function(cond) {
[16:06:16.305]                 is_error <- inherits(cond, "error")
[16:06:16.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.305]                   NULL)
[16:06:16.305]                 if (is_error) {
[16:06:16.305]                   sessionInformation <- function() {
[16:06:16.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.305]                       search = base::search(), system = base::Sys.info())
[16:06:16.305]                   }
[16:06:16.305]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.305]                     cond$call), session = sessionInformation(), 
[16:06:16.305]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.305]                   signalCondition(cond)
[16:06:16.305]                 }
[16:06:16.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.305]                 "immediateCondition"))) {
[16:06:16.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.305]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.305]                   if (TRUE && !signal) {
[16:06:16.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.305]                     {
[16:06:16.305]                       inherits <- base::inherits
[16:06:16.305]                       invokeRestart <- base::invokeRestart
[16:06:16.305]                       is.null <- base::is.null
[16:06:16.305]                       muffled <- FALSE
[16:06:16.305]                       if (inherits(cond, "message")) {
[16:06:16.305]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.305]                         if (muffled) 
[16:06:16.305]                           invokeRestart("muffleMessage")
[16:06:16.305]                       }
[16:06:16.305]                       else if (inherits(cond, "warning")) {
[16:06:16.305]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.305]                         if (muffled) 
[16:06:16.305]                           invokeRestart("muffleWarning")
[16:06:16.305]                       }
[16:06:16.305]                       else if (inherits(cond, "condition")) {
[16:06:16.305]                         if (!is.null(pattern)) {
[16:06:16.305]                           computeRestarts <- base::computeRestarts
[16:06:16.305]                           grepl <- base::grepl
[16:06:16.305]                           restarts <- computeRestarts(cond)
[16:06:16.305]                           for (restart in restarts) {
[16:06:16.305]                             name <- restart$name
[16:06:16.305]                             if (is.null(name)) 
[16:06:16.305]                               next
[16:06:16.305]                             if (!grepl(pattern, name)) 
[16:06:16.305]                               next
[16:06:16.305]                             invokeRestart(restart)
[16:06:16.305]                             muffled <- TRUE
[16:06:16.305]                             break
[16:06:16.305]                           }
[16:06:16.305]                         }
[16:06:16.305]                       }
[16:06:16.305]                       invisible(muffled)
[16:06:16.305]                     }
[16:06:16.305]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.305]                   }
[16:06:16.305]                 }
[16:06:16.305]                 else {
[16:06:16.305]                   if (TRUE) {
[16:06:16.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.305]                     {
[16:06:16.305]                       inherits <- base::inherits
[16:06:16.305]                       invokeRestart <- base::invokeRestart
[16:06:16.305]                       is.null <- base::is.null
[16:06:16.305]                       muffled <- FALSE
[16:06:16.305]                       if (inherits(cond, "message")) {
[16:06:16.305]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.305]                         if (muffled) 
[16:06:16.305]                           invokeRestart("muffleMessage")
[16:06:16.305]                       }
[16:06:16.305]                       else if (inherits(cond, "warning")) {
[16:06:16.305]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.305]                         if (muffled) 
[16:06:16.305]                           invokeRestart("muffleWarning")
[16:06:16.305]                       }
[16:06:16.305]                       else if (inherits(cond, "condition")) {
[16:06:16.305]                         if (!is.null(pattern)) {
[16:06:16.305]                           computeRestarts <- base::computeRestarts
[16:06:16.305]                           grepl <- base::grepl
[16:06:16.305]                           restarts <- computeRestarts(cond)
[16:06:16.305]                           for (restart in restarts) {
[16:06:16.305]                             name <- restart$name
[16:06:16.305]                             if (is.null(name)) 
[16:06:16.305]                               next
[16:06:16.305]                             if (!grepl(pattern, name)) 
[16:06:16.305]                               next
[16:06:16.305]                             invokeRestart(restart)
[16:06:16.305]                             muffled <- TRUE
[16:06:16.305]                             break
[16:06:16.305]                           }
[16:06:16.305]                         }
[16:06:16.305]                       }
[16:06:16.305]                       invisible(muffled)
[16:06:16.305]                     }
[16:06:16.305]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.305]                   }
[16:06:16.305]                 }
[16:06:16.305]             }
[16:06:16.305]         }))
[16:06:16.305]     }, error = function(ex) {
[16:06:16.305]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.305]                 ...future.rng), started = ...future.startTime, 
[16:06:16.305]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.305]             version = "1.8"), class = "FutureResult")
[16:06:16.305]     }, finally = {
[16:06:16.305]         if (!identical(...future.workdir, getwd())) 
[16:06:16.305]             setwd(...future.workdir)
[16:06:16.305]         {
[16:06:16.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.305]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.305]             }
[16:06:16.305]             base::options(...future.oldOptions)
[16:06:16.305]             if (.Platform$OS.type == "windows") {
[16:06:16.305]                 old_names <- names(...future.oldEnvVars)
[16:06:16.305]                 envs <- base::Sys.getenv()
[16:06:16.305]                 names <- names(envs)
[16:06:16.305]                 common <- intersect(names, old_names)
[16:06:16.305]                 added <- setdiff(names, old_names)
[16:06:16.305]                 removed <- setdiff(old_names, names)
[16:06:16.305]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.305]                   envs[common]]
[16:06:16.305]                 NAMES <- toupper(changed)
[16:06:16.305]                 args <- list()
[16:06:16.305]                 for (kk in seq_along(NAMES)) {
[16:06:16.305]                   name <- changed[[kk]]
[16:06:16.305]                   NAME <- NAMES[[kk]]
[16:06:16.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.305]                     next
[16:06:16.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.305]                 }
[16:06:16.305]                 NAMES <- toupper(added)
[16:06:16.305]                 for (kk in seq_along(NAMES)) {
[16:06:16.305]                   name <- added[[kk]]
[16:06:16.305]                   NAME <- NAMES[[kk]]
[16:06:16.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.305]                     next
[16:06:16.305]                   args[[name]] <- ""
[16:06:16.305]                 }
[16:06:16.305]                 NAMES <- toupper(removed)
[16:06:16.305]                 for (kk in seq_along(NAMES)) {
[16:06:16.305]                   name <- removed[[kk]]
[16:06:16.305]                   NAME <- NAMES[[kk]]
[16:06:16.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.305]                     next
[16:06:16.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.305]                 }
[16:06:16.305]                 if (length(args) > 0) 
[16:06:16.305]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.305]             }
[16:06:16.305]             else {
[16:06:16.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.305]             }
[16:06:16.305]             {
[16:06:16.305]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.305]                   0L) {
[16:06:16.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.305]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.305]                   base::options(opts)
[16:06:16.305]                 }
[16:06:16.305]                 {
[16:06:16.305]                   {
[16:06:16.305]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.305]                     NULL
[16:06:16.305]                   }
[16:06:16.305]                   options(future.plan = NULL)
[16:06:16.305]                   if (is.na(NA_character_)) 
[16:06:16.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.305]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.305]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.305]                     envir = parent.frame()) 
[16:06:16.305]                   {
[16:06:16.305]                     if (is.function(workers)) 
[16:06:16.305]                       workers <- workers()
[16:06:16.305]                     workers <- structure(as.integer(workers), 
[16:06:16.305]                       class = class(workers))
[16:06:16.305]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.305]                       workers >= 1)
[16:06:16.305]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.305]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.305]                     }
[16:06:16.305]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.305]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.305]                       envir = envir)
[16:06:16.305]                     if (!future$lazy) 
[16:06:16.305]                       future <- run(future)
[16:06:16.305]                     invisible(future)
[16:06:16.305]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.305]                 }
[16:06:16.305]             }
[16:06:16.305]         }
[16:06:16.305]     })
[16:06:16.305]     if (TRUE) {
[16:06:16.305]         base::sink(type = "output", split = FALSE)
[16:06:16.305]         if (TRUE) {
[16:06:16.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.305]         }
[16:06:16.305]         else {
[16:06:16.305]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.305]         }
[16:06:16.305]         base::close(...future.stdout)
[16:06:16.305]         ...future.stdout <- NULL
[16:06:16.305]     }
[16:06:16.305]     ...future.result$conditions <- ...future.conditions
[16:06:16.305]     ...future.result$finished <- base::Sys.time()
[16:06:16.305]     ...future.result
[16:06:16.305] }
[16:06:16.308] MultisessionFuture started
[16:06:16.308] - Launch lazy future ... done
[16:06:16.308] run() for ‘MultisessionFuture’ ... done
[16:06:16.308] getGlobalsAndPackages() ...
[16:06:16.308] Searching for globals...
[16:06:16.309] 
[16:06:16.309] Searching for globals ... DONE
[16:06:16.309] - globals: [0] <none>
[16:06:16.309] getGlobalsAndPackages() ... DONE
[16:06:16.309] run() for ‘Future’ ...
[16:06:16.309] - state: ‘created’
[16:06:16.310] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.326]   - Field: ‘node’
[16:06:16.326]   - Field: ‘label’
[16:06:16.327]   - Field: ‘local’
[16:06:16.327]   - Field: ‘owner’
[16:06:16.327]   - Field: ‘envir’
[16:06:16.327]   - Field: ‘workers’
[16:06:16.327]   - Field: ‘packages’
[16:06:16.327]   - Field: ‘gc’
[16:06:16.327]   - Field: ‘conditions’
[16:06:16.327]   - Field: ‘persistent’
[16:06:16.327]   - Field: ‘expr’
[16:06:16.327]   - Field: ‘uuid’
[16:06:16.328]   - Field: ‘seed’
[16:06:16.328]   - Field: ‘version’
[16:06:16.328]   - Field: ‘result’
[16:06:16.328]   - Field: ‘asynchronous’
[16:06:16.328]   - Field: ‘calls’
[16:06:16.328]   - Field: ‘globals’
[16:06:16.328]   - Field: ‘stdout’
[16:06:16.328]   - Field: ‘earlySignal’
[16:06:16.328]   - Field: ‘lazy’
[16:06:16.328]   - Field: ‘state’
[16:06:16.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.329] - Launch lazy future ...
[16:06:16.329] Packages needed by the future expression (n = 0): <none>
[16:06:16.329] Packages needed by future strategies (n = 0): <none>
[16:06:16.329] {
[16:06:16.329]     {
[16:06:16.329]         {
[16:06:16.329]             ...future.startTime <- base::Sys.time()
[16:06:16.329]             {
[16:06:16.329]                 {
[16:06:16.329]                   {
[16:06:16.329]                     {
[16:06:16.329]                       base::local({
[16:06:16.329]                         has_future <- base::requireNamespace("future", 
[16:06:16.329]                           quietly = TRUE)
[16:06:16.329]                         if (has_future) {
[16:06:16.329]                           ns <- base::getNamespace("future")
[16:06:16.329]                           version <- ns[[".package"]][["version"]]
[16:06:16.329]                           if (is.null(version)) 
[16:06:16.329]                             version <- utils::packageVersion("future")
[16:06:16.329]                         }
[16:06:16.329]                         else {
[16:06:16.329]                           version <- NULL
[16:06:16.329]                         }
[16:06:16.329]                         if (!has_future || version < "1.8.0") {
[16:06:16.329]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.329]                             "", base::R.version$version.string), 
[16:06:16.329]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.329]                               "release", "version")], collapse = " "), 
[16:06:16.329]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.329]                             info)
[16:06:16.329]                           info <- base::paste(info, collapse = "; ")
[16:06:16.329]                           if (!has_future) {
[16:06:16.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.329]                               info)
[16:06:16.329]                           }
[16:06:16.329]                           else {
[16:06:16.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.329]                               info, version)
[16:06:16.329]                           }
[16:06:16.329]                           base::stop(msg)
[16:06:16.329]                         }
[16:06:16.329]                       })
[16:06:16.329]                     }
[16:06:16.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.329]                     base::options(mc.cores = 1L)
[16:06:16.329]                   }
[16:06:16.329]                   options(future.plan = NULL)
[16:06:16.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.329]                 }
[16:06:16.329]                 ...future.workdir <- getwd()
[16:06:16.329]             }
[16:06:16.329]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.329]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.329]         }
[16:06:16.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.329]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.329]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.329]             base::names(...future.oldOptions))
[16:06:16.329]     }
[16:06:16.329]     if (FALSE) {
[16:06:16.329]     }
[16:06:16.329]     else {
[16:06:16.329]         if (TRUE) {
[16:06:16.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.329]                 open = "w")
[16:06:16.329]         }
[16:06:16.329]         else {
[16:06:16.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.329]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.329]         }
[16:06:16.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.329]             base::sink(type = "output", split = FALSE)
[16:06:16.329]             base::close(...future.stdout)
[16:06:16.329]         }, add = TRUE)
[16:06:16.329]     }
[16:06:16.329]     ...future.frame <- base::sys.nframe()
[16:06:16.329]     ...future.conditions <- base::list()
[16:06:16.329]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.329]     if (FALSE) {
[16:06:16.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.329]     }
[16:06:16.329]     ...future.result <- base::tryCatch({
[16:06:16.329]         base::withCallingHandlers({
[16:06:16.329]             ...future.value <- base::withVisible(base::local({
[16:06:16.329]                 ...future.makeSendCondition <- base::local({
[16:06:16.329]                   sendCondition <- NULL
[16:06:16.329]                   function(frame = 1L) {
[16:06:16.329]                     if (is.function(sendCondition)) 
[16:06:16.329]                       return(sendCondition)
[16:06:16.329]                     ns <- getNamespace("parallel")
[16:06:16.329]                     if (exists("sendData", mode = "function", 
[16:06:16.329]                       envir = ns)) {
[16:06:16.329]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.329]                         envir = ns)
[16:06:16.329]                       envir <- sys.frame(frame)
[16:06:16.329]                       master <- NULL
[16:06:16.329]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.329]                         !identical(envir, emptyenv())) {
[16:06:16.329]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.329]                           inherits = FALSE)) {
[16:06:16.329]                           master <- get("master", mode = "list", 
[16:06:16.329]                             envir = envir, inherits = FALSE)
[16:06:16.329]                           if (inherits(master, c("SOCKnode", 
[16:06:16.329]                             "SOCK0node"))) {
[16:06:16.329]                             sendCondition <<- function(cond) {
[16:06:16.329]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.329]                                 success = TRUE)
[16:06:16.329]                               parallel_sendData(master, data)
[16:06:16.329]                             }
[16:06:16.329]                             return(sendCondition)
[16:06:16.329]                           }
[16:06:16.329]                         }
[16:06:16.329]                         frame <- frame + 1L
[16:06:16.329]                         envir <- sys.frame(frame)
[16:06:16.329]                       }
[16:06:16.329]                     }
[16:06:16.329]                     sendCondition <<- function(cond) NULL
[16:06:16.329]                   }
[16:06:16.329]                 })
[16:06:16.329]                 withCallingHandlers({
[16:06:16.329]                   2
[16:06:16.329]                 }, immediateCondition = function(cond) {
[16:06:16.329]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.329]                   sendCondition(cond)
[16:06:16.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.329]                   {
[16:06:16.329]                     inherits <- base::inherits
[16:06:16.329]                     invokeRestart <- base::invokeRestart
[16:06:16.329]                     is.null <- base::is.null
[16:06:16.329]                     muffled <- FALSE
[16:06:16.329]                     if (inherits(cond, "message")) {
[16:06:16.329]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.329]                       if (muffled) 
[16:06:16.329]                         invokeRestart("muffleMessage")
[16:06:16.329]                     }
[16:06:16.329]                     else if (inherits(cond, "warning")) {
[16:06:16.329]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.329]                       if (muffled) 
[16:06:16.329]                         invokeRestart("muffleWarning")
[16:06:16.329]                     }
[16:06:16.329]                     else if (inherits(cond, "condition")) {
[16:06:16.329]                       if (!is.null(pattern)) {
[16:06:16.329]                         computeRestarts <- base::computeRestarts
[16:06:16.329]                         grepl <- base::grepl
[16:06:16.329]                         restarts <- computeRestarts(cond)
[16:06:16.329]                         for (restart in restarts) {
[16:06:16.329]                           name <- restart$name
[16:06:16.329]                           if (is.null(name)) 
[16:06:16.329]                             next
[16:06:16.329]                           if (!grepl(pattern, name)) 
[16:06:16.329]                             next
[16:06:16.329]                           invokeRestart(restart)
[16:06:16.329]                           muffled <- TRUE
[16:06:16.329]                           break
[16:06:16.329]                         }
[16:06:16.329]                       }
[16:06:16.329]                     }
[16:06:16.329]                     invisible(muffled)
[16:06:16.329]                   }
[16:06:16.329]                   muffleCondition(cond)
[16:06:16.329]                 })
[16:06:16.329]             }))
[16:06:16.329]             future::FutureResult(value = ...future.value$value, 
[16:06:16.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.329]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.329]                     ...future.globalenv.names))
[16:06:16.329]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.329]         }, condition = base::local({
[16:06:16.329]             c <- base::c
[16:06:16.329]             inherits <- base::inherits
[16:06:16.329]             invokeRestart <- base::invokeRestart
[16:06:16.329]             length <- base::length
[16:06:16.329]             list <- base::list
[16:06:16.329]             seq.int <- base::seq.int
[16:06:16.329]             signalCondition <- base::signalCondition
[16:06:16.329]             sys.calls <- base::sys.calls
[16:06:16.329]             `[[` <- base::`[[`
[16:06:16.329]             `+` <- base::`+`
[16:06:16.329]             `<<-` <- base::`<<-`
[16:06:16.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.329]                   3L)]
[16:06:16.329]             }
[16:06:16.329]             function(cond) {
[16:06:16.329]                 is_error <- inherits(cond, "error")
[16:06:16.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.329]                   NULL)
[16:06:16.329]                 if (is_error) {
[16:06:16.329]                   sessionInformation <- function() {
[16:06:16.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.329]                       search = base::search(), system = base::Sys.info())
[16:06:16.329]                   }
[16:06:16.329]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.329]                     cond$call), session = sessionInformation(), 
[16:06:16.329]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.329]                   signalCondition(cond)
[16:06:16.329]                 }
[16:06:16.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.329]                 "immediateCondition"))) {
[16:06:16.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.329]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.329]                   if (TRUE && !signal) {
[16:06:16.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.329]                     {
[16:06:16.329]                       inherits <- base::inherits
[16:06:16.329]                       invokeRestart <- base::invokeRestart
[16:06:16.329]                       is.null <- base::is.null
[16:06:16.329]                       muffled <- FALSE
[16:06:16.329]                       if (inherits(cond, "message")) {
[16:06:16.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.329]                         if (muffled) 
[16:06:16.329]                           invokeRestart("muffleMessage")
[16:06:16.329]                       }
[16:06:16.329]                       else if (inherits(cond, "warning")) {
[16:06:16.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.329]                         if (muffled) 
[16:06:16.329]                           invokeRestart("muffleWarning")
[16:06:16.329]                       }
[16:06:16.329]                       else if (inherits(cond, "condition")) {
[16:06:16.329]                         if (!is.null(pattern)) {
[16:06:16.329]                           computeRestarts <- base::computeRestarts
[16:06:16.329]                           grepl <- base::grepl
[16:06:16.329]                           restarts <- computeRestarts(cond)
[16:06:16.329]                           for (restart in restarts) {
[16:06:16.329]                             name <- restart$name
[16:06:16.329]                             if (is.null(name)) 
[16:06:16.329]                               next
[16:06:16.329]                             if (!grepl(pattern, name)) 
[16:06:16.329]                               next
[16:06:16.329]                             invokeRestart(restart)
[16:06:16.329]                             muffled <- TRUE
[16:06:16.329]                             break
[16:06:16.329]                           }
[16:06:16.329]                         }
[16:06:16.329]                       }
[16:06:16.329]                       invisible(muffled)
[16:06:16.329]                     }
[16:06:16.329]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.329]                   }
[16:06:16.329]                 }
[16:06:16.329]                 else {
[16:06:16.329]                   if (TRUE) {
[16:06:16.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.329]                     {
[16:06:16.329]                       inherits <- base::inherits
[16:06:16.329]                       invokeRestart <- base::invokeRestart
[16:06:16.329]                       is.null <- base::is.null
[16:06:16.329]                       muffled <- FALSE
[16:06:16.329]                       if (inherits(cond, "message")) {
[16:06:16.329]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.329]                         if (muffled) 
[16:06:16.329]                           invokeRestart("muffleMessage")
[16:06:16.329]                       }
[16:06:16.329]                       else if (inherits(cond, "warning")) {
[16:06:16.329]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.329]                         if (muffled) 
[16:06:16.329]                           invokeRestart("muffleWarning")
[16:06:16.329]                       }
[16:06:16.329]                       else if (inherits(cond, "condition")) {
[16:06:16.329]                         if (!is.null(pattern)) {
[16:06:16.329]                           computeRestarts <- base::computeRestarts
[16:06:16.329]                           grepl <- base::grepl
[16:06:16.329]                           restarts <- computeRestarts(cond)
[16:06:16.329]                           for (restart in restarts) {
[16:06:16.329]                             name <- restart$name
[16:06:16.329]                             if (is.null(name)) 
[16:06:16.329]                               next
[16:06:16.329]                             if (!grepl(pattern, name)) 
[16:06:16.329]                               next
[16:06:16.329]                             invokeRestart(restart)
[16:06:16.329]                             muffled <- TRUE
[16:06:16.329]                             break
[16:06:16.329]                           }
[16:06:16.329]                         }
[16:06:16.329]                       }
[16:06:16.329]                       invisible(muffled)
[16:06:16.329]                     }
[16:06:16.329]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.329]                   }
[16:06:16.329]                 }
[16:06:16.329]             }
[16:06:16.329]         }))
[16:06:16.329]     }, error = function(ex) {
[16:06:16.329]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.329]                 ...future.rng), started = ...future.startTime, 
[16:06:16.329]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.329]             version = "1.8"), class = "FutureResult")
[16:06:16.329]     }, finally = {
[16:06:16.329]         if (!identical(...future.workdir, getwd())) 
[16:06:16.329]             setwd(...future.workdir)
[16:06:16.329]         {
[16:06:16.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.329]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.329]             }
[16:06:16.329]             base::options(...future.oldOptions)
[16:06:16.329]             if (.Platform$OS.type == "windows") {
[16:06:16.329]                 old_names <- names(...future.oldEnvVars)
[16:06:16.329]                 envs <- base::Sys.getenv()
[16:06:16.329]                 names <- names(envs)
[16:06:16.329]                 common <- intersect(names, old_names)
[16:06:16.329]                 added <- setdiff(names, old_names)
[16:06:16.329]                 removed <- setdiff(old_names, names)
[16:06:16.329]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.329]                   envs[common]]
[16:06:16.329]                 NAMES <- toupper(changed)
[16:06:16.329]                 args <- list()
[16:06:16.329]                 for (kk in seq_along(NAMES)) {
[16:06:16.329]                   name <- changed[[kk]]
[16:06:16.329]                   NAME <- NAMES[[kk]]
[16:06:16.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.329]                     next
[16:06:16.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.329]                 }
[16:06:16.329]                 NAMES <- toupper(added)
[16:06:16.329]                 for (kk in seq_along(NAMES)) {
[16:06:16.329]                   name <- added[[kk]]
[16:06:16.329]                   NAME <- NAMES[[kk]]
[16:06:16.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.329]                     next
[16:06:16.329]                   args[[name]] <- ""
[16:06:16.329]                 }
[16:06:16.329]                 NAMES <- toupper(removed)
[16:06:16.329]                 for (kk in seq_along(NAMES)) {
[16:06:16.329]                   name <- removed[[kk]]
[16:06:16.329]                   NAME <- NAMES[[kk]]
[16:06:16.329]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.329]                     next
[16:06:16.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.329]                 }
[16:06:16.329]                 if (length(args) > 0) 
[16:06:16.329]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.329]             }
[16:06:16.329]             else {
[16:06:16.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.329]             }
[16:06:16.329]             {
[16:06:16.329]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.329]                   0L) {
[16:06:16.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.329]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.329]                   base::options(opts)
[16:06:16.329]                 }
[16:06:16.329]                 {
[16:06:16.329]                   {
[16:06:16.329]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.329]                     NULL
[16:06:16.329]                   }
[16:06:16.329]                   options(future.plan = NULL)
[16:06:16.329]                   if (is.na(NA_character_)) 
[16:06:16.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.329]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.329]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.329]                     envir = parent.frame()) 
[16:06:16.329]                   {
[16:06:16.329]                     if (is.function(workers)) 
[16:06:16.329]                       workers <- workers()
[16:06:16.329]                     workers <- structure(as.integer(workers), 
[16:06:16.329]                       class = class(workers))
[16:06:16.329]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.329]                       workers >= 1)
[16:06:16.329]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.329]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.329]                     }
[16:06:16.329]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.329]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.329]                       envir = envir)
[16:06:16.329]                     if (!future$lazy) 
[16:06:16.329]                       future <- run(future)
[16:06:16.329]                     invisible(future)
[16:06:16.329]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.329]                 }
[16:06:16.329]             }
[16:06:16.329]         }
[16:06:16.329]     })
[16:06:16.329]     if (TRUE) {
[16:06:16.329]         base::sink(type = "output", split = FALSE)
[16:06:16.329]         if (TRUE) {
[16:06:16.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.329]         }
[16:06:16.329]         else {
[16:06:16.329]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.329]         }
[16:06:16.329]         base::close(...future.stdout)
[16:06:16.329]         ...future.stdout <- NULL
[16:06:16.329]     }
[16:06:16.329]     ...future.result$conditions <- ...future.conditions
[16:06:16.329]     ...future.result$finished <- base::Sys.time()
[16:06:16.329]     ...future.result
[16:06:16.329] }
[16:06:16.332] MultisessionFuture started
[16:06:16.332] - Launch lazy future ... done
[16:06:16.332] run() for ‘MultisessionFuture’ ... done
[16:06:16.333] resolve() on list environment ...
[16:06:16.333]  recursive: 0
[16:06:16.334]  length: 3
[16:06:16.334]  elements: ‘a’, ‘b’, ‘c’
[16:06:16.355]  length: 2 (resolved future 3)
[16:06:16.365] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.366] - Validating connection of MultisessionFuture
[16:06:16.366] - received message: FutureResult
[16:06:16.366] - Received FutureResult
[16:06:16.366] - Erased future from FutureRegistry
[16:06:16.366] result() for ClusterFuture ...
[16:06:16.366] - result already collected: FutureResult
[16:06:16.366] result() for ClusterFuture ... done
[16:06:16.366] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.367] Future #1
[16:06:16.367]  length: 1 (resolved future 1)
[16:06:16.388] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.388] - Validating connection of MultisessionFuture
[16:06:16.388] - received message: FutureResult
[16:06:16.388] - Received FutureResult
[16:06:16.389] - Erased future from FutureRegistry
[16:06:16.389] result() for ClusterFuture ...
[16:06:16.389] - result already collected: FutureResult
[16:06:16.389] result() for ClusterFuture ... done
[16:06:16.389] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.389] Future #2
[16:06:16.389]  length: 0 (resolved future 2)
[16:06:16.389] resolve() on list environment ... DONE
[16:06:16.390] getGlobalsAndPackages() ...
[16:06:16.390] Searching for globals...
[16:06:16.390] - globals found: [1] ‘{’
[16:06:16.391] Searching for globals ... DONE
[16:06:16.391] Resolving globals: FALSE
[16:06:16.391] 
[16:06:16.391] 
[16:06:16.391] getGlobalsAndPackages() ... DONE
[16:06:16.391] run() for ‘Future’ ...
[16:06:16.392] - state: ‘created’
[16:06:16.392] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.405]   - Field: ‘node’
[16:06:16.405]   - Field: ‘label’
[16:06:16.405]   - Field: ‘local’
[16:06:16.405]   - Field: ‘owner’
[16:06:16.405]   - Field: ‘envir’
[16:06:16.406]   - Field: ‘workers’
[16:06:16.406]   - Field: ‘packages’
[16:06:16.406]   - Field: ‘gc’
[16:06:16.406]   - Field: ‘conditions’
[16:06:16.406]   - Field: ‘persistent’
[16:06:16.406]   - Field: ‘expr’
[16:06:16.406]   - Field: ‘uuid’
[16:06:16.406]   - Field: ‘seed’
[16:06:16.406]   - Field: ‘version’
[16:06:16.406]   - Field: ‘result’
[16:06:16.406]   - Field: ‘asynchronous’
[16:06:16.407]   - Field: ‘calls’
[16:06:16.407]   - Field: ‘globals’
[16:06:16.407]   - Field: ‘stdout’
[16:06:16.407]   - Field: ‘earlySignal’
[16:06:16.407]   - Field: ‘lazy’
[16:06:16.407]   - Field: ‘state’
[16:06:16.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.407] - Launch lazy future ...
[16:06:16.408] Packages needed by the future expression (n = 0): <none>
[16:06:16.408] Packages needed by future strategies (n = 0): <none>
[16:06:16.408] {
[16:06:16.408]     {
[16:06:16.408]         {
[16:06:16.408]             ...future.startTime <- base::Sys.time()
[16:06:16.408]             {
[16:06:16.408]                 {
[16:06:16.408]                   {
[16:06:16.408]                     {
[16:06:16.408]                       base::local({
[16:06:16.408]                         has_future <- base::requireNamespace("future", 
[16:06:16.408]                           quietly = TRUE)
[16:06:16.408]                         if (has_future) {
[16:06:16.408]                           ns <- base::getNamespace("future")
[16:06:16.408]                           version <- ns[[".package"]][["version"]]
[16:06:16.408]                           if (is.null(version)) 
[16:06:16.408]                             version <- utils::packageVersion("future")
[16:06:16.408]                         }
[16:06:16.408]                         else {
[16:06:16.408]                           version <- NULL
[16:06:16.408]                         }
[16:06:16.408]                         if (!has_future || version < "1.8.0") {
[16:06:16.408]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.408]                             "", base::R.version$version.string), 
[16:06:16.408]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.408]                               "release", "version")], collapse = " "), 
[16:06:16.408]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.408]                             info)
[16:06:16.408]                           info <- base::paste(info, collapse = "; ")
[16:06:16.408]                           if (!has_future) {
[16:06:16.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.408]                               info)
[16:06:16.408]                           }
[16:06:16.408]                           else {
[16:06:16.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.408]                               info, version)
[16:06:16.408]                           }
[16:06:16.408]                           base::stop(msg)
[16:06:16.408]                         }
[16:06:16.408]                       })
[16:06:16.408]                     }
[16:06:16.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.408]                     base::options(mc.cores = 1L)
[16:06:16.408]                   }
[16:06:16.408]                   options(future.plan = NULL)
[16:06:16.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.408]                 }
[16:06:16.408]                 ...future.workdir <- getwd()
[16:06:16.408]             }
[16:06:16.408]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.408]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.408]         }
[16:06:16.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.408]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.408]             base::names(...future.oldOptions))
[16:06:16.408]     }
[16:06:16.408]     if (FALSE) {
[16:06:16.408]     }
[16:06:16.408]     else {
[16:06:16.408]         if (TRUE) {
[16:06:16.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.408]                 open = "w")
[16:06:16.408]         }
[16:06:16.408]         else {
[16:06:16.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.408]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.408]         }
[16:06:16.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.408]             base::sink(type = "output", split = FALSE)
[16:06:16.408]             base::close(...future.stdout)
[16:06:16.408]         }, add = TRUE)
[16:06:16.408]     }
[16:06:16.408]     ...future.frame <- base::sys.nframe()
[16:06:16.408]     ...future.conditions <- base::list()
[16:06:16.408]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.408]     if (FALSE) {
[16:06:16.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.408]     }
[16:06:16.408]     ...future.result <- base::tryCatch({
[16:06:16.408]         base::withCallingHandlers({
[16:06:16.408]             ...future.value <- base::withVisible(base::local({
[16:06:16.408]                 ...future.makeSendCondition <- base::local({
[16:06:16.408]                   sendCondition <- NULL
[16:06:16.408]                   function(frame = 1L) {
[16:06:16.408]                     if (is.function(sendCondition)) 
[16:06:16.408]                       return(sendCondition)
[16:06:16.408]                     ns <- getNamespace("parallel")
[16:06:16.408]                     if (exists("sendData", mode = "function", 
[16:06:16.408]                       envir = ns)) {
[16:06:16.408]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.408]                         envir = ns)
[16:06:16.408]                       envir <- sys.frame(frame)
[16:06:16.408]                       master <- NULL
[16:06:16.408]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.408]                         !identical(envir, emptyenv())) {
[16:06:16.408]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.408]                           inherits = FALSE)) {
[16:06:16.408]                           master <- get("master", mode = "list", 
[16:06:16.408]                             envir = envir, inherits = FALSE)
[16:06:16.408]                           if (inherits(master, c("SOCKnode", 
[16:06:16.408]                             "SOCK0node"))) {
[16:06:16.408]                             sendCondition <<- function(cond) {
[16:06:16.408]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.408]                                 success = TRUE)
[16:06:16.408]                               parallel_sendData(master, data)
[16:06:16.408]                             }
[16:06:16.408]                             return(sendCondition)
[16:06:16.408]                           }
[16:06:16.408]                         }
[16:06:16.408]                         frame <- frame + 1L
[16:06:16.408]                         envir <- sys.frame(frame)
[16:06:16.408]                       }
[16:06:16.408]                     }
[16:06:16.408]                     sendCondition <<- function(cond) NULL
[16:06:16.408]                   }
[16:06:16.408]                 })
[16:06:16.408]                 withCallingHandlers({
[16:06:16.408]                   {
[16:06:16.408]                     1
[16:06:16.408]                   }
[16:06:16.408]                 }, immediateCondition = function(cond) {
[16:06:16.408]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.408]                   sendCondition(cond)
[16:06:16.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.408]                   {
[16:06:16.408]                     inherits <- base::inherits
[16:06:16.408]                     invokeRestart <- base::invokeRestart
[16:06:16.408]                     is.null <- base::is.null
[16:06:16.408]                     muffled <- FALSE
[16:06:16.408]                     if (inherits(cond, "message")) {
[16:06:16.408]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.408]                       if (muffled) 
[16:06:16.408]                         invokeRestart("muffleMessage")
[16:06:16.408]                     }
[16:06:16.408]                     else if (inherits(cond, "warning")) {
[16:06:16.408]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.408]                       if (muffled) 
[16:06:16.408]                         invokeRestart("muffleWarning")
[16:06:16.408]                     }
[16:06:16.408]                     else if (inherits(cond, "condition")) {
[16:06:16.408]                       if (!is.null(pattern)) {
[16:06:16.408]                         computeRestarts <- base::computeRestarts
[16:06:16.408]                         grepl <- base::grepl
[16:06:16.408]                         restarts <- computeRestarts(cond)
[16:06:16.408]                         for (restart in restarts) {
[16:06:16.408]                           name <- restart$name
[16:06:16.408]                           if (is.null(name)) 
[16:06:16.408]                             next
[16:06:16.408]                           if (!grepl(pattern, name)) 
[16:06:16.408]                             next
[16:06:16.408]                           invokeRestart(restart)
[16:06:16.408]                           muffled <- TRUE
[16:06:16.408]                           break
[16:06:16.408]                         }
[16:06:16.408]                       }
[16:06:16.408]                     }
[16:06:16.408]                     invisible(muffled)
[16:06:16.408]                   }
[16:06:16.408]                   muffleCondition(cond)
[16:06:16.408]                 })
[16:06:16.408]             }))
[16:06:16.408]             future::FutureResult(value = ...future.value$value, 
[16:06:16.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.408]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.408]                     ...future.globalenv.names))
[16:06:16.408]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.408]         }, condition = base::local({
[16:06:16.408]             c <- base::c
[16:06:16.408]             inherits <- base::inherits
[16:06:16.408]             invokeRestart <- base::invokeRestart
[16:06:16.408]             length <- base::length
[16:06:16.408]             list <- base::list
[16:06:16.408]             seq.int <- base::seq.int
[16:06:16.408]             signalCondition <- base::signalCondition
[16:06:16.408]             sys.calls <- base::sys.calls
[16:06:16.408]             `[[` <- base::`[[`
[16:06:16.408]             `+` <- base::`+`
[16:06:16.408]             `<<-` <- base::`<<-`
[16:06:16.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.408]                   3L)]
[16:06:16.408]             }
[16:06:16.408]             function(cond) {
[16:06:16.408]                 is_error <- inherits(cond, "error")
[16:06:16.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.408]                   NULL)
[16:06:16.408]                 if (is_error) {
[16:06:16.408]                   sessionInformation <- function() {
[16:06:16.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.408]                       search = base::search(), system = base::Sys.info())
[16:06:16.408]                   }
[16:06:16.408]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.408]                     cond$call), session = sessionInformation(), 
[16:06:16.408]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.408]                   signalCondition(cond)
[16:06:16.408]                 }
[16:06:16.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.408]                 "immediateCondition"))) {
[16:06:16.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.408]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.408]                   if (TRUE && !signal) {
[16:06:16.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.408]                     {
[16:06:16.408]                       inherits <- base::inherits
[16:06:16.408]                       invokeRestart <- base::invokeRestart
[16:06:16.408]                       is.null <- base::is.null
[16:06:16.408]                       muffled <- FALSE
[16:06:16.408]                       if (inherits(cond, "message")) {
[16:06:16.408]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.408]                         if (muffled) 
[16:06:16.408]                           invokeRestart("muffleMessage")
[16:06:16.408]                       }
[16:06:16.408]                       else if (inherits(cond, "warning")) {
[16:06:16.408]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.408]                         if (muffled) 
[16:06:16.408]                           invokeRestart("muffleWarning")
[16:06:16.408]                       }
[16:06:16.408]                       else if (inherits(cond, "condition")) {
[16:06:16.408]                         if (!is.null(pattern)) {
[16:06:16.408]                           computeRestarts <- base::computeRestarts
[16:06:16.408]                           grepl <- base::grepl
[16:06:16.408]                           restarts <- computeRestarts(cond)
[16:06:16.408]                           for (restart in restarts) {
[16:06:16.408]                             name <- restart$name
[16:06:16.408]                             if (is.null(name)) 
[16:06:16.408]                               next
[16:06:16.408]                             if (!grepl(pattern, name)) 
[16:06:16.408]                               next
[16:06:16.408]                             invokeRestart(restart)
[16:06:16.408]                             muffled <- TRUE
[16:06:16.408]                             break
[16:06:16.408]                           }
[16:06:16.408]                         }
[16:06:16.408]                       }
[16:06:16.408]                       invisible(muffled)
[16:06:16.408]                     }
[16:06:16.408]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.408]                   }
[16:06:16.408]                 }
[16:06:16.408]                 else {
[16:06:16.408]                   if (TRUE) {
[16:06:16.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.408]                     {
[16:06:16.408]                       inherits <- base::inherits
[16:06:16.408]                       invokeRestart <- base::invokeRestart
[16:06:16.408]                       is.null <- base::is.null
[16:06:16.408]                       muffled <- FALSE
[16:06:16.408]                       if (inherits(cond, "message")) {
[16:06:16.408]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.408]                         if (muffled) 
[16:06:16.408]                           invokeRestart("muffleMessage")
[16:06:16.408]                       }
[16:06:16.408]                       else if (inherits(cond, "warning")) {
[16:06:16.408]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.408]                         if (muffled) 
[16:06:16.408]                           invokeRestart("muffleWarning")
[16:06:16.408]                       }
[16:06:16.408]                       else if (inherits(cond, "condition")) {
[16:06:16.408]                         if (!is.null(pattern)) {
[16:06:16.408]                           computeRestarts <- base::computeRestarts
[16:06:16.408]                           grepl <- base::grepl
[16:06:16.408]                           restarts <- computeRestarts(cond)
[16:06:16.408]                           for (restart in restarts) {
[16:06:16.408]                             name <- restart$name
[16:06:16.408]                             if (is.null(name)) 
[16:06:16.408]                               next
[16:06:16.408]                             if (!grepl(pattern, name)) 
[16:06:16.408]                               next
[16:06:16.408]                             invokeRestart(restart)
[16:06:16.408]                             muffled <- TRUE
[16:06:16.408]                             break
[16:06:16.408]                           }
[16:06:16.408]                         }
[16:06:16.408]                       }
[16:06:16.408]                       invisible(muffled)
[16:06:16.408]                     }
[16:06:16.408]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.408]                   }
[16:06:16.408]                 }
[16:06:16.408]             }
[16:06:16.408]         }))
[16:06:16.408]     }, error = function(ex) {
[16:06:16.408]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.408]                 ...future.rng), started = ...future.startTime, 
[16:06:16.408]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.408]             version = "1.8"), class = "FutureResult")
[16:06:16.408]     }, finally = {
[16:06:16.408]         if (!identical(...future.workdir, getwd())) 
[16:06:16.408]             setwd(...future.workdir)
[16:06:16.408]         {
[16:06:16.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.408]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.408]             }
[16:06:16.408]             base::options(...future.oldOptions)
[16:06:16.408]             if (.Platform$OS.type == "windows") {
[16:06:16.408]                 old_names <- names(...future.oldEnvVars)
[16:06:16.408]                 envs <- base::Sys.getenv()
[16:06:16.408]                 names <- names(envs)
[16:06:16.408]                 common <- intersect(names, old_names)
[16:06:16.408]                 added <- setdiff(names, old_names)
[16:06:16.408]                 removed <- setdiff(old_names, names)
[16:06:16.408]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.408]                   envs[common]]
[16:06:16.408]                 NAMES <- toupper(changed)
[16:06:16.408]                 args <- list()
[16:06:16.408]                 for (kk in seq_along(NAMES)) {
[16:06:16.408]                   name <- changed[[kk]]
[16:06:16.408]                   NAME <- NAMES[[kk]]
[16:06:16.408]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.408]                     next
[16:06:16.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.408]                 }
[16:06:16.408]                 NAMES <- toupper(added)
[16:06:16.408]                 for (kk in seq_along(NAMES)) {
[16:06:16.408]                   name <- added[[kk]]
[16:06:16.408]                   NAME <- NAMES[[kk]]
[16:06:16.408]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.408]                     next
[16:06:16.408]                   args[[name]] <- ""
[16:06:16.408]                 }
[16:06:16.408]                 NAMES <- toupper(removed)
[16:06:16.408]                 for (kk in seq_along(NAMES)) {
[16:06:16.408]                   name <- removed[[kk]]
[16:06:16.408]                   NAME <- NAMES[[kk]]
[16:06:16.408]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.408]                     next
[16:06:16.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.408]                 }
[16:06:16.408]                 if (length(args) > 0) 
[16:06:16.408]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.408]             }
[16:06:16.408]             else {
[16:06:16.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.408]             }
[16:06:16.408]             {
[16:06:16.408]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.408]                   0L) {
[16:06:16.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.408]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.408]                   base::options(opts)
[16:06:16.408]                 }
[16:06:16.408]                 {
[16:06:16.408]                   {
[16:06:16.408]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.408]                     NULL
[16:06:16.408]                   }
[16:06:16.408]                   options(future.plan = NULL)
[16:06:16.408]                   if (is.na(NA_character_)) 
[16:06:16.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.408]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.408]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.408]                     envir = parent.frame()) 
[16:06:16.408]                   {
[16:06:16.408]                     if (is.function(workers)) 
[16:06:16.408]                       workers <- workers()
[16:06:16.408]                     workers <- structure(as.integer(workers), 
[16:06:16.408]                       class = class(workers))
[16:06:16.408]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.408]                       workers >= 1)
[16:06:16.408]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.408]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.408]                     }
[16:06:16.408]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.408]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.408]                       envir = envir)
[16:06:16.408]                     if (!future$lazy) 
[16:06:16.408]                       future <- run(future)
[16:06:16.408]                     invisible(future)
[16:06:16.408]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.408]                 }
[16:06:16.408]             }
[16:06:16.408]         }
[16:06:16.408]     })
[16:06:16.408]     if (TRUE) {
[16:06:16.408]         base::sink(type = "output", split = FALSE)
[16:06:16.408]         if (TRUE) {
[16:06:16.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.408]         }
[16:06:16.408]         else {
[16:06:16.408]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.408]         }
[16:06:16.408]         base::close(...future.stdout)
[16:06:16.408]         ...future.stdout <- NULL
[16:06:16.408]     }
[16:06:16.408]     ...future.result$conditions <- ...future.conditions
[16:06:16.408]     ...future.result$finished <- base::Sys.time()
[16:06:16.408]     ...future.result
[16:06:16.408] }
[16:06:16.411] MultisessionFuture started
[16:06:16.411] - Launch lazy future ... done
[16:06:16.411] run() for ‘MultisessionFuture’ ... done
[16:06:16.412] getGlobalsAndPackages() ...
[16:06:16.412] Searching for globals...
[16:06:16.412] - globals found: [1] ‘{’
[16:06:16.413] Searching for globals ... DONE
[16:06:16.413] Resolving globals: FALSE
[16:06:16.413] 
[16:06:16.413] 
[16:06:16.413] getGlobalsAndPackages() ... DONE
[16:06:16.413] run() for ‘Future’ ...
[16:06:16.413] - state: ‘created’
[16:06:16.414] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.427] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.427]   - Field: ‘node’
[16:06:16.427]   - Field: ‘label’
[16:06:16.427]   - Field: ‘local’
[16:06:16.427]   - Field: ‘owner’
[16:06:16.427]   - Field: ‘envir’
[16:06:16.428]   - Field: ‘workers’
[16:06:16.428]   - Field: ‘packages’
[16:06:16.428]   - Field: ‘gc’
[16:06:16.428]   - Field: ‘conditions’
[16:06:16.428]   - Field: ‘persistent’
[16:06:16.428]   - Field: ‘expr’
[16:06:16.428]   - Field: ‘uuid’
[16:06:16.428]   - Field: ‘seed’
[16:06:16.428]   - Field: ‘version’
[16:06:16.428]   - Field: ‘result’
[16:06:16.428]   - Field: ‘asynchronous’
[16:06:16.429]   - Field: ‘calls’
[16:06:16.429]   - Field: ‘globals’
[16:06:16.429]   - Field: ‘stdout’
[16:06:16.429]   - Field: ‘earlySignal’
[16:06:16.429]   - Field: ‘lazy’
[16:06:16.429]   - Field: ‘state’
[16:06:16.429] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.429] - Launch lazy future ...
[16:06:16.429] Packages needed by the future expression (n = 0): <none>
[16:06:16.430] Packages needed by future strategies (n = 0): <none>
[16:06:16.430] {
[16:06:16.430]     {
[16:06:16.430]         {
[16:06:16.430]             ...future.startTime <- base::Sys.time()
[16:06:16.430]             {
[16:06:16.430]                 {
[16:06:16.430]                   {
[16:06:16.430]                     {
[16:06:16.430]                       base::local({
[16:06:16.430]                         has_future <- base::requireNamespace("future", 
[16:06:16.430]                           quietly = TRUE)
[16:06:16.430]                         if (has_future) {
[16:06:16.430]                           ns <- base::getNamespace("future")
[16:06:16.430]                           version <- ns[[".package"]][["version"]]
[16:06:16.430]                           if (is.null(version)) 
[16:06:16.430]                             version <- utils::packageVersion("future")
[16:06:16.430]                         }
[16:06:16.430]                         else {
[16:06:16.430]                           version <- NULL
[16:06:16.430]                         }
[16:06:16.430]                         if (!has_future || version < "1.8.0") {
[16:06:16.430]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.430]                             "", base::R.version$version.string), 
[16:06:16.430]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.430]                               "release", "version")], collapse = " "), 
[16:06:16.430]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.430]                             info)
[16:06:16.430]                           info <- base::paste(info, collapse = "; ")
[16:06:16.430]                           if (!has_future) {
[16:06:16.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.430]                               info)
[16:06:16.430]                           }
[16:06:16.430]                           else {
[16:06:16.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.430]                               info, version)
[16:06:16.430]                           }
[16:06:16.430]                           base::stop(msg)
[16:06:16.430]                         }
[16:06:16.430]                       })
[16:06:16.430]                     }
[16:06:16.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.430]                     base::options(mc.cores = 1L)
[16:06:16.430]                   }
[16:06:16.430]                   options(future.plan = NULL)
[16:06:16.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.430]                 }
[16:06:16.430]                 ...future.workdir <- getwd()
[16:06:16.430]             }
[16:06:16.430]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.430]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.430]         }
[16:06:16.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.430]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.430]             base::names(...future.oldOptions))
[16:06:16.430]     }
[16:06:16.430]     if (FALSE) {
[16:06:16.430]     }
[16:06:16.430]     else {
[16:06:16.430]         if (TRUE) {
[16:06:16.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.430]                 open = "w")
[16:06:16.430]         }
[16:06:16.430]         else {
[16:06:16.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.430]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.430]         }
[16:06:16.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.430]             base::sink(type = "output", split = FALSE)
[16:06:16.430]             base::close(...future.stdout)
[16:06:16.430]         }, add = TRUE)
[16:06:16.430]     }
[16:06:16.430]     ...future.frame <- base::sys.nframe()
[16:06:16.430]     ...future.conditions <- base::list()
[16:06:16.430]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.430]     if (FALSE) {
[16:06:16.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.430]     }
[16:06:16.430]     ...future.result <- base::tryCatch({
[16:06:16.430]         base::withCallingHandlers({
[16:06:16.430]             ...future.value <- base::withVisible(base::local({
[16:06:16.430]                 ...future.makeSendCondition <- base::local({
[16:06:16.430]                   sendCondition <- NULL
[16:06:16.430]                   function(frame = 1L) {
[16:06:16.430]                     if (is.function(sendCondition)) 
[16:06:16.430]                       return(sendCondition)
[16:06:16.430]                     ns <- getNamespace("parallel")
[16:06:16.430]                     if (exists("sendData", mode = "function", 
[16:06:16.430]                       envir = ns)) {
[16:06:16.430]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.430]                         envir = ns)
[16:06:16.430]                       envir <- sys.frame(frame)
[16:06:16.430]                       master <- NULL
[16:06:16.430]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.430]                         !identical(envir, emptyenv())) {
[16:06:16.430]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.430]                           inherits = FALSE)) {
[16:06:16.430]                           master <- get("master", mode = "list", 
[16:06:16.430]                             envir = envir, inherits = FALSE)
[16:06:16.430]                           if (inherits(master, c("SOCKnode", 
[16:06:16.430]                             "SOCK0node"))) {
[16:06:16.430]                             sendCondition <<- function(cond) {
[16:06:16.430]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.430]                                 success = TRUE)
[16:06:16.430]                               parallel_sendData(master, data)
[16:06:16.430]                             }
[16:06:16.430]                             return(sendCondition)
[16:06:16.430]                           }
[16:06:16.430]                         }
[16:06:16.430]                         frame <- frame + 1L
[16:06:16.430]                         envir <- sys.frame(frame)
[16:06:16.430]                       }
[16:06:16.430]                     }
[16:06:16.430]                     sendCondition <<- function(cond) NULL
[16:06:16.430]                   }
[16:06:16.430]                 })
[16:06:16.430]                 withCallingHandlers({
[16:06:16.430]                   {
[16:06:16.430]                     2
[16:06:16.430]                   }
[16:06:16.430]                 }, immediateCondition = function(cond) {
[16:06:16.430]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.430]                   sendCondition(cond)
[16:06:16.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.430]                   {
[16:06:16.430]                     inherits <- base::inherits
[16:06:16.430]                     invokeRestart <- base::invokeRestart
[16:06:16.430]                     is.null <- base::is.null
[16:06:16.430]                     muffled <- FALSE
[16:06:16.430]                     if (inherits(cond, "message")) {
[16:06:16.430]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.430]                       if (muffled) 
[16:06:16.430]                         invokeRestart("muffleMessage")
[16:06:16.430]                     }
[16:06:16.430]                     else if (inherits(cond, "warning")) {
[16:06:16.430]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.430]                       if (muffled) 
[16:06:16.430]                         invokeRestart("muffleWarning")
[16:06:16.430]                     }
[16:06:16.430]                     else if (inherits(cond, "condition")) {
[16:06:16.430]                       if (!is.null(pattern)) {
[16:06:16.430]                         computeRestarts <- base::computeRestarts
[16:06:16.430]                         grepl <- base::grepl
[16:06:16.430]                         restarts <- computeRestarts(cond)
[16:06:16.430]                         for (restart in restarts) {
[16:06:16.430]                           name <- restart$name
[16:06:16.430]                           if (is.null(name)) 
[16:06:16.430]                             next
[16:06:16.430]                           if (!grepl(pattern, name)) 
[16:06:16.430]                             next
[16:06:16.430]                           invokeRestart(restart)
[16:06:16.430]                           muffled <- TRUE
[16:06:16.430]                           break
[16:06:16.430]                         }
[16:06:16.430]                       }
[16:06:16.430]                     }
[16:06:16.430]                     invisible(muffled)
[16:06:16.430]                   }
[16:06:16.430]                   muffleCondition(cond)
[16:06:16.430]                 })
[16:06:16.430]             }))
[16:06:16.430]             future::FutureResult(value = ...future.value$value, 
[16:06:16.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.430]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.430]                     ...future.globalenv.names))
[16:06:16.430]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.430]         }, condition = base::local({
[16:06:16.430]             c <- base::c
[16:06:16.430]             inherits <- base::inherits
[16:06:16.430]             invokeRestart <- base::invokeRestart
[16:06:16.430]             length <- base::length
[16:06:16.430]             list <- base::list
[16:06:16.430]             seq.int <- base::seq.int
[16:06:16.430]             signalCondition <- base::signalCondition
[16:06:16.430]             sys.calls <- base::sys.calls
[16:06:16.430]             `[[` <- base::`[[`
[16:06:16.430]             `+` <- base::`+`
[16:06:16.430]             `<<-` <- base::`<<-`
[16:06:16.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.430]                   3L)]
[16:06:16.430]             }
[16:06:16.430]             function(cond) {
[16:06:16.430]                 is_error <- inherits(cond, "error")
[16:06:16.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.430]                   NULL)
[16:06:16.430]                 if (is_error) {
[16:06:16.430]                   sessionInformation <- function() {
[16:06:16.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.430]                       search = base::search(), system = base::Sys.info())
[16:06:16.430]                   }
[16:06:16.430]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.430]                     cond$call), session = sessionInformation(), 
[16:06:16.430]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.430]                   signalCondition(cond)
[16:06:16.430]                 }
[16:06:16.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.430]                 "immediateCondition"))) {
[16:06:16.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.430]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.430]                   if (TRUE && !signal) {
[16:06:16.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.430]                     {
[16:06:16.430]                       inherits <- base::inherits
[16:06:16.430]                       invokeRestart <- base::invokeRestart
[16:06:16.430]                       is.null <- base::is.null
[16:06:16.430]                       muffled <- FALSE
[16:06:16.430]                       if (inherits(cond, "message")) {
[16:06:16.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.430]                         if (muffled) 
[16:06:16.430]                           invokeRestart("muffleMessage")
[16:06:16.430]                       }
[16:06:16.430]                       else if (inherits(cond, "warning")) {
[16:06:16.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.430]                         if (muffled) 
[16:06:16.430]                           invokeRestart("muffleWarning")
[16:06:16.430]                       }
[16:06:16.430]                       else if (inherits(cond, "condition")) {
[16:06:16.430]                         if (!is.null(pattern)) {
[16:06:16.430]                           computeRestarts <- base::computeRestarts
[16:06:16.430]                           grepl <- base::grepl
[16:06:16.430]                           restarts <- computeRestarts(cond)
[16:06:16.430]                           for (restart in restarts) {
[16:06:16.430]                             name <- restart$name
[16:06:16.430]                             if (is.null(name)) 
[16:06:16.430]                               next
[16:06:16.430]                             if (!grepl(pattern, name)) 
[16:06:16.430]                               next
[16:06:16.430]                             invokeRestart(restart)
[16:06:16.430]                             muffled <- TRUE
[16:06:16.430]                             break
[16:06:16.430]                           }
[16:06:16.430]                         }
[16:06:16.430]                       }
[16:06:16.430]                       invisible(muffled)
[16:06:16.430]                     }
[16:06:16.430]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.430]                   }
[16:06:16.430]                 }
[16:06:16.430]                 else {
[16:06:16.430]                   if (TRUE) {
[16:06:16.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.430]                     {
[16:06:16.430]                       inherits <- base::inherits
[16:06:16.430]                       invokeRestart <- base::invokeRestart
[16:06:16.430]                       is.null <- base::is.null
[16:06:16.430]                       muffled <- FALSE
[16:06:16.430]                       if (inherits(cond, "message")) {
[16:06:16.430]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.430]                         if (muffled) 
[16:06:16.430]                           invokeRestart("muffleMessage")
[16:06:16.430]                       }
[16:06:16.430]                       else if (inherits(cond, "warning")) {
[16:06:16.430]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.430]                         if (muffled) 
[16:06:16.430]                           invokeRestart("muffleWarning")
[16:06:16.430]                       }
[16:06:16.430]                       else if (inherits(cond, "condition")) {
[16:06:16.430]                         if (!is.null(pattern)) {
[16:06:16.430]                           computeRestarts <- base::computeRestarts
[16:06:16.430]                           grepl <- base::grepl
[16:06:16.430]                           restarts <- computeRestarts(cond)
[16:06:16.430]                           for (restart in restarts) {
[16:06:16.430]                             name <- restart$name
[16:06:16.430]                             if (is.null(name)) 
[16:06:16.430]                               next
[16:06:16.430]                             if (!grepl(pattern, name)) 
[16:06:16.430]                               next
[16:06:16.430]                             invokeRestart(restart)
[16:06:16.430]                             muffled <- TRUE
[16:06:16.430]                             break
[16:06:16.430]                           }
[16:06:16.430]                         }
[16:06:16.430]                       }
[16:06:16.430]                       invisible(muffled)
[16:06:16.430]                     }
[16:06:16.430]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.430]                   }
[16:06:16.430]                 }
[16:06:16.430]             }
[16:06:16.430]         }))
[16:06:16.430]     }, error = function(ex) {
[16:06:16.430]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.430]                 ...future.rng), started = ...future.startTime, 
[16:06:16.430]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.430]             version = "1.8"), class = "FutureResult")
[16:06:16.430]     }, finally = {
[16:06:16.430]         if (!identical(...future.workdir, getwd())) 
[16:06:16.430]             setwd(...future.workdir)
[16:06:16.430]         {
[16:06:16.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.430]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.430]             }
[16:06:16.430]             base::options(...future.oldOptions)
[16:06:16.430]             if (.Platform$OS.type == "windows") {
[16:06:16.430]                 old_names <- names(...future.oldEnvVars)
[16:06:16.430]                 envs <- base::Sys.getenv()
[16:06:16.430]                 names <- names(envs)
[16:06:16.430]                 common <- intersect(names, old_names)
[16:06:16.430]                 added <- setdiff(names, old_names)
[16:06:16.430]                 removed <- setdiff(old_names, names)
[16:06:16.430]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.430]                   envs[common]]
[16:06:16.430]                 NAMES <- toupper(changed)
[16:06:16.430]                 args <- list()
[16:06:16.430]                 for (kk in seq_along(NAMES)) {
[16:06:16.430]                   name <- changed[[kk]]
[16:06:16.430]                   NAME <- NAMES[[kk]]
[16:06:16.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.430]                     next
[16:06:16.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.430]                 }
[16:06:16.430]                 NAMES <- toupper(added)
[16:06:16.430]                 for (kk in seq_along(NAMES)) {
[16:06:16.430]                   name <- added[[kk]]
[16:06:16.430]                   NAME <- NAMES[[kk]]
[16:06:16.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.430]                     next
[16:06:16.430]                   args[[name]] <- ""
[16:06:16.430]                 }
[16:06:16.430]                 NAMES <- toupper(removed)
[16:06:16.430]                 for (kk in seq_along(NAMES)) {
[16:06:16.430]                   name <- removed[[kk]]
[16:06:16.430]                   NAME <- NAMES[[kk]]
[16:06:16.430]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.430]                     next
[16:06:16.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.430]                 }
[16:06:16.430]                 if (length(args) > 0) 
[16:06:16.430]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.430]             }
[16:06:16.430]             else {
[16:06:16.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.430]             }
[16:06:16.430]             {
[16:06:16.430]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.430]                   0L) {
[16:06:16.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.430]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.430]                   base::options(opts)
[16:06:16.430]                 }
[16:06:16.430]                 {
[16:06:16.430]                   {
[16:06:16.430]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.430]                     NULL
[16:06:16.430]                   }
[16:06:16.430]                   options(future.plan = NULL)
[16:06:16.430]                   if (is.na(NA_character_)) 
[16:06:16.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.430]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.430]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.430]                     envir = parent.frame()) 
[16:06:16.430]                   {
[16:06:16.430]                     if (is.function(workers)) 
[16:06:16.430]                       workers <- workers()
[16:06:16.430]                     workers <- structure(as.integer(workers), 
[16:06:16.430]                       class = class(workers))
[16:06:16.430]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.430]                       workers >= 1)
[16:06:16.430]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.430]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.430]                     }
[16:06:16.430]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.430]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.430]                       envir = envir)
[16:06:16.430]                     if (!future$lazy) 
[16:06:16.430]                       future <- run(future)
[16:06:16.430]                     invisible(future)
[16:06:16.430]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.430]                 }
[16:06:16.430]             }
[16:06:16.430]         }
[16:06:16.430]     })
[16:06:16.430]     if (TRUE) {
[16:06:16.430]         base::sink(type = "output", split = FALSE)
[16:06:16.430]         if (TRUE) {
[16:06:16.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.430]         }
[16:06:16.430]         else {
[16:06:16.430]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.430]         }
[16:06:16.430]         base::close(...future.stdout)
[16:06:16.430]         ...future.stdout <- NULL
[16:06:16.430]     }
[16:06:16.430]     ...future.result$conditions <- ...future.conditions
[16:06:16.430]     ...future.result$finished <- base::Sys.time()
[16:06:16.430]     ...future.result
[16:06:16.430] }
[16:06:16.433] MultisessionFuture started
[16:06:16.433] - Launch lazy future ... done
[16:06:16.433] run() for ‘MultisessionFuture’ ... done
[16:06:16.434] resolve() on list environment ...
[16:06:16.434]  recursive: 0
[16:06:16.434]  length: 3
[16:06:16.434]  elements: ‘a’, ‘b’, ‘c’
[16:06:16.455]  length: 2 (resolved future 3)
[16:06:16.466] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.466] - Validating connection of MultisessionFuture
[16:06:16.466] - received message: FutureResult
[16:06:16.467] - Received FutureResult
[16:06:16.467] - Erased future from FutureRegistry
[16:06:16.467] result() for ClusterFuture ...
[16:06:16.467] - result already collected: FutureResult
[16:06:16.467] result() for ClusterFuture ... done
[16:06:16.467] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.467] Future #1
[16:06:16.467]  length: 1 (resolved future 1)
[16:06:16.488] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.488] - Validating connection of MultisessionFuture
[16:06:16.489] - received message: FutureResult
[16:06:16.489] - Received FutureResult
[16:06:16.489] - Erased future from FutureRegistry
[16:06:16.489] result() for ClusterFuture ...
[16:06:16.489] - result already collected: FutureResult
[16:06:16.489] result() for ClusterFuture ... done
[16:06:16.489] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.489] Future #2
[16:06:16.489]  length: 0 (resolved future 2)
[16:06:16.489] resolve() on list environment ... DONE
[16:06:16.490] getGlobalsAndPackages() ...
[16:06:16.490] Searching for globals...
[16:06:16.491] - globals found: [1] ‘{’
[16:06:16.491] Searching for globals ... DONE
[16:06:16.491] Resolving globals: FALSE
[16:06:16.491] 
[16:06:16.491] 
[16:06:16.491] getGlobalsAndPackages() ... DONE
[16:06:16.491] run() for ‘Future’ ...
[16:06:16.492] - state: ‘created’
[16:06:16.492] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.505]   - Field: ‘node’
[16:06:16.505]   - Field: ‘label’
[16:06:16.505]   - Field: ‘local’
[16:06:16.506]   - Field: ‘owner’
[16:06:16.506]   - Field: ‘envir’
[16:06:16.506]   - Field: ‘workers’
[16:06:16.506]   - Field: ‘packages’
[16:06:16.506]   - Field: ‘gc’
[16:06:16.506]   - Field: ‘conditions’
[16:06:16.506]   - Field: ‘persistent’
[16:06:16.506]   - Field: ‘expr’
[16:06:16.506]   - Field: ‘uuid’
[16:06:16.509]   - Field: ‘seed’
[16:06:16.509]   - Field: ‘version’
[16:06:16.509]   - Field: ‘result’
[16:06:16.509]   - Field: ‘asynchronous’
[16:06:16.510]   - Field: ‘calls’
[16:06:16.510]   - Field: ‘globals’
[16:06:16.510]   - Field: ‘stdout’
[16:06:16.510]   - Field: ‘earlySignal’
[16:06:16.510]   - Field: ‘lazy’
[16:06:16.510]   - Field: ‘state’
[16:06:16.510] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.510] - Launch lazy future ...
[16:06:16.511] Packages needed by the future expression (n = 0): <none>
[16:06:16.511] Packages needed by future strategies (n = 0): <none>
[16:06:16.511] {
[16:06:16.511]     {
[16:06:16.511]         {
[16:06:16.511]             ...future.startTime <- base::Sys.time()
[16:06:16.511]             {
[16:06:16.511]                 {
[16:06:16.511]                   {
[16:06:16.511]                     {
[16:06:16.511]                       base::local({
[16:06:16.511]                         has_future <- base::requireNamespace("future", 
[16:06:16.511]                           quietly = TRUE)
[16:06:16.511]                         if (has_future) {
[16:06:16.511]                           ns <- base::getNamespace("future")
[16:06:16.511]                           version <- ns[[".package"]][["version"]]
[16:06:16.511]                           if (is.null(version)) 
[16:06:16.511]                             version <- utils::packageVersion("future")
[16:06:16.511]                         }
[16:06:16.511]                         else {
[16:06:16.511]                           version <- NULL
[16:06:16.511]                         }
[16:06:16.511]                         if (!has_future || version < "1.8.0") {
[16:06:16.511]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.511]                             "", base::R.version$version.string), 
[16:06:16.511]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.511]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.511]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.511]                               "release", "version")], collapse = " "), 
[16:06:16.511]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.511]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.511]                             info)
[16:06:16.511]                           info <- base::paste(info, collapse = "; ")
[16:06:16.511]                           if (!has_future) {
[16:06:16.511]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.511]                               info)
[16:06:16.511]                           }
[16:06:16.511]                           else {
[16:06:16.511]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.511]                               info, version)
[16:06:16.511]                           }
[16:06:16.511]                           base::stop(msg)
[16:06:16.511]                         }
[16:06:16.511]                       })
[16:06:16.511]                     }
[16:06:16.511]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.511]                     base::options(mc.cores = 1L)
[16:06:16.511]                   }
[16:06:16.511]                   options(future.plan = NULL)
[16:06:16.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.511]                 }
[16:06:16.511]                 ...future.workdir <- getwd()
[16:06:16.511]             }
[16:06:16.511]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.511]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.511]         }
[16:06:16.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.511]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.511]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.511]             base::names(...future.oldOptions))
[16:06:16.511]     }
[16:06:16.511]     if (FALSE) {
[16:06:16.511]     }
[16:06:16.511]     else {
[16:06:16.511]         if (TRUE) {
[16:06:16.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.511]                 open = "w")
[16:06:16.511]         }
[16:06:16.511]         else {
[16:06:16.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.511]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.511]         }
[16:06:16.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.511]             base::sink(type = "output", split = FALSE)
[16:06:16.511]             base::close(...future.stdout)
[16:06:16.511]         }, add = TRUE)
[16:06:16.511]     }
[16:06:16.511]     ...future.frame <- base::sys.nframe()
[16:06:16.511]     ...future.conditions <- base::list()
[16:06:16.511]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.511]     if (FALSE) {
[16:06:16.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.511]     }
[16:06:16.511]     ...future.result <- base::tryCatch({
[16:06:16.511]         base::withCallingHandlers({
[16:06:16.511]             ...future.value <- base::withVisible(base::local({
[16:06:16.511]                 ...future.makeSendCondition <- base::local({
[16:06:16.511]                   sendCondition <- NULL
[16:06:16.511]                   function(frame = 1L) {
[16:06:16.511]                     if (is.function(sendCondition)) 
[16:06:16.511]                       return(sendCondition)
[16:06:16.511]                     ns <- getNamespace("parallel")
[16:06:16.511]                     if (exists("sendData", mode = "function", 
[16:06:16.511]                       envir = ns)) {
[16:06:16.511]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.511]                         envir = ns)
[16:06:16.511]                       envir <- sys.frame(frame)
[16:06:16.511]                       master <- NULL
[16:06:16.511]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.511]                         !identical(envir, emptyenv())) {
[16:06:16.511]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.511]                           inherits = FALSE)) {
[16:06:16.511]                           master <- get("master", mode = "list", 
[16:06:16.511]                             envir = envir, inherits = FALSE)
[16:06:16.511]                           if (inherits(master, c("SOCKnode", 
[16:06:16.511]                             "SOCK0node"))) {
[16:06:16.511]                             sendCondition <<- function(cond) {
[16:06:16.511]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.511]                                 success = TRUE)
[16:06:16.511]                               parallel_sendData(master, data)
[16:06:16.511]                             }
[16:06:16.511]                             return(sendCondition)
[16:06:16.511]                           }
[16:06:16.511]                         }
[16:06:16.511]                         frame <- frame + 1L
[16:06:16.511]                         envir <- sys.frame(frame)
[16:06:16.511]                       }
[16:06:16.511]                     }
[16:06:16.511]                     sendCondition <<- function(cond) NULL
[16:06:16.511]                   }
[16:06:16.511]                 })
[16:06:16.511]                 withCallingHandlers({
[16:06:16.511]                   {
[16:06:16.511]                     1
[16:06:16.511]                   }
[16:06:16.511]                 }, immediateCondition = function(cond) {
[16:06:16.511]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.511]                   sendCondition(cond)
[16:06:16.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.511]                   {
[16:06:16.511]                     inherits <- base::inherits
[16:06:16.511]                     invokeRestart <- base::invokeRestart
[16:06:16.511]                     is.null <- base::is.null
[16:06:16.511]                     muffled <- FALSE
[16:06:16.511]                     if (inherits(cond, "message")) {
[16:06:16.511]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.511]                       if (muffled) 
[16:06:16.511]                         invokeRestart("muffleMessage")
[16:06:16.511]                     }
[16:06:16.511]                     else if (inherits(cond, "warning")) {
[16:06:16.511]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.511]                       if (muffled) 
[16:06:16.511]                         invokeRestart("muffleWarning")
[16:06:16.511]                     }
[16:06:16.511]                     else if (inherits(cond, "condition")) {
[16:06:16.511]                       if (!is.null(pattern)) {
[16:06:16.511]                         computeRestarts <- base::computeRestarts
[16:06:16.511]                         grepl <- base::grepl
[16:06:16.511]                         restarts <- computeRestarts(cond)
[16:06:16.511]                         for (restart in restarts) {
[16:06:16.511]                           name <- restart$name
[16:06:16.511]                           if (is.null(name)) 
[16:06:16.511]                             next
[16:06:16.511]                           if (!grepl(pattern, name)) 
[16:06:16.511]                             next
[16:06:16.511]                           invokeRestart(restart)
[16:06:16.511]                           muffled <- TRUE
[16:06:16.511]                           break
[16:06:16.511]                         }
[16:06:16.511]                       }
[16:06:16.511]                     }
[16:06:16.511]                     invisible(muffled)
[16:06:16.511]                   }
[16:06:16.511]                   muffleCondition(cond)
[16:06:16.511]                 })
[16:06:16.511]             }))
[16:06:16.511]             future::FutureResult(value = ...future.value$value, 
[16:06:16.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.511]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.511]                     ...future.globalenv.names))
[16:06:16.511]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.511]         }, condition = base::local({
[16:06:16.511]             c <- base::c
[16:06:16.511]             inherits <- base::inherits
[16:06:16.511]             invokeRestart <- base::invokeRestart
[16:06:16.511]             length <- base::length
[16:06:16.511]             list <- base::list
[16:06:16.511]             seq.int <- base::seq.int
[16:06:16.511]             signalCondition <- base::signalCondition
[16:06:16.511]             sys.calls <- base::sys.calls
[16:06:16.511]             `[[` <- base::`[[`
[16:06:16.511]             `+` <- base::`+`
[16:06:16.511]             `<<-` <- base::`<<-`
[16:06:16.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.511]                   3L)]
[16:06:16.511]             }
[16:06:16.511]             function(cond) {
[16:06:16.511]                 is_error <- inherits(cond, "error")
[16:06:16.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.511]                   NULL)
[16:06:16.511]                 if (is_error) {
[16:06:16.511]                   sessionInformation <- function() {
[16:06:16.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.511]                       search = base::search(), system = base::Sys.info())
[16:06:16.511]                   }
[16:06:16.511]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.511]                     cond$call), session = sessionInformation(), 
[16:06:16.511]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.511]                   signalCondition(cond)
[16:06:16.511]                 }
[16:06:16.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.511]                 "immediateCondition"))) {
[16:06:16.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.511]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.511]                   if (TRUE && !signal) {
[16:06:16.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.511]                     {
[16:06:16.511]                       inherits <- base::inherits
[16:06:16.511]                       invokeRestart <- base::invokeRestart
[16:06:16.511]                       is.null <- base::is.null
[16:06:16.511]                       muffled <- FALSE
[16:06:16.511]                       if (inherits(cond, "message")) {
[16:06:16.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.511]                         if (muffled) 
[16:06:16.511]                           invokeRestart("muffleMessage")
[16:06:16.511]                       }
[16:06:16.511]                       else if (inherits(cond, "warning")) {
[16:06:16.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.511]                         if (muffled) 
[16:06:16.511]                           invokeRestart("muffleWarning")
[16:06:16.511]                       }
[16:06:16.511]                       else if (inherits(cond, "condition")) {
[16:06:16.511]                         if (!is.null(pattern)) {
[16:06:16.511]                           computeRestarts <- base::computeRestarts
[16:06:16.511]                           grepl <- base::grepl
[16:06:16.511]                           restarts <- computeRestarts(cond)
[16:06:16.511]                           for (restart in restarts) {
[16:06:16.511]                             name <- restart$name
[16:06:16.511]                             if (is.null(name)) 
[16:06:16.511]                               next
[16:06:16.511]                             if (!grepl(pattern, name)) 
[16:06:16.511]                               next
[16:06:16.511]                             invokeRestart(restart)
[16:06:16.511]                             muffled <- TRUE
[16:06:16.511]                             break
[16:06:16.511]                           }
[16:06:16.511]                         }
[16:06:16.511]                       }
[16:06:16.511]                       invisible(muffled)
[16:06:16.511]                     }
[16:06:16.511]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.511]                   }
[16:06:16.511]                 }
[16:06:16.511]                 else {
[16:06:16.511]                   if (TRUE) {
[16:06:16.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.511]                     {
[16:06:16.511]                       inherits <- base::inherits
[16:06:16.511]                       invokeRestart <- base::invokeRestart
[16:06:16.511]                       is.null <- base::is.null
[16:06:16.511]                       muffled <- FALSE
[16:06:16.511]                       if (inherits(cond, "message")) {
[16:06:16.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.511]                         if (muffled) 
[16:06:16.511]                           invokeRestart("muffleMessage")
[16:06:16.511]                       }
[16:06:16.511]                       else if (inherits(cond, "warning")) {
[16:06:16.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.511]                         if (muffled) 
[16:06:16.511]                           invokeRestart("muffleWarning")
[16:06:16.511]                       }
[16:06:16.511]                       else if (inherits(cond, "condition")) {
[16:06:16.511]                         if (!is.null(pattern)) {
[16:06:16.511]                           computeRestarts <- base::computeRestarts
[16:06:16.511]                           grepl <- base::grepl
[16:06:16.511]                           restarts <- computeRestarts(cond)
[16:06:16.511]                           for (restart in restarts) {
[16:06:16.511]                             name <- restart$name
[16:06:16.511]                             if (is.null(name)) 
[16:06:16.511]                               next
[16:06:16.511]                             if (!grepl(pattern, name)) 
[16:06:16.511]                               next
[16:06:16.511]                             invokeRestart(restart)
[16:06:16.511]                             muffled <- TRUE
[16:06:16.511]                             break
[16:06:16.511]                           }
[16:06:16.511]                         }
[16:06:16.511]                       }
[16:06:16.511]                       invisible(muffled)
[16:06:16.511]                     }
[16:06:16.511]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.511]                   }
[16:06:16.511]                 }
[16:06:16.511]             }
[16:06:16.511]         }))
[16:06:16.511]     }, error = function(ex) {
[16:06:16.511]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.511]                 ...future.rng), started = ...future.startTime, 
[16:06:16.511]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.511]             version = "1.8"), class = "FutureResult")
[16:06:16.511]     }, finally = {
[16:06:16.511]         if (!identical(...future.workdir, getwd())) 
[16:06:16.511]             setwd(...future.workdir)
[16:06:16.511]         {
[16:06:16.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.511]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.511]             }
[16:06:16.511]             base::options(...future.oldOptions)
[16:06:16.511]             if (.Platform$OS.type == "windows") {
[16:06:16.511]                 old_names <- names(...future.oldEnvVars)
[16:06:16.511]                 envs <- base::Sys.getenv()
[16:06:16.511]                 names <- names(envs)
[16:06:16.511]                 common <- intersect(names, old_names)
[16:06:16.511]                 added <- setdiff(names, old_names)
[16:06:16.511]                 removed <- setdiff(old_names, names)
[16:06:16.511]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.511]                   envs[common]]
[16:06:16.511]                 NAMES <- toupper(changed)
[16:06:16.511]                 args <- list()
[16:06:16.511]                 for (kk in seq_along(NAMES)) {
[16:06:16.511]                   name <- changed[[kk]]
[16:06:16.511]                   NAME <- NAMES[[kk]]
[16:06:16.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.511]                     next
[16:06:16.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.511]                 }
[16:06:16.511]                 NAMES <- toupper(added)
[16:06:16.511]                 for (kk in seq_along(NAMES)) {
[16:06:16.511]                   name <- added[[kk]]
[16:06:16.511]                   NAME <- NAMES[[kk]]
[16:06:16.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.511]                     next
[16:06:16.511]                   args[[name]] <- ""
[16:06:16.511]                 }
[16:06:16.511]                 NAMES <- toupper(removed)
[16:06:16.511]                 for (kk in seq_along(NAMES)) {
[16:06:16.511]                   name <- removed[[kk]]
[16:06:16.511]                   NAME <- NAMES[[kk]]
[16:06:16.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.511]                     next
[16:06:16.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.511]                 }
[16:06:16.511]                 if (length(args) > 0) 
[16:06:16.511]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.511]             }
[16:06:16.511]             else {
[16:06:16.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.511]             }
[16:06:16.511]             {
[16:06:16.511]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.511]                   0L) {
[16:06:16.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.511]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.511]                   base::options(opts)
[16:06:16.511]                 }
[16:06:16.511]                 {
[16:06:16.511]                   {
[16:06:16.511]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.511]                     NULL
[16:06:16.511]                   }
[16:06:16.511]                   options(future.plan = NULL)
[16:06:16.511]                   if (is.na(NA_character_)) 
[16:06:16.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.511]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.511]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.511]                     envir = parent.frame()) 
[16:06:16.511]                   {
[16:06:16.511]                     if (is.function(workers)) 
[16:06:16.511]                       workers <- workers()
[16:06:16.511]                     workers <- structure(as.integer(workers), 
[16:06:16.511]                       class = class(workers))
[16:06:16.511]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.511]                       workers >= 1)
[16:06:16.511]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.511]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.511]                     }
[16:06:16.511]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.511]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.511]                       envir = envir)
[16:06:16.511]                     if (!future$lazy) 
[16:06:16.511]                       future <- run(future)
[16:06:16.511]                     invisible(future)
[16:06:16.511]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.511]                 }
[16:06:16.511]             }
[16:06:16.511]         }
[16:06:16.511]     })
[16:06:16.511]     if (TRUE) {
[16:06:16.511]         base::sink(type = "output", split = FALSE)
[16:06:16.511]         if (TRUE) {
[16:06:16.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.511]         }
[16:06:16.511]         else {
[16:06:16.511]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.511]         }
[16:06:16.511]         base::close(...future.stdout)
[16:06:16.511]         ...future.stdout <- NULL
[16:06:16.511]     }
[16:06:16.511]     ...future.result$conditions <- ...future.conditions
[16:06:16.511]     ...future.result$finished <- base::Sys.time()
[16:06:16.511]     ...future.result
[16:06:16.511] }
[16:06:16.514] MultisessionFuture started
[16:06:16.515] - Launch lazy future ... done
[16:06:16.515] run() for ‘MultisessionFuture’ ... done
[16:06:16.515] getGlobalsAndPackages() ...
[16:06:16.515] Searching for globals...
[16:06:16.516] - globals found: [2] ‘{’, ‘Sys.sleep’
[16:06:16.516] Searching for globals ... DONE
[16:06:16.516] Resolving globals: FALSE
[16:06:16.517] 
[16:06:16.517] 
[16:06:16.517] getGlobalsAndPackages() ... DONE
[16:06:16.517] run() for ‘Future’ ...
[16:06:16.517] - state: ‘created’
[16:06:16.517] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.531] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.531]   - Field: ‘node’
[16:06:16.532]   - Field: ‘label’
[16:06:16.532]   - Field: ‘local’
[16:06:16.532]   - Field: ‘owner’
[16:06:16.532]   - Field: ‘envir’
[16:06:16.532]   - Field: ‘workers’
[16:06:16.532]   - Field: ‘packages’
[16:06:16.532]   - Field: ‘gc’
[16:06:16.532]   - Field: ‘conditions’
[16:06:16.532]   - Field: ‘persistent’
[16:06:16.532]   - Field: ‘expr’
[16:06:16.532]   - Field: ‘uuid’
[16:06:16.533]   - Field: ‘seed’
[16:06:16.533]   - Field: ‘version’
[16:06:16.533]   - Field: ‘result’
[16:06:16.533]   - Field: ‘asynchronous’
[16:06:16.533]   - Field: ‘calls’
[16:06:16.533]   - Field: ‘globals’
[16:06:16.533]   - Field: ‘stdout’
[16:06:16.533]   - Field: ‘earlySignal’
[16:06:16.533]   - Field: ‘lazy’
[16:06:16.533]   - Field: ‘state’
[16:06:16.533] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.534] - Launch lazy future ...
[16:06:16.534] Packages needed by the future expression (n = 0): <none>
[16:06:16.534] Packages needed by future strategies (n = 0): <none>
[16:06:16.534] {
[16:06:16.534]     {
[16:06:16.534]         {
[16:06:16.534]             ...future.startTime <- base::Sys.time()
[16:06:16.534]             {
[16:06:16.534]                 {
[16:06:16.534]                   {
[16:06:16.534]                     {
[16:06:16.534]                       base::local({
[16:06:16.534]                         has_future <- base::requireNamespace("future", 
[16:06:16.534]                           quietly = TRUE)
[16:06:16.534]                         if (has_future) {
[16:06:16.534]                           ns <- base::getNamespace("future")
[16:06:16.534]                           version <- ns[[".package"]][["version"]]
[16:06:16.534]                           if (is.null(version)) 
[16:06:16.534]                             version <- utils::packageVersion("future")
[16:06:16.534]                         }
[16:06:16.534]                         else {
[16:06:16.534]                           version <- NULL
[16:06:16.534]                         }
[16:06:16.534]                         if (!has_future || version < "1.8.0") {
[16:06:16.534]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.534]                             "", base::R.version$version.string), 
[16:06:16.534]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.534]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.534]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.534]                               "release", "version")], collapse = " "), 
[16:06:16.534]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.534]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.534]                             info)
[16:06:16.534]                           info <- base::paste(info, collapse = "; ")
[16:06:16.534]                           if (!has_future) {
[16:06:16.534]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.534]                               info)
[16:06:16.534]                           }
[16:06:16.534]                           else {
[16:06:16.534]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.534]                               info, version)
[16:06:16.534]                           }
[16:06:16.534]                           base::stop(msg)
[16:06:16.534]                         }
[16:06:16.534]                       })
[16:06:16.534]                     }
[16:06:16.534]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.534]                     base::options(mc.cores = 1L)
[16:06:16.534]                   }
[16:06:16.534]                   options(future.plan = NULL)
[16:06:16.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.534]                 }
[16:06:16.534]                 ...future.workdir <- getwd()
[16:06:16.534]             }
[16:06:16.534]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.534]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.534]         }
[16:06:16.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.534]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.534]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.534]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.534]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.534]             base::names(...future.oldOptions))
[16:06:16.534]     }
[16:06:16.534]     if (FALSE) {
[16:06:16.534]     }
[16:06:16.534]     else {
[16:06:16.534]         if (TRUE) {
[16:06:16.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.534]                 open = "w")
[16:06:16.534]         }
[16:06:16.534]         else {
[16:06:16.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.534]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.534]         }
[16:06:16.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.534]             base::sink(type = "output", split = FALSE)
[16:06:16.534]             base::close(...future.stdout)
[16:06:16.534]         }, add = TRUE)
[16:06:16.534]     }
[16:06:16.534]     ...future.frame <- base::sys.nframe()
[16:06:16.534]     ...future.conditions <- base::list()
[16:06:16.534]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.534]     if (FALSE) {
[16:06:16.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.534]     }
[16:06:16.534]     ...future.result <- base::tryCatch({
[16:06:16.534]         base::withCallingHandlers({
[16:06:16.534]             ...future.value <- base::withVisible(base::local({
[16:06:16.534]                 ...future.makeSendCondition <- base::local({
[16:06:16.534]                   sendCondition <- NULL
[16:06:16.534]                   function(frame = 1L) {
[16:06:16.534]                     if (is.function(sendCondition)) 
[16:06:16.534]                       return(sendCondition)
[16:06:16.534]                     ns <- getNamespace("parallel")
[16:06:16.534]                     if (exists("sendData", mode = "function", 
[16:06:16.534]                       envir = ns)) {
[16:06:16.534]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.534]                         envir = ns)
[16:06:16.534]                       envir <- sys.frame(frame)
[16:06:16.534]                       master <- NULL
[16:06:16.534]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.534]                         !identical(envir, emptyenv())) {
[16:06:16.534]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.534]                           inherits = FALSE)) {
[16:06:16.534]                           master <- get("master", mode = "list", 
[16:06:16.534]                             envir = envir, inherits = FALSE)
[16:06:16.534]                           if (inherits(master, c("SOCKnode", 
[16:06:16.534]                             "SOCK0node"))) {
[16:06:16.534]                             sendCondition <<- function(cond) {
[16:06:16.534]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.534]                                 success = TRUE)
[16:06:16.534]                               parallel_sendData(master, data)
[16:06:16.534]                             }
[16:06:16.534]                             return(sendCondition)
[16:06:16.534]                           }
[16:06:16.534]                         }
[16:06:16.534]                         frame <- frame + 1L
[16:06:16.534]                         envir <- sys.frame(frame)
[16:06:16.534]                       }
[16:06:16.534]                     }
[16:06:16.534]                     sendCondition <<- function(cond) NULL
[16:06:16.534]                   }
[16:06:16.534]                 })
[16:06:16.534]                 withCallingHandlers({
[16:06:16.534]                   {
[16:06:16.534]                     Sys.sleep(0.5)
[16:06:16.534]                     2
[16:06:16.534]                   }
[16:06:16.534]                 }, immediateCondition = function(cond) {
[16:06:16.534]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.534]                   sendCondition(cond)
[16:06:16.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.534]                   {
[16:06:16.534]                     inherits <- base::inherits
[16:06:16.534]                     invokeRestart <- base::invokeRestart
[16:06:16.534]                     is.null <- base::is.null
[16:06:16.534]                     muffled <- FALSE
[16:06:16.534]                     if (inherits(cond, "message")) {
[16:06:16.534]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.534]                       if (muffled) 
[16:06:16.534]                         invokeRestart("muffleMessage")
[16:06:16.534]                     }
[16:06:16.534]                     else if (inherits(cond, "warning")) {
[16:06:16.534]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.534]                       if (muffled) 
[16:06:16.534]                         invokeRestart("muffleWarning")
[16:06:16.534]                     }
[16:06:16.534]                     else if (inherits(cond, "condition")) {
[16:06:16.534]                       if (!is.null(pattern)) {
[16:06:16.534]                         computeRestarts <- base::computeRestarts
[16:06:16.534]                         grepl <- base::grepl
[16:06:16.534]                         restarts <- computeRestarts(cond)
[16:06:16.534]                         for (restart in restarts) {
[16:06:16.534]                           name <- restart$name
[16:06:16.534]                           if (is.null(name)) 
[16:06:16.534]                             next
[16:06:16.534]                           if (!grepl(pattern, name)) 
[16:06:16.534]                             next
[16:06:16.534]                           invokeRestart(restart)
[16:06:16.534]                           muffled <- TRUE
[16:06:16.534]                           break
[16:06:16.534]                         }
[16:06:16.534]                       }
[16:06:16.534]                     }
[16:06:16.534]                     invisible(muffled)
[16:06:16.534]                   }
[16:06:16.534]                   muffleCondition(cond)
[16:06:16.534]                 })
[16:06:16.534]             }))
[16:06:16.534]             future::FutureResult(value = ...future.value$value, 
[16:06:16.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.534]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.534]                     ...future.globalenv.names))
[16:06:16.534]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.534]         }, condition = base::local({
[16:06:16.534]             c <- base::c
[16:06:16.534]             inherits <- base::inherits
[16:06:16.534]             invokeRestart <- base::invokeRestart
[16:06:16.534]             length <- base::length
[16:06:16.534]             list <- base::list
[16:06:16.534]             seq.int <- base::seq.int
[16:06:16.534]             signalCondition <- base::signalCondition
[16:06:16.534]             sys.calls <- base::sys.calls
[16:06:16.534]             `[[` <- base::`[[`
[16:06:16.534]             `+` <- base::`+`
[16:06:16.534]             `<<-` <- base::`<<-`
[16:06:16.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.534]                   3L)]
[16:06:16.534]             }
[16:06:16.534]             function(cond) {
[16:06:16.534]                 is_error <- inherits(cond, "error")
[16:06:16.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.534]                   NULL)
[16:06:16.534]                 if (is_error) {
[16:06:16.534]                   sessionInformation <- function() {
[16:06:16.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.534]                       search = base::search(), system = base::Sys.info())
[16:06:16.534]                   }
[16:06:16.534]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.534]                     cond$call), session = sessionInformation(), 
[16:06:16.534]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.534]                   signalCondition(cond)
[16:06:16.534]                 }
[16:06:16.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.534]                 "immediateCondition"))) {
[16:06:16.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.534]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.534]                   if (TRUE && !signal) {
[16:06:16.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.534]                     {
[16:06:16.534]                       inherits <- base::inherits
[16:06:16.534]                       invokeRestart <- base::invokeRestart
[16:06:16.534]                       is.null <- base::is.null
[16:06:16.534]                       muffled <- FALSE
[16:06:16.534]                       if (inherits(cond, "message")) {
[16:06:16.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.534]                         if (muffled) 
[16:06:16.534]                           invokeRestart("muffleMessage")
[16:06:16.534]                       }
[16:06:16.534]                       else if (inherits(cond, "warning")) {
[16:06:16.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.534]                         if (muffled) 
[16:06:16.534]                           invokeRestart("muffleWarning")
[16:06:16.534]                       }
[16:06:16.534]                       else if (inherits(cond, "condition")) {
[16:06:16.534]                         if (!is.null(pattern)) {
[16:06:16.534]                           computeRestarts <- base::computeRestarts
[16:06:16.534]                           grepl <- base::grepl
[16:06:16.534]                           restarts <- computeRestarts(cond)
[16:06:16.534]                           for (restart in restarts) {
[16:06:16.534]                             name <- restart$name
[16:06:16.534]                             if (is.null(name)) 
[16:06:16.534]                               next
[16:06:16.534]                             if (!grepl(pattern, name)) 
[16:06:16.534]                               next
[16:06:16.534]                             invokeRestart(restart)
[16:06:16.534]                             muffled <- TRUE
[16:06:16.534]                             break
[16:06:16.534]                           }
[16:06:16.534]                         }
[16:06:16.534]                       }
[16:06:16.534]                       invisible(muffled)
[16:06:16.534]                     }
[16:06:16.534]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.534]                   }
[16:06:16.534]                 }
[16:06:16.534]                 else {
[16:06:16.534]                   if (TRUE) {
[16:06:16.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.534]                     {
[16:06:16.534]                       inherits <- base::inherits
[16:06:16.534]                       invokeRestart <- base::invokeRestart
[16:06:16.534]                       is.null <- base::is.null
[16:06:16.534]                       muffled <- FALSE
[16:06:16.534]                       if (inherits(cond, "message")) {
[16:06:16.534]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.534]                         if (muffled) 
[16:06:16.534]                           invokeRestart("muffleMessage")
[16:06:16.534]                       }
[16:06:16.534]                       else if (inherits(cond, "warning")) {
[16:06:16.534]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.534]                         if (muffled) 
[16:06:16.534]                           invokeRestart("muffleWarning")
[16:06:16.534]                       }
[16:06:16.534]                       else if (inherits(cond, "condition")) {
[16:06:16.534]                         if (!is.null(pattern)) {
[16:06:16.534]                           computeRestarts <- base::computeRestarts
[16:06:16.534]                           grepl <- base::grepl
[16:06:16.534]                           restarts <- computeRestarts(cond)
[16:06:16.534]                           for (restart in restarts) {
[16:06:16.534]                             name <- restart$name
[16:06:16.534]                             if (is.null(name)) 
[16:06:16.534]                               next
[16:06:16.534]                             if (!grepl(pattern, name)) 
[16:06:16.534]                               next
[16:06:16.534]                             invokeRestart(restart)
[16:06:16.534]                             muffled <- TRUE
[16:06:16.534]                             break
[16:06:16.534]                           }
[16:06:16.534]                         }
[16:06:16.534]                       }
[16:06:16.534]                       invisible(muffled)
[16:06:16.534]                     }
[16:06:16.534]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.534]                   }
[16:06:16.534]                 }
[16:06:16.534]             }
[16:06:16.534]         }))
[16:06:16.534]     }, error = function(ex) {
[16:06:16.534]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.534]                 ...future.rng), started = ...future.startTime, 
[16:06:16.534]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.534]             version = "1.8"), class = "FutureResult")
[16:06:16.534]     }, finally = {
[16:06:16.534]         if (!identical(...future.workdir, getwd())) 
[16:06:16.534]             setwd(...future.workdir)
[16:06:16.534]         {
[16:06:16.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.534]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.534]             }
[16:06:16.534]             base::options(...future.oldOptions)
[16:06:16.534]             if (.Platform$OS.type == "windows") {
[16:06:16.534]                 old_names <- names(...future.oldEnvVars)
[16:06:16.534]                 envs <- base::Sys.getenv()
[16:06:16.534]                 names <- names(envs)
[16:06:16.534]                 common <- intersect(names, old_names)
[16:06:16.534]                 added <- setdiff(names, old_names)
[16:06:16.534]                 removed <- setdiff(old_names, names)
[16:06:16.534]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.534]                   envs[common]]
[16:06:16.534]                 NAMES <- toupper(changed)
[16:06:16.534]                 args <- list()
[16:06:16.534]                 for (kk in seq_along(NAMES)) {
[16:06:16.534]                   name <- changed[[kk]]
[16:06:16.534]                   NAME <- NAMES[[kk]]
[16:06:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.534]                     next
[16:06:16.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.534]                 }
[16:06:16.534]                 NAMES <- toupper(added)
[16:06:16.534]                 for (kk in seq_along(NAMES)) {
[16:06:16.534]                   name <- added[[kk]]
[16:06:16.534]                   NAME <- NAMES[[kk]]
[16:06:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.534]                     next
[16:06:16.534]                   args[[name]] <- ""
[16:06:16.534]                 }
[16:06:16.534]                 NAMES <- toupper(removed)
[16:06:16.534]                 for (kk in seq_along(NAMES)) {
[16:06:16.534]                   name <- removed[[kk]]
[16:06:16.534]                   NAME <- NAMES[[kk]]
[16:06:16.534]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.534]                     next
[16:06:16.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.534]                 }
[16:06:16.534]                 if (length(args) > 0) 
[16:06:16.534]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.534]             }
[16:06:16.534]             else {
[16:06:16.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.534]             }
[16:06:16.534]             {
[16:06:16.534]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.534]                   0L) {
[16:06:16.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.534]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.534]                   base::options(opts)
[16:06:16.534]                 }
[16:06:16.534]                 {
[16:06:16.534]                   {
[16:06:16.534]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.534]                     NULL
[16:06:16.534]                   }
[16:06:16.534]                   options(future.plan = NULL)
[16:06:16.534]                   if (is.na(NA_character_)) 
[16:06:16.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.534]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.534]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.534]                     envir = parent.frame()) 
[16:06:16.534]                   {
[16:06:16.534]                     if (is.function(workers)) 
[16:06:16.534]                       workers <- workers()
[16:06:16.534]                     workers <- structure(as.integer(workers), 
[16:06:16.534]                       class = class(workers))
[16:06:16.534]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.534]                       workers >= 1)
[16:06:16.534]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.534]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.534]                     }
[16:06:16.534]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.534]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.534]                       envir = envir)
[16:06:16.534]                     if (!future$lazy) 
[16:06:16.534]                       future <- run(future)
[16:06:16.534]                     invisible(future)
[16:06:16.534]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.534]                 }
[16:06:16.534]             }
[16:06:16.534]         }
[16:06:16.534]     })
[16:06:16.534]     if (TRUE) {
[16:06:16.534]         base::sink(type = "output", split = FALSE)
[16:06:16.534]         if (TRUE) {
[16:06:16.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.534]         }
[16:06:16.534]         else {
[16:06:16.534]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.534]         }
[16:06:16.534]         base::close(...future.stdout)
[16:06:16.534]         ...future.stdout <- NULL
[16:06:16.534]     }
[16:06:16.534]     ...future.result$conditions <- ...future.conditions
[16:06:16.534]     ...future.result$finished <- base::Sys.time()
[16:06:16.534]     ...future.result
[16:06:16.534] }
[16:06:16.537] MultisessionFuture started
[16:06:16.538] - Launch lazy future ... done
[16:06:16.538] run() for ‘MultisessionFuture’ ... done
[16:06:16.538] getGlobalsAndPackages() ...
[16:06:16.538] Searching for globals...
[16:06:16.539] - globals found: [1] ‘{’
[16:06:16.539] Searching for globals ... DONE
[16:06:16.539] Resolving globals: FALSE
[16:06:16.539] 
[16:06:16.539] 
[16:06:16.539] getGlobalsAndPackages() ... DONE
[16:06:16.540] run() for ‘Future’ ...
[16:06:16.540] - state: ‘created’
[16:06:16.540] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:06:16.554] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:06:16.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:06:16.554]   - Field: ‘node’
[16:06:16.554]   - Field: ‘label’
[16:06:16.554]   - Field: ‘local’
[16:06:16.554]   - Field: ‘owner’
[16:06:16.554]   - Field: ‘envir’
[16:06:16.554]   - Field: ‘workers’
[16:06:16.554]   - Field: ‘packages’
[16:06:16.555]   - Field: ‘gc’
[16:06:16.555]   - Field: ‘conditions’
[16:06:16.555]   - Field: ‘persistent’
[16:06:16.555]   - Field: ‘expr’
[16:06:16.555]   - Field: ‘uuid’
[16:06:16.555]   - Field: ‘seed’
[16:06:16.555]   - Field: ‘version’
[16:06:16.555]   - Field: ‘result’
[16:06:16.556]   - Field: ‘asynchronous’
[16:06:16.556]   - Field: ‘calls’
[16:06:16.556]   - Field: ‘globals’
[16:06:16.556]   - Field: ‘stdout’
[16:06:16.556]   - Field: ‘earlySignal’
[16:06:16.556]   - Field: ‘lazy’
[16:06:16.556]   - Field: ‘state’
[16:06:16.557] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:06:16.557] - Launch lazy future ...
[16:06:16.557] Packages needed by the future expression (n = 0): <none>
[16:06:16.557] Packages needed by future strategies (n = 0): <none>
[16:06:16.558] {
[16:06:16.558]     {
[16:06:16.558]         {
[16:06:16.558]             ...future.startTime <- base::Sys.time()
[16:06:16.558]             {
[16:06:16.558]                 {
[16:06:16.558]                   {
[16:06:16.558]                     {
[16:06:16.558]                       base::local({
[16:06:16.558]                         has_future <- base::requireNamespace("future", 
[16:06:16.558]                           quietly = TRUE)
[16:06:16.558]                         if (has_future) {
[16:06:16.558]                           ns <- base::getNamespace("future")
[16:06:16.558]                           version <- ns[[".package"]][["version"]]
[16:06:16.558]                           if (is.null(version)) 
[16:06:16.558]                             version <- utils::packageVersion("future")
[16:06:16.558]                         }
[16:06:16.558]                         else {
[16:06:16.558]                           version <- NULL
[16:06:16.558]                         }
[16:06:16.558]                         if (!has_future || version < "1.8.0") {
[16:06:16.558]                           info <- base::c(r_version = base::gsub("R version ", 
[16:06:16.558]                             "", base::R.version$version.string), 
[16:06:16.558]                             platform = base::sprintf("%s (%s-bit)", 
[16:06:16.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:06:16.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:06:16.558]                               "release", "version")], collapse = " "), 
[16:06:16.558]                             hostname = base::Sys.info()[["nodename"]])
[16:06:16.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:06:16.558]                             info)
[16:06:16.558]                           info <- base::paste(info, collapse = "; ")
[16:06:16.558]                           if (!has_future) {
[16:06:16.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:06:16.558]                               info)
[16:06:16.558]                           }
[16:06:16.558]                           else {
[16:06:16.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:06:16.558]                               info, version)
[16:06:16.558]                           }
[16:06:16.558]                           base::stop(msg)
[16:06:16.558]                         }
[16:06:16.558]                       })
[16:06:16.558]                     }
[16:06:16.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:06:16.558]                     base::options(mc.cores = 1L)
[16:06:16.558]                   }
[16:06:16.558]                   options(future.plan = NULL)
[16:06:16.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:06:16.558]                 }
[16:06:16.558]                 ...future.workdir <- getwd()
[16:06:16.558]             }
[16:06:16.558]             ...future.oldOptions <- base::as.list(base::.Options)
[16:06:16.558]             ...future.oldEnvVars <- base::Sys.getenv()
[16:06:16.558]         }
[16:06:16.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:06:16.558]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:06:16.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:06:16.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:06:16.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:06:16.558]             future.stdout.windows.reencode = NULL, width = 80L)
[16:06:16.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:06:16.558]             base::names(...future.oldOptions))
[16:06:16.558]     }
[16:06:16.558]     if (FALSE) {
[16:06:16.558]     }
[16:06:16.558]     else {
[16:06:16.558]         if (TRUE) {
[16:06:16.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:06:16.558]                 open = "w")
[16:06:16.558]         }
[16:06:16.558]         else {
[16:06:16.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:06:16.558]                 windows = "NUL", "/dev/null"), open = "w")
[16:06:16.558]         }
[16:06:16.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:06:16.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:06:16.558]             base::sink(type = "output", split = FALSE)
[16:06:16.558]             base::close(...future.stdout)
[16:06:16.558]         }, add = TRUE)
[16:06:16.558]     }
[16:06:16.558]     ...future.frame <- base::sys.nframe()
[16:06:16.558]     ...future.conditions <- base::list()
[16:06:16.558]     ...future.rng <- base::globalenv()$.Random.seed
[16:06:16.558]     if (FALSE) {
[16:06:16.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:06:16.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:06:16.558]     }
[16:06:16.558]     ...future.result <- base::tryCatch({
[16:06:16.558]         base::withCallingHandlers({
[16:06:16.558]             ...future.value <- base::withVisible(base::local({
[16:06:16.558]                 ...future.makeSendCondition <- base::local({
[16:06:16.558]                   sendCondition <- NULL
[16:06:16.558]                   function(frame = 1L) {
[16:06:16.558]                     if (is.function(sendCondition)) 
[16:06:16.558]                       return(sendCondition)
[16:06:16.558]                     ns <- getNamespace("parallel")
[16:06:16.558]                     if (exists("sendData", mode = "function", 
[16:06:16.558]                       envir = ns)) {
[16:06:16.558]                       parallel_sendData <- get("sendData", mode = "function", 
[16:06:16.558]                         envir = ns)
[16:06:16.558]                       envir <- sys.frame(frame)
[16:06:16.558]                       master <- NULL
[16:06:16.558]                       while (!identical(envir, .GlobalEnv) && 
[16:06:16.558]                         !identical(envir, emptyenv())) {
[16:06:16.558]                         if (exists("master", mode = "list", envir = envir, 
[16:06:16.558]                           inherits = FALSE)) {
[16:06:16.558]                           master <- get("master", mode = "list", 
[16:06:16.558]                             envir = envir, inherits = FALSE)
[16:06:16.558]                           if (inherits(master, c("SOCKnode", 
[16:06:16.558]                             "SOCK0node"))) {
[16:06:16.558]                             sendCondition <<- function(cond) {
[16:06:16.558]                               data <- list(type = "VALUE", value = cond, 
[16:06:16.558]                                 success = TRUE)
[16:06:16.558]                               parallel_sendData(master, data)
[16:06:16.558]                             }
[16:06:16.558]                             return(sendCondition)
[16:06:16.558]                           }
[16:06:16.558]                         }
[16:06:16.558]                         frame <- frame + 1L
[16:06:16.558]                         envir <- sys.frame(frame)
[16:06:16.558]                       }
[16:06:16.558]                     }
[16:06:16.558]                     sendCondition <<- function(cond) NULL
[16:06:16.558]                   }
[16:06:16.558]                 })
[16:06:16.558]                 withCallingHandlers({
[16:06:16.558]                   {
[16:06:16.558]                     3
[16:06:16.558]                   }
[16:06:16.558]                 }, immediateCondition = function(cond) {
[16:06:16.558]                   sendCondition <- ...future.makeSendCondition()
[16:06:16.558]                   sendCondition(cond)
[16:06:16.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.558]                   {
[16:06:16.558]                     inherits <- base::inherits
[16:06:16.558]                     invokeRestart <- base::invokeRestart
[16:06:16.558]                     is.null <- base::is.null
[16:06:16.558]                     muffled <- FALSE
[16:06:16.558]                     if (inherits(cond, "message")) {
[16:06:16.558]                       muffled <- grepl(pattern, "muffleMessage")
[16:06:16.558]                       if (muffled) 
[16:06:16.558]                         invokeRestart("muffleMessage")
[16:06:16.558]                     }
[16:06:16.558]                     else if (inherits(cond, "warning")) {
[16:06:16.558]                       muffled <- grepl(pattern, "muffleWarning")
[16:06:16.558]                       if (muffled) 
[16:06:16.558]                         invokeRestart("muffleWarning")
[16:06:16.558]                     }
[16:06:16.558]                     else if (inherits(cond, "condition")) {
[16:06:16.558]                       if (!is.null(pattern)) {
[16:06:16.558]                         computeRestarts <- base::computeRestarts
[16:06:16.558]                         grepl <- base::grepl
[16:06:16.558]                         restarts <- computeRestarts(cond)
[16:06:16.558]                         for (restart in restarts) {
[16:06:16.558]                           name <- restart$name
[16:06:16.558]                           if (is.null(name)) 
[16:06:16.558]                             next
[16:06:16.558]                           if (!grepl(pattern, name)) 
[16:06:16.558]                             next
[16:06:16.558]                           invokeRestart(restart)
[16:06:16.558]                           muffled <- TRUE
[16:06:16.558]                           break
[16:06:16.558]                         }
[16:06:16.558]                       }
[16:06:16.558]                     }
[16:06:16.558]                     invisible(muffled)
[16:06:16.558]                   }
[16:06:16.558]                   muffleCondition(cond)
[16:06:16.558]                 })
[16:06:16.558]             }))
[16:06:16.558]             future::FutureResult(value = ...future.value$value, 
[16:06:16.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.558]                   ...future.rng), globalenv = if (FALSE) 
[16:06:16.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:06:16.558]                     ...future.globalenv.names))
[16:06:16.558]                 else NULL, started = ...future.startTime, version = "1.8")
[16:06:16.558]         }, condition = base::local({
[16:06:16.558]             c <- base::c
[16:06:16.558]             inherits <- base::inherits
[16:06:16.558]             invokeRestart <- base::invokeRestart
[16:06:16.558]             length <- base::length
[16:06:16.558]             list <- base::list
[16:06:16.558]             seq.int <- base::seq.int
[16:06:16.558]             signalCondition <- base::signalCondition
[16:06:16.558]             sys.calls <- base::sys.calls
[16:06:16.558]             `[[` <- base::`[[`
[16:06:16.558]             `+` <- base::`+`
[16:06:16.558]             `<<-` <- base::`<<-`
[16:06:16.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:06:16.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:06:16.558]                   3L)]
[16:06:16.558]             }
[16:06:16.558]             function(cond) {
[16:06:16.558]                 is_error <- inherits(cond, "error")
[16:06:16.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:06:16.558]                   NULL)
[16:06:16.558]                 if (is_error) {
[16:06:16.558]                   sessionInformation <- function() {
[16:06:16.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:06:16.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:06:16.558]                       search = base::search(), system = base::Sys.info())
[16:06:16.558]                   }
[16:06:16.558]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:06:16.558]                     cond$call), session = sessionInformation(), 
[16:06:16.558]                     timestamp = base::Sys.time(), signaled = 0L)
[16:06:16.558]                   signalCondition(cond)
[16:06:16.558]                 }
[16:06:16.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:06:16.558]                 "immediateCondition"))) {
[16:06:16.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:06:16.558]                   ...future.conditions[[length(...future.conditions) + 
[16:06:16.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:06:16.558]                   if (TRUE && !signal) {
[16:06:16.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.558]                     {
[16:06:16.558]                       inherits <- base::inherits
[16:06:16.558]                       invokeRestart <- base::invokeRestart
[16:06:16.558]                       is.null <- base::is.null
[16:06:16.558]                       muffled <- FALSE
[16:06:16.558]                       if (inherits(cond, "message")) {
[16:06:16.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.558]                         if (muffled) 
[16:06:16.558]                           invokeRestart("muffleMessage")
[16:06:16.558]                       }
[16:06:16.558]                       else if (inherits(cond, "warning")) {
[16:06:16.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.558]                         if (muffled) 
[16:06:16.558]                           invokeRestart("muffleWarning")
[16:06:16.558]                       }
[16:06:16.558]                       else if (inherits(cond, "condition")) {
[16:06:16.558]                         if (!is.null(pattern)) {
[16:06:16.558]                           computeRestarts <- base::computeRestarts
[16:06:16.558]                           grepl <- base::grepl
[16:06:16.558]                           restarts <- computeRestarts(cond)
[16:06:16.558]                           for (restart in restarts) {
[16:06:16.558]                             name <- restart$name
[16:06:16.558]                             if (is.null(name)) 
[16:06:16.558]                               next
[16:06:16.558]                             if (!grepl(pattern, name)) 
[16:06:16.558]                               next
[16:06:16.558]                             invokeRestart(restart)
[16:06:16.558]                             muffled <- TRUE
[16:06:16.558]                             break
[16:06:16.558]                           }
[16:06:16.558]                         }
[16:06:16.558]                       }
[16:06:16.558]                       invisible(muffled)
[16:06:16.558]                     }
[16:06:16.558]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.558]                   }
[16:06:16.558]                 }
[16:06:16.558]                 else {
[16:06:16.558]                   if (TRUE) {
[16:06:16.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:06:16.558]                     {
[16:06:16.558]                       inherits <- base::inherits
[16:06:16.558]                       invokeRestart <- base::invokeRestart
[16:06:16.558]                       is.null <- base::is.null
[16:06:16.558]                       muffled <- FALSE
[16:06:16.558]                       if (inherits(cond, "message")) {
[16:06:16.558]                         muffled <- grepl(pattern, "muffleMessage")
[16:06:16.558]                         if (muffled) 
[16:06:16.558]                           invokeRestart("muffleMessage")
[16:06:16.558]                       }
[16:06:16.558]                       else if (inherits(cond, "warning")) {
[16:06:16.558]                         muffled <- grepl(pattern, "muffleWarning")
[16:06:16.558]                         if (muffled) 
[16:06:16.558]                           invokeRestart("muffleWarning")
[16:06:16.558]                       }
[16:06:16.558]                       else if (inherits(cond, "condition")) {
[16:06:16.558]                         if (!is.null(pattern)) {
[16:06:16.558]                           computeRestarts <- base::computeRestarts
[16:06:16.558]                           grepl <- base::grepl
[16:06:16.558]                           restarts <- computeRestarts(cond)
[16:06:16.558]                           for (restart in restarts) {
[16:06:16.558]                             name <- restart$name
[16:06:16.558]                             if (is.null(name)) 
[16:06:16.558]                               next
[16:06:16.558]                             if (!grepl(pattern, name)) 
[16:06:16.558]                               next
[16:06:16.558]                             invokeRestart(restart)
[16:06:16.558]                             muffled <- TRUE
[16:06:16.558]                             break
[16:06:16.558]                           }
[16:06:16.558]                         }
[16:06:16.558]                       }
[16:06:16.558]                       invisible(muffled)
[16:06:16.558]                     }
[16:06:16.558]                     muffleCondition(cond, pattern = "^muffle")
[16:06:16.558]                   }
[16:06:16.558]                 }
[16:06:16.558]             }
[16:06:16.558]         }))
[16:06:16.558]     }, error = function(ex) {
[16:06:16.558]         base::structure(base::list(value = NULL, visible = NULL, 
[16:06:16.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:06:16.558]                 ...future.rng), started = ...future.startTime, 
[16:06:16.558]             finished = Sys.time(), session_uuid = NA_character_, 
[16:06:16.558]             version = "1.8"), class = "FutureResult")
[16:06:16.558]     }, finally = {
[16:06:16.558]         if (!identical(...future.workdir, getwd())) 
[16:06:16.558]             setwd(...future.workdir)
[16:06:16.558]         {
[16:06:16.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:06:16.558]                 ...future.oldOptions$nwarnings <- NULL
[16:06:16.558]             }
[16:06:16.558]             base::options(...future.oldOptions)
[16:06:16.558]             if (.Platform$OS.type == "windows") {
[16:06:16.558]                 old_names <- names(...future.oldEnvVars)
[16:06:16.558]                 envs <- base::Sys.getenv()
[16:06:16.558]                 names <- names(envs)
[16:06:16.558]                 common <- intersect(names, old_names)
[16:06:16.558]                 added <- setdiff(names, old_names)
[16:06:16.558]                 removed <- setdiff(old_names, names)
[16:06:16.558]                 changed <- common[...future.oldEnvVars[common] != 
[16:06:16.558]                   envs[common]]
[16:06:16.558]                 NAMES <- toupper(changed)
[16:06:16.558]                 args <- list()
[16:06:16.558]                 for (kk in seq_along(NAMES)) {
[16:06:16.558]                   name <- changed[[kk]]
[16:06:16.558]                   NAME <- NAMES[[kk]]
[16:06:16.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.558]                     next
[16:06:16.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.558]                 }
[16:06:16.558]                 NAMES <- toupper(added)
[16:06:16.558]                 for (kk in seq_along(NAMES)) {
[16:06:16.558]                   name <- added[[kk]]
[16:06:16.558]                   NAME <- NAMES[[kk]]
[16:06:16.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.558]                     next
[16:06:16.558]                   args[[name]] <- ""
[16:06:16.558]                 }
[16:06:16.558]                 NAMES <- toupper(removed)
[16:06:16.558]                 for (kk in seq_along(NAMES)) {
[16:06:16.558]                   name <- removed[[kk]]
[16:06:16.558]                   NAME <- NAMES[[kk]]
[16:06:16.558]                   if (name != NAME && is.element(NAME, old_names)) 
[16:06:16.558]                     next
[16:06:16.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:06:16.558]                 }
[16:06:16.558]                 if (length(args) > 0) 
[16:06:16.558]                   base::do.call(base::Sys.setenv, args = args)
[16:06:16.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:06:16.558]             }
[16:06:16.558]             else {
[16:06:16.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:06:16.558]             }
[16:06:16.558]             {
[16:06:16.558]                 if (base::length(...future.futureOptionsAdded) > 
[16:06:16.558]                   0L) {
[16:06:16.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:06:16.558]                   base::names(opts) <- ...future.futureOptionsAdded
[16:06:16.558]                   base::options(opts)
[16:06:16.558]                 }
[16:06:16.558]                 {
[16:06:16.558]                   {
[16:06:16.558]                     base::options(mc.cores = ...future.mc.cores.old)
[16:06:16.558]                     NULL
[16:06:16.558]                   }
[16:06:16.558]                   options(future.plan = NULL)
[16:06:16.558]                   if (is.na(NA_character_)) 
[16:06:16.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:06:16.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:06:16.558]                   future::plan(list(function (..., workers = availableCores(), 
[16:06:16.558]                     lazy = FALSE, rscript_libs = .libPaths(), 
[16:06:16.558]                     envir = parent.frame()) 
[16:06:16.558]                   {
[16:06:16.558]                     if (is.function(workers)) 
[16:06:16.558]                       workers <- workers()
[16:06:16.558]                     workers <- structure(as.integer(workers), 
[16:06:16.558]                       class = class(workers))
[16:06:16.558]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[16:06:16.558]                       workers >= 1)
[16:06:16.558]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[16:06:16.558]                       return(sequential(..., lazy = TRUE, envir = envir))
[16:06:16.558]                     }
[16:06:16.558]                     future <- MultisessionFuture(..., workers = workers, 
[16:06:16.558]                       lazy = lazy, rscript_libs = rscript_libs, 
[16:06:16.558]                       envir = envir)
[16:06:16.558]                     if (!future$lazy) 
[16:06:16.558]                       future <- run(future)
[16:06:16.558]                     invisible(future)
[16:06:16.558]                   }), .cleanup = FALSE, .init = FALSE)
[16:06:16.558]                 }
[16:06:16.558]             }
[16:06:16.558]         }
[16:06:16.558]     })
[16:06:16.558]     if (TRUE) {
[16:06:16.558]         base::sink(type = "output", split = FALSE)
[16:06:16.558]         if (TRUE) {
[16:06:16.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:06:16.558]         }
[16:06:16.558]         else {
[16:06:16.558]             ...future.result["stdout"] <- base::list(NULL)
[16:06:16.558]         }
[16:06:16.558]         base::close(...future.stdout)
[16:06:16.558]         ...future.stdout <- NULL
[16:06:16.558]     }
[16:06:16.558]     ...future.result$conditions <- ...future.conditions
[16:06:16.558]     ...future.result$finished <- base::Sys.time()
[16:06:16.558]     ...future.result
[16:06:16.558] }
[16:06:16.561] Poll #1 (0): usedNodes() = 2, workers = 2
[16:06:16.571] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.572] - Validating connection of MultisessionFuture
[16:06:16.572] - received message: FutureResult
[16:06:16.572] - Received FutureResult
[16:06:16.572] - Erased future from FutureRegistry
[16:06:16.572] result() for ClusterFuture ...
[16:06:16.572] - result already collected: FutureResult
[16:06:16.572] result() for ClusterFuture ... done
[16:06:16.572] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.573] result() for ClusterFuture ...
[16:06:16.573] - result already collected: FutureResult
[16:06:16.573] result() for ClusterFuture ... done
[16:06:16.573] result() for ClusterFuture ...
[16:06:16.573] - result already collected: FutureResult
[16:06:16.573] result() for ClusterFuture ... done
[16:06:16.574] MultisessionFuture started
[16:06:16.574] - Launch lazy future ... done
[16:06:16.574] run() for ‘MultisessionFuture’ ... done
[16:06:16.575] resolve() on list environment ...
[16:06:16.575]  recursive: 0
[16:06:16.576]  length: 4
[16:06:16.576]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:06:16.576] Future #1
[16:06:16.576]  length: 3 (resolved future 1)
[16:06:16.597]  length: 2 (resolved future 4)
[16:06:16.619] receiveMessageFromWorker() for ClusterFuture ...
[16:06:16.620] - Validating connection of MultisessionFuture
[16:06:16.620] - received message: FutureResult
[16:06:16.620] - Received FutureResult
[16:06:16.620] - Erased future from FutureRegistry
[16:06:16.620] result() for ClusterFuture ...
[16:06:16.620] - result already collected: FutureResult
[16:06:16.620] result() for ClusterFuture ... done
[16:06:16.620] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:16.621] Future #3
[16:06:16.621]  length: 1 (resolved future 3)
[16:06:17.089] receiveMessageFromWorker() for ClusterFuture ...
[16:06:17.089] - Validating connection of MultisessionFuture
[16:06:17.089] - received message: FutureResult
[16:06:17.089] - Received FutureResult
[16:06:17.090] - Erased future from FutureRegistry
[16:06:17.090] result() for ClusterFuture ...
[16:06:17.090] - result already collected: FutureResult
[16:06:17.090] result() for ClusterFuture ... done
[16:06:17.090] receiveMessageFromWorker() for ClusterFuture ... done
[16:06:17.090] Future #2
[16:06:17.090]  length: 0 (resolved future 2)
[16:06:17.090] resolve() on list environment ... DONE
[16:06:17.091] resolve() on list environment ...
[16:06:17.091]  recursive: 0
[16:06:17.091]  length: 4
[16:06:17.091]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:06:17.092] Future #1
[16:06:17.092]  length: 3 (resolved future 1)
[16:06:17.092] Future #2
[16:06:17.092]  length: 2 (resolved future 2)
[16:06:17.092] Future #3
[16:06:17.092]  length: 1 (resolved future 3)
[16:06:17.092]  length: 0 (resolved future 4)
[16:06:17.092] resolve() on list environment ... DONE
[16:06:17.093] resolve() on list environment ...
[16:06:17.093]  recursive: 0
[16:06:17.094]  length: 4
[16:06:17.094]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:06:17.094] Future #1
[16:06:17.094]  length: 3 (resolved future 1)
[16:06:17.094] Future #2
[16:06:17.094]  length: 2 (resolved future 2)
[16:06:17.094] Future #3
[16:06:17.094]  length: 1 (resolved future 3)
[16:06:17.094]  length: 0 (resolved future 4)
[16:06:17.095] resolve() on list environment ... DONE
[16:06:17.095] resolve() on list environment ...
[16:06:17.095]  recursive: 0
[16:06:17.096]  length: 4
[16:06:17.096]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:06:17.096] Future #1
[16:06:17.096]  length: 3 (resolved future 1)
[16:06:17.096] Future #2
[16:06:17.096]  length: 2 (resolved future 2)
[16:06:17.096] Future #3
[16:06:17.097]  length: 1 (resolved future 3)
[16:06:17.097]  length: 0 (resolved future 4)
[16:06:17.097] resolve() on list environment ... DONE
[16:06:17.097] resolve() on list environment ...
[16:06:17.097]  recursive: 0
[16:06:17.098]  length: 4
[16:06:17.098]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:06:17.098] Future #1
[16:06:17.098] result() for ClusterFuture ...
[16:06:17.098] - result already collected: FutureResult
[16:06:17.098] result() for ClusterFuture ... done
[16:06:17.098] result() for ClusterFuture ...
[16:06:17.099] - result already collected: FutureResult
[16:06:17.099] result() for ClusterFuture ... done
[16:06:17.099]  length: 3 (resolved future 1)
[16:06:17.099] Future #2
[16:06:17.099] result() for ClusterFuture ...
[16:06:17.099] - result already collected: FutureResult
[16:06:17.099] result() for ClusterFuture ... done
[16:06:17.099] result() for ClusterFuture ...
[16:06:17.099] - result already collected: FutureResult
[16:06:17.099] result() for ClusterFuture ... done
[16:06:17.100]  length: 2 (resolved future 2)
[16:06:17.100] Future #3
[16:06:17.100] result() for ClusterFuture ...
[16:06:17.100] - result already collected: FutureResult
[16:06:17.100] result() for ClusterFuture ... done
[16:06:17.100] result() for ClusterFuture ...
[16:06:17.100] - result already collected: FutureResult
[16:06:17.100] result() for ClusterFuture ... done
[16:06:17.100]  length: 1 (resolved future 3)
[16:06:17.100]  length: 0 (resolved future 4)
[16:06:17.101] resolve() on list environment ... DONE
[16:06:17.101] resolve() on list environment ...
[16:06:17.101]  recursive: 99
[16:06:17.102]  length: 4
[16:06:17.102]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[16:06:17.102] Future #1
[16:06:17.102] result() for ClusterFuture ...
[16:06:17.102] - result already collected: FutureResult
[16:06:17.102] result() for ClusterFuture ... done
[16:06:17.102] result() for ClusterFuture ...
[16:06:17.102] - result already collected: FutureResult
[16:06:17.102] result() for ClusterFuture ... done
[16:06:17.103] A MultisessionFuture was resolved
[16:06:17.103]  length: 3 (resolved future 1)
[16:06:17.103] Future #2
[16:06:17.103] result() for ClusterFuture ...
[16:06:17.103] - result already collected: FutureResult
[16:06:17.103] result() for ClusterFuture ... done
[16:06:17.103] result() for ClusterFuture ...
[16:06:17.103] - result already collected: FutureResult
[16:06:17.103] result() for ClusterFuture ... done
[16:06:17.104] A MultisessionFuture was resolved
[16:06:17.104]  length: 2 (resolved future 2)
[16:06:17.104] Future #3
[16:06:17.104] result() for ClusterFuture ...
[16:06:17.104] - result already collected: FutureResult
[16:06:17.104] result() for ClusterFuture ... done
[16:06:17.104] result() for ClusterFuture ...
[16:06:17.104] - result already collected: FutureResult
[16:06:17.104] result() for ClusterFuture ... done
[16:06:17.104] A MultisessionFuture was resolved
[16:06:17.105]  length: 1 (resolved future 3)
[16:06:17.105]  length: 0 (resolved future 4)
[16:06:17.105] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[16:06:17.108] resolve() on list ...
[16:06:17.108]  recursive: 0
[16:06:17.108]  length: 3
[16:06:17.108] 
[16:06:17.108]  length: 2 (resolved future 1)
[16:06:17.108]  length: 1 (resolved future 2)
[16:06:17.108]  length: 0 (resolved future 3)
[16:06:17.108] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[16:06:17.109] plan(): Setting new future strategy stack:
[16:06:17.109] List of future strategies:
[16:06:17.109] 1. FutureStrategy:
[16:06:17.109]    - args: function (..., envir = parent.frame())
[16:06:17.109]    - tweaked: FALSE
[16:06:17.109]    - call: future::plan(oplan)
[16:06:17.110] plan(): nbrOfWorkers() = 1
> 
