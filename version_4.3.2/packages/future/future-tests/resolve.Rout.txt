
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[13:24:20.177] plan(): Setting new future strategy stack:
[13:24:20.178] List of future strategies:
[13:24:20.178] 1. sequential:
[13:24:20.178]    - args: function (..., envir = parent.frame())
[13:24:20.178]    - tweaked: FALSE
[13:24:20.178]    - call: future::plan("sequential")
[13:24:20.193] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[13:24:20.386] plan(): Setting new future strategy stack:
[13:24:20.387] List of future strategies:
[13:24:20.387] 1. sequential:
[13:24:20.387]    - args: function (..., envir = parent.frame())
[13:24:20.387]    - tweaked: FALSE
[13:24:20.387]    - call: plan(strategy)
[13:24:20.399] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[13:24:20.400] resolve() on list ...
[13:24:20.400]  recursive: 0
[13:24:20.400]  length: 2
[13:24:20.400]  elements: ‘a’, ‘b’
[13:24:20.401]  length: 1 (resolved future 1)
[13:24:20.401]  length: 0 (resolved future 2)
[13:24:20.401] resolve() on list ... DONE
[13:24:20.402] getGlobalsAndPackages() ...
[13:24:20.402] Searching for globals...
[13:24:20.404] 
[13:24:20.404] Searching for globals ... DONE
[13:24:20.404] - globals: [0] <none>
[13:24:20.404] getGlobalsAndPackages() ... DONE
[13:24:20.405] run() for ‘Future’ ...
[13:24:20.405] - state: ‘created’
[13:24:20.405] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.406] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.406]   - Field: ‘label’
[13:24:20.406]   - Field: ‘local’
[13:24:20.406]   - Field: ‘owner’
[13:24:20.406]   - Field: ‘envir’
[13:24:20.406]   - Field: ‘packages’
[13:24:20.406]   - Field: ‘gc’
[13:24:20.407]   - Field: ‘conditions’
[13:24:20.407]   - Field: ‘expr’
[13:24:20.407]   - Field: ‘uuid’
[13:24:20.407]   - Field: ‘seed’
[13:24:20.407]   - Field: ‘version’
[13:24:20.407]   - Field: ‘result’
[13:24:20.407]   - Field: ‘asynchronous’
[13:24:20.407]   - Field: ‘calls’
[13:24:20.407]   - Field: ‘globals’
[13:24:20.407]   - Field: ‘stdout’
[13:24:20.407]   - Field: ‘earlySignal’
[13:24:20.408]   - Field: ‘lazy’
[13:24:20.408]   - Field: ‘state’
[13:24:20.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.408] - Launch lazy future ...
[13:24:20.409] Packages needed by the future expression (n = 0): <none>
[13:24:20.409] Packages needed by future strategies (n = 0): <none>
[13:24:20.410] {
[13:24:20.410]     {
[13:24:20.410]         {
[13:24:20.410]             ...future.startTime <- base::Sys.time()
[13:24:20.410]             {
[13:24:20.410]                 {
[13:24:20.410]                   {
[13:24:20.410]                     base::local({
[13:24:20.410]                       has_future <- base::requireNamespace("future", 
[13:24:20.410]                         quietly = TRUE)
[13:24:20.410]                       if (has_future) {
[13:24:20.410]                         ns <- base::getNamespace("future")
[13:24:20.410]                         version <- ns[[".package"]][["version"]]
[13:24:20.410]                         if (is.null(version)) 
[13:24:20.410]                           version <- utils::packageVersion("future")
[13:24:20.410]                       }
[13:24:20.410]                       else {
[13:24:20.410]                         version <- NULL
[13:24:20.410]                       }
[13:24:20.410]                       if (!has_future || version < "1.8.0") {
[13:24:20.410]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.410]                           "", base::R.version$version.string), 
[13:24:20.410]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.410]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.410]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.410]                             "release", "version")], collapse = " "), 
[13:24:20.410]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.410]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.410]                           info)
[13:24:20.410]                         info <- base::paste(info, collapse = "; ")
[13:24:20.410]                         if (!has_future) {
[13:24:20.410]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.410]                             info)
[13:24:20.410]                         }
[13:24:20.410]                         else {
[13:24:20.410]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.410]                             info, version)
[13:24:20.410]                         }
[13:24:20.410]                         base::stop(msg)
[13:24:20.410]                       }
[13:24:20.410]                     })
[13:24:20.410]                   }
[13:24:20.410]                   options(future.plan = NULL)
[13:24:20.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.410]                 }
[13:24:20.410]                 ...future.workdir <- getwd()
[13:24:20.410]             }
[13:24:20.410]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.410]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.410]         }
[13:24:20.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.410]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.410]             base::names(...future.oldOptions))
[13:24:20.410]     }
[13:24:20.410]     if (FALSE) {
[13:24:20.410]     }
[13:24:20.410]     else {
[13:24:20.410]         if (TRUE) {
[13:24:20.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.410]                 open = "w")
[13:24:20.410]         }
[13:24:20.410]         else {
[13:24:20.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.410]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.410]         }
[13:24:20.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.410]             base::sink(type = "output", split = FALSE)
[13:24:20.410]             base::close(...future.stdout)
[13:24:20.410]         }, add = TRUE)
[13:24:20.410]     }
[13:24:20.410]     ...future.frame <- base::sys.nframe()
[13:24:20.410]     ...future.conditions <- base::list()
[13:24:20.410]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.410]     if (FALSE) {
[13:24:20.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.410]     }
[13:24:20.410]     ...future.result <- base::tryCatch({
[13:24:20.410]         base::withCallingHandlers({
[13:24:20.410]             ...future.value <- base::withVisible(base::local(1))
[13:24:20.410]             future::FutureResult(value = ...future.value$value, 
[13:24:20.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.410]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.410]                     ...future.globalenv.names))
[13:24:20.410]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.410]         }, condition = base::local({
[13:24:20.410]             c <- base::c
[13:24:20.410]             inherits <- base::inherits
[13:24:20.410]             invokeRestart <- base::invokeRestart
[13:24:20.410]             length <- base::length
[13:24:20.410]             list <- base::list
[13:24:20.410]             seq.int <- base::seq.int
[13:24:20.410]             signalCondition <- base::signalCondition
[13:24:20.410]             sys.calls <- base::sys.calls
[13:24:20.410]             `[[` <- base::`[[`
[13:24:20.410]             `+` <- base::`+`
[13:24:20.410]             `<<-` <- base::`<<-`
[13:24:20.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.410]                   3L)]
[13:24:20.410]             }
[13:24:20.410]             function(cond) {
[13:24:20.410]                 is_error <- inherits(cond, "error")
[13:24:20.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.410]                   NULL)
[13:24:20.410]                 if (is_error) {
[13:24:20.410]                   sessionInformation <- function() {
[13:24:20.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.410]                       search = base::search(), system = base::Sys.info())
[13:24:20.410]                   }
[13:24:20.410]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.410]                     cond$call), session = sessionInformation(), 
[13:24:20.410]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.410]                   signalCondition(cond)
[13:24:20.410]                 }
[13:24:20.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.410]                 "immediateCondition"))) {
[13:24:20.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.410]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.410]                   if (TRUE && !signal) {
[13:24:20.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.410]                     {
[13:24:20.410]                       inherits <- base::inherits
[13:24:20.410]                       invokeRestart <- base::invokeRestart
[13:24:20.410]                       is.null <- base::is.null
[13:24:20.410]                       muffled <- FALSE
[13:24:20.410]                       if (inherits(cond, "message")) {
[13:24:20.410]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.410]                         if (muffled) 
[13:24:20.410]                           invokeRestart("muffleMessage")
[13:24:20.410]                       }
[13:24:20.410]                       else if (inherits(cond, "warning")) {
[13:24:20.410]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.410]                         if (muffled) 
[13:24:20.410]                           invokeRestart("muffleWarning")
[13:24:20.410]                       }
[13:24:20.410]                       else if (inherits(cond, "condition")) {
[13:24:20.410]                         if (!is.null(pattern)) {
[13:24:20.410]                           computeRestarts <- base::computeRestarts
[13:24:20.410]                           grepl <- base::grepl
[13:24:20.410]                           restarts <- computeRestarts(cond)
[13:24:20.410]                           for (restart in restarts) {
[13:24:20.410]                             name <- restart$name
[13:24:20.410]                             if (is.null(name)) 
[13:24:20.410]                               next
[13:24:20.410]                             if (!grepl(pattern, name)) 
[13:24:20.410]                               next
[13:24:20.410]                             invokeRestart(restart)
[13:24:20.410]                             muffled <- TRUE
[13:24:20.410]                             break
[13:24:20.410]                           }
[13:24:20.410]                         }
[13:24:20.410]                       }
[13:24:20.410]                       invisible(muffled)
[13:24:20.410]                     }
[13:24:20.410]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.410]                   }
[13:24:20.410]                 }
[13:24:20.410]                 else {
[13:24:20.410]                   if (TRUE) {
[13:24:20.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.410]                     {
[13:24:20.410]                       inherits <- base::inherits
[13:24:20.410]                       invokeRestart <- base::invokeRestart
[13:24:20.410]                       is.null <- base::is.null
[13:24:20.410]                       muffled <- FALSE
[13:24:20.410]                       if (inherits(cond, "message")) {
[13:24:20.410]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.410]                         if (muffled) 
[13:24:20.410]                           invokeRestart("muffleMessage")
[13:24:20.410]                       }
[13:24:20.410]                       else if (inherits(cond, "warning")) {
[13:24:20.410]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.410]                         if (muffled) 
[13:24:20.410]                           invokeRestart("muffleWarning")
[13:24:20.410]                       }
[13:24:20.410]                       else if (inherits(cond, "condition")) {
[13:24:20.410]                         if (!is.null(pattern)) {
[13:24:20.410]                           computeRestarts <- base::computeRestarts
[13:24:20.410]                           grepl <- base::grepl
[13:24:20.410]                           restarts <- computeRestarts(cond)
[13:24:20.410]                           for (restart in restarts) {
[13:24:20.410]                             name <- restart$name
[13:24:20.410]                             if (is.null(name)) 
[13:24:20.410]                               next
[13:24:20.410]                             if (!grepl(pattern, name)) 
[13:24:20.410]                               next
[13:24:20.410]                             invokeRestart(restart)
[13:24:20.410]                             muffled <- TRUE
[13:24:20.410]                             break
[13:24:20.410]                           }
[13:24:20.410]                         }
[13:24:20.410]                       }
[13:24:20.410]                       invisible(muffled)
[13:24:20.410]                     }
[13:24:20.410]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.410]                   }
[13:24:20.410]                 }
[13:24:20.410]             }
[13:24:20.410]         }))
[13:24:20.410]     }, error = function(ex) {
[13:24:20.410]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.410]                 ...future.rng), started = ...future.startTime, 
[13:24:20.410]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.410]             version = "1.8"), class = "FutureResult")
[13:24:20.410]     }, finally = {
[13:24:20.410]         if (!identical(...future.workdir, getwd())) 
[13:24:20.410]             setwd(...future.workdir)
[13:24:20.410]         {
[13:24:20.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.410]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.410]             }
[13:24:20.410]             base::options(...future.oldOptions)
[13:24:20.410]             if (.Platform$OS.type == "windows") {
[13:24:20.410]                 old_names <- names(...future.oldEnvVars)
[13:24:20.410]                 envs <- base::Sys.getenv()
[13:24:20.410]                 names <- names(envs)
[13:24:20.410]                 common <- intersect(names, old_names)
[13:24:20.410]                 added <- setdiff(names, old_names)
[13:24:20.410]                 removed <- setdiff(old_names, names)
[13:24:20.410]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.410]                   envs[common]]
[13:24:20.410]                 NAMES <- toupper(changed)
[13:24:20.410]                 args <- list()
[13:24:20.410]                 for (kk in seq_along(NAMES)) {
[13:24:20.410]                   name <- changed[[kk]]
[13:24:20.410]                   NAME <- NAMES[[kk]]
[13:24:20.410]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.410]                     next
[13:24:20.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.410]                 }
[13:24:20.410]                 NAMES <- toupper(added)
[13:24:20.410]                 for (kk in seq_along(NAMES)) {
[13:24:20.410]                   name <- added[[kk]]
[13:24:20.410]                   NAME <- NAMES[[kk]]
[13:24:20.410]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.410]                     next
[13:24:20.410]                   args[[name]] <- ""
[13:24:20.410]                 }
[13:24:20.410]                 NAMES <- toupper(removed)
[13:24:20.410]                 for (kk in seq_along(NAMES)) {
[13:24:20.410]                   name <- removed[[kk]]
[13:24:20.410]                   NAME <- NAMES[[kk]]
[13:24:20.410]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.410]                     next
[13:24:20.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.410]                 }
[13:24:20.410]                 if (length(args) > 0) 
[13:24:20.410]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.410]             }
[13:24:20.410]             else {
[13:24:20.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.410]             }
[13:24:20.410]             {
[13:24:20.410]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.410]                   0L) {
[13:24:20.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.410]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.410]                   base::options(opts)
[13:24:20.410]                 }
[13:24:20.410]                 {
[13:24:20.410]                   {
[13:24:20.410]                     NULL
[13:24:20.410]                     RNGkind("Mersenne-Twister")
[13:24:20.410]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.410]                       inherits = FALSE)
[13:24:20.410]                   }
[13:24:20.410]                   options(future.plan = NULL)
[13:24:20.410]                   if (is.na(NA_character_)) 
[13:24:20.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.410]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.410]                   {
[13:24:20.410]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.410]                     if (!future$lazy) 
[13:24:20.410]                       future <- run(future)
[13:24:20.410]                     invisible(future)
[13:24:20.410]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.410]                 }
[13:24:20.410]             }
[13:24:20.410]         }
[13:24:20.410]     })
[13:24:20.410]     if (TRUE) {
[13:24:20.410]         base::sink(type = "output", split = FALSE)
[13:24:20.410]         if (TRUE) {
[13:24:20.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.410]         }
[13:24:20.410]         else {
[13:24:20.410]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.410]         }
[13:24:20.410]         base::close(...future.stdout)
[13:24:20.410]         ...future.stdout <- NULL
[13:24:20.410]     }
[13:24:20.410]     ...future.result$conditions <- ...future.conditions
[13:24:20.410]     ...future.result$finished <- base::Sys.time()
[13:24:20.410]     ...future.result
[13:24:20.410] }
[13:24:20.412] plan(): Setting new future strategy stack:
[13:24:20.412] List of future strategies:
[13:24:20.412] 1. sequential:
[13:24:20.412]    - args: function (..., envir = parent.frame())
[13:24:20.412]    - tweaked: FALSE
[13:24:20.412]    - call: NULL
[13:24:20.412] plan(): nbrOfWorkers() = 1
[13:24:20.414] plan(): Setting new future strategy stack:
[13:24:20.414] List of future strategies:
[13:24:20.414] 1. sequential:
[13:24:20.414]    - args: function (..., envir = parent.frame())
[13:24:20.414]    - tweaked: FALSE
[13:24:20.414]    - call: plan(strategy)
[13:24:20.414] plan(): nbrOfWorkers() = 1
[13:24:20.414] SequentialFuture started (and completed)
[13:24:20.415] - Launch lazy future ... done
[13:24:20.415] run() for ‘SequentialFuture’ ... done
[13:24:20.415] getGlobalsAndPackages() ...
[13:24:20.415] Searching for globals...
[13:24:20.415] 
[13:24:20.416] Searching for globals ... DONE
[13:24:20.416] - globals: [0] <none>
[13:24:20.416] getGlobalsAndPackages() ... DONE
[13:24:20.416] run() for ‘Future’ ...
[13:24:20.416] - state: ‘created’
[13:24:20.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.417] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.417] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.417]   - Field: ‘label’
[13:24:20.417]   - Field: ‘local’
[13:24:20.417]   - Field: ‘owner’
[13:24:20.417]   - Field: ‘envir’
[13:24:20.417]   - Field: ‘packages’
[13:24:20.417]   - Field: ‘gc’
[13:24:20.417]   - Field: ‘conditions’
[13:24:20.417]   - Field: ‘expr’
[13:24:20.418]   - Field: ‘uuid’
[13:24:20.418]   - Field: ‘seed’
[13:24:20.418]   - Field: ‘version’
[13:24:20.418]   - Field: ‘result’
[13:24:20.418]   - Field: ‘asynchronous’
[13:24:20.418]   - Field: ‘calls’
[13:24:20.418]   - Field: ‘globals’
[13:24:20.418]   - Field: ‘stdout’
[13:24:20.418]   - Field: ‘earlySignal’
[13:24:20.418]   - Field: ‘lazy’
[13:24:20.418]   - Field: ‘state’
[13:24:20.419] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.419] - Launch lazy future ...
[13:24:20.419] Packages needed by the future expression (n = 0): <none>
[13:24:20.419] Packages needed by future strategies (n = 0): <none>
[13:24:20.419] {
[13:24:20.419]     {
[13:24:20.419]         {
[13:24:20.419]             ...future.startTime <- base::Sys.time()
[13:24:20.419]             {
[13:24:20.419]                 {
[13:24:20.419]                   {
[13:24:20.419]                     base::local({
[13:24:20.419]                       has_future <- base::requireNamespace("future", 
[13:24:20.419]                         quietly = TRUE)
[13:24:20.419]                       if (has_future) {
[13:24:20.419]                         ns <- base::getNamespace("future")
[13:24:20.419]                         version <- ns[[".package"]][["version"]]
[13:24:20.419]                         if (is.null(version)) 
[13:24:20.419]                           version <- utils::packageVersion("future")
[13:24:20.419]                       }
[13:24:20.419]                       else {
[13:24:20.419]                         version <- NULL
[13:24:20.419]                       }
[13:24:20.419]                       if (!has_future || version < "1.8.0") {
[13:24:20.419]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.419]                           "", base::R.version$version.string), 
[13:24:20.419]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.419]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.419]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.419]                             "release", "version")], collapse = " "), 
[13:24:20.419]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.419]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.419]                           info)
[13:24:20.419]                         info <- base::paste(info, collapse = "; ")
[13:24:20.419]                         if (!has_future) {
[13:24:20.419]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.419]                             info)
[13:24:20.419]                         }
[13:24:20.419]                         else {
[13:24:20.419]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.419]                             info, version)
[13:24:20.419]                         }
[13:24:20.419]                         base::stop(msg)
[13:24:20.419]                       }
[13:24:20.419]                     })
[13:24:20.419]                   }
[13:24:20.419]                   options(future.plan = NULL)
[13:24:20.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.419]                 }
[13:24:20.419]                 ...future.workdir <- getwd()
[13:24:20.419]             }
[13:24:20.419]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.419]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.419]         }
[13:24:20.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.419]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.419]             base::names(...future.oldOptions))
[13:24:20.419]     }
[13:24:20.419]     if (FALSE) {
[13:24:20.419]     }
[13:24:20.419]     else {
[13:24:20.419]         if (TRUE) {
[13:24:20.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.419]                 open = "w")
[13:24:20.419]         }
[13:24:20.419]         else {
[13:24:20.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.419]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.419]         }
[13:24:20.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.419]             base::sink(type = "output", split = FALSE)
[13:24:20.419]             base::close(...future.stdout)
[13:24:20.419]         }, add = TRUE)
[13:24:20.419]     }
[13:24:20.419]     ...future.frame <- base::sys.nframe()
[13:24:20.419]     ...future.conditions <- base::list()
[13:24:20.419]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.419]     if (FALSE) {
[13:24:20.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.419]     }
[13:24:20.419]     ...future.result <- base::tryCatch({
[13:24:20.419]         base::withCallingHandlers({
[13:24:20.419]             ...future.value <- base::withVisible(base::local(2))
[13:24:20.419]             future::FutureResult(value = ...future.value$value, 
[13:24:20.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.419]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.419]                     ...future.globalenv.names))
[13:24:20.419]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.419]         }, condition = base::local({
[13:24:20.419]             c <- base::c
[13:24:20.419]             inherits <- base::inherits
[13:24:20.419]             invokeRestart <- base::invokeRestart
[13:24:20.419]             length <- base::length
[13:24:20.419]             list <- base::list
[13:24:20.419]             seq.int <- base::seq.int
[13:24:20.419]             signalCondition <- base::signalCondition
[13:24:20.419]             sys.calls <- base::sys.calls
[13:24:20.419]             `[[` <- base::`[[`
[13:24:20.419]             `+` <- base::`+`
[13:24:20.419]             `<<-` <- base::`<<-`
[13:24:20.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.419]                   3L)]
[13:24:20.419]             }
[13:24:20.419]             function(cond) {
[13:24:20.419]                 is_error <- inherits(cond, "error")
[13:24:20.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.419]                   NULL)
[13:24:20.419]                 if (is_error) {
[13:24:20.419]                   sessionInformation <- function() {
[13:24:20.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.419]                       search = base::search(), system = base::Sys.info())
[13:24:20.419]                   }
[13:24:20.419]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.419]                     cond$call), session = sessionInformation(), 
[13:24:20.419]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.419]                   signalCondition(cond)
[13:24:20.419]                 }
[13:24:20.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.419]                 "immediateCondition"))) {
[13:24:20.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.419]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.419]                   if (TRUE && !signal) {
[13:24:20.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.419]                     {
[13:24:20.419]                       inherits <- base::inherits
[13:24:20.419]                       invokeRestart <- base::invokeRestart
[13:24:20.419]                       is.null <- base::is.null
[13:24:20.419]                       muffled <- FALSE
[13:24:20.419]                       if (inherits(cond, "message")) {
[13:24:20.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.419]                         if (muffled) 
[13:24:20.419]                           invokeRestart("muffleMessage")
[13:24:20.419]                       }
[13:24:20.419]                       else if (inherits(cond, "warning")) {
[13:24:20.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.419]                         if (muffled) 
[13:24:20.419]                           invokeRestart("muffleWarning")
[13:24:20.419]                       }
[13:24:20.419]                       else if (inherits(cond, "condition")) {
[13:24:20.419]                         if (!is.null(pattern)) {
[13:24:20.419]                           computeRestarts <- base::computeRestarts
[13:24:20.419]                           grepl <- base::grepl
[13:24:20.419]                           restarts <- computeRestarts(cond)
[13:24:20.419]                           for (restart in restarts) {
[13:24:20.419]                             name <- restart$name
[13:24:20.419]                             if (is.null(name)) 
[13:24:20.419]                               next
[13:24:20.419]                             if (!grepl(pattern, name)) 
[13:24:20.419]                               next
[13:24:20.419]                             invokeRestart(restart)
[13:24:20.419]                             muffled <- TRUE
[13:24:20.419]                             break
[13:24:20.419]                           }
[13:24:20.419]                         }
[13:24:20.419]                       }
[13:24:20.419]                       invisible(muffled)
[13:24:20.419]                     }
[13:24:20.419]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.419]                   }
[13:24:20.419]                 }
[13:24:20.419]                 else {
[13:24:20.419]                   if (TRUE) {
[13:24:20.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.419]                     {
[13:24:20.419]                       inherits <- base::inherits
[13:24:20.419]                       invokeRestart <- base::invokeRestart
[13:24:20.419]                       is.null <- base::is.null
[13:24:20.419]                       muffled <- FALSE
[13:24:20.419]                       if (inherits(cond, "message")) {
[13:24:20.419]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.419]                         if (muffled) 
[13:24:20.419]                           invokeRestart("muffleMessage")
[13:24:20.419]                       }
[13:24:20.419]                       else if (inherits(cond, "warning")) {
[13:24:20.419]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.419]                         if (muffled) 
[13:24:20.419]                           invokeRestart("muffleWarning")
[13:24:20.419]                       }
[13:24:20.419]                       else if (inherits(cond, "condition")) {
[13:24:20.419]                         if (!is.null(pattern)) {
[13:24:20.419]                           computeRestarts <- base::computeRestarts
[13:24:20.419]                           grepl <- base::grepl
[13:24:20.419]                           restarts <- computeRestarts(cond)
[13:24:20.419]                           for (restart in restarts) {
[13:24:20.419]                             name <- restart$name
[13:24:20.419]                             if (is.null(name)) 
[13:24:20.419]                               next
[13:24:20.419]                             if (!grepl(pattern, name)) 
[13:24:20.419]                               next
[13:24:20.419]                             invokeRestart(restart)
[13:24:20.419]                             muffled <- TRUE
[13:24:20.419]                             break
[13:24:20.419]                           }
[13:24:20.419]                         }
[13:24:20.419]                       }
[13:24:20.419]                       invisible(muffled)
[13:24:20.419]                     }
[13:24:20.419]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.419]                   }
[13:24:20.419]                 }
[13:24:20.419]             }
[13:24:20.419]         }))
[13:24:20.419]     }, error = function(ex) {
[13:24:20.419]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.419]                 ...future.rng), started = ...future.startTime, 
[13:24:20.419]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.419]             version = "1.8"), class = "FutureResult")
[13:24:20.419]     }, finally = {
[13:24:20.419]         if (!identical(...future.workdir, getwd())) 
[13:24:20.419]             setwd(...future.workdir)
[13:24:20.419]         {
[13:24:20.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.419]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.419]             }
[13:24:20.419]             base::options(...future.oldOptions)
[13:24:20.419]             if (.Platform$OS.type == "windows") {
[13:24:20.419]                 old_names <- names(...future.oldEnvVars)
[13:24:20.419]                 envs <- base::Sys.getenv()
[13:24:20.419]                 names <- names(envs)
[13:24:20.419]                 common <- intersect(names, old_names)
[13:24:20.419]                 added <- setdiff(names, old_names)
[13:24:20.419]                 removed <- setdiff(old_names, names)
[13:24:20.419]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.419]                   envs[common]]
[13:24:20.419]                 NAMES <- toupper(changed)
[13:24:20.419]                 args <- list()
[13:24:20.419]                 for (kk in seq_along(NAMES)) {
[13:24:20.419]                   name <- changed[[kk]]
[13:24:20.419]                   NAME <- NAMES[[kk]]
[13:24:20.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.419]                     next
[13:24:20.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.419]                 }
[13:24:20.419]                 NAMES <- toupper(added)
[13:24:20.419]                 for (kk in seq_along(NAMES)) {
[13:24:20.419]                   name <- added[[kk]]
[13:24:20.419]                   NAME <- NAMES[[kk]]
[13:24:20.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.419]                     next
[13:24:20.419]                   args[[name]] <- ""
[13:24:20.419]                 }
[13:24:20.419]                 NAMES <- toupper(removed)
[13:24:20.419]                 for (kk in seq_along(NAMES)) {
[13:24:20.419]                   name <- removed[[kk]]
[13:24:20.419]                   NAME <- NAMES[[kk]]
[13:24:20.419]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.419]                     next
[13:24:20.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.419]                 }
[13:24:20.419]                 if (length(args) > 0) 
[13:24:20.419]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.419]             }
[13:24:20.419]             else {
[13:24:20.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.419]             }
[13:24:20.419]             {
[13:24:20.419]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.419]                   0L) {
[13:24:20.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.419]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.419]                   base::options(opts)
[13:24:20.419]                 }
[13:24:20.419]                 {
[13:24:20.419]                   {
[13:24:20.419]                     NULL
[13:24:20.419]                     RNGkind("Mersenne-Twister")
[13:24:20.419]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.419]                       inherits = FALSE)
[13:24:20.419]                   }
[13:24:20.419]                   options(future.plan = NULL)
[13:24:20.419]                   if (is.na(NA_character_)) 
[13:24:20.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.419]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.419]                   {
[13:24:20.419]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.419]                     if (!future$lazy) 
[13:24:20.419]                       future <- run(future)
[13:24:20.419]                     invisible(future)
[13:24:20.419]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.419]                 }
[13:24:20.419]             }
[13:24:20.419]         }
[13:24:20.419]     })
[13:24:20.419]     if (TRUE) {
[13:24:20.419]         base::sink(type = "output", split = FALSE)
[13:24:20.419]         if (TRUE) {
[13:24:20.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.419]         }
[13:24:20.419]         else {
[13:24:20.419]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.419]         }
[13:24:20.419]         base::close(...future.stdout)
[13:24:20.419]         ...future.stdout <- NULL
[13:24:20.419]     }
[13:24:20.419]     ...future.result$conditions <- ...future.conditions
[13:24:20.419]     ...future.result$finished <- base::Sys.time()
[13:24:20.419]     ...future.result
[13:24:20.419] }
[13:24:20.421] plan(): Setting new future strategy stack:
[13:24:20.421] List of future strategies:
[13:24:20.421] 1. sequential:
[13:24:20.421]    - args: function (..., envir = parent.frame())
[13:24:20.421]    - tweaked: FALSE
[13:24:20.421]    - call: NULL
[13:24:20.422] plan(): nbrOfWorkers() = 1
[13:24:20.422] plan(): Setting new future strategy stack:
[13:24:20.422] List of future strategies:
[13:24:20.422] 1. sequential:
[13:24:20.422]    - args: function (..., envir = parent.frame())
[13:24:20.422]    - tweaked: FALSE
[13:24:20.422]    - call: plan(strategy)
[13:24:20.423] plan(): nbrOfWorkers() = 1
[13:24:20.423] SequentialFuture started (and completed)
[13:24:20.423] - Launch lazy future ... done
[13:24:20.423] run() for ‘SequentialFuture’ ... done
[13:24:20.423] resolve() on list ...
[13:24:20.423]  recursive: 0
[13:24:20.424]  length: 3
[13:24:20.424]  elements: ‘a’, ‘b’, ‘’
[13:24:20.424] resolved() for ‘SequentialFuture’ ...
[13:24:20.424] - state: ‘finished’
[13:24:20.424] - run: TRUE
[13:24:20.424] - result: ‘FutureResult’
[13:24:20.424] resolved() for ‘SequentialFuture’ ... done
[13:24:20.424] Future #1
[13:24:20.425]  length: 2 (resolved future 1)
[13:24:20.425] resolved() for ‘SequentialFuture’ ...
[13:24:20.425] - state: ‘finished’
[13:24:20.425] - run: TRUE
[13:24:20.425] - result: ‘FutureResult’
[13:24:20.425] resolved() for ‘SequentialFuture’ ... done
[13:24:20.425] Future #2
[13:24:20.425]  length: 1 (resolved future 2)
[13:24:20.425]  length: 0 (resolved future 3)
[13:24:20.426] resolve() on list ... DONE
[13:24:20.426] resolved() for ‘SequentialFuture’ ...
[13:24:20.426] - state: ‘finished’
[13:24:20.426] - run: TRUE
[13:24:20.426] - result: ‘FutureResult’
[13:24:20.426] resolved() for ‘SequentialFuture’ ... done
[13:24:20.426] resolved() for ‘SequentialFuture’ ...
[13:24:20.426] - state: ‘finished’
[13:24:20.426] - run: TRUE
[13:24:20.426] - result: ‘FutureResult’
[13:24:20.426] resolved() for ‘SequentialFuture’ ... done
[13:24:20.427] getGlobalsAndPackages() ...
[13:24:20.427] Searching for globals...
[13:24:20.429] 
[13:24:20.429] Searching for globals ... DONE
[13:24:20.429] - globals: [0] <none>
[13:24:20.429] getGlobalsAndPackages() ... DONE
[13:24:20.430] getGlobalsAndPackages() ...
[13:24:20.430] Searching for globals...
[13:24:20.430] 
[13:24:20.430] Searching for globals ... DONE
[13:24:20.430] - globals: [0] <none>
[13:24:20.430] getGlobalsAndPackages() ... DONE
[13:24:20.431] run() for ‘Future’ ...
[13:24:20.431] - state: ‘created’
[13:24:20.431] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.431] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.431] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.431]   - Field: ‘label’
[13:24:20.431]   - Field: ‘local’
[13:24:20.432]   - Field: ‘owner’
[13:24:20.432]   - Field: ‘envir’
[13:24:20.432]   - Field: ‘packages’
[13:24:20.432]   - Field: ‘gc’
[13:24:20.432]   - Field: ‘conditions’
[13:24:20.432]   - Field: ‘expr’
[13:24:20.432]   - Field: ‘uuid’
[13:24:20.432]   - Field: ‘seed’
[13:24:20.432]   - Field: ‘version’
[13:24:20.432]   - Field: ‘result’
[13:24:20.433]   - Field: ‘asynchronous’
[13:24:20.433]   - Field: ‘calls’
[13:24:20.433]   - Field: ‘globals’
[13:24:20.433]   - Field: ‘stdout’
[13:24:20.433]   - Field: ‘earlySignal’
[13:24:20.433]   - Field: ‘lazy’
[13:24:20.433]   - Field: ‘state’
[13:24:20.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.433] - Launch lazy future ...
[13:24:20.433] Packages needed by the future expression (n = 0): <none>
[13:24:20.434] Packages needed by future strategies (n = 0): <none>
[13:24:20.434] {
[13:24:20.434]     {
[13:24:20.434]         {
[13:24:20.434]             ...future.startTime <- base::Sys.time()
[13:24:20.434]             {
[13:24:20.434]                 {
[13:24:20.434]                   {
[13:24:20.434]                     base::local({
[13:24:20.434]                       has_future <- base::requireNamespace("future", 
[13:24:20.434]                         quietly = TRUE)
[13:24:20.434]                       if (has_future) {
[13:24:20.434]                         ns <- base::getNamespace("future")
[13:24:20.434]                         version <- ns[[".package"]][["version"]]
[13:24:20.434]                         if (is.null(version)) 
[13:24:20.434]                           version <- utils::packageVersion("future")
[13:24:20.434]                       }
[13:24:20.434]                       else {
[13:24:20.434]                         version <- NULL
[13:24:20.434]                       }
[13:24:20.434]                       if (!has_future || version < "1.8.0") {
[13:24:20.434]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.434]                           "", base::R.version$version.string), 
[13:24:20.434]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.434]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.434]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.434]                             "release", "version")], collapse = " "), 
[13:24:20.434]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.434]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.434]                           info)
[13:24:20.434]                         info <- base::paste(info, collapse = "; ")
[13:24:20.434]                         if (!has_future) {
[13:24:20.434]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.434]                             info)
[13:24:20.434]                         }
[13:24:20.434]                         else {
[13:24:20.434]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.434]                             info, version)
[13:24:20.434]                         }
[13:24:20.434]                         base::stop(msg)
[13:24:20.434]                       }
[13:24:20.434]                     })
[13:24:20.434]                   }
[13:24:20.434]                   options(future.plan = NULL)
[13:24:20.434]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.434]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.434]                 }
[13:24:20.434]                 ...future.workdir <- getwd()
[13:24:20.434]             }
[13:24:20.434]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.434]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.434]         }
[13:24:20.434]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.434]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.434]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.434]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.434]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.434]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.434]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.434]             base::names(...future.oldOptions))
[13:24:20.434]     }
[13:24:20.434]     if (FALSE) {
[13:24:20.434]     }
[13:24:20.434]     else {
[13:24:20.434]         if (TRUE) {
[13:24:20.434]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.434]                 open = "w")
[13:24:20.434]         }
[13:24:20.434]         else {
[13:24:20.434]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.434]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.434]         }
[13:24:20.434]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.434]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.434]             base::sink(type = "output", split = FALSE)
[13:24:20.434]             base::close(...future.stdout)
[13:24:20.434]         }, add = TRUE)
[13:24:20.434]     }
[13:24:20.434]     ...future.frame <- base::sys.nframe()
[13:24:20.434]     ...future.conditions <- base::list()
[13:24:20.434]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.434]     if (FALSE) {
[13:24:20.434]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.434]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.434]     }
[13:24:20.434]     ...future.result <- base::tryCatch({
[13:24:20.434]         base::withCallingHandlers({
[13:24:20.434]             ...future.value <- base::withVisible(base::local(2))
[13:24:20.434]             future::FutureResult(value = ...future.value$value, 
[13:24:20.434]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.434]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.434]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.434]                     ...future.globalenv.names))
[13:24:20.434]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.434]         }, condition = base::local({
[13:24:20.434]             c <- base::c
[13:24:20.434]             inherits <- base::inherits
[13:24:20.434]             invokeRestart <- base::invokeRestart
[13:24:20.434]             length <- base::length
[13:24:20.434]             list <- base::list
[13:24:20.434]             seq.int <- base::seq.int
[13:24:20.434]             signalCondition <- base::signalCondition
[13:24:20.434]             sys.calls <- base::sys.calls
[13:24:20.434]             `[[` <- base::`[[`
[13:24:20.434]             `+` <- base::`+`
[13:24:20.434]             `<<-` <- base::`<<-`
[13:24:20.434]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.434]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.434]                   3L)]
[13:24:20.434]             }
[13:24:20.434]             function(cond) {
[13:24:20.434]                 is_error <- inherits(cond, "error")
[13:24:20.434]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.434]                   NULL)
[13:24:20.434]                 if (is_error) {
[13:24:20.434]                   sessionInformation <- function() {
[13:24:20.434]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.434]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.434]                       search = base::search(), system = base::Sys.info())
[13:24:20.434]                   }
[13:24:20.434]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.434]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.434]                     cond$call), session = sessionInformation(), 
[13:24:20.434]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.434]                   signalCondition(cond)
[13:24:20.434]                 }
[13:24:20.434]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.434]                 "immediateCondition"))) {
[13:24:20.434]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.434]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.434]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.434]                   if (TRUE && !signal) {
[13:24:20.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.434]                     {
[13:24:20.434]                       inherits <- base::inherits
[13:24:20.434]                       invokeRestart <- base::invokeRestart
[13:24:20.434]                       is.null <- base::is.null
[13:24:20.434]                       muffled <- FALSE
[13:24:20.434]                       if (inherits(cond, "message")) {
[13:24:20.434]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.434]                         if (muffled) 
[13:24:20.434]                           invokeRestart("muffleMessage")
[13:24:20.434]                       }
[13:24:20.434]                       else if (inherits(cond, "warning")) {
[13:24:20.434]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.434]                         if (muffled) 
[13:24:20.434]                           invokeRestart("muffleWarning")
[13:24:20.434]                       }
[13:24:20.434]                       else if (inherits(cond, "condition")) {
[13:24:20.434]                         if (!is.null(pattern)) {
[13:24:20.434]                           computeRestarts <- base::computeRestarts
[13:24:20.434]                           grepl <- base::grepl
[13:24:20.434]                           restarts <- computeRestarts(cond)
[13:24:20.434]                           for (restart in restarts) {
[13:24:20.434]                             name <- restart$name
[13:24:20.434]                             if (is.null(name)) 
[13:24:20.434]                               next
[13:24:20.434]                             if (!grepl(pattern, name)) 
[13:24:20.434]                               next
[13:24:20.434]                             invokeRestart(restart)
[13:24:20.434]                             muffled <- TRUE
[13:24:20.434]                             break
[13:24:20.434]                           }
[13:24:20.434]                         }
[13:24:20.434]                       }
[13:24:20.434]                       invisible(muffled)
[13:24:20.434]                     }
[13:24:20.434]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.434]                   }
[13:24:20.434]                 }
[13:24:20.434]                 else {
[13:24:20.434]                   if (TRUE) {
[13:24:20.434]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.434]                     {
[13:24:20.434]                       inherits <- base::inherits
[13:24:20.434]                       invokeRestart <- base::invokeRestart
[13:24:20.434]                       is.null <- base::is.null
[13:24:20.434]                       muffled <- FALSE
[13:24:20.434]                       if (inherits(cond, "message")) {
[13:24:20.434]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.434]                         if (muffled) 
[13:24:20.434]                           invokeRestart("muffleMessage")
[13:24:20.434]                       }
[13:24:20.434]                       else if (inherits(cond, "warning")) {
[13:24:20.434]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.434]                         if (muffled) 
[13:24:20.434]                           invokeRestart("muffleWarning")
[13:24:20.434]                       }
[13:24:20.434]                       else if (inherits(cond, "condition")) {
[13:24:20.434]                         if (!is.null(pattern)) {
[13:24:20.434]                           computeRestarts <- base::computeRestarts
[13:24:20.434]                           grepl <- base::grepl
[13:24:20.434]                           restarts <- computeRestarts(cond)
[13:24:20.434]                           for (restart in restarts) {
[13:24:20.434]                             name <- restart$name
[13:24:20.434]                             if (is.null(name)) 
[13:24:20.434]                               next
[13:24:20.434]                             if (!grepl(pattern, name)) 
[13:24:20.434]                               next
[13:24:20.434]                             invokeRestart(restart)
[13:24:20.434]                             muffled <- TRUE
[13:24:20.434]                             break
[13:24:20.434]                           }
[13:24:20.434]                         }
[13:24:20.434]                       }
[13:24:20.434]                       invisible(muffled)
[13:24:20.434]                     }
[13:24:20.434]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.434]                   }
[13:24:20.434]                 }
[13:24:20.434]             }
[13:24:20.434]         }))
[13:24:20.434]     }, error = function(ex) {
[13:24:20.434]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.434]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.434]                 ...future.rng), started = ...future.startTime, 
[13:24:20.434]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.434]             version = "1.8"), class = "FutureResult")
[13:24:20.434]     }, finally = {
[13:24:20.434]         if (!identical(...future.workdir, getwd())) 
[13:24:20.434]             setwd(...future.workdir)
[13:24:20.434]         {
[13:24:20.434]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.434]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.434]             }
[13:24:20.434]             base::options(...future.oldOptions)
[13:24:20.434]             if (.Platform$OS.type == "windows") {
[13:24:20.434]                 old_names <- names(...future.oldEnvVars)
[13:24:20.434]                 envs <- base::Sys.getenv()
[13:24:20.434]                 names <- names(envs)
[13:24:20.434]                 common <- intersect(names, old_names)
[13:24:20.434]                 added <- setdiff(names, old_names)
[13:24:20.434]                 removed <- setdiff(old_names, names)
[13:24:20.434]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.434]                   envs[common]]
[13:24:20.434]                 NAMES <- toupper(changed)
[13:24:20.434]                 args <- list()
[13:24:20.434]                 for (kk in seq_along(NAMES)) {
[13:24:20.434]                   name <- changed[[kk]]
[13:24:20.434]                   NAME <- NAMES[[kk]]
[13:24:20.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.434]                     next
[13:24:20.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.434]                 }
[13:24:20.434]                 NAMES <- toupper(added)
[13:24:20.434]                 for (kk in seq_along(NAMES)) {
[13:24:20.434]                   name <- added[[kk]]
[13:24:20.434]                   NAME <- NAMES[[kk]]
[13:24:20.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.434]                     next
[13:24:20.434]                   args[[name]] <- ""
[13:24:20.434]                 }
[13:24:20.434]                 NAMES <- toupper(removed)
[13:24:20.434]                 for (kk in seq_along(NAMES)) {
[13:24:20.434]                   name <- removed[[kk]]
[13:24:20.434]                   NAME <- NAMES[[kk]]
[13:24:20.434]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.434]                     next
[13:24:20.434]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.434]                 }
[13:24:20.434]                 if (length(args) > 0) 
[13:24:20.434]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.434]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.434]             }
[13:24:20.434]             else {
[13:24:20.434]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.434]             }
[13:24:20.434]             {
[13:24:20.434]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.434]                   0L) {
[13:24:20.434]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.434]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.434]                   base::options(opts)
[13:24:20.434]                 }
[13:24:20.434]                 {
[13:24:20.434]                   {
[13:24:20.434]                     NULL
[13:24:20.434]                     RNGkind("Mersenne-Twister")
[13:24:20.434]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.434]                       inherits = FALSE)
[13:24:20.434]                   }
[13:24:20.434]                   options(future.plan = NULL)
[13:24:20.434]                   if (is.na(NA_character_)) 
[13:24:20.434]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.434]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.434]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.434]                   {
[13:24:20.434]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.434]                     if (!future$lazy) 
[13:24:20.434]                       future <- run(future)
[13:24:20.434]                     invisible(future)
[13:24:20.434]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.434]                 }
[13:24:20.434]             }
[13:24:20.434]         }
[13:24:20.434]     })
[13:24:20.434]     if (TRUE) {
[13:24:20.434]         base::sink(type = "output", split = FALSE)
[13:24:20.434]         if (TRUE) {
[13:24:20.434]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.434]         }
[13:24:20.434]         else {
[13:24:20.434]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.434]         }
[13:24:20.434]         base::close(...future.stdout)
[13:24:20.434]         ...future.stdout <- NULL
[13:24:20.434]     }
[13:24:20.434]     ...future.result$conditions <- ...future.conditions
[13:24:20.434]     ...future.result$finished <- base::Sys.time()
[13:24:20.434]     ...future.result
[13:24:20.434] }
[13:24:20.436] plan(): Setting new future strategy stack:
[13:24:20.436] List of future strategies:
[13:24:20.436] 1. sequential:
[13:24:20.436]    - args: function (..., envir = parent.frame())
[13:24:20.436]    - tweaked: FALSE
[13:24:20.436]    - call: NULL
[13:24:20.436] plan(): nbrOfWorkers() = 1
[13:24:20.437] plan(): Setting new future strategy stack:
[13:24:20.437] List of future strategies:
[13:24:20.437] 1. sequential:
[13:24:20.437]    - args: function (..., envir = parent.frame())
[13:24:20.437]    - tweaked: FALSE
[13:24:20.437]    - call: plan(strategy)
[13:24:20.437] plan(): nbrOfWorkers() = 1
[13:24:20.438] SequentialFuture started (and completed)
[13:24:20.438] - Launch lazy future ... done
[13:24:20.438] run() for ‘SequentialFuture’ ... done
[13:24:20.438] resolve() on list ...
[13:24:20.438]  recursive: 0
[13:24:20.438]  length: 3
[13:24:20.438]  elements: ‘a’, ‘b’, ‘’
[13:24:20.438] run() for ‘Future’ ...
[13:24:20.438] - state: ‘created’
[13:24:20.439] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.439] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.439]   - Field: ‘label’
[13:24:20.439]   - Field: ‘local’
[13:24:20.439]   - Field: ‘owner’
[13:24:20.439]   - Field: ‘envir’
[13:24:20.439]   - Field: ‘packages’
[13:24:20.439]   - Field: ‘gc’
[13:24:20.440]   - Field: ‘conditions’
[13:24:20.440]   - Field: ‘expr’
[13:24:20.440]   - Field: ‘uuid’
[13:24:20.440]   - Field: ‘seed’
[13:24:20.440]   - Field: ‘version’
[13:24:20.440]   - Field: ‘result’
[13:24:20.440]   - Field: ‘asynchronous’
[13:24:20.440]   - Field: ‘calls’
[13:24:20.440]   - Field: ‘globals’
[13:24:20.440]   - Field: ‘stdout’
[13:24:20.441]   - Field: ‘earlySignal’
[13:24:20.441]   - Field: ‘lazy’
[13:24:20.441]   - Field: ‘state’
[13:24:20.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.441] - Launch lazy future ...
[13:24:20.441] Packages needed by the future expression (n = 0): <none>
[13:24:20.441] Packages needed by future strategies (n = 0): <none>
[13:24:20.442] {
[13:24:20.442]     {
[13:24:20.442]         {
[13:24:20.442]             ...future.startTime <- base::Sys.time()
[13:24:20.442]             {
[13:24:20.442]                 {
[13:24:20.442]                   {
[13:24:20.442]                     base::local({
[13:24:20.442]                       has_future <- base::requireNamespace("future", 
[13:24:20.442]                         quietly = TRUE)
[13:24:20.442]                       if (has_future) {
[13:24:20.442]                         ns <- base::getNamespace("future")
[13:24:20.442]                         version <- ns[[".package"]][["version"]]
[13:24:20.442]                         if (is.null(version)) 
[13:24:20.442]                           version <- utils::packageVersion("future")
[13:24:20.442]                       }
[13:24:20.442]                       else {
[13:24:20.442]                         version <- NULL
[13:24:20.442]                       }
[13:24:20.442]                       if (!has_future || version < "1.8.0") {
[13:24:20.442]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.442]                           "", base::R.version$version.string), 
[13:24:20.442]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.442]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.442]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.442]                             "release", "version")], collapse = " "), 
[13:24:20.442]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.442]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.442]                           info)
[13:24:20.442]                         info <- base::paste(info, collapse = "; ")
[13:24:20.442]                         if (!has_future) {
[13:24:20.442]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.442]                             info)
[13:24:20.442]                         }
[13:24:20.442]                         else {
[13:24:20.442]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.442]                             info, version)
[13:24:20.442]                         }
[13:24:20.442]                         base::stop(msg)
[13:24:20.442]                       }
[13:24:20.442]                     })
[13:24:20.442]                   }
[13:24:20.442]                   options(future.plan = NULL)
[13:24:20.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.442]                 }
[13:24:20.442]                 ...future.workdir <- getwd()
[13:24:20.442]             }
[13:24:20.442]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.442]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.442]         }
[13:24:20.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.442]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.442]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.442]             base::names(...future.oldOptions))
[13:24:20.442]     }
[13:24:20.442]     if (FALSE) {
[13:24:20.442]     }
[13:24:20.442]     else {
[13:24:20.442]         if (TRUE) {
[13:24:20.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.442]                 open = "w")
[13:24:20.442]         }
[13:24:20.442]         else {
[13:24:20.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.442]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.442]         }
[13:24:20.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.442]             base::sink(type = "output", split = FALSE)
[13:24:20.442]             base::close(...future.stdout)
[13:24:20.442]         }, add = TRUE)
[13:24:20.442]     }
[13:24:20.442]     ...future.frame <- base::sys.nframe()
[13:24:20.442]     ...future.conditions <- base::list()
[13:24:20.442]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.442]     if (FALSE) {
[13:24:20.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.442]     }
[13:24:20.442]     ...future.result <- base::tryCatch({
[13:24:20.442]         base::withCallingHandlers({
[13:24:20.442]             ...future.value <- base::withVisible(base::local(1))
[13:24:20.442]             future::FutureResult(value = ...future.value$value, 
[13:24:20.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.442]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.442]                     ...future.globalenv.names))
[13:24:20.442]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.442]         }, condition = base::local({
[13:24:20.442]             c <- base::c
[13:24:20.442]             inherits <- base::inherits
[13:24:20.442]             invokeRestart <- base::invokeRestart
[13:24:20.442]             length <- base::length
[13:24:20.442]             list <- base::list
[13:24:20.442]             seq.int <- base::seq.int
[13:24:20.442]             signalCondition <- base::signalCondition
[13:24:20.442]             sys.calls <- base::sys.calls
[13:24:20.442]             `[[` <- base::`[[`
[13:24:20.442]             `+` <- base::`+`
[13:24:20.442]             `<<-` <- base::`<<-`
[13:24:20.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.442]                   3L)]
[13:24:20.442]             }
[13:24:20.442]             function(cond) {
[13:24:20.442]                 is_error <- inherits(cond, "error")
[13:24:20.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.442]                   NULL)
[13:24:20.442]                 if (is_error) {
[13:24:20.442]                   sessionInformation <- function() {
[13:24:20.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.442]                       search = base::search(), system = base::Sys.info())
[13:24:20.442]                   }
[13:24:20.442]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.442]                     cond$call), session = sessionInformation(), 
[13:24:20.442]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.442]                   signalCondition(cond)
[13:24:20.442]                 }
[13:24:20.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.442]                 "immediateCondition"))) {
[13:24:20.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.442]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.442]                   if (TRUE && !signal) {
[13:24:20.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.442]                     {
[13:24:20.442]                       inherits <- base::inherits
[13:24:20.442]                       invokeRestart <- base::invokeRestart
[13:24:20.442]                       is.null <- base::is.null
[13:24:20.442]                       muffled <- FALSE
[13:24:20.442]                       if (inherits(cond, "message")) {
[13:24:20.442]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.442]                         if (muffled) 
[13:24:20.442]                           invokeRestart("muffleMessage")
[13:24:20.442]                       }
[13:24:20.442]                       else if (inherits(cond, "warning")) {
[13:24:20.442]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.442]                         if (muffled) 
[13:24:20.442]                           invokeRestart("muffleWarning")
[13:24:20.442]                       }
[13:24:20.442]                       else if (inherits(cond, "condition")) {
[13:24:20.442]                         if (!is.null(pattern)) {
[13:24:20.442]                           computeRestarts <- base::computeRestarts
[13:24:20.442]                           grepl <- base::grepl
[13:24:20.442]                           restarts <- computeRestarts(cond)
[13:24:20.442]                           for (restart in restarts) {
[13:24:20.442]                             name <- restart$name
[13:24:20.442]                             if (is.null(name)) 
[13:24:20.442]                               next
[13:24:20.442]                             if (!grepl(pattern, name)) 
[13:24:20.442]                               next
[13:24:20.442]                             invokeRestart(restart)
[13:24:20.442]                             muffled <- TRUE
[13:24:20.442]                             break
[13:24:20.442]                           }
[13:24:20.442]                         }
[13:24:20.442]                       }
[13:24:20.442]                       invisible(muffled)
[13:24:20.442]                     }
[13:24:20.442]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.442]                   }
[13:24:20.442]                 }
[13:24:20.442]                 else {
[13:24:20.442]                   if (TRUE) {
[13:24:20.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.442]                     {
[13:24:20.442]                       inherits <- base::inherits
[13:24:20.442]                       invokeRestart <- base::invokeRestart
[13:24:20.442]                       is.null <- base::is.null
[13:24:20.442]                       muffled <- FALSE
[13:24:20.442]                       if (inherits(cond, "message")) {
[13:24:20.442]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.442]                         if (muffled) 
[13:24:20.442]                           invokeRestart("muffleMessage")
[13:24:20.442]                       }
[13:24:20.442]                       else if (inherits(cond, "warning")) {
[13:24:20.442]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.442]                         if (muffled) 
[13:24:20.442]                           invokeRestart("muffleWarning")
[13:24:20.442]                       }
[13:24:20.442]                       else if (inherits(cond, "condition")) {
[13:24:20.442]                         if (!is.null(pattern)) {
[13:24:20.442]                           computeRestarts <- base::computeRestarts
[13:24:20.442]                           grepl <- base::grepl
[13:24:20.442]                           restarts <- computeRestarts(cond)
[13:24:20.442]                           for (restart in restarts) {
[13:24:20.442]                             name <- restart$name
[13:24:20.442]                             if (is.null(name)) 
[13:24:20.442]                               next
[13:24:20.442]                             if (!grepl(pattern, name)) 
[13:24:20.442]                               next
[13:24:20.442]                             invokeRestart(restart)
[13:24:20.442]                             muffled <- TRUE
[13:24:20.442]                             break
[13:24:20.442]                           }
[13:24:20.442]                         }
[13:24:20.442]                       }
[13:24:20.442]                       invisible(muffled)
[13:24:20.442]                     }
[13:24:20.442]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.442]                   }
[13:24:20.442]                 }
[13:24:20.442]             }
[13:24:20.442]         }))
[13:24:20.442]     }, error = function(ex) {
[13:24:20.442]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.442]                 ...future.rng), started = ...future.startTime, 
[13:24:20.442]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.442]             version = "1.8"), class = "FutureResult")
[13:24:20.442]     }, finally = {
[13:24:20.442]         if (!identical(...future.workdir, getwd())) 
[13:24:20.442]             setwd(...future.workdir)
[13:24:20.442]         {
[13:24:20.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.442]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.442]             }
[13:24:20.442]             base::options(...future.oldOptions)
[13:24:20.442]             if (.Platform$OS.type == "windows") {
[13:24:20.442]                 old_names <- names(...future.oldEnvVars)
[13:24:20.442]                 envs <- base::Sys.getenv()
[13:24:20.442]                 names <- names(envs)
[13:24:20.442]                 common <- intersect(names, old_names)
[13:24:20.442]                 added <- setdiff(names, old_names)
[13:24:20.442]                 removed <- setdiff(old_names, names)
[13:24:20.442]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.442]                   envs[common]]
[13:24:20.442]                 NAMES <- toupper(changed)
[13:24:20.442]                 args <- list()
[13:24:20.442]                 for (kk in seq_along(NAMES)) {
[13:24:20.442]                   name <- changed[[kk]]
[13:24:20.442]                   NAME <- NAMES[[kk]]
[13:24:20.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.442]                     next
[13:24:20.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.442]                 }
[13:24:20.442]                 NAMES <- toupper(added)
[13:24:20.442]                 for (kk in seq_along(NAMES)) {
[13:24:20.442]                   name <- added[[kk]]
[13:24:20.442]                   NAME <- NAMES[[kk]]
[13:24:20.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.442]                     next
[13:24:20.442]                   args[[name]] <- ""
[13:24:20.442]                 }
[13:24:20.442]                 NAMES <- toupper(removed)
[13:24:20.442]                 for (kk in seq_along(NAMES)) {
[13:24:20.442]                   name <- removed[[kk]]
[13:24:20.442]                   NAME <- NAMES[[kk]]
[13:24:20.442]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.442]                     next
[13:24:20.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.442]                 }
[13:24:20.442]                 if (length(args) > 0) 
[13:24:20.442]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.442]             }
[13:24:20.442]             else {
[13:24:20.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.442]             }
[13:24:20.442]             {
[13:24:20.442]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.442]                   0L) {
[13:24:20.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.442]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.442]                   base::options(opts)
[13:24:20.442]                 }
[13:24:20.442]                 {
[13:24:20.442]                   {
[13:24:20.442]                     NULL
[13:24:20.442]                     RNGkind("Mersenne-Twister")
[13:24:20.442]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.442]                       inherits = FALSE)
[13:24:20.442]                   }
[13:24:20.442]                   options(future.plan = NULL)
[13:24:20.442]                   if (is.na(NA_character_)) 
[13:24:20.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.442]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.442]                   {
[13:24:20.442]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.442]                     if (!future$lazy) 
[13:24:20.442]                       future <- run(future)
[13:24:20.442]                     invisible(future)
[13:24:20.442]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.442]                 }
[13:24:20.442]             }
[13:24:20.442]         }
[13:24:20.442]     })
[13:24:20.442]     if (TRUE) {
[13:24:20.442]         base::sink(type = "output", split = FALSE)
[13:24:20.442]         if (TRUE) {
[13:24:20.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.442]         }
[13:24:20.442]         else {
[13:24:20.442]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.442]         }
[13:24:20.442]         base::close(...future.stdout)
[13:24:20.442]         ...future.stdout <- NULL
[13:24:20.442]     }
[13:24:20.442]     ...future.result$conditions <- ...future.conditions
[13:24:20.442]     ...future.result$finished <- base::Sys.time()
[13:24:20.442]     ...future.result
[13:24:20.442] }
[13:24:20.443] plan(): Setting new future strategy stack:
[13:24:20.443] List of future strategies:
[13:24:20.443] 1. sequential:
[13:24:20.443]    - args: function (..., envir = parent.frame())
[13:24:20.443]    - tweaked: FALSE
[13:24:20.443]    - call: NULL
[13:24:20.444] plan(): nbrOfWorkers() = 1
[13:24:20.444] plan(): Setting new future strategy stack:
[13:24:20.445] List of future strategies:
[13:24:20.445] 1. sequential:
[13:24:20.445]    - args: function (..., envir = parent.frame())
[13:24:20.445]    - tweaked: FALSE
[13:24:20.445]    - call: plan(strategy)
[13:24:20.445] plan(): nbrOfWorkers() = 1
[13:24:20.445] SequentialFuture started (and completed)
[13:24:20.445] - Launch lazy future ... done
[13:24:20.445] run() for ‘SequentialFuture’ ... done
[13:24:20.445] resolved() for ‘SequentialFuture’ ...
[13:24:20.446] - state: ‘finished’
[13:24:20.446] - run: TRUE
[13:24:20.446] - result: ‘FutureResult’
[13:24:20.446] resolved() for ‘SequentialFuture’ ... done
[13:24:20.446] Future #1
[13:24:20.446]  length: 2 (resolved future 1)
[13:24:20.446] resolved() for ‘SequentialFuture’ ...
[13:24:20.446] - state: ‘finished’
[13:24:20.446] - run: TRUE
[13:24:20.446] - result: ‘FutureResult’
[13:24:20.446] resolved() for ‘SequentialFuture’ ... done
[13:24:20.447] Future #2
[13:24:20.447]  length: 1 (resolved future 2)
[13:24:20.447]  length: 0 (resolved future 3)
[13:24:20.447] resolve() on list ... DONE
[13:24:20.447] resolved() for ‘SequentialFuture’ ...
[13:24:20.447] - state: ‘finished’
[13:24:20.447] - run: TRUE
[13:24:20.447] - result: ‘FutureResult’
[13:24:20.447] resolved() for ‘SequentialFuture’ ... done
[13:24:20.447] resolved() for ‘SequentialFuture’ ...
[13:24:20.448] - state: ‘finished’
[13:24:20.448] - run: TRUE
[13:24:20.448] - result: ‘FutureResult’
[13:24:20.448] resolved() for ‘SequentialFuture’ ... done
[13:24:20.448] getGlobalsAndPackages() ...
[13:24:20.448] Searching for globals...
[13:24:20.448] 
[13:24:20.448] Searching for globals ... DONE
[13:24:20.449] - globals: [0] <none>
[13:24:20.449] getGlobalsAndPackages() ... DONE
[13:24:20.449] getGlobalsAndPackages() ...
[13:24:20.449] Searching for globals...
[13:24:20.449] 
[13:24:20.449] Searching for globals ... DONE
[13:24:20.449] - globals: [0] <none>
[13:24:20.449] getGlobalsAndPackages() ... DONE
[13:24:20.450] resolve() on list ...
[13:24:20.450]  recursive: 0
[13:24:20.450]  length: 3
[13:24:20.450]  elements: ‘a’, ‘b’, ‘’
[13:24:20.450] run() for ‘Future’ ...
[13:24:20.450] - state: ‘created’
[13:24:20.450] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.451] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.451]   - Field: ‘label’
[13:24:20.451]   - Field: ‘local’
[13:24:20.451]   - Field: ‘owner’
[13:24:20.451]   - Field: ‘envir’
[13:24:20.451]   - Field: ‘packages’
[13:24:20.451]   - Field: ‘gc’
[13:24:20.451]   - Field: ‘conditions’
[13:24:20.451]   - Field: ‘expr’
[13:24:20.452]   - Field: ‘uuid’
[13:24:20.452]   - Field: ‘seed’
[13:24:20.452]   - Field: ‘version’
[13:24:20.452]   - Field: ‘result’
[13:24:20.452]   - Field: ‘asynchronous’
[13:24:20.452]   - Field: ‘calls’
[13:24:20.452]   - Field: ‘globals’
[13:24:20.452]   - Field: ‘stdout’
[13:24:20.452]   - Field: ‘earlySignal’
[13:24:20.452]   - Field: ‘lazy’
[13:24:20.452]   - Field: ‘state’
[13:24:20.453] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.453] - Launch lazy future ...
[13:24:20.453] Packages needed by the future expression (n = 0): <none>
[13:24:20.453] Packages needed by future strategies (n = 0): <none>
[13:24:20.453] {
[13:24:20.453]     {
[13:24:20.453]         {
[13:24:20.453]             ...future.startTime <- base::Sys.time()
[13:24:20.453]             {
[13:24:20.453]                 {
[13:24:20.453]                   {
[13:24:20.453]                     base::local({
[13:24:20.453]                       has_future <- base::requireNamespace("future", 
[13:24:20.453]                         quietly = TRUE)
[13:24:20.453]                       if (has_future) {
[13:24:20.453]                         ns <- base::getNamespace("future")
[13:24:20.453]                         version <- ns[[".package"]][["version"]]
[13:24:20.453]                         if (is.null(version)) 
[13:24:20.453]                           version <- utils::packageVersion("future")
[13:24:20.453]                       }
[13:24:20.453]                       else {
[13:24:20.453]                         version <- NULL
[13:24:20.453]                       }
[13:24:20.453]                       if (!has_future || version < "1.8.0") {
[13:24:20.453]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.453]                           "", base::R.version$version.string), 
[13:24:20.453]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.453]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.453]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.453]                             "release", "version")], collapse = " "), 
[13:24:20.453]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.453]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.453]                           info)
[13:24:20.453]                         info <- base::paste(info, collapse = "; ")
[13:24:20.453]                         if (!has_future) {
[13:24:20.453]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.453]                             info)
[13:24:20.453]                         }
[13:24:20.453]                         else {
[13:24:20.453]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.453]                             info, version)
[13:24:20.453]                         }
[13:24:20.453]                         base::stop(msg)
[13:24:20.453]                       }
[13:24:20.453]                     })
[13:24:20.453]                   }
[13:24:20.453]                   options(future.plan = NULL)
[13:24:20.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.453]                 }
[13:24:20.453]                 ...future.workdir <- getwd()
[13:24:20.453]             }
[13:24:20.453]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.453]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.453]         }
[13:24:20.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.453]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.453]             base::names(...future.oldOptions))
[13:24:20.453]     }
[13:24:20.453]     if (FALSE) {
[13:24:20.453]     }
[13:24:20.453]     else {
[13:24:20.453]         if (TRUE) {
[13:24:20.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.453]                 open = "w")
[13:24:20.453]         }
[13:24:20.453]         else {
[13:24:20.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.453]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.453]         }
[13:24:20.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.453]             base::sink(type = "output", split = FALSE)
[13:24:20.453]             base::close(...future.stdout)
[13:24:20.453]         }, add = TRUE)
[13:24:20.453]     }
[13:24:20.453]     ...future.frame <- base::sys.nframe()
[13:24:20.453]     ...future.conditions <- base::list()
[13:24:20.453]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.453]     if (FALSE) {
[13:24:20.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.453]     }
[13:24:20.453]     ...future.result <- base::tryCatch({
[13:24:20.453]         base::withCallingHandlers({
[13:24:20.453]             ...future.value <- base::withVisible(base::local(1))
[13:24:20.453]             future::FutureResult(value = ...future.value$value, 
[13:24:20.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.453]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.453]                     ...future.globalenv.names))
[13:24:20.453]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.453]         }, condition = base::local({
[13:24:20.453]             c <- base::c
[13:24:20.453]             inherits <- base::inherits
[13:24:20.453]             invokeRestart <- base::invokeRestart
[13:24:20.453]             length <- base::length
[13:24:20.453]             list <- base::list
[13:24:20.453]             seq.int <- base::seq.int
[13:24:20.453]             signalCondition <- base::signalCondition
[13:24:20.453]             sys.calls <- base::sys.calls
[13:24:20.453]             `[[` <- base::`[[`
[13:24:20.453]             `+` <- base::`+`
[13:24:20.453]             `<<-` <- base::`<<-`
[13:24:20.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.453]                   3L)]
[13:24:20.453]             }
[13:24:20.453]             function(cond) {
[13:24:20.453]                 is_error <- inherits(cond, "error")
[13:24:20.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.453]                   NULL)
[13:24:20.453]                 if (is_error) {
[13:24:20.453]                   sessionInformation <- function() {
[13:24:20.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.453]                       search = base::search(), system = base::Sys.info())
[13:24:20.453]                   }
[13:24:20.453]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.453]                     cond$call), session = sessionInformation(), 
[13:24:20.453]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.453]                   signalCondition(cond)
[13:24:20.453]                 }
[13:24:20.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.453]                 "immediateCondition"))) {
[13:24:20.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.453]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.453]                   if (TRUE && !signal) {
[13:24:20.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.453]                     {
[13:24:20.453]                       inherits <- base::inherits
[13:24:20.453]                       invokeRestart <- base::invokeRestart
[13:24:20.453]                       is.null <- base::is.null
[13:24:20.453]                       muffled <- FALSE
[13:24:20.453]                       if (inherits(cond, "message")) {
[13:24:20.453]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.453]                         if (muffled) 
[13:24:20.453]                           invokeRestart("muffleMessage")
[13:24:20.453]                       }
[13:24:20.453]                       else if (inherits(cond, "warning")) {
[13:24:20.453]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.453]                         if (muffled) 
[13:24:20.453]                           invokeRestart("muffleWarning")
[13:24:20.453]                       }
[13:24:20.453]                       else if (inherits(cond, "condition")) {
[13:24:20.453]                         if (!is.null(pattern)) {
[13:24:20.453]                           computeRestarts <- base::computeRestarts
[13:24:20.453]                           grepl <- base::grepl
[13:24:20.453]                           restarts <- computeRestarts(cond)
[13:24:20.453]                           for (restart in restarts) {
[13:24:20.453]                             name <- restart$name
[13:24:20.453]                             if (is.null(name)) 
[13:24:20.453]                               next
[13:24:20.453]                             if (!grepl(pattern, name)) 
[13:24:20.453]                               next
[13:24:20.453]                             invokeRestart(restart)
[13:24:20.453]                             muffled <- TRUE
[13:24:20.453]                             break
[13:24:20.453]                           }
[13:24:20.453]                         }
[13:24:20.453]                       }
[13:24:20.453]                       invisible(muffled)
[13:24:20.453]                     }
[13:24:20.453]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.453]                   }
[13:24:20.453]                 }
[13:24:20.453]                 else {
[13:24:20.453]                   if (TRUE) {
[13:24:20.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.453]                     {
[13:24:20.453]                       inherits <- base::inherits
[13:24:20.453]                       invokeRestart <- base::invokeRestart
[13:24:20.453]                       is.null <- base::is.null
[13:24:20.453]                       muffled <- FALSE
[13:24:20.453]                       if (inherits(cond, "message")) {
[13:24:20.453]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.453]                         if (muffled) 
[13:24:20.453]                           invokeRestart("muffleMessage")
[13:24:20.453]                       }
[13:24:20.453]                       else if (inherits(cond, "warning")) {
[13:24:20.453]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.453]                         if (muffled) 
[13:24:20.453]                           invokeRestart("muffleWarning")
[13:24:20.453]                       }
[13:24:20.453]                       else if (inherits(cond, "condition")) {
[13:24:20.453]                         if (!is.null(pattern)) {
[13:24:20.453]                           computeRestarts <- base::computeRestarts
[13:24:20.453]                           grepl <- base::grepl
[13:24:20.453]                           restarts <- computeRestarts(cond)
[13:24:20.453]                           for (restart in restarts) {
[13:24:20.453]                             name <- restart$name
[13:24:20.453]                             if (is.null(name)) 
[13:24:20.453]                               next
[13:24:20.453]                             if (!grepl(pattern, name)) 
[13:24:20.453]                               next
[13:24:20.453]                             invokeRestart(restart)
[13:24:20.453]                             muffled <- TRUE
[13:24:20.453]                             break
[13:24:20.453]                           }
[13:24:20.453]                         }
[13:24:20.453]                       }
[13:24:20.453]                       invisible(muffled)
[13:24:20.453]                     }
[13:24:20.453]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.453]                   }
[13:24:20.453]                 }
[13:24:20.453]             }
[13:24:20.453]         }))
[13:24:20.453]     }, error = function(ex) {
[13:24:20.453]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.453]                 ...future.rng), started = ...future.startTime, 
[13:24:20.453]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.453]             version = "1.8"), class = "FutureResult")
[13:24:20.453]     }, finally = {
[13:24:20.453]         if (!identical(...future.workdir, getwd())) 
[13:24:20.453]             setwd(...future.workdir)
[13:24:20.453]         {
[13:24:20.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.453]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.453]             }
[13:24:20.453]             base::options(...future.oldOptions)
[13:24:20.453]             if (.Platform$OS.type == "windows") {
[13:24:20.453]                 old_names <- names(...future.oldEnvVars)
[13:24:20.453]                 envs <- base::Sys.getenv()
[13:24:20.453]                 names <- names(envs)
[13:24:20.453]                 common <- intersect(names, old_names)
[13:24:20.453]                 added <- setdiff(names, old_names)
[13:24:20.453]                 removed <- setdiff(old_names, names)
[13:24:20.453]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.453]                   envs[common]]
[13:24:20.453]                 NAMES <- toupper(changed)
[13:24:20.453]                 args <- list()
[13:24:20.453]                 for (kk in seq_along(NAMES)) {
[13:24:20.453]                   name <- changed[[kk]]
[13:24:20.453]                   NAME <- NAMES[[kk]]
[13:24:20.453]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.453]                     next
[13:24:20.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.453]                 }
[13:24:20.453]                 NAMES <- toupper(added)
[13:24:20.453]                 for (kk in seq_along(NAMES)) {
[13:24:20.453]                   name <- added[[kk]]
[13:24:20.453]                   NAME <- NAMES[[kk]]
[13:24:20.453]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.453]                     next
[13:24:20.453]                   args[[name]] <- ""
[13:24:20.453]                 }
[13:24:20.453]                 NAMES <- toupper(removed)
[13:24:20.453]                 for (kk in seq_along(NAMES)) {
[13:24:20.453]                   name <- removed[[kk]]
[13:24:20.453]                   NAME <- NAMES[[kk]]
[13:24:20.453]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.453]                     next
[13:24:20.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.453]                 }
[13:24:20.453]                 if (length(args) > 0) 
[13:24:20.453]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.453]             }
[13:24:20.453]             else {
[13:24:20.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.453]             }
[13:24:20.453]             {
[13:24:20.453]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.453]                   0L) {
[13:24:20.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.453]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.453]                   base::options(opts)
[13:24:20.453]                 }
[13:24:20.453]                 {
[13:24:20.453]                   {
[13:24:20.453]                     NULL
[13:24:20.453]                     RNGkind("Mersenne-Twister")
[13:24:20.453]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.453]                       inherits = FALSE)
[13:24:20.453]                   }
[13:24:20.453]                   options(future.plan = NULL)
[13:24:20.453]                   if (is.na(NA_character_)) 
[13:24:20.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.453]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.453]                   {
[13:24:20.453]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.453]                     if (!future$lazy) 
[13:24:20.453]                       future <- run(future)
[13:24:20.453]                     invisible(future)
[13:24:20.453]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.453]                 }
[13:24:20.453]             }
[13:24:20.453]         }
[13:24:20.453]     })
[13:24:20.453]     if (TRUE) {
[13:24:20.453]         base::sink(type = "output", split = FALSE)
[13:24:20.453]         if (TRUE) {
[13:24:20.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.453]         }
[13:24:20.453]         else {
[13:24:20.453]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.453]         }
[13:24:20.453]         base::close(...future.stdout)
[13:24:20.453]         ...future.stdout <- NULL
[13:24:20.453]     }
[13:24:20.453]     ...future.result$conditions <- ...future.conditions
[13:24:20.453]     ...future.result$finished <- base::Sys.time()
[13:24:20.453]     ...future.result
[13:24:20.453] }
[13:24:20.455] plan(): Setting new future strategy stack:
[13:24:20.455] List of future strategies:
[13:24:20.455] 1. sequential:
[13:24:20.455]    - args: function (..., envir = parent.frame())
[13:24:20.455]    - tweaked: FALSE
[13:24:20.455]    - call: NULL
[13:24:20.456] plan(): nbrOfWorkers() = 1
[13:24:20.456] plan(): Setting new future strategy stack:
[13:24:20.456] List of future strategies:
[13:24:20.456] 1. sequential:
[13:24:20.456]    - args: function (..., envir = parent.frame())
[13:24:20.456]    - tweaked: FALSE
[13:24:20.456]    - call: plan(strategy)
[13:24:20.457] plan(): nbrOfWorkers() = 1
[13:24:20.457] SequentialFuture started (and completed)
[13:24:20.457] - Launch lazy future ... done
[13:24:20.457] run() for ‘SequentialFuture’ ... done
[13:24:20.457] resolved() for ‘SequentialFuture’ ...
[13:24:20.457] - state: ‘finished’
[13:24:20.457] - run: TRUE
[13:24:20.458] - result: ‘FutureResult’
[13:24:20.458] resolved() for ‘SequentialFuture’ ... done
[13:24:20.458] Future #1
[13:24:20.458]  length: 2 (resolved future 1)
[13:24:20.458] run() for ‘Future’ ...
[13:24:20.458] - state: ‘created’
[13:24:20.458] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.458] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.459]   - Field: ‘label’
[13:24:20.459]   - Field: ‘local’
[13:24:20.459]   - Field: ‘owner’
[13:24:20.459]   - Field: ‘envir’
[13:24:20.459]   - Field: ‘packages’
[13:24:20.459]   - Field: ‘gc’
[13:24:20.459]   - Field: ‘conditions’
[13:24:20.459]   - Field: ‘expr’
[13:24:20.459]   - Field: ‘uuid’
[13:24:20.460]   - Field: ‘seed’
[13:24:20.460]   - Field: ‘version’
[13:24:20.460]   - Field: ‘result’
[13:24:20.460]   - Field: ‘asynchronous’
[13:24:20.460]   - Field: ‘calls’
[13:24:20.460]   - Field: ‘globals’
[13:24:20.460]   - Field: ‘stdout’
[13:24:20.460]   - Field: ‘earlySignal’
[13:24:20.460]   - Field: ‘lazy’
[13:24:20.460]   - Field: ‘state’
[13:24:20.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.461] - Launch lazy future ...
[13:24:20.461] Packages needed by the future expression (n = 0): <none>
[13:24:20.461] Packages needed by future strategies (n = 0): <none>
[13:24:20.463] {
[13:24:20.463]     {
[13:24:20.463]         {
[13:24:20.463]             ...future.startTime <- base::Sys.time()
[13:24:20.463]             {
[13:24:20.463]                 {
[13:24:20.463]                   {
[13:24:20.463]                     base::local({
[13:24:20.463]                       has_future <- base::requireNamespace("future", 
[13:24:20.463]                         quietly = TRUE)
[13:24:20.463]                       if (has_future) {
[13:24:20.463]                         ns <- base::getNamespace("future")
[13:24:20.463]                         version <- ns[[".package"]][["version"]]
[13:24:20.463]                         if (is.null(version)) 
[13:24:20.463]                           version <- utils::packageVersion("future")
[13:24:20.463]                       }
[13:24:20.463]                       else {
[13:24:20.463]                         version <- NULL
[13:24:20.463]                       }
[13:24:20.463]                       if (!has_future || version < "1.8.0") {
[13:24:20.463]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.463]                           "", base::R.version$version.string), 
[13:24:20.463]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.463]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.463]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.463]                             "release", "version")], collapse = " "), 
[13:24:20.463]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.463]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.463]                           info)
[13:24:20.463]                         info <- base::paste(info, collapse = "; ")
[13:24:20.463]                         if (!has_future) {
[13:24:20.463]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.463]                             info)
[13:24:20.463]                         }
[13:24:20.463]                         else {
[13:24:20.463]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.463]                             info, version)
[13:24:20.463]                         }
[13:24:20.463]                         base::stop(msg)
[13:24:20.463]                       }
[13:24:20.463]                     })
[13:24:20.463]                   }
[13:24:20.463]                   options(future.plan = NULL)
[13:24:20.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.463]                 }
[13:24:20.463]                 ...future.workdir <- getwd()
[13:24:20.463]             }
[13:24:20.463]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.463]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.463]         }
[13:24:20.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.463]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.463]             base::names(...future.oldOptions))
[13:24:20.463]     }
[13:24:20.463]     if (FALSE) {
[13:24:20.463]     }
[13:24:20.463]     else {
[13:24:20.463]         if (TRUE) {
[13:24:20.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.463]                 open = "w")
[13:24:20.463]         }
[13:24:20.463]         else {
[13:24:20.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.463]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.463]         }
[13:24:20.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.463]             base::sink(type = "output", split = FALSE)
[13:24:20.463]             base::close(...future.stdout)
[13:24:20.463]         }, add = TRUE)
[13:24:20.463]     }
[13:24:20.463]     ...future.frame <- base::sys.nframe()
[13:24:20.463]     ...future.conditions <- base::list()
[13:24:20.463]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.463]     if (FALSE) {
[13:24:20.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.463]     }
[13:24:20.463]     ...future.result <- base::tryCatch({
[13:24:20.463]         base::withCallingHandlers({
[13:24:20.463]             ...future.value <- base::withVisible(base::local(2))
[13:24:20.463]             future::FutureResult(value = ...future.value$value, 
[13:24:20.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.463]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.463]                     ...future.globalenv.names))
[13:24:20.463]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.463]         }, condition = base::local({
[13:24:20.463]             c <- base::c
[13:24:20.463]             inherits <- base::inherits
[13:24:20.463]             invokeRestart <- base::invokeRestart
[13:24:20.463]             length <- base::length
[13:24:20.463]             list <- base::list
[13:24:20.463]             seq.int <- base::seq.int
[13:24:20.463]             signalCondition <- base::signalCondition
[13:24:20.463]             sys.calls <- base::sys.calls
[13:24:20.463]             `[[` <- base::`[[`
[13:24:20.463]             `+` <- base::`+`
[13:24:20.463]             `<<-` <- base::`<<-`
[13:24:20.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.463]                   3L)]
[13:24:20.463]             }
[13:24:20.463]             function(cond) {
[13:24:20.463]                 is_error <- inherits(cond, "error")
[13:24:20.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.463]                   NULL)
[13:24:20.463]                 if (is_error) {
[13:24:20.463]                   sessionInformation <- function() {
[13:24:20.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.463]                       search = base::search(), system = base::Sys.info())
[13:24:20.463]                   }
[13:24:20.463]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.463]                     cond$call), session = sessionInformation(), 
[13:24:20.463]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.463]                   signalCondition(cond)
[13:24:20.463]                 }
[13:24:20.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.463]                 "immediateCondition"))) {
[13:24:20.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.463]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.463]                   if (TRUE && !signal) {
[13:24:20.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.463]                     {
[13:24:20.463]                       inherits <- base::inherits
[13:24:20.463]                       invokeRestart <- base::invokeRestart
[13:24:20.463]                       is.null <- base::is.null
[13:24:20.463]                       muffled <- FALSE
[13:24:20.463]                       if (inherits(cond, "message")) {
[13:24:20.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.463]                         if (muffled) 
[13:24:20.463]                           invokeRestart("muffleMessage")
[13:24:20.463]                       }
[13:24:20.463]                       else if (inherits(cond, "warning")) {
[13:24:20.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.463]                         if (muffled) 
[13:24:20.463]                           invokeRestart("muffleWarning")
[13:24:20.463]                       }
[13:24:20.463]                       else if (inherits(cond, "condition")) {
[13:24:20.463]                         if (!is.null(pattern)) {
[13:24:20.463]                           computeRestarts <- base::computeRestarts
[13:24:20.463]                           grepl <- base::grepl
[13:24:20.463]                           restarts <- computeRestarts(cond)
[13:24:20.463]                           for (restart in restarts) {
[13:24:20.463]                             name <- restart$name
[13:24:20.463]                             if (is.null(name)) 
[13:24:20.463]                               next
[13:24:20.463]                             if (!grepl(pattern, name)) 
[13:24:20.463]                               next
[13:24:20.463]                             invokeRestart(restart)
[13:24:20.463]                             muffled <- TRUE
[13:24:20.463]                             break
[13:24:20.463]                           }
[13:24:20.463]                         }
[13:24:20.463]                       }
[13:24:20.463]                       invisible(muffled)
[13:24:20.463]                     }
[13:24:20.463]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.463]                   }
[13:24:20.463]                 }
[13:24:20.463]                 else {
[13:24:20.463]                   if (TRUE) {
[13:24:20.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.463]                     {
[13:24:20.463]                       inherits <- base::inherits
[13:24:20.463]                       invokeRestart <- base::invokeRestart
[13:24:20.463]                       is.null <- base::is.null
[13:24:20.463]                       muffled <- FALSE
[13:24:20.463]                       if (inherits(cond, "message")) {
[13:24:20.463]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.463]                         if (muffled) 
[13:24:20.463]                           invokeRestart("muffleMessage")
[13:24:20.463]                       }
[13:24:20.463]                       else if (inherits(cond, "warning")) {
[13:24:20.463]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.463]                         if (muffled) 
[13:24:20.463]                           invokeRestart("muffleWarning")
[13:24:20.463]                       }
[13:24:20.463]                       else if (inherits(cond, "condition")) {
[13:24:20.463]                         if (!is.null(pattern)) {
[13:24:20.463]                           computeRestarts <- base::computeRestarts
[13:24:20.463]                           grepl <- base::grepl
[13:24:20.463]                           restarts <- computeRestarts(cond)
[13:24:20.463]                           for (restart in restarts) {
[13:24:20.463]                             name <- restart$name
[13:24:20.463]                             if (is.null(name)) 
[13:24:20.463]                               next
[13:24:20.463]                             if (!grepl(pattern, name)) 
[13:24:20.463]                               next
[13:24:20.463]                             invokeRestart(restart)
[13:24:20.463]                             muffled <- TRUE
[13:24:20.463]                             break
[13:24:20.463]                           }
[13:24:20.463]                         }
[13:24:20.463]                       }
[13:24:20.463]                       invisible(muffled)
[13:24:20.463]                     }
[13:24:20.463]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.463]                   }
[13:24:20.463]                 }
[13:24:20.463]             }
[13:24:20.463]         }))
[13:24:20.463]     }, error = function(ex) {
[13:24:20.463]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.463]                 ...future.rng), started = ...future.startTime, 
[13:24:20.463]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.463]             version = "1.8"), class = "FutureResult")
[13:24:20.463]     }, finally = {
[13:24:20.463]         if (!identical(...future.workdir, getwd())) 
[13:24:20.463]             setwd(...future.workdir)
[13:24:20.463]         {
[13:24:20.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.463]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.463]             }
[13:24:20.463]             base::options(...future.oldOptions)
[13:24:20.463]             if (.Platform$OS.type == "windows") {
[13:24:20.463]                 old_names <- names(...future.oldEnvVars)
[13:24:20.463]                 envs <- base::Sys.getenv()
[13:24:20.463]                 names <- names(envs)
[13:24:20.463]                 common <- intersect(names, old_names)
[13:24:20.463]                 added <- setdiff(names, old_names)
[13:24:20.463]                 removed <- setdiff(old_names, names)
[13:24:20.463]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.463]                   envs[common]]
[13:24:20.463]                 NAMES <- toupper(changed)
[13:24:20.463]                 args <- list()
[13:24:20.463]                 for (kk in seq_along(NAMES)) {
[13:24:20.463]                   name <- changed[[kk]]
[13:24:20.463]                   NAME <- NAMES[[kk]]
[13:24:20.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.463]                     next
[13:24:20.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.463]                 }
[13:24:20.463]                 NAMES <- toupper(added)
[13:24:20.463]                 for (kk in seq_along(NAMES)) {
[13:24:20.463]                   name <- added[[kk]]
[13:24:20.463]                   NAME <- NAMES[[kk]]
[13:24:20.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.463]                     next
[13:24:20.463]                   args[[name]] <- ""
[13:24:20.463]                 }
[13:24:20.463]                 NAMES <- toupper(removed)
[13:24:20.463]                 for (kk in seq_along(NAMES)) {
[13:24:20.463]                   name <- removed[[kk]]
[13:24:20.463]                   NAME <- NAMES[[kk]]
[13:24:20.463]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.463]                     next
[13:24:20.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.463]                 }
[13:24:20.463]                 if (length(args) > 0) 
[13:24:20.463]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.463]             }
[13:24:20.463]             else {
[13:24:20.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.463]             }
[13:24:20.463]             {
[13:24:20.463]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.463]                   0L) {
[13:24:20.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.463]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.463]                   base::options(opts)
[13:24:20.463]                 }
[13:24:20.463]                 {
[13:24:20.463]                   {
[13:24:20.463]                     NULL
[13:24:20.463]                     RNGkind("Mersenne-Twister")
[13:24:20.463]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.463]                       inherits = FALSE)
[13:24:20.463]                   }
[13:24:20.463]                   options(future.plan = NULL)
[13:24:20.463]                   if (is.na(NA_character_)) 
[13:24:20.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.463]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.463]                   {
[13:24:20.463]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.463]                     if (!future$lazy) 
[13:24:20.463]                       future <- run(future)
[13:24:20.463]                     invisible(future)
[13:24:20.463]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.463]                 }
[13:24:20.463]             }
[13:24:20.463]         }
[13:24:20.463]     })
[13:24:20.463]     if (TRUE) {
[13:24:20.463]         base::sink(type = "output", split = FALSE)
[13:24:20.463]         if (TRUE) {
[13:24:20.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.463]         }
[13:24:20.463]         else {
[13:24:20.463]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.463]         }
[13:24:20.463]         base::close(...future.stdout)
[13:24:20.463]         ...future.stdout <- NULL
[13:24:20.463]     }
[13:24:20.463]     ...future.result$conditions <- ...future.conditions
[13:24:20.463]     ...future.result$finished <- base::Sys.time()
[13:24:20.463]     ...future.result
[13:24:20.463] }
[13:24:20.465] plan(): Setting new future strategy stack:
[13:24:20.465] List of future strategies:
[13:24:20.465] 1. sequential:
[13:24:20.465]    - args: function (..., envir = parent.frame())
[13:24:20.465]    - tweaked: FALSE
[13:24:20.465]    - call: NULL
[13:24:20.465] plan(): nbrOfWorkers() = 1
[13:24:20.466] plan(): Setting new future strategy stack:
[13:24:20.466] List of future strategies:
[13:24:20.466] 1. sequential:
[13:24:20.466]    - args: function (..., envir = parent.frame())
[13:24:20.466]    - tweaked: FALSE
[13:24:20.466]    - call: plan(strategy)
[13:24:20.466] plan(): nbrOfWorkers() = 1
[13:24:20.467] SequentialFuture started (and completed)
[13:24:20.467] - Launch lazy future ... done
[13:24:20.467] run() for ‘SequentialFuture’ ... done
[13:24:20.467] resolved() for ‘SequentialFuture’ ...
[13:24:20.467] - state: ‘finished’
[13:24:20.467] - run: TRUE
[13:24:20.467] - result: ‘FutureResult’
[13:24:20.467] resolved() for ‘SequentialFuture’ ... done
[13:24:20.467] Future #2
[13:24:20.468]  length: 1 (resolved future 2)
[13:24:20.468]  length: 0 (resolved future 3)
[13:24:20.468] resolve() on list ... DONE
[13:24:20.468] resolved() for ‘SequentialFuture’ ...
[13:24:20.468] - state: ‘finished’
[13:24:20.468] - run: TRUE
[13:24:20.468] - result: ‘FutureResult’
[13:24:20.468] resolved() for ‘SequentialFuture’ ... done
[13:24:20.468] resolved() for ‘SequentialFuture’ ...
[13:24:20.469] - state: ‘finished’
[13:24:20.469] - run: TRUE
[13:24:20.469] - result: ‘FutureResult’
[13:24:20.469] resolved() for ‘SequentialFuture’ ... done
[13:24:20.469] getGlobalsAndPackages() ...
[13:24:20.469] Searching for globals...
[13:24:20.469] 
[13:24:20.469] Searching for globals ... DONE
[13:24:20.470] - globals: [0] <none>
[13:24:20.470] getGlobalsAndPackages() ... DONE
[13:24:20.470] run() for ‘Future’ ...
[13:24:20.470] - state: ‘created’
[13:24:20.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.471]   - Field: ‘label’
[13:24:20.471]   - Field: ‘local’
[13:24:20.471]   - Field: ‘owner’
[13:24:20.471]   - Field: ‘envir’
[13:24:20.471]   - Field: ‘packages’
[13:24:20.471]   - Field: ‘gc’
[13:24:20.471]   - Field: ‘conditions’
[13:24:20.471]   - Field: ‘expr’
[13:24:20.471]   - Field: ‘uuid’
[13:24:20.471]   - Field: ‘seed’
[13:24:20.472]   - Field: ‘version’
[13:24:20.472]   - Field: ‘result’
[13:24:20.472]   - Field: ‘asynchronous’
[13:24:20.472]   - Field: ‘calls’
[13:24:20.472]   - Field: ‘globals’
[13:24:20.472]   - Field: ‘stdout’
[13:24:20.472]   - Field: ‘earlySignal’
[13:24:20.472]   - Field: ‘lazy’
[13:24:20.472]   - Field: ‘state’
[13:24:20.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.473] - Launch lazy future ...
[13:24:20.473] Packages needed by the future expression (n = 0): <none>
[13:24:20.473] Packages needed by future strategies (n = 0): <none>
[13:24:20.473] {
[13:24:20.473]     {
[13:24:20.473]         {
[13:24:20.473]             ...future.startTime <- base::Sys.time()
[13:24:20.473]             {
[13:24:20.473]                 {
[13:24:20.473]                   {
[13:24:20.473]                     base::local({
[13:24:20.473]                       has_future <- base::requireNamespace("future", 
[13:24:20.473]                         quietly = TRUE)
[13:24:20.473]                       if (has_future) {
[13:24:20.473]                         ns <- base::getNamespace("future")
[13:24:20.473]                         version <- ns[[".package"]][["version"]]
[13:24:20.473]                         if (is.null(version)) 
[13:24:20.473]                           version <- utils::packageVersion("future")
[13:24:20.473]                       }
[13:24:20.473]                       else {
[13:24:20.473]                         version <- NULL
[13:24:20.473]                       }
[13:24:20.473]                       if (!has_future || version < "1.8.0") {
[13:24:20.473]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.473]                           "", base::R.version$version.string), 
[13:24:20.473]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.473]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.473]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.473]                             "release", "version")], collapse = " "), 
[13:24:20.473]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.473]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.473]                           info)
[13:24:20.473]                         info <- base::paste(info, collapse = "; ")
[13:24:20.473]                         if (!has_future) {
[13:24:20.473]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.473]                             info)
[13:24:20.473]                         }
[13:24:20.473]                         else {
[13:24:20.473]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.473]                             info, version)
[13:24:20.473]                         }
[13:24:20.473]                         base::stop(msg)
[13:24:20.473]                       }
[13:24:20.473]                     })
[13:24:20.473]                   }
[13:24:20.473]                   options(future.plan = NULL)
[13:24:20.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.473]                 }
[13:24:20.473]                 ...future.workdir <- getwd()
[13:24:20.473]             }
[13:24:20.473]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.473]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.473]         }
[13:24:20.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.473]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.473]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.473]             base::names(...future.oldOptions))
[13:24:20.473]     }
[13:24:20.473]     if (FALSE) {
[13:24:20.473]     }
[13:24:20.473]     else {
[13:24:20.473]         if (TRUE) {
[13:24:20.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.473]                 open = "w")
[13:24:20.473]         }
[13:24:20.473]         else {
[13:24:20.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.473]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.473]         }
[13:24:20.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.473]             base::sink(type = "output", split = FALSE)
[13:24:20.473]             base::close(...future.stdout)
[13:24:20.473]         }, add = TRUE)
[13:24:20.473]     }
[13:24:20.473]     ...future.frame <- base::sys.nframe()
[13:24:20.473]     ...future.conditions <- base::list()
[13:24:20.473]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.473]     if (FALSE) {
[13:24:20.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.473]     }
[13:24:20.473]     ...future.result <- base::tryCatch({
[13:24:20.473]         base::withCallingHandlers({
[13:24:20.473]             ...future.value <- base::withVisible(base::local(1))
[13:24:20.473]             future::FutureResult(value = ...future.value$value, 
[13:24:20.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.473]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.473]                     ...future.globalenv.names))
[13:24:20.473]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.473]         }, condition = base::local({
[13:24:20.473]             c <- base::c
[13:24:20.473]             inherits <- base::inherits
[13:24:20.473]             invokeRestart <- base::invokeRestart
[13:24:20.473]             length <- base::length
[13:24:20.473]             list <- base::list
[13:24:20.473]             seq.int <- base::seq.int
[13:24:20.473]             signalCondition <- base::signalCondition
[13:24:20.473]             sys.calls <- base::sys.calls
[13:24:20.473]             `[[` <- base::`[[`
[13:24:20.473]             `+` <- base::`+`
[13:24:20.473]             `<<-` <- base::`<<-`
[13:24:20.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.473]                   3L)]
[13:24:20.473]             }
[13:24:20.473]             function(cond) {
[13:24:20.473]                 is_error <- inherits(cond, "error")
[13:24:20.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.473]                   NULL)
[13:24:20.473]                 if (is_error) {
[13:24:20.473]                   sessionInformation <- function() {
[13:24:20.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.473]                       search = base::search(), system = base::Sys.info())
[13:24:20.473]                   }
[13:24:20.473]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.473]                     cond$call), session = sessionInformation(), 
[13:24:20.473]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.473]                   signalCondition(cond)
[13:24:20.473]                 }
[13:24:20.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.473]                 "immediateCondition"))) {
[13:24:20.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.473]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.473]                   if (TRUE && !signal) {
[13:24:20.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.473]                     {
[13:24:20.473]                       inherits <- base::inherits
[13:24:20.473]                       invokeRestart <- base::invokeRestart
[13:24:20.473]                       is.null <- base::is.null
[13:24:20.473]                       muffled <- FALSE
[13:24:20.473]                       if (inherits(cond, "message")) {
[13:24:20.473]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.473]                         if (muffled) 
[13:24:20.473]                           invokeRestart("muffleMessage")
[13:24:20.473]                       }
[13:24:20.473]                       else if (inherits(cond, "warning")) {
[13:24:20.473]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.473]                         if (muffled) 
[13:24:20.473]                           invokeRestart("muffleWarning")
[13:24:20.473]                       }
[13:24:20.473]                       else if (inherits(cond, "condition")) {
[13:24:20.473]                         if (!is.null(pattern)) {
[13:24:20.473]                           computeRestarts <- base::computeRestarts
[13:24:20.473]                           grepl <- base::grepl
[13:24:20.473]                           restarts <- computeRestarts(cond)
[13:24:20.473]                           for (restart in restarts) {
[13:24:20.473]                             name <- restart$name
[13:24:20.473]                             if (is.null(name)) 
[13:24:20.473]                               next
[13:24:20.473]                             if (!grepl(pattern, name)) 
[13:24:20.473]                               next
[13:24:20.473]                             invokeRestart(restart)
[13:24:20.473]                             muffled <- TRUE
[13:24:20.473]                             break
[13:24:20.473]                           }
[13:24:20.473]                         }
[13:24:20.473]                       }
[13:24:20.473]                       invisible(muffled)
[13:24:20.473]                     }
[13:24:20.473]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.473]                   }
[13:24:20.473]                 }
[13:24:20.473]                 else {
[13:24:20.473]                   if (TRUE) {
[13:24:20.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.473]                     {
[13:24:20.473]                       inherits <- base::inherits
[13:24:20.473]                       invokeRestart <- base::invokeRestart
[13:24:20.473]                       is.null <- base::is.null
[13:24:20.473]                       muffled <- FALSE
[13:24:20.473]                       if (inherits(cond, "message")) {
[13:24:20.473]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.473]                         if (muffled) 
[13:24:20.473]                           invokeRestart("muffleMessage")
[13:24:20.473]                       }
[13:24:20.473]                       else if (inherits(cond, "warning")) {
[13:24:20.473]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.473]                         if (muffled) 
[13:24:20.473]                           invokeRestart("muffleWarning")
[13:24:20.473]                       }
[13:24:20.473]                       else if (inherits(cond, "condition")) {
[13:24:20.473]                         if (!is.null(pattern)) {
[13:24:20.473]                           computeRestarts <- base::computeRestarts
[13:24:20.473]                           grepl <- base::grepl
[13:24:20.473]                           restarts <- computeRestarts(cond)
[13:24:20.473]                           for (restart in restarts) {
[13:24:20.473]                             name <- restart$name
[13:24:20.473]                             if (is.null(name)) 
[13:24:20.473]                               next
[13:24:20.473]                             if (!grepl(pattern, name)) 
[13:24:20.473]                               next
[13:24:20.473]                             invokeRestart(restart)
[13:24:20.473]                             muffled <- TRUE
[13:24:20.473]                             break
[13:24:20.473]                           }
[13:24:20.473]                         }
[13:24:20.473]                       }
[13:24:20.473]                       invisible(muffled)
[13:24:20.473]                     }
[13:24:20.473]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.473]                   }
[13:24:20.473]                 }
[13:24:20.473]             }
[13:24:20.473]         }))
[13:24:20.473]     }, error = function(ex) {
[13:24:20.473]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.473]                 ...future.rng), started = ...future.startTime, 
[13:24:20.473]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.473]             version = "1.8"), class = "FutureResult")
[13:24:20.473]     }, finally = {
[13:24:20.473]         if (!identical(...future.workdir, getwd())) 
[13:24:20.473]             setwd(...future.workdir)
[13:24:20.473]         {
[13:24:20.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.473]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.473]             }
[13:24:20.473]             base::options(...future.oldOptions)
[13:24:20.473]             if (.Platform$OS.type == "windows") {
[13:24:20.473]                 old_names <- names(...future.oldEnvVars)
[13:24:20.473]                 envs <- base::Sys.getenv()
[13:24:20.473]                 names <- names(envs)
[13:24:20.473]                 common <- intersect(names, old_names)
[13:24:20.473]                 added <- setdiff(names, old_names)
[13:24:20.473]                 removed <- setdiff(old_names, names)
[13:24:20.473]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.473]                   envs[common]]
[13:24:20.473]                 NAMES <- toupper(changed)
[13:24:20.473]                 args <- list()
[13:24:20.473]                 for (kk in seq_along(NAMES)) {
[13:24:20.473]                   name <- changed[[kk]]
[13:24:20.473]                   NAME <- NAMES[[kk]]
[13:24:20.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.473]                     next
[13:24:20.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.473]                 }
[13:24:20.473]                 NAMES <- toupper(added)
[13:24:20.473]                 for (kk in seq_along(NAMES)) {
[13:24:20.473]                   name <- added[[kk]]
[13:24:20.473]                   NAME <- NAMES[[kk]]
[13:24:20.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.473]                     next
[13:24:20.473]                   args[[name]] <- ""
[13:24:20.473]                 }
[13:24:20.473]                 NAMES <- toupper(removed)
[13:24:20.473]                 for (kk in seq_along(NAMES)) {
[13:24:20.473]                   name <- removed[[kk]]
[13:24:20.473]                   NAME <- NAMES[[kk]]
[13:24:20.473]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.473]                     next
[13:24:20.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.473]                 }
[13:24:20.473]                 if (length(args) > 0) 
[13:24:20.473]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.473]             }
[13:24:20.473]             else {
[13:24:20.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.473]             }
[13:24:20.473]             {
[13:24:20.473]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.473]                   0L) {
[13:24:20.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.473]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.473]                   base::options(opts)
[13:24:20.473]                 }
[13:24:20.473]                 {
[13:24:20.473]                   {
[13:24:20.473]                     NULL
[13:24:20.473]                     RNGkind("Mersenne-Twister")
[13:24:20.473]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.473]                       inherits = FALSE)
[13:24:20.473]                   }
[13:24:20.473]                   options(future.plan = NULL)
[13:24:20.473]                   if (is.na(NA_character_)) 
[13:24:20.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.473]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.473]                   {
[13:24:20.473]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.473]                     if (!future$lazy) 
[13:24:20.473]                       future <- run(future)
[13:24:20.473]                     invisible(future)
[13:24:20.473]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.473]                 }
[13:24:20.473]             }
[13:24:20.473]         }
[13:24:20.473]     })
[13:24:20.473]     if (TRUE) {
[13:24:20.473]         base::sink(type = "output", split = FALSE)
[13:24:20.473]         if (TRUE) {
[13:24:20.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.473]         }
[13:24:20.473]         else {
[13:24:20.473]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.473]         }
[13:24:20.473]         base::close(...future.stdout)
[13:24:20.473]         ...future.stdout <- NULL
[13:24:20.473]     }
[13:24:20.473]     ...future.result$conditions <- ...future.conditions
[13:24:20.473]     ...future.result$finished <- base::Sys.time()
[13:24:20.473]     ...future.result
[13:24:20.473] }
[13:24:20.475] plan(): Setting new future strategy stack:
[13:24:20.475] List of future strategies:
[13:24:20.475] 1. sequential:
[13:24:20.475]    - args: function (..., envir = parent.frame())
[13:24:20.475]    - tweaked: FALSE
[13:24:20.475]    - call: NULL
[13:24:20.475] plan(): nbrOfWorkers() = 1
[13:24:20.476] plan(): Setting new future strategy stack:
[13:24:20.476] List of future strategies:
[13:24:20.476] 1. sequential:
[13:24:20.476]    - args: function (..., envir = parent.frame())
[13:24:20.476]    - tweaked: FALSE
[13:24:20.476]    - call: plan(strategy)
[13:24:20.477] plan(): nbrOfWorkers() = 1
[13:24:20.477] SequentialFuture started (and completed)
[13:24:20.477] - Launch lazy future ... done
[13:24:20.477] run() for ‘SequentialFuture’ ... done
[13:24:20.477] getGlobalsAndPackages() ...
[13:24:20.477] Searching for globals...
[13:24:20.482] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:24:20.482] Searching for globals ... DONE
[13:24:20.482] Resolving globals: FALSE
[13:24:20.483] 
[13:24:20.483] 
[13:24:20.483] getGlobalsAndPackages() ... DONE
[13:24:20.483] run() for ‘Future’ ...
[13:24:20.484] - state: ‘created’
[13:24:20.484] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:20.484] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:20.484] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:20.484]   - Field: ‘label’
[13:24:20.484]   - Field: ‘local’
[13:24:20.484]   - Field: ‘owner’
[13:24:20.484]   - Field: ‘envir’
[13:24:20.485]   - Field: ‘packages’
[13:24:20.485]   - Field: ‘gc’
[13:24:20.485]   - Field: ‘conditions’
[13:24:20.485]   - Field: ‘expr’
[13:24:20.485]   - Field: ‘uuid’
[13:24:20.485]   - Field: ‘seed’
[13:24:20.485]   - Field: ‘version’
[13:24:20.485]   - Field: ‘result’
[13:24:20.485]   - Field: ‘asynchronous’
[13:24:20.485]   - Field: ‘calls’
[13:24:20.486]   - Field: ‘globals’
[13:24:20.486]   - Field: ‘stdout’
[13:24:20.486]   - Field: ‘earlySignal’
[13:24:20.486]   - Field: ‘lazy’
[13:24:20.486]   - Field: ‘state’
[13:24:20.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:20.486] - Launch lazy future ...
[13:24:20.486] Packages needed by the future expression (n = 0): <none>
[13:24:20.486] Packages needed by future strategies (n = 0): <none>
[13:24:20.487] {
[13:24:20.487]     {
[13:24:20.487]         {
[13:24:20.487]             ...future.startTime <- base::Sys.time()
[13:24:20.487]             {
[13:24:20.487]                 {
[13:24:20.487]                   {
[13:24:20.487]                     base::local({
[13:24:20.487]                       has_future <- base::requireNamespace("future", 
[13:24:20.487]                         quietly = TRUE)
[13:24:20.487]                       if (has_future) {
[13:24:20.487]                         ns <- base::getNamespace("future")
[13:24:20.487]                         version <- ns[[".package"]][["version"]]
[13:24:20.487]                         if (is.null(version)) 
[13:24:20.487]                           version <- utils::packageVersion("future")
[13:24:20.487]                       }
[13:24:20.487]                       else {
[13:24:20.487]                         version <- NULL
[13:24:20.487]                       }
[13:24:20.487]                       if (!has_future || version < "1.8.0") {
[13:24:20.487]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:20.487]                           "", base::R.version$version.string), 
[13:24:20.487]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:20.487]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:20.487]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:20.487]                             "release", "version")], collapse = " "), 
[13:24:20.487]                           hostname = base::Sys.info()[["nodename"]])
[13:24:20.487]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:20.487]                           info)
[13:24:20.487]                         info <- base::paste(info, collapse = "; ")
[13:24:20.487]                         if (!has_future) {
[13:24:20.487]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:20.487]                             info)
[13:24:20.487]                         }
[13:24:20.487]                         else {
[13:24:20.487]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:20.487]                             info, version)
[13:24:20.487]                         }
[13:24:20.487]                         base::stop(msg)
[13:24:20.487]                       }
[13:24:20.487]                     })
[13:24:20.487]                   }
[13:24:20.487]                   options(future.plan = NULL)
[13:24:20.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:20.487]                 }
[13:24:20.487]                 ...future.workdir <- getwd()
[13:24:20.487]             }
[13:24:20.487]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:20.487]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:20.487]         }
[13:24:20.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:20.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:20.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:20.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:20.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:20.487]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:20.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:20.487]             base::names(...future.oldOptions))
[13:24:20.487]     }
[13:24:20.487]     if (FALSE) {
[13:24:20.487]     }
[13:24:20.487]     else {
[13:24:20.487]         if (TRUE) {
[13:24:20.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:20.487]                 open = "w")
[13:24:20.487]         }
[13:24:20.487]         else {
[13:24:20.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:20.487]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:20.487]         }
[13:24:20.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:20.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:20.487]             base::sink(type = "output", split = FALSE)
[13:24:20.487]             base::close(...future.stdout)
[13:24:20.487]         }, add = TRUE)
[13:24:20.487]     }
[13:24:20.487]     ...future.frame <- base::sys.nframe()
[13:24:20.487]     ...future.conditions <- base::list()
[13:24:20.487]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:20.487]     if (FALSE) {
[13:24:20.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:20.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:20.487]     }
[13:24:20.487]     ...future.result <- base::tryCatch({
[13:24:20.487]         base::withCallingHandlers({
[13:24:20.487]             ...future.value <- base::withVisible(base::local({
[13:24:20.487]                 Sys.sleep(0.5)
[13:24:20.487]                 2
[13:24:20.487]             }))
[13:24:20.487]             future::FutureResult(value = ...future.value$value, 
[13:24:20.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.487]                   ...future.rng), globalenv = if (FALSE) 
[13:24:20.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:20.487]                     ...future.globalenv.names))
[13:24:20.487]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:20.487]         }, condition = base::local({
[13:24:20.487]             c <- base::c
[13:24:20.487]             inherits <- base::inherits
[13:24:20.487]             invokeRestart <- base::invokeRestart
[13:24:20.487]             length <- base::length
[13:24:20.487]             list <- base::list
[13:24:20.487]             seq.int <- base::seq.int
[13:24:20.487]             signalCondition <- base::signalCondition
[13:24:20.487]             sys.calls <- base::sys.calls
[13:24:20.487]             `[[` <- base::`[[`
[13:24:20.487]             `+` <- base::`+`
[13:24:20.487]             `<<-` <- base::`<<-`
[13:24:20.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:20.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:20.487]                   3L)]
[13:24:20.487]             }
[13:24:20.487]             function(cond) {
[13:24:20.487]                 is_error <- inherits(cond, "error")
[13:24:20.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:20.487]                   NULL)
[13:24:20.487]                 if (is_error) {
[13:24:20.487]                   sessionInformation <- function() {
[13:24:20.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:20.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:20.487]                       search = base::search(), system = base::Sys.info())
[13:24:20.487]                   }
[13:24:20.487]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:20.487]                     cond$call), session = sessionInformation(), 
[13:24:20.487]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:20.487]                   signalCondition(cond)
[13:24:20.487]                 }
[13:24:20.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:20.487]                 "immediateCondition"))) {
[13:24:20.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:20.487]                   ...future.conditions[[length(...future.conditions) + 
[13:24:20.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:20.487]                   if (TRUE && !signal) {
[13:24:20.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.487]                     {
[13:24:20.487]                       inherits <- base::inherits
[13:24:20.487]                       invokeRestart <- base::invokeRestart
[13:24:20.487]                       is.null <- base::is.null
[13:24:20.487]                       muffled <- FALSE
[13:24:20.487]                       if (inherits(cond, "message")) {
[13:24:20.487]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.487]                         if (muffled) 
[13:24:20.487]                           invokeRestart("muffleMessage")
[13:24:20.487]                       }
[13:24:20.487]                       else if (inherits(cond, "warning")) {
[13:24:20.487]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.487]                         if (muffled) 
[13:24:20.487]                           invokeRestart("muffleWarning")
[13:24:20.487]                       }
[13:24:20.487]                       else if (inherits(cond, "condition")) {
[13:24:20.487]                         if (!is.null(pattern)) {
[13:24:20.487]                           computeRestarts <- base::computeRestarts
[13:24:20.487]                           grepl <- base::grepl
[13:24:20.487]                           restarts <- computeRestarts(cond)
[13:24:20.487]                           for (restart in restarts) {
[13:24:20.487]                             name <- restart$name
[13:24:20.487]                             if (is.null(name)) 
[13:24:20.487]                               next
[13:24:20.487]                             if (!grepl(pattern, name)) 
[13:24:20.487]                               next
[13:24:20.487]                             invokeRestart(restart)
[13:24:20.487]                             muffled <- TRUE
[13:24:20.487]                             break
[13:24:20.487]                           }
[13:24:20.487]                         }
[13:24:20.487]                       }
[13:24:20.487]                       invisible(muffled)
[13:24:20.487]                     }
[13:24:20.487]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.487]                   }
[13:24:20.487]                 }
[13:24:20.487]                 else {
[13:24:20.487]                   if (TRUE) {
[13:24:20.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:20.487]                     {
[13:24:20.487]                       inherits <- base::inherits
[13:24:20.487]                       invokeRestart <- base::invokeRestart
[13:24:20.487]                       is.null <- base::is.null
[13:24:20.487]                       muffled <- FALSE
[13:24:20.487]                       if (inherits(cond, "message")) {
[13:24:20.487]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:20.487]                         if (muffled) 
[13:24:20.487]                           invokeRestart("muffleMessage")
[13:24:20.487]                       }
[13:24:20.487]                       else if (inherits(cond, "warning")) {
[13:24:20.487]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:20.487]                         if (muffled) 
[13:24:20.487]                           invokeRestart("muffleWarning")
[13:24:20.487]                       }
[13:24:20.487]                       else if (inherits(cond, "condition")) {
[13:24:20.487]                         if (!is.null(pattern)) {
[13:24:20.487]                           computeRestarts <- base::computeRestarts
[13:24:20.487]                           grepl <- base::grepl
[13:24:20.487]                           restarts <- computeRestarts(cond)
[13:24:20.487]                           for (restart in restarts) {
[13:24:20.487]                             name <- restart$name
[13:24:20.487]                             if (is.null(name)) 
[13:24:20.487]                               next
[13:24:20.487]                             if (!grepl(pattern, name)) 
[13:24:20.487]                               next
[13:24:20.487]                             invokeRestart(restart)
[13:24:20.487]                             muffled <- TRUE
[13:24:20.487]                             break
[13:24:20.487]                           }
[13:24:20.487]                         }
[13:24:20.487]                       }
[13:24:20.487]                       invisible(muffled)
[13:24:20.487]                     }
[13:24:20.487]                     muffleCondition(cond, pattern = "^muffle")
[13:24:20.487]                   }
[13:24:20.487]                 }
[13:24:20.487]             }
[13:24:20.487]         }))
[13:24:20.487]     }, error = function(ex) {
[13:24:20.487]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:20.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:20.487]                 ...future.rng), started = ...future.startTime, 
[13:24:20.487]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:20.487]             version = "1.8"), class = "FutureResult")
[13:24:20.487]     }, finally = {
[13:24:20.487]         if (!identical(...future.workdir, getwd())) 
[13:24:20.487]             setwd(...future.workdir)
[13:24:20.487]         {
[13:24:20.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:20.487]                 ...future.oldOptions$nwarnings <- NULL
[13:24:20.487]             }
[13:24:20.487]             base::options(...future.oldOptions)
[13:24:20.487]             if (.Platform$OS.type == "windows") {
[13:24:20.487]                 old_names <- names(...future.oldEnvVars)
[13:24:20.487]                 envs <- base::Sys.getenv()
[13:24:20.487]                 names <- names(envs)
[13:24:20.487]                 common <- intersect(names, old_names)
[13:24:20.487]                 added <- setdiff(names, old_names)
[13:24:20.487]                 removed <- setdiff(old_names, names)
[13:24:20.487]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:20.487]                   envs[common]]
[13:24:20.487]                 NAMES <- toupper(changed)
[13:24:20.487]                 args <- list()
[13:24:20.487]                 for (kk in seq_along(NAMES)) {
[13:24:20.487]                   name <- changed[[kk]]
[13:24:20.487]                   NAME <- NAMES[[kk]]
[13:24:20.487]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.487]                     next
[13:24:20.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.487]                 }
[13:24:20.487]                 NAMES <- toupper(added)
[13:24:20.487]                 for (kk in seq_along(NAMES)) {
[13:24:20.487]                   name <- added[[kk]]
[13:24:20.487]                   NAME <- NAMES[[kk]]
[13:24:20.487]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.487]                     next
[13:24:20.487]                   args[[name]] <- ""
[13:24:20.487]                 }
[13:24:20.487]                 NAMES <- toupper(removed)
[13:24:20.487]                 for (kk in seq_along(NAMES)) {
[13:24:20.487]                   name <- removed[[kk]]
[13:24:20.487]                   NAME <- NAMES[[kk]]
[13:24:20.487]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:20.487]                     next
[13:24:20.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:20.487]                 }
[13:24:20.487]                 if (length(args) > 0) 
[13:24:20.487]                   base::do.call(base::Sys.setenv, args = args)
[13:24:20.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:20.487]             }
[13:24:20.487]             else {
[13:24:20.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:20.487]             }
[13:24:20.487]             {
[13:24:20.487]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:20.487]                   0L) {
[13:24:20.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:20.487]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:20.487]                   base::options(opts)
[13:24:20.487]                 }
[13:24:20.487]                 {
[13:24:20.487]                   {
[13:24:20.487]                     NULL
[13:24:20.487]                     RNGkind("Mersenne-Twister")
[13:24:20.487]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:20.487]                       inherits = FALSE)
[13:24:20.487]                   }
[13:24:20.487]                   options(future.plan = NULL)
[13:24:20.487]                   if (is.na(NA_character_)) 
[13:24:20.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:20.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:20.487]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:20.487]                   {
[13:24:20.487]                     future <- SequentialFuture(..., envir = envir)
[13:24:20.487]                     if (!future$lazy) 
[13:24:20.487]                       future <- run(future)
[13:24:20.487]                     invisible(future)
[13:24:20.487]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:20.487]                 }
[13:24:20.487]             }
[13:24:20.487]         }
[13:24:20.487]     })
[13:24:20.487]     if (TRUE) {
[13:24:20.487]         base::sink(type = "output", split = FALSE)
[13:24:20.487]         if (TRUE) {
[13:24:20.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:20.487]         }
[13:24:20.487]         else {
[13:24:20.487]             ...future.result["stdout"] <- base::list(NULL)
[13:24:20.487]         }
[13:24:20.487]         base::close(...future.stdout)
[13:24:20.487]         ...future.stdout <- NULL
[13:24:20.487]     }
[13:24:20.487]     ...future.result$conditions <- ...future.conditions
[13:24:20.487]     ...future.result$finished <- base::Sys.time()
[13:24:20.487]     ...future.result
[13:24:20.487] }
[13:24:20.489] plan(): Setting new future strategy stack:
[13:24:20.489] List of future strategies:
[13:24:20.489] 1. sequential:
[13:24:20.489]    - args: function (..., envir = parent.frame())
[13:24:20.489]    - tweaked: FALSE
[13:24:20.489]    - call: NULL
[13:24:20.489] plan(): nbrOfWorkers() = 1
[13:24:20.991] plan(): Setting new future strategy stack:
[13:24:20.991] List of future strategies:
[13:24:20.991] 1. sequential:
[13:24:20.991]    - args: function (..., envir = parent.frame())
[13:24:20.991]    - tweaked: FALSE
[13:24:20.991]    - call: plan(strategy)
[13:24:20.992] plan(): nbrOfWorkers() = 1
[13:24:20.992] SequentialFuture started (and completed)
[13:24:20.992] - Launch lazy future ... done
[13:24:20.992] run() for ‘SequentialFuture’ ... done
[13:24:20.993] resolve() on list ...
[13:24:20.993]  recursive: 0
[13:24:20.993]  length: 1
[13:24:20.993] 
[13:24:20.993] resolved() for ‘SequentialFuture’ ...
[13:24:20.993] - state: ‘finished’
[13:24:20.993] - run: TRUE
[13:24:20.993] - result: ‘FutureResult’
[13:24:20.994] resolved() for ‘SequentialFuture’ ... done
[13:24:20.994] Future #1
[13:24:20.994]  length: 0 (resolved future 1)
[13:24:20.994] resolve() on list ... DONE
[13:24:20.994] resolved() for ‘SequentialFuture’ ...
[13:24:20.994] - state: ‘finished’
[13:24:20.994] - run: TRUE
[13:24:20.994] - result: ‘FutureResult’
[13:24:20.994] resolved() for ‘SequentialFuture’ ... done
[13:24:20.994] resolve() on list ...
[13:24:20.995]  recursive: 0
[13:24:20.995]  length: 1
[13:24:20.995] 
[13:24:20.995] resolved() for ‘SequentialFuture’ ...
[13:24:20.995] - state: ‘finished’
[13:24:20.995] - run: TRUE
[13:24:20.995] - result: ‘FutureResult’
[13:24:20.995] resolved() for ‘SequentialFuture’ ... done
[13:24:20.995] Future #1
[13:24:20.995]  length: 0 (resolved future 1)
[13:24:20.995] resolve() on list ... DONE
[13:24:20.996] resolved() for ‘SequentialFuture’ ...
[13:24:20.996] - state: ‘finished’
[13:24:20.996] - run: TRUE
[13:24:20.996] - result: ‘FutureResult’
[13:24:20.996] resolved() for ‘SequentialFuture’ ... done
[13:24:20.996] resolve() on list ...
[13:24:20.996]  recursive: 0
[13:24:20.996]  length: 1
[13:24:20.996] 
[13:24:20.996]  length: 0 (resolved future 1)
[13:24:20.997] resolve() on list ... DONE
[13:24:20.997] resolve() on list ...
[13:24:20.997]  recursive: 0
[13:24:20.997]  length: 4
[13:24:20.997] 
[13:24:20.997] resolved() for ‘SequentialFuture’ ...
[13:24:20.997] - state: ‘finished’
[13:24:20.997] - run: TRUE
[13:24:20.997] - result: ‘FutureResult’
[13:24:20.997] resolved() for ‘SequentialFuture’ ... done
[13:24:20.998] Future #1
[13:24:21.000]  length: 3 (resolved future 1)
[13:24:21.000] resolved() for ‘SequentialFuture’ ...
[13:24:21.000] - state: ‘finished’
[13:24:21.000] - run: TRUE
[13:24:21.000] - result: ‘FutureResult’
[13:24:21.000] resolved() for ‘SequentialFuture’ ... done
[13:24:21.000] Future #2
[13:24:21.000]  length: 2 (resolved future 2)
[13:24:21.001]  length: 1 (resolved future 3)
[13:24:21.001]  length: 0 (resolved future 4)
[13:24:21.001] resolve() on list ... DONE
[13:24:21.001] resolve() on list ...
[13:24:21.001]  recursive: 0
[13:24:21.001]  length: 4
[13:24:21.001] 
[13:24:21.001] resolved() for ‘SequentialFuture’ ...
[13:24:21.001] - state: ‘finished’
[13:24:21.002] - run: TRUE
[13:24:21.002] - result: ‘FutureResult’
[13:24:21.002] resolved() for ‘SequentialFuture’ ... done
[13:24:21.002] Future #1
[13:24:21.002]  length: 3 (resolved future 1)
[13:24:21.002] resolved() for ‘SequentialFuture’ ...
[13:24:21.002] - state: ‘finished’
[13:24:21.002] - run: TRUE
[13:24:21.002] - result: ‘FutureResult’
[13:24:21.002] resolved() for ‘SequentialFuture’ ... done
[13:24:21.002] Future #2
[13:24:21.003]  length: 2 (resolved future 2)
[13:24:21.003]  length: 1 (resolved future 3)
[13:24:21.003]  length: 0 (resolved future 4)
[13:24:21.003] resolve() on list ... DONE
[13:24:21.003] resolve() on list ...
[13:24:21.003]  recursive: 0
[13:24:21.003]  length: 1
[13:24:21.003] 
[13:24:21.004]  length: 0 (resolved future 1)
[13:24:21.004] resolve() on list ... DONE
[13:24:21.004] getGlobalsAndPackages() ...
[13:24:21.004] Searching for globals...
[13:24:21.005] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:21.005] Searching for globals ... DONE
[13:24:21.005] Resolving globals: FALSE
[13:24:21.006] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:21.006] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:21.006] - globals: [1] ‘kk’
[13:24:21.007] 
[13:24:21.007] getGlobalsAndPackages() ... DONE
[13:24:21.007] run() for ‘Future’ ...
[13:24:21.007] - state: ‘created’
[13:24:21.007] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.007] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.008]   - Field: ‘label’
[13:24:21.008]   - Field: ‘local’
[13:24:21.008]   - Field: ‘owner’
[13:24:21.008]   - Field: ‘envir’
[13:24:21.008]   - Field: ‘packages’
[13:24:21.008]   - Field: ‘gc’
[13:24:21.008]   - Field: ‘conditions’
[13:24:21.008]   - Field: ‘expr’
[13:24:21.008]   - Field: ‘uuid’
[13:24:21.009]   - Field: ‘seed’
[13:24:21.009]   - Field: ‘version’
[13:24:21.009]   - Field: ‘result’
[13:24:21.009]   - Field: ‘asynchronous’
[13:24:21.009]   - Field: ‘calls’
[13:24:21.009]   - Field: ‘globals’
[13:24:21.009]   - Field: ‘stdout’
[13:24:21.009]   - Field: ‘earlySignal’
[13:24:21.009]   - Field: ‘lazy’
[13:24:21.009]   - Field: ‘state’
[13:24:21.009] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.010] - Launch lazy future ...
[13:24:21.010] Packages needed by the future expression (n = 0): <none>
[13:24:21.010] Packages needed by future strategies (n = 0): <none>
[13:24:21.010] {
[13:24:21.010]     {
[13:24:21.010]         {
[13:24:21.010]             ...future.startTime <- base::Sys.time()
[13:24:21.010]             {
[13:24:21.010]                 {
[13:24:21.010]                   {
[13:24:21.010]                     base::local({
[13:24:21.010]                       has_future <- base::requireNamespace("future", 
[13:24:21.010]                         quietly = TRUE)
[13:24:21.010]                       if (has_future) {
[13:24:21.010]                         ns <- base::getNamespace("future")
[13:24:21.010]                         version <- ns[[".package"]][["version"]]
[13:24:21.010]                         if (is.null(version)) 
[13:24:21.010]                           version <- utils::packageVersion("future")
[13:24:21.010]                       }
[13:24:21.010]                       else {
[13:24:21.010]                         version <- NULL
[13:24:21.010]                       }
[13:24:21.010]                       if (!has_future || version < "1.8.0") {
[13:24:21.010]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.010]                           "", base::R.version$version.string), 
[13:24:21.010]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.010]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.010]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.010]                             "release", "version")], collapse = " "), 
[13:24:21.010]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.010]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.010]                           info)
[13:24:21.010]                         info <- base::paste(info, collapse = "; ")
[13:24:21.010]                         if (!has_future) {
[13:24:21.010]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.010]                             info)
[13:24:21.010]                         }
[13:24:21.010]                         else {
[13:24:21.010]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.010]                             info, version)
[13:24:21.010]                         }
[13:24:21.010]                         base::stop(msg)
[13:24:21.010]                       }
[13:24:21.010]                     })
[13:24:21.010]                   }
[13:24:21.010]                   options(future.plan = NULL)
[13:24:21.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.010]                 }
[13:24:21.010]                 ...future.workdir <- getwd()
[13:24:21.010]             }
[13:24:21.010]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.010]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.010]         }
[13:24:21.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.010]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.010]             base::names(...future.oldOptions))
[13:24:21.010]     }
[13:24:21.010]     if (FALSE) {
[13:24:21.010]     }
[13:24:21.010]     else {
[13:24:21.010]         if (TRUE) {
[13:24:21.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.010]                 open = "w")
[13:24:21.010]         }
[13:24:21.010]         else {
[13:24:21.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.010]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.010]         }
[13:24:21.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.010]             base::sink(type = "output", split = FALSE)
[13:24:21.010]             base::close(...future.stdout)
[13:24:21.010]         }, add = TRUE)
[13:24:21.010]     }
[13:24:21.010]     ...future.frame <- base::sys.nframe()
[13:24:21.010]     ...future.conditions <- base::list()
[13:24:21.010]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.010]     if (FALSE) {
[13:24:21.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.010]     }
[13:24:21.010]     ...future.result <- base::tryCatch({
[13:24:21.010]         base::withCallingHandlers({
[13:24:21.010]             ...future.value <- base::withVisible(base::local({
[13:24:21.010]                 Sys.sleep(0.1)
[13:24:21.010]                 kk
[13:24:21.010]             }))
[13:24:21.010]             future::FutureResult(value = ...future.value$value, 
[13:24:21.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.010]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.010]                     ...future.globalenv.names))
[13:24:21.010]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.010]         }, condition = base::local({
[13:24:21.010]             c <- base::c
[13:24:21.010]             inherits <- base::inherits
[13:24:21.010]             invokeRestart <- base::invokeRestart
[13:24:21.010]             length <- base::length
[13:24:21.010]             list <- base::list
[13:24:21.010]             seq.int <- base::seq.int
[13:24:21.010]             signalCondition <- base::signalCondition
[13:24:21.010]             sys.calls <- base::sys.calls
[13:24:21.010]             `[[` <- base::`[[`
[13:24:21.010]             `+` <- base::`+`
[13:24:21.010]             `<<-` <- base::`<<-`
[13:24:21.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.010]                   3L)]
[13:24:21.010]             }
[13:24:21.010]             function(cond) {
[13:24:21.010]                 is_error <- inherits(cond, "error")
[13:24:21.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.010]                   NULL)
[13:24:21.010]                 if (is_error) {
[13:24:21.010]                   sessionInformation <- function() {
[13:24:21.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.010]                       search = base::search(), system = base::Sys.info())
[13:24:21.010]                   }
[13:24:21.010]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.010]                     cond$call), session = sessionInformation(), 
[13:24:21.010]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.010]                   signalCondition(cond)
[13:24:21.010]                 }
[13:24:21.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.010]                 "immediateCondition"))) {
[13:24:21.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.010]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.010]                   if (TRUE && !signal) {
[13:24:21.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.010]                     {
[13:24:21.010]                       inherits <- base::inherits
[13:24:21.010]                       invokeRestart <- base::invokeRestart
[13:24:21.010]                       is.null <- base::is.null
[13:24:21.010]                       muffled <- FALSE
[13:24:21.010]                       if (inherits(cond, "message")) {
[13:24:21.010]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.010]                         if (muffled) 
[13:24:21.010]                           invokeRestart("muffleMessage")
[13:24:21.010]                       }
[13:24:21.010]                       else if (inherits(cond, "warning")) {
[13:24:21.010]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.010]                         if (muffled) 
[13:24:21.010]                           invokeRestart("muffleWarning")
[13:24:21.010]                       }
[13:24:21.010]                       else if (inherits(cond, "condition")) {
[13:24:21.010]                         if (!is.null(pattern)) {
[13:24:21.010]                           computeRestarts <- base::computeRestarts
[13:24:21.010]                           grepl <- base::grepl
[13:24:21.010]                           restarts <- computeRestarts(cond)
[13:24:21.010]                           for (restart in restarts) {
[13:24:21.010]                             name <- restart$name
[13:24:21.010]                             if (is.null(name)) 
[13:24:21.010]                               next
[13:24:21.010]                             if (!grepl(pattern, name)) 
[13:24:21.010]                               next
[13:24:21.010]                             invokeRestart(restart)
[13:24:21.010]                             muffled <- TRUE
[13:24:21.010]                             break
[13:24:21.010]                           }
[13:24:21.010]                         }
[13:24:21.010]                       }
[13:24:21.010]                       invisible(muffled)
[13:24:21.010]                     }
[13:24:21.010]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.010]                   }
[13:24:21.010]                 }
[13:24:21.010]                 else {
[13:24:21.010]                   if (TRUE) {
[13:24:21.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.010]                     {
[13:24:21.010]                       inherits <- base::inherits
[13:24:21.010]                       invokeRestart <- base::invokeRestart
[13:24:21.010]                       is.null <- base::is.null
[13:24:21.010]                       muffled <- FALSE
[13:24:21.010]                       if (inherits(cond, "message")) {
[13:24:21.010]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.010]                         if (muffled) 
[13:24:21.010]                           invokeRestart("muffleMessage")
[13:24:21.010]                       }
[13:24:21.010]                       else if (inherits(cond, "warning")) {
[13:24:21.010]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.010]                         if (muffled) 
[13:24:21.010]                           invokeRestart("muffleWarning")
[13:24:21.010]                       }
[13:24:21.010]                       else if (inherits(cond, "condition")) {
[13:24:21.010]                         if (!is.null(pattern)) {
[13:24:21.010]                           computeRestarts <- base::computeRestarts
[13:24:21.010]                           grepl <- base::grepl
[13:24:21.010]                           restarts <- computeRestarts(cond)
[13:24:21.010]                           for (restart in restarts) {
[13:24:21.010]                             name <- restart$name
[13:24:21.010]                             if (is.null(name)) 
[13:24:21.010]                               next
[13:24:21.010]                             if (!grepl(pattern, name)) 
[13:24:21.010]                               next
[13:24:21.010]                             invokeRestart(restart)
[13:24:21.010]                             muffled <- TRUE
[13:24:21.010]                             break
[13:24:21.010]                           }
[13:24:21.010]                         }
[13:24:21.010]                       }
[13:24:21.010]                       invisible(muffled)
[13:24:21.010]                     }
[13:24:21.010]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.010]                   }
[13:24:21.010]                 }
[13:24:21.010]             }
[13:24:21.010]         }))
[13:24:21.010]     }, error = function(ex) {
[13:24:21.010]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.010]                 ...future.rng), started = ...future.startTime, 
[13:24:21.010]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.010]             version = "1.8"), class = "FutureResult")
[13:24:21.010]     }, finally = {
[13:24:21.010]         if (!identical(...future.workdir, getwd())) 
[13:24:21.010]             setwd(...future.workdir)
[13:24:21.010]         {
[13:24:21.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.010]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.010]             }
[13:24:21.010]             base::options(...future.oldOptions)
[13:24:21.010]             if (.Platform$OS.type == "windows") {
[13:24:21.010]                 old_names <- names(...future.oldEnvVars)
[13:24:21.010]                 envs <- base::Sys.getenv()
[13:24:21.010]                 names <- names(envs)
[13:24:21.010]                 common <- intersect(names, old_names)
[13:24:21.010]                 added <- setdiff(names, old_names)
[13:24:21.010]                 removed <- setdiff(old_names, names)
[13:24:21.010]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.010]                   envs[common]]
[13:24:21.010]                 NAMES <- toupper(changed)
[13:24:21.010]                 args <- list()
[13:24:21.010]                 for (kk in seq_along(NAMES)) {
[13:24:21.010]                   name <- changed[[kk]]
[13:24:21.010]                   NAME <- NAMES[[kk]]
[13:24:21.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.010]                     next
[13:24:21.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.010]                 }
[13:24:21.010]                 NAMES <- toupper(added)
[13:24:21.010]                 for (kk in seq_along(NAMES)) {
[13:24:21.010]                   name <- added[[kk]]
[13:24:21.010]                   NAME <- NAMES[[kk]]
[13:24:21.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.010]                     next
[13:24:21.010]                   args[[name]] <- ""
[13:24:21.010]                 }
[13:24:21.010]                 NAMES <- toupper(removed)
[13:24:21.010]                 for (kk in seq_along(NAMES)) {
[13:24:21.010]                   name <- removed[[kk]]
[13:24:21.010]                   NAME <- NAMES[[kk]]
[13:24:21.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.010]                     next
[13:24:21.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.010]                 }
[13:24:21.010]                 if (length(args) > 0) 
[13:24:21.010]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.010]             }
[13:24:21.010]             else {
[13:24:21.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.010]             }
[13:24:21.010]             {
[13:24:21.010]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.010]                   0L) {
[13:24:21.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.010]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.010]                   base::options(opts)
[13:24:21.010]                 }
[13:24:21.010]                 {
[13:24:21.010]                   {
[13:24:21.010]                     NULL
[13:24:21.010]                     RNGkind("Mersenne-Twister")
[13:24:21.010]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.010]                       inherits = FALSE)
[13:24:21.010]                   }
[13:24:21.010]                   options(future.plan = NULL)
[13:24:21.010]                   if (is.na(NA_character_)) 
[13:24:21.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.010]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.010]                   {
[13:24:21.010]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.010]                     if (!future$lazy) 
[13:24:21.010]                       future <- run(future)
[13:24:21.010]                     invisible(future)
[13:24:21.010]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.010]                 }
[13:24:21.010]             }
[13:24:21.010]         }
[13:24:21.010]     })
[13:24:21.010]     if (TRUE) {
[13:24:21.010]         base::sink(type = "output", split = FALSE)
[13:24:21.010]         if (TRUE) {
[13:24:21.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.010]         }
[13:24:21.010]         else {
[13:24:21.010]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.010]         }
[13:24:21.010]         base::close(...future.stdout)
[13:24:21.010]         ...future.stdout <- NULL
[13:24:21.010]     }
[13:24:21.010]     ...future.result$conditions <- ...future.conditions
[13:24:21.010]     ...future.result$finished <- base::Sys.time()
[13:24:21.010]     ...future.result
[13:24:21.010] }
[13:24:21.012] assign_globals() ...
[13:24:21.012] List of 1
[13:24:21.012]  $ kk: int 1
[13:24:21.012]  - attr(*, "where")=List of 1
[13:24:21.012]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:21.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:21.012]  - attr(*, "resolved")= logi FALSE
[13:24:21.012]  - attr(*, "total_size")= num 56
[13:24:21.012]  - attr(*, "already-done")= logi TRUE
[13:24:21.017] - copied ‘kk’ to environment
[13:24:21.017] assign_globals() ... done
[13:24:21.018] plan(): Setting new future strategy stack:
[13:24:21.018] List of future strategies:
[13:24:21.018] 1. sequential:
[13:24:21.018]    - args: function (..., envir = parent.frame())
[13:24:21.018]    - tweaked: FALSE
[13:24:21.018]    - call: NULL
[13:24:21.018] plan(): nbrOfWorkers() = 1
[13:24:21.119] plan(): Setting new future strategy stack:
[13:24:21.119] List of future strategies:
[13:24:21.119] 1. sequential:
[13:24:21.119]    - args: function (..., envir = parent.frame())
[13:24:21.119]    - tweaked: FALSE
[13:24:21.119]    - call: plan(strategy)
[13:24:21.120] plan(): nbrOfWorkers() = 1
[13:24:21.120] SequentialFuture started (and completed)
[13:24:21.120] - Launch lazy future ... done
[13:24:21.120] run() for ‘SequentialFuture’ ... done
[13:24:21.120] getGlobalsAndPackages() ...
[13:24:21.121] Searching for globals...
[13:24:21.122] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:21.122] Searching for globals ... DONE
[13:24:21.122] Resolving globals: FALSE
[13:24:21.122] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:21.123] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:21.123] - globals: [1] ‘kk’
[13:24:21.123] 
[13:24:21.123] getGlobalsAndPackages() ... DONE
[13:24:21.123] run() for ‘Future’ ...
[13:24:21.123] - state: ‘created’
[13:24:21.123] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.124] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.124]   - Field: ‘label’
[13:24:21.124]   - Field: ‘local’
[13:24:21.124]   - Field: ‘owner’
[13:24:21.124]   - Field: ‘envir’
[13:24:21.124]   - Field: ‘packages’
[13:24:21.124]   - Field: ‘gc’
[13:24:21.124]   - Field: ‘conditions’
[13:24:21.125]   - Field: ‘expr’
[13:24:21.125]   - Field: ‘uuid’
[13:24:21.125]   - Field: ‘seed’
[13:24:21.125]   - Field: ‘version’
[13:24:21.125]   - Field: ‘result’
[13:24:21.125]   - Field: ‘asynchronous’
[13:24:21.125]   - Field: ‘calls’
[13:24:21.125]   - Field: ‘globals’
[13:24:21.125]   - Field: ‘stdout’
[13:24:21.125]   - Field: ‘earlySignal’
[13:24:21.125]   - Field: ‘lazy’
[13:24:21.126]   - Field: ‘state’
[13:24:21.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.126] - Launch lazy future ...
[13:24:21.126] Packages needed by the future expression (n = 0): <none>
[13:24:21.126] Packages needed by future strategies (n = 0): <none>
[13:24:21.126] {
[13:24:21.126]     {
[13:24:21.126]         {
[13:24:21.126]             ...future.startTime <- base::Sys.time()
[13:24:21.126]             {
[13:24:21.126]                 {
[13:24:21.126]                   {
[13:24:21.126]                     base::local({
[13:24:21.126]                       has_future <- base::requireNamespace("future", 
[13:24:21.126]                         quietly = TRUE)
[13:24:21.126]                       if (has_future) {
[13:24:21.126]                         ns <- base::getNamespace("future")
[13:24:21.126]                         version <- ns[[".package"]][["version"]]
[13:24:21.126]                         if (is.null(version)) 
[13:24:21.126]                           version <- utils::packageVersion("future")
[13:24:21.126]                       }
[13:24:21.126]                       else {
[13:24:21.126]                         version <- NULL
[13:24:21.126]                       }
[13:24:21.126]                       if (!has_future || version < "1.8.0") {
[13:24:21.126]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.126]                           "", base::R.version$version.string), 
[13:24:21.126]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.126]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.126]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.126]                             "release", "version")], collapse = " "), 
[13:24:21.126]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.126]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.126]                           info)
[13:24:21.126]                         info <- base::paste(info, collapse = "; ")
[13:24:21.126]                         if (!has_future) {
[13:24:21.126]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.126]                             info)
[13:24:21.126]                         }
[13:24:21.126]                         else {
[13:24:21.126]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.126]                             info, version)
[13:24:21.126]                         }
[13:24:21.126]                         base::stop(msg)
[13:24:21.126]                       }
[13:24:21.126]                     })
[13:24:21.126]                   }
[13:24:21.126]                   options(future.plan = NULL)
[13:24:21.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.126]                 }
[13:24:21.126]                 ...future.workdir <- getwd()
[13:24:21.126]             }
[13:24:21.126]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.126]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.126]         }
[13:24:21.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.126]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.126]             base::names(...future.oldOptions))
[13:24:21.126]     }
[13:24:21.126]     if (FALSE) {
[13:24:21.126]     }
[13:24:21.126]     else {
[13:24:21.126]         if (TRUE) {
[13:24:21.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.126]                 open = "w")
[13:24:21.126]         }
[13:24:21.126]         else {
[13:24:21.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.126]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.126]         }
[13:24:21.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.126]             base::sink(type = "output", split = FALSE)
[13:24:21.126]             base::close(...future.stdout)
[13:24:21.126]         }, add = TRUE)
[13:24:21.126]     }
[13:24:21.126]     ...future.frame <- base::sys.nframe()
[13:24:21.126]     ...future.conditions <- base::list()
[13:24:21.126]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.126]     if (FALSE) {
[13:24:21.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.126]     }
[13:24:21.126]     ...future.result <- base::tryCatch({
[13:24:21.126]         base::withCallingHandlers({
[13:24:21.126]             ...future.value <- base::withVisible(base::local({
[13:24:21.126]                 Sys.sleep(0.1)
[13:24:21.126]                 kk
[13:24:21.126]             }))
[13:24:21.126]             future::FutureResult(value = ...future.value$value, 
[13:24:21.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.126]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.126]                     ...future.globalenv.names))
[13:24:21.126]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.126]         }, condition = base::local({
[13:24:21.126]             c <- base::c
[13:24:21.126]             inherits <- base::inherits
[13:24:21.126]             invokeRestart <- base::invokeRestart
[13:24:21.126]             length <- base::length
[13:24:21.126]             list <- base::list
[13:24:21.126]             seq.int <- base::seq.int
[13:24:21.126]             signalCondition <- base::signalCondition
[13:24:21.126]             sys.calls <- base::sys.calls
[13:24:21.126]             `[[` <- base::`[[`
[13:24:21.126]             `+` <- base::`+`
[13:24:21.126]             `<<-` <- base::`<<-`
[13:24:21.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.126]                   3L)]
[13:24:21.126]             }
[13:24:21.126]             function(cond) {
[13:24:21.126]                 is_error <- inherits(cond, "error")
[13:24:21.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.126]                   NULL)
[13:24:21.126]                 if (is_error) {
[13:24:21.126]                   sessionInformation <- function() {
[13:24:21.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.126]                       search = base::search(), system = base::Sys.info())
[13:24:21.126]                   }
[13:24:21.126]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.126]                     cond$call), session = sessionInformation(), 
[13:24:21.126]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.126]                   signalCondition(cond)
[13:24:21.126]                 }
[13:24:21.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.126]                 "immediateCondition"))) {
[13:24:21.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.126]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.126]                   if (TRUE && !signal) {
[13:24:21.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.126]                     {
[13:24:21.126]                       inherits <- base::inherits
[13:24:21.126]                       invokeRestart <- base::invokeRestart
[13:24:21.126]                       is.null <- base::is.null
[13:24:21.126]                       muffled <- FALSE
[13:24:21.126]                       if (inherits(cond, "message")) {
[13:24:21.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.126]                         if (muffled) 
[13:24:21.126]                           invokeRestart("muffleMessage")
[13:24:21.126]                       }
[13:24:21.126]                       else if (inherits(cond, "warning")) {
[13:24:21.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.126]                         if (muffled) 
[13:24:21.126]                           invokeRestart("muffleWarning")
[13:24:21.126]                       }
[13:24:21.126]                       else if (inherits(cond, "condition")) {
[13:24:21.126]                         if (!is.null(pattern)) {
[13:24:21.126]                           computeRestarts <- base::computeRestarts
[13:24:21.126]                           grepl <- base::grepl
[13:24:21.126]                           restarts <- computeRestarts(cond)
[13:24:21.126]                           for (restart in restarts) {
[13:24:21.126]                             name <- restart$name
[13:24:21.126]                             if (is.null(name)) 
[13:24:21.126]                               next
[13:24:21.126]                             if (!grepl(pattern, name)) 
[13:24:21.126]                               next
[13:24:21.126]                             invokeRestart(restart)
[13:24:21.126]                             muffled <- TRUE
[13:24:21.126]                             break
[13:24:21.126]                           }
[13:24:21.126]                         }
[13:24:21.126]                       }
[13:24:21.126]                       invisible(muffled)
[13:24:21.126]                     }
[13:24:21.126]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.126]                   }
[13:24:21.126]                 }
[13:24:21.126]                 else {
[13:24:21.126]                   if (TRUE) {
[13:24:21.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.126]                     {
[13:24:21.126]                       inherits <- base::inherits
[13:24:21.126]                       invokeRestart <- base::invokeRestart
[13:24:21.126]                       is.null <- base::is.null
[13:24:21.126]                       muffled <- FALSE
[13:24:21.126]                       if (inherits(cond, "message")) {
[13:24:21.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.126]                         if (muffled) 
[13:24:21.126]                           invokeRestart("muffleMessage")
[13:24:21.126]                       }
[13:24:21.126]                       else if (inherits(cond, "warning")) {
[13:24:21.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.126]                         if (muffled) 
[13:24:21.126]                           invokeRestart("muffleWarning")
[13:24:21.126]                       }
[13:24:21.126]                       else if (inherits(cond, "condition")) {
[13:24:21.126]                         if (!is.null(pattern)) {
[13:24:21.126]                           computeRestarts <- base::computeRestarts
[13:24:21.126]                           grepl <- base::grepl
[13:24:21.126]                           restarts <- computeRestarts(cond)
[13:24:21.126]                           for (restart in restarts) {
[13:24:21.126]                             name <- restart$name
[13:24:21.126]                             if (is.null(name)) 
[13:24:21.126]                               next
[13:24:21.126]                             if (!grepl(pattern, name)) 
[13:24:21.126]                               next
[13:24:21.126]                             invokeRestart(restart)
[13:24:21.126]                             muffled <- TRUE
[13:24:21.126]                             break
[13:24:21.126]                           }
[13:24:21.126]                         }
[13:24:21.126]                       }
[13:24:21.126]                       invisible(muffled)
[13:24:21.126]                     }
[13:24:21.126]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.126]                   }
[13:24:21.126]                 }
[13:24:21.126]             }
[13:24:21.126]         }))
[13:24:21.126]     }, error = function(ex) {
[13:24:21.126]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.126]                 ...future.rng), started = ...future.startTime, 
[13:24:21.126]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.126]             version = "1.8"), class = "FutureResult")
[13:24:21.126]     }, finally = {
[13:24:21.126]         if (!identical(...future.workdir, getwd())) 
[13:24:21.126]             setwd(...future.workdir)
[13:24:21.126]         {
[13:24:21.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.126]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.126]             }
[13:24:21.126]             base::options(...future.oldOptions)
[13:24:21.126]             if (.Platform$OS.type == "windows") {
[13:24:21.126]                 old_names <- names(...future.oldEnvVars)
[13:24:21.126]                 envs <- base::Sys.getenv()
[13:24:21.126]                 names <- names(envs)
[13:24:21.126]                 common <- intersect(names, old_names)
[13:24:21.126]                 added <- setdiff(names, old_names)
[13:24:21.126]                 removed <- setdiff(old_names, names)
[13:24:21.126]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.126]                   envs[common]]
[13:24:21.126]                 NAMES <- toupper(changed)
[13:24:21.126]                 args <- list()
[13:24:21.126]                 for (kk in seq_along(NAMES)) {
[13:24:21.126]                   name <- changed[[kk]]
[13:24:21.126]                   NAME <- NAMES[[kk]]
[13:24:21.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.126]                     next
[13:24:21.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.126]                 }
[13:24:21.126]                 NAMES <- toupper(added)
[13:24:21.126]                 for (kk in seq_along(NAMES)) {
[13:24:21.126]                   name <- added[[kk]]
[13:24:21.126]                   NAME <- NAMES[[kk]]
[13:24:21.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.126]                     next
[13:24:21.126]                   args[[name]] <- ""
[13:24:21.126]                 }
[13:24:21.126]                 NAMES <- toupper(removed)
[13:24:21.126]                 for (kk in seq_along(NAMES)) {
[13:24:21.126]                   name <- removed[[kk]]
[13:24:21.126]                   NAME <- NAMES[[kk]]
[13:24:21.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.126]                     next
[13:24:21.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.126]                 }
[13:24:21.126]                 if (length(args) > 0) 
[13:24:21.126]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.126]             }
[13:24:21.126]             else {
[13:24:21.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.126]             }
[13:24:21.126]             {
[13:24:21.126]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.126]                   0L) {
[13:24:21.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.126]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.126]                   base::options(opts)
[13:24:21.126]                 }
[13:24:21.126]                 {
[13:24:21.126]                   {
[13:24:21.126]                     NULL
[13:24:21.126]                     RNGkind("Mersenne-Twister")
[13:24:21.126]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.126]                       inherits = FALSE)
[13:24:21.126]                   }
[13:24:21.126]                   options(future.plan = NULL)
[13:24:21.126]                   if (is.na(NA_character_)) 
[13:24:21.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.126]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.126]                   {
[13:24:21.126]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.126]                     if (!future$lazy) 
[13:24:21.126]                       future <- run(future)
[13:24:21.126]                     invisible(future)
[13:24:21.126]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.126]                 }
[13:24:21.126]             }
[13:24:21.126]         }
[13:24:21.126]     })
[13:24:21.126]     if (TRUE) {
[13:24:21.126]         base::sink(type = "output", split = FALSE)
[13:24:21.126]         if (TRUE) {
[13:24:21.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.126]         }
[13:24:21.126]         else {
[13:24:21.126]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.126]         }
[13:24:21.126]         base::close(...future.stdout)
[13:24:21.126]         ...future.stdout <- NULL
[13:24:21.126]     }
[13:24:21.126]     ...future.result$conditions <- ...future.conditions
[13:24:21.126]     ...future.result$finished <- base::Sys.time()
[13:24:21.126]     ...future.result
[13:24:21.126] }
[13:24:21.128] assign_globals() ...
[13:24:21.128] List of 1
[13:24:21.128]  $ kk: int 2
[13:24:21.128]  - attr(*, "where")=List of 1
[13:24:21.128]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:21.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:21.128]  - attr(*, "resolved")= logi FALSE
[13:24:21.128]  - attr(*, "total_size")= num 56
[13:24:21.128]  - attr(*, "already-done")= logi TRUE
[13:24:21.131] - copied ‘kk’ to environment
[13:24:21.133] assign_globals() ... done
[13:24:21.133] plan(): Setting new future strategy stack:
[13:24:21.133] List of future strategies:
[13:24:21.133] 1. sequential:
[13:24:21.133]    - args: function (..., envir = parent.frame())
[13:24:21.133]    - tweaked: FALSE
[13:24:21.133]    - call: NULL
[13:24:21.134] plan(): nbrOfWorkers() = 1
[13:24:21.235] plan(): Setting new future strategy stack:
[13:24:21.235] List of future strategies:
[13:24:21.235] 1. sequential:
[13:24:21.235]    - args: function (..., envir = parent.frame())
[13:24:21.235]    - tweaked: FALSE
[13:24:21.235]    - call: plan(strategy)
[13:24:21.236] plan(): nbrOfWorkers() = 1
[13:24:21.236] SequentialFuture started (and completed)
[13:24:21.236] - Launch lazy future ... done
[13:24:21.236] run() for ‘SequentialFuture’ ... done
[13:24:21.236] getGlobalsAndPackages() ...
[13:24:21.236] Searching for globals...
[13:24:21.237] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:21.237] Searching for globals ... DONE
[13:24:21.238] Resolving globals: FALSE
[13:24:21.238] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:21.238] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:21.238] - globals: [1] ‘kk’
[13:24:21.239] 
[13:24:21.239] getGlobalsAndPackages() ... DONE
[13:24:21.239] run() for ‘Future’ ...
[13:24:21.239] - state: ‘created’
[13:24:21.239] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.239] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.240]   - Field: ‘label’
[13:24:21.240]   - Field: ‘local’
[13:24:21.240]   - Field: ‘owner’
[13:24:21.240]   - Field: ‘envir’
[13:24:21.240]   - Field: ‘packages’
[13:24:21.240]   - Field: ‘gc’
[13:24:21.240]   - Field: ‘conditions’
[13:24:21.240]   - Field: ‘expr’
[13:24:21.240]   - Field: ‘uuid’
[13:24:21.241]   - Field: ‘seed’
[13:24:21.241]   - Field: ‘version’
[13:24:21.241]   - Field: ‘result’
[13:24:21.241]   - Field: ‘asynchronous’
[13:24:21.241]   - Field: ‘calls’
[13:24:21.241]   - Field: ‘globals’
[13:24:21.241]   - Field: ‘stdout’
[13:24:21.241]   - Field: ‘earlySignal’
[13:24:21.241]   - Field: ‘lazy’
[13:24:21.241]   - Field: ‘state’
[13:24:21.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.242] - Launch lazy future ...
[13:24:21.242] Packages needed by the future expression (n = 0): <none>
[13:24:21.242] Packages needed by future strategies (n = 0): <none>
[13:24:21.242] {
[13:24:21.242]     {
[13:24:21.242]         {
[13:24:21.242]             ...future.startTime <- base::Sys.time()
[13:24:21.242]             {
[13:24:21.242]                 {
[13:24:21.242]                   {
[13:24:21.242]                     base::local({
[13:24:21.242]                       has_future <- base::requireNamespace("future", 
[13:24:21.242]                         quietly = TRUE)
[13:24:21.242]                       if (has_future) {
[13:24:21.242]                         ns <- base::getNamespace("future")
[13:24:21.242]                         version <- ns[[".package"]][["version"]]
[13:24:21.242]                         if (is.null(version)) 
[13:24:21.242]                           version <- utils::packageVersion("future")
[13:24:21.242]                       }
[13:24:21.242]                       else {
[13:24:21.242]                         version <- NULL
[13:24:21.242]                       }
[13:24:21.242]                       if (!has_future || version < "1.8.0") {
[13:24:21.242]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.242]                           "", base::R.version$version.string), 
[13:24:21.242]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.242]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.242]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.242]                             "release", "version")], collapse = " "), 
[13:24:21.242]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.242]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.242]                           info)
[13:24:21.242]                         info <- base::paste(info, collapse = "; ")
[13:24:21.242]                         if (!has_future) {
[13:24:21.242]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.242]                             info)
[13:24:21.242]                         }
[13:24:21.242]                         else {
[13:24:21.242]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.242]                             info, version)
[13:24:21.242]                         }
[13:24:21.242]                         base::stop(msg)
[13:24:21.242]                       }
[13:24:21.242]                     })
[13:24:21.242]                   }
[13:24:21.242]                   options(future.plan = NULL)
[13:24:21.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.242]                 }
[13:24:21.242]                 ...future.workdir <- getwd()
[13:24:21.242]             }
[13:24:21.242]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.242]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.242]         }
[13:24:21.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.242]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.242]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.242]             base::names(...future.oldOptions))
[13:24:21.242]     }
[13:24:21.242]     if (FALSE) {
[13:24:21.242]     }
[13:24:21.242]     else {
[13:24:21.242]         if (TRUE) {
[13:24:21.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.242]                 open = "w")
[13:24:21.242]         }
[13:24:21.242]         else {
[13:24:21.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.242]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.242]         }
[13:24:21.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.242]             base::sink(type = "output", split = FALSE)
[13:24:21.242]             base::close(...future.stdout)
[13:24:21.242]         }, add = TRUE)
[13:24:21.242]     }
[13:24:21.242]     ...future.frame <- base::sys.nframe()
[13:24:21.242]     ...future.conditions <- base::list()
[13:24:21.242]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.242]     if (FALSE) {
[13:24:21.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.242]     }
[13:24:21.242]     ...future.result <- base::tryCatch({
[13:24:21.242]         base::withCallingHandlers({
[13:24:21.242]             ...future.value <- base::withVisible(base::local({
[13:24:21.242]                 Sys.sleep(0.1)
[13:24:21.242]                 kk
[13:24:21.242]             }))
[13:24:21.242]             future::FutureResult(value = ...future.value$value, 
[13:24:21.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.242]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.242]                     ...future.globalenv.names))
[13:24:21.242]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.242]         }, condition = base::local({
[13:24:21.242]             c <- base::c
[13:24:21.242]             inherits <- base::inherits
[13:24:21.242]             invokeRestart <- base::invokeRestart
[13:24:21.242]             length <- base::length
[13:24:21.242]             list <- base::list
[13:24:21.242]             seq.int <- base::seq.int
[13:24:21.242]             signalCondition <- base::signalCondition
[13:24:21.242]             sys.calls <- base::sys.calls
[13:24:21.242]             `[[` <- base::`[[`
[13:24:21.242]             `+` <- base::`+`
[13:24:21.242]             `<<-` <- base::`<<-`
[13:24:21.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.242]                   3L)]
[13:24:21.242]             }
[13:24:21.242]             function(cond) {
[13:24:21.242]                 is_error <- inherits(cond, "error")
[13:24:21.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.242]                   NULL)
[13:24:21.242]                 if (is_error) {
[13:24:21.242]                   sessionInformation <- function() {
[13:24:21.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.242]                       search = base::search(), system = base::Sys.info())
[13:24:21.242]                   }
[13:24:21.242]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.242]                     cond$call), session = sessionInformation(), 
[13:24:21.242]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.242]                   signalCondition(cond)
[13:24:21.242]                 }
[13:24:21.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.242]                 "immediateCondition"))) {
[13:24:21.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.242]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.242]                   if (TRUE && !signal) {
[13:24:21.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.242]                     {
[13:24:21.242]                       inherits <- base::inherits
[13:24:21.242]                       invokeRestart <- base::invokeRestart
[13:24:21.242]                       is.null <- base::is.null
[13:24:21.242]                       muffled <- FALSE
[13:24:21.242]                       if (inherits(cond, "message")) {
[13:24:21.242]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.242]                         if (muffled) 
[13:24:21.242]                           invokeRestart("muffleMessage")
[13:24:21.242]                       }
[13:24:21.242]                       else if (inherits(cond, "warning")) {
[13:24:21.242]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.242]                         if (muffled) 
[13:24:21.242]                           invokeRestart("muffleWarning")
[13:24:21.242]                       }
[13:24:21.242]                       else if (inherits(cond, "condition")) {
[13:24:21.242]                         if (!is.null(pattern)) {
[13:24:21.242]                           computeRestarts <- base::computeRestarts
[13:24:21.242]                           grepl <- base::grepl
[13:24:21.242]                           restarts <- computeRestarts(cond)
[13:24:21.242]                           for (restart in restarts) {
[13:24:21.242]                             name <- restart$name
[13:24:21.242]                             if (is.null(name)) 
[13:24:21.242]                               next
[13:24:21.242]                             if (!grepl(pattern, name)) 
[13:24:21.242]                               next
[13:24:21.242]                             invokeRestart(restart)
[13:24:21.242]                             muffled <- TRUE
[13:24:21.242]                             break
[13:24:21.242]                           }
[13:24:21.242]                         }
[13:24:21.242]                       }
[13:24:21.242]                       invisible(muffled)
[13:24:21.242]                     }
[13:24:21.242]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.242]                   }
[13:24:21.242]                 }
[13:24:21.242]                 else {
[13:24:21.242]                   if (TRUE) {
[13:24:21.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.242]                     {
[13:24:21.242]                       inherits <- base::inherits
[13:24:21.242]                       invokeRestart <- base::invokeRestart
[13:24:21.242]                       is.null <- base::is.null
[13:24:21.242]                       muffled <- FALSE
[13:24:21.242]                       if (inherits(cond, "message")) {
[13:24:21.242]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.242]                         if (muffled) 
[13:24:21.242]                           invokeRestart("muffleMessage")
[13:24:21.242]                       }
[13:24:21.242]                       else if (inherits(cond, "warning")) {
[13:24:21.242]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.242]                         if (muffled) 
[13:24:21.242]                           invokeRestart("muffleWarning")
[13:24:21.242]                       }
[13:24:21.242]                       else if (inherits(cond, "condition")) {
[13:24:21.242]                         if (!is.null(pattern)) {
[13:24:21.242]                           computeRestarts <- base::computeRestarts
[13:24:21.242]                           grepl <- base::grepl
[13:24:21.242]                           restarts <- computeRestarts(cond)
[13:24:21.242]                           for (restart in restarts) {
[13:24:21.242]                             name <- restart$name
[13:24:21.242]                             if (is.null(name)) 
[13:24:21.242]                               next
[13:24:21.242]                             if (!grepl(pattern, name)) 
[13:24:21.242]                               next
[13:24:21.242]                             invokeRestart(restart)
[13:24:21.242]                             muffled <- TRUE
[13:24:21.242]                             break
[13:24:21.242]                           }
[13:24:21.242]                         }
[13:24:21.242]                       }
[13:24:21.242]                       invisible(muffled)
[13:24:21.242]                     }
[13:24:21.242]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.242]                   }
[13:24:21.242]                 }
[13:24:21.242]             }
[13:24:21.242]         }))
[13:24:21.242]     }, error = function(ex) {
[13:24:21.242]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.242]                 ...future.rng), started = ...future.startTime, 
[13:24:21.242]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.242]             version = "1.8"), class = "FutureResult")
[13:24:21.242]     }, finally = {
[13:24:21.242]         if (!identical(...future.workdir, getwd())) 
[13:24:21.242]             setwd(...future.workdir)
[13:24:21.242]         {
[13:24:21.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.242]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.242]             }
[13:24:21.242]             base::options(...future.oldOptions)
[13:24:21.242]             if (.Platform$OS.type == "windows") {
[13:24:21.242]                 old_names <- names(...future.oldEnvVars)
[13:24:21.242]                 envs <- base::Sys.getenv()
[13:24:21.242]                 names <- names(envs)
[13:24:21.242]                 common <- intersect(names, old_names)
[13:24:21.242]                 added <- setdiff(names, old_names)
[13:24:21.242]                 removed <- setdiff(old_names, names)
[13:24:21.242]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.242]                   envs[common]]
[13:24:21.242]                 NAMES <- toupper(changed)
[13:24:21.242]                 args <- list()
[13:24:21.242]                 for (kk in seq_along(NAMES)) {
[13:24:21.242]                   name <- changed[[kk]]
[13:24:21.242]                   NAME <- NAMES[[kk]]
[13:24:21.242]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.242]                     next
[13:24:21.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.242]                 }
[13:24:21.242]                 NAMES <- toupper(added)
[13:24:21.242]                 for (kk in seq_along(NAMES)) {
[13:24:21.242]                   name <- added[[kk]]
[13:24:21.242]                   NAME <- NAMES[[kk]]
[13:24:21.242]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.242]                     next
[13:24:21.242]                   args[[name]] <- ""
[13:24:21.242]                 }
[13:24:21.242]                 NAMES <- toupper(removed)
[13:24:21.242]                 for (kk in seq_along(NAMES)) {
[13:24:21.242]                   name <- removed[[kk]]
[13:24:21.242]                   NAME <- NAMES[[kk]]
[13:24:21.242]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.242]                     next
[13:24:21.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.242]                 }
[13:24:21.242]                 if (length(args) > 0) 
[13:24:21.242]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.242]             }
[13:24:21.242]             else {
[13:24:21.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.242]             }
[13:24:21.242]             {
[13:24:21.242]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.242]                   0L) {
[13:24:21.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.242]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.242]                   base::options(opts)
[13:24:21.242]                 }
[13:24:21.242]                 {
[13:24:21.242]                   {
[13:24:21.242]                     NULL
[13:24:21.242]                     RNGkind("Mersenne-Twister")
[13:24:21.242]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.242]                       inherits = FALSE)
[13:24:21.242]                   }
[13:24:21.242]                   options(future.plan = NULL)
[13:24:21.242]                   if (is.na(NA_character_)) 
[13:24:21.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.242]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.242]                   {
[13:24:21.242]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.242]                     if (!future$lazy) 
[13:24:21.242]                       future <- run(future)
[13:24:21.242]                     invisible(future)
[13:24:21.242]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.242]                 }
[13:24:21.242]             }
[13:24:21.242]         }
[13:24:21.242]     })
[13:24:21.242]     if (TRUE) {
[13:24:21.242]         base::sink(type = "output", split = FALSE)
[13:24:21.242]         if (TRUE) {
[13:24:21.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.242]         }
[13:24:21.242]         else {
[13:24:21.242]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.242]         }
[13:24:21.242]         base::close(...future.stdout)
[13:24:21.242]         ...future.stdout <- NULL
[13:24:21.242]     }
[13:24:21.242]     ...future.result$conditions <- ...future.conditions
[13:24:21.242]     ...future.result$finished <- base::Sys.time()
[13:24:21.242]     ...future.result
[13:24:21.242] }
[13:24:21.244] assign_globals() ...
[13:24:21.244] List of 1
[13:24:21.244]  $ kk: int 3
[13:24:21.244]  - attr(*, "where")=List of 1
[13:24:21.244]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:21.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:21.244]  - attr(*, "resolved")= logi FALSE
[13:24:21.244]  - attr(*, "total_size")= num 56
[13:24:21.244]  - attr(*, "already-done")= logi TRUE
[13:24:21.247] - copied ‘kk’ to environment
[13:24:21.247] assign_globals() ... done
[13:24:21.247] plan(): Setting new future strategy stack:
[13:24:21.247] List of future strategies:
[13:24:21.247] 1. sequential:
[13:24:21.247]    - args: function (..., envir = parent.frame())
[13:24:21.247]    - tweaked: FALSE
[13:24:21.247]    - call: NULL
[13:24:21.247] plan(): nbrOfWorkers() = 1
[13:24:21.349] plan(): Setting new future strategy stack:
[13:24:21.349] List of future strategies:
[13:24:21.349] 1. sequential:
[13:24:21.349]    - args: function (..., envir = parent.frame())
[13:24:21.349]    - tweaked: FALSE
[13:24:21.349]    - call: plan(strategy)
[13:24:21.349] plan(): nbrOfWorkers() = 1
[13:24:21.350] SequentialFuture started (and completed)
[13:24:21.350] - Launch lazy future ... done
[13:24:21.350] run() for ‘SequentialFuture’ ... done
[13:24:21.350] resolve() on list ...
[13:24:21.350]  recursive: 0
[13:24:21.350]  length: 3
[13:24:21.350] 
[13:24:21.350] resolved() for ‘SequentialFuture’ ...
[13:24:21.350] - state: ‘finished’
[13:24:21.351] - run: TRUE
[13:24:21.351] - result: ‘FutureResult’
[13:24:21.351] resolved() for ‘SequentialFuture’ ... done
[13:24:21.351] Future #1
[13:24:21.351]  length: 2 (resolved future 1)
[13:24:21.351] resolved() for ‘SequentialFuture’ ...
[13:24:21.351] - state: ‘finished’
[13:24:21.351] - run: TRUE
[13:24:21.351] - result: ‘FutureResult’
[13:24:21.351] resolved() for ‘SequentialFuture’ ... done
[13:24:21.351] Future #2
[13:24:21.352]  length: 1 (resolved future 2)
[13:24:21.352] resolved() for ‘SequentialFuture’ ...
[13:24:21.352] - state: ‘finished’
[13:24:21.352] - run: TRUE
[13:24:21.352] - result: ‘FutureResult’
[13:24:21.352] resolved() for ‘SequentialFuture’ ... done
[13:24:21.352] Future #3
[13:24:21.352]  length: 0 (resolved future 3)
[13:24:21.352] resolve() on list ... DONE
[13:24:21.352] getGlobalsAndPackages() ...
[13:24:21.353] Searching for globals...
[13:24:21.354] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:21.354] Searching for globals ... DONE
[13:24:21.354] Resolving globals: FALSE
[13:24:21.354] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:21.355] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:21.355] - globals: [1] ‘kk’
[13:24:21.355] 
[13:24:21.355] getGlobalsAndPackages() ... DONE
[13:24:21.355] getGlobalsAndPackages() ...
[13:24:21.355] Searching for globals...
[13:24:21.356] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:21.356] Searching for globals ... DONE
[13:24:21.356] Resolving globals: FALSE
[13:24:21.357] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:21.357] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:21.357] - globals: [1] ‘kk’
[13:24:21.357] 
[13:24:21.357] getGlobalsAndPackages() ... DONE
[13:24:21.358] getGlobalsAndPackages() ...
[13:24:21.358] Searching for globals...
[13:24:21.359] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:21.359] Searching for globals ... DONE
[13:24:21.359] Resolving globals: FALSE
[13:24:21.359] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:21.359] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:21.360] - globals: [1] ‘kk’
[13:24:21.360] 
[13:24:21.360] getGlobalsAndPackages() ... DONE
[13:24:21.360] resolve() on list ...
[13:24:21.360]  recursive: 0
[13:24:21.360]  length: 3
[13:24:21.360] 
[13:24:21.360] run() for ‘Future’ ...
[13:24:21.361] - state: ‘created’
[13:24:21.361] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.363] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.363] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.363]   - Field: ‘label’
[13:24:21.363]   - Field: ‘local’
[13:24:21.363]   - Field: ‘owner’
[13:24:21.363]   - Field: ‘envir’
[13:24:21.363]   - Field: ‘packages’
[13:24:21.363]   - Field: ‘gc’
[13:24:21.363]   - Field: ‘conditions’
[13:24:21.363]   - Field: ‘expr’
[13:24:21.364]   - Field: ‘uuid’
[13:24:21.364]   - Field: ‘seed’
[13:24:21.364]   - Field: ‘version’
[13:24:21.364]   - Field: ‘result’
[13:24:21.364]   - Field: ‘asynchronous’
[13:24:21.364]   - Field: ‘calls’
[13:24:21.364]   - Field: ‘globals’
[13:24:21.364]   - Field: ‘stdout’
[13:24:21.364]   - Field: ‘earlySignal’
[13:24:21.364]   - Field: ‘lazy’
[13:24:21.365]   - Field: ‘state’
[13:24:21.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.365] - Launch lazy future ...
[13:24:21.365] Packages needed by the future expression (n = 0): <none>
[13:24:21.365] Packages needed by future strategies (n = 0): <none>
[13:24:21.365] {
[13:24:21.365]     {
[13:24:21.365]         {
[13:24:21.365]             ...future.startTime <- base::Sys.time()
[13:24:21.365]             {
[13:24:21.365]                 {
[13:24:21.365]                   {
[13:24:21.365]                     base::local({
[13:24:21.365]                       has_future <- base::requireNamespace("future", 
[13:24:21.365]                         quietly = TRUE)
[13:24:21.365]                       if (has_future) {
[13:24:21.365]                         ns <- base::getNamespace("future")
[13:24:21.365]                         version <- ns[[".package"]][["version"]]
[13:24:21.365]                         if (is.null(version)) 
[13:24:21.365]                           version <- utils::packageVersion("future")
[13:24:21.365]                       }
[13:24:21.365]                       else {
[13:24:21.365]                         version <- NULL
[13:24:21.365]                       }
[13:24:21.365]                       if (!has_future || version < "1.8.0") {
[13:24:21.365]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.365]                           "", base::R.version$version.string), 
[13:24:21.365]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.365]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.365]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.365]                             "release", "version")], collapse = " "), 
[13:24:21.365]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.365]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.365]                           info)
[13:24:21.365]                         info <- base::paste(info, collapse = "; ")
[13:24:21.365]                         if (!has_future) {
[13:24:21.365]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.365]                             info)
[13:24:21.365]                         }
[13:24:21.365]                         else {
[13:24:21.365]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.365]                             info, version)
[13:24:21.365]                         }
[13:24:21.365]                         base::stop(msg)
[13:24:21.365]                       }
[13:24:21.365]                     })
[13:24:21.365]                   }
[13:24:21.365]                   options(future.plan = NULL)
[13:24:21.365]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.365]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.365]                 }
[13:24:21.365]                 ...future.workdir <- getwd()
[13:24:21.365]             }
[13:24:21.365]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.365]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.365]         }
[13:24:21.365]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.365]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.365]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.365]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.365]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.365]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.365]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.365]             base::names(...future.oldOptions))
[13:24:21.365]     }
[13:24:21.365]     if (FALSE) {
[13:24:21.365]     }
[13:24:21.365]     else {
[13:24:21.365]         if (TRUE) {
[13:24:21.365]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.365]                 open = "w")
[13:24:21.365]         }
[13:24:21.365]         else {
[13:24:21.365]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.365]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.365]         }
[13:24:21.365]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.365]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.365]             base::sink(type = "output", split = FALSE)
[13:24:21.365]             base::close(...future.stdout)
[13:24:21.365]         }, add = TRUE)
[13:24:21.365]     }
[13:24:21.365]     ...future.frame <- base::sys.nframe()
[13:24:21.365]     ...future.conditions <- base::list()
[13:24:21.365]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.365]     if (FALSE) {
[13:24:21.365]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.365]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.365]     }
[13:24:21.365]     ...future.result <- base::tryCatch({
[13:24:21.365]         base::withCallingHandlers({
[13:24:21.365]             ...future.value <- base::withVisible(base::local({
[13:24:21.365]                 Sys.sleep(0.1)
[13:24:21.365]                 kk
[13:24:21.365]             }))
[13:24:21.365]             future::FutureResult(value = ...future.value$value, 
[13:24:21.365]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.365]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.365]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.365]                     ...future.globalenv.names))
[13:24:21.365]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.365]         }, condition = base::local({
[13:24:21.365]             c <- base::c
[13:24:21.365]             inherits <- base::inherits
[13:24:21.365]             invokeRestart <- base::invokeRestart
[13:24:21.365]             length <- base::length
[13:24:21.365]             list <- base::list
[13:24:21.365]             seq.int <- base::seq.int
[13:24:21.365]             signalCondition <- base::signalCondition
[13:24:21.365]             sys.calls <- base::sys.calls
[13:24:21.365]             `[[` <- base::`[[`
[13:24:21.365]             `+` <- base::`+`
[13:24:21.365]             `<<-` <- base::`<<-`
[13:24:21.365]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.365]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.365]                   3L)]
[13:24:21.365]             }
[13:24:21.365]             function(cond) {
[13:24:21.365]                 is_error <- inherits(cond, "error")
[13:24:21.365]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.365]                   NULL)
[13:24:21.365]                 if (is_error) {
[13:24:21.365]                   sessionInformation <- function() {
[13:24:21.365]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.365]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.365]                       search = base::search(), system = base::Sys.info())
[13:24:21.365]                   }
[13:24:21.365]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.365]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.365]                     cond$call), session = sessionInformation(), 
[13:24:21.365]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.365]                   signalCondition(cond)
[13:24:21.365]                 }
[13:24:21.365]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.365]                 "immediateCondition"))) {
[13:24:21.365]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.365]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.365]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.365]                   if (TRUE && !signal) {
[13:24:21.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.365]                     {
[13:24:21.365]                       inherits <- base::inherits
[13:24:21.365]                       invokeRestart <- base::invokeRestart
[13:24:21.365]                       is.null <- base::is.null
[13:24:21.365]                       muffled <- FALSE
[13:24:21.365]                       if (inherits(cond, "message")) {
[13:24:21.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.365]                         if (muffled) 
[13:24:21.365]                           invokeRestart("muffleMessage")
[13:24:21.365]                       }
[13:24:21.365]                       else if (inherits(cond, "warning")) {
[13:24:21.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.365]                         if (muffled) 
[13:24:21.365]                           invokeRestart("muffleWarning")
[13:24:21.365]                       }
[13:24:21.365]                       else if (inherits(cond, "condition")) {
[13:24:21.365]                         if (!is.null(pattern)) {
[13:24:21.365]                           computeRestarts <- base::computeRestarts
[13:24:21.365]                           grepl <- base::grepl
[13:24:21.365]                           restarts <- computeRestarts(cond)
[13:24:21.365]                           for (restart in restarts) {
[13:24:21.365]                             name <- restart$name
[13:24:21.365]                             if (is.null(name)) 
[13:24:21.365]                               next
[13:24:21.365]                             if (!grepl(pattern, name)) 
[13:24:21.365]                               next
[13:24:21.365]                             invokeRestart(restart)
[13:24:21.365]                             muffled <- TRUE
[13:24:21.365]                             break
[13:24:21.365]                           }
[13:24:21.365]                         }
[13:24:21.365]                       }
[13:24:21.365]                       invisible(muffled)
[13:24:21.365]                     }
[13:24:21.365]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.365]                   }
[13:24:21.365]                 }
[13:24:21.365]                 else {
[13:24:21.365]                   if (TRUE) {
[13:24:21.365]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.365]                     {
[13:24:21.365]                       inherits <- base::inherits
[13:24:21.365]                       invokeRestart <- base::invokeRestart
[13:24:21.365]                       is.null <- base::is.null
[13:24:21.365]                       muffled <- FALSE
[13:24:21.365]                       if (inherits(cond, "message")) {
[13:24:21.365]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.365]                         if (muffled) 
[13:24:21.365]                           invokeRestart("muffleMessage")
[13:24:21.365]                       }
[13:24:21.365]                       else if (inherits(cond, "warning")) {
[13:24:21.365]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.365]                         if (muffled) 
[13:24:21.365]                           invokeRestart("muffleWarning")
[13:24:21.365]                       }
[13:24:21.365]                       else if (inherits(cond, "condition")) {
[13:24:21.365]                         if (!is.null(pattern)) {
[13:24:21.365]                           computeRestarts <- base::computeRestarts
[13:24:21.365]                           grepl <- base::grepl
[13:24:21.365]                           restarts <- computeRestarts(cond)
[13:24:21.365]                           for (restart in restarts) {
[13:24:21.365]                             name <- restart$name
[13:24:21.365]                             if (is.null(name)) 
[13:24:21.365]                               next
[13:24:21.365]                             if (!grepl(pattern, name)) 
[13:24:21.365]                               next
[13:24:21.365]                             invokeRestart(restart)
[13:24:21.365]                             muffled <- TRUE
[13:24:21.365]                             break
[13:24:21.365]                           }
[13:24:21.365]                         }
[13:24:21.365]                       }
[13:24:21.365]                       invisible(muffled)
[13:24:21.365]                     }
[13:24:21.365]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.365]                   }
[13:24:21.365]                 }
[13:24:21.365]             }
[13:24:21.365]         }))
[13:24:21.365]     }, error = function(ex) {
[13:24:21.365]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.365]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.365]                 ...future.rng), started = ...future.startTime, 
[13:24:21.365]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.365]             version = "1.8"), class = "FutureResult")
[13:24:21.365]     }, finally = {
[13:24:21.365]         if (!identical(...future.workdir, getwd())) 
[13:24:21.365]             setwd(...future.workdir)
[13:24:21.365]         {
[13:24:21.365]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.365]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.365]             }
[13:24:21.365]             base::options(...future.oldOptions)
[13:24:21.365]             if (.Platform$OS.type == "windows") {
[13:24:21.365]                 old_names <- names(...future.oldEnvVars)
[13:24:21.365]                 envs <- base::Sys.getenv()
[13:24:21.365]                 names <- names(envs)
[13:24:21.365]                 common <- intersect(names, old_names)
[13:24:21.365]                 added <- setdiff(names, old_names)
[13:24:21.365]                 removed <- setdiff(old_names, names)
[13:24:21.365]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.365]                   envs[common]]
[13:24:21.365]                 NAMES <- toupper(changed)
[13:24:21.365]                 args <- list()
[13:24:21.365]                 for (kk in seq_along(NAMES)) {
[13:24:21.365]                   name <- changed[[kk]]
[13:24:21.365]                   NAME <- NAMES[[kk]]
[13:24:21.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.365]                     next
[13:24:21.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.365]                 }
[13:24:21.365]                 NAMES <- toupper(added)
[13:24:21.365]                 for (kk in seq_along(NAMES)) {
[13:24:21.365]                   name <- added[[kk]]
[13:24:21.365]                   NAME <- NAMES[[kk]]
[13:24:21.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.365]                     next
[13:24:21.365]                   args[[name]] <- ""
[13:24:21.365]                 }
[13:24:21.365]                 NAMES <- toupper(removed)
[13:24:21.365]                 for (kk in seq_along(NAMES)) {
[13:24:21.365]                   name <- removed[[kk]]
[13:24:21.365]                   NAME <- NAMES[[kk]]
[13:24:21.365]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.365]                     next
[13:24:21.365]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.365]                 }
[13:24:21.365]                 if (length(args) > 0) 
[13:24:21.365]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.365]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.365]             }
[13:24:21.365]             else {
[13:24:21.365]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.365]             }
[13:24:21.365]             {
[13:24:21.365]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.365]                   0L) {
[13:24:21.365]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.365]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.365]                   base::options(opts)
[13:24:21.365]                 }
[13:24:21.365]                 {
[13:24:21.365]                   {
[13:24:21.365]                     NULL
[13:24:21.365]                     RNGkind("Mersenne-Twister")
[13:24:21.365]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.365]                       inherits = FALSE)
[13:24:21.365]                   }
[13:24:21.365]                   options(future.plan = NULL)
[13:24:21.365]                   if (is.na(NA_character_)) 
[13:24:21.365]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.365]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.365]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.365]                   {
[13:24:21.365]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.365]                     if (!future$lazy) 
[13:24:21.365]                       future <- run(future)
[13:24:21.365]                     invisible(future)
[13:24:21.365]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.365]                 }
[13:24:21.365]             }
[13:24:21.365]         }
[13:24:21.365]     })
[13:24:21.365]     if (TRUE) {
[13:24:21.365]         base::sink(type = "output", split = FALSE)
[13:24:21.365]         if (TRUE) {
[13:24:21.365]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.365]         }
[13:24:21.365]         else {
[13:24:21.365]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.365]         }
[13:24:21.365]         base::close(...future.stdout)
[13:24:21.365]         ...future.stdout <- NULL
[13:24:21.365]     }
[13:24:21.365]     ...future.result$conditions <- ...future.conditions
[13:24:21.365]     ...future.result$finished <- base::Sys.time()
[13:24:21.365]     ...future.result
[13:24:21.365] }
[13:24:21.367] assign_globals() ...
[13:24:21.367] List of 1
[13:24:21.367]  $ kk: int 1
[13:24:21.367]  - attr(*, "where")=List of 1
[13:24:21.367]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:21.367]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:21.367]  - attr(*, "resolved")= logi FALSE
[13:24:21.367]  - attr(*, "total_size")= num 56
[13:24:21.367]  - attr(*, "already-done")= logi TRUE
[13:24:21.370] - copied ‘kk’ to environment
[13:24:21.370] assign_globals() ... done
[13:24:21.370] plan(): Setting new future strategy stack:
[13:24:21.370] List of future strategies:
[13:24:21.370] 1. sequential:
[13:24:21.370]    - args: function (..., envir = parent.frame())
[13:24:21.370]    - tweaked: FALSE
[13:24:21.370]    - call: NULL
[13:24:21.371] plan(): nbrOfWorkers() = 1
[13:24:21.472] plan(): Setting new future strategy stack:
[13:24:21.472] List of future strategies:
[13:24:21.472] 1. sequential:
[13:24:21.472]    - args: function (..., envir = parent.frame())
[13:24:21.472]    - tweaked: FALSE
[13:24:21.472]    - call: plan(strategy)
[13:24:21.472] plan(): nbrOfWorkers() = 1
[13:24:21.473] SequentialFuture started (and completed)
[13:24:21.473] - Launch lazy future ... done
[13:24:21.473] run() for ‘SequentialFuture’ ... done
[13:24:21.473] resolved() for ‘SequentialFuture’ ...
[13:24:21.473] - state: ‘finished’
[13:24:21.473] - run: TRUE
[13:24:21.473] - result: ‘FutureResult’
[13:24:21.473] resolved() for ‘SequentialFuture’ ... done
[13:24:21.473] Future #1
[13:24:21.474]  length: 2 (resolved future 1)
[13:24:21.474] run() for ‘Future’ ...
[13:24:21.474] - state: ‘created’
[13:24:21.474] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.474] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.475]   - Field: ‘label’
[13:24:21.475]   - Field: ‘local’
[13:24:21.475]   - Field: ‘owner’
[13:24:21.475]   - Field: ‘envir’
[13:24:21.475]   - Field: ‘packages’
[13:24:21.475]   - Field: ‘gc’
[13:24:21.475]   - Field: ‘conditions’
[13:24:21.475]   - Field: ‘expr’
[13:24:21.475]   - Field: ‘uuid’
[13:24:21.475]   - Field: ‘seed’
[13:24:21.475]   - Field: ‘version’
[13:24:21.476]   - Field: ‘result’
[13:24:21.476]   - Field: ‘asynchronous’
[13:24:21.476]   - Field: ‘calls’
[13:24:21.476]   - Field: ‘globals’
[13:24:21.476]   - Field: ‘stdout’
[13:24:21.476]   - Field: ‘earlySignal’
[13:24:21.476]   - Field: ‘lazy’
[13:24:21.476]   - Field: ‘state’
[13:24:21.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.476] - Launch lazy future ...
[13:24:21.477] Packages needed by the future expression (n = 0): <none>
[13:24:21.477] Packages needed by future strategies (n = 0): <none>
[13:24:21.477] {
[13:24:21.477]     {
[13:24:21.477]         {
[13:24:21.477]             ...future.startTime <- base::Sys.time()
[13:24:21.477]             {
[13:24:21.477]                 {
[13:24:21.477]                   {
[13:24:21.477]                     base::local({
[13:24:21.477]                       has_future <- base::requireNamespace("future", 
[13:24:21.477]                         quietly = TRUE)
[13:24:21.477]                       if (has_future) {
[13:24:21.477]                         ns <- base::getNamespace("future")
[13:24:21.477]                         version <- ns[[".package"]][["version"]]
[13:24:21.477]                         if (is.null(version)) 
[13:24:21.477]                           version <- utils::packageVersion("future")
[13:24:21.477]                       }
[13:24:21.477]                       else {
[13:24:21.477]                         version <- NULL
[13:24:21.477]                       }
[13:24:21.477]                       if (!has_future || version < "1.8.0") {
[13:24:21.477]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.477]                           "", base::R.version$version.string), 
[13:24:21.477]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.477]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.477]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.477]                             "release", "version")], collapse = " "), 
[13:24:21.477]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.477]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.477]                           info)
[13:24:21.477]                         info <- base::paste(info, collapse = "; ")
[13:24:21.477]                         if (!has_future) {
[13:24:21.477]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.477]                             info)
[13:24:21.477]                         }
[13:24:21.477]                         else {
[13:24:21.477]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.477]                             info, version)
[13:24:21.477]                         }
[13:24:21.477]                         base::stop(msg)
[13:24:21.477]                       }
[13:24:21.477]                     })
[13:24:21.477]                   }
[13:24:21.477]                   options(future.plan = NULL)
[13:24:21.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.477]                 }
[13:24:21.477]                 ...future.workdir <- getwd()
[13:24:21.477]             }
[13:24:21.477]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.477]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.477]         }
[13:24:21.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.477]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.477]             base::names(...future.oldOptions))
[13:24:21.477]     }
[13:24:21.477]     if (FALSE) {
[13:24:21.477]     }
[13:24:21.477]     else {
[13:24:21.477]         if (TRUE) {
[13:24:21.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.477]                 open = "w")
[13:24:21.477]         }
[13:24:21.477]         else {
[13:24:21.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.477]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.477]         }
[13:24:21.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.477]             base::sink(type = "output", split = FALSE)
[13:24:21.477]             base::close(...future.stdout)
[13:24:21.477]         }, add = TRUE)
[13:24:21.477]     }
[13:24:21.477]     ...future.frame <- base::sys.nframe()
[13:24:21.477]     ...future.conditions <- base::list()
[13:24:21.477]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.477]     if (FALSE) {
[13:24:21.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.477]     }
[13:24:21.477]     ...future.result <- base::tryCatch({
[13:24:21.477]         base::withCallingHandlers({
[13:24:21.477]             ...future.value <- base::withVisible(base::local({
[13:24:21.477]                 Sys.sleep(0.1)
[13:24:21.477]                 kk
[13:24:21.477]             }))
[13:24:21.477]             future::FutureResult(value = ...future.value$value, 
[13:24:21.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.477]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.477]                     ...future.globalenv.names))
[13:24:21.477]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.477]         }, condition = base::local({
[13:24:21.477]             c <- base::c
[13:24:21.477]             inherits <- base::inherits
[13:24:21.477]             invokeRestart <- base::invokeRestart
[13:24:21.477]             length <- base::length
[13:24:21.477]             list <- base::list
[13:24:21.477]             seq.int <- base::seq.int
[13:24:21.477]             signalCondition <- base::signalCondition
[13:24:21.477]             sys.calls <- base::sys.calls
[13:24:21.477]             `[[` <- base::`[[`
[13:24:21.477]             `+` <- base::`+`
[13:24:21.477]             `<<-` <- base::`<<-`
[13:24:21.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.477]                   3L)]
[13:24:21.477]             }
[13:24:21.477]             function(cond) {
[13:24:21.477]                 is_error <- inherits(cond, "error")
[13:24:21.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.477]                   NULL)
[13:24:21.477]                 if (is_error) {
[13:24:21.477]                   sessionInformation <- function() {
[13:24:21.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.477]                       search = base::search(), system = base::Sys.info())
[13:24:21.477]                   }
[13:24:21.477]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.477]                     cond$call), session = sessionInformation(), 
[13:24:21.477]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.477]                   signalCondition(cond)
[13:24:21.477]                 }
[13:24:21.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.477]                 "immediateCondition"))) {
[13:24:21.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.477]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.477]                   if (TRUE && !signal) {
[13:24:21.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.477]                     {
[13:24:21.477]                       inherits <- base::inherits
[13:24:21.477]                       invokeRestart <- base::invokeRestart
[13:24:21.477]                       is.null <- base::is.null
[13:24:21.477]                       muffled <- FALSE
[13:24:21.477]                       if (inherits(cond, "message")) {
[13:24:21.477]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.477]                         if (muffled) 
[13:24:21.477]                           invokeRestart("muffleMessage")
[13:24:21.477]                       }
[13:24:21.477]                       else if (inherits(cond, "warning")) {
[13:24:21.477]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.477]                         if (muffled) 
[13:24:21.477]                           invokeRestart("muffleWarning")
[13:24:21.477]                       }
[13:24:21.477]                       else if (inherits(cond, "condition")) {
[13:24:21.477]                         if (!is.null(pattern)) {
[13:24:21.477]                           computeRestarts <- base::computeRestarts
[13:24:21.477]                           grepl <- base::grepl
[13:24:21.477]                           restarts <- computeRestarts(cond)
[13:24:21.477]                           for (restart in restarts) {
[13:24:21.477]                             name <- restart$name
[13:24:21.477]                             if (is.null(name)) 
[13:24:21.477]                               next
[13:24:21.477]                             if (!grepl(pattern, name)) 
[13:24:21.477]                               next
[13:24:21.477]                             invokeRestart(restart)
[13:24:21.477]                             muffled <- TRUE
[13:24:21.477]                             break
[13:24:21.477]                           }
[13:24:21.477]                         }
[13:24:21.477]                       }
[13:24:21.477]                       invisible(muffled)
[13:24:21.477]                     }
[13:24:21.477]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.477]                   }
[13:24:21.477]                 }
[13:24:21.477]                 else {
[13:24:21.477]                   if (TRUE) {
[13:24:21.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.477]                     {
[13:24:21.477]                       inherits <- base::inherits
[13:24:21.477]                       invokeRestart <- base::invokeRestart
[13:24:21.477]                       is.null <- base::is.null
[13:24:21.477]                       muffled <- FALSE
[13:24:21.477]                       if (inherits(cond, "message")) {
[13:24:21.477]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.477]                         if (muffled) 
[13:24:21.477]                           invokeRestart("muffleMessage")
[13:24:21.477]                       }
[13:24:21.477]                       else if (inherits(cond, "warning")) {
[13:24:21.477]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.477]                         if (muffled) 
[13:24:21.477]                           invokeRestart("muffleWarning")
[13:24:21.477]                       }
[13:24:21.477]                       else if (inherits(cond, "condition")) {
[13:24:21.477]                         if (!is.null(pattern)) {
[13:24:21.477]                           computeRestarts <- base::computeRestarts
[13:24:21.477]                           grepl <- base::grepl
[13:24:21.477]                           restarts <- computeRestarts(cond)
[13:24:21.477]                           for (restart in restarts) {
[13:24:21.477]                             name <- restart$name
[13:24:21.477]                             if (is.null(name)) 
[13:24:21.477]                               next
[13:24:21.477]                             if (!grepl(pattern, name)) 
[13:24:21.477]                               next
[13:24:21.477]                             invokeRestart(restart)
[13:24:21.477]                             muffled <- TRUE
[13:24:21.477]                             break
[13:24:21.477]                           }
[13:24:21.477]                         }
[13:24:21.477]                       }
[13:24:21.477]                       invisible(muffled)
[13:24:21.477]                     }
[13:24:21.477]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.477]                   }
[13:24:21.477]                 }
[13:24:21.477]             }
[13:24:21.477]         }))
[13:24:21.477]     }, error = function(ex) {
[13:24:21.477]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.477]                 ...future.rng), started = ...future.startTime, 
[13:24:21.477]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.477]             version = "1.8"), class = "FutureResult")
[13:24:21.477]     }, finally = {
[13:24:21.477]         if (!identical(...future.workdir, getwd())) 
[13:24:21.477]             setwd(...future.workdir)
[13:24:21.477]         {
[13:24:21.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.477]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.477]             }
[13:24:21.477]             base::options(...future.oldOptions)
[13:24:21.477]             if (.Platform$OS.type == "windows") {
[13:24:21.477]                 old_names <- names(...future.oldEnvVars)
[13:24:21.477]                 envs <- base::Sys.getenv()
[13:24:21.477]                 names <- names(envs)
[13:24:21.477]                 common <- intersect(names, old_names)
[13:24:21.477]                 added <- setdiff(names, old_names)
[13:24:21.477]                 removed <- setdiff(old_names, names)
[13:24:21.477]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.477]                   envs[common]]
[13:24:21.477]                 NAMES <- toupper(changed)
[13:24:21.477]                 args <- list()
[13:24:21.477]                 for (kk in seq_along(NAMES)) {
[13:24:21.477]                   name <- changed[[kk]]
[13:24:21.477]                   NAME <- NAMES[[kk]]
[13:24:21.477]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.477]                     next
[13:24:21.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.477]                 }
[13:24:21.477]                 NAMES <- toupper(added)
[13:24:21.477]                 for (kk in seq_along(NAMES)) {
[13:24:21.477]                   name <- added[[kk]]
[13:24:21.477]                   NAME <- NAMES[[kk]]
[13:24:21.477]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.477]                     next
[13:24:21.477]                   args[[name]] <- ""
[13:24:21.477]                 }
[13:24:21.477]                 NAMES <- toupper(removed)
[13:24:21.477]                 for (kk in seq_along(NAMES)) {
[13:24:21.477]                   name <- removed[[kk]]
[13:24:21.477]                   NAME <- NAMES[[kk]]
[13:24:21.477]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.477]                     next
[13:24:21.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.477]                 }
[13:24:21.477]                 if (length(args) > 0) 
[13:24:21.477]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.477]             }
[13:24:21.477]             else {
[13:24:21.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.477]             }
[13:24:21.477]             {
[13:24:21.477]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.477]                   0L) {
[13:24:21.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.477]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.477]                   base::options(opts)
[13:24:21.477]                 }
[13:24:21.477]                 {
[13:24:21.477]                   {
[13:24:21.477]                     NULL
[13:24:21.477]                     RNGkind("Mersenne-Twister")
[13:24:21.477]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.477]                       inherits = FALSE)
[13:24:21.477]                   }
[13:24:21.477]                   options(future.plan = NULL)
[13:24:21.477]                   if (is.na(NA_character_)) 
[13:24:21.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.477]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.477]                   {
[13:24:21.477]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.477]                     if (!future$lazy) 
[13:24:21.477]                       future <- run(future)
[13:24:21.477]                     invisible(future)
[13:24:21.477]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.477]                 }
[13:24:21.477]             }
[13:24:21.477]         }
[13:24:21.477]     })
[13:24:21.477]     if (TRUE) {
[13:24:21.477]         base::sink(type = "output", split = FALSE)
[13:24:21.477]         if (TRUE) {
[13:24:21.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.477]         }
[13:24:21.477]         else {
[13:24:21.477]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.477]         }
[13:24:21.477]         base::close(...future.stdout)
[13:24:21.477]         ...future.stdout <- NULL
[13:24:21.477]     }
[13:24:21.477]     ...future.result$conditions <- ...future.conditions
[13:24:21.477]     ...future.result$finished <- base::Sys.time()
[13:24:21.477]     ...future.result
[13:24:21.477] }
[13:24:21.479] assign_globals() ...
[13:24:21.479] List of 1
[13:24:21.479]  $ kk: int 2
[13:24:21.479]  - attr(*, "where")=List of 1
[13:24:21.479]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:21.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:21.479]  - attr(*, "resolved")= logi FALSE
[13:24:21.479]  - attr(*, "total_size")= num 56
[13:24:21.479]  - attr(*, "already-done")= logi TRUE
[13:24:21.482] - copied ‘kk’ to environment
[13:24:21.482] assign_globals() ... done
[13:24:21.482] plan(): Setting new future strategy stack:
[13:24:21.482] List of future strategies:
[13:24:21.482] 1. sequential:
[13:24:21.482]    - args: function (..., envir = parent.frame())
[13:24:21.482]    - tweaked: FALSE
[13:24:21.482]    - call: NULL
[13:24:21.482] plan(): nbrOfWorkers() = 1
[13:24:21.584] plan(): Setting new future strategy stack:
[13:24:21.584] List of future strategies:
[13:24:21.584] 1. sequential:
[13:24:21.584]    - args: function (..., envir = parent.frame())
[13:24:21.584]    - tweaked: FALSE
[13:24:21.584]    - call: plan(strategy)
[13:24:21.584] plan(): nbrOfWorkers() = 1
[13:24:21.585] SequentialFuture started (and completed)
[13:24:21.585] - Launch lazy future ... done
[13:24:21.585] run() for ‘SequentialFuture’ ... done
[13:24:21.585] resolved() for ‘SequentialFuture’ ...
[13:24:21.585] - state: ‘finished’
[13:24:21.585] - run: TRUE
[13:24:21.585] - result: ‘FutureResult’
[13:24:21.585] resolved() for ‘SequentialFuture’ ... done
[13:24:21.585] Future #2
[13:24:21.585]  length: 1 (resolved future 2)
[13:24:21.586] run() for ‘Future’ ...
[13:24:21.586] - state: ‘created’
[13:24:21.586] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.586] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.586] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.586]   - Field: ‘label’
[13:24:21.587]   - Field: ‘local’
[13:24:21.587]   - Field: ‘owner’
[13:24:21.587]   - Field: ‘envir’
[13:24:21.587]   - Field: ‘packages’
[13:24:21.587]   - Field: ‘gc’
[13:24:21.587]   - Field: ‘conditions’
[13:24:21.587]   - Field: ‘expr’
[13:24:21.587]   - Field: ‘uuid’
[13:24:21.587]   - Field: ‘seed’
[13:24:21.587]   - Field: ‘version’
[13:24:21.587]   - Field: ‘result’
[13:24:21.588]   - Field: ‘asynchronous’
[13:24:21.588]   - Field: ‘calls’
[13:24:21.588]   - Field: ‘globals’
[13:24:21.588]   - Field: ‘stdout’
[13:24:21.588]   - Field: ‘earlySignal’
[13:24:21.588]   - Field: ‘lazy’
[13:24:21.588]   - Field: ‘state’
[13:24:21.588] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.588] - Launch lazy future ...
[13:24:21.588] Packages needed by the future expression (n = 0): <none>
[13:24:21.589] Packages needed by future strategies (n = 0): <none>
[13:24:21.589] {
[13:24:21.589]     {
[13:24:21.589]         {
[13:24:21.589]             ...future.startTime <- base::Sys.time()
[13:24:21.589]             {
[13:24:21.589]                 {
[13:24:21.589]                   {
[13:24:21.589]                     base::local({
[13:24:21.589]                       has_future <- base::requireNamespace("future", 
[13:24:21.589]                         quietly = TRUE)
[13:24:21.589]                       if (has_future) {
[13:24:21.589]                         ns <- base::getNamespace("future")
[13:24:21.589]                         version <- ns[[".package"]][["version"]]
[13:24:21.589]                         if (is.null(version)) 
[13:24:21.589]                           version <- utils::packageVersion("future")
[13:24:21.589]                       }
[13:24:21.589]                       else {
[13:24:21.589]                         version <- NULL
[13:24:21.589]                       }
[13:24:21.589]                       if (!has_future || version < "1.8.0") {
[13:24:21.589]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.589]                           "", base::R.version$version.string), 
[13:24:21.589]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.589]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.589]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.589]                             "release", "version")], collapse = " "), 
[13:24:21.589]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.589]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.589]                           info)
[13:24:21.589]                         info <- base::paste(info, collapse = "; ")
[13:24:21.589]                         if (!has_future) {
[13:24:21.589]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.589]                             info)
[13:24:21.589]                         }
[13:24:21.589]                         else {
[13:24:21.589]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.589]                             info, version)
[13:24:21.589]                         }
[13:24:21.589]                         base::stop(msg)
[13:24:21.589]                       }
[13:24:21.589]                     })
[13:24:21.589]                   }
[13:24:21.589]                   options(future.plan = NULL)
[13:24:21.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.589]                 }
[13:24:21.589]                 ...future.workdir <- getwd()
[13:24:21.589]             }
[13:24:21.589]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.589]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.589]         }
[13:24:21.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.589]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.589]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.589]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.589]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.589]             base::names(...future.oldOptions))
[13:24:21.589]     }
[13:24:21.589]     if (FALSE) {
[13:24:21.589]     }
[13:24:21.589]     else {
[13:24:21.589]         if (TRUE) {
[13:24:21.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.589]                 open = "w")
[13:24:21.589]         }
[13:24:21.589]         else {
[13:24:21.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.589]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.589]         }
[13:24:21.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.589]             base::sink(type = "output", split = FALSE)
[13:24:21.589]             base::close(...future.stdout)
[13:24:21.589]         }, add = TRUE)
[13:24:21.589]     }
[13:24:21.589]     ...future.frame <- base::sys.nframe()
[13:24:21.589]     ...future.conditions <- base::list()
[13:24:21.589]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.589]     if (FALSE) {
[13:24:21.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.589]     }
[13:24:21.589]     ...future.result <- base::tryCatch({
[13:24:21.589]         base::withCallingHandlers({
[13:24:21.589]             ...future.value <- base::withVisible(base::local({
[13:24:21.589]                 Sys.sleep(0.1)
[13:24:21.589]                 kk
[13:24:21.589]             }))
[13:24:21.589]             future::FutureResult(value = ...future.value$value, 
[13:24:21.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.589]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.589]                     ...future.globalenv.names))
[13:24:21.589]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.589]         }, condition = base::local({
[13:24:21.589]             c <- base::c
[13:24:21.589]             inherits <- base::inherits
[13:24:21.589]             invokeRestart <- base::invokeRestart
[13:24:21.589]             length <- base::length
[13:24:21.589]             list <- base::list
[13:24:21.589]             seq.int <- base::seq.int
[13:24:21.589]             signalCondition <- base::signalCondition
[13:24:21.589]             sys.calls <- base::sys.calls
[13:24:21.589]             `[[` <- base::`[[`
[13:24:21.589]             `+` <- base::`+`
[13:24:21.589]             `<<-` <- base::`<<-`
[13:24:21.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.589]                   3L)]
[13:24:21.589]             }
[13:24:21.589]             function(cond) {
[13:24:21.589]                 is_error <- inherits(cond, "error")
[13:24:21.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.589]                   NULL)
[13:24:21.589]                 if (is_error) {
[13:24:21.589]                   sessionInformation <- function() {
[13:24:21.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.589]                       search = base::search(), system = base::Sys.info())
[13:24:21.589]                   }
[13:24:21.589]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.589]                     cond$call), session = sessionInformation(), 
[13:24:21.589]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.589]                   signalCondition(cond)
[13:24:21.589]                 }
[13:24:21.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.589]                 "immediateCondition"))) {
[13:24:21.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.589]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.589]                   if (TRUE && !signal) {
[13:24:21.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.589]                     {
[13:24:21.589]                       inherits <- base::inherits
[13:24:21.589]                       invokeRestart <- base::invokeRestart
[13:24:21.589]                       is.null <- base::is.null
[13:24:21.589]                       muffled <- FALSE
[13:24:21.589]                       if (inherits(cond, "message")) {
[13:24:21.589]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.589]                         if (muffled) 
[13:24:21.589]                           invokeRestart("muffleMessage")
[13:24:21.589]                       }
[13:24:21.589]                       else if (inherits(cond, "warning")) {
[13:24:21.589]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.589]                         if (muffled) 
[13:24:21.589]                           invokeRestart("muffleWarning")
[13:24:21.589]                       }
[13:24:21.589]                       else if (inherits(cond, "condition")) {
[13:24:21.589]                         if (!is.null(pattern)) {
[13:24:21.589]                           computeRestarts <- base::computeRestarts
[13:24:21.589]                           grepl <- base::grepl
[13:24:21.589]                           restarts <- computeRestarts(cond)
[13:24:21.589]                           for (restart in restarts) {
[13:24:21.589]                             name <- restart$name
[13:24:21.589]                             if (is.null(name)) 
[13:24:21.589]                               next
[13:24:21.589]                             if (!grepl(pattern, name)) 
[13:24:21.589]                               next
[13:24:21.589]                             invokeRestart(restart)
[13:24:21.589]                             muffled <- TRUE
[13:24:21.589]                             break
[13:24:21.589]                           }
[13:24:21.589]                         }
[13:24:21.589]                       }
[13:24:21.589]                       invisible(muffled)
[13:24:21.589]                     }
[13:24:21.589]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.589]                   }
[13:24:21.589]                 }
[13:24:21.589]                 else {
[13:24:21.589]                   if (TRUE) {
[13:24:21.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.589]                     {
[13:24:21.589]                       inherits <- base::inherits
[13:24:21.589]                       invokeRestart <- base::invokeRestart
[13:24:21.589]                       is.null <- base::is.null
[13:24:21.589]                       muffled <- FALSE
[13:24:21.589]                       if (inherits(cond, "message")) {
[13:24:21.589]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.589]                         if (muffled) 
[13:24:21.589]                           invokeRestart("muffleMessage")
[13:24:21.589]                       }
[13:24:21.589]                       else if (inherits(cond, "warning")) {
[13:24:21.589]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.589]                         if (muffled) 
[13:24:21.589]                           invokeRestart("muffleWarning")
[13:24:21.589]                       }
[13:24:21.589]                       else if (inherits(cond, "condition")) {
[13:24:21.589]                         if (!is.null(pattern)) {
[13:24:21.589]                           computeRestarts <- base::computeRestarts
[13:24:21.589]                           grepl <- base::grepl
[13:24:21.589]                           restarts <- computeRestarts(cond)
[13:24:21.589]                           for (restart in restarts) {
[13:24:21.589]                             name <- restart$name
[13:24:21.589]                             if (is.null(name)) 
[13:24:21.589]                               next
[13:24:21.589]                             if (!grepl(pattern, name)) 
[13:24:21.589]                               next
[13:24:21.589]                             invokeRestart(restart)
[13:24:21.589]                             muffled <- TRUE
[13:24:21.589]                             break
[13:24:21.589]                           }
[13:24:21.589]                         }
[13:24:21.589]                       }
[13:24:21.589]                       invisible(muffled)
[13:24:21.589]                     }
[13:24:21.589]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.589]                   }
[13:24:21.589]                 }
[13:24:21.589]             }
[13:24:21.589]         }))
[13:24:21.589]     }, error = function(ex) {
[13:24:21.589]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.589]                 ...future.rng), started = ...future.startTime, 
[13:24:21.589]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.589]             version = "1.8"), class = "FutureResult")
[13:24:21.589]     }, finally = {
[13:24:21.589]         if (!identical(...future.workdir, getwd())) 
[13:24:21.589]             setwd(...future.workdir)
[13:24:21.589]         {
[13:24:21.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.589]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.589]             }
[13:24:21.589]             base::options(...future.oldOptions)
[13:24:21.589]             if (.Platform$OS.type == "windows") {
[13:24:21.589]                 old_names <- names(...future.oldEnvVars)
[13:24:21.589]                 envs <- base::Sys.getenv()
[13:24:21.589]                 names <- names(envs)
[13:24:21.589]                 common <- intersect(names, old_names)
[13:24:21.589]                 added <- setdiff(names, old_names)
[13:24:21.589]                 removed <- setdiff(old_names, names)
[13:24:21.589]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.589]                   envs[common]]
[13:24:21.589]                 NAMES <- toupper(changed)
[13:24:21.589]                 args <- list()
[13:24:21.589]                 for (kk in seq_along(NAMES)) {
[13:24:21.589]                   name <- changed[[kk]]
[13:24:21.589]                   NAME <- NAMES[[kk]]
[13:24:21.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.589]                     next
[13:24:21.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.589]                 }
[13:24:21.589]                 NAMES <- toupper(added)
[13:24:21.589]                 for (kk in seq_along(NAMES)) {
[13:24:21.589]                   name <- added[[kk]]
[13:24:21.589]                   NAME <- NAMES[[kk]]
[13:24:21.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.589]                     next
[13:24:21.589]                   args[[name]] <- ""
[13:24:21.589]                 }
[13:24:21.589]                 NAMES <- toupper(removed)
[13:24:21.589]                 for (kk in seq_along(NAMES)) {
[13:24:21.589]                   name <- removed[[kk]]
[13:24:21.589]                   NAME <- NAMES[[kk]]
[13:24:21.589]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.589]                     next
[13:24:21.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.589]                 }
[13:24:21.589]                 if (length(args) > 0) 
[13:24:21.589]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.589]             }
[13:24:21.589]             else {
[13:24:21.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.589]             }
[13:24:21.589]             {
[13:24:21.589]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.589]                   0L) {
[13:24:21.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.589]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.589]                   base::options(opts)
[13:24:21.589]                 }
[13:24:21.589]                 {
[13:24:21.589]                   {
[13:24:21.589]                     NULL
[13:24:21.589]                     RNGkind("Mersenne-Twister")
[13:24:21.589]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.589]                       inherits = FALSE)
[13:24:21.589]                   }
[13:24:21.589]                   options(future.plan = NULL)
[13:24:21.589]                   if (is.na(NA_character_)) 
[13:24:21.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.589]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.589]                   {
[13:24:21.589]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.589]                     if (!future$lazy) 
[13:24:21.589]                       future <- run(future)
[13:24:21.589]                     invisible(future)
[13:24:21.589]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.589]                 }
[13:24:21.589]             }
[13:24:21.589]         }
[13:24:21.589]     })
[13:24:21.589]     if (TRUE) {
[13:24:21.589]         base::sink(type = "output", split = FALSE)
[13:24:21.589]         if (TRUE) {
[13:24:21.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.589]         }
[13:24:21.589]         else {
[13:24:21.589]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.589]         }
[13:24:21.589]         base::close(...future.stdout)
[13:24:21.589]         ...future.stdout <- NULL
[13:24:21.589]     }
[13:24:21.589]     ...future.result$conditions <- ...future.conditions
[13:24:21.589]     ...future.result$finished <- base::Sys.time()
[13:24:21.589]     ...future.result
[13:24:21.589] }
[13:24:21.591] assign_globals() ...
[13:24:21.591] List of 1
[13:24:21.591]  $ kk: int 3
[13:24:21.591]  - attr(*, "where")=List of 1
[13:24:21.591]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:21.591]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:21.591]  - attr(*, "resolved")= logi FALSE
[13:24:21.591]  - attr(*, "total_size")= num 56
[13:24:21.591]  - attr(*, "already-done")= logi TRUE
[13:24:21.596] - copied ‘kk’ to environment
[13:24:21.596] assign_globals() ... done
[13:24:21.596] plan(): Setting new future strategy stack:
[13:24:21.596] List of future strategies:
[13:24:21.596] 1. sequential:
[13:24:21.596]    - args: function (..., envir = parent.frame())
[13:24:21.596]    - tweaked: FALSE
[13:24:21.596]    - call: NULL
[13:24:21.596] plan(): nbrOfWorkers() = 1
[13:24:21.698] plan(): Setting new future strategy stack:
[13:24:21.698] List of future strategies:
[13:24:21.698] 1. sequential:
[13:24:21.698]    - args: function (..., envir = parent.frame())
[13:24:21.698]    - tweaked: FALSE
[13:24:21.698]    - call: plan(strategy)
[13:24:21.698] plan(): nbrOfWorkers() = 1
[13:24:21.699] SequentialFuture started (and completed)
[13:24:21.699] - Launch lazy future ... done
[13:24:21.699] run() for ‘SequentialFuture’ ... done
[13:24:21.699] resolved() for ‘SequentialFuture’ ...
[13:24:21.699] - state: ‘finished’
[13:24:21.699] - run: TRUE
[13:24:21.699] - result: ‘FutureResult’
[13:24:21.699] resolved() for ‘SequentialFuture’ ... done
[13:24:21.700] Future #3
[13:24:21.700]  length: 0 (resolved future 3)
[13:24:21.700] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:24:21.701] resolve() on environment ...
[13:24:21.701]  recursive: 0
[13:24:21.702]  elements: [2] ‘a’, ‘b’
[13:24:21.702]  length: 1 (resolved future 1)
[13:24:21.702]  length: 0 (resolved future 2)
[13:24:21.702] resolve() on environment ... DONE
[13:24:21.703] getGlobalsAndPackages() ...
[13:24:21.703] Searching for globals...
[13:24:21.703] 
[13:24:21.703] Searching for globals ... DONE
[13:24:21.703] - globals: [0] <none>
[13:24:21.704] getGlobalsAndPackages() ... DONE
[13:24:21.704] run() for ‘Future’ ...
[13:24:21.704] - state: ‘created’
[13:24:21.704] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.704] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.704] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.705]   - Field: ‘label’
[13:24:21.705]   - Field: ‘local’
[13:24:21.705]   - Field: ‘owner’
[13:24:21.705]   - Field: ‘envir’
[13:24:21.705]   - Field: ‘packages’
[13:24:21.705]   - Field: ‘gc’
[13:24:21.705]   - Field: ‘conditions’
[13:24:21.705]   - Field: ‘expr’
[13:24:21.705]   - Field: ‘uuid’
[13:24:21.705]   - Field: ‘seed’
[13:24:21.706]   - Field: ‘version’
[13:24:21.706]   - Field: ‘result’
[13:24:21.706]   - Field: ‘asynchronous’
[13:24:21.706]   - Field: ‘calls’
[13:24:21.706]   - Field: ‘globals’
[13:24:21.706]   - Field: ‘stdout’
[13:24:21.706]   - Field: ‘earlySignal’
[13:24:21.706]   - Field: ‘lazy’
[13:24:21.706]   - Field: ‘state’
[13:24:21.706] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.706] - Launch lazy future ...
[13:24:21.707] Packages needed by the future expression (n = 0): <none>
[13:24:21.707] Packages needed by future strategies (n = 0): <none>
[13:24:21.707] {
[13:24:21.707]     {
[13:24:21.707]         {
[13:24:21.707]             ...future.startTime <- base::Sys.time()
[13:24:21.707]             {
[13:24:21.707]                 {
[13:24:21.707]                   {
[13:24:21.707]                     base::local({
[13:24:21.707]                       has_future <- base::requireNamespace("future", 
[13:24:21.707]                         quietly = TRUE)
[13:24:21.707]                       if (has_future) {
[13:24:21.707]                         ns <- base::getNamespace("future")
[13:24:21.707]                         version <- ns[[".package"]][["version"]]
[13:24:21.707]                         if (is.null(version)) 
[13:24:21.707]                           version <- utils::packageVersion("future")
[13:24:21.707]                       }
[13:24:21.707]                       else {
[13:24:21.707]                         version <- NULL
[13:24:21.707]                       }
[13:24:21.707]                       if (!has_future || version < "1.8.0") {
[13:24:21.707]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.707]                           "", base::R.version$version.string), 
[13:24:21.707]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.707]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.707]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.707]                             "release", "version")], collapse = " "), 
[13:24:21.707]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.707]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.707]                           info)
[13:24:21.707]                         info <- base::paste(info, collapse = "; ")
[13:24:21.707]                         if (!has_future) {
[13:24:21.707]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.707]                             info)
[13:24:21.707]                         }
[13:24:21.707]                         else {
[13:24:21.707]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.707]                             info, version)
[13:24:21.707]                         }
[13:24:21.707]                         base::stop(msg)
[13:24:21.707]                       }
[13:24:21.707]                     })
[13:24:21.707]                   }
[13:24:21.707]                   options(future.plan = NULL)
[13:24:21.707]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.707]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.707]                 }
[13:24:21.707]                 ...future.workdir <- getwd()
[13:24:21.707]             }
[13:24:21.707]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.707]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.707]         }
[13:24:21.707]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.707]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.707]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.707]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.707]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.707]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.707]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.707]             base::names(...future.oldOptions))
[13:24:21.707]     }
[13:24:21.707]     if (FALSE) {
[13:24:21.707]     }
[13:24:21.707]     else {
[13:24:21.707]         if (TRUE) {
[13:24:21.707]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.707]                 open = "w")
[13:24:21.707]         }
[13:24:21.707]         else {
[13:24:21.707]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.707]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.707]         }
[13:24:21.707]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.707]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.707]             base::sink(type = "output", split = FALSE)
[13:24:21.707]             base::close(...future.stdout)
[13:24:21.707]         }, add = TRUE)
[13:24:21.707]     }
[13:24:21.707]     ...future.frame <- base::sys.nframe()
[13:24:21.707]     ...future.conditions <- base::list()
[13:24:21.707]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.707]     if (FALSE) {
[13:24:21.707]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.707]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.707]     }
[13:24:21.707]     ...future.result <- base::tryCatch({
[13:24:21.707]         base::withCallingHandlers({
[13:24:21.707]             ...future.value <- base::withVisible(base::local(1))
[13:24:21.707]             future::FutureResult(value = ...future.value$value, 
[13:24:21.707]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.707]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.707]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.707]                     ...future.globalenv.names))
[13:24:21.707]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.707]         }, condition = base::local({
[13:24:21.707]             c <- base::c
[13:24:21.707]             inherits <- base::inherits
[13:24:21.707]             invokeRestart <- base::invokeRestart
[13:24:21.707]             length <- base::length
[13:24:21.707]             list <- base::list
[13:24:21.707]             seq.int <- base::seq.int
[13:24:21.707]             signalCondition <- base::signalCondition
[13:24:21.707]             sys.calls <- base::sys.calls
[13:24:21.707]             `[[` <- base::`[[`
[13:24:21.707]             `+` <- base::`+`
[13:24:21.707]             `<<-` <- base::`<<-`
[13:24:21.707]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.707]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.707]                   3L)]
[13:24:21.707]             }
[13:24:21.707]             function(cond) {
[13:24:21.707]                 is_error <- inherits(cond, "error")
[13:24:21.707]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.707]                   NULL)
[13:24:21.707]                 if (is_error) {
[13:24:21.707]                   sessionInformation <- function() {
[13:24:21.707]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.707]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.707]                       search = base::search(), system = base::Sys.info())
[13:24:21.707]                   }
[13:24:21.707]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.707]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.707]                     cond$call), session = sessionInformation(), 
[13:24:21.707]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.707]                   signalCondition(cond)
[13:24:21.707]                 }
[13:24:21.707]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.707]                 "immediateCondition"))) {
[13:24:21.707]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.707]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.707]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.707]                   if (TRUE && !signal) {
[13:24:21.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.707]                     {
[13:24:21.707]                       inherits <- base::inherits
[13:24:21.707]                       invokeRestart <- base::invokeRestart
[13:24:21.707]                       is.null <- base::is.null
[13:24:21.707]                       muffled <- FALSE
[13:24:21.707]                       if (inherits(cond, "message")) {
[13:24:21.707]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.707]                         if (muffled) 
[13:24:21.707]                           invokeRestart("muffleMessage")
[13:24:21.707]                       }
[13:24:21.707]                       else if (inherits(cond, "warning")) {
[13:24:21.707]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.707]                         if (muffled) 
[13:24:21.707]                           invokeRestart("muffleWarning")
[13:24:21.707]                       }
[13:24:21.707]                       else if (inherits(cond, "condition")) {
[13:24:21.707]                         if (!is.null(pattern)) {
[13:24:21.707]                           computeRestarts <- base::computeRestarts
[13:24:21.707]                           grepl <- base::grepl
[13:24:21.707]                           restarts <- computeRestarts(cond)
[13:24:21.707]                           for (restart in restarts) {
[13:24:21.707]                             name <- restart$name
[13:24:21.707]                             if (is.null(name)) 
[13:24:21.707]                               next
[13:24:21.707]                             if (!grepl(pattern, name)) 
[13:24:21.707]                               next
[13:24:21.707]                             invokeRestart(restart)
[13:24:21.707]                             muffled <- TRUE
[13:24:21.707]                             break
[13:24:21.707]                           }
[13:24:21.707]                         }
[13:24:21.707]                       }
[13:24:21.707]                       invisible(muffled)
[13:24:21.707]                     }
[13:24:21.707]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.707]                   }
[13:24:21.707]                 }
[13:24:21.707]                 else {
[13:24:21.707]                   if (TRUE) {
[13:24:21.707]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.707]                     {
[13:24:21.707]                       inherits <- base::inherits
[13:24:21.707]                       invokeRestart <- base::invokeRestart
[13:24:21.707]                       is.null <- base::is.null
[13:24:21.707]                       muffled <- FALSE
[13:24:21.707]                       if (inherits(cond, "message")) {
[13:24:21.707]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.707]                         if (muffled) 
[13:24:21.707]                           invokeRestart("muffleMessage")
[13:24:21.707]                       }
[13:24:21.707]                       else if (inherits(cond, "warning")) {
[13:24:21.707]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.707]                         if (muffled) 
[13:24:21.707]                           invokeRestart("muffleWarning")
[13:24:21.707]                       }
[13:24:21.707]                       else if (inherits(cond, "condition")) {
[13:24:21.707]                         if (!is.null(pattern)) {
[13:24:21.707]                           computeRestarts <- base::computeRestarts
[13:24:21.707]                           grepl <- base::grepl
[13:24:21.707]                           restarts <- computeRestarts(cond)
[13:24:21.707]                           for (restart in restarts) {
[13:24:21.707]                             name <- restart$name
[13:24:21.707]                             if (is.null(name)) 
[13:24:21.707]                               next
[13:24:21.707]                             if (!grepl(pattern, name)) 
[13:24:21.707]                               next
[13:24:21.707]                             invokeRestart(restart)
[13:24:21.707]                             muffled <- TRUE
[13:24:21.707]                             break
[13:24:21.707]                           }
[13:24:21.707]                         }
[13:24:21.707]                       }
[13:24:21.707]                       invisible(muffled)
[13:24:21.707]                     }
[13:24:21.707]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.707]                   }
[13:24:21.707]                 }
[13:24:21.707]             }
[13:24:21.707]         }))
[13:24:21.707]     }, error = function(ex) {
[13:24:21.707]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.707]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.707]                 ...future.rng), started = ...future.startTime, 
[13:24:21.707]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.707]             version = "1.8"), class = "FutureResult")
[13:24:21.707]     }, finally = {
[13:24:21.707]         if (!identical(...future.workdir, getwd())) 
[13:24:21.707]             setwd(...future.workdir)
[13:24:21.707]         {
[13:24:21.707]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.707]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.707]             }
[13:24:21.707]             base::options(...future.oldOptions)
[13:24:21.707]             if (.Platform$OS.type == "windows") {
[13:24:21.707]                 old_names <- names(...future.oldEnvVars)
[13:24:21.707]                 envs <- base::Sys.getenv()
[13:24:21.707]                 names <- names(envs)
[13:24:21.707]                 common <- intersect(names, old_names)
[13:24:21.707]                 added <- setdiff(names, old_names)
[13:24:21.707]                 removed <- setdiff(old_names, names)
[13:24:21.707]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.707]                   envs[common]]
[13:24:21.707]                 NAMES <- toupper(changed)
[13:24:21.707]                 args <- list()
[13:24:21.707]                 for (kk in seq_along(NAMES)) {
[13:24:21.707]                   name <- changed[[kk]]
[13:24:21.707]                   NAME <- NAMES[[kk]]
[13:24:21.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.707]                     next
[13:24:21.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.707]                 }
[13:24:21.707]                 NAMES <- toupper(added)
[13:24:21.707]                 for (kk in seq_along(NAMES)) {
[13:24:21.707]                   name <- added[[kk]]
[13:24:21.707]                   NAME <- NAMES[[kk]]
[13:24:21.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.707]                     next
[13:24:21.707]                   args[[name]] <- ""
[13:24:21.707]                 }
[13:24:21.707]                 NAMES <- toupper(removed)
[13:24:21.707]                 for (kk in seq_along(NAMES)) {
[13:24:21.707]                   name <- removed[[kk]]
[13:24:21.707]                   NAME <- NAMES[[kk]]
[13:24:21.707]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.707]                     next
[13:24:21.707]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.707]                 }
[13:24:21.707]                 if (length(args) > 0) 
[13:24:21.707]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.707]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.707]             }
[13:24:21.707]             else {
[13:24:21.707]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.707]             }
[13:24:21.707]             {
[13:24:21.707]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.707]                   0L) {
[13:24:21.707]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.707]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.707]                   base::options(opts)
[13:24:21.707]                 }
[13:24:21.707]                 {
[13:24:21.707]                   {
[13:24:21.707]                     NULL
[13:24:21.707]                     RNGkind("Mersenne-Twister")
[13:24:21.707]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.707]                       inherits = FALSE)
[13:24:21.707]                   }
[13:24:21.707]                   options(future.plan = NULL)
[13:24:21.707]                   if (is.na(NA_character_)) 
[13:24:21.707]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.707]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.707]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.707]                   {
[13:24:21.707]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.707]                     if (!future$lazy) 
[13:24:21.707]                       future <- run(future)
[13:24:21.707]                     invisible(future)
[13:24:21.707]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.707]                 }
[13:24:21.707]             }
[13:24:21.707]         }
[13:24:21.707]     })
[13:24:21.707]     if (TRUE) {
[13:24:21.707]         base::sink(type = "output", split = FALSE)
[13:24:21.707]         if (TRUE) {
[13:24:21.707]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.707]         }
[13:24:21.707]         else {
[13:24:21.707]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.707]         }
[13:24:21.707]         base::close(...future.stdout)
[13:24:21.707]         ...future.stdout <- NULL
[13:24:21.707]     }
[13:24:21.707]     ...future.result$conditions <- ...future.conditions
[13:24:21.707]     ...future.result$finished <- base::Sys.time()
[13:24:21.707]     ...future.result
[13:24:21.707] }
[13:24:21.709] plan(): Setting new future strategy stack:
[13:24:21.709] List of future strategies:
[13:24:21.709] 1. sequential:
[13:24:21.709]    - args: function (..., envir = parent.frame())
[13:24:21.709]    - tweaked: FALSE
[13:24:21.709]    - call: NULL
[13:24:21.710] plan(): nbrOfWorkers() = 1
[13:24:21.711] plan(): Setting new future strategy stack:
[13:24:21.711] List of future strategies:
[13:24:21.711] 1. sequential:
[13:24:21.711]    - args: function (..., envir = parent.frame())
[13:24:21.711]    - tweaked: FALSE
[13:24:21.711]    - call: plan(strategy)
[13:24:21.711] plan(): nbrOfWorkers() = 1
[13:24:21.711] SequentialFuture started (and completed)
[13:24:21.711] - Launch lazy future ... done
[13:24:21.711] run() for ‘SequentialFuture’ ... done
[13:24:21.712] getGlobalsAndPackages() ...
[13:24:21.712] Searching for globals...
[13:24:21.712] 
[13:24:21.712] Searching for globals ... DONE
[13:24:21.712] - globals: [0] <none>
[13:24:21.712] getGlobalsAndPackages() ... DONE
[13:24:21.713] run() for ‘Future’ ...
[13:24:21.713] - state: ‘created’
[13:24:21.713] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.713] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.713]   - Field: ‘label’
[13:24:21.713]   - Field: ‘local’
[13:24:21.713]   - Field: ‘owner’
[13:24:21.714]   - Field: ‘envir’
[13:24:21.714]   - Field: ‘packages’
[13:24:21.714]   - Field: ‘gc’
[13:24:21.714]   - Field: ‘conditions’
[13:24:21.714]   - Field: ‘expr’
[13:24:21.714]   - Field: ‘uuid’
[13:24:21.714]   - Field: ‘seed’
[13:24:21.714]   - Field: ‘version’
[13:24:21.714]   - Field: ‘result’
[13:24:21.714]   - Field: ‘asynchronous’
[13:24:21.715]   - Field: ‘calls’
[13:24:21.715]   - Field: ‘globals’
[13:24:21.715]   - Field: ‘stdout’
[13:24:21.715]   - Field: ‘earlySignal’
[13:24:21.715]   - Field: ‘lazy’
[13:24:21.715]   - Field: ‘state’
[13:24:21.715] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.715] - Launch lazy future ...
[13:24:21.715] Packages needed by the future expression (n = 0): <none>
[13:24:21.715] Packages needed by future strategies (n = 0): <none>
[13:24:21.716] {
[13:24:21.716]     {
[13:24:21.716]         {
[13:24:21.716]             ...future.startTime <- base::Sys.time()
[13:24:21.716]             {
[13:24:21.716]                 {
[13:24:21.716]                   {
[13:24:21.716]                     base::local({
[13:24:21.716]                       has_future <- base::requireNamespace("future", 
[13:24:21.716]                         quietly = TRUE)
[13:24:21.716]                       if (has_future) {
[13:24:21.716]                         ns <- base::getNamespace("future")
[13:24:21.716]                         version <- ns[[".package"]][["version"]]
[13:24:21.716]                         if (is.null(version)) 
[13:24:21.716]                           version <- utils::packageVersion("future")
[13:24:21.716]                       }
[13:24:21.716]                       else {
[13:24:21.716]                         version <- NULL
[13:24:21.716]                       }
[13:24:21.716]                       if (!has_future || version < "1.8.0") {
[13:24:21.716]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.716]                           "", base::R.version$version.string), 
[13:24:21.716]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.716]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.716]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.716]                             "release", "version")], collapse = " "), 
[13:24:21.716]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.716]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.716]                           info)
[13:24:21.716]                         info <- base::paste(info, collapse = "; ")
[13:24:21.716]                         if (!has_future) {
[13:24:21.716]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.716]                             info)
[13:24:21.716]                         }
[13:24:21.716]                         else {
[13:24:21.716]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.716]                             info, version)
[13:24:21.716]                         }
[13:24:21.716]                         base::stop(msg)
[13:24:21.716]                       }
[13:24:21.716]                     })
[13:24:21.716]                   }
[13:24:21.716]                   options(future.plan = NULL)
[13:24:21.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.716]                 }
[13:24:21.716]                 ...future.workdir <- getwd()
[13:24:21.716]             }
[13:24:21.716]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.716]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.716]         }
[13:24:21.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.716]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.716]             base::names(...future.oldOptions))
[13:24:21.716]     }
[13:24:21.716]     if (FALSE) {
[13:24:21.716]     }
[13:24:21.716]     else {
[13:24:21.716]         if (TRUE) {
[13:24:21.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.716]                 open = "w")
[13:24:21.716]         }
[13:24:21.716]         else {
[13:24:21.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.716]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.716]         }
[13:24:21.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.716]             base::sink(type = "output", split = FALSE)
[13:24:21.716]             base::close(...future.stdout)
[13:24:21.716]         }, add = TRUE)
[13:24:21.716]     }
[13:24:21.716]     ...future.frame <- base::sys.nframe()
[13:24:21.716]     ...future.conditions <- base::list()
[13:24:21.716]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.716]     if (FALSE) {
[13:24:21.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.716]     }
[13:24:21.716]     ...future.result <- base::tryCatch({
[13:24:21.716]         base::withCallingHandlers({
[13:24:21.716]             ...future.value <- base::withVisible(base::local(2))
[13:24:21.716]             future::FutureResult(value = ...future.value$value, 
[13:24:21.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.716]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.716]                     ...future.globalenv.names))
[13:24:21.716]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.716]         }, condition = base::local({
[13:24:21.716]             c <- base::c
[13:24:21.716]             inherits <- base::inherits
[13:24:21.716]             invokeRestart <- base::invokeRestart
[13:24:21.716]             length <- base::length
[13:24:21.716]             list <- base::list
[13:24:21.716]             seq.int <- base::seq.int
[13:24:21.716]             signalCondition <- base::signalCondition
[13:24:21.716]             sys.calls <- base::sys.calls
[13:24:21.716]             `[[` <- base::`[[`
[13:24:21.716]             `+` <- base::`+`
[13:24:21.716]             `<<-` <- base::`<<-`
[13:24:21.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.716]                   3L)]
[13:24:21.716]             }
[13:24:21.716]             function(cond) {
[13:24:21.716]                 is_error <- inherits(cond, "error")
[13:24:21.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.716]                   NULL)
[13:24:21.716]                 if (is_error) {
[13:24:21.716]                   sessionInformation <- function() {
[13:24:21.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.716]                       search = base::search(), system = base::Sys.info())
[13:24:21.716]                   }
[13:24:21.716]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.716]                     cond$call), session = sessionInformation(), 
[13:24:21.716]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.716]                   signalCondition(cond)
[13:24:21.716]                 }
[13:24:21.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.716]                 "immediateCondition"))) {
[13:24:21.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.716]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.716]                   if (TRUE && !signal) {
[13:24:21.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.716]                     {
[13:24:21.716]                       inherits <- base::inherits
[13:24:21.716]                       invokeRestart <- base::invokeRestart
[13:24:21.716]                       is.null <- base::is.null
[13:24:21.716]                       muffled <- FALSE
[13:24:21.716]                       if (inherits(cond, "message")) {
[13:24:21.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.716]                         if (muffled) 
[13:24:21.716]                           invokeRestart("muffleMessage")
[13:24:21.716]                       }
[13:24:21.716]                       else if (inherits(cond, "warning")) {
[13:24:21.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.716]                         if (muffled) 
[13:24:21.716]                           invokeRestart("muffleWarning")
[13:24:21.716]                       }
[13:24:21.716]                       else if (inherits(cond, "condition")) {
[13:24:21.716]                         if (!is.null(pattern)) {
[13:24:21.716]                           computeRestarts <- base::computeRestarts
[13:24:21.716]                           grepl <- base::grepl
[13:24:21.716]                           restarts <- computeRestarts(cond)
[13:24:21.716]                           for (restart in restarts) {
[13:24:21.716]                             name <- restart$name
[13:24:21.716]                             if (is.null(name)) 
[13:24:21.716]                               next
[13:24:21.716]                             if (!grepl(pattern, name)) 
[13:24:21.716]                               next
[13:24:21.716]                             invokeRestart(restart)
[13:24:21.716]                             muffled <- TRUE
[13:24:21.716]                             break
[13:24:21.716]                           }
[13:24:21.716]                         }
[13:24:21.716]                       }
[13:24:21.716]                       invisible(muffled)
[13:24:21.716]                     }
[13:24:21.716]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.716]                   }
[13:24:21.716]                 }
[13:24:21.716]                 else {
[13:24:21.716]                   if (TRUE) {
[13:24:21.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.716]                     {
[13:24:21.716]                       inherits <- base::inherits
[13:24:21.716]                       invokeRestart <- base::invokeRestart
[13:24:21.716]                       is.null <- base::is.null
[13:24:21.716]                       muffled <- FALSE
[13:24:21.716]                       if (inherits(cond, "message")) {
[13:24:21.716]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.716]                         if (muffled) 
[13:24:21.716]                           invokeRestart("muffleMessage")
[13:24:21.716]                       }
[13:24:21.716]                       else if (inherits(cond, "warning")) {
[13:24:21.716]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.716]                         if (muffled) 
[13:24:21.716]                           invokeRestart("muffleWarning")
[13:24:21.716]                       }
[13:24:21.716]                       else if (inherits(cond, "condition")) {
[13:24:21.716]                         if (!is.null(pattern)) {
[13:24:21.716]                           computeRestarts <- base::computeRestarts
[13:24:21.716]                           grepl <- base::grepl
[13:24:21.716]                           restarts <- computeRestarts(cond)
[13:24:21.716]                           for (restart in restarts) {
[13:24:21.716]                             name <- restart$name
[13:24:21.716]                             if (is.null(name)) 
[13:24:21.716]                               next
[13:24:21.716]                             if (!grepl(pattern, name)) 
[13:24:21.716]                               next
[13:24:21.716]                             invokeRestart(restart)
[13:24:21.716]                             muffled <- TRUE
[13:24:21.716]                             break
[13:24:21.716]                           }
[13:24:21.716]                         }
[13:24:21.716]                       }
[13:24:21.716]                       invisible(muffled)
[13:24:21.716]                     }
[13:24:21.716]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.716]                   }
[13:24:21.716]                 }
[13:24:21.716]             }
[13:24:21.716]         }))
[13:24:21.716]     }, error = function(ex) {
[13:24:21.716]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.716]                 ...future.rng), started = ...future.startTime, 
[13:24:21.716]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.716]             version = "1.8"), class = "FutureResult")
[13:24:21.716]     }, finally = {
[13:24:21.716]         if (!identical(...future.workdir, getwd())) 
[13:24:21.716]             setwd(...future.workdir)
[13:24:21.716]         {
[13:24:21.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.716]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.716]             }
[13:24:21.716]             base::options(...future.oldOptions)
[13:24:21.716]             if (.Platform$OS.type == "windows") {
[13:24:21.716]                 old_names <- names(...future.oldEnvVars)
[13:24:21.716]                 envs <- base::Sys.getenv()
[13:24:21.716]                 names <- names(envs)
[13:24:21.716]                 common <- intersect(names, old_names)
[13:24:21.716]                 added <- setdiff(names, old_names)
[13:24:21.716]                 removed <- setdiff(old_names, names)
[13:24:21.716]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.716]                   envs[common]]
[13:24:21.716]                 NAMES <- toupper(changed)
[13:24:21.716]                 args <- list()
[13:24:21.716]                 for (kk in seq_along(NAMES)) {
[13:24:21.716]                   name <- changed[[kk]]
[13:24:21.716]                   NAME <- NAMES[[kk]]
[13:24:21.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.716]                     next
[13:24:21.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.716]                 }
[13:24:21.716]                 NAMES <- toupper(added)
[13:24:21.716]                 for (kk in seq_along(NAMES)) {
[13:24:21.716]                   name <- added[[kk]]
[13:24:21.716]                   NAME <- NAMES[[kk]]
[13:24:21.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.716]                     next
[13:24:21.716]                   args[[name]] <- ""
[13:24:21.716]                 }
[13:24:21.716]                 NAMES <- toupper(removed)
[13:24:21.716]                 for (kk in seq_along(NAMES)) {
[13:24:21.716]                   name <- removed[[kk]]
[13:24:21.716]                   NAME <- NAMES[[kk]]
[13:24:21.716]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.716]                     next
[13:24:21.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.716]                 }
[13:24:21.716]                 if (length(args) > 0) 
[13:24:21.716]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.716]             }
[13:24:21.716]             else {
[13:24:21.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.716]             }
[13:24:21.716]             {
[13:24:21.716]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.716]                   0L) {
[13:24:21.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.716]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.716]                   base::options(opts)
[13:24:21.716]                 }
[13:24:21.716]                 {
[13:24:21.716]                   {
[13:24:21.716]                     NULL
[13:24:21.716]                     RNGkind("Mersenne-Twister")
[13:24:21.716]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.716]                       inherits = FALSE)
[13:24:21.716]                   }
[13:24:21.716]                   options(future.plan = NULL)
[13:24:21.716]                   if (is.na(NA_character_)) 
[13:24:21.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.716]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.716]                   {
[13:24:21.716]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.716]                     if (!future$lazy) 
[13:24:21.716]                       future <- run(future)
[13:24:21.716]                     invisible(future)
[13:24:21.716]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.716]                 }
[13:24:21.716]             }
[13:24:21.716]         }
[13:24:21.716]     })
[13:24:21.716]     if (TRUE) {
[13:24:21.716]         base::sink(type = "output", split = FALSE)
[13:24:21.716]         if (TRUE) {
[13:24:21.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.716]         }
[13:24:21.716]         else {
[13:24:21.716]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.716]         }
[13:24:21.716]         base::close(...future.stdout)
[13:24:21.716]         ...future.stdout <- NULL
[13:24:21.716]     }
[13:24:21.716]     ...future.result$conditions <- ...future.conditions
[13:24:21.716]     ...future.result$finished <- base::Sys.time()
[13:24:21.716]     ...future.result
[13:24:21.716] }
[13:24:21.718] plan(): Setting new future strategy stack:
[13:24:21.718] List of future strategies:
[13:24:21.718] 1. sequential:
[13:24:21.718]    - args: function (..., envir = parent.frame())
[13:24:21.718]    - tweaked: FALSE
[13:24:21.718]    - call: NULL
[13:24:21.718] plan(): nbrOfWorkers() = 1
[13:24:21.719] plan(): Setting new future strategy stack:
[13:24:21.719] List of future strategies:
[13:24:21.719] 1. sequential:
[13:24:21.719]    - args: function (..., envir = parent.frame())
[13:24:21.719]    - tweaked: FALSE
[13:24:21.719]    - call: plan(strategy)
[13:24:21.719] plan(): nbrOfWorkers() = 1
[13:24:21.720] SequentialFuture started (and completed)
[13:24:21.720] - Launch lazy future ... done
[13:24:21.720] run() for ‘SequentialFuture’ ... done
[13:24:21.720] resolve() on environment ...
[13:24:21.720]  recursive: 0
[13:24:21.721]  elements: [3] ‘a’, ‘b’, ‘c’
[13:24:21.721] resolved() for ‘SequentialFuture’ ...
[13:24:21.721] - state: ‘finished’
[13:24:21.721] - run: TRUE
[13:24:21.721] - result: ‘FutureResult’
[13:24:21.721] resolved() for ‘SequentialFuture’ ... done
[13:24:21.722] Future #1
[13:24:21.722]  length: 2 (resolved future 1)
[13:24:21.722] resolved() for ‘SequentialFuture’ ...
[13:24:21.722] - state: ‘finished’
[13:24:21.722] - run: TRUE
[13:24:21.722] - result: ‘FutureResult’
[13:24:21.722] resolved() for ‘SequentialFuture’ ... done
[13:24:21.722] Future #2
[13:24:21.722]  length: 1 (resolved future 2)
[13:24:21.722]  length: 0 (resolved future 3)
[13:24:21.723] resolve() on environment ... DONE
[13:24:21.723] resolved() for ‘SequentialFuture’ ...
[13:24:21.723] - state: ‘finished’
[13:24:21.723] - run: TRUE
[13:24:21.723] - result: ‘FutureResult’
[13:24:21.723] resolved() for ‘SequentialFuture’ ... done
[13:24:21.723] resolved() for ‘SequentialFuture’ ...
[13:24:21.723] - state: ‘finished’
[13:24:21.723] - run: TRUE
[13:24:21.723] - result: ‘FutureResult’
[13:24:21.723] resolved() for ‘SequentialFuture’ ... done
[13:24:21.724] getGlobalsAndPackages() ...
[13:24:21.724] Searching for globals...
[13:24:21.725] - globals found: [1] ‘{’
[13:24:21.727] Searching for globals ... DONE
[13:24:21.727] Resolving globals: FALSE
[13:24:21.728] 
[13:24:21.728] 
[13:24:21.728] getGlobalsAndPackages() ... DONE
[13:24:21.728] run() for ‘Future’ ...
[13:24:21.728] - state: ‘created’
[13:24:21.728] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.729] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.729]   - Field: ‘label’
[13:24:21.729]   - Field: ‘local’
[13:24:21.729]   - Field: ‘owner’
[13:24:21.729]   - Field: ‘envir’
[13:24:21.729]   - Field: ‘packages’
[13:24:21.729]   - Field: ‘gc’
[13:24:21.729]   - Field: ‘conditions’
[13:24:21.730]   - Field: ‘expr’
[13:24:21.730]   - Field: ‘uuid’
[13:24:21.730]   - Field: ‘seed’
[13:24:21.730]   - Field: ‘version’
[13:24:21.730]   - Field: ‘result’
[13:24:21.730]   - Field: ‘asynchronous’
[13:24:21.730]   - Field: ‘calls’
[13:24:21.730]   - Field: ‘globals’
[13:24:21.730]   - Field: ‘stdout’
[13:24:21.730]   - Field: ‘earlySignal’
[13:24:21.730]   - Field: ‘lazy’
[13:24:21.731]   - Field: ‘state’
[13:24:21.731] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.731] - Launch lazy future ...
[13:24:21.731] Packages needed by the future expression (n = 0): <none>
[13:24:21.731] Packages needed by future strategies (n = 0): <none>
[13:24:21.731] {
[13:24:21.731]     {
[13:24:21.731]         {
[13:24:21.731]             ...future.startTime <- base::Sys.time()
[13:24:21.731]             {
[13:24:21.731]                 {
[13:24:21.731]                   {
[13:24:21.731]                     base::local({
[13:24:21.731]                       has_future <- base::requireNamespace("future", 
[13:24:21.731]                         quietly = TRUE)
[13:24:21.731]                       if (has_future) {
[13:24:21.731]                         ns <- base::getNamespace("future")
[13:24:21.731]                         version <- ns[[".package"]][["version"]]
[13:24:21.731]                         if (is.null(version)) 
[13:24:21.731]                           version <- utils::packageVersion("future")
[13:24:21.731]                       }
[13:24:21.731]                       else {
[13:24:21.731]                         version <- NULL
[13:24:21.731]                       }
[13:24:21.731]                       if (!has_future || version < "1.8.0") {
[13:24:21.731]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.731]                           "", base::R.version$version.string), 
[13:24:21.731]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.731]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.731]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.731]                             "release", "version")], collapse = " "), 
[13:24:21.731]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.731]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.731]                           info)
[13:24:21.731]                         info <- base::paste(info, collapse = "; ")
[13:24:21.731]                         if (!has_future) {
[13:24:21.731]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.731]                             info)
[13:24:21.731]                         }
[13:24:21.731]                         else {
[13:24:21.731]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.731]                             info, version)
[13:24:21.731]                         }
[13:24:21.731]                         base::stop(msg)
[13:24:21.731]                       }
[13:24:21.731]                     })
[13:24:21.731]                   }
[13:24:21.731]                   options(future.plan = NULL)
[13:24:21.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.731]                 }
[13:24:21.731]                 ...future.workdir <- getwd()
[13:24:21.731]             }
[13:24:21.731]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.731]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.731]         }
[13:24:21.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.731]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.731]             base::names(...future.oldOptions))
[13:24:21.731]     }
[13:24:21.731]     if (FALSE) {
[13:24:21.731]     }
[13:24:21.731]     else {
[13:24:21.731]         if (TRUE) {
[13:24:21.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.731]                 open = "w")
[13:24:21.731]         }
[13:24:21.731]         else {
[13:24:21.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.731]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.731]         }
[13:24:21.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.731]             base::sink(type = "output", split = FALSE)
[13:24:21.731]             base::close(...future.stdout)
[13:24:21.731]         }, add = TRUE)
[13:24:21.731]     }
[13:24:21.731]     ...future.frame <- base::sys.nframe()
[13:24:21.731]     ...future.conditions <- base::list()
[13:24:21.731]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.731]     if (FALSE) {
[13:24:21.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.731]     }
[13:24:21.731]     ...future.result <- base::tryCatch({
[13:24:21.731]         base::withCallingHandlers({
[13:24:21.731]             ...future.value <- base::withVisible(base::local({
[13:24:21.731]                 1
[13:24:21.731]             }))
[13:24:21.731]             future::FutureResult(value = ...future.value$value, 
[13:24:21.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.731]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.731]                     ...future.globalenv.names))
[13:24:21.731]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.731]         }, condition = base::local({
[13:24:21.731]             c <- base::c
[13:24:21.731]             inherits <- base::inherits
[13:24:21.731]             invokeRestart <- base::invokeRestart
[13:24:21.731]             length <- base::length
[13:24:21.731]             list <- base::list
[13:24:21.731]             seq.int <- base::seq.int
[13:24:21.731]             signalCondition <- base::signalCondition
[13:24:21.731]             sys.calls <- base::sys.calls
[13:24:21.731]             `[[` <- base::`[[`
[13:24:21.731]             `+` <- base::`+`
[13:24:21.731]             `<<-` <- base::`<<-`
[13:24:21.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.731]                   3L)]
[13:24:21.731]             }
[13:24:21.731]             function(cond) {
[13:24:21.731]                 is_error <- inherits(cond, "error")
[13:24:21.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.731]                   NULL)
[13:24:21.731]                 if (is_error) {
[13:24:21.731]                   sessionInformation <- function() {
[13:24:21.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.731]                       search = base::search(), system = base::Sys.info())
[13:24:21.731]                   }
[13:24:21.731]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.731]                     cond$call), session = sessionInformation(), 
[13:24:21.731]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.731]                   signalCondition(cond)
[13:24:21.731]                 }
[13:24:21.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.731]                 "immediateCondition"))) {
[13:24:21.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.731]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.731]                   if (TRUE && !signal) {
[13:24:21.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.731]                     {
[13:24:21.731]                       inherits <- base::inherits
[13:24:21.731]                       invokeRestart <- base::invokeRestart
[13:24:21.731]                       is.null <- base::is.null
[13:24:21.731]                       muffled <- FALSE
[13:24:21.731]                       if (inherits(cond, "message")) {
[13:24:21.731]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.731]                         if (muffled) 
[13:24:21.731]                           invokeRestart("muffleMessage")
[13:24:21.731]                       }
[13:24:21.731]                       else if (inherits(cond, "warning")) {
[13:24:21.731]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.731]                         if (muffled) 
[13:24:21.731]                           invokeRestart("muffleWarning")
[13:24:21.731]                       }
[13:24:21.731]                       else if (inherits(cond, "condition")) {
[13:24:21.731]                         if (!is.null(pattern)) {
[13:24:21.731]                           computeRestarts <- base::computeRestarts
[13:24:21.731]                           grepl <- base::grepl
[13:24:21.731]                           restarts <- computeRestarts(cond)
[13:24:21.731]                           for (restart in restarts) {
[13:24:21.731]                             name <- restart$name
[13:24:21.731]                             if (is.null(name)) 
[13:24:21.731]                               next
[13:24:21.731]                             if (!grepl(pattern, name)) 
[13:24:21.731]                               next
[13:24:21.731]                             invokeRestart(restart)
[13:24:21.731]                             muffled <- TRUE
[13:24:21.731]                             break
[13:24:21.731]                           }
[13:24:21.731]                         }
[13:24:21.731]                       }
[13:24:21.731]                       invisible(muffled)
[13:24:21.731]                     }
[13:24:21.731]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.731]                   }
[13:24:21.731]                 }
[13:24:21.731]                 else {
[13:24:21.731]                   if (TRUE) {
[13:24:21.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.731]                     {
[13:24:21.731]                       inherits <- base::inherits
[13:24:21.731]                       invokeRestart <- base::invokeRestart
[13:24:21.731]                       is.null <- base::is.null
[13:24:21.731]                       muffled <- FALSE
[13:24:21.731]                       if (inherits(cond, "message")) {
[13:24:21.731]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.731]                         if (muffled) 
[13:24:21.731]                           invokeRestart("muffleMessage")
[13:24:21.731]                       }
[13:24:21.731]                       else if (inherits(cond, "warning")) {
[13:24:21.731]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.731]                         if (muffled) 
[13:24:21.731]                           invokeRestart("muffleWarning")
[13:24:21.731]                       }
[13:24:21.731]                       else if (inherits(cond, "condition")) {
[13:24:21.731]                         if (!is.null(pattern)) {
[13:24:21.731]                           computeRestarts <- base::computeRestarts
[13:24:21.731]                           grepl <- base::grepl
[13:24:21.731]                           restarts <- computeRestarts(cond)
[13:24:21.731]                           for (restart in restarts) {
[13:24:21.731]                             name <- restart$name
[13:24:21.731]                             if (is.null(name)) 
[13:24:21.731]                               next
[13:24:21.731]                             if (!grepl(pattern, name)) 
[13:24:21.731]                               next
[13:24:21.731]                             invokeRestart(restart)
[13:24:21.731]                             muffled <- TRUE
[13:24:21.731]                             break
[13:24:21.731]                           }
[13:24:21.731]                         }
[13:24:21.731]                       }
[13:24:21.731]                       invisible(muffled)
[13:24:21.731]                     }
[13:24:21.731]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.731]                   }
[13:24:21.731]                 }
[13:24:21.731]             }
[13:24:21.731]         }))
[13:24:21.731]     }, error = function(ex) {
[13:24:21.731]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.731]                 ...future.rng), started = ...future.startTime, 
[13:24:21.731]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.731]             version = "1.8"), class = "FutureResult")
[13:24:21.731]     }, finally = {
[13:24:21.731]         if (!identical(...future.workdir, getwd())) 
[13:24:21.731]             setwd(...future.workdir)
[13:24:21.731]         {
[13:24:21.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.731]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.731]             }
[13:24:21.731]             base::options(...future.oldOptions)
[13:24:21.731]             if (.Platform$OS.type == "windows") {
[13:24:21.731]                 old_names <- names(...future.oldEnvVars)
[13:24:21.731]                 envs <- base::Sys.getenv()
[13:24:21.731]                 names <- names(envs)
[13:24:21.731]                 common <- intersect(names, old_names)
[13:24:21.731]                 added <- setdiff(names, old_names)
[13:24:21.731]                 removed <- setdiff(old_names, names)
[13:24:21.731]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.731]                   envs[common]]
[13:24:21.731]                 NAMES <- toupper(changed)
[13:24:21.731]                 args <- list()
[13:24:21.731]                 for (kk in seq_along(NAMES)) {
[13:24:21.731]                   name <- changed[[kk]]
[13:24:21.731]                   NAME <- NAMES[[kk]]
[13:24:21.731]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.731]                     next
[13:24:21.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.731]                 }
[13:24:21.731]                 NAMES <- toupper(added)
[13:24:21.731]                 for (kk in seq_along(NAMES)) {
[13:24:21.731]                   name <- added[[kk]]
[13:24:21.731]                   NAME <- NAMES[[kk]]
[13:24:21.731]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.731]                     next
[13:24:21.731]                   args[[name]] <- ""
[13:24:21.731]                 }
[13:24:21.731]                 NAMES <- toupper(removed)
[13:24:21.731]                 for (kk in seq_along(NAMES)) {
[13:24:21.731]                   name <- removed[[kk]]
[13:24:21.731]                   NAME <- NAMES[[kk]]
[13:24:21.731]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.731]                     next
[13:24:21.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.731]                 }
[13:24:21.731]                 if (length(args) > 0) 
[13:24:21.731]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.731]             }
[13:24:21.731]             else {
[13:24:21.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.731]             }
[13:24:21.731]             {
[13:24:21.731]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.731]                   0L) {
[13:24:21.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.731]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.731]                   base::options(opts)
[13:24:21.731]                 }
[13:24:21.731]                 {
[13:24:21.731]                   {
[13:24:21.731]                     NULL
[13:24:21.731]                     RNGkind("Mersenne-Twister")
[13:24:21.731]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.731]                       inherits = FALSE)
[13:24:21.731]                   }
[13:24:21.731]                   options(future.plan = NULL)
[13:24:21.731]                   if (is.na(NA_character_)) 
[13:24:21.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.731]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.731]                   {
[13:24:21.731]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.731]                     if (!future$lazy) 
[13:24:21.731]                       future <- run(future)
[13:24:21.731]                     invisible(future)
[13:24:21.731]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.731]                 }
[13:24:21.731]             }
[13:24:21.731]         }
[13:24:21.731]     })
[13:24:21.731]     if (TRUE) {
[13:24:21.731]         base::sink(type = "output", split = FALSE)
[13:24:21.731]         if (TRUE) {
[13:24:21.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.731]         }
[13:24:21.731]         else {
[13:24:21.731]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.731]         }
[13:24:21.731]         base::close(...future.stdout)
[13:24:21.731]         ...future.stdout <- NULL
[13:24:21.731]     }
[13:24:21.731]     ...future.result$conditions <- ...future.conditions
[13:24:21.731]     ...future.result$finished <- base::Sys.time()
[13:24:21.731]     ...future.result
[13:24:21.731] }
[13:24:21.733] plan(): Setting new future strategy stack:
[13:24:21.733] List of future strategies:
[13:24:21.733] 1. sequential:
[13:24:21.733]    - args: function (..., envir = parent.frame())
[13:24:21.733]    - tweaked: FALSE
[13:24:21.733]    - call: NULL
[13:24:21.734] plan(): nbrOfWorkers() = 1
[13:24:21.734] plan(): Setting new future strategy stack:
[13:24:21.735] List of future strategies:
[13:24:21.735] 1. sequential:
[13:24:21.735]    - args: function (..., envir = parent.frame())
[13:24:21.735]    - tweaked: FALSE
[13:24:21.735]    - call: plan(strategy)
[13:24:21.735] plan(): nbrOfWorkers() = 1
[13:24:21.735] SequentialFuture started (and completed)
[13:24:21.735] - Launch lazy future ... done
[13:24:21.735] run() for ‘SequentialFuture’ ... done
[13:24:21.736] getGlobalsAndPackages() ...
[13:24:21.736] Searching for globals...
[13:24:21.736] - globals found: [1] ‘{’
[13:24:21.737] Searching for globals ... DONE
[13:24:21.737] Resolving globals: FALSE
[13:24:21.737] 
[13:24:21.737] 
[13:24:21.737] getGlobalsAndPackages() ... DONE
[13:24:21.737] run() for ‘Future’ ...
[13:24:21.737] - state: ‘created’
[13:24:21.738] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.738] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.738]   - Field: ‘label’
[13:24:21.738]   - Field: ‘local’
[13:24:21.738]   - Field: ‘owner’
[13:24:21.738]   - Field: ‘envir’
[13:24:21.738]   - Field: ‘packages’
[13:24:21.739]   - Field: ‘gc’
[13:24:21.739]   - Field: ‘conditions’
[13:24:21.739]   - Field: ‘expr’
[13:24:21.739]   - Field: ‘uuid’
[13:24:21.739]   - Field: ‘seed’
[13:24:21.739]   - Field: ‘version’
[13:24:21.739]   - Field: ‘result’
[13:24:21.739]   - Field: ‘asynchronous’
[13:24:21.739]   - Field: ‘calls’
[13:24:21.739]   - Field: ‘globals’
[13:24:21.739]   - Field: ‘stdout’
[13:24:21.740]   - Field: ‘earlySignal’
[13:24:21.740]   - Field: ‘lazy’
[13:24:21.740]   - Field: ‘state’
[13:24:21.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.740] - Launch lazy future ...
[13:24:21.740] Packages needed by the future expression (n = 0): <none>
[13:24:21.740] Packages needed by future strategies (n = 0): <none>
[13:24:21.741] {
[13:24:21.741]     {
[13:24:21.741]         {
[13:24:21.741]             ...future.startTime <- base::Sys.time()
[13:24:21.741]             {
[13:24:21.741]                 {
[13:24:21.741]                   {
[13:24:21.741]                     base::local({
[13:24:21.741]                       has_future <- base::requireNamespace("future", 
[13:24:21.741]                         quietly = TRUE)
[13:24:21.741]                       if (has_future) {
[13:24:21.741]                         ns <- base::getNamespace("future")
[13:24:21.741]                         version <- ns[[".package"]][["version"]]
[13:24:21.741]                         if (is.null(version)) 
[13:24:21.741]                           version <- utils::packageVersion("future")
[13:24:21.741]                       }
[13:24:21.741]                       else {
[13:24:21.741]                         version <- NULL
[13:24:21.741]                       }
[13:24:21.741]                       if (!has_future || version < "1.8.0") {
[13:24:21.741]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.741]                           "", base::R.version$version.string), 
[13:24:21.741]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.741]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.741]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.741]                             "release", "version")], collapse = " "), 
[13:24:21.741]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.741]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.741]                           info)
[13:24:21.741]                         info <- base::paste(info, collapse = "; ")
[13:24:21.741]                         if (!has_future) {
[13:24:21.741]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.741]                             info)
[13:24:21.741]                         }
[13:24:21.741]                         else {
[13:24:21.741]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.741]                             info, version)
[13:24:21.741]                         }
[13:24:21.741]                         base::stop(msg)
[13:24:21.741]                       }
[13:24:21.741]                     })
[13:24:21.741]                   }
[13:24:21.741]                   options(future.plan = NULL)
[13:24:21.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.741]                 }
[13:24:21.741]                 ...future.workdir <- getwd()
[13:24:21.741]             }
[13:24:21.741]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.741]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.741]         }
[13:24:21.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.741]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.741]             base::names(...future.oldOptions))
[13:24:21.741]     }
[13:24:21.741]     if (FALSE) {
[13:24:21.741]     }
[13:24:21.741]     else {
[13:24:21.741]         if (TRUE) {
[13:24:21.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.741]                 open = "w")
[13:24:21.741]         }
[13:24:21.741]         else {
[13:24:21.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.741]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.741]         }
[13:24:21.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.741]             base::sink(type = "output", split = FALSE)
[13:24:21.741]             base::close(...future.stdout)
[13:24:21.741]         }, add = TRUE)
[13:24:21.741]     }
[13:24:21.741]     ...future.frame <- base::sys.nframe()
[13:24:21.741]     ...future.conditions <- base::list()
[13:24:21.741]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.741]     if (FALSE) {
[13:24:21.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.741]     }
[13:24:21.741]     ...future.result <- base::tryCatch({
[13:24:21.741]         base::withCallingHandlers({
[13:24:21.741]             ...future.value <- base::withVisible(base::local({
[13:24:21.741]                 2
[13:24:21.741]             }))
[13:24:21.741]             future::FutureResult(value = ...future.value$value, 
[13:24:21.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.741]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.741]                     ...future.globalenv.names))
[13:24:21.741]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.741]         }, condition = base::local({
[13:24:21.741]             c <- base::c
[13:24:21.741]             inherits <- base::inherits
[13:24:21.741]             invokeRestart <- base::invokeRestart
[13:24:21.741]             length <- base::length
[13:24:21.741]             list <- base::list
[13:24:21.741]             seq.int <- base::seq.int
[13:24:21.741]             signalCondition <- base::signalCondition
[13:24:21.741]             sys.calls <- base::sys.calls
[13:24:21.741]             `[[` <- base::`[[`
[13:24:21.741]             `+` <- base::`+`
[13:24:21.741]             `<<-` <- base::`<<-`
[13:24:21.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.741]                   3L)]
[13:24:21.741]             }
[13:24:21.741]             function(cond) {
[13:24:21.741]                 is_error <- inherits(cond, "error")
[13:24:21.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.741]                   NULL)
[13:24:21.741]                 if (is_error) {
[13:24:21.741]                   sessionInformation <- function() {
[13:24:21.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.741]                       search = base::search(), system = base::Sys.info())
[13:24:21.741]                   }
[13:24:21.741]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.741]                     cond$call), session = sessionInformation(), 
[13:24:21.741]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.741]                   signalCondition(cond)
[13:24:21.741]                 }
[13:24:21.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.741]                 "immediateCondition"))) {
[13:24:21.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.741]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.741]                   if (TRUE && !signal) {
[13:24:21.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.741]                     {
[13:24:21.741]                       inherits <- base::inherits
[13:24:21.741]                       invokeRestart <- base::invokeRestart
[13:24:21.741]                       is.null <- base::is.null
[13:24:21.741]                       muffled <- FALSE
[13:24:21.741]                       if (inherits(cond, "message")) {
[13:24:21.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.741]                         if (muffled) 
[13:24:21.741]                           invokeRestart("muffleMessage")
[13:24:21.741]                       }
[13:24:21.741]                       else if (inherits(cond, "warning")) {
[13:24:21.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.741]                         if (muffled) 
[13:24:21.741]                           invokeRestart("muffleWarning")
[13:24:21.741]                       }
[13:24:21.741]                       else if (inherits(cond, "condition")) {
[13:24:21.741]                         if (!is.null(pattern)) {
[13:24:21.741]                           computeRestarts <- base::computeRestarts
[13:24:21.741]                           grepl <- base::grepl
[13:24:21.741]                           restarts <- computeRestarts(cond)
[13:24:21.741]                           for (restart in restarts) {
[13:24:21.741]                             name <- restart$name
[13:24:21.741]                             if (is.null(name)) 
[13:24:21.741]                               next
[13:24:21.741]                             if (!grepl(pattern, name)) 
[13:24:21.741]                               next
[13:24:21.741]                             invokeRestart(restart)
[13:24:21.741]                             muffled <- TRUE
[13:24:21.741]                             break
[13:24:21.741]                           }
[13:24:21.741]                         }
[13:24:21.741]                       }
[13:24:21.741]                       invisible(muffled)
[13:24:21.741]                     }
[13:24:21.741]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.741]                   }
[13:24:21.741]                 }
[13:24:21.741]                 else {
[13:24:21.741]                   if (TRUE) {
[13:24:21.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.741]                     {
[13:24:21.741]                       inherits <- base::inherits
[13:24:21.741]                       invokeRestart <- base::invokeRestart
[13:24:21.741]                       is.null <- base::is.null
[13:24:21.741]                       muffled <- FALSE
[13:24:21.741]                       if (inherits(cond, "message")) {
[13:24:21.741]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.741]                         if (muffled) 
[13:24:21.741]                           invokeRestart("muffleMessage")
[13:24:21.741]                       }
[13:24:21.741]                       else if (inherits(cond, "warning")) {
[13:24:21.741]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.741]                         if (muffled) 
[13:24:21.741]                           invokeRestart("muffleWarning")
[13:24:21.741]                       }
[13:24:21.741]                       else if (inherits(cond, "condition")) {
[13:24:21.741]                         if (!is.null(pattern)) {
[13:24:21.741]                           computeRestarts <- base::computeRestarts
[13:24:21.741]                           grepl <- base::grepl
[13:24:21.741]                           restarts <- computeRestarts(cond)
[13:24:21.741]                           for (restart in restarts) {
[13:24:21.741]                             name <- restart$name
[13:24:21.741]                             if (is.null(name)) 
[13:24:21.741]                               next
[13:24:21.741]                             if (!grepl(pattern, name)) 
[13:24:21.741]                               next
[13:24:21.741]                             invokeRestart(restart)
[13:24:21.741]                             muffled <- TRUE
[13:24:21.741]                             break
[13:24:21.741]                           }
[13:24:21.741]                         }
[13:24:21.741]                       }
[13:24:21.741]                       invisible(muffled)
[13:24:21.741]                     }
[13:24:21.741]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.741]                   }
[13:24:21.741]                 }
[13:24:21.741]             }
[13:24:21.741]         }))
[13:24:21.741]     }, error = function(ex) {
[13:24:21.741]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.741]                 ...future.rng), started = ...future.startTime, 
[13:24:21.741]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.741]             version = "1.8"), class = "FutureResult")
[13:24:21.741]     }, finally = {
[13:24:21.741]         if (!identical(...future.workdir, getwd())) 
[13:24:21.741]             setwd(...future.workdir)
[13:24:21.741]         {
[13:24:21.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.741]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.741]             }
[13:24:21.741]             base::options(...future.oldOptions)
[13:24:21.741]             if (.Platform$OS.type == "windows") {
[13:24:21.741]                 old_names <- names(...future.oldEnvVars)
[13:24:21.741]                 envs <- base::Sys.getenv()
[13:24:21.741]                 names <- names(envs)
[13:24:21.741]                 common <- intersect(names, old_names)
[13:24:21.741]                 added <- setdiff(names, old_names)
[13:24:21.741]                 removed <- setdiff(old_names, names)
[13:24:21.741]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.741]                   envs[common]]
[13:24:21.741]                 NAMES <- toupper(changed)
[13:24:21.741]                 args <- list()
[13:24:21.741]                 for (kk in seq_along(NAMES)) {
[13:24:21.741]                   name <- changed[[kk]]
[13:24:21.741]                   NAME <- NAMES[[kk]]
[13:24:21.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.741]                     next
[13:24:21.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.741]                 }
[13:24:21.741]                 NAMES <- toupper(added)
[13:24:21.741]                 for (kk in seq_along(NAMES)) {
[13:24:21.741]                   name <- added[[kk]]
[13:24:21.741]                   NAME <- NAMES[[kk]]
[13:24:21.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.741]                     next
[13:24:21.741]                   args[[name]] <- ""
[13:24:21.741]                 }
[13:24:21.741]                 NAMES <- toupper(removed)
[13:24:21.741]                 for (kk in seq_along(NAMES)) {
[13:24:21.741]                   name <- removed[[kk]]
[13:24:21.741]                   NAME <- NAMES[[kk]]
[13:24:21.741]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.741]                     next
[13:24:21.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.741]                 }
[13:24:21.741]                 if (length(args) > 0) 
[13:24:21.741]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.741]             }
[13:24:21.741]             else {
[13:24:21.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.741]             }
[13:24:21.741]             {
[13:24:21.741]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.741]                   0L) {
[13:24:21.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.741]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.741]                   base::options(opts)
[13:24:21.741]                 }
[13:24:21.741]                 {
[13:24:21.741]                   {
[13:24:21.741]                     NULL
[13:24:21.741]                     RNGkind("Mersenne-Twister")
[13:24:21.741]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.741]                       inherits = FALSE)
[13:24:21.741]                   }
[13:24:21.741]                   options(future.plan = NULL)
[13:24:21.741]                   if (is.na(NA_character_)) 
[13:24:21.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.741]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.741]                   {
[13:24:21.741]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.741]                     if (!future$lazy) 
[13:24:21.741]                       future <- run(future)
[13:24:21.741]                     invisible(future)
[13:24:21.741]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.741]                 }
[13:24:21.741]             }
[13:24:21.741]         }
[13:24:21.741]     })
[13:24:21.741]     if (TRUE) {
[13:24:21.741]         base::sink(type = "output", split = FALSE)
[13:24:21.741]         if (TRUE) {
[13:24:21.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.741]         }
[13:24:21.741]         else {
[13:24:21.741]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.741]         }
[13:24:21.741]         base::close(...future.stdout)
[13:24:21.741]         ...future.stdout <- NULL
[13:24:21.741]     }
[13:24:21.741]     ...future.result$conditions <- ...future.conditions
[13:24:21.741]     ...future.result$finished <- base::Sys.time()
[13:24:21.741]     ...future.result
[13:24:21.741] }
[13:24:21.742] plan(): Setting new future strategy stack:
[13:24:21.743] List of future strategies:
[13:24:21.743] 1. sequential:
[13:24:21.743]    - args: function (..., envir = parent.frame())
[13:24:21.743]    - tweaked: FALSE
[13:24:21.743]    - call: NULL
[13:24:21.743] plan(): nbrOfWorkers() = 1
[13:24:21.744] plan(): Setting new future strategy stack:
[13:24:21.744] List of future strategies:
[13:24:21.744] 1. sequential:
[13:24:21.744]    - args: function (..., envir = parent.frame())
[13:24:21.744]    - tweaked: FALSE
[13:24:21.744]    - call: plan(strategy)
[13:24:21.744] plan(): nbrOfWorkers() = 1
[13:24:21.744] SequentialFuture started (and completed)
[13:24:21.744] - Launch lazy future ... done
[13:24:21.745] run() for ‘SequentialFuture’ ... done
[13:24:21.745] resolve() on environment ...
[13:24:21.745]  recursive: 0
[13:24:21.746]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:24:21.746] resolved() for ‘SequentialFuture’ ...
[13:24:21.746] - state: ‘finished’
[13:24:21.746] - run: TRUE
[13:24:21.746] - result: ‘FutureResult’
[13:24:21.746] resolved() for ‘SequentialFuture’ ... done
[13:24:21.746] Future #1
[13:24:21.746]  length: 2 (resolved future 1)
[13:24:21.746] resolved() for ‘SequentialFuture’ ...
[13:24:21.747] - state: ‘finished’
[13:24:21.747] - run: TRUE
[13:24:21.747] - result: ‘FutureResult’
[13:24:21.747] resolved() for ‘SequentialFuture’ ... done
[13:24:21.747] Future #2
[13:24:21.747]  length: 1 (resolved future 2)
[13:24:21.747]  length: 0 (resolved future 3)
[13:24:21.747] resolve() on environment ... DONE
[13:24:21.748] getGlobalsAndPackages() ...
[13:24:21.748] Searching for globals...
[13:24:21.748] - globals found: [1] ‘{’
[13:24:21.748] Searching for globals ... DONE
[13:24:21.749] Resolving globals: FALSE
[13:24:21.749] 
[13:24:21.749] 
[13:24:21.749] getGlobalsAndPackages() ... DONE
[13:24:21.749] run() for ‘Future’ ...
[13:24:21.749] - state: ‘created’
[13:24:21.750] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.750] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.750] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.750]   - Field: ‘label’
[13:24:21.750]   - Field: ‘local’
[13:24:21.750]   - Field: ‘owner’
[13:24:21.750]   - Field: ‘envir’
[13:24:21.750]   - Field: ‘packages’
[13:24:21.750]   - Field: ‘gc’
[13:24:21.751]   - Field: ‘conditions’
[13:24:21.751]   - Field: ‘expr’
[13:24:21.751]   - Field: ‘uuid’
[13:24:21.751]   - Field: ‘seed’
[13:24:21.751]   - Field: ‘version’
[13:24:21.751]   - Field: ‘result’
[13:24:21.751]   - Field: ‘asynchronous’
[13:24:21.751]   - Field: ‘calls’
[13:24:21.751]   - Field: ‘globals’
[13:24:21.751]   - Field: ‘stdout’
[13:24:21.751]   - Field: ‘earlySignal’
[13:24:21.752]   - Field: ‘lazy’
[13:24:21.752]   - Field: ‘state’
[13:24:21.752] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.752] - Launch lazy future ...
[13:24:21.752] Packages needed by the future expression (n = 0): <none>
[13:24:21.752] Packages needed by future strategies (n = 0): <none>
[13:24:21.753] {
[13:24:21.753]     {
[13:24:21.753]         {
[13:24:21.753]             ...future.startTime <- base::Sys.time()
[13:24:21.753]             {
[13:24:21.753]                 {
[13:24:21.753]                   {
[13:24:21.753]                     base::local({
[13:24:21.753]                       has_future <- base::requireNamespace("future", 
[13:24:21.753]                         quietly = TRUE)
[13:24:21.753]                       if (has_future) {
[13:24:21.753]                         ns <- base::getNamespace("future")
[13:24:21.753]                         version <- ns[[".package"]][["version"]]
[13:24:21.753]                         if (is.null(version)) 
[13:24:21.753]                           version <- utils::packageVersion("future")
[13:24:21.753]                       }
[13:24:21.753]                       else {
[13:24:21.753]                         version <- NULL
[13:24:21.753]                       }
[13:24:21.753]                       if (!has_future || version < "1.8.0") {
[13:24:21.753]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.753]                           "", base::R.version$version.string), 
[13:24:21.753]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.753]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.753]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.753]                             "release", "version")], collapse = " "), 
[13:24:21.753]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.753]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.753]                           info)
[13:24:21.753]                         info <- base::paste(info, collapse = "; ")
[13:24:21.753]                         if (!has_future) {
[13:24:21.753]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.753]                             info)
[13:24:21.753]                         }
[13:24:21.753]                         else {
[13:24:21.753]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.753]                             info, version)
[13:24:21.753]                         }
[13:24:21.753]                         base::stop(msg)
[13:24:21.753]                       }
[13:24:21.753]                     })
[13:24:21.753]                   }
[13:24:21.753]                   options(future.plan = NULL)
[13:24:21.753]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.753]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.753]                 }
[13:24:21.753]                 ...future.workdir <- getwd()
[13:24:21.753]             }
[13:24:21.753]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.753]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.753]         }
[13:24:21.753]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.753]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.753]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.753]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.753]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.753]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.753]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.753]             base::names(...future.oldOptions))
[13:24:21.753]     }
[13:24:21.753]     if (FALSE) {
[13:24:21.753]     }
[13:24:21.753]     else {
[13:24:21.753]         if (TRUE) {
[13:24:21.753]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.753]                 open = "w")
[13:24:21.753]         }
[13:24:21.753]         else {
[13:24:21.753]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.753]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.753]         }
[13:24:21.753]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.753]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.753]             base::sink(type = "output", split = FALSE)
[13:24:21.753]             base::close(...future.stdout)
[13:24:21.753]         }, add = TRUE)
[13:24:21.753]     }
[13:24:21.753]     ...future.frame <- base::sys.nframe()
[13:24:21.753]     ...future.conditions <- base::list()
[13:24:21.753]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.753]     if (FALSE) {
[13:24:21.753]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.753]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.753]     }
[13:24:21.753]     ...future.result <- base::tryCatch({
[13:24:21.753]         base::withCallingHandlers({
[13:24:21.753]             ...future.value <- base::withVisible(base::local({
[13:24:21.753]                 1
[13:24:21.753]             }))
[13:24:21.753]             future::FutureResult(value = ...future.value$value, 
[13:24:21.753]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.753]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.753]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.753]                     ...future.globalenv.names))
[13:24:21.753]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.753]         }, condition = base::local({
[13:24:21.753]             c <- base::c
[13:24:21.753]             inherits <- base::inherits
[13:24:21.753]             invokeRestart <- base::invokeRestart
[13:24:21.753]             length <- base::length
[13:24:21.753]             list <- base::list
[13:24:21.753]             seq.int <- base::seq.int
[13:24:21.753]             signalCondition <- base::signalCondition
[13:24:21.753]             sys.calls <- base::sys.calls
[13:24:21.753]             `[[` <- base::`[[`
[13:24:21.753]             `+` <- base::`+`
[13:24:21.753]             `<<-` <- base::`<<-`
[13:24:21.753]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.753]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.753]                   3L)]
[13:24:21.753]             }
[13:24:21.753]             function(cond) {
[13:24:21.753]                 is_error <- inherits(cond, "error")
[13:24:21.753]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.753]                   NULL)
[13:24:21.753]                 if (is_error) {
[13:24:21.753]                   sessionInformation <- function() {
[13:24:21.753]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.753]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.753]                       search = base::search(), system = base::Sys.info())
[13:24:21.753]                   }
[13:24:21.753]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.753]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.753]                     cond$call), session = sessionInformation(), 
[13:24:21.753]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.753]                   signalCondition(cond)
[13:24:21.753]                 }
[13:24:21.753]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.753]                 "immediateCondition"))) {
[13:24:21.753]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.753]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.753]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.753]                   if (TRUE && !signal) {
[13:24:21.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.753]                     {
[13:24:21.753]                       inherits <- base::inherits
[13:24:21.753]                       invokeRestart <- base::invokeRestart
[13:24:21.753]                       is.null <- base::is.null
[13:24:21.753]                       muffled <- FALSE
[13:24:21.753]                       if (inherits(cond, "message")) {
[13:24:21.753]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.753]                         if (muffled) 
[13:24:21.753]                           invokeRestart("muffleMessage")
[13:24:21.753]                       }
[13:24:21.753]                       else if (inherits(cond, "warning")) {
[13:24:21.753]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.753]                         if (muffled) 
[13:24:21.753]                           invokeRestart("muffleWarning")
[13:24:21.753]                       }
[13:24:21.753]                       else if (inherits(cond, "condition")) {
[13:24:21.753]                         if (!is.null(pattern)) {
[13:24:21.753]                           computeRestarts <- base::computeRestarts
[13:24:21.753]                           grepl <- base::grepl
[13:24:21.753]                           restarts <- computeRestarts(cond)
[13:24:21.753]                           for (restart in restarts) {
[13:24:21.753]                             name <- restart$name
[13:24:21.753]                             if (is.null(name)) 
[13:24:21.753]                               next
[13:24:21.753]                             if (!grepl(pattern, name)) 
[13:24:21.753]                               next
[13:24:21.753]                             invokeRestart(restart)
[13:24:21.753]                             muffled <- TRUE
[13:24:21.753]                             break
[13:24:21.753]                           }
[13:24:21.753]                         }
[13:24:21.753]                       }
[13:24:21.753]                       invisible(muffled)
[13:24:21.753]                     }
[13:24:21.753]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.753]                   }
[13:24:21.753]                 }
[13:24:21.753]                 else {
[13:24:21.753]                   if (TRUE) {
[13:24:21.753]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.753]                     {
[13:24:21.753]                       inherits <- base::inherits
[13:24:21.753]                       invokeRestart <- base::invokeRestart
[13:24:21.753]                       is.null <- base::is.null
[13:24:21.753]                       muffled <- FALSE
[13:24:21.753]                       if (inherits(cond, "message")) {
[13:24:21.753]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.753]                         if (muffled) 
[13:24:21.753]                           invokeRestart("muffleMessage")
[13:24:21.753]                       }
[13:24:21.753]                       else if (inherits(cond, "warning")) {
[13:24:21.753]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.753]                         if (muffled) 
[13:24:21.753]                           invokeRestart("muffleWarning")
[13:24:21.753]                       }
[13:24:21.753]                       else if (inherits(cond, "condition")) {
[13:24:21.753]                         if (!is.null(pattern)) {
[13:24:21.753]                           computeRestarts <- base::computeRestarts
[13:24:21.753]                           grepl <- base::grepl
[13:24:21.753]                           restarts <- computeRestarts(cond)
[13:24:21.753]                           for (restart in restarts) {
[13:24:21.753]                             name <- restart$name
[13:24:21.753]                             if (is.null(name)) 
[13:24:21.753]                               next
[13:24:21.753]                             if (!grepl(pattern, name)) 
[13:24:21.753]                               next
[13:24:21.753]                             invokeRestart(restart)
[13:24:21.753]                             muffled <- TRUE
[13:24:21.753]                             break
[13:24:21.753]                           }
[13:24:21.753]                         }
[13:24:21.753]                       }
[13:24:21.753]                       invisible(muffled)
[13:24:21.753]                     }
[13:24:21.753]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.753]                   }
[13:24:21.753]                 }
[13:24:21.753]             }
[13:24:21.753]         }))
[13:24:21.753]     }, error = function(ex) {
[13:24:21.753]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.753]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.753]                 ...future.rng), started = ...future.startTime, 
[13:24:21.753]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.753]             version = "1.8"), class = "FutureResult")
[13:24:21.753]     }, finally = {
[13:24:21.753]         if (!identical(...future.workdir, getwd())) 
[13:24:21.753]             setwd(...future.workdir)
[13:24:21.753]         {
[13:24:21.753]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.753]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.753]             }
[13:24:21.753]             base::options(...future.oldOptions)
[13:24:21.753]             if (.Platform$OS.type == "windows") {
[13:24:21.753]                 old_names <- names(...future.oldEnvVars)
[13:24:21.753]                 envs <- base::Sys.getenv()
[13:24:21.753]                 names <- names(envs)
[13:24:21.753]                 common <- intersect(names, old_names)
[13:24:21.753]                 added <- setdiff(names, old_names)
[13:24:21.753]                 removed <- setdiff(old_names, names)
[13:24:21.753]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.753]                   envs[common]]
[13:24:21.753]                 NAMES <- toupper(changed)
[13:24:21.753]                 args <- list()
[13:24:21.753]                 for (kk in seq_along(NAMES)) {
[13:24:21.753]                   name <- changed[[kk]]
[13:24:21.753]                   NAME <- NAMES[[kk]]
[13:24:21.753]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.753]                     next
[13:24:21.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.753]                 }
[13:24:21.753]                 NAMES <- toupper(added)
[13:24:21.753]                 for (kk in seq_along(NAMES)) {
[13:24:21.753]                   name <- added[[kk]]
[13:24:21.753]                   NAME <- NAMES[[kk]]
[13:24:21.753]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.753]                     next
[13:24:21.753]                   args[[name]] <- ""
[13:24:21.753]                 }
[13:24:21.753]                 NAMES <- toupper(removed)
[13:24:21.753]                 for (kk in seq_along(NAMES)) {
[13:24:21.753]                   name <- removed[[kk]]
[13:24:21.753]                   NAME <- NAMES[[kk]]
[13:24:21.753]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.753]                     next
[13:24:21.753]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.753]                 }
[13:24:21.753]                 if (length(args) > 0) 
[13:24:21.753]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.753]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.753]             }
[13:24:21.753]             else {
[13:24:21.753]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.753]             }
[13:24:21.753]             {
[13:24:21.753]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.753]                   0L) {
[13:24:21.753]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.753]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.753]                   base::options(opts)
[13:24:21.753]                 }
[13:24:21.753]                 {
[13:24:21.753]                   {
[13:24:21.753]                     NULL
[13:24:21.753]                     RNGkind("Mersenne-Twister")
[13:24:21.753]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.753]                       inherits = FALSE)
[13:24:21.753]                   }
[13:24:21.753]                   options(future.plan = NULL)
[13:24:21.753]                   if (is.na(NA_character_)) 
[13:24:21.753]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.753]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.753]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.753]                   {
[13:24:21.753]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.753]                     if (!future$lazy) 
[13:24:21.753]                       future <- run(future)
[13:24:21.753]                     invisible(future)
[13:24:21.753]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.753]                 }
[13:24:21.753]             }
[13:24:21.753]         }
[13:24:21.753]     })
[13:24:21.753]     if (TRUE) {
[13:24:21.753]         base::sink(type = "output", split = FALSE)
[13:24:21.753]         if (TRUE) {
[13:24:21.753]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.753]         }
[13:24:21.753]         else {
[13:24:21.753]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.753]         }
[13:24:21.753]         base::close(...future.stdout)
[13:24:21.753]         ...future.stdout <- NULL
[13:24:21.753]     }
[13:24:21.753]     ...future.result$conditions <- ...future.conditions
[13:24:21.753]     ...future.result$finished <- base::Sys.time()
[13:24:21.753]     ...future.result
[13:24:21.753] }
[13:24:21.755] plan(): Setting new future strategy stack:
[13:24:21.755] List of future strategies:
[13:24:21.755] 1. sequential:
[13:24:21.755]    - args: function (..., envir = parent.frame())
[13:24:21.755]    - tweaked: FALSE
[13:24:21.755]    - call: NULL
[13:24:21.755] plan(): nbrOfWorkers() = 1
[13:24:21.758] plan(): Setting new future strategy stack:
[13:24:21.758] List of future strategies:
[13:24:21.758] 1. sequential:
[13:24:21.758]    - args: function (..., envir = parent.frame())
[13:24:21.758]    - tweaked: FALSE
[13:24:21.758]    - call: plan(strategy)
[13:24:21.758] plan(): nbrOfWorkers() = 1
[13:24:21.758] SequentialFuture started (and completed)
[13:24:21.758] - Launch lazy future ... done
[13:24:21.759] run() for ‘SequentialFuture’ ... done
[13:24:21.759] getGlobalsAndPackages() ...
[13:24:21.759] Searching for globals...
[13:24:21.760] - globals found: [1] ‘{’
[13:24:21.760] Searching for globals ... DONE
[13:24:21.760] Resolving globals: FALSE
[13:24:21.760] 
[13:24:21.760] 
[13:24:21.760] getGlobalsAndPackages() ... DONE
[13:24:21.760] run() for ‘Future’ ...
[13:24:21.761] - state: ‘created’
[13:24:21.761] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.761] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.761] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.761]   - Field: ‘label’
[13:24:21.761]   - Field: ‘local’
[13:24:21.761]   - Field: ‘owner’
[13:24:21.761]   - Field: ‘envir’
[13:24:21.762]   - Field: ‘packages’
[13:24:21.762]   - Field: ‘gc’
[13:24:21.762]   - Field: ‘conditions’
[13:24:21.762]   - Field: ‘expr’
[13:24:21.762]   - Field: ‘uuid’
[13:24:21.762]   - Field: ‘seed’
[13:24:21.762]   - Field: ‘version’
[13:24:21.762]   - Field: ‘result’
[13:24:21.762]   - Field: ‘asynchronous’
[13:24:21.762]   - Field: ‘calls’
[13:24:21.762]   - Field: ‘globals’
[13:24:21.763]   - Field: ‘stdout’
[13:24:21.763]   - Field: ‘earlySignal’
[13:24:21.763]   - Field: ‘lazy’
[13:24:21.763]   - Field: ‘state’
[13:24:21.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.763] - Launch lazy future ...
[13:24:21.763] Packages needed by the future expression (n = 0): <none>
[13:24:21.763] Packages needed by future strategies (n = 0): <none>
[13:24:21.764] {
[13:24:21.764]     {
[13:24:21.764]         {
[13:24:21.764]             ...future.startTime <- base::Sys.time()
[13:24:21.764]             {
[13:24:21.764]                 {
[13:24:21.764]                   {
[13:24:21.764]                     base::local({
[13:24:21.764]                       has_future <- base::requireNamespace("future", 
[13:24:21.764]                         quietly = TRUE)
[13:24:21.764]                       if (has_future) {
[13:24:21.764]                         ns <- base::getNamespace("future")
[13:24:21.764]                         version <- ns[[".package"]][["version"]]
[13:24:21.764]                         if (is.null(version)) 
[13:24:21.764]                           version <- utils::packageVersion("future")
[13:24:21.764]                       }
[13:24:21.764]                       else {
[13:24:21.764]                         version <- NULL
[13:24:21.764]                       }
[13:24:21.764]                       if (!has_future || version < "1.8.0") {
[13:24:21.764]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.764]                           "", base::R.version$version.string), 
[13:24:21.764]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.764]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.764]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.764]                             "release", "version")], collapse = " "), 
[13:24:21.764]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.764]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.764]                           info)
[13:24:21.764]                         info <- base::paste(info, collapse = "; ")
[13:24:21.764]                         if (!has_future) {
[13:24:21.764]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.764]                             info)
[13:24:21.764]                         }
[13:24:21.764]                         else {
[13:24:21.764]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.764]                             info, version)
[13:24:21.764]                         }
[13:24:21.764]                         base::stop(msg)
[13:24:21.764]                       }
[13:24:21.764]                     })
[13:24:21.764]                   }
[13:24:21.764]                   options(future.plan = NULL)
[13:24:21.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.764]                 }
[13:24:21.764]                 ...future.workdir <- getwd()
[13:24:21.764]             }
[13:24:21.764]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.764]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.764]         }
[13:24:21.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.764]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.764]             base::names(...future.oldOptions))
[13:24:21.764]     }
[13:24:21.764]     if (FALSE) {
[13:24:21.764]     }
[13:24:21.764]     else {
[13:24:21.764]         if (TRUE) {
[13:24:21.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.764]                 open = "w")
[13:24:21.764]         }
[13:24:21.764]         else {
[13:24:21.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.764]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.764]         }
[13:24:21.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.764]             base::sink(type = "output", split = FALSE)
[13:24:21.764]             base::close(...future.stdout)
[13:24:21.764]         }, add = TRUE)
[13:24:21.764]     }
[13:24:21.764]     ...future.frame <- base::sys.nframe()
[13:24:21.764]     ...future.conditions <- base::list()
[13:24:21.764]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.764]     if (FALSE) {
[13:24:21.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.764]     }
[13:24:21.764]     ...future.result <- base::tryCatch({
[13:24:21.764]         base::withCallingHandlers({
[13:24:21.764]             ...future.value <- base::withVisible(base::local({
[13:24:21.764]                 2
[13:24:21.764]             }))
[13:24:21.764]             future::FutureResult(value = ...future.value$value, 
[13:24:21.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.764]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.764]                     ...future.globalenv.names))
[13:24:21.764]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.764]         }, condition = base::local({
[13:24:21.764]             c <- base::c
[13:24:21.764]             inherits <- base::inherits
[13:24:21.764]             invokeRestart <- base::invokeRestart
[13:24:21.764]             length <- base::length
[13:24:21.764]             list <- base::list
[13:24:21.764]             seq.int <- base::seq.int
[13:24:21.764]             signalCondition <- base::signalCondition
[13:24:21.764]             sys.calls <- base::sys.calls
[13:24:21.764]             `[[` <- base::`[[`
[13:24:21.764]             `+` <- base::`+`
[13:24:21.764]             `<<-` <- base::`<<-`
[13:24:21.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.764]                   3L)]
[13:24:21.764]             }
[13:24:21.764]             function(cond) {
[13:24:21.764]                 is_error <- inherits(cond, "error")
[13:24:21.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.764]                   NULL)
[13:24:21.764]                 if (is_error) {
[13:24:21.764]                   sessionInformation <- function() {
[13:24:21.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.764]                       search = base::search(), system = base::Sys.info())
[13:24:21.764]                   }
[13:24:21.764]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.764]                     cond$call), session = sessionInformation(), 
[13:24:21.764]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.764]                   signalCondition(cond)
[13:24:21.764]                 }
[13:24:21.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.764]                 "immediateCondition"))) {
[13:24:21.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.764]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.764]                   if (TRUE && !signal) {
[13:24:21.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.764]                     {
[13:24:21.764]                       inherits <- base::inherits
[13:24:21.764]                       invokeRestart <- base::invokeRestart
[13:24:21.764]                       is.null <- base::is.null
[13:24:21.764]                       muffled <- FALSE
[13:24:21.764]                       if (inherits(cond, "message")) {
[13:24:21.764]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.764]                         if (muffled) 
[13:24:21.764]                           invokeRestart("muffleMessage")
[13:24:21.764]                       }
[13:24:21.764]                       else if (inherits(cond, "warning")) {
[13:24:21.764]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.764]                         if (muffled) 
[13:24:21.764]                           invokeRestart("muffleWarning")
[13:24:21.764]                       }
[13:24:21.764]                       else if (inherits(cond, "condition")) {
[13:24:21.764]                         if (!is.null(pattern)) {
[13:24:21.764]                           computeRestarts <- base::computeRestarts
[13:24:21.764]                           grepl <- base::grepl
[13:24:21.764]                           restarts <- computeRestarts(cond)
[13:24:21.764]                           for (restart in restarts) {
[13:24:21.764]                             name <- restart$name
[13:24:21.764]                             if (is.null(name)) 
[13:24:21.764]                               next
[13:24:21.764]                             if (!grepl(pattern, name)) 
[13:24:21.764]                               next
[13:24:21.764]                             invokeRestart(restart)
[13:24:21.764]                             muffled <- TRUE
[13:24:21.764]                             break
[13:24:21.764]                           }
[13:24:21.764]                         }
[13:24:21.764]                       }
[13:24:21.764]                       invisible(muffled)
[13:24:21.764]                     }
[13:24:21.764]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.764]                   }
[13:24:21.764]                 }
[13:24:21.764]                 else {
[13:24:21.764]                   if (TRUE) {
[13:24:21.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.764]                     {
[13:24:21.764]                       inherits <- base::inherits
[13:24:21.764]                       invokeRestart <- base::invokeRestart
[13:24:21.764]                       is.null <- base::is.null
[13:24:21.764]                       muffled <- FALSE
[13:24:21.764]                       if (inherits(cond, "message")) {
[13:24:21.764]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.764]                         if (muffled) 
[13:24:21.764]                           invokeRestart("muffleMessage")
[13:24:21.764]                       }
[13:24:21.764]                       else if (inherits(cond, "warning")) {
[13:24:21.764]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.764]                         if (muffled) 
[13:24:21.764]                           invokeRestart("muffleWarning")
[13:24:21.764]                       }
[13:24:21.764]                       else if (inherits(cond, "condition")) {
[13:24:21.764]                         if (!is.null(pattern)) {
[13:24:21.764]                           computeRestarts <- base::computeRestarts
[13:24:21.764]                           grepl <- base::grepl
[13:24:21.764]                           restarts <- computeRestarts(cond)
[13:24:21.764]                           for (restart in restarts) {
[13:24:21.764]                             name <- restart$name
[13:24:21.764]                             if (is.null(name)) 
[13:24:21.764]                               next
[13:24:21.764]                             if (!grepl(pattern, name)) 
[13:24:21.764]                               next
[13:24:21.764]                             invokeRestart(restart)
[13:24:21.764]                             muffled <- TRUE
[13:24:21.764]                             break
[13:24:21.764]                           }
[13:24:21.764]                         }
[13:24:21.764]                       }
[13:24:21.764]                       invisible(muffled)
[13:24:21.764]                     }
[13:24:21.764]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.764]                   }
[13:24:21.764]                 }
[13:24:21.764]             }
[13:24:21.764]         }))
[13:24:21.764]     }, error = function(ex) {
[13:24:21.764]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.764]                 ...future.rng), started = ...future.startTime, 
[13:24:21.764]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.764]             version = "1.8"), class = "FutureResult")
[13:24:21.764]     }, finally = {
[13:24:21.764]         if (!identical(...future.workdir, getwd())) 
[13:24:21.764]             setwd(...future.workdir)
[13:24:21.764]         {
[13:24:21.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.764]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.764]             }
[13:24:21.764]             base::options(...future.oldOptions)
[13:24:21.764]             if (.Platform$OS.type == "windows") {
[13:24:21.764]                 old_names <- names(...future.oldEnvVars)
[13:24:21.764]                 envs <- base::Sys.getenv()
[13:24:21.764]                 names <- names(envs)
[13:24:21.764]                 common <- intersect(names, old_names)
[13:24:21.764]                 added <- setdiff(names, old_names)
[13:24:21.764]                 removed <- setdiff(old_names, names)
[13:24:21.764]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.764]                   envs[common]]
[13:24:21.764]                 NAMES <- toupper(changed)
[13:24:21.764]                 args <- list()
[13:24:21.764]                 for (kk in seq_along(NAMES)) {
[13:24:21.764]                   name <- changed[[kk]]
[13:24:21.764]                   NAME <- NAMES[[kk]]
[13:24:21.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.764]                     next
[13:24:21.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.764]                 }
[13:24:21.764]                 NAMES <- toupper(added)
[13:24:21.764]                 for (kk in seq_along(NAMES)) {
[13:24:21.764]                   name <- added[[kk]]
[13:24:21.764]                   NAME <- NAMES[[kk]]
[13:24:21.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.764]                     next
[13:24:21.764]                   args[[name]] <- ""
[13:24:21.764]                 }
[13:24:21.764]                 NAMES <- toupper(removed)
[13:24:21.764]                 for (kk in seq_along(NAMES)) {
[13:24:21.764]                   name <- removed[[kk]]
[13:24:21.764]                   NAME <- NAMES[[kk]]
[13:24:21.764]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.764]                     next
[13:24:21.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.764]                 }
[13:24:21.764]                 if (length(args) > 0) 
[13:24:21.764]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.764]             }
[13:24:21.764]             else {
[13:24:21.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.764]             }
[13:24:21.764]             {
[13:24:21.764]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.764]                   0L) {
[13:24:21.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.764]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.764]                   base::options(opts)
[13:24:21.764]                 }
[13:24:21.764]                 {
[13:24:21.764]                   {
[13:24:21.764]                     NULL
[13:24:21.764]                     RNGkind("Mersenne-Twister")
[13:24:21.764]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.764]                       inherits = FALSE)
[13:24:21.764]                   }
[13:24:21.764]                   options(future.plan = NULL)
[13:24:21.764]                   if (is.na(NA_character_)) 
[13:24:21.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.764]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.764]                   {
[13:24:21.764]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.764]                     if (!future$lazy) 
[13:24:21.764]                       future <- run(future)
[13:24:21.764]                     invisible(future)
[13:24:21.764]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.764]                 }
[13:24:21.764]             }
[13:24:21.764]         }
[13:24:21.764]     })
[13:24:21.764]     if (TRUE) {
[13:24:21.764]         base::sink(type = "output", split = FALSE)
[13:24:21.764]         if (TRUE) {
[13:24:21.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.764]         }
[13:24:21.764]         else {
[13:24:21.764]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.764]         }
[13:24:21.764]         base::close(...future.stdout)
[13:24:21.764]         ...future.stdout <- NULL
[13:24:21.764]     }
[13:24:21.764]     ...future.result$conditions <- ...future.conditions
[13:24:21.764]     ...future.result$finished <- base::Sys.time()
[13:24:21.764]     ...future.result
[13:24:21.764] }
[13:24:21.766] plan(): Setting new future strategy stack:
[13:24:21.766] List of future strategies:
[13:24:21.766] 1. sequential:
[13:24:21.766]    - args: function (..., envir = parent.frame())
[13:24:21.766]    - tweaked: FALSE
[13:24:21.766]    - call: NULL
[13:24:21.766] plan(): nbrOfWorkers() = 1
[13:24:21.767] plan(): Setting new future strategy stack:
[13:24:21.767] List of future strategies:
[13:24:21.767] 1. sequential:
[13:24:21.767]    - args: function (..., envir = parent.frame())
[13:24:21.767]    - tweaked: FALSE
[13:24:21.767]    - call: plan(strategy)
[13:24:21.767] plan(): nbrOfWorkers() = 1
[13:24:21.767] SequentialFuture started (and completed)
[13:24:21.767] - Launch lazy future ... done
[13:24:21.768] run() for ‘SequentialFuture’ ... done
[13:24:21.768] resolve() on environment ...
[13:24:21.768]  recursive: 0
[13:24:21.769]  elements: [3] ‘a’
[13:24:21.769] resolved() for ‘SequentialFuture’ ...
[13:24:21.769] - state: ‘finished’
[13:24:21.769] - run: TRUE
[13:24:21.769] - result: ‘FutureResult’
[13:24:21.769] resolved() for ‘SequentialFuture’ ... done
[13:24:21.769] Future #1
[13:24:21.769]  length: 2 (resolved future 1)
[13:24:21.769] resolved() for ‘SequentialFuture’ ...
[13:24:21.770] - state: ‘finished’
[13:24:21.770] - run: TRUE
[13:24:21.770] - result: ‘FutureResult’
[13:24:21.770] resolved() for ‘SequentialFuture’ ... done
[13:24:21.770] Future #2
[13:24:21.770]  length: 1 (resolved future 2)
[13:24:21.770]  length: 0 (resolved future 3)
[13:24:21.770] resolve() on environment ... DONE
[13:24:21.770] resolved() for ‘SequentialFuture’ ...
[13:24:21.770] - state: ‘finished’
[13:24:21.771] - run: TRUE
[13:24:21.771] - result: ‘FutureResult’
[13:24:21.771] resolved() for ‘SequentialFuture’ ... done
[13:24:21.771] resolve() on environment ...
[13:24:21.771]  recursive: 0
[13:24:21.772]  elements: [3] ‘b’
[13:24:21.772] resolved() for ‘SequentialFuture’ ...
[13:24:21.772] - state: ‘finished’
[13:24:21.772] - run: TRUE
[13:24:21.772] - result: ‘FutureResult’
[13:24:21.772] resolved() for ‘SequentialFuture’ ... done
[13:24:21.772] Future #1
[13:24:21.772]  length: 2 (resolved future 1)
[13:24:21.773] resolved() for ‘SequentialFuture’ ...
[13:24:21.773] - state: ‘finished’
[13:24:21.773] - run: TRUE
[13:24:21.773] - result: ‘FutureResult’
[13:24:21.773] resolved() for ‘SequentialFuture’ ... done
[13:24:21.773] Future #2
[13:24:21.773]  length: 1 (resolved future 2)
[13:24:21.773]  length: 0 (resolved future 3)
[13:24:21.773] resolve() on environment ... DONE
[13:24:21.774] resolve() on environment ...
[13:24:21.774]  recursive: 0
[13:24:21.774]  elements: [3] ‘c’
[13:24:21.774] resolved() for ‘SequentialFuture’ ...
[13:24:21.774] - state: ‘finished’
[13:24:21.775] - run: TRUE
[13:24:21.775] - result: ‘FutureResult’
[13:24:21.775] resolved() for ‘SequentialFuture’ ... done
[13:24:21.775] Future #1
[13:24:21.775]  length: 2 (resolved future 1)
[13:24:21.775] resolved() for ‘SequentialFuture’ ...
[13:24:21.775] - state: ‘finished’
[13:24:21.775] - run: TRUE
[13:24:21.775] - result: ‘FutureResult’
[13:24:21.775] resolved() for ‘SequentialFuture’ ... done
[13:24:21.775] Future #2
[13:24:21.776]  length: 1 (resolved future 2)
[13:24:21.776]  length: 0 (resolved future 3)
[13:24:21.776] resolve() on environment ... DONE
[13:24:21.776] resolve() on environment ...
[13:24:21.776]  recursive: 0
[13:24:21.777]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:24:21.777] resolved() for ‘SequentialFuture’ ...
[13:24:21.777] - state: ‘finished’
[13:24:21.777] - run: TRUE
[13:24:21.777] - result: ‘FutureResult’
[13:24:21.777] resolved() for ‘SequentialFuture’ ... done
[13:24:21.777] Future #1
[13:24:21.778]  length: 2 (resolved future 1)
[13:24:21.778] resolved() for ‘SequentialFuture’ ...
[13:24:21.778] - state: ‘finished’
[13:24:21.778] - run: TRUE
[13:24:21.778] - result: ‘FutureResult’
[13:24:21.778] resolved() for ‘SequentialFuture’ ... done
[13:24:21.778] Future #2
[13:24:21.779]  length: 1 (resolved future 2)
[13:24:21.779]  length: 0 (resolved future 3)
[13:24:21.779] resolve() on environment ... DONE
[13:24:21.779] resolve() on environment ...
[13:24:21.779]  recursive: 99
[13:24:21.780]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:24:21.780] resolved() for ‘SequentialFuture’ ...
[13:24:21.780] - state: ‘finished’
[13:24:21.780] - run: TRUE
[13:24:21.780] - result: ‘FutureResult’
[13:24:21.780] resolved() for ‘SequentialFuture’ ... done
[13:24:21.780] Future #1
[13:24:21.781] resolved() for ‘SequentialFuture’ ...
[13:24:21.781] - state: ‘finished’
[13:24:21.781] - run: TRUE
[13:24:21.781] - result: ‘FutureResult’
[13:24:21.781] resolved() for ‘SequentialFuture’ ... done
[13:24:21.781] A SequentialFuture was resolved
[13:24:21.781]  length: 2 (resolved future 1)
[13:24:21.781] resolved() for ‘SequentialFuture’ ...
[13:24:21.783] - state: ‘finished’
[13:24:21.783] - run: TRUE
[13:24:21.783] - result: ‘FutureResult’
[13:24:21.783] resolved() for ‘SequentialFuture’ ... done
[13:24:21.783] Future #2
[13:24:21.784] resolved() for ‘SequentialFuture’ ...
[13:24:21.784] - state: ‘finished’
[13:24:21.784] - run: TRUE
[13:24:21.784] - result: ‘FutureResult’
[13:24:21.784] resolved() for ‘SequentialFuture’ ... done
[13:24:21.784] A SequentialFuture was resolved
[13:24:21.784]  length: 1 (resolved future 2)
[13:24:21.784]  length: 0 (resolved future 3)
[13:24:21.784] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:24:21.786] resolve() on list environment ...
[13:24:21.786]  recursive: 0
[13:24:21.787]  length: 2
[13:24:21.787]  elements: ‘a’, ‘b’
[13:24:21.787]  length: 1 (resolved future 1)
[13:24:21.787]  length: 0 (resolved future 2)
[13:24:21.787] resolve() on list environment ... DONE
[13:24:21.787] getGlobalsAndPackages() ...
[13:24:21.787] Searching for globals...
[13:24:21.788] 
[13:24:21.788] Searching for globals ... DONE
[13:24:21.788] - globals: [0] <none>
[13:24:21.788] getGlobalsAndPackages() ... DONE
[13:24:21.788] run() for ‘Future’ ...
[13:24:21.788] - state: ‘created’
[13:24:21.788] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.789] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.789]   - Field: ‘label’
[13:24:21.789]   - Field: ‘local’
[13:24:21.789]   - Field: ‘owner’
[13:24:21.789]   - Field: ‘envir’
[13:24:21.789]   - Field: ‘packages’
[13:24:21.789]   - Field: ‘gc’
[13:24:21.790]   - Field: ‘conditions’
[13:24:21.790]   - Field: ‘expr’
[13:24:21.790]   - Field: ‘uuid’
[13:24:21.790]   - Field: ‘seed’
[13:24:21.790]   - Field: ‘version’
[13:24:21.790]   - Field: ‘result’
[13:24:21.790]   - Field: ‘asynchronous’
[13:24:21.790]   - Field: ‘calls’
[13:24:21.790]   - Field: ‘globals’
[13:24:21.790]   - Field: ‘stdout’
[13:24:21.790]   - Field: ‘earlySignal’
[13:24:21.791]   - Field: ‘lazy’
[13:24:21.791]   - Field: ‘state’
[13:24:21.791] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.791] - Launch lazy future ...
[13:24:21.791] Packages needed by the future expression (n = 0): <none>
[13:24:21.791] Packages needed by future strategies (n = 0): <none>
[13:24:21.792] {
[13:24:21.792]     {
[13:24:21.792]         {
[13:24:21.792]             ...future.startTime <- base::Sys.time()
[13:24:21.792]             {
[13:24:21.792]                 {
[13:24:21.792]                   {
[13:24:21.792]                     base::local({
[13:24:21.792]                       has_future <- base::requireNamespace("future", 
[13:24:21.792]                         quietly = TRUE)
[13:24:21.792]                       if (has_future) {
[13:24:21.792]                         ns <- base::getNamespace("future")
[13:24:21.792]                         version <- ns[[".package"]][["version"]]
[13:24:21.792]                         if (is.null(version)) 
[13:24:21.792]                           version <- utils::packageVersion("future")
[13:24:21.792]                       }
[13:24:21.792]                       else {
[13:24:21.792]                         version <- NULL
[13:24:21.792]                       }
[13:24:21.792]                       if (!has_future || version < "1.8.0") {
[13:24:21.792]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.792]                           "", base::R.version$version.string), 
[13:24:21.792]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.792]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.792]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.792]                             "release", "version")], collapse = " "), 
[13:24:21.792]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.792]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.792]                           info)
[13:24:21.792]                         info <- base::paste(info, collapse = "; ")
[13:24:21.792]                         if (!has_future) {
[13:24:21.792]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.792]                             info)
[13:24:21.792]                         }
[13:24:21.792]                         else {
[13:24:21.792]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.792]                             info, version)
[13:24:21.792]                         }
[13:24:21.792]                         base::stop(msg)
[13:24:21.792]                       }
[13:24:21.792]                     })
[13:24:21.792]                   }
[13:24:21.792]                   options(future.plan = NULL)
[13:24:21.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.792]                 }
[13:24:21.792]                 ...future.workdir <- getwd()
[13:24:21.792]             }
[13:24:21.792]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.792]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.792]         }
[13:24:21.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.792]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.792]             base::names(...future.oldOptions))
[13:24:21.792]     }
[13:24:21.792]     if (FALSE) {
[13:24:21.792]     }
[13:24:21.792]     else {
[13:24:21.792]         if (TRUE) {
[13:24:21.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.792]                 open = "w")
[13:24:21.792]         }
[13:24:21.792]         else {
[13:24:21.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.792]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.792]         }
[13:24:21.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.792]             base::sink(type = "output", split = FALSE)
[13:24:21.792]             base::close(...future.stdout)
[13:24:21.792]         }, add = TRUE)
[13:24:21.792]     }
[13:24:21.792]     ...future.frame <- base::sys.nframe()
[13:24:21.792]     ...future.conditions <- base::list()
[13:24:21.792]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.792]     if (FALSE) {
[13:24:21.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.792]     }
[13:24:21.792]     ...future.result <- base::tryCatch({
[13:24:21.792]         base::withCallingHandlers({
[13:24:21.792]             ...future.value <- base::withVisible(base::local(1))
[13:24:21.792]             future::FutureResult(value = ...future.value$value, 
[13:24:21.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.792]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.792]                     ...future.globalenv.names))
[13:24:21.792]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.792]         }, condition = base::local({
[13:24:21.792]             c <- base::c
[13:24:21.792]             inherits <- base::inherits
[13:24:21.792]             invokeRestart <- base::invokeRestart
[13:24:21.792]             length <- base::length
[13:24:21.792]             list <- base::list
[13:24:21.792]             seq.int <- base::seq.int
[13:24:21.792]             signalCondition <- base::signalCondition
[13:24:21.792]             sys.calls <- base::sys.calls
[13:24:21.792]             `[[` <- base::`[[`
[13:24:21.792]             `+` <- base::`+`
[13:24:21.792]             `<<-` <- base::`<<-`
[13:24:21.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.792]                   3L)]
[13:24:21.792]             }
[13:24:21.792]             function(cond) {
[13:24:21.792]                 is_error <- inherits(cond, "error")
[13:24:21.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.792]                   NULL)
[13:24:21.792]                 if (is_error) {
[13:24:21.792]                   sessionInformation <- function() {
[13:24:21.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.792]                       search = base::search(), system = base::Sys.info())
[13:24:21.792]                   }
[13:24:21.792]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.792]                     cond$call), session = sessionInformation(), 
[13:24:21.792]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.792]                   signalCondition(cond)
[13:24:21.792]                 }
[13:24:21.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.792]                 "immediateCondition"))) {
[13:24:21.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.792]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.792]                   if (TRUE && !signal) {
[13:24:21.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.792]                     {
[13:24:21.792]                       inherits <- base::inherits
[13:24:21.792]                       invokeRestart <- base::invokeRestart
[13:24:21.792]                       is.null <- base::is.null
[13:24:21.792]                       muffled <- FALSE
[13:24:21.792]                       if (inherits(cond, "message")) {
[13:24:21.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.792]                         if (muffled) 
[13:24:21.792]                           invokeRestart("muffleMessage")
[13:24:21.792]                       }
[13:24:21.792]                       else if (inherits(cond, "warning")) {
[13:24:21.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.792]                         if (muffled) 
[13:24:21.792]                           invokeRestart("muffleWarning")
[13:24:21.792]                       }
[13:24:21.792]                       else if (inherits(cond, "condition")) {
[13:24:21.792]                         if (!is.null(pattern)) {
[13:24:21.792]                           computeRestarts <- base::computeRestarts
[13:24:21.792]                           grepl <- base::grepl
[13:24:21.792]                           restarts <- computeRestarts(cond)
[13:24:21.792]                           for (restart in restarts) {
[13:24:21.792]                             name <- restart$name
[13:24:21.792]                             if (is.null(name)) 
[13:24:21.792]                               next
[13:24:21.792]                             if (!grepl(pattern, name)) 
[13:24:21.792]                               next
[13:24:21.792]                             invokeRestart(restart)
[13:24:21.792]                             muffled <- TRUE
[13:24:21.792]                             break
[13:24:21.792]                           }
[13:24:21.792]                         }
[13:24:21.792]                       }
[13:24:21.792]                       invisible(muffled)
[13:24:21.792]                     }
[13:24:21.792]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.792]                   }
[13:24:21.792]                 }
[13:24:21.792]                 else {
[13:24:21.792]                   if (TRUE) {
[13:24:21.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.792]                     {
[13:24:21.792]                       inherits <- base::inherits
[13:24:21.792]                       invokeRestart <- base::invokeRestart
[13:24:21.792]                       is.null <- base::is.null
[13:24:21.792]                       muffled <- FALSE
[13:24:21.792]                       if (inherits(cond, "message")) {
[13:24:21.792]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.792]                         if (muffled) 
[13:24:21.792]                           invokeRestart("muffleMessage")
[13:24:21.792]                       }
[13:24:21.792]                       else if (inherits(cond, "warning")) {
[13:24:21.792]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.792]                         if (muffled) 
[13:24:21.792]                           invokeRestart("muffleWarning")
[13:24:21.792]                       }
[13:24:21.792]                       else if (inherits(cond, "condition")) {
[13:24:21.792]                         if (!is.null(pattern)) {
[13:24:21.792]                           computeRestarts <- base::computeRestarts
[13:24:21.792]                           grepl <- base::grepl
[13:24:21.792]                           restarts <- computeRestarts(cond)
[13:24:21.792]                           for (restart in restarts) {
[13:24:21.792]                             name <- restart$name
[13:24:21.792]                             if (is.null(name)) 
[13:24:21.792]                               next
[13:24:21.792]                             if (!grepl(pattern, name)) 
[13:24:21.792]                               next
[13:24:21.792]                             invokeRestart(restart)
[13:24:21.792]                             muffled <- TRUE
[13:24:21.792]                             break
[13:24:21.792]                           }
[13:24:21.792]                         }
[13:24:21.792]                       }
[13:24:21.792]                       invisible(muffled)
[13:24:21.792]                     }
[13:24:21.792]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.792]                   }
[13:24:21.792]                 }
[13:24:21.792]             }
[13:24:21.792]         }))
[13:24:21.792]     }, error = function(ex) {
[13:24:21.792]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.792]                 ...future.rng), started = ...future.startTime, 
[13:24:21.792]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.792]             version = "1.8"), class = "FutureResult")
[13:24:21.792]     }, finally = {
[13:24:21.792]         if (!identical(...future.workdir, getwd())) 
[13:24:21.792]             setwd(...future.workdir)
[13:24:21.792]         {
[13:24:21.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.792]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.792]             }
[13:24:21.792]             base::options(...future.oldOptions)
[13:24:21.792]             if (.Platform$OS.type == "windows") {
[13:24:21.792]                 old_names <- names(...future.oldEnvVars)
[13:24:21.792]                 envs <- base::Sys.getenv()
[13:24:21.792]                 names <- names(envs)
[13:24:21.792]                 common <- intersect(names, old_names)
[13:24:21.792]                 added <- setdiff(names, old_names)
[13:24:21.792]                 removed <- setdiff(old_names, names)
[13:24:21.792]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.792]                   envs[common]]
[13:24:21.792]                 NAMES <- toupper(changed)
[13:24:21.792]                 args <- list()
[13:24:21.792]                 for (kk in seq_along(NAMES)) {
[13:24:21.792]                   name <- changed[[kk]]
[13:24:21.792]                   NAME <- NAMES[[kk]]
[13:24:21.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.792]                     next
[13:24:21.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.792]                 }
[13:24:21.792]                 NAMES <- toupper(added)
[13:24:21.792]                 for (kk in seq_along(NAMES)) {
[13:24:21.792]                   name <- added[[kk]]
[13:24:21.792]                   NAME <- NAMES[[kk]]
[13:24:21.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.792]                     next
[13:24:21.792]                   args[[name]] <- ""
[13:24:21.792]                 }
[13:24:21.792]                 NAMES <- toupper(removed)
[13:24:21.792]                 for (kk in seq_along(NAMES)) {
[13:24:21.792]                   name <- removed[[kk]]
[13:24:21.792]                   NAME <- NAMES[[kk]]
[13:24:21.792]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.792]                     next
[13:24:21.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.792]                 }
[13:24:21.792]                 if (length(args) > 0) 
[13:24:21.792]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.792]             }
[13:24:21.792]             else {
[13:24:21.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.792]             }
[13:24:21.792]             {
[13:24:21.792]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.792]                   0L) {
[13:24:21.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.792]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.792]                   base::options(opts)
[13:24:21.792]                 }
[13:24:21.792]                 {
[13:24:21.792]                   {
[13:24:21.792]                     NULL
[13:24:21.792]                     RNGkind("Mersenne-Twister")
[13:24:21.792]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.792]                       inherits = FALSE)
[13:24:21.792]                   }
[13:24:21.792]                   options(future.plan = NULL)
[13:24:21.792]                   if (is.na(NA_character_)) 
[13:24:21.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.792]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.792]                   {
[13:24:21.792]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.792]                     if (!future$lazy) 
[13:24:21.792]                       future <- run(future)
[13:24:21.792]                     invisible(future)
[13:24:21.792]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.792]                 }
[13:24:21.792]             }
[13:24:21.792]         }
[13:24:21.792]     })
[13:24:21.792]     if (TRUE) {
[13:24:21.792]         base::sink(type = "output", split = FALSE)
[13:24:21.792]         if (TRUE) {
[13:24:21.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.792]         }
[13:24:21.792]         else {
[13:24:21.792]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.792]         }
[13:24:21.792]         base::close(...future.stdout)
[13:24:21.792]         ...future.stdout <- NULL
[13:24:21.792]     }
[13:24:21.792]     ...future.result$conditions <- ...future.conditions
[13:24:21.792]     ...future.result$finished <- base::Sys.time()
[13:24:21.792]     ...future.result
[13:24:21.792] }
[13:24:21.794] plan(): Setting new future strategy stack:
[13:24:21.794] List of future strategies:
[13:24:21.794] 1. sequential:
[13:24:21.794]    - args: function (..., envir = parent.frame())
[13:24:21.794]    - tweaked: FALSE
[13:24:21.794]    - call: NULL
[13:24:21.794] plan(): nbrOfWorkers() = 1
[13:24:21.795] plan(): Setting new future strategy stack:
[13:24:21.795] List of future strategies:
[13:24:21.795] 1. sequential:
[13:24:21.795]    - args: function (..., envir = parent.frame())
[13:24:21.795]    - tweaked: FALSE
[13:24:21.795]    - call: plan(strategy)
[13:24:21.796] plan(): nbrOfWorkers() = 1
[13:24:21.796] SequentialFuture started (and completed)
[13:24:21.796] - Launch lazy future ... done
[13:24:21.796] run() for ‘SequentialFuture’ ... done
[13:24:21.796] getGlobalsAndPackages() ...
[13:24:21.796] Searching for globals...
[13:24:21.797] 
[13:24:21.797] Searching for globals ... DONE
[13:24:21.797] - globals: [0] <none>
[13:24:21.797] getGlobalsAndPackages() ... DONE
[13:24:21.797] run() for ‘Future’ ...
[13:24:21.797] - state: ‘created’
[13:24:21.797] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.798] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.798] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.798]   - Field: ‘label’
[13:24:21.798]   - Field: ‘local’
[13:24:21.798]   - Field: ‘owner’
[13:24:21.798]   - Field: ‘envir’
[13:24:21.798]   - Field: ‘packages’
[13:24:21.798]   - Field: ‘gc’
[13:24:21.799]   - Field: ‘conditions’
[13:24:21.799]   - Field: ‘expr’
[13:24:21.799]   - Field: ‘uuid’
[13:24:21.799]   - Field: ‘seed’
[13:24:21.799]   - Field: ‘version’
[13:24:21.799]   - Field: ‘result’
[13:24:21.799]   - Field: ‘asynchronous’
[13:24:21.799]   - Field: ‘calls’
[13:24:21.799]   - Field: ‘globals’
[13:24:21.799]   - Field: ‘stdout’
[13:24:21.799]   - Field: ‘earlySignal’
[13:24:21.800]   - Field: ‘lazy’
[13:24:21.800]   - Field: ‘state’
[13:24:21.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.800] - Launch lazy future ...
[13:24:21.800] Packages needed by the future expression (n = 0): <none>
[13:24:21.800] Packages needed by future strategies (n = 0): <none>
[13:24:21.801] {
[13:24:21.801]     {
[13:24:21.801]         {
[13:24:21.801]             ...future.startTime <- base::Sys.time()
[13:24:21.801]             {
[13:24:21.801]                 {
[13:24:21.801]                   {
[13:24:21.801]                     base::local({
[13:24:21.801]                       has_future <- base::requireNamespace("future", 
[13:24:21.801]                         quietly = TRUE)
[13:24:21.801]                       if (has_future) {
[13:24:21.801]                         ns <- base::getNamespace("future")
[13:24:21.801]                         version <- ns[[".package"]][["version"]]
[13:24:21.801]                         if (is.null(version)) 
[13:24:21.801]                           version <- utils::packageVersion("future")
[13:24:21.801]                       }
[13:24:21.801]                       else {
[13:24:21.801]                         version <- NULL
[13:24:21.801]                       }
[13:24:21.801]                       if (!has_future || version < "1.8.0") {
[13:24:21.801]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.801]                           "", base::R.version$version.string), 
[13:24:21.801]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.801]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.801]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.801]                             "release", "version")], collapse = " "), 
[13:24:21.801]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.801]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.801]                           info)
[13:24:21.801]                         info <- base::paste(info, collapse = "; ")
[13:24:21.801]                         if (!has_future) {
[13:24:21.801]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.801]                             info)
[13:24:21.801]                         }
[13:24:21.801]                         else {
[13:24:21.801]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.801]                             info, version)
[13:24:21.801]                         }
[13:24:21.801]                         base::stop(msg)
[13:24:21.801]                       }
[13:24:21.801]                     })
[13:24:21.801]                   }
[13:24:21.801]                   options(future.plan = NULL)
[13:24:21.801]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.801]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.801]                 }
[13:24:21.801]                 ...future.workdir <- getwd()
[13:24:21.801]             }
[13:24:21.801]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.801]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.801]         }
[13:24:21.801]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.801]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.801]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.801]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.801]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.801]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.801]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.801]             base::names(...future.oldOptions))
[13:24:21.801]     }
[13:24:21.801]     if (FALSE) {
[13:24:21.801]     }
[13:24:21.801]     else {
[13:24:21.801]         if (TRUE) {
[13:24:21.801]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.801]                 open = "w")
[13:24:21.801]         }
[13:24:21.801]         else {
[13:24:21.801]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.801]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.801]         }
[13:24:21.801]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.801]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.801]             base::sink(type = "output", split = FALSE)
[13:24:21.801]             base::close(...future.stdout)
[13:24:21.801]         }, add = TRUE)
[13:24:21.801]     }
[13:24:21.801]     ...future.frame <- base::sys.nframe()
[13:24:21.801]     ...future.conditions <- base::list()
[13:24:21.801]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.801]     if (FALSE) {
[13:24:21.801]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.801]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.801]     }
[13:24:21.801]     ...future.result <- base::tryCatch({
[13:24:21.801]         base::withCallingHandlers({
[13:24:21.801]             ...future.value <- base::withVisible(base::local(2))
[13:24:21.801]             future::FutureResult(value = ...future.value$value, 
[13:24:21.801]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.801]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.801]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.801]                     ...future.globalenv.names))
[13:24:21.801]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.801]         }, condition = base::local({
[13:24:21.801]             c <- base::c
[13:24:21.801]             inherits <- base::inherits
[13:24:21.801]             invokeRestart <- base::invokeRestart
[13:24:21.801]             length <- base::length
[13:24:21.801]             list <- base::list
[13:24:21.801]             seq.int <- base::seq.int
[13:24:21.801]             signalCondition <- base::signalCondition
[13:24:21.801]             sys.calls <- base::sys.calls
[13:24:21.801]             `[[` <- base::`[[`
[13:24:21.801]             `+` <- base::`+`
[13:24:21.801]             `<<-` <- base::`<<-`
[13:24:21.801]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.801]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.801]                   3L)]
[13:24:21.801]             }
[13:24:21.801]             function(cond) {
[13:24:21.801]                 is_error <- inherits(cond, "error")
[13:24:21.801]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.801]                   NULL)
[13:24:21.801]                 if (is_error) {
[13:24:21.801]                   sessionInformation <- function() {
[13:24:21.801]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.801]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.801]                       search = base::search(), system = base::Sys.info())
[13:24:21.801]                   }
[13:24:21.801]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.801]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.801]                     cond$call), session = sessionInformation(), 
[13:24:21.801]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.801]                   signalCondition(cond)
[13:24:21.801]                 }
[13:24:21.801]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.801]                 "immediateCondition"))) {
[13:24:21.801]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.801]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.801]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.801]                   if (TRUE && !signal) {
[13:24:21.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.801]                     {
[13:24:21.801]                       inherits <- base::inherits
[13:24:21.801]                       invokeRestart <- base::invokeRestart
[13:24:21.801]                       is.null <- base::is.null
[13:24:21.801]                       muffled <- FALSE
[13:24:21.801]                       if (inherits(cond, "message")) {
[13:24:21.801]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.801]                         if (muffled) 
[13:24:21.801]                           invokeRestart("muffleMessage")
[13:24:21.801]                       }
[13:24:21.801]                       else if (inherits(cond, "warning")) {
[13:24:21.801]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.801]                         if (muffled) 
[13:24:21.801]                           invokeRestart("muffleWarning")
[13:24:21.801]                       }
[13:24:21.801]                       else if (inherits(cond, "condition")) {
[13:24:21.801]                         if (!is.null(pattern)) {
[13:24:21.801]                           computeRestarts <- base::computeRestarts
[13:24:21.801]                           grepl <- base::grepl
[13:24:21.801]                           restarts <- computeRestarts(cond)
[13:24:21.801]                           for (restart in restarts) {
[13:24:21.801]                             name <- restart$name
[13:24:21.801]                             if (is.null(name)) 
[13:24:21.801]                               next
[13:24:21.801]                             if (!grepl(pattern, name)) 
[13:24:21.801]                               next
[13:24:21.801]                             invokeRestart(restart)
[13:24:21.801]                             muffled <- TRUE
[13:24:21.801]                             break
[13:24:21.801]                           }
[13:24:21.801]                         }
[13:24:21.801]                       }
[13:24:21.801]                       invisible(muffled)
[13:24:21.801]                     }
[13:24:21.801]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.801]                   }
[13:24:21.801]                 }
[13:24:21.801]                 else {
[13:24:21.801]                   if (TRUE) {
[13:24:21.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.801]                     {
[13:24:21.801]                       inherits <- base::inherits
[13:24:21.801]                       invokeRestart <- base::invokeRestart
[13:24:21.801]                       is.null <- base::is.null
[13:24:21.801]                       muffled <- FALSE
[13:24:21.801]                       if (inherits(cond, "message")) {
[13:24:21.801]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.801]                         if (muffled) 
[13:24:21.801]                           invokeRestart("muffleMessage")
[13:24:21.801]                       }
[13:24:21.801]                       else if (inherits(cond, "warning")) {
[13:24:21.801]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.801]                         if (muffled) 
[13:24:21.801]                           invokeRestart("muffleWarning")
[13:24:21.801]                       }
[13:24:21.801]                       else if (inherits(cond, "condition")) {
[13:24:21.801]                         if (!is.null(pattern)) {
[13:24:21.801]                           computeRestarts <- base::computeRestarts
[13:24:21.801]                           grepl <- base::grepl
[13:24:21.801]                           restarts <- computeRestarts(cond)
[13:24:21.801]                           for (restart in restarts) {
[13:24:21.801]                             name <- restart$name
[13:24:21.801]                             if (is.null(name)) 
[13:24:21.801]                               next
[13:24:21.801]                             if (!grepl(pattern, name)) 
[13:24:21.801]                               next
[13:24:21.801]                             invokeRestart(restart)
[13:24:21.801]                             muffled <- TRUE
[13:24:21.801]                             break
[13:24:21.801]                           }
[13:24:21.801]                         }
[13:24:21.801]                       }
[13:24:21.801]                       invisible(muffled)
[13:24:21.801]                     }
[13:24:21.801]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.801]                   }
[13:24:21.801]                 }
[13:24:21.801]             }
[13:24:21.801]         }))
[13:24:21.801]     }, error = function(ex) {
[13:24:21.801]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.801]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.801]                 ...future.rng), started = ...future.startTime, 
[13:24:21.801]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.801]             version = "1.8"), class = "FutureResult")
[13:24:21.801]     }, finally = {
[13:24:21.801]         if (!identical(...future.workdir, getwd())) 
[13:24:21.801]             setwd(...future.workdir)
[13:24:21.801]         {
[13:24:21.801]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.801]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.801]             }
[13:24:21.801]             base::options(...future.oldOptions)
[13:24:21.801]             if (.Platform$OS.type == "windows") {
[13:24:21.801]                 old_names <- names(...future.oldEnvVars)
[13:24:21.801]                 envs <- base::Sys.getenv()
[13:24:21.801]                 names <- names(envs)
[13:24:21.801]                 common <- intersect(names, old_names)
[13:24:21.801]                 added <- setdiff(names, old_names)
[13:24:21.801]                 removed <- setdiff(old_names, names)
[13:24:21.801]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.801]                   envs[common]]
[13:24:21.801]                 NAMES <- toupper(changed)
[13:24:21.801]                 args <- list()
[13:24:21.801]                 for (kk in seq_along(NAMES)) {
[13:24:21.801]                   name <- changed[[kk]]
[13:24:21.801]                   NAME <- NAMES[[kk]]
[13:24:21.801]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.801]                     next
[13:24:21.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.801]                 }
[13:24:21.801]                 NAMES <- toupper(added)
[13:24:21.801]                 for (kk in seq_along(NAMES)) {
[13:24:21.801]                   name <- added[[kk]]
[13:24:21.801]                   NAME <- NAMES[[kk]]
[13:24:21.801]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.801]                     next
[13:24:21.801]                   args[[name]] <- ""
[13:24:21.801]                 }
[13:24:21.801]                 NAMES <- toupper(removed)
[13:24:21.801]                 for (kk in seq_along(NAMES)) {
[13:24:21.801]                   name <- removed[[kk]]
[13:24:21.801]                   NAME <- NAMES[[kk]]
[13:24:21.801]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.801]                     next
[13:24:21.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.801]                 }
[13:24:21.801]                 if (length(args) > 0) 
[13:24:21.801]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.801]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.801]             }
[13:24:21.801]             else {
[13:24:21.801]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.801]             }
[13:24:21.801]             {
[13:24:21.801]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.801]                   0L) {
[13:24:21.801]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.801]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.801]                   base::options(opts)
[13:24:21.801]                 }
[13:24:21.801]                 {
[13:24:21.801]                   {
[13:24:21.801]                     NULL
[13:24:21.801]                     RNGkind("Mersenne-Twister")
[13:24:21.801]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.801]                       inherits = FALSE)
[13:24:21.801]                   }
[13:24:21.801]                   options(future.plan = NULL)
[13:24:21.801]                   if (is.na(NA_character_)) 
[13:24:21.801]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.801]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.801]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.801]                   {
[13:24:21.801]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.801]                     if (!future$lazy) 
[13:24:21.801]                       future <- run(future)
[13:24:21.801]                     invisible(future)
[13:24:21.801]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.801]                 }
[13:24:21.801]             }
[13:24:21.801]         }
[13:24:21.801]     })
[13:24:21.801]     if (TRUE) {
[13:24:21.801]         base::sink(type = "output", split = FALSE)
[13:24:21.801]         if (TRUE) {
[13:24:21.801]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.801]         }
[13:24:21.801]         else {
[13:24:21.801]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.801]         }
[13:24:21.801]         base::close(...future.stdout)
[13:24:21.801]         ...future.stdout <- NULL
[13:24:21.801]     }
[13:24:21.801]     ...future.result$conditions <- ...future.conditions
[13:24:21.801]     ...future.result$finished <- base::Sys.time()
[13:24:21.801]     ...future.result
[13:24:21.801] }
[13:24:21.802] plan(): Setting new future strategy stack:
[13:24:21.803] List of future strategies:
[13:24:21.803] 1. sequential:
[13:24:21.803]    - args: function (..., envir = parent.frame())
[13:24:21.803]    - tweaked: FALSE
[13:24:21.803]    - call: NULL
[13:24:21.803] plan(): nbrOfWorkers() = 1
[13:24:21.804] plan(): Setting new future strategy stack:
[13:24:21.804] List of future strategies:
[13:24:21.804] 1. sequential:
[13:24:21.804]    - args: function (..., envir = parent.frame())
[13:24:21.804]    - tweaked: FALSE
[13:24:21.804]    - call: plan(strategy)
[13:24:21.804] plan(): nbrOfWorkers() = 1
[13:24:21.804] SequentialFuture started (and completed)
[13:24:21.804] - Launch lazy future ... done
[13:24:21.804] run() for ‘SequentialFuture’ ... done
[13:24:21.805] resolve() on list environment ...
[13:24:21.805]  recursive: 0
[13:24:21.806]  length: 3
[13:24:21.806]  elements: ‘a’, ‘b’, ‘c’
[13:24:21.806] resolved() for ‘SequentialFuture’ ...
[13:24:21.806] - state: ‘finished’
[13:24:21.806] - run: TRUE
[13:24:21.806] - result: ‘FutureResult’
[13:24:21.807] resolved() for ‘SequentialFuture’ ... done
[13:24:21.807] Future #1
[13:24:21.807]  length: 2 (resolved future 1)
[13:24:21.807] resolved() for ‘SequentialFuture’ ...
[13:24:21.807] - state: ‘finished’
[13:24:21.807] - run: TRUE
[13:24:21.807] - result: ‘FutureResult’
[13:24:21.807] resolved() for ‘SequentialFuture’ ... done
[13:24:21.807] Future #2
[13:24:21.807]  length: 1 (resolved future 2)
[13:24:21.808]  length: 0 (resolved future 3)
[13:24:21.808] resolve() on list environment ... DONE
[13:24:21.809] getGlobalsAndPackages() ...
[13:24:21.809] Searching for globals...
[13:24:21.809] - globals found: [1] ‘{’
[13:24:21.809] Searching for globals ... DONE
[13:24:21.809] Resolving globals: FALSE
[13:24:21.810] 
[13:24:21.810] 
[13:24:21.810] getGlobalsAndPackages() ... DONE
[13:24:21.810] run() for ‘Future’ ...
[13:24:21.810] - state: ‘created’
[13:24:21.813] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.813] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.813]   - Field: ‘label’
[13:24:21.813]   - Field: ‘local’
[13:24:21.813]   - Field: ‘owner’
[13:24:21.813]   - Field: ‘envir’
[13:24:21.814]   - Field: ‘packages’
[13:24:21.814]   - Field: ‘gc’
[13:24:21.814]   - Field: ‘conditions’
[13:24:21.814]   - Field: ‘expr’
[13:24:21.814]   - Field: ‘uuid’
[13:24:21.814]   - Field: ‘seed’
[13:24:21.814]   - Field: ‘version’
[13:24:21.814]   - Field: ‘result’
[13:24:21.814]   - Field: ‘asynchronous’
[13:24:21.814]   - Field: ‘calls’
[13:24:21.814]   - Field: ‘globals’
[13:24:21.815]   - Field: ‘stdout’
[13:24:21.815]   - Field: ‘earlySignal’
[13:24:21.815]   - Field: ‘lazy’
[13:24:21.815]   - Field: ‘state’
[13:24:21.815] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.815] - Launch lazy future ...
[13:24:21.815] Packages needed by the future expression (n = 0): <none>
[13:24:21.815] Packages needed by future strategies (n = 0): <none>
[13:24:21.816] {
[13:24:21.816]     {
[13:24:21.816]         {
[13:24:21.816]             ...future.startTime <- base::Sys.time()
[13:24:21.816]             {
[13:24:21.816]                 {
[13:24:21.816]                   {
[13:24:21.816]                     base::local({
[13:24:21.816]                       has_future <- base::requireNamespace("future", 
[13:24:21.816]                         quietly = TRUE)
[13:24:21.816]                       if (has_future) {
[13:24:21.816]                         ns <- base::getNamespace("future")
[13:24:21.816]                         version <- ns[[".package"]][["version"]]
[13:24:21.816]                         if (is.null(version)) 
[13:24:21.816]                           version <- utils::packageVersion("future")
[13:24:21.816]                       }
[13:24:21.816]                       else {
[13:24:21.816]                         version <- NULL
[13:24:21.816]                       }
[13:24:21.816]                       if (!has_future || version < "1.8.0") {
[13:24:21.816]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.816]                           "", base::R.version$version.string), 
[13:24:21.816]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.816]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.816]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.816]                             "release", "version")], collapse = " "), 
[13:24:21.816]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.816]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.816]                           info)
[13:24:21.816]                         info <- base::paste(info, collapse = "; ")
[13:24:21.816]                         if (!has_future) {
[13:24:21.816]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.816]                             info)
[13:24:21.816]                         }
[13:24:21.816]                         else {
[13:24:21.816]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.816]                             info, version)
[13:24:21.816]                         }
[13:24:21.816]                         base::stop(msg)
[13:24:21.816]                       }
[13:24:21.816]                     })
[13:24:21.816]                   }
[13:24:21.816]                   options(future.plan = NULL)
[13:24:21.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.816]                 }
[13:24:21.816]                 ...future.workdir <- getwd()
[13:24:21.816]             }
[13:24:21.816]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.816]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.816]         }
[13:24:21.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.816]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.816]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.816]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.816]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.816]             base::names(...future.oldOptions))
[13:24:21.816]     }
[13:24:21.816]     if (FALSE) {
[13:24:21.816]     }
[13:24:21.816]     else {
[13:24:21.816]         if (TRUE) {
[13:24:21.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.816]                 open = "w")
[13:24:21.816]         }
[13:24:21.816]         else {
[13:24:21.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.816]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.816]         }
[13:24:21.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.816]             base::sink(type = "output", split = FALSE)
[13:24:21.816]             base::close(...future.stdout)
[13:24:21.816]         }, add = TRUE)
[13:24:21.816]     }
[13:24:21.816]     ...future.frame <- base::sys.nframe()
[13:24:21.816]     ...future.conditions <- base::list()
[13:24:21.816]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.816]     if (FALSE) {
[13:24:21.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.816]     }
[13:24:21.816]     ...future.result <- base::tryCatch({
[13:24:21.816]         base::withCallingHandlers({
[13:24:21.816]             ...future.value <- base::withVisible(base::local({
[13:24:21.816]                 1
[13:24:21.816]             }))
[13:24:21.816]             future::FutureResult(value = ...future.value$value, 
[13:24:21.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.816]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.816]                     ...future.globalenv.names))
[13:24:21.816]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.816]         }, condition = base::local({
[13:24:21.816]             c <- base::c
[13:24:21.816]             inherits <- base::inherits
[13:24:21.816]             invokeRestart <- base::invokeRestart
[13:24:21.816]             length <- base::length
[13:24:21.816]             list <- base::list
[13:24:21.816]             seq.int <- base::seq.int
[13:24:21.816]             signalCondition <- base::signalCondition
[13:24:21.816]             sys.calls <- base::sys.calls
[13:24:21.816]             `[[` <- base::`[[`
[13:24:21.816]             `+` <- base::`+`
[13:24:21.816]             `<<-` <- base::`<<-`
[13:24:21.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.816]                   3L)]
[13:24:21.816]             }
[13:24:21.816]             function(cond) {
[13:24:21.816]                 is_error <- inherits(cond, "error")
[13:24:21.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.816]                   NULL)
[13:24:21.816]                 if (is_error) {
[13:24:21.816]                   sessionInformation <- function() {
[13:24:21.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.816]                       search = base::search(), system = base::Sys.info())
[13:24:21.816]                   }
[13:24:21.816]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.816]                     cond$call), session = sessionInformation(), 
[13:24:21.816]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.816]                   signalCondition(cond)
[13:24:21.816]                 }
[13:24:21.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.816]                 "immediateCondition"))) {
[13:24:21.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.816]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.816]                   if (TRUE && !signal) {
[13:24:21.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.816]                     {
[13:24:21.816]                       inherits <- base::inherits
[13:24:21.816]                       invokeRestart <- base::invokeRestart
[13:24:21.816]                       is.null <- base::is.null
[13:24:21.816]                       muffled <- FALSE
[13:24:21.816]                       if (inherits(cond, "message")) {
[13:24:21.816]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.816]                         if (muffled) 
[13:24:21.816]                           invokeRestart("muffleMessage")
[13:24:21.816]                       }
[13:24:21.816]                       else if (inherits(cond, "warning")) {
[13:24:21.816]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.816]                         if (muffled) 
[13:24:21.816]                           invokeRestart("muffleWarning")
[13:24:21.816]                       }
[13:24:21.816]                       else if (inherits(cond, "condition")) {
[13:24:21.816]                         if (!is.null(pattern)) {
[13:24:21.816]                           computeRestarts <- base::computeRestarts
[13:24:21.816]                           grepl <- base::grepl
[13:24:21.816]                           restarts <- computeRestarts(cond)
[13:24:21.816]                           for (restart in restarts) {
[13:24:21.816]                             name <- restart$name
[13:24:21.816]                             if (is.null(name)) 
[13:24:21.816]                               next
[13:24:21.816]                             if (!grepl(pattern, name)) 
[13:24:21.816]                               next
[13:24:21.816]                             invokeRestart(restart)
[13:24:21.816]                             muffled <- TRUE
[13:24:21.816]                             break
[13:24:21.816]                           }
[13:24:21.816]                         }
[13:24:21.816]                       }
[13:24:21.816]                       invisible(muffled)
[13:24:21.816]                     }
[13:24:21.816]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.816]                   }
[13:24:21.816]                 }
[13:24:21.816]                 else {
[13:24:21.816]                   if (TRUE) {
[13:24:21.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.816]                     {
[13:24:21.816]                       inherits <- base::inherits
[13:24:21.816]                       invokeRestart <- base::invokeRestart
[13:24:21.816]                       is.null <- base::is.null
[13:24:21.816]                       muffled <- FALSE
[13:24:21.816]                       if (inherits(cond, "message")) {
[13:24:21.816]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.816]                         if (muffled) 
[13:24:21.816]                           invokeRestart("muffleMessage")
[13:24:21.816]                       }
[13:24:21.816]                       else if (inherits(cond, "warning")) {
[13:24:21.816]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.816]                         if (muffled) 
[13:24:21.816]                           invokeRestart("muffleWarning")
[13:24:21.816]                       }
[13:24:21.816]                       else if (inherits(cond, "condition")) {
[13:24:21.816]                         if (!is.null(pattern)) {
[13:24:21.816]                           computeRestarts <- base::computeRestarts
[13:24:21.816]                           grepl <- base::grepl
[13:24:21.816]                           restarts <- computeRestarts(cond)
[13:24:21.816]                           for (restart in restarts) {
[13:24:21.816]                             name <- restart$name
[13:24:21.816]                             if (is.null(name)) 
[13:24:21.816]                               next
[13:24:21.816]                             if (!grepl(pattern, name)) 
[13:24:21.816]                               next
[13:24:21.816]                             invokeRestart(restart)
[13:24:21.816]                             muffled <- TRUE
[13:24:21.816]                             break
[13:24:21.816]                           }
[13:24:21.816]                         }
[13:24:21.816]                       }
[13:24:21.816]                       invisible(muffled)
[13:24:21.816]                     }
[13:24:21.816]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.816]                   }
[13:24:21.816]                 }
[13:24:21.816]             }
[13:24:21.816]         }))
[13:24:21.816]     }, error = function(ex) {
[13:24:21.816]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.816]                 ...future.rng), started = ...future.startTime, 
[13:24:21.816]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.816]             version = "1.8"), class = "FutureResult")
[13:24:21.816]     }, finally = {
[13:24:21.816]         if (!identical(...future.workdir, getwd())) 
[13:24:21.816]             setwd(...future.workdir)
[13:24:21.816]         {
[13:24:21.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.816]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.816]             }
[13:24:21.816]             base::options(...future.oldOptions)
[13:24:21.816]             if (.Platform$OS.type == "windows") {
[13:24:21.816]                 old_names <- names(...future.oldEnvVars)
[13:24:21.816]                 envs <- base::Sys.getenv()
[13:24:21.816]                 names <- names(envs)
[13:24:21.816]                 common <- intersect(names, old_names)
[13:24:21.816]                 added <- setdiff(names, old_names)
[13:24:21.816]                 removed <- setdiff(old_names, names)
[13:24:21.816]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.816]                   envs[common]]
[13:24:21.816]                 NAMES <- toupper(changed)
[13:24:21.816]                 args <- list()
[13:24:21.816]                 for (kk in seq_along(NAMES)) {
[13:24:21.816]                   name <- changed[[kk]]
[13:24:21.816]                   NAME <- NAMES[[kk]]
[13:24:21.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.816]                     next
[13:24:21.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.816]                 }
[13:24:21.816]                 NAMES <- toupper(added)
[13:24:21.816]                 for (kk in seq_along(NAMES)) {
[13:24:21.816]                   name <- added[[kk]]
[13:24:21.816]                   NAME <- NAMES[[kk]]
[13:24:21.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.816]                     next
[13:24:21.816]                   args[[name]] <- ""
[13:24:21.816]                 }
[13:24:21.816]                 NAMES <- toupper(removed)
[13:24:21.816]                 for (kk in seq_along(NAMES)) {
[13:24:21.816]                   name <- removed[[kk]]
[13:24:21.816]                   NAME <- NAMES[[kk]]
[13:24:21.816]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.816]                     next
[13:24:21.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.816]                 }
[13:24:21.816]                 if (length(args) > 0) 
[13:24:21.816]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.816]             }
[13:24:21.816]             else {
[13:24:21.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.816]             }
[13:24:21.816]             {
[13:24:21.816]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.816]                   0L) {
[13:24:21.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.816]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.816]                   base::options(opts)
[13:24:21.816]                 }
[13:24:21.816]                 {
[13:24:21.816]                   {
[13:24:21.816]                     NULL
[13:24:21.816]                     RNGkind("Mersenne-Twister")
[13:24:21.816]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.816]                       inherits = FALSE)
[13:24:21.816]                   }
[13:24:21.816]                   options(future.plan = NULL)
[13:24:21.816]                   if (is.na(NA_character_)) 
[13:24:21.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.816]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.816]                   {
[13:24:21.816]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.816]                     if (!future$lazy) 
[13:24:21.816]                       future <- run(future)
[13:24:21.816]                     invisible(future)
[13:24:21.816]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.816]                 }
[13:24:21.816]             }
[13:24:21.816]         }
[13:24:21.816]     })
[13:24:21.816]     if (TRUE) {
[13:24:21.816]         base::sink(type = "output", split = FALSE)
[13:24:21.816]         if (TRUE) {
[13:24:21.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.816]         }
[13:24:21.816]         else {
[13:24:21.816]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.816]         }
[13:24:21.816]         base::close(...future.stdout)
[13:24:21.816]         ...future.stdout <- NULL
[13:24:21.816]     }
[13:24:21.816]     ...future.result$conditions <- ...future.conditions
[13:24:21.816]     ...future.result$finished <- base::Sys.time()
[13:24:21.816]     ...future.result
[13:24:21.816] }
[13:24:21.818] plan(): Setting new future strategy stack:
[13:24:21.818] List of future strategies:
[13:24:21.818] 1. sequential:
[13:24:21.818]    - args: function (..., envir = parent.frame())
[13:24:21.818]    - tweaked: FALSE
[13:24:21.818]    - call: NULL
[13:24:21.818] plan(): nbrOfWorkers() = 1
[13:24:21.819] plan(): Setting new future strategy stack:
[13:24:21.819] List of future strategies:
[13:24:21.819] 1. sequential:
[13:24:21.819]    - args: function (..., envir = parent.frame())
[13:24:21.819]    - tweaked: FALSE
[13:24:21.819]    - call: plan(strategy)
[13:24:21.819] plan(): nbrOfWorkers() = 1
[13:24:21.819] SequentialFuture started (and completed)
[13:24:21.820] - Launch lazy future ... done
[13:24:21.820] run() for ‘SequentialFuture’ ... done
[13:24:21.820] getGlobalsAndPackages() ...
[13:24:21.820] Searching for globals...
[13:24:21.821] - globals found: [1] ‘{’
[13:24:21.821] Searching for globals ... DONE
[13:24:21.821] Resolving globals: FALSE
[13:24:21.821] 
[13:24:21.821] 
[13:24:21.821] getGlobalsAndPackages() ... DONE
[13:24:21.822] run() for ‘Future’ ...
[13:24:21.822] - state: ‘created’
[13:24:21.822] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.822] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.822] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.822]   - Field: ‘label’
[13:24:21.823]   - Field: ‘local’
[13:24:21.823]   - Field: ‘owner’
[13:24:21.823]   - Field: ‘envir’
[13:24:21.823]   - Field: ‘packages’
[13:24:21.823]   - Field: ‘gc’
[13:24:21.823]   - Field: ‘conditions’
[13:24:21.823]   - Field: ‘expr’
[13:24:21.823]   - Field: ‘uuid’
[13:24:21.823]   - Field: ‘seed’
[13:24:21.823]   - Field: ‘version’
[13:24:21.823]   - Field: ‘result’
[13:24:21.824]   - Field: ‘asynchronous’
[13:24:21.824]   - Field: ‘calls’
[13:24:21.824]   - Field: ‘globals’
[13:24:21.824]   - Field: ‘stdout’
[13:24:21.824]   - Field: ‘earlySignal’
[13:24:21.824]   - Field: ‘lazy’
[13:24:21.824]   - Field: ‘state’
[13:24:21.824] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.824] - Launch lazy future ...
[13:24:21.825] Packages needed by the future expression (n = 0): <none>
[13:24:21.825] Packages needed by future strategies (n = 0): <none>
[13:24:21.825] {
[13:24:21.825]     {
[13:24:21.825]         {
[13:24:21.825]             ...future.startTime <- base::Sys.time()
[13:24:21.825]             {
[13:24:21.825]                 {
[13:24:21.825]                   {
[13:24:21.825]                     base::local({
[13:24:21.825]                       has_future <- base::requireNamespace("future", 
[13:24:21.825]                         quietly = TRUE)
[13:24:21.825]                       if (has_future) {
[13:24:21.825]                         ns <- base::getNamespace("future")
[13:24:21.825]                         version <- ns[[".package"]][["version"]]
[13:24:21.825]                         if (is.null(version)) 
[13:24:21.825]                           version <- utils::packageVersion("future")
[13:24:21.825]                       }
[13:24:21.825]                       else {
[13:24:21.825]                         version <- NULL
[13:24:21.825]                       }
[13:24:21.825]                       if (!has_future || version < "1.8.0") {
[13:24:21.825]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.825]                           "", base::R.version$version.string), 
[13:24:21.825]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.825]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.825]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.825]                             "release", "version")], collapse = " "), 
[13:24:21.825]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.825]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.825]                           info)
[13:24:21.825]                         info <- base::paste(info, collapse = "; ")
[13:24:21.825]                         if (!has_future) {
[13:24:21.825]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.825]                             info)
[13:24:21.825]                         }
[13:24:21.825]                         else {
[13:24:21.825]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.825]                             info, version)
[13:24:21.825]                         }
[13:24:21.825]                         base::stop(msg)
[13:24:21.825]                       }
[13:24:21.825]                     })
[13:24:21.825]                   }
[13:24:21.825]                   options(future.plan = NULL)
[13:24:21.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.825]                 }
[13:24:21.825]                 ...future.workdir <- getwd()
[13:24:21.825]             }
[13:24:21.825]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.825]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.825]         }
[13:24:21.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.825]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.825]             base::names(...future.oldOptions))
[13:24:21.825]     }
[13:24:21.825]     if (FALSE) {
[13:24:21.825]     }
[13:24:21.825]     else {
[13:24:21.825]         if (TRUE) {
[13:24:21.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.825]                 open = "w")
[13:24:21.825]         }
[13:24:21.825]         else {
[13:24:21.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.825]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.825]         }
[13:24:21.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.825]             base::sink(type = "output", split = FALSE)
[13:24:21.825]             base::close(...future.stdout)
[13:24:21.825]         }, add = TRUE)
[13:24:21.825]     }
[13:24:21.825]     ...future.frame <- base::sys.nframe()
[13:24:21.825]     ...future.conditions <- base::list()
[13:24:21.825]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.825]     if (FALSE) {
[13:24:21.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.825]     }
[13:24:21.825]     ...future.result <- base::tryCatch({
[13:24:21.825]         base::withCallingHandlers({
[13:24:21.825]             ...future.value <- base::withVisible(base::local({
[13:24:21.825]                 2
[13:24:21.825]             }))
[13:24:21.825]             future::FutureResult(value = ...future.value$value, 
[13:24:21.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.825]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.825]                     ...future.globalenv.names))
[13:24:21.825]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.825]         }, condition = base::local({
[13:24:21.825]             c <- base::c
[13:24:21.825]             inherits <- base::inherits
[13:24:21.825]             invokeRestart <- base::invokeRestart
[13:24:21.825]             length <- base::length
[13:24:21.825]             list <- base::list
[13:24:21.825]             seq.int <- base::seq.int
[13:24:21.825]             signalCondition <- base::signalCondition
[13:24:21.825]             sys.calls <- base::sys.calls
[13:24:21.825]             `[[` <- base::`[[`
[13:24:21.825]             `+` <- base::`+`
[13:24:21.825]             `<<-` <- base::`<<-`
[13:24:21.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.825]                   3L)]
[13:24:21.825]             }
[13:24:21.825]             function(cond) {
[13:24:21.825]                 is_error <- inherits(cond, "error")
[13:24:21.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.825]                   NULL)
[13:24:21.825]                 if (is_error) {
[13:24:21.825]                   sessionInformation <- function() {
[13:24:21.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.825]                       search = base::search(), system = base::Sys.info())
[13:24:21.825]                   }
[13:24:21.825]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.825]                     cond$call), session = sessionInformation(), 
[13:24:21.825]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.825]                   signalCondition(cond)
[13:24:21.825]                 }
[13:24:21.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.825]                 "immediateCondition"))) {
[13:24:21.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.825]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.825]                   if (TRUE && !signal) {
[13:24:21.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.825]                     {
[13:24:21.825]                       inherits <- base::inherits
[13:24:21.825]                       invokeRestart <- base::invokeRestart
[13:24:21.825]                       is.null <- base::is.null
[13:24:21.825]                       muffled <- FALSE
[13:24:21.825]                       if (inherits(cond, "message")) {
[13:24:21.825]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.825]                         if (muffled) 
[13:24:21.825]                           invokeRestart("muffleMessage")
[13:24:21.825]                       }
[13:24:21.825]                       else if (inherits(cond, "warning")) {
[13:24:21.825]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.825]                         if (muffled) 
[13:24:21.825]                           invokeRestart("muffleWarning")
[13:24:21.825]                       }
[13:24:21.825]                       else if (inherits(cond, "condition")) {
[13:24:21.825]                         if (!is.null(pattern)) {
[13:24:21.825]                           computeRestarts <- base::computeRestarts
[13:24:21.825]                           grepl <- base::grepl
[13:24:21.825]                           restarts <- computeRestarts(cond)
[13:24:21.825]                           for (restart in restarts) {
[13:24:21.825]                             name <- restart$name
[13:24:21.825]                             if (is.null(name)) 
[13:24:21.825]                               next
[13:24:21.825]                             if (!grepl(pattern, name)) 
[13:24:21.825]                               next
[13:24:21.825]                             invokeRestart(restart)
[13:24:21.825]                             muffled <- TRUE
[13:24:21.825]                             break
[13:24:21.825]                           }
[13:24:21.825]                         }
[13:24:21.825]                       }
[13:24:21.825]                       invisible(muffled)
[13:24:21.825]                     }
[13:24:21.825]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.825]                   }
[13:24:21.825]                 }
[13:24:21.825]                 else {
[13:24:21.825]                   if (TRUE) {
[13:24:21.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.825]                     {
[13:24:21.825]                       inherits <- base::inherits
[13:24:21.825]                       invokeRestart <- base::invokeRestart
[13:24:21.825]                       is.null <- base::is.null
[13:24:21.825]                       muffled <- FALSE
[13:24:21.825]                       if (inherits(cond, "message")) {
[13:24:21.825]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.825]                         if (muffled) 
[13:24:21.825]                           invokeRestart("muffleMessage")
[13:24:21.825]                       }
[13:24:21.825]                       else if (inherits(cond, "warning")) {
[13:24:21.825]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.825]                         if (muffled) 
[13:24:21.825]                           invokeRestart("muffleWarning")
[13:24:21.825]                       }
[13:24:21.825]                       else if (inherits(cond, "condition")) {
[13:24:21.825]                         if (!is.null(pattern)) {
[13:24:21.825]                           computeRestarts <- base::computeRestarts
[13:24:21.825]                           grepl <- base::grepl
[13:24:21.825]                           restarts <- computeRestarts(cond)
[13:24:21.825]                           for (restart in restarts) {
[13:24:21.825]                             name <- restart$name
[13:24:21.825]                             if (is.null(name)) 
[13:24:21.825]                               next
[13:24:21.825]                             if (!grepl(pattern, name)) 
[13:24:21.825]                               next
[13:24:21.825]                             invokeRestart(restart)
[13:24:21.825]                             muffled <- TRUE
[13:24:21.825]                             break
[13:24:21.825]                           }
[13:24:21.825]                         }
[13:24:21.825]                       }
[13:24:21.825]                       invisible(muffled)
[13:24:21.825]                     }
[13:24:21.825]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.825]                   }
[13:24:21.825]                 }
[13:24:21.825]             }
[13:24:21.825]         }))
[13:24:21.825]     }, error = function(ex) {
[13:24:21.825]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.825]                 ...future.rng), started = ...future.startTime, 
[13:24:21.825]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.825]             version = "1.8"), class = "FutureResult")
[13:24:21.825]     }, finally = {
[13:24:21.825]         if (!identical(...future.workdir, getwd())) 
[13:24:21.825]             setwd(...future.workdir)
[13:24:21.825]         {
[13:24:21.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.825]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.825]             }
[13:24:21.825]             base::options(...future.oldOptions)
[13:24:21.825]             if (.Platform$OS.type == "windows") {
[13:24:21.825]                 old_names <- names(...future.oldEnvVars)
[13:24:21.825]                 envs <- base::Sys.getenv()
[13:24:21.825]                 names <- names(envs)
[13:24:21.825]                 common <- intersect(names, old_names)
[13:24:21.825]                 added <- setdiff(names, old_names)
[13:24:21.825]                 removed <- setdiff(old_names, names)
[13:24:21.825]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.825]                   envs[common]]
[13:24:21.825]                 NAMES <- toupper(changed)
[13:24:21.825]                 args <- list()
[13:24:21.825]                 for (kk in seq_along(NAMES)) {
[13:24:21.825]                   name <- changed[[kk]]
[13:24:21.825]                   NAME <- NAMES[[kk]]
[13:24:21.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.825]                     next
[13:24:21.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.825]                 }
[13:24:21.825]                 NAMES <- toupper(added)
[13:24:21.825]                 for (kk in seq_along(NAMES)) {
[13:24:21.825]                   name <- added[[kk]]
[13:24:21.825]                   NAME <- NAMES[[kk]]
[13:24:21.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.825]                     next
[13:24:21.825]                   args[[name]] <- ""
[13:24:21.825]                 }
[13:24:21.825]                 NAMES <- toupper(removed)
[13:24:21.825]                 for (kk in seq_along(NAMES)) {
[13:24:21.825]                   name <- removed[[kk]]
[13:24:21.825]                   NAME <- NAMES[[kk]]
[13:24:21.825]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.825]                     next
[13:24:21.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.825]                 }
[13:24:21.825]                 if (length(args) > 0) 
[13:24:21.825]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.825]             }
[13:24:21.825]             else {
[13:24:21.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.825]             }
[13:24:21.825]             {
[13:24:21.825]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.825]                   0L) {
[13:24:21.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.825]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.825]                   base::options(opts)
[13:24:21.825]                 }
[13:24:21.825]                 {
[13:24:21.825]                   {
[13:24:21.825]                     NULL
[13:24:21.825]                     RNGkind("Mersenne-Twister")
[13:24:21.825]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.825]                       inherits = FALSE)
[13:24:21.825]                   }
[13:24:21.825]                   options(future.plan = NULL)
[13:24:21.825]                   if (is.na(NA_character_)) 
[13:24:21.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.825]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.825]                   {
[13:24:21.825]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.825]                     if (!future$lazy) 
[13:24:21.825]                       future <- run(future)
[13:24:21.825]                     invisible(future)
[13:24:21.825]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.825]                 }
[13:24:21.825]             }
[13:24:21.825]         }
[13:24:21.825]     })
[13:24:21.825]     if (TRUE) {
[13:24:21.825]         base::sink(type = "output", split = FALSE)
[13:24:21.825]         if (TRUE) {
[13:24:21.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.825]         }
[13:24:21.825]         else {
[13:24:21.825]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.825]         }
[13:24:21.825]         base::close(...future.stdout)
[13:24:21.825]         ...future.stdout <- NULL
[13:24:21.825]     }
[13:24:21.825]     ...future.result$conditions <- ...future.conditions
[13:24:21.825]     ...future.result$finished <- base::Sys.time()
[13:24:21.825]     ...future.result
[13:24:21.825] }
[13:24:21.827] plan(): Setting new future strategy stack:
[13:24:21.827] List of future strategies:
[13:24:21.827] 1. sequential:
[13:24:21.827]    - args: function (..., envir = parent.frame())
[13:24:21.827]    - tweaked: FALSE
[13:24:21.827]    - call: NULL
[13:24:21.827] plan(): nbrOfWorkers() = 1
[13:24:21.828] plan(): Setting new future strategy stack:
[13:24:21.828] List of future strategies:
[13:24:21.828] 1. sequential:
[13:24:21.828]    - args: function (..., envir = parent.frame())
[13:24:21.828]    - tweaked: FALSE
[13:24:21.828]    - call: plan(strategy)
[13:24:21.829] plan(): nbrOfWorkers() = 1
[13:24:21.829] SequentialFuture started (and completed)
[13:24:21.829] - Launch lazy future ... done
[13:24:21.829] run() for ‘SequentialFuture’ ... done
[13:24:21.830] resolve() on list environment ...
[13:24:21.830]  recursive: 0
[13:24:21.830]  length: 3
[13:24:21.830]  elements: ‘a’, ‘b’, ‘c’
[13:24:21.830] resolved() for ‘SequentialFuture’ ...
[13:24:21.831] - state: ‘finished’
[13:24:21.831] - run: TRUE
[13:24:21.831] - result: ‘FutureResult’
[13:24:21.831] resolved() for ‘SequentialFuture’ ... done
[13:24:21.831] Future #1
[13:24:21.831]  length: 2 (resolved future 1)
[13:24:21.831] resolved() for ‘SequentialFuture’ ...
[13:24:21.831] - state: ‘finished’
[13:24:21.831] - run: TRUE
[13:24:21.831] - result: ‘FutureResult’
[13:24:21.831] resolved() for ‘SequentialFuture’ ... done
[13:24:21.832] Future #2
[13:24:21.832]  length: 1 (resolved future 2)
[13:24:21.832]  length: 0 (resolved future 3)
[13:24:21.832] resolve() on list environment ... DONE
[13:24:21.832] getGlobalsAndPackages() ...
[13:24:21.832] Searching for globals...
[13:24:21.833] - globals found: [1] ‘{’
[13:24:21.833] Searching for globals ... DONE
[13:24:21.833] Resolving globals: FALSE
[13:24:21.834] 
[13:24:21.834] 
[13:24:21.834] getGlobalsAndPackages() ... DONE
[13:24:21.834] run() for ‘Future’ ...
[13:24:21.834] - state: ‘created’
[13:24:21.834] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.835] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.835] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.835]   - Field: ‘label’
[13:24:21.835]   - Field: ‘local’
[13:24:21.835]   - Field: ‘owner’
[13:24:21.835]   - Field: ‘envir’
[13:24:21.835]   - Field: ‘packages’
[13:24:21.835]   - Field: ‘gc’
[13:24:21.835]   - Field: ‘conditions’
[13:24:21.835]   - Field: ‘expr’
[13:24:21.836]   - Field: ‘uuid’
[13:24:21.836]   - Field: ‘seed’
[13:24:21.836]   - Field: ‘version’
[13:24:21.836]   - Field: ‘result’
[13:24:21.836]   - Field: ‘asynchronous’
[13:24:21.836]   - Field: ‘calls’
[13:24:21.836]   - Field: ‘globals’
[13:24:21.836]   - Field: ‘stdout’
[13:24:21.836]   - Field: ‘earlySignal’
[13:24:21.836]   - Field: ‘lazy’
[13:24:21.836]   - Field: ‘state’
[13:24:21.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.837] - Launch lazy future ...
[13:24:21.837] Packages needed by the future expression (n = 0): <none>
[13:24:21.837] Packages needed by future strategies (n = 0): <none>
[13:24:21.837] {
[13:24:21.837]     {
[13:24:21.837]         {
[13:24:21.837]             ...future.startTime <- base::Sys.time()
[13:24:21.837]             {
[13:24:21.837]                 {
[13:24:21.837]                   {
[13:24:21.837]                     base::local({
[13:24:21.837]                       has_future <- base::requireNamespace("future", 
[13:24:21.837]                         quietly = TRUE)
[13:24:21.837]                       if (has_future) {
[13:24:21.837]                         ns <- base::getNamespace("future")
[13:24:21.837]                         version <- ns[[".package"]][["version"]]
[13:24:21.837]                         if (is.null(version)) 
[13:24:21.837]                           version <- utils::packageVersion("future")
[13:24:21.837]                       }
[13:24:21.837]                       else {
[13:24:21.837]                         version <- NULL
[13:24:21.837]                       }
[13:24:21.837]                       if (!has_future || version < "1.8.0") {
[13:24:21.837]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.837]                           "", base::R.version$version.string), 
[13:24:21.837]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.837]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.837]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.837]                             "release", "version")], collapse = " "), 
[13:24:21.837]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.837]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.837]                           info)
[13:24:21.837]                         info <- base::paste(info, collapse = "; ")
[13:24:21.837]                         if (!has_future) {
[13:24:21.837]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.837]                             info)
[13:24:21.837]                         }
[13:24:21.837]                         else {
[13:24:21.837]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.837]                             info, version)
[13:24:21.837]                         }
[13:24:21.837]                         base::stop(msg)
[13:24:21.837]                       }
[13:24:21.837]                     })
[13:24:21.837]                   }
[13:24:21.837]                   options(future.plan = NULL)
[13:24:21.837]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.837]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.837]                 }
[13:24:21.837]                 ...future.workdir <- getwd()
[13:24:21.837]             }
[13:24:21.837]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.837]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.837]         }
[13:24:21.837]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.837]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.837]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.837]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.837]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.837]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.837]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.837]             base::names(...future.oldOptions))
[13:24:21.837]     }
[13:24:21.837]     if (FALSE) {
[13:24:21.837]     }
[13:24:21.837]     else {
[13:24:21.837]         if (TRUE) {
[13:24:21.837]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.837]                 open = "w")
[13:24:21.837]         }
[13:24:21.837]         else {
[13:24:21.837]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.837]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.837]         }
[13:24:21.837]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.837]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.837]             base::sink(type = "output", split = FALSE)
[13:24:21.837]             base::close(...future.stdout)
[13:24:21.837]         }, add = TRUE)
[13:24:21.837]     }
[13:24:21.837]     ...future.frame <- base::sys.nframe()
[13:24:21.837]     ...future.conditions <- base::list()
[13:24:21.837]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.837]     if (FALSE) {
[13:24:21.837]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.837]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.837]     }
[13:24:21.837]     ...future.result <- base::tryCatch({
[13:24:21.837]         base::withCallingHandlers({
[13:24:21.837]             ...future.value <- base::withVisible(base::local({
[13:24:21.837]                 1
[13:24:21.837]             }))
[13:24:21.837]             future::FutureResult(value = ...future.value$value, 
[13:24:21.837]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.837]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.837]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.837]                     ...future.globalenv.names))
[13:24:21.837]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.837]         }, condition = base::local({
[13:24:21.837]             c <- base::c
[13:24:21.837]             inherits <- base::inherits
[13:24:21.837]             invokeRestart <- base::invokeRestart
[13:24:21.837]             length <- base::length
[13:24:21.837]             list <- base::list
[13:24:21.837]             seq.int <- base::seq.int
[13:24:21.837]             signalCondition <- base::signalCondition
[13:24:21.837]             sys.calls <- base::sys.calls
[13:24:21.837]             `[[` <- base::`[[`
[13:24:21.837]             `+` <- base::`+`
[13:24:21.837]             `<<-` <- base::`<<-`
[13:24:21.837]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.837]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.837]                   3L)]
[13:24:21.837]             }
[13:24:21.837]             function(cond) {
[13:24:21.837]                 is_error <- inherits(cond, "error")
[13:24:21.837]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.837]                   NULL)
[13:24:21.837]                 if (is_error) {
[13:24:21.837]                   sessionInformation <- function() {
[13:24:21.837]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.837]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.837]                       search = base::search(), system = base::Sys.info())
[13:24:21.837]                   }
[13:24:21.837]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.837]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.837]                     cond$call), session = sessionInformation(), 
[13:24:21.837]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.837]                   signalCondition(cond)
[13:24:21.837]                 }
[13:24:21.837]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.837]                 "immediateCondition"))) {
[13:24:21.837]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.837]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.837]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.837]                   if (TRUE && !signal) {
[13:24:21.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.837]                     {
[13:24:21.837]                       inherits <- base::inherits
[13:24:21.837]                       invokeRestart <- base::invokeRestart
[13:24:21.837]                       is.null <- base::is.null
[13:24:21.837]                       muffled <- FALSE
[13:24:21.837]                       if (inherits(cond, "message")) {
[13:24:21.837]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.837]                         if (muffled) 
[13:24:21.837]                           invokeRestart("muffleMessage")
[13:24:21.837]                       }
[13:24:21.837]                       else if (inherits(cond, "warning")) {
[13:24:21.837]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.837]                         if (muffled) 
[13:24:21.837]                           invokeRestart("muffleWarning")
[13:24:21.837]                       }
[13:24:21.837]                       else if (inherits(cond, "condition")) {
[13:24:21.837]                         if (!is.null(pattern)) {
[13:24:21.837]                           computeRestarts <- base::computeRestarts
[13:24:21.837]                           grepl <- base::grepl
[13:24:21.837]                           restarts <- computeRestarts(cond)
[13:24:21.837]                           for (restart in restarts) {
[13:24:21.837]                             name <- restart$name
[13:24:21.837]                             if (is.null(name)) 
[13:24:21.837]                               next
[13:24:21.837]                             if (!grepl(pattern, name)) 
[13:24:21.837]                               next
[13:24:21.837]                             invokeRestart(restart)
[13:24:21.837]                             muffled <- TRUE
[13:24:21.837]                             break
[13:24:21.837]                           }
[13:24:21.837]                         }
[13:24:21.837]                       }
[13:24:21.837]                       invisible(muffled)
[13:24:21.837]                     }
[13:24:21.837]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.837]                   }
[13:24:21.837]                 }
[13:24:21.837]                 else {
[13:24:21.837]                   if (TRUE) {
[13:24:21.837]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.837]                     {
[13:24:21.837]                       inherits <- base::inherits
[13:24:21.837]                       invokeRestart <- base::invokeRestart
[13:24:21.837]                       is.null <- base::is.null
[13:24:21.837]                       muffled <- FALSE
[13:24:21.837]                       if (inherits(cond, "message")) {
[13:24:21.837]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.837]                         if (muffled) 
[13:24:21.837]                           invokeRestart("muffleMessage")
[13:24:21.837]                       }
[13:24:21.837]                       else if (inherits(cond, "warning")) {
[13:24:21.837]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.837]                         if (muffled) 
[13:24:21.837]                           invokeRestart("muffleWarning")
[13:24:21.837]                       }
[13:24:21.837]                       else if (inherits(cond, "condition")) {
[13:24:21.837]                         if (!is.null(pattern)) {
[13:24:21.837]                           computeRestarts <- base::computeRestarts
[13:24:21.837]                           grepl <- base::grepl
[13:24:21.837]                           restarts <- computeRestarts(cond)
[13:24:21.837]                           for (restart in restarts) {
[13:24:21.837]                             name <- restart$name
[13:24:21.837]                             if (is.null(name)) 
[13:24:21.837]                               next
[13:24:21.837]                             if (!grepl(pattern, name)) 
[13:24:21.837]                               next
[13:24:21.837]                             invokeRestart(restart)
[13:24:21.837]                             muffled <- TRUE
[13:24:21.837]                             break
[13:24:21.837]                           }
[13:24:21.837]                         }
[13:24:21.837]                       }
[13:24:21.837]                       invisible(muffled)
[13:24:21.837]                     }
[13:24:21.837]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.837]                   }
[13:24:21.837]                 }
[13:24:21.837]             }
[13:24:21.837]         }))
[13:24:21.837]     }, error = function(ex) {
[13:24:21.837]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.837]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.837]                 ...future.rng), started = ...future.startTime, 
[13:24:21.837]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.837]             version = "1.8"), class = "FutureResult")
[13:24:21.837]     }, finally = {
[13:24:21.837]         if (!identical(...future.workdir, getwd())) 
[13:24:21.837]             setwd(...future.workdir)
[13:24:21.837]         {
[13:24:21.837]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.837]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.837]             }
[13:24:21.837]             base::options(...future.oldOptions)
[13:24:21.837]             if (.Platform$OS.type == "windows") {
[13:24:21.837]                 old_names <- names(...future.oldEnvVars)
[13:24:21.837]                 envs <- base::Sys.getenv()
[13:24:21.837]                 names <- names(envs)
[13:24:21.837]                 common <- intersect(names, old_names)
[13:24:21.837]                 added <- setdiff(names, old_names)
[13:24:21.837]                 removed <- setdiff(old_names, names)
[13:24:21.837]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.837]                   envs[common]]
[13:24:21.837]                 NAMES <- toupper(changed)
[13:24:21.837]                 args <- list()
[13:24:21.837]                 for (kk in seq_along(NAMES)) {
[13:24:21.837]                   name <- changed[[kk]]
[13:24:21.837]                   NAME <- NAMES[[kk]]
[13:24:21.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.837]                     next
[13:24:21.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.837]                 }
[13:24:21.837]                 NAMES <- toupper(added)
[13:24:21.837]                 for (kk in seq_along(NAMES)) {
[13:24:21.837]                   name <- added[[kk]]
[13:24:21.837]                   NAME <- NAMES[[kk]]
[13:24:21.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.837]                     next
[13:24:21.837]                   args[[name]] <- ""
[13:24:21.837]                 }
[13:24:21.837]                 NAMES <- toupper(removed)
[13:24:21.837]                 for (kk in seq_along(NAMES)) {
[13:24:21.837]                   name <- removed[[kk]]
[13:24:21.837]                   NAME <- NAMES[[kk]]
[13:24:21.837]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.837]                     next
[13:24:21.837]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.837]                 }
[13:24:21.837]                 if (length(args) > 0) 
[13:24:21.837]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.837]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.837]             }
[13:24:21.837]             else {
[13:24:21.837]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.837]             }
[13:24:21.837]             {
[13:24:21.837]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.837]                   0L) {
[13:24:21.837]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.837]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.837]                   base::options(opts)
[13:24:21.837]                 }
[13:24:21.837]                 {
[13:24:21.837]                   {
[13:24:21.837]                     NULL
[13:24:21.837]                     RNGkind("Mersenne-Twister")
[13:24:21.837]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.837]                       inherits = FALSE)
[13:24:21.837]                   }
[13:24:21.837]                   options(future.plan = NULL)
[13:24:21.837]                   if (is.na(NA_character_)) 
[13:24:21.837]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.837]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.837]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.837]                   {
[13:24:21.837]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.837]                     if (!future$lazy) 
[13:24:21.837]                       future <- run(future)
[13:24:21.837]                     invisible(future)
[13:24:21.837]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.837]                 }
[13:24:21.837]             }
[13:24:21.837]         }
[13:24:21.837]     })
[13:24:21.837]     if (TRUE) {
[13:24:21.837]         base::sink(type = "output", split = FALSE)
[13:24:21.837]         if (TRUE) {
[13:24:21.837]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.837]         }
[13:24:21.837]         else {
[13:24:21.837]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.837]         }
[13:24:21.837]         base::close(...future.stdout)
[13:24:21.837]         ...future.stdout <- NULL
[13:24:21.837]     }
[13:24:21.837]     ...future.result$conditions <- ...future.conditions
[13:24:21.837]     ...future.result$finished <- base::Sys.time()
[13:24:21.837]     ...future.result
[13:24:21.837] }
[13:24:21.839] plan(): Setting new future strategy stack:
[13:24:21.840] List of future strategies:
[13:24:21.840] 1. sequential:
[13:24:21.840]    - args: function (..., envir = parent.frame())
[13:24:21.840]    - tweaked: FALSE
[13:24:21.840]    - call: NULL
[13:24:21.842] plan(): nbrOfWorkers() = 1
[13:24:21.843] plan(): Setting new future strategy stack:
[13:24:21.843] List of future strategies:
[13:24:21.843] 1. sequential:
[13:24:21.843]    - args: function (..., envir = parent.frame())
[13:24:21.843]    - tweaked: FALSE
[13:24:21.843]    - call: plan(strategy)
[13:24:21.843] plan(): nbrOfWorkers() = 1
[13:24:21.844] SequentialFuture started (and completed)
[13:24:21.844] - Launch lazy future ... done
[13:24:21.844] run() for ‘SequentialFuture’ ... done
[13:24:21.844] getGlobalsAndPackages() ...
[13:24:21.844] Searching for globals...
[13:24:21.845] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:24:21.845] Searching for globals ... DONE
[13:24:21.845] Resolving globals: FALSE
[13:24:21.846] 
[13:24:21.846] 
[13:24:21.846] getGlobalsAndPackages() ... DONE
[13:24:21.846] run() for ‘Future’ ...
[13:24:21.846] - state: ‘created’
[13:24:21.846] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:21.847] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:21.847] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:21.847]   - Field: ‘label’
[13:24:21.847]   - Field: ‘local’
[13:24:21.847]   - Field: ‘owner’
[13:24:21.847]   - Field: ‘envir’
[13:24:21.847]   - Field: ‘packages’
[13:24:21.847]   - Field: ‘gc’
[13:24:21.847]   - Field: ‘conditions’
[13:24:21.848]   - Field: ‘expr’
[13:24:21.848]   - Field: ‘uuid’
[13:24:21.848]   - Field: ‘seed’
[13:24:21.848]   - Field: ‘version’
[13:24:21.848]   - Field: ‘result’
[13:24:21.848]   - Field: ‘asynchronous’
[13:24:21.848]   - Field: ‘calls’
[13:24:21.848]   - Field: ‘globals’
[13:24:21.848]   - Field: ‘stdout’
[13:24:21.848]   - Field: ‘earlySignal’
[13:24:21.849]   - Field: ‘lazy’
[13:24:21.849]   - Field: ‘state’
[13:24:21.849] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:21.849] - Launch lazy future ...
[13:24:21.849] Packages needed by the future expression (n = 0): <none>
[13:24:21.849] Packages needed by future strategies (n = 0): <none>
[13:24:21.850] {
[13:24:21.850]     {
[13:24:21.850]         {
[13:24:21.850]             ...future.startTime <- base::Sys.time()
[13:24:21.850]             {
[13:24:21.850]                 {
[13:24:21.850]                   {
[13:24:21.850]                     base::local({
[13:24:21.850]                       has_future <- base::requireNamespace("future", 
[13:24:21.850]                         quietly = TRUE)
[13:24:21.850]                       if (has_future) {
[13:24:21.850]                         ns <- base::getNamespace("future")
[13:24:21.850]                         version <- ns[[".package"]][["version"]]
[13:24:21.850]                         if (is.null(version)) 
[13:24:21.850]                           version <- utils::packageVersion("future")
[13:24:21.850]                       }
[13:24:21.850]                       else {
[13:24:21.850]                         version <- NULL
[13:24:21.850]                       }
[13:24:21.850]                       if (!has_future || version < "1.8.0") {
[13:24:21.850]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:21.850]                           "", base::R.version$version.string), 
[13:24:21.850]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:21.850]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:21.850]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:21.850]                             "release", "version")], collapse = " "), 
[13:24:21.850]                           hostname = base::Sys.info()[["nodename"]])
[13:24:21.850]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:21.850]                           info)
[13:24:21.850]                         info <- base::paste(info, collapse = "; ")
[13:24:21.850]                         if (!has_future) {
[13:24:21.850]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:21.850]                             info)
[13:24:21.850]                         }
[13:24:21.850]                         else {
[13:24:21.850]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:21.850]                             info, version)
[13:24:21.850]                         }
[13:24:21.850]                         base::stop(msg)
[13:24:21.850]                       }
[13:24:21.850]                     })
[13:24:21.850]                   }
[13:24:21.850]                   options(future.plan = NULL)
[13:24:21.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:21.850]                 }
[13:24:21.850]                 ...future.workdir <- getwd()
[13:24:21.850]             }
[13:24:21.850]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:21.850]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:21.850]         }
[13:24:21.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:21.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:21.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:21.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:21.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:21.850]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:21.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:21.850]             base::names(...future.oldOptions))
[13:24:21.850]     }
[13:24:21.850]     if (FALSE) {
[13:24:21.850]     }
[13:24:21.850]     else {
[13:24:21.850]         if (TRUE) {
[13:24:21.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:21.850]                 open = "w")
[13:24:21.850]         }
[13:24:21.850]         else {
[13:24:21.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:21.850]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:21.850]         }
[13:24:21.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:21.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:21.850]             base::sink(type = "output", split = FALSE)
[13:24:21.850]             base::close(...future.stdout)
[13:24:21.850]         }, add = TRUE)
[13:24:21.850]     }
[13:24:21.850]     ...future.frame <- base::sys.nframe()
[13:24:21.850]     ...future.conditions <- base::list()
[13:24:21.850]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:21.850]     if (FALSE) {
[13:24:21.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:21.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:21.850]     }
[13:24:21.850]     ...future.result <- base::tryCatch({
[13:24:21.850]         base::withCallingHandlers({
[13:24:21.850]             ...future.value <- base::withVisible(base::local({
[13:24:21.850]                 Sys.sleep(0.5)
[13:24:21.850]                 2
[13:24:21.850]             }))
[13:24:21.850]             future::FutureResult(value = ...future.value$value, 
[13:24:21.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.850]                   ...future.rng), globalenv = if (FALSE) 
[13:24:21.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:21.850]                     ...future.globalenv.names))
[13:24:21.850]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:21.850]         }, condition = base::local({
[13:24:21.850]             c <- base::c
[13:24:21.850]             inherits <- base::inherits
[13:24:21.850]             invokeRestart <- base::invokeRestart
[13:24:21.850]             length <- base::length
[13:24:21.850]             list <- base::list
[13:24:21.850]             seq.int <- base::seq.int
[13:24:21.850]             signalCondition <- base::signalCondition
[13:24:21.850]             sys.calls <- base::sys.calls
[13:24:21.850]             `[[` <- base::`[[`
[13:24:21.850]             `+` <- base::`+`
[13:24:21.850]             `<<-` <- base::`<<-`
[13:24:21.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:21.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:21.850]                   3L)]
[13:24:21.850]             }
[13:24:21.850]             function(cond) {
[13:24:21.850]                 is_error <- inherits(cond, "error")
[13:24:21.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:21.850]                   NULL)
[13:24:21.850]                 if (is_error) {
[13:24:21.850]                   sessionInformation <- function() {
[13:24:21.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:21.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:21.850]                       search = base::search(), system = base::Sys.info())
[13:24:21.850]                   }
[13:24:21.850]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:21.850]                     cond$call), session = sessionInformation(), 
[13:24:21.850]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:21.850]                   signalCondition(cond)
[13:24:21.850]                 }
[13:24:21.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:21.850]                 "immediateCondition"))) {
[13:24:21.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:21.850]                   ...future.conditions[[length(...future.conditions) + 
[13:24:21.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:21.850]                   if (TRUE && !signal) {
[13:24:21.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.850]                     {
[13:24:21.850]                       inherits <- base::inherits
[13:24:21.850]                       invokeRestart <- base::invokeRestart
[13:24:21.850]                       is.null <- base::is.null
[13:24:21.850]                       muffled <- FALSE
[13:24:21.850]                       if (inherits(cond, "message")) {
[13:24:21.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.850]                         if (muffled) 
[13:24:21.850]                           invokeRestart("muffleMessage")
[13:24:21.850]                       }
[13:24:21.850]                       else if (inherits(cond, "warning")) {
[13:24:21.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.850]                         if (muffled) 
[13:24:21.850]                           invokeRestart("muffleWarning")
[13:24:21.850]                       }
[13:24:21.850]                       else if (inherits(cond, "condition")) {
[13:24:21.850]                         if (!is.null(pattern)) {
[13:24:21.850]                           computeRestarts <- base::computeRestarts
[13:24:21.850]                           grepl <- base::grepl
[13:24:21.850]                           restarts <- computeRestarts(cond)
[13:24:21.850]                           for (restart in restarts) {
[13:24:21.850]                             name <- restart$name
[13:24:21.850]                             if (is.null(name)) 
[13:24:21.850]                               next
[13:24:21.850]                             if (!grepl(pattern, name)) 
[13:24:21.850]                               next
[13:24:21.850]                             invokeRestart(restart)
[13:24:21.850]                             muffled <- TRUE
[13:24:21.850]                             break
[13:24:21.850]                           }
[13:24:21.850]                         }
[13:24:21.850]                       }
[13:24:21.850]                       invisible(muffled)
[13:24:21.850]                     }
[13:24:21.850]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.850]                   }
[13:24:21.850]                 }
[13:24:21.850]                 else {
[13:24:21.850]                   if (TRUE) {
[13:24:21.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:21.850]                     {
[13:24:21.850]                       inherits <- base::inherits
[13:24:21.850]                       invokeRestart <- base::invokeRestart
[13:24:21.850]                       is.null <- base::is.null
[13:24:21.850]                       muffled <- FALSE
[13:24:21.850]                       if (inherits(cond, "message")) {
[13:24:21.850]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:21.850]                         if (muffled) 
[13:24:21.850]                           invokeRestart("muffleMessage")
[13:24:21.850]                       }
[13:24:21.850]                       else if (inherits(cond, "warning")) {
[13:24:21.850]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:21.850]                         if (muffled) 
[13:24:21.850]                           invokeRestart("muffleWarning")
[13:24:21.850]                       }
[13:24:21.850]                       else if (inherits(cond, "condition")) {
[13:24:21.850]                         if (!is.null(pattern)) {
[13:24:21.850]                           computeRestarts <- base::computeRestarts
[13:24:21.850]                           grepl <- base::grepl
[13:24:21.850]                           restarts <- computeRestarts(cond)
[13:24:21.850]                           for (restart in restarts) {
[13:24:21.850]                             name <- restart$name
[13:24:21.850]                             if (is.null(name)) 
[13:24:21.850]                               next
[13:24:21.850]                             if (!grepl(pattern, name)) 
[13:24:21.850]                               next
[13:24:21.850]                             invokeRestart(restart)
[13:24:21.850]                             muffled <- TRUE
[13:24:21.850]                             break
[13:24:21.850]                           }
[13:24:21.850]                         }
[13:24:21.850]                       }
[13:24:21.850]                       invisible(muffled)
[13:24:21.850]                     }
[13:24:21.850]                     muffleCondition(cond, pattern = "^muffle")
[13:24:21.850]                   }
[13:24:21.850]                 }
[13:24:21.850]             }
[13:24:21.850]         }))
[13:24:21.850]     }, error = function(ex) {
[13:24:21.850]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:21.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:21.850]                 ...future.rng), started = ...future.startTime, 
[13:24:21.850]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:21.850]             version = "1.8"), class = "FutureResult")
[13:24:21.850]     }, finally = {
[13:24:21.850]         if (!identical(...future.workdir, getwd())) 
[13:24:21.850]             setwd(...future.workdir)
[13:24:21.850]         {
[13:24:21.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:21.850]                 ...future.oldOptions$nwarnings <- NULL
[13:24:21.850]             }
[13:24:21.850]             base::options(...future.oldOptions)
[13:24:21.850]             if (.Platform$OS.type == "windows") {
[13:24:21.850]                 old_names <- names(...future.oldEnvVars)
[13:24:21.850]                 envs <- base::Sys.getenv()
[13:24:21.850]                 names <- names(envs)
[13:24:21.850]                 common <- intersect(names, old_names)
[13:24:21.850]                 added <- setdiff(names, old_names)
[13:24:21.850]                 removed <- setdiff(old_names, names)
[13:24:21.850]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:21.850]                   envs[common]]
[13:24:21.850]                 NAMES <- toupper(changed)
[13:24:21.850]                 args <- list()
[13:24:21.850]                 for (kk in seq_along(NAMES)) {
[13:24:21.850]                   name <- changed[[kk]]
[13:24:21.850]                   NAME <- NAMES[[kk]]
[13:24:21.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.850]                     next
[13:24:21.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.850]                 }
[13:24:21.850]                 NAMES <- toupper(added)
[13:24:21.850]                 for (kk in seq_along(NAMES)) {
[13:24:21.850]                   name <- added[[kk]]
[13:24:21.850]                   NAME <- NAMES[[kk]]
[13:24:21.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.850]                     next
[13:24:21.850]                   args[[name]] <- ""
[13:24:21.850]                 }
[13:24:21.850]                 NAMES <- toupper(removed)
[13:24:21.850]                 for (kk in seq_along(NAMES)) {
[13:24:21.850]                   name <- removed[[kk]]
[13:24:21.850]                   NAME <- NAMES[[kk]]
[13:24:21.850]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:21.850]                     next
[13:24:21.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:21.850]                 }
[13:24:21.850]                 if (length(args) > 0) 
[13:24:21.850]                   base::do.call(base::Sys.setenv, args = args)
[13:24:21.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:21.850]             }
[13:24:21.850]             else {
[13:24:21.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:21.850]             }
[13:24:21.850]             {
[13:24:21.850]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:21.850]                   0L) {
[13:24:21.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:21.850]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:21.850]                   base::options(opts)
[13:24:21.850]                 }
[13:24:21.850]                 {
[13:24:21.850]                   {
[13:24:21.850]                     NULL
[13:24:21.850]                     RNGkind("Mersenne-Twister")
[13:24:21.850]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:21.850]                       inherits = FALSE)
[13:24:21.850]                   }
[13:24:21.850]                   options(future.plan = NULL)
[13:24:21.850]                   if (is.na(NA_character_)) 
[13:24:21.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:21.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:21.850]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:21.850]                   {
[13:24:21.850]                     future <- SequentialFuture(..., envir = envir)
[13:24:21.850]                     if (!future$lazy) 
[13:24:21.850]                       future <- run(future)
[13:24:21.850]                     invisible(future)
[13:24:21.850]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:21.850]                 }
[13:24:21.850]             }
[13:24:21.850]         }
[13:24:21.850]     })
[13:24:21.850]     if (TRUE) {
[13:24:21.850]         base::sink(type = "output", split = FALSE)
[13:24:21.850]         if (TRUE) {
[13:24:21.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:21.850]         }
[13:24:21.850]         else {
[13:24:21.850]             ...future.result["stdout"] <- base::list(NULL)
[13:24:21.850]         }
[13:24:21.850]         base::close(...future.stdout)
[13:24:21.850]         ...future.stdout <- NULL
[13:24:21.850]     }
[13:24:21.850]     ...future.result$conditions <- ...future.conditions
[13:24:21.850]     ...future.result$finished <- base::Sys.time()
[13:24:21.850]     ...future.result
[13:24:21.850] }
[13:24:21.851] plan(): Setting new future strategy stack:
[13:24:21.851] List of future strategies:
[13:24:21.851] 1. sequential:
[13:24:21.851]    - args: function (..., envir = parent.frame())
[13:24:21.851]    - tweaked: FALSE
[13:24:21.851]    - call: NULL
[13:24:21.852] plan(): nbrOfWorkers() = 1
[13:24:22.353] plan(): Setting new future strategy stack:
[13:24:22.354] List of future strategies:
[13:24:22.354] 1. sequential:
[13:24:22.354]    - args: function (..., envir = parent.frame())
[13:24:22.354]    - tweaked: FALSE
[13:24:22.354]    - call: plan(strategy)
[13:24:22.354] plan(): nbrOfWorkers() = 1
[13:24:22.354] SequentialFuture started (and completed)
[13:24:22.354] - Launch lazy future ... done
[13:24:22.355] run() for ‘SequentialFuture’ ... done
[13:24:22.355] getGlobalsAndPackages() ...
[13:24:22.355] Searching for globals...
[13:24:22.356] - globals found: [1] ‘{’
[13:24:22.356] Searching for globals ... DONE
[13:24:22.356] Resolving globals: FALSE
[13:24:22.356] 
[13:24:22.356] 
[13:24:22.356] getGlobalsAndPackages() ... DONE
[13:24:22.357] run() for ‘Future’ ...
[13:24:22.357] - state: ‘created’
[13:24:22.357] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:24:22.357] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:24:22.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:24:22.357]   - Field: ‘label’
[13:24:22.358]   - Field: ‘local’
[13:24:22.358]   - Field: ‘owner’
[13:24:22.358]   - Field: ‘envir’
[13:24:22.358]   - Field: ‘packages’
[13:24:22.358]   - Field: ‘gc’
[13:24:22.358]   - Field: ‘conditions’
[13:24:22.358]   - Field: ‘expr’
[13:24:22.358]   - Field: ‘uuid’
[13:24:22.358]   - Field: ‘seed’
[13:24:22.358]   - Field: ‘version’
[13:24:22.358]   - Field: ‘result’
[13:24:22.359]   - Field: ‘asynchronous’
[13:24:22.359]   - Field: ‘calls’
[13:24:22.359]   - Field: ‘globals’
[13:24:22.359]   - Field: ‘stdout’
[13:24:22.359]   - Field: ‘earlySignal’
[13:24:22.359]   - Field: ‘lazy’
[13:24:22.359]   - Field: ‘state’
[13:24:22.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:24:22.359] - Launch lazy future ...
[13:24:22.359] Packages needed by the future expression (n = 0): <none>
[13:24:22.360] Packages needed by future strategies (n = 0): <none>
[13:24:22.360] {
[13:24:22.360]     {
[13:24:22.360]         {
[13:24:22.360]             ...future.startTime <- base::Sys.time()
[13:24:22.360]             {
[13:24:22.360]                 {
[13:24:22.360]                   {
[13:24:22.360]                     base::local({
[13:24:22.360]                       has_future <- base::requireNamespace("future", 
[13:24:22.360]                         quietly = TRUE)
[13:24:22.360]                       if (has_future) {
[13:24:22.360]                         ns <- base::getNamespace("future")
[13:24:22.360]                         version <- ns[[".package"]][["version"]]
[13:24:22.360]                         if (is.null(version)) 
[13:24:22.360]                           version <- utils::packageVersion("future")
[13:24:22.360]                       }
[13:24:22.360]                       else {
[13:24:22.360]                         version <- NULL
[13:24:22.360]                       }
[13:24:22.360]                       if (!has_future || version < "1.8.0") {
[13:24:22.360]                         info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.360]                           "", base::R.version$version.string), 
[13:24:22.360]                           platform = base::sprintf("%s (%s-bit)", 
[13:24:22.360]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.360]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.360]                             "release", "version")], collapse = " "), 
[13:24:22.360]                           hostname = base::Sys.info()[["nodename"]])
[13:24:22.360]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.360]                           info)
[13:24:22.360]                         info <- base::paste(info, collapse = "; ")
[13:24:22.360]                         if (!has_future) {
[13:24:22.360]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.360]                             info)
[13:24:22.360]                         }
[13:24:22.360]                         else {
[13:24:22.360]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.360]                             info, version)
[13:24:22.360]                         }
[13:24:22.360]                         base::stop(msg)
[13:24:22.360]                       }
[13:24:22.360]                     })
[13:24:22.360]                   }
[13:24:22.360]                   options(future.plan = NULL)
[13:24:22.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.360]                 }
[13:24:22.360]                 ...future.workdir <- getwd()
[13:24:22.360]             }
[13:24:22.360]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.360]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.360]         }
[13:24:22.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.360]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.360]             base::names(...future.oldOptions))
[13:24:22.360]     }
[13:24:22.360]     if (FALSE) {
[13:24:22.360]     }
[13:24:22.360]     else {
[13:24:22.360]         if (TRUE) {
[13:24:22.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.360]                 open = "w")
[13:24:22.360]         }
[13:24:22.360]         else {
[13:24:22.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.360]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.360]         }
[13:24:22.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.360]             base::sink(type = "output", split = FALSE)
[13:24:22.360]             base::close(...future.stdout)
[13:24:22.360]         }, add = TRUE)
[13:24:22.360]     }
[13:24:22.360]     ...future.frame <- base::sys.nframe()
[13:24:22.360]     ...future.conditions <- base::list()
[13:24:22.360]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.360]     if (FALSE) {
[13:24:22.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.360]     }
[13:24:22.360]     ...future.result <- base::tryCatch({
[13:24:22.360]         base::withCallingHandlers({
[13:24:22.360]             ...future.value <- base::withVisible(base::local({
[13:24:22.360]                 3
[13:24:22.360]             }))
[13:24:22.360]             future::FutureResult(value = ...future.value$value, 
[13:24:22.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.360]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.360]                     ...future.globalenv.names))
[13:24:22.360]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.360]         }, condition = base::local({
[13:24:22.360]             c <- base::c
[13:24:22.360]             inherits <- base::inherits
[13:24:22.360]             invokeRestart <- base::invokeRestart
[13:24:22.360]             length <- base::length
[13:24:22.360]             list <- base::list
[13:24:22.360]             seq.int <- base::seq.int
[13:24:22.360]             signalCondition <- base::signalCondition
[13:24:22.360]             sys.calls <- base::sys.calls
[13:24:22.360]             `[[` <- base::`[[`
[13:24:22.360]             `+` <- base::`+`
[13:24:22.360]             `<<-` <- base::`<<-`
[13:24:22.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.360]                   3L)]
[13:24:22.360]             }
[13:24:22.360]             function(cond) {
[13:24:22.360]                 is_error <- inherits(cond, "error")
[13:24:22.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.360]                   NULL)
[13:24:22.360]                 if (is_error) {
[13:24:22.360]                   sessionInformation <- function() {
[13:24:22.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.360]                       search = base::search(), system = base::Sys.info())
[13:24:22.360]                   }
[13:24:22.360]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.360]                     cond$call), session = sessionInformation(), 
[13:24:22.360]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.360]                   signalCondition(cond)
[13:24:22.360]                 }
[13:24:22.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.360]                 "immediateCondition"))) {
[13:24:22.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.360]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.360]                   if (TRUE && !signal) {
[13:24:22.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.360]                     {
[13:24:22.360]                       inherits <- base::inherits
[13:24:22.360]                       invokeRestart <- base::invokeRestart
[13:24:22.360]                       is.null <- base::is.null
[13:24:22.360]                       muffled <- FALSE
[13:24:22.360]                       if (inherits(cond, "message")) {
[13:24:22.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.360]                         if (muffled) 
[13:24:22.360]                           invokeRestart("muffleMessage")
[13:24:22.360]                       }
[13:24:22.360]                       else if (inherits(cond, "warning")) {
[13:24:22.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.360]                         if (muffled) 
[13:24:22.360]                           invokeRestart("muffleWarning")
[13:24:22.360]                       }
[13:24:22.360]                       else if (inherits(cond, "condition")) {
[13:24:22.360]                         if (!is.null(pattern)) {
[13:24:22.360]                           computeRestarts <- base::computeRestarts
[13:24:22.360]                           grepl <- base::grepl
[13:24:22.360]                           restarts <- computeRestarts(cond)
[13:24:22.360]                           for (restart in restarts) {
[13:24:22.360]                             name <- restart$name
[13:24:22.360]                             if (is.null(name)) 
[13:24:22.360]                               next
[13:24:22.360]                             if (!grepl(pattern, name)) 
[13:24:22.360]                               next
[13:24:22.360]                             invokeRestart(restart)
[13:24:22.360]                             muffled <- TRUE
[13:24:22.360]                             break
[13:24:22.360]                           }
[13:24:22.360]                         }
[13:24:22.360]                       }
[13:24:22.360]                       invisible(muffled)
[13:24:22.360]                     }
[13:24:22.360]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.360]                   }
[13:24:22.360]                 }
[13:24:22.360]                 else {
[13:24:22.360]                   if (TRUE) {
[13:24:22.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.360]                     {
[13:24:22.360]                       inherits <- base::inherits
[13:24:22.360]                       invokeRestart <- base::invokeRestart
[13:24:22.360]                       is.null <- base::is.null
[13:24:22.360]                       muffled <- FALSE
[13:24:22.360]                       if (inherits(cond, "message")) {
[13:24:22.360]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.360]                         if (muffled) 
[13:24:22.360]                           invokeRestart("muffleMessage")
[13:24:22.360]                       }
[13:24:22.360]                       else if (inherits(cond, "warning")) {
[13:24:22.360]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.360]                         if (muffled) 
[13:24:22.360]                           invokeRestart("muffleWarning")
[13:24:22.360]                       }
[13:24:22.360]                       else if (inherits(cond, "condition")) {
[13:24:22.360]                         if (!is.null(pattern)) {
[13:24:22.360]                           computeRestarts <- base::computeRestarts
[13:24:22.360]                           grepl <- base::grepl
[13:24:22.360]                           restarts <- computeRestarts(cond)
[13:24:22.360]                           for (restart in restarts) {
[13:24:22.360]                             name <- restart$name
[13:24:22.360]                             if (is.null(name)) 
[13:24:22.360]                               next
[13:24:22.360]                             if (!grepl(pattern, name)) 
[13:24:22.360]                               next
[13:24:22.360]                             invokeRestart(restart)
[13:24:22.360]                             muffled <- TRUE
[13:24:22.360]                             break
[13:24:22.360]                           }
[13:24:22.360]                         }
[13:24:22.360]                       }
[13:24:22.360]                       invisible(muffled)
[13:24:22.360]                     }
[13:24:22.360]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.360]                   }
[13:24:22.360]                 }
[13:24:22.360]             }
[13:24:22.360]         }))
[13:24:22.360]     }, error = function(ex) {
[13:24:22.360]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.360]                 ...future.rng), started = ...future.startTime, 
[13:24:22.360]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.360]             version = "1.8"), class = "FutureResult")
[13:24:22.360]     }, finally = {
[13:24:22.360]         if (!identical(...future.workdir, getwd())) 
[13:24:22.360]             setwd(...future.workdir)
[13:24:22.360]         {
[13:24:22.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.360]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.360]             }
[13:24:22.360]             base::options(...future.oldOptions)
[13:24:22.360]             if (.Platform$OS.type == "windows") {
[13:24:22.360]                 old_names <- names(...future.oldEnvVars)
[13:24:22.360]                 envs <- base::Sys.getenv()
[13:24:22.360]                 names <- names(envs)
[13:24:22.360]                 common <- intersect(names, old_names)
[13:24:22.360]                 added <- setdiff(names, old_names)
[13:24:22.360]                 removed <- setdiff(old_names, names)
[13:24:22.360]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.360]                   envs[common]]
[13:24:22.360]                 NAMES <- toupper(changed)
[13:24:22.360]                 args <- list()
[13:24:22.360]                 for (kk in seq_along(NAMES)) {
[13:24:22.360]                   name <- changed[[kk]]
[13:24:22.360]                   NAME <- NAMES[[kk]]
[13:24:22.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.360]                     next
[13:24:22.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.360]                 }
[13:24:22.360]                 NAMES <- toupper(added)
[13:24:22.360]                 for (kk in seq_along(NAMES)) {
[13:24:22.360]                   name <- added[[kk]]
[13:24:22.360]                   NAME <- NAMES[[kk]]
[13:24:22.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.360]                     next
[13:24:22.360]                   args[[name]] <- ""
[13:24:22.360]                 }
[13:24:22.360]                 NAMES <- toupper(removed)
[13:24:22.360]                 for (kk in seq_along(NAMES)) {
[13:24:22.360]                   name <- removed[[kk]]
[13:24:22.360]                   NAME <- NAMES[[kk]]
[13:24:22.360]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.360]                     next
[13:24:22.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.360]                 }
[13:24:22.360]                 if (length(args) > 0) 
[13:24:22.360]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.360]             }
[13:24:22.360]             else {
[13:24:22.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.360]             }
[13:24:22.360]             {
[13:24:22.360]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.360]                   0L) {
[13:24:22.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.360]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.360]                   base::options(opts)
[13:24:22.360]                 }
[13:24:22.360]                 {
[13:24:22.360]                   {
[13:24:22.360]                     NULL
[13:24:22.360]                     RNGkind("Mersenne-Twister")
[13:24:22.360]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:24:22.360]                       inherits = FALSE)
[13:24:22.360]                   }
[13:24:22.360]                   options(future.plan = NULL)
[13:24:22.360]                   if (is.na(NA_character_)) 
[13:24:22.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.360]                   future::plan(list(function (..., envir = parent.frame()) 
[13:24:22.360]                   {
[13:24:22.360]                     future <- SequentialFuture(..., envir = envir)
[13:24:22.360]                     if (!future$lazy) 
[13:24:22.360]                       future <- run(future)
[13:24:22.360]                     invisible(future)
[13:24:22.360]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.360]                 }
[13:24:22.360]             }
[13:24:22.360]         }
[13:24:22.360]     })
[13:24:22.360]     if (TRUE) {
[13:24:22.360]         base::sink(type = "output", split = FALSE)
[13:24:22.360]         if (TRUE) {
[13:24:22.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.360]         }
[13:24:22.360]         else {
[13:24:22.360]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.360]         }
[13:24:22.360]         base::close(...future.stdout)
[13:24:22.360]         ...future.stdout <- NULL
[13:24:22.360]     }
[13:24:22.360]     ...future.result$conditions <- ...future.conditions
[13:24:22.360]     ...future.result$finished <- base::Sys.time()
[13:24:22.360]     ...future.result
[13:24:22.360] }
[13:24:22.362] plan(): Setting new future strategy stack:
[13:24:22.362] List of future strategies:
[13:24:22.362] 1. sequential:
[13:24:22.362]    - args: function (..., envir = parent.frame())
[13:24:22.362]    - tweaked: FALSE
[13:24:22.362]    - call: NULL
[13:24:22.362] plan(): nbrOfWorkers() = 1
[13:24:22.363] plan(): Setting new future strategy stack:
[13:24:22.363] List of future strategies:
[13:24:22.363] 1. sequential:
[13:24:22.363]    - args: function (..., envir = parent.frame())
[13:24:22.363]    - tweaked: FALSE
[13:24:22.363]    - call: plan(strategy)
[13:24:22.364] plan(): nbrOfWorkers() = 1
[13:24:22.364] SequentialFuture started (and completed)
[13:24:22.364] - Launch lazy future ... done
[13:24:22.364] run() for ‘SequentialFuture’ ... done
[13:24:22.365] resolve() on list environment ...
[13:24:22.365]  recursive: 0
[13:24:22.365]  length: 4
[13:24:22.365]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:22.366] resolved() for ‘SequentialFuture’ ...
[13:24:22.366] - state: ‘finished’
[13:24:22.366] - run: TRUE
[13:24:22.366] - result: ‘FutureResult’
[13:24:22.366] resolved() for ‘SequentialFuture’ ... done
[13:24:22.366] Future #1
[13:24:22.366]  length: 3 (resolved future 1)
[13:24:22.366] resolved() for ‘SequentialFuture’ ...
[13:24:22.366] - state: ‘finished’
[13:24:22.367] - run: TRUE
[13:24:22.367] - result: ‘FutureResult’
[13:24:22.367] resolved() for ‘SequentialFuture’ ... done
[13:24:22.367] Future #2
[13:24:22.367]  length: 2 (resolved future 2)
[13:24:22.367] resolved() for ‘SequentialFuture’ ...
[13:24:22.367] - state: ‘finished’
[13:24:22.367] - run: TRUE
[13:24:22.367] - result: ‘FutureResult’
[13:24:22.367] resolved() for ‘SequentialFuture’ ... done
[13:24:22.367] Future #3
[13:24:22.368]  length: 1 (resolved future 3)
[13:24:22.368]  length: 0 (resolved future 4)
[13:24:22.368] resolve() on list environment ... DONE
[13:24:22.368] resolved() for ‘SequentialFuture’ ...
[13:24:22.368] - state: ‘finished’
[13:24:22.368] - run: TRUE
[13:24:22.370] - result: ‘FutureResult’
[13:24:22.371] resolved() for ‘SequentialFuture’ ... done
[13:24:22.371] resolve() on list environment ...
[13:24:22.371]  recursive: 0
[13:24:22.371]  length: 4
[13:24:22.372]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:22.372] resolved() for ‘SequentialFuture’ ...
[13:24:22.372] - state: ‘finished’
[13:24:22.372] - run: TRUE
[13:24:22.372] - result: ‘FutureResult’
[13:24:22.372] resolved() for ‘SequentialFuture’ ... done
[13:24:22.372] Future #1
[13:24:22.372]  length: 3 (resolved future 1)
[13:24:22.372] resolved() for ‘SequentialFuture’ ...
[13:24:22.373] - state: ‘finished’
[13:24:22.373] - run: TRUE
[13:24:22.373] - result: ‘FutureResult’
[13:24:22.373] resolved() for ‘SequentialFuture’ ... done
[13:24:22.373] Future #2
[13:24:22.373]  length: 2 (resolved future 2)
[13:24:22.373] resolved() for ‘SequentialFuture’ ...
[13:24:22.373] - state: ‘finished’
[13:24:22.373] - run: TRUE
[13:24:22.373] - result: ‘FutureResult’
[13:24:22.374] resolved() for ‘SequentialFuture’ ... done
[13:24:22.374] Future #3
[13:24:22.374]  length: 1 (resolved future 3)
[13:24:22.374]  length: 0 (resolved future 4)
[13:24:22.374] resolve() on list environment ... DONE
[13:24:22.375] resolve() on list environment ...
[13:24:22.375]  recursive: 0
[13:24:22.375]  length: 4
[13:24:22.376]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:22.376] resolved() for ‘SequentialFuture’ ...
[13:24:22.376] - state: ‘finished’
[13:24:22.376] - run: TRUE
[13:24:22.376] - result: ‘FutureResult’
[13:24:22.376] resolved() for ‘SequentialFuture’ ... done
[13:24:22.376] Future #1
[13:24:22.376]  length: 3 (resolved future 1)
[13:24:22.376] resolved() for ‘SequentialFuture’ ...
[13:24:22.376] - state: ‘finished’
[13:24:22.377] - run: TRUE
[13:24:22.377] - result: ‘FutureResult’
[13:24:22.377] resolved() for ‘SequentialFuture’ ... done
[13:24:22.377] Future #2
[13:24:22.377]  length: 2 (resolved future 2)
[13:24:22.377] resolved() for ‘SequentialFuture’ ...
[13:24:22.377] - state: ‘finished’
[13:24:22.377] - run: TRUE
[13:24:22.377] - result: ‘FutureResult’
[13:24:22.377] resolved() for ‘SequentialFuture’ ... done
[13:24:22.378] Future #3
[13:24:22.378]  length: 1 (resolved future 3)
[13:24:22.378]  length: 0 (resolved future 4)
[13:24:22.378] resolve() on list environment ... DONE
[13:24:22.378] resolve() on list environment ...
[13:24:22.378]  recursive: 0
[13:24:22.379]  length: 4
[13:24:22.379]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:22.379] resolved() for ‘SequentialFuture’ ...
[13:24:22.379] - state: ‘finished’
[13:24:22.379] - run: TRUE
[13:24:22.379] - result: ‘FutureResult’
[13:24:22.380] resolved() for ‘SequentialFuture’ ... done
[13:24:22.380] Future #1
[13:24:22.380]  length: 3 (resolved future 1)
[13:24:22.380] resolved() for ‘SequentialFuture’ ...
[13:24:22.380] - state: ‘finished’
[13:24:22.380] - run: TRUE
[13:24:22.380] - result: ‘FutureResult’
[13:24:22.380] resolved() for ‘SequentialFuture’ ... done
[13:24:22.380] Future #2
[13:24:22.381]  length: 2 (resolved future 2)
[13:24:22.381] resolved() for ‘SequentialFuture’ ...
[13:24:22.381] - state: ‘finished’
[13:24:22.381] - run: TRUE
[13:24:22.381] - result: ‘FutureResult’
[13:24:22.381] resolved() for ‘SequentialFuture’ ... done
[13:24:22.381] Future #3
[13:24:22.381]  length: 1 (resolved future 3)
[13:24:22.381]  length: 0 (resolved future 4)
[13:24:22.381] resolve() on list environment ... DONE
[13:24:22.382] resolve() on list environment ...
[13:24:22.382]  recursive: 0
[13:24:22.383]  length: 4
[13:24:22.383]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:22.383] resolved() for ‘SequentialFuture’ ...
[13:24:22.383] - state: ‘finished’
[13:24:22.383] - run: TRUE
[13:24:22.383] - result: ‘FutureResult’
[13:24:22.383] resolved() for ‘SequentialFuture’ ... done
[13:24:22.383] Future #1
[13:24:22.383]  length: 3 (resolved future 1)
[13:24:22.384] resolved() for ‘SequentialFuture’ ...
[13:24:22.384] - state: ‘finished’
[13:24:22.384] - run: TRUE
[13:24:22.384] - result: ‘FutureResult’
[13:24:22.384] resolved() for ‘SequentialFuture’ ... done
[13:24:22.384] Future #2
[13:24:22.384]  length: 2 (resolved future 2)
[13:24:22.384] resolved() for ‘SequentialFuture’ ...
[13:24:22.384] - state: ‘finished’
[13:24:22.385] - run: TRUE
[13:24:22.385] - result: ‘FutureResult’
[13:24:22.385] resolved() for ‘SequentialFuture’ ... done
[13:24:22.385] Future #3
[13:24:22.385]  length: 1 (resolved future 3)
[13:24:22.385]  length: 0 (resolved future 4)
[13:24:22.385] resolve() on list environment ... DONE
[13:24:22.386] resolve() on list environment ...
[13:24:22.386]  recursive: 99
[13:24:22.386]  length: 4
[13:24:22.386]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:22.387] resolved() for ‘SequentialFuture’ ...
[13:24:22.387] - state: ‘finished’
[13:24:22.387] - run: TRUE
[13:24:22.387] - result: ‘FutureResult’
[13:24:22.387] resolved() for ‘SequentialFuture’ ... done
[13:24:22.387] Future #1
[13:24:22.387] resolved() for ‘SequentialFuture’ ...
[13:24:22.387] - state: ‘finished’
[13:24:22.387] - run: TRUE
[13:24:22.387] - result: ‘FutureResult’
[13:24:22.388] resolved() for ‘SequentialFuture’ ... done
[13:24:22.388] A SequentialFuture was resolved
[13:24:22.388]  length: 3 (resolved future 1)
[13:24:22.388] resolved() for ‘SequentialFuture’ ...
[13:24:22.388] - state: ‘finished’
[13:24:22.388] - run: TRUE
[13:24:22.388] - result: ‘FutureResult’
[13:24:22.388] resolved() for ‘SequentialFuture’ ... done
[13:24:22.388] Future #2
[13:24:22.388] resolved() for ‘SequentialFuture’ ...
[13:24:22.389] - state: ‘finished’
[13:24:22.389] - run: TRUE
[13:24:22.389] - result: ‘FutureResult’
[13:24:22.389] resolved() for ‘SequentialFuture’ ... done
[13:24:22.389] A SequentialFuture was resolved
[13:24:22.389]  length: 2 (resolved future 2)
[13:24:22.389] resolved() for ‘SequentialFuture’ ...
[13:24:22.389] - state: ‘finished’
[13:24:22.389] - run: TRUE
[13:24:22.389] - result: ‘FutureResult’
[13:24:22.390] resolved() for ‘SequentialFuture’ ... done
[13:24:22.390] Future #3
[13:24:22.390] resolved() for ‘SequentialFuture’ ...
[13:24:22.390] - state: ‘finished’
[13:24:22.390] - run: TRUE
[13:24:22.390] - result: ‘FutureResult’
[13:24:22.417] resolved() for ‘SequentialFuture’ ... done
[13:24:22.418] A SequentialFuture was resolved
[13:24:22.418]  length: 1 (resolved future 3)
[13:24:22.418]  length: 0 (resolved future 4)
[13:24:22.418] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[13:24:22.419] plan(): Setting new future strategy stack:
[13:24:22.419] List of future strategies:
[13:24:22.419] 1. multicore:
[13:24:22.419]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.419]    - tweaked: FALSE
[13:24:22.419]    - call: plan(strategy)
[13:24:22.423] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[13:24:22.423] resolve() on list ...
[13:24:22.423]  recursive: 0
[13:24:22.424]  length: 2
[13:24:22.424]  elements: ‘a’, ‘b’
[13:24:22.424]  length: 1 (resolved future 1)
[13:24:22.424]  length: 0 (resolved future 2)
[13:24:22.424] resolve() on list ... DONE
[13:24:22.424] getGlobalsAndPackages() ...
[13:24:22.424] Searching for globals...
[13:24:22.425] 
[13:24:22.425] Searching for globals ... DONE
[13:24:22.425] - globals: [0] <none>
[13:24:22.425] getGlobalsAndPackages() ... DONE
[13:24:22.425] run() for ‘Future’ ...
[13:24:22.425] - state: ‘created’
[13:24:22.425] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.429] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.429]   - Field: ‘label’
[13:24:22.430]   - Field: ‘local’
[13:24:22.430]   - Field: ‘owner’
[13:24:22.430]   - Field: ‘envir’
[13:24:22.430]   - Field: ‘workers’
[13:24:22.430]   - Field: ‘packages’
[13:24:22.430]   - Field: ‘gc’
[13:24:22.430]   - Field: ‘job’
[13:24:22.430]   - Field: ‘conditions’
[13:24:22.430]   - Field: ‘expr’
[13:24:22.430]   - Field: ‘uuid’
[13:24:22.430]   - Field: ‘seed’
[13:24:22.431]   - Field: ‘version’
[13:24:22.431]   - Field: ‘result’
[13:24:22.431]   - Field: ‘asynchronous’
[13:24:22.431]   - Field: ‘calls’
[13:24:22.431]   - Field: ‘globals’
[13:24:22.431]   - Field: ‘stdout’
[13:24:22.431]   - Field: ‘earlySignal’
[13:24:22.431]   - Field: ‘lazy’
[13:24:22.431]   - Field: ‘state’
[13:24:22.431] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.432] - Launch lazy future ...
[13:24:22.433] Packages needed by the future expression (n = 0): <none>
[13:24:22.433] Packages needed by future strategies (n = 0): <none>
[13:24:22.433] {
[13:24:22.433]     {
[13:24:22.433]         {
[13:24:22.433]             ...future.startTime <- base::Sys.time()
[13:24:22.433]             {
[13:24:22.433]                 {
[13:24:22.433]                   {
[13:24:22.433]                     {
[13:24:22.433]                       base::local({
[13:24:22.433]                         has_future <- base::requireNamespace("future", 
[13:24:22.433]                           quietly = TRUE)
[13:24:22.433]                         if (has_future) {
[13:24:22.433]                           ns <- base::getNamespace("future")
[13:24:22.433]                           version <- ns[[".package"]][["version"]]
[13:24:22.433]                           if (is.null(version)) 
[13:24:22.433]                             version <- utils::packageVersion("future")
[13:24:22.433]                         }
[13:24:22.433]                         else {
[13:24:22.433]                           version <- NULL
[13:24:22.433]                         }
[13:24:22.433]                         if (!has_future || version < "1.8.0") {
[13:24:22.433]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.433]                             "", base::R.version$version.string), 
[13:24:22.433]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.433]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.433]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.433]                               "release", "version")], collapse = " "), 
[13:24:22.433]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.433]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.433]                             info)
[13:24:22.433]                           info <- base::paste(info, collapse = "; ")
[13:24:22.433]                           if (!has_future) {
[13:24:22.433]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.433]                               info)
[13:24:22.433]                           }
[13:24:22.433]                           else {
[13:24:22.433]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.433]                               info, version)
[13:24:22.433]                           }
[13:24:22.433]                           base::stop(msg)
[13:24:22.433]                         }
[13:24:22.433]                       })
[13:24:22.433]                     }
[13:24:22.433]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.433]                     base::options(mc.cores = 1L)
[13:24:22.433]                   }
[13:24:22.433]                   options(future.plan = NULL)
[13:24:22.433]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.433]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.433]                 }
[13:24:22.433]                 ...future.workdir <- getwd()
[13:24:22.433]             }
[13:24:22.433]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.433]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.433]         }
[13:24:22.433]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.433]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.433]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.433]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.433]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.433]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.433]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.433]             base::names(...future.oldOptions))
[13:24:22.433]     }
[13:24:22.433]     if (FALSE) {
[13:24:22.433]     }
[13:24:22.433]     else {
[13:24:22.433]         if (TRUE) {
[13:24:22.433]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.433]                 open = "w")
[13:24:22.433]         }
[13:24:22.433]         else {
[13:24:22.433]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.433]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.433]         }
[13:24:22.433]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.433]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.433]             base::sink(type = "output", split = FALSE)
[13:24:22.433]             base::close(...future.stdout)
[13:24:22.433]         }, add = TRUE)
[13:24:22.433]     }
[13:24:22.433]     ...future.frame <- base::sys.nframe()
[13:24:22.433]     ...future.conditions <- base::list()
[13:24:22.433]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.433]     if (FALSE) {
[13:24:22.433]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.433]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.433]     }
[13:24:22.433]     ...future.result <- base::tryCatch({
[13:24:22.433]         base::withCallingHandlers({
[13:24:22.433]             ...future.value <- base::withVisible(base::local({
[13:24:22.433]                 withCallingHandlers({
[13:24:22.433]                   1
[13:24:22.433]                 }, immediateCondition = function(cond) {
[13:24:22.433]                   save_rds <- function (object, pathname, ...) 
[13:24:22.433]                   {
[13:24:22.433]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.433]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.433]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.433]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.433]                         fi_tmp[["mtime"]])
[13:24:22.433]                     }
[13:24:22.433]                     tryCatch({
[13:24:22.433]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.433]                     }, error = function(ex) {
[13:24:22.433]                       msg <- conditionMessage(ex)
[13:24:22.433]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.433]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.433]                         fi_tmp[["mtime"]], msg)
[13:24:22.433]                       ex$message <- msg
[13:24:22.433]                       stop(ex)
[13:24:22.433]                     })
[13:24:22.433]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.433]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.433]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.433]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.433]                       fi <- file.info(pathname)
[13:24:22.433]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.433]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.433]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.433]                         fi[["size"]], fi[["mtime"]])
[13:24:22.433]                       stop(msg)
[13:24:22.433]                     }
[13:24:22.433]                     invisible(pathname)
[13:24:22.433]                   }
[13:24:22.433]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.433]                     rootPath = tempdir()) 
[13:24:22.433]                   {
[13:24:22.433]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.433]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.433]                       tmpdir = path, fileext = ".rds")
[13:24:22.433]                     save_rds(obj, file)
[13:24:22.433]                   }
[13:24:22.433]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.433]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.433]                   {
[13:24:22.433]                     inherits <- base::inherits
[13:24:22.433]                     invokeRestart <- base::invokeRestart
[13:24:22.433]                     is.null <- base::is.null
[13:24:22.433]                     muffled <- FALSE
[13:24:22.433]                     if (inherits(cond, "message")) {
[13:24:22.433]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.433]                       if (muffled) 
[13:24:22.433]                         invokeRestart("muffleMessage")
[13:24:22.433]                     }
[13:24:22.433]                     else if (inherits(cond, "warning")) {
[13:24:22.433]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.433]                       if (muffled) 
[13:24:22.433]                         invokeRestart("muffleWarning")
[13:24:22.433]                     }
[13:24:22.433]                     else if (inherits(cond, "condition")) {
[13:24:22.433]                       if (!is.null(pattern)) {
[13:24:22.433]                         computeRestarts <- base::computeRestarts
[13:24:22.433]                         grepl <- base::grepl
[13:24:22.433]                         restarts <- computeRestarts(cond)
[13:24:22.433]                         for (restart in restarts) {
[13:24:22.433]                           name <- restart$name
[13:24:22.433]                           if (is.null(name)) 
[13:24:22.433]                             next
[13:24:22.433]                           if (!grepl(pattern, name)) 
[13:24:22.433]                             next
[13:24:22.433]                           invokeRestart(restart)
[13:24:22.433]                           muffled <- TRUE
[13:24:22.433]                           break
[13:24:22.433]                         }
[13:24:22.433]                       }
[13:24:22.433]                     }
[13:24:22.433]                     invisible(muffled)
[13:24:22.433]                   }
[13:24:22.433]                   muffleCondition(cond)
[13:24:22.433]                 })
[13:24:22.433]             }))
[13:24:22.433]             future::FutureResult(value = ...future.value$value, 
[13:24:22.433]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.433]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.433]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.433]                     ...future.globalenv.names))
[13:24:22.433]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.433]         }, condition = base::local({
[13:24:22.433]             c <- base::c
[13:24:22.433]             inherits <- base::inherits
[13:24:22.433]             invokeRestart <- base::invokeRestart
[13:24:22.433]             length <- base::length
[13:24:22.433]             list <- base::list
[13:24:22.433]             seq.int <- base::seq.int
[13:24:22.433]             signalCondition <- base::signalCondition
[13:24:22.433]             sys.calls <- base::sys.calls
[13:24:22.433]             `[[` <- base::`[[`
[13:24:22.433]             `+` <- base::`+`
[13:24:22.433]             `<<-` <- base::`<<-`
[13:24:22.433]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.433]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.433]                   3L)]
[13:24:22.433]             }
[13:24:22.433]             function(cond) {
[13:24:22.433]                 is_error <- inherits(cond, "error")
[13:24:22.433]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.433]                   NULL)
[13:24:22.433]                 if (is_error) {
[13:24:22.433]                   sessionInformation <- function() {
[13:24:22.433]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.433]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.433]                       search = base::search(), system = base::Sys.info())
[13:24:22.433]                   }
[13:24:22.433]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.433]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.433]                     cond$call), session = sessionInformation(), 
[13:24:22.433]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.433]                   signalCondition(cond)
[13:24:22.433]                 }
[13:24:22.433]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.433]                 "immediateCondition"))) {
[13:24:22.433]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.433]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.433]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.433]                   if (TRUE && !signal) {
[13:24:22.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.433]                     {
[13:24:22.433]                       inherits <- base::inherits
[13:24:22.433]                       invokeRestart <- base::invokeRestart
[13:24:22.433]                       is.null <- base::is.null
[13:24:22.433]                       muffled <- FALSE
[13:24:22.433]                       if (inherits(cond, "message")) {
[13:24:22.433]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.433]                         if (muffled) 
[13:24:22.433]                           invokeRestart("muffleMessage")
[13:24:22.433]                       }
[13:24:22.433]                       else if (inherits(cond, "warning")) {
[13:24:22.433]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.433]                         if (muffled) 
[13:24:22.433]                           invokeRestart("muffleWarning")
[13:24:22.433]                       }
[13:24:22.433]                       else if (inherits(cond, "condition")) {
[13:24:22.433]                         if (!is.null(pattern)) {
[13:24:22.433]                           computeRestarts <- base::computeRestarts
[13:24:22.433]                           grepl <- base::grepl
[13:24:22.433]                           restarts <- computeRestarts(cond)
[13:24:22.433]                           for (restart in restarts) {
[13:24:22.433]                             name <- restart$name
[13:24:22.433]                             if (is.null(name)) 
[13:24:22.433]                               next
[13:24:22.433]                             if (!grepl(pattern, name)) 
[13:24:22.433]                               next
[13:24:22.433]                             invokeRestart(restart)
[13:24:22.433]                             muffled <- TRUE
[13:24:22.433]                             break
[13:24:22.433]                           }
[13:24:22.433]                         }
[13:24:22.433]                       }
[13:24:22.433]                       invisible(muffled)
[13:24:22.433]                     }
[13:24:22.433]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.433]                   }
[13:24:22.433]                 }
[13:24:22.433]                 else {
[13:24:22.433]                   if (TRUE) {
[13:24:22.433]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.433]                     {
[13:24:22.433]                       inherits <- base::inherits
[13:24:22.433]                       invokeRestart <- base::invokeRestart
[13:24:22.433]                       is.null <- base::is.null
[13:24:22.433]                       muffled <- FALSE
[13:24:22.433]                       if (inherits(cond, "message")) {
[13:24:22.433]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.433]                         if (muffled) 
[13:24:22.433]                           invokeRestart("muffleMessage")
[13:24:22.433]                       }
[13:24:22.433]                       else if (inherits(cond, "warning")) {
[13:24:22.433]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.433]                         if (muffled) 
[13:24:22.433]                           invokeRestart("muffleWarning")
[13:24:22.433]                       }
[13:24:22.433]                       else if (inherits(cond, "condition")) {
[13:24:22.433]                         if (!is.null(pattern)) {
[13:24:22.433]                           computeRestarts <- base::computeRestarts
[13:24:22.433]                           grepl <- base::grepl
[13:24:22.433]                           restarts <- computeRestarts(cond)
[13:24:22.433]                           for (restart in restarts) {
[13:24:22.433]                             name <- restart$name
[13:24:22.433]                             if (is.null(name)) 
[13:24:22.433]                               next
[13:24:22.433]                             if (!grepl(pattern, name)) 
[13:24:22.433]                               next
[13:24:22.433]                             invokeRestart(restart)
[13:24:22.433]                             muffled <- TRUE
[13:24:22.433]                             break
[13:24:22.433]                           }
[13:24:22.433]                         }
[13:24:22.433]                       }
[13:24:22.433]                       invisible(muffled)
[13:24:22.433]                     }
[13:24:22.433]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.433]                   }
[13:24:22.433]                 }
[13:24:22.433]             }
[13:24:22.433]         }))
[13:24:22.433]     }, error = function(ex) {
[13:24:22.433]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.433]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.433]                 ...future.rng), started = ...future.startTime, 
[13:24:22.433]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.433]             version = "1.8"), class = "FutureResult")
[13:24:22.433]     }, finally = {
[13:24:22.433]         if (!identical(...future.workdir, getwd())) 
[13:24:22.433]             setwd(...future.workdir)
[13:24:22.433]         {
[13:24:22.433]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.433]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.433]             }
[13:24:22.433]             base::options(...future.oldOptions)
[13:24:22.433]             if (.Platform$OS.type == "windows") {
[13:24:22.433]                 old_names <- names(...future.oldEnvVars)
[13:24:22.433]                 envs <- base::Sys.getenv()
[13:24:22.433]                 names <- names(envs)
[13:24:22.433]                 common <- intersect(names, old_names)
[13:24:22.433]                 added <- setdiff(names, old_names)
[13:24:22.433]                 removed <- setdiff(old_names, names)
[13:24:22.433]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.433]                   envs[common]]
[13:24:22.433]                 NAMES <- toupper(changed)
[13:24:22.433]                 args <- list()
[13:24:22.433]                 for (kk in seq_along(NAMES)) {
[13:24:22.433]                   name <- changed[[kk]]
[13:24:22.433]                   NAME <- NAMES[[kk]]
[13:24:22.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.433]                     next
[13:24:22.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.433]                 }
[13:24:22.433]                 NAMES <- toupper(added)
[13:24:22.433]                 for (kk in seq_along(NAMES)) {
[13:24:22.433]                   name <- added[[kk]]
[13:24:22.433]                   NAME <- NAMES[[kk]]
[13:24:22.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.433]                     next
[13:24:22.433]                   args[[name]] <- ""
[13:24:22.433]                 }
[13:24:22.433]                 NAMES <- toupper(removed)
[13:24:22.433]                 for (kk in seq_along(NAMES)) {
[13:24:22.433]                   name <- removed[[kk]]
[13:24:22.433]                   NAME <- NAMES[[kk]]
[13:24:22.433]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.433]                     next
[13:24:22.433]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.433]                 }
[13:24:22.433]                 if (length(args) > 0) 
[13:24:22.433]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.433]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.433]             }
[13:24:22.433]             else {
[13:24:22.433]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.433]             }
[13:24:22.433]             {
[13:24:22.433]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.433]                   0L) {
[13:24:22.433]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.433]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.433]                   base::options(opts)
[13:24:22.433]                 }
[13:24:22.433]                 {
[13:24:22.433]                   {
[13:24:22.433]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.433]                     NULL
[13:24:22.433]                   }
[13:24:22.433]                   options(future.plan = NULL)
[13:24:22.433]                   if (is.na(NA_character_)) 
[13:24:22.433]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.433]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.433]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.433]                     envir = parent.frame()) 
[13:24:22.433]                   {
[13:24:22.433]                     default_workers <- missing(workers)
[13:24:22.433]                     if (is.function(workers)) 
[13:24:22.433]                       workers <- workers()
[13:24:22.433]                     workers <- structure(as.integer(workers), 
[13:24:22.433]                       class = class(workers))
[13:24:22.433]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.433]                       1L)
[13:24:22.433]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.433]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.433]                       if (default_workers) 
[13:24:22.433]                         supportsMulticore(warn = TRUE)
[13:24:22.433]                       return(sequential(..., envir = envir))
[13:24:22.433]                     }
[13:24:22.433]                     oopts <- options(mc.cores = workers)
[13:24:22.433]                     on.exit(options(oopts))
[13:24:22.433]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.433]                       envir = envir)
[13:24:22.433]                     if (!future$lazy) 
[13:24:22.433]                       future <- run(future)
[13:24:22.433]                     invisible(future)
[13:24:22.433]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.433]                 }
[13:24:22.433]             }
[13:24:22.433]         }
[13:24:22.433]     })
[13:24:22.433]     if (TRUE) {
[13:24:22.433]         base::sink(type = "output", split = FALSE)
[13:24:22.433]         if (TRUE) {
[13:24:22.433]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.433]         }
[13:24:22.433]         else {
[13:24:22.433]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.433]         }
[13:24:22.433]         base::close(...future.stdout)
[13:24:22.433]         ...future.stdout <- NULL
[13:24:22.433]     }
[13:24:22.433]     ...future.result$conditions <- ...future.conditions
[13:24:22.433]     ...future.result$finished <- base::Sys.time()
[13:24:22.433]     ...future.result
[13:24:22.433] }
[13:24:22.436] requestCore(): workers = 2
[13:24:22.439] MulticoreFuture started
[13:24:22.439] - Launch lazy future ... done
[13:24:22.440] run() for ‘MulticoreFuture’ ... done
[13:24:22.440] plan(): Setting new future strategy stack:
[13:24:22.440] getGlobalsAndPackages() ...
[13:24:22.440] Searching for globals...
[13:24:22.440] List of future strategies:
[13:24:22.440] 1. sequential:
[13:24:22.440]    - args: function (..., envir = parent.frame())
[13:24:22.440]    - tweaked: FALSE
[13:24:22.440]    - call: NULL
[13:24:22.441] plan(): nbrOfWorkers() = 1
[13:24:22.441] 
[13:24:22.442] Searching for globals ... DONE
[13:24:22.442] - globals: [0] <none>
[13:24:22.442] getGlobalsAndPackages() ... DONE
[13:24:22.443] run() for ‘Future’ ...
[13:24:22.443] plan(): Setting new future strategy stack:
[13:24:22.443] - state: ‘created’
[13:24:22.443] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.443] List of future strategies:
[13:24:22.443] 1. multicore:
[13:24:22.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.443]    - tweaked: FALSE
[13:24:22.443]    - call: plan(strategy)
[13:24:22.448] plan(): nbrOfWorkers() = 2
[13:24:22.448] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.449] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.449]   - Field: ‘label’
[13:24:22.449]   - Field: ‘local’
[13:24:22.449]   - Field: ‘owner’
[13:24:22.449]   - Field: ‘envir’
[13:24:22.449]   - Field: ‘workers’
[13:24:22.450]   - Field: ‘packages’
[13:24:22.450]   - Field: ‘gc’
[13:24:22.450]   - Field: ‘job’
[13:24:22.450]   - Field: ‘conditions’
[13:24:22.450]   - Field: ‘expr’
[13:24:22.450]   - Field: ‘uuid’
[13:24:22.450]   - Field: ‘seed’
[13:24:22.451]   - Field: ‘version’
[13:24:22.451]   - Field: ‘result’
[13:24:22.451]   - Field: ‘asynchronous’
[13:24:22.451]   - Field: ‘calls’
[13:24:22.451]   - Field: ‘globals’
[13:24:22.451]   - Field: ‘stdout’
[13:24:22.452]   - Field: ‘earlySignal’
[13:24:22.452]   - Field: ‘lazy’
[13:24:22.452]   - Field: ‘state’
[13:24:22.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.452] - Launch lazy future ...
[13:24:22.453] Packages needed by the future expression (n = 0): <none>
[13:24:22.453] Packages needed by future strategies (n = 0): <none>
[13:24:22.454] {
[13:24:22.454]     {
[13:24:22.454]         {
[13:24:22.454]             ...future.startTime <- base::Sys.time()
[13:24:22.454]             {
[13:24:22.454]                 {
[13:24:22.454]                   {
[13:24:22.454]                     {
[13:24:22.454]                       base::local({
[13:24:22.454]                         has_future <- base::requireNamespace("future", 
[13:24:22.454]                           quietly = TRUE)
[13:24:22.454]                         if (has_future) {
[13:24:22.454]                           ns <- base::getNamespace("future")
[13:24:22.454]                           version <- ns[[".package"]][["version"]]
[13:24:22.454]                           if (is.null(version)) 
[13:24:22.454]                             version <- utils::packageVersion("future")
[13:24:22.454]                         }
[13:24:22.454]                         else {
[13:24:22.454]                           version <- NULL
[13:24:22.454]                         }
[13:24:22.454]                         if (!has_future || version < "1.8.0") {
[13:24:22.454]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.454]                             "", base::R.version$version.string), 
[13:24:22.454]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.454]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.454]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.454]                               "release", "version")], collapse = " "), 
[13:24:22.454]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.454]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.454]                             info)
[13:24:22.454]                           info <- base::paste(info, collapse = "; ")
[13:24:22.454]                           if (!has_future) {
[13:24:22.454]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.454]                               info)
[13:24:22.454]                           }
[13:24:22.454]                           else {
[13:24:22.454]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.454]                               info, version)
[13:24:22.454]                           }
[13:24:22.454]                           base::stop(msg)
[13:24:22.454]                         }
[13:24:22.454]                       })
[13:24:22.454]                     }
[13:24:22.454]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.454]                     base::options(mc.cores = 1L)
[13:24:22.454]                   }
[13:24:22.454]                   options(future.plan = NULL)
[13:24:22.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.454]                 }
[13:24:22.454]                 ...future.workdir <- getwd()
[13:24:22.454]             }
[13:24:22.454]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.454]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.454]         }
[13:24:22.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.454]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.454]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.454]             base::names(...future.oldOptions))
[13:24:22.454]     }
[13:24:22.454]     if (FALSE) {
[13:24:22.454]     }
[13:24:22.454]     else {
[13:24:22.454]         if (TRUE) {
[13:24:22.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.454]                 open = "w")
[13:24:22.454]         }
[13:24:22.454]         else {
[13:24:22.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.454]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.454]         }
[13:24:22.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.454]             base::sink(type = "output", split = FALSE)
[13:24:22.454]             base::close(...future.stdout)
[13:24:22.454]         }, add = TRUE)
[13:24:22.454]     }
[13:24:22.454]     ...future.frame <- base::sys.nframe()
[13:24:22.454]     ...future.conditions <- base::list()
[13:24:22.454]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.454]     if (FALSE) {
[13:24:22.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.454]     }
[13:24:22.454]     ...future.result <- base::tryCatch({
[13:24:22.454]         base::withCallingHandlers({
[13:24:22.454]             ...future.value <- base::withVisible(base::local({
[13:24:22.454]                 withCallingHandlers({
[13:24:22.454]                   2
[13:24:22.454]                 }, immediateCondition = function(cond) {
[13:24:22.454]                   save_rds <- function (object, pathname, ...) 
[13:24:22.454]                   {
[13:24:22.454]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.454]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.454]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.454]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.454]                         fi_tmp[["mtime"]])
[13:24:22.454]                     }
[13:24:22.454]                     tryCatch({
[13:24:22.454]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.454]                     }, error = function(ex) {
[13:24:22.454]                       msg <- conditionMessage(ex)
[13:24:22.454]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.454]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.454]                         fi_tmp[["mtime"]], msg)
[13:24:22.454]                       ex$message <- msg
[13:24:22.454]                       stop(ex)
[13:24:22.454]                     })
[13:24:22.454]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.454]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.454]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.454]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.454]                       fi <- file.info(pathname)
[13:24:22.454]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.454]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.454]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.454]                         fi[["size"]], fi[["mtime"]])
[13:24:22.454]                       stop(msg)
[13:24:22.454]                     }
[13:24:22.454]                     invisible(pathname)
[13:24:22.454]                   }
[13:24:22.454]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.454]                     rootPath = tempdir()) 
[13:24:22.454]                   {
[13:24:22.454]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.454]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.454]                       tmpdir = path, fileext = ".rds")
[13:24:22.454]                     save_rds(obj, file)
[13:24:22.454]                   }
[13:24:22.454]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.454]                   {
[13:24:22.454]                     inherits <- base::inherits
[13:24:22.454]                     invokeRestart <- base::invokeRestart
[13:24:22.454]                     is.null <- base::is.null
[13:24:22.454]                     muffled <- FALSE
[13:24:22.454]                     if (inherits(cond, "message")) {
[13:24:22.454]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.454]                       if (muffled) 
[13:24:22.454]                         invokeRestart("muffleMessage")
[13:24:22.454]                     }
[13:24:22.454]                     else if (inherits(cond, "warning")) {
[13:24:22.454]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.454]                       if (muffled) 
[13:24:22.454]                         invokeRestart("muffleWarning")
[13:24:22.454]                     }
[13:24:22.454]                     else if (inherits(cond, "condition")) {
[13:24:22.454]                       if (!is.null(pattern)) {
[13:24:22.454]                         computeRestarts <- base::computeRestarts
[13:24:22.454]                         grepl <- base::grepl
[13:24:22.454]                         restarts <- computeRestarts(cond)
[13:24:22.454]                         for (restart in restarts) {
[13:24:22.454]                           name <- restart$name
[13:24:22.454]                           if (is.null(name)) 
[13:24:22.454]                             next
[13:24:22.454]                           if (!grepl(pattern, name)) 
[13:24:22.454]                             next
[13:24:22.454]                           invokeRestart(restart)
[13:24:22.454]                           muffled <- TRUE
[13:24:22.454]                           break
[13:24:22.454]                         }
[13:24:22.454]                       }
[13:24:22.454]                     }
[13:24:22.454]                     invisible(muffled)
[13:24:22.454]                   }
[13:24:22.454]                   muffleCondition(cond)
[13:24:22.454]                 })
[13:24:22.454]             }))
[13:24:22.454]             future::FutureResult(value = ...future.value$value, 
[13:24:22.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.454]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.454]                     ...future.globalenv.names))
[13:24:22.454]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.454]         }, condition = base::local({
[13:24:22.454]             c <- base::c
[13:24:22.454]             inherits <- base::inherits
[13:24:22.454]             invokeRestart <- base::invokeRestart
[13:24:22.454]             length <- base::length
[13:24:22.454]             list <- base::list
[13:24:22.454]             seq.int <- base::seq.int
[13:24:22.454]             signalCondition <- base::signalCondition
[13:24:22.454]             sys.calls <- base::sys.calls
[13:24:22.454]             `[[` <- base::`[[`
[13:24:22.454]             `+` <- base::`+`
[13:24:22.454]             `<<-` <- base::`<<-`
[13:24:22.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.454]                   3L)]
[13:24:22.454]             }
[13:24:22.454]             function(cond) {
[13:24:22.454]                 is_error <- inherits(cond, "error")
[13:24:22.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.454]                   NULL)
[13:24:22.454]                 if (is_error) {
[13:24:22.454]                   sessionInformation <- function() {
[13:24:22.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.454]                       search = base::search(), system = base::Sys.info())
[13:24:22.454]                   }
[13:24:22.454]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.454]                     cond$call), session = sessionInformation(), 
[13:24:22.454]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.454]                   signalCondition(cond)
[13:24:22.454]                 }
[13:24:22.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.454]                 "immediateCondition"))) {
[13:24:22.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.454]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.454]                   if (TRUE && !signal) {
[13:24:22.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.454]                     {
[13:24:22.454]                       inherits <- base::inherits
[13:24:22.454]                       invokeRestart <- base::invokeRestart
[13:24:22.454]                       is.null <- base::is.null
[13:24:22.454]                       muffled <- FALSE
[13:24:22.454]                       if (inherits(cond, "message")) {
[13:24:22.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.454]                         if (muffled) 
[13:24:22.454]                           invokeRestart("muffleMessage")
[13:24:22.454]                       }
[13:24:22.454]                       else if (inherits(cond, "warning")) {
[13:24:22.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.454]                         if (muffled) 
[13:24:22.454]                           invokeRestart("muffleWarning")
[13:24:22.454]                       }
[13:24:22.454]                       else if (inherits(cond, "condition")) {
[13:24:22.454]                         if (!is.null(pattern)) {
[13:24:22.454]                           computeRestarts <- base::computeRestarts
[13:24:22.454]                           grepl <- base::grepl
[13:24:22.454]                           restarts <- computeRestarts(cond)
[13:24:22.454]                           for (restart in restarts) {
[13:24:22.454]                             name <- restart$name
[13:24:22.454]                             if (is.null(name)) 
[13:24:22.454]                               next
[13:24:22.454]                             if (!grepl(pattern, name)) 
[13:24:22.454]                               next
[13:24:22.454]                             invokeRestart(restart)
[13:24:22.454]                             muffled <- TRUE
[13:24:22.454]                             break
[13:24:22.454]                           }
[13:24:22.454]                         }
[13:24:22.454]                       }
[13:24:22.454]                       invisible(muffled)
[13:24:22.454]                     }
[13:24:22.454]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.454]                   }
[13:24:22.454]                 }
[13:24:22.454]                 else {
[13:24:22.454]                   if (TRUE) {
[13:24:22.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.454]                     {
[13:24:22.454]                       inherits <- base::inherits
[13:24:22.454]                       invokeRestart <- base::invokeRestart
[13:24:22.454]                       is.null <- base::is.null
[13:24:22.454]                       muffled <- FALSE
[13:24:22.454]                       if (inherits(cond, "message")) {
[13:24:22.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.454]                         if (muffled) 
[13:24:22.454]                           invokeRestart("muffleMessage")
[13:24:22.454]                       }
[13:24:22.454]                       else if (inherits(cond, "warning")) {
[13:24:22.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.454]                         if (muffled) 
[13:24:22.454]                           invokeRestart("muffleWarning")
[13:24:22.454]                       }
[13:24:22.454]                       else if (inherits(cond, "condition")) {
[13:24:22.454]                         if (!is.null(pattern)) {
[13:24:22.454]                           computeRestarts <- base::computeRestarts
[13:24:22.454]                           grepl <- base::grepl
[13:24:22.454]                           restarts <- computeRestarts(cond)
[13:24:22.454]                           for (restart in restarts) {
[13:24:22.454]                             name <- restart$name
[13:24:22.454]                             if (is.null(name)) 
[13:24:22.454]                               next
[13:24:22.454]                             if (!grepl(pattern, name)) 
[13:24:22.454]                               next
[13:24:22.454]                             invokeRestart(restart)
[13:24:22.454]                             muffled <- TRUE
[13:24:22.454]                             break
[13:24:22.454]                           }
[13:24:22.454]                         }
[13:24:22.454]                       }
[13:24:22.454]                       invisible(muffled)
[13:24:22.454]                     }
[13:24:22.454]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.454]                   }
[13:24:22.454]                 }
[13:24:22.454]             }
[13:24:22.454]         }))
[13:24:22.454]     }, error = function(ex) {
[13:24:22.454]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.454]                 ...future.rng), started = ...future.startTime, 
[13:24:22.454]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.454]             version = "1.8"), class = "FutureResult")
[13:24:22.454]     }, finally = {
[13:24:22.454]         if (!identical(...future.workdir, getwd())) 
[13:24:22.454]             setwd(...future.workdir)
[13:24:22.454]         {
[13:24:22.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.454]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.454]             }
[13:24:22.454]             base::options(...future.oldOptions)
[13:24:22.454]             if (.Platform$OS.type == "windows") {
[13:24:22.454]                 old_names <- names(...future.oldEnvVars)
[13:24:22.454]                 envs <- base::Sys.getenv()
[13:24:22.454]                 names <- names(envs)
[13:24:22.454]                 common <- intersect(names, old_names)
[13:24:22.454]                 added <- setdiff(names, old_names)
[13:24:22.454]                 removed <- setdiff(old_names, names)
[13:24:22.454]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.454]                   envs[common]]
[13:24:22.454]                 NAMES <- toupper(changed)
[13:24:22.454]                 args <- list()
[13:24:22.454]                 for (kk in seq_along(NAMES)) {
[13:24:22.454]                   name <- changed[[kk]]
[13:24:22.454]                   NAME <- NAMES[[kk]]
[13:24:22.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.454]                     next
[13:24:22.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.454]                 }
[13:24:22.454]                 NAMES <- toupper(added)
[13:24:22.454]                 for (kk in seq_along(NAMES)) {
[13:24:22.454]                   name <- added[[kk]]
[13:24:22.454]                   NAME <- NAMES[[kk]]
[13:24:22.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.454]                     next
[13:24:22.454]                   args[[name]] <- ""
[13:24:22.454]                 }
[13:24:22.454]                 NAMES <- toupper(removed)
[13:24:22.454]                 for (kk in seq_along(NAMES)) {
[13:24:22.454]                   name <- removed[[kk]]
[13:24:22.454]                   NAME <- NAMES[[kk]]
[13:24:22.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.454]                     next
[13:24:22.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.454]                 }
[13:24:22.454]                 if (length(args) > 0) 
[13:24:22.454]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.454]             }
[13:24:22.454]             else {
[13:24:22.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.454]             }
[13:24:22.454]             {
[13:24:22.454]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.454]                   0L) {
[13:24:22.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.454]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.454]                   base::options(opts)
[13:24:22.454]                 }
[13:24:22.454]                 {
[13:24:22.454]                   {
[13:24:22.454]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.454]                     NULL
[13:24:22.454]                   }
[13:24:22.454]                   options(future.plan = NULL)
[13:24:22.454]                   if (is.na(NA_character_)) 
[13:24:22.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.454]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.454]                     envir = parent.frame()) 
[13:24:22.454]                   {
[13:24:22.454]                     default_workers <- missing(workers)
[13:24:22.454]                     if (is.function(workers)) 
[13:24:22.454]                       workers <- workers()
[13:24:22.454]                     workers <- structure(as.integer(workers), 
[13:24:22.454]                       class = class(workers))
[13:24:22.454]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.454]                       1L)
[13:24:22.454]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.454]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.454]                       if (default_workers) 
[13:24:22.454]                         supportsMulticore(warn = TRUE)
[13:24:22.454]                       return(sequential(..., envir = envir))
[13:24:22.454]                     }
[13:24:22.454]                     oopts <- options(mc.cores = workers)
[13:24:22.454]                     on.exit(options(oopts))
[13:24:22.454]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.454]                       envir = envir)
[13:24:22.454]                     if (!future$lazy) 
[13:24:22.454]                       future <- run(future)
[13:24:22.454]                     invisible(future)
[13:24:22.454]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.454]                 }
[13:24:22.454]             }
[13:24:22.454]         }
[13:24:22.454]     })
[13:24:22.454]     if (TRUE) {
[13:24:22.454]         base::sink(type = "output", split = FALSE)
[13:24:22.454]         if (TRUE) {
[13:24:22.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.454]         }
[13:24:22.454]         else {
[13:24:22.454]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.454]         }
[13:24:22.454]         base::close(...future.stdout)
[13:24:22.454]         ...future.stdout <- NULL
[13:24:22.454]     }
[13:24:22.454]     ...future.result$conditions <- ...future.conditions
[13:24:22.454]     ...future.result$finished <- base::Sys.time()
[13:24:22.454]     ...future.result
[13:24:22.454] }
[13:24:22.457] requestCore(): workers = 2
[13:24:22.463] MulticoreFuture started
[13:24:22.463] - Launch lazy future ... done
[13:24:22.464] run() for ‘MulticoreFuture’ ... done
[13:24:22.464] resolve() on list ...
[13:24:22.464]  recursive: 0
[13:24:22.464]  length: 3
[13:24:22.464] plan(): Setting new future strategy stack:
[13:24:22.465]  elements: ‘a’, ‘b’, ‘’
[13:24:22.465] List of future strategies:
[13:24:22.465] 1. sequential:
[13:24:22.465]    - args: function (..., envir = parent.frame())
[13:24:22.465]    - tweaked: FALSE
[13:24:22.465]    - call: NULL
[13:24:22.465] plan(): nbrOfWorkers() = 1
[13:24:22.467] Future #1
[13:24:22.467]  length: 2 (resolved future 1)
[13:24:22.468] plan(): Setting new future strategy stack:
[13:24:22.468] List of future strategies:
[13:24:22.468] 1. multicore:
[13:24:22.468]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.468]    - tweaked: FALSE
[13:24:22.468]    - call: plan(strategy)
[13:24:22.473] plan(): nbrOfWorkers() = 2
[13:24:22.473] Future #2
[13:24:22.473]  length: 1 (resolved future 2)
[13:24:22.473]  length: 0 (resolved future 3)
[13:24:22.474] resolve() on list ... DONE
[13:24:22.474] getGlobalsAndPackages() ...
[13:24:22.474] Searching for globals...
[13:24:22.475] 
[13:24:22.475] Searching for globals ... DONE
[13:24:22.475] - globals: [0] <none>
[13:24:22.475] getGlobalsAndPackages() ... DONE
[13:24:22.476] getGlobalsAndPackages() ...
[13:24:22.476] Searching for globals...
[13:24:22.477] 
[13:24:22.477] Searching for globals ... DONE
[13:24:22.477] - globals: [0] <none>
[13:24:22.477] getGlobalsAndPackages() ... DONE
[13:24:22.477] run() for ‘Future’ ...
[13:24:22.477] - state: ‘created’
[13:24:22.478] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.483] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.483] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.483]   - Field: ‘label’
[13:24:22.483]   - Field: ‘local’
[13:24:22.484]   - Field: ‘owner’
[13:24:22.488]   - Field: ‘envir’
[13:24:22.488]   - Field: ‘workers’
[13:24:22.489]   - Field: ‘packages’
[13:24:22.489]   - Field: ‘gc’
[13:24:22.489]   - Field: ‘job’
[13:24:22.489]   - Field: ‘conditions’
[13:24:22.490]   - Field: ‘expr’
[13:24:22.490]   - Field: ‘uuid’
[13:24:22.490]   - Field: ‘seed’
[13:24:22.491]   - Field: ‘version’
[13:24:22.491]   - Field: ‘result’
[13:24:22.491]   - Field: ‘asynchronous’
[13:24:22.491]   - Field: ‘calls’
[13:24:22.492]   - Field: ‘globals’
[13:24:22.492]   - Field: ‘stdout’
[13:24:22.492]   - Field: ‘earlySignal’
[13:24:22.492]   - Field: ‘lazy’
[13:24:22.492]   - Field: ‘state’
[13:24:22.493] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.493] - Launch lazy future ...
[13:24:22.493] Packages needed by the future expression (n = 0): <none>
[13:24:22.493] Packages needed by future strategies (n = 0): <none>
[13:24:22.494] {
[13:24:22.494]     {
[13:24:22.494]         {
[13:24:22.494]             ...future.startTime <- base::Sys.time()
[13:24:22.494]             {
[13:24:22.494]                 {
[13:24:22.494]                   {
[13:24:22.494]                     {
[13:24:22.494]                       base::local({
[13:24:22.494]                         has_future <- base::requireNamespace("future", 
[13:24:22.494]                           quietly = TRUE)
[13:24:22.494]                         if (has_future) {
[13:24:22.494]                           ns <- base::getNamespace("future")
[13:24:22.494]                           version <- ns[[".package"]][["version"]]
[13:24:22.494]                           if (is.null(version)) 
[13:24:22.494]                             version <- utils::packageVersion("future")
[13:24:22.494]                         }
[13:24:22.494]                         else {
[13:24:22.494]                           version <- NULL
[13:24:22.494]                         }
[13:24:22.494]                         if (!has_future || version < "1.8.0") {
[13:24:22.494]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.494]                             "", base::R.version$version.string), 
[13:24:22.494]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.494]                               "release", "version")], collapse = " "), 
[13:24:22.494]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.494]                             info)
[13:24:22.494]                           info <- base::paste(info, collapse = "; ")
[13:24:22.494]                           if (!has_future) {
[13:24:22.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.494]                               info)
[13:24:22.494]                           }
[13:24:22.494]                           else {
[13:24:22.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.494]                               info, version)
[13:24:22.494]                           }
[13:24:22.494]                           base::stop(msg)
[13:24:22.494]                         }
[13:24:22.494]                       })
[13:24:22.494]                     }
[13:24:22.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.494]                     base::options(mc.cores = 1L)
[13:24:22.494]                   }
[13:24:22.494]                   options(future.plan = NULL)
[13:24:22.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.494]                 }
[13:24:22.494]                 ...future.workdir <- getwd()
[13:24:22.494]             }
[13:24:22.494]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.494]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.494]         }
[13:24:22.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.494]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.494]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.494]             base::names(...future.oldOptions))
[13:24:22.494]     }
[13:24:22.494]     if (FALSE) {
[13:24:22.494]     }
[13:24:22.494]     else {
[13:24:22.494]         if (TRUE) {
[13:24:22.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.494]                 open = "w")
[13:24:22.494]         }
[13:24:22.494]         else {
[13:24:22.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.494]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.494]         }
[13:24:22.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.494]             base::sink(type = "output", split = FALSE)
[13:24:22.494]             base::close(...future.stdout)
[13:24:22.494]         }, add = TRUE)
[13:24:22.494]     }
[13:24:22.494]     ...future.frame <- base::sys.nframe()
[13:24:22.494]     ...future.conditions <- base::list()
[13:24:22.494]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.494]     if (FALSE) {
[13:24:22.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.494]     }
[13:24:22.494]     ...future.result <- base::tryCatch({
[13:24:22.494]         base::withCallingHandlers({
[13:24:22.494]             ...future.value <- base::withVisible(base::local({
[13:24:22.494]                 withCallingHandlers({
[13:24:22.494]                   2
[13:24:22.494]                 }, immediateCondition = function(cond) {
[13:24:22.494]                   save_rds <- function (object, pathname, ...) 
[13:24:22.494]                   {
[13:24:22.494]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.494]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.494]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.494]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.494]                         fi_tmp[["mtime"]])
[13:24:22.494]                     }
[13:24:22.494]                     tryCatch({
[13:24:22.494]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.494]                     }, error = function(ex) {
[13:24:22.494]                       msg <- conditionMessage(ex)
[13:24:22.494]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.494]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.494]                         fi_tmp[["mtime"]], msg)
[13:24:22.494]                       ex$message <- msg
[13:24:22.494]                       stop(ex)
[13:24:22.494]                     })
[13:24:22.494]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.494]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.494]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.494]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.494]                       fi <- file.info(pathname)
[13:24:22.494]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.494]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.494]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.494]                         fi[["size"]], fi[["mtime"]])
[13:24:22.494]                       stop(msg)
[13:24:22.494]                     }
[13:24:22.494]                     invisible(pathname)
[13:24:22.494]                   }
[13:24:22.494]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.494]                     rootPath = tempdir()) 
[13:24:22.494]                   {
[13:24:22.494]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.494]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.494]                       tmpdir = path, fileext = ".rds")
[13:24:22.494]                     save_rds(obj, file)
[13:24:22.494]                   }
[13:24:22.494]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.494]                   {
[13:24:22.494]                     inherits <- base::inherits
[13:24:22.494]                     invokeRestart <- base::invokeRestart
[13:24:22.494]                     is.null <- base::is.null
[13:24:22.494]                     muffled <- FALSE
[13:24:22.494]                     if (inherits(cond, "message")) {
[13:24:22.494]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.494]                       if (muffled) 
[13:24:22.494]                         invokeRestart("muffleMessage")
[13:24:22.494]                     }
[13:24:22.494]                     else if (inherits(cond, "warning")) {
[13:24:22.494]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.494]                       if (muffled) 
[13:24:22.494]                         invokeRestart("muffleWarning")
[13:24:22.494]                     }
[13:24:22.494]                     else if (inherits(cond, "condition")) {
[13:24:22.494]                       if (!is.null(pattern)) {
[13:24:22.494]                         computeRestarts <- base::computeRestarts
[13:24:22.494]                         grepl <- base::grepl
[13:24:22.494]                         restarts <- computeRestarts(cond)
[13:24:22.494]                         for (restart in restarts) {
[13:24:22.494]                           name <- restart$name
[13:24:22.494]                           if (is.null(name)) 
[13:24:22.494]                             next
[13:24:22.494]                           if (!grepl(pattern, name)) 
[13:24:22.494]                             next
[13:24:22.494]                           invokeRestart(restart)
[13:24:22.494]                           muffled <- TRUE
[13:24:22.494]                           break
[13:24:22.494]                         }
[13:24:22.494]                       }
[13:24:22.494]                     }
[13:24:22.494]                     invisible(muffled)
[13:24:22.494]                   }
[13:24:22.494]                   muffleCondition(cond)
[13:24:22.494]                 })
[13:24:22.494]             }))
[13:24:22.494]             future::FutureResult(value = ...future.value$value, 
[13:24:22.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.494]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.494]                     ...future.globalenv.names))
[13:24:22.494]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.494]         }, condition = base::local({
[13:24:22.494]             c <- base::c
[13:24:22.494]             inherits <- base::inherits
[13:24:22.494]             invokeRestart <- base::invokeRestart
[13:24:22.494]             length <- base::length
[13:24:22.494]             list <- base::list
[13:24:22.494]             seq.int <- base::seq.int
[13:24:22.494]             signalCondition <- base::signalCondition
[13:24:22.494]             sys.calls <- base::sys.calls
[13:24:22.494]             `[[` <- base::`[[`
[13:24:22.494]             `+` <- base::`+`
[13:24:22.494]             `<<-` <- base::`<<-`
[13:24:22.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.494]                   3L)]
[13:24:22.494]             }
[13:24:22.494]             function(cond) {
[13:24:22.494]                 is_error <- inherits(cond, "error")
[13:24:22.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.494]                   NULL)
[13:24:22.494]                 if (is_error) {
[13:24:22.494]                   sessionInformation <- function() {
[13:24:22.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.494]                       search = base::search(), system = base::Sys.info())
[13:24:22.494]                   }
[13:24:22.494]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.494]                     cond$call), session = sessionInformation(), 
[13:24:22.494]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.494]                   signalCondition(cond)
[13:24:22.494]                 }
[13:24:22.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.494]                 "immediateCondition"))) {
[13:24:22.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.494]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.494]                   if (TRUE && !signal) {
[13:24:22.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.494]                     {
[13:24:22.494]                       inherits <- base::inherits
[13:24:22.494]                       invokeRestart <- base::invokeRestart
[13:24:22.494]                       is.null <- base::is.null
[13:24:22.494]                       muffled <- FALSE
[13:24:22.494]                       if (inherits(cond, "message")) {
[13:24:22.494]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.494]                         if (muffled) 
[13:24:22.494]                           invokeRestart("muffleMessage")
[13:24:22.494]                       }
[13:24:22.494]                       else if (inherits(cond, "warning")) {
[13:24:22.494]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.494]                         if (muffled) 
[13:24:22.494]                           invokeRestart("muffleWarning")
[13:24:22.494]                       }
[13:24:22.494]                       else if (inherits(cond, "condition")) {
[13:24:22.494]                         if (!is.null(pattern)) {
[13:24:22.494]                           computeRestarts <- base::computeRestarts
[13:24:22.494]                           grepl <- base::grepl
[13:24:22.494]                           restarts <- computeRestarts(cond)
[13:24:22.494]                           for (restart in restarts) {
[13:24:22.494]                             name <- restart$name
[13:24:22.494]                             if (is.null(name)) 
[13:24:22.494]                               next
[13:24:22.494]                             if (!grepl(pattern, name)) 
[13:24:22.494]                               next
[13:24:22.494]                             invokeRestart(restart)
[13:24:22.494]                             muffled <- TRUE
[13:24:22.494]                             break
[13:24:22.494]                           }
[13:24:22.494]                         }
[13:24:22.494]                       }
[13:24:22.494]                       invisible(muffled)
[13:24:22.494]                     }
[13:24:22.494]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.494]                   }
[13:24:22.494]                 }
[13:24:22.494]                 else {
[13:24:22.494]                   if (TRUE) {
[13:24:22.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.494]                     {
[13:24:22.494]                       inherits <- base::inherits
[13:24:22.494]                       invokeRestart <- base::invokeRestart
[13:24:22.494]                       is.null <- base::is.null
[13:24:22.494]                       muffled <- FALSE
[13:24:22.494]                       if (inherits(cond, "message")) {
[13:24:22.494]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.494]                         if (muffled) 
[13:24:22.494]                           invokeRestart("muffleMessage")
[13:24:22.494]                       }
[13:24:22.494]                       else if (inherits(cond, "warning")) {
[13:24:22.494]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.494]                         if (muffled) 
[13:24:22.494]                           invokeRestart("muffleWarning")
[13:24:22.494]                       }
[13:24:22.494]                       else if (inherits(cond, "condition")) {
[13:24:22.494]                         if (!is.null(pattern)) {
[13:24:22.494]                           computeRestarts <- base::computeRestarts
[13:24:22.494]                           grepl <- base::grepl
[13:24:22.494]                           restarts <- computeRestarts(cond)
[13:24:22.494]                           for (restart in restarts) {
[13:24:22.494]                             name <- restart$name
[13:24:22.494]                             if (is.null(name)) 
[13:24:22.494]                               next
[13:24:22.494]                             if (!grepl(pattern, name)) 
[13:24:22.494]                               next
[13:24:22.494]                             invokeRestart(restart)
[13:24:22.494]                             muffled <- TRUE
[13:24:22.494]                             break
[13:24:22.494]                           }
[13:24:22.494]                         }
[13:24:22.494]                       }
[13:24:22.494]                       invisible(muffled)
[13:24:22.494]                     }
[13:24:22.494]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.494]                   }
[13:24:22.494]                 }
[13:24:22.494]             }
[13:24:22.494]         }))
[13:24:22.494]     }, error = function(ex) {
[13:24:22.494]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.494]                 ...future.rng), started = ...future.startTime, 
[13:24:22.494]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.494]             version = "1.8"), class = "FutureResult")
[13:24:22.494]     }, finally = {
[13:24:22.494]         if (!identical(...future.workdir, getwd())) 
[13:24:22.494]             setwd(...future.workdir)
[13:24:22.494]         {
[13:24:22.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.494]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.494]             }
[13:24:22.494]             base::options(...future.oldOptions)
[13:24:22.494]             if (.Platform$OS.type == "windows") {
[13:24:22.494]                 old_names <- names(...future.oldEnvVars)
[13:24:22.494]                 envs <- base::Sys.getenv()
[13:24:22.494]                 names <- names(envs)
[13:24:22.494]                 common <- intersect(names, old_names)
[13:24:22.494]                 added <- setdiff(names, old_names)
[13:24:22.494]                 removed <- setdiff(old_names, names)
[13:24:22.494]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.494]                   envs[common]]
[13:24:22.494]                 NAMES <- toupper(changed)
[13:24:22.494]                 args <- list()
[13:24:22.494]                 for (kk in seq_along(NAMES)) {
[13:24:22.494]                   name <- changed[[kk]]
[13:24:22.494]                   NAME <- NAMES[[kk]]
[13:24:22.494]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.494]                     next
[13:24:22.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.494]                 }
[13:24:22.494]                 NAMES <- toupper(added)
[13:24:22.494]                 for (kk in seq_along(NAMES)) {
[13:24:22.494]                   name <- added[[kk]]
[13:24:22.494]                   NAME <- NAMES[[kk]]
[13:24:22.494]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.494]                     next
[13:24:22.494]                   args[[name]] <- ""
[13:24:22.494]                 }
[13:24:22.494]                 NAMES <- toupper(removed)
[13:24:22.494]                 for (kk in seq_along(NAMES)) {
[13:24:22.494]                   name <- removed[[kk]]
[13:24:22.494]                   NAME <- NAMES[[kk]]
[13:24:22.494]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.494]                     next
[13:24:22.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.494]                 }
[13:24:22.494]                 if (length(args) > 0) 
[13:24:22.494]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.494]             }
[13:24:22.494]             else {
[13:24:22.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.494]             }
[13:24:22.494]             {
[13:24:22.494]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.494]                   0L) {
[13:24:22.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.494]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.494]                   base::options(opts)
[13:24:22.494]                 }
[13:24:22.494]                 {
[13:24:22.494]                   {
[13:24:22.494]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.494]                     NULL
[13:24:22.494]                   }
[13:24:22.494]                   options(future.plan = NULL)
[13:24:22.494]                   if (is.na(NA_character_)) 
[13:24:22.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.494]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.494]                     envir = parent.frame()) 
[13:24:22.494]                   {
[13:24:22.494]                     default_workers <- missing(workers)
[13:24:22.494]                     if (is.function(workers)) 
[13:24:22.494]                       workers <- workers()
[13:24:22.494]                     workers <- structure(as.integer(workers), 
[13:24:22.494]                       class = class(workers))
[13:24:22.494]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.494]                       1L)
[13:24:22.494]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.494]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.494]                       if (default_workers) 
[13:24:22.494]                         supportsMulticore(warn = TRUE)
[13:24:22.494]                       return(sequential(..., envir = envir))
[13:24:22.494]                     }
[13:24:22.494]                     oopts <- options(mc.cores = workers)
[13:24:22.494]                     on.exit(options(oopts))
[13:24:22.494]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.494]                       envir = envir)
[13:24:22.494]                     if (!future$lazy) 
[13:24:22.494]                       future <- run(future)
[13:24:22.494]                     invisible(future)
[13:24:22.494]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.494]                 }
[13:24:22.494]             }
[13:24:22.494]         }
[13:24:22.494]     })
[13:24:22.494]     if (TRUE) {
[13:24:22.494]         base::sink(type = "output", split = FALSE)
[13:24:22.494]         if (TRUE) {
[13:24:22.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.494]         }
[13:24:22.494]         else {
[13:24:22.494]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.494]         }
[13:24:22.494]         base::close(...future.stdout)
[13:24:22.494]         ...future.stdout <- NULL
[13:24:22.494]     }
[13:24:22.494]     ...future.result$conditions <- ...future.conditions
[13:24:22.494]     ...future.result$finished <- base::Sys.time()
[13:24:22.494]     ...future.result
[13:24:22.494] }
[13:24:22.497] requestCore(): workers = 2
[13:24:22.498] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:22.509] result() for MulticoreFuture ...
[13:24:22.510] result() for MulticoreFuture ...
[13:24:22.511] result() for MulticoreFuture ... done
[13:24:22.511] result() for MulticoreFuture ... done
[13:24:22.511] result() for MulticoreFuture ...
[13:24:22.511] result() for MulticoreFuture ... done
[13:24:22.514] MulticoreFuture started
[13:24:22.515] - Launch lazy future ... done
[13:24:22.515] run() for ‘MulticoreFuture’ ... done
[13:24:22.515] resolve() on list ...
[13:24:22.515] plan(): Setting new future strategy stack:
[13:24:22.516]  recursive: 0
[13:24:22.516]  length: 3
[13:24:22.516]  elements: ‘a’, ‘b’, ‘’
[13:24:22.516] run() for ‘Future’ ...
[13:24:22.516] List of future strategies:
[13:24:22.516] 1. sequential:
[13:24:22.516]    - args: function (..., envir = parent.frame())
[13:24:22.516]    - tweaked: FALSE
[13:24:22.516]    - call: NULL
[13:24:22.516] - state: ‘created’
[13:24:22.517] plan(): nbrOfWorkers() = 1
[13:24:22.517] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.519] plan(): Setting new future strategy stack:
[13:24:22.519] List of future strategies:
[13:24:22.519] 1. multicore:
[13:24:22.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.519]    - tweaked: FALSE
[13:24:22.519]    - call: plan(strategy)
[13:24:22.522] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.523] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.523]   - Field: ‘label’
[13:24:22.523]   - Field: ‘local’
[13:24:22.523]   - Field: ‘owner’
[13:24:22.523]   - Field: ‘envir’
[13:24:22.523] plan(): nbrOfWorkers() = 2
[13:24:22.524]   - Field: ‘workers’
[13:24:22.524]   - Field: ‘packages’
[13:24:22.524]   - Field: ‘gc’
[13:24:22.524]   - Field: ‘job’
[13:24:22.524]   - Field: ‘conditions’
[13:24:22.524]   - Field: ‘expr’
[13:24:22.525]   - Field: ‘uuid’
[13:24:22.525]   - Field: ‘seed’
[13:24:22.525]   - Field: ‘version’
[13:24:22.525]   - Field: ‘result’
[13:24:22.525]   - Field: ‘asynchronous’
[13:24:22.525]   - Field: ‘calls’
[13:24:22.525]   - Field: ‘globals’
[13:24:22.526]   - Field: ‘stdout’
[13:24:22.526]   - Field: ‘earlySignal’
[13:24:22.526]   - Field: ‘lazy’
[13:24:22.526]   - Field: ‘state’
[13:24:22.526] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.526] - Launch lazy future ...
[13:24:22.527] Packages needed by the future expression (n = 0): <none>
[13:24:22.527] Packages needed by future strategies (n = 0): <none>
[13:24:22.528] {
[13:24:22.528]     {
[13:24:22.528]         {
[13:24:22.528]             ...future.startTime <- base::Sys.time()
[13:24:22.528]             {
[13:24:22.528]                 {
[13:24:22.528]                   {
[13:24:22.528]                     {
[13:24:22.528]                       base::local({
[13:24:22.528]                         has_future <- base::requireNamespace("future", 
[13:24:22.528]                           quietly = TRUE)
[13:24:22.528]                         if (has_future) {
[13:24:22.528]                           ns <- base::getNamespace("future")
[13:24:22.528]                           version <- ns[[".package"]][["version"]]
[13:24:22.528]                           if (is.null(version)) 
[13:24:22.528]                             version <- utils::packageVersion("future")
[13:24:22.528]                         }
[13:24:22.528]                         else {
[13:24:22.528]                           version <- NULL
[13:24:22.528]                         }
[13:24:22.528]                         if (!has_future || version < "1.8.0") {
[13:24:22.528]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.528]                             "", base::R.version$version.string), 
[13:24:22.528]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.528]                               "release", "version")], collapse = " "), 
[13:24:22.528]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.528]                             info)
[13:24:22.528]                           info <- base::paste(info, collapse = "; ")
[13:24:22.528]                           if (!has_future) {
[13:24:22.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.528]                               info)
[13:24:22.528]                           }
[13:24:22.528]                           else {
[13:24:22.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.528]                               info, version)
[13:24:22.528]                           }
[13:24:22.528]                           base::stop(msg)
[13:24:22.528]                         }
[13:24:22.528]                       })
[13:24:22.528]                     }
[13:24:22.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.528]                     base::options(mc.cores = 1L)
[13:24:22.528]                   }
[13:24:22.528]                   options(future.plan = NULL)
[13:24:22.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.528]                 }
[13:24:22.528]                 ...future.workdir <- getwd()
[13:24:22.528]             }
[13:24:22.528]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.528]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.528]         }
[13:24:22.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.528]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.528]             base::names(...future.oldOptions))
[13:24:22.528]     }
[13:24:22.528]     if (FALSE) {
[13:24:22.528]     }
[13:24:22.528]     else {
[13:24:22.528]         if (TRUE) {
[13:24:22.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.528]                 open = "w")
[13:24:22.528]         }
[13:24:22.528]         else {
[13:24:22.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.528]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.528]         }
[13:24:22.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.528]             base::sink(type = "output", split = FALSE)
[13:24:22.528]             base::close(...future.stdout)
[13:24:22.528]         }, add = TRUE)
[13:24:22.528]     }
[13:24:22.528]     ...future.frame <- base::sys.nframe()
[13:24:22.528]     ...future.conditions <- base::list()
[13:24:22.528]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.528]     if (FALSE) {
[13:24:22.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.528]     }
[13:24:22.528]     ...future.result <- base::tryCatch({
[13:24:22.528]         base::withCallingHandlers({
[13:24:22.528]             ...future.value <- base::withVisible(base::local({
[13:24:22.528]                 withCallingHandlers({
[13:24:22.528]                   1
[13:24:22.528]                 }, immediateCondition = function(cond) {
[13:24:22.528]                   save_rds <- function (object, pathname, ...) 
[13:24:22.528]                   {
[13:24:22.528]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.528]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.528]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.528]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.528]                         fi_tmp[["mtime"]])
[13:24:22.528]                     }
[13:24:22.528]                     tryCatch({
[13:24:22.528]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.528]                     }, error = function(ex) {
[13:24:22.528]                       msg <- conditionMessage(ex)
[13:24:22.528]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.528]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.528]                         fi_tmp[["mtime"]], msg)
[13:24:22.528]                       ex$message <- msg
[13:24:22.528]                       stop(ex)
[13:24:22.528]                     })
[13:24:22.528]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.528]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.528]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.528]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.528]                       fi <- file.info(pathname)
[13:24:22.528]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.528]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.528]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.528]                         fi[["size"]], fi[["mtime"]])
[13:24:22.528]                       stop(msg)
[13:24:22.528]                     }
[13:24:22.528]                     invisible(pathname)
[13:24:22.528]                   }
[13:24:22.528]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.528]                     rootPath = tempdir()) 
[13:24:22.528]                   {
[13:24:22.528]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.528]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.528]                       tmpdir = path, fileext = ".rds")
[13:24:22.528]                     save_rds(obj, file)
[13:24:22.528]                   }
[13:24:22.528]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.528]                   {
[13:24:22.528]                     inherits <- base::inherits
[13:24:22.528]                     invokeRestart <- base::invokeRestart
[13:24:22.528]                     is.null <- base::is.null
[13:24:22.528]                     muffled <- FALSE
[13:24:22.528]                     if (inherits(cond, "message")) {
[13:24:22.528]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.528]                       if (muffled) 
[13:24:22.528]                         invokeRestart("muffleMessage")
[13:24:22.528]                     }
[13:24:22.528]                     else if (inherits(cond, "warning")) {
[13:24:22.528]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.528]                       if (muffled) 
[13:24:22.528]                         invokeRestart("muffleWarning")
[13:24:22.528]                     }
[13:24:22.528]                     else if (inherits(cond, "condition")) {
[13:24:22.528]                       if (!is.null(pattern)) {
[13:24:22.528]                         computeRestarts <- base::computeRestarts
[13:24:22.528]                         grepl <- base::grepl
[13:24:22.528]                         restarts <- computeRestarts(cond)
[13:24:22.528]                         for (restart in restarts) {
[13:24:22.528]                           name <- restart$name
[13:24:22.528]                           if (is.null(name)) 
[13:24:22.528]                             next
[13:24:22.528]                           if (!grepl(pattern, name)) 
[13:24:22.528]                             next
[13:24:22.528]                           invokeRestart(restart)
[13:24:22.528]                           muffled <- TRUE
[13:24:22.528]                           break
[13:24:22.528]                         }
[13:24:22.528]                       }
[13:24:22.528]                     }
[13:24:22.528]                     invisible(muffled)
[13:24:22.528]                   }
[13:24:22.528]                   muffleCondition(cond)
[13:24:22.528]                 })
[13:24:22.528]             }))
[13:24:22.528]             future::FutureResult(value = ...future.value$value, 
[13:24:22.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.528]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.528]                     ...future.globalenv.names))
[13:24:22.528]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.528]         }, condition = base::local({
[13:24:22.528]             c <- base::c
[13:24:22.528]             inherits <- base::inherits
[13:24:22.528]             invokeRestart <- base::invokeRestart
[13:24:22.528]             length <- base::length
[13:24:22.528]             list <- base::list
[13:24:22.528]             seq.int <- base::seq.int
[13:24:22.528]             signalCondition <- base::signalCondition
[13:24:22.528]             sys.calls <- base::sys.calls
[13:24:22.528]             `[[` <- base::`[[`
[13:24:22.528]             `+` <- base::`+`
[13:24:22.528]             `<<-` <- base::`<<-`
[13:24:22.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.528]                   3L)]
[13:24:22.528]             }
[13:24:22.528]             function(cond) {
[13:24:22.528]                 is_error <- inherits(cond, "error")
[13:24:22.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.528]                   NULL)
[13:24:22.528]                 if (is_error) {
[13:24:22.528]                   sessionInformation <- function() {
[13:24:22.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.528]                       search = base::search(), system = base::Sys.info())
[13:24:22.528]                   }
[13:24:22.528]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.528]                     cond$call), session = sessionInformation(), 
[13:24:22.528]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.528]                   signalCondition(cond)
[13:24:22.528]                 }
[13:24:22.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.528]                 "immediateCondition"))) {
[13:24:22.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.528]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.528]                   if (TRUE && !signal) {
[13:24:22.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.528]                     {
[13:24:22.528]                       inherits <- base::inherits
[13:24:22.528]                       invokeRestart <- base::invokeRestart
[13:24:22.528]                       is.null <- base::is.null
[13:24:22.528]                       muffled <- FALSE
[13:24:22.528]                       if (inherits(cond, "message")) {
[13:24:22.528]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.528]                         if (muffled) 
[13:24:22.528]                           invokeRestart("muffleMessage")
[13:24:22.528]                       }
[13:24:22.528]                       else if (inherits(cond, "warning")) {
[13:24:22.528]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.528]                         if (muffled) 
[13:24:22.528]                           invokeRestart("muffleWarning")
[13:24:22.528]                       }
[13:24:22.528]                       else if (inherits(cond, "condition")) {
[13:24:22.528]                         if (!is.null(pattern)) {
[13:24:22.528]                           computeRestarts <- base::computeRestarts
[13:24:22.528]                           grepl <- base::grepl
[13:24:22.528]                           restarts <- computeRestarts(cond)
[13:24:22.528]                           for (restart in restarts) {
[13:24:22.528]                             name <- restart$name
[13:24:22.528]                             if (is.null(name)) 
[13:24:22.528]                               next
[13:24:22.528]                             if (!grepl(pattern, name)) 
[13:24:22.528]                               next
[13:24:22.528]                             invokeRestart(restart)
[13:24:22.528]                             muffled <- TRUE
[13:24:22.528]                             break
[13:24:22.528]                           }
[13:24:22.528]                         }
[13:24:22.528]                       }
[13:24:22.528]                       invisible(muffled)
[13:24:22.528]                     }
[13:24:22.528]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.528]                   }
[13:24:22.528]                 }
[13:24:22.528]                 else {
[13:24:22.528]                   if (TRUE) {
[13:24:22.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.528]                     {
[13:24:22.528]                       inherits <- base::inherits
[13:24:22.528]                       invokeRestart <- base::invokeRestart
[13:24:22.528]                       is.null <- base::is.null
[13:24:22.528]                       muffled <- FALSE
[13:24:22.528]                       if (inherits(cond, "message")) {
[13:24:22.528]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.528]                         if (muffled) 
[13:24:22.528]                           invokeRestart("muffleMessage")
[13:24:22.528]                       }
[13:24:22.528]                       else if (inherits(cond, "warning")) {
[13:24:22.528]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.528]                         if (muffled) 
[13:24:22.528]                           invokeRestart("muffleWarning")
[13:24:22.528]                       }
[13:24:22.528]                       else if (inherits(cond, "condition")) {
[13:24:22.528]                         if (!is.null(pattern)) {
[13:24:22.528]                           computeRestarts <- base::computeRestarts
[13:24:22.528]                           grepl <- base::grepl
[13:24:22.528]                           restarts <- computeRestarts(cond)
[13:24:22.528]                           for (restart in restarts) {
[13:24:22.528]                             name <- restart$name
[13:24:22.528]                             if (is.null(name)) 
[13:24:22.528]                               next
[13:24:22.528]                             if (!grepl(pattern, name)) 
[13:24:22.528]                               next
[13:24:22.528]                             invokeRestart(restart)
[13:24:22.528]                             muffled <- TRUE
[13:24:22.528]                             break
[13:24:22.528]                           }
[13:24:22.528]                         }
[13:24:22.528]                       }
[13:24:22.528]                       invisible(muffled)
[13:24:22.528]                     }
[13:24:22.528]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.528]                   }
[13:24:22.528]                 }
[13:24:22.528]             }
[13:24:22.528]         }))
[13:24:22.528]     }, error = function(ex) {
[13:24:22.528]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.528]                 ...future.rng), started = ...future.startTime, 
[13:24:22.528]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.528]             version = "1.8"), class = "FutureResult")
[13:24:22.528]     }, finally = {
[13:24:22.528]         if (!identical(...future.workdir, getwd())) 
[13:24:22.528]             setwd(...future.workdir)
[13:24:22.528]         {
[13:24:22.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.528]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.528]             }
[13:24:22.528]             base::options(...future.oldOptions)
[13:24:22.528]             if (.Platform$OS.type == "windows") {
[13:24:22.528]                 old_names <- names(...future.oldEnvVars)
[13:24:22.528]                 envs <- base::Sys.getenv()
[13:24:22.528]                 names <- names(envs)
[13:24:22.528]                 common <- intersect(names, old_names)
[13:24:22.528]                 added <- setdiff(names, old_names)
[13:24:22.528]                 removed <- setdiff(old_names, names)
[13:24:22.528]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.528]                   envs[common]]
[13:24:22.528]                 NAMES <- toupper(changed)
[13:24:22.528]                 args <- list()
[13:24:22.528]                 for (kk in seq_along(NAMES)) {
[13:24:22.528]                   name <- changed[[kk]]
[13:24:22.528]                   NAME <- NAMES[[kk]]
[13:24:22.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.528]                     next
[13:24:22.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.528]                 }
[13:24:22.528]                 NAMES <- toupper(added)
[13:24:22.528]                 for (kk in seq_along(NAMES)) {
[13:24:22.528]                   name <- added[[kk]]
[13:24:22.528]                   NAME <- NAMES[[kk]]
[13:24:22.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.528]                     next
[13:24:22.528]                   args[[name]] <- ""
[13:24:22.528]                 }
[13:24:22.528]                 NAMES <- toupper(removed)
[13:24:22.528]                 for (kk in seq_along(NAMES)) {
[13:24:22.528]                   name <- removed[[kk]]
[13:24:22.528]                   NAME <- NAMES[[kk]]
[13:24:22.528]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.528]                     next
[13:24:22.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.528]                 }
[13:24:22.528]                 if (length(args) > 0) 
[13:24:22.528]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.528]             }
[13:24:22.528]             else {
[13:24:22.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.528]             }
[13:24:22.528]             {
[13:24:22.528]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.528]                   0L) {
[13:24:22.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.528]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.528]                   base::options(opts)
[13:24:22.528]                 }
[13:24:22.528]                 {
[13:24:22.528]                   {
[13:24:22.528]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.528]                     NULL
[13:24:22.528]                   }
[13:24:22.528]                   options(future.plan = NULL)
[13:24:22.528]                   if (is.na(NA_character_)) 
[13:24:22.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.528]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.528]                     envir = parent.frame()) 
[13:24:22.528]                   {
[13:24:22.528]                     default_workers <- missing(workers)
[13:24:22.528]                     if (is.function(workers)) 
[13:24:22.528]                       workers <- workers()
[13:24:22.528]                     workers <- structure(as.integer(workers), 
[13:24:22.528]                       class = class(workers))
[13:24:22.528]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.528]                       1L)
[13:24:22.528]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.528]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.528]                       if (default_workers) 
[13:24:22.528]                         supportsMulticore(warn = TRUE)
[13:24:22.528]                       return(sequential(..., envir = envir))
[13:24:22.528]                     }
[13:24:22.528]                     oopts <- options(mc.cores = workers)
[13:24:22.528]                     on.exit(options(oopts))
[13:24:22.528]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.528]                       envir = envir)
[13:24:22.528]                     if (!future$lazy) 
[13:24:22.528]                       future <- run(future)
[13:24:22.528]                     invisible(future)
[13:24:22.528]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.528]                 }
[13:24:22.528]             }
[13:24:22.528]         }
[13:24:22.528]     })
[13:24:22.528]     if (TRUE) {
[13:24:22.528]         base::sink(type = "output", split = FALSE)
[13:24:22.528]         if (TRUE) {
[13:24:22.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.528]         }
[13:24:22.528]         else {
[13:24:22.528]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.528]         }
[13:24:22.528]         base::close(...future.stdout)
[13:24:22.528]         ...future.stdout <- NULL
[13:24:22.528]     }
[13:24:22.528]     ...future.result$conditions <- ...future.conditions
[13:24:22.528]     ...future.result$finished <- base::Sys.time()
[13:24:22.528]     ...future.result
[13:24:22.528] }
[13:24:22.532] requestCore(): workers = 2
[13:24:22.532] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:22.556] result() for MulticoreFuture ...
[13:24:22.557] result() for MulticoreFuture ...
[13:24:22.557] result() for MulticoreFuture ... done
[13:24:22.557] result() for MulticoreFuture ... done
[13:24:22.557] result() for MulticoreFuture ...
[13:24:22.557] result() for MulticoreFuture ... done
[13:24:22.560] MulticoreFuture started
[13:24:22.560] - Launch lazy future ... done
[13:24:22.560] run() for ‘MulticoreFuture’ ... done
[13:24:22.561] plan(): Setting new future strategy stack:
[13:24:22.561] List of future strategies:
[13:24:22.561] 1. sequential:
[13:24:22.561]    - args: function (..., envir = parent.frame())
[13:24:22.561]    - tweaked: FALSE
[13:24:22.561]    - call: NULL
[13:24:22.562] plan(): nbrOfWorkers() = 1
[13:24:22.564] plan(): Setting new future strategy stack:
[13:24:22.564] List of future strategies:
[13:24:22.564] 1. multicore:
[13:24:22.564]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.564]    - tweaked: FALSE
[13:24:22.564]    - call: plan(strategy)
[13:24:22.572] Future #2
[13:24:22.572]  length: 2 (resolved future 2)
[13:24:22.572]  length: 1 (resolved future 3)
[13:24:22.577] plan(): nbrOfWorkers() = 2
[13:24:22.583] Future #1
[13:24:22.583]  length: 0 (resolved future 1)
[13:24:22.583] resolve() on list ... DONE
[13:24:22.584] getGlobalsAndPackages() ...
[13:24:22.588] Searching for globals...
[13:24:22.589] 
[13:24:22.589] Searching for globals ... DONE
[13:24:22.589] - globals: [0] <none>
[13:24:22.589] getGlobalsAndPackages() ... DONE
[13:24:22.590] getGlobalsAndPackages() ...
[13:24:22.590] Searching for globals...
[13:24:22.591] 
[13:24:22.591] Searching for globals ... DONE
[13:24:22.592] - globals: [0] <none>
[13:24:22.592] getGlobalsAndPackages() ... DONE
[13:24:22.592] resolve() on list ...
[13:24:22.593]  recursive: 0
[13:24:22.593]  length: 3
[13:24:22.593]  elements: ‘a’, ‘b’, ‘’
[13:24:22.593] run() for ‘Future’ ...
[13:24:22.593] - state: ‘created’
[13:24:22.594] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.599]   - Field: ‘label’
[13:24:22.599]   - Field: ‘local’
[13:24:22.600]   - Field: ‘owner’
[13:24:22.600]   - Field: ‘envir’
[13:24:22.600]   - Field: ‘workers’
[13:24:22.600]   - Field: ‘packages’
[13:24:22.601]   - Field: ‘gc’
[13:24:22.601]   - Field: ‘job’
[13:24:22.601]   - Field: ‘conditions’
[13:24:22.601]   - Field: ‘expr’
[13:24:22.601]   - Field: ‘uuid’
[13:24:22.601]   - Field: ‘seed’
[13:24:22.602]   - Field: ‘version’
[13:24:22.602]   - Field: ‘result’
[13:24:22.602]   - Field: ‘asynchronous’
[13:24:22.602]   - Field: ‘calls’
[13:24:22.602]   - Field: ‘globals’
[13:24:22.602]   - Field: ‘stdout’
[13:24:22.602]   - Field: ‘earlySignal’
[13:24:22.602]   - Field: ‘lazy’
[13:24:22.603]   - Field: ‘state’
[13:24:22.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.603] - Launch lazy future ...
[13:24:22.603] Packages needed by the future expression (n = 0): <none>
[13:24:22.603] Packages needed by future strategies (n = 0): <none>
[13:24:22.604] {
[13:24:22.604]     {
[13:24:22.604]         {
[13:24:22.604]             ...future.startTime <- base::Sys.time()
[13:24:22.604]             {
[13:24:22.604]                 {
[13:24:22.604]                   {
[13:24:22.604]                     {
[13:24:22.604]                       base::local({
[13:24:22.604]                         has_future <- base::requireNamespace("future", 
[13:24:22.604]                           quietly = TRUE)
[13:24:22.604]                         if (has_future) {
[13:24:22.604]                           ns <- base::getNamespace("future")
[13:24:22.604]                           version <- ns[[".package"]][["version"]]
[13:24:22.604]                           if (is.null(version)) 
[13:24:22.604]                             version <- utils::packageVersion("future")
[13:24:22.604]                         }
[13:24:22.604]                         else {
[13:24:22.604]                           version <- NULL
[13:24:22.604]                         }
[13:24:22.604]                         if (!has_future || version < "1.8.0") {
[13:24:22.604]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.604]                             "", base::R.version$version.string), 
[13:24:22.604]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.604]                               "release", "version")], collapse = " "), 
[13:24:22.604]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.604]                             info)
[13:24:22.604]                           info <- base::paste(info, collapse = "; ")
[13:24:22.604]                           if (!has_future) {
[13:24:22.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.604]                               info)
[13:24:22.604]                           }
[13:24:22.604]                           else {
[13:24:22.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.604]                               info, version)
[13:24:22.604]                           }
[13:24:22.604]                           base::stop(msg)
[13:24:22.604]                         }
[13:24:22.604]                       })
[13:24:22.604]                     }
[13:24:22.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.604]                     base::options(mc.cores = 1L)
[13:24:22.604]                   }
[13:24:22.604]                   options(future.plan = NULL)
[13:24:22.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.604]                 }
[13:24:22.604]                 ...future.workdir <- getwd()
[13:24:22.604]             }
[13:24:22.604]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.604]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.604]         }
[13:24:22.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.604]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.604]             base::names(...future.oldOptions))
[13:24:22.604]     }
[13:24:22.604]     if (FALSE) {
[13:24:22.604]     }
[13:24:22.604]     else {
[13:24:22.604]         if (TRUE) {
[13:24:22.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.604]                 open = "w")
[13:24:22.604]         }
[13:24:22.604]         else {
[13:24:22.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.604]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.604]         }
[13:24:22.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.604]             base::sink(type = "output", split = FALSE)
[13:24:22.604]             base::close(...future.stdout)
[13:24:22.604]         }, add = TRUE)
[13:24:22.604]     }
[13:24:22.604]     ...future.frame <- base::sys.nframe()
[13:24:22.604]     ...future.conditions <- base::list()
[13:24:22.604]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.604]     if (FALSE) {
[13:24:22.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.604]     }
[13:24:22.604]     ...future.result <- base::tryCatch({
[13:24:22.604]         base::withCallingHandlers({
[13:24:22.604]             ...future.value <- base::withVisible(base::local({
[13:24:22.604]                 withCallingHandlers({
[13:24:22.604]                   1
[13:24:22.604]                 }, immediateCondition = function(cond) {
[13:24:22.604]                   save_rds <- function (object, pathname, ...) 
[13:24:22.604]                   {
[13:24:22.604]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.604]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.604]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.604]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.604]                         fi_tmp[["mtime"]])
[13:24:22.604]                     }
[13:24:22.604]                     tryCatch({
[13:24:22.604]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.604]                     }, error = function(ex) {
[13:24:22.604]                       msg <- conditionMessage(ex)
[13:24:22.604]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.604]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.604]                         fi_tmp[["mtime"]], msg)
[13:24:22.604]                       ex$message <- msg
[13:24:22.604]                       stop(ex)
[13:24:22.604]                     })
[13:24:22.604]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.604]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.604]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.604]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.604]                       fi <- file.info(pathname)
[13:24:22.604]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.604]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.604]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.604]                         fi[["size"]], fi[["mtime"]])
[13:24:22.604]                       stop(msg)
[13:24:22.604]                     }
[13:24:22.604]                     invisible(pathname)
[13:24:22.604]                   }
[13:24:22.604]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.604]                     rootPath = tempdir()) 
[13:24:22.604]                   {
[13:24:22.604]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.604]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.604]                       tmpdir = path, fileext = ".rds")
[13:24:22.604]                     save_rds(obj, file)
[13:24:22.604]                   }
[13:24:22.604]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.604]                   {
[13:24:22.604]                     inherits <- base::inherits
[13:24:22.604]                     invokeRestart <- base::invokeRestart
[13:24:22.604]                     is.null <- base::is.null
[13:24:22.604]                     muffled <- FALSE
[13:24:22.604]                     if (inherits(cond, "message")) {
[13:24:22.604]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.604]                       if (muffled) 
[13:24:22.604]                         invokeRestart("muffleMessage")
[13:24:22.604]                     }
[13:24:22.604]                     else if (inherits(cond, "warning")) {
[13:24:22.604]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.604]                       if (muffled) 
[13:24:22.604]                         invokeRestart("muffleWarning")
[13:24:22.604]                     }
[13:24:22.604]                     else if (inherits(cond, "condition")) {
[13:24:22.604]                       if (!is.null(pattern)) {
[13:24:22.604]                         computeRestarts <- base::computeRestarts
[13:24:22.604]                         grepl <- base::grepl
[13:24:22.604]                         restarts <- computeRestarts(cond)
[13:24:22.604]                         for (restart in restarts) {
[13:24:22.604]                           name <- restart$name
[13:24:22.604]                           if (is.null(name)) 
[13:24:22.604]                             next
[13:24:22.604]                           if (!grepl(pattern, name)) 
[13:24:22.604]                             next
[13:24:22.604]                           invokeRestart(restart)
[13:24:22.604]                           muffled <- TRUE
[13:24:22.604]                           break
[13:24:22.604]                         }
[13:24:22.604]                       }
[13:24:22.604]                     }
[13:24:22.604]                     invisible(muffled)
[13:24:22.604]                   }
[13:24:22.604]                   muffleCondition(cond)
[13:24:22.604]                 })
[13:24:22.604]             }))
[13:24:22.604]             future::FutureResult(value = ...future.value$value, 
[13:24:22.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.604]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.604]                     ...future.globalenv.names))
[13:24:22.604]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.604]         }, condition = base::local({
[13:24:22.604]             c <- base::c
[13:24:22.604]             inherits <- base::inherits
[13:24:22.604]             invokeRestart <- base::invokeRestart
[13:24:22.604]             length <- base::length
[13:24:22.604]             list <- base::list
[13:24:22.604]             seq.int <- base::seq.int
[13:24:22.604]             signalCondition <- base::signalCondition
[13:24:22.604]             sys.calls <- base::sys.calls
[13:24:22.604]             `[[` <- base::`[[`
[13:24:22.604]             `+` <- base::`+`
[13:24:22.604]             `<<-` <- base::`<<-`
[13:24:22.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.604]                   3L)]
[13:24:22.604]             }
[13:24:22.604]             function(cond) {
[13:24:22.604]                 is_error <- inherits(cond, "error")
[13:24:22.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.604]                   NULL)
[13:24:22.604]                 if (is_error) {
[13:24:22.604]                   sessionInformation <- function() {
[13:24:22.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.604]                       search = base::search(), system = base::Sys.info())
[13:24:22.604]                   }
[13:24:22.604]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.604]                     cond$call), session = sessionInformation(), 
[13:24:22.604]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.604]                   signalCondition(cond)
[13:24:22.604]                 }
[13:24:22.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.604]                 "immediateCondition"))) {
[13:24:22.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.604]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.604]                   if (TRUE && !signal) {
[13:24:22.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.604]                     {
[13:24:22.604]                       inherits <- base::inherits
[13:24:22.604]                       invokeRestart <- base::invokeRestart
[13:24:22.604]                       is.null <- base::is.null
[13:24:22.604]                       muffled <- FALSE
[13:24:22.604]                       if (inherits(cond, "message")) {
[13:24:22.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.604]                         if (muffled) 
[13:24:22.604]                           invokeRestart("muffleMessage")
[13:24:22.604]                       }
[13:24:22.604]                       else if (inherits(cond, "warning")) {
[13:24:22.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.604]                         if (muffled) 
[13:24:22.604]                           invokeRestart("muffleWarning")
[13:24:22.604]                       }
[13:24:22.604]                       else if (inherits(cond, "condition")) {
[13:24:22.604]                         if (!is.null(pattern)) {
[13:24:22.604]                           computeRestarts <- base::computeRestarts
[13:24:22.604]                           grepl <- base::grepl
[13:24:22.604]                           restarts <- computeRestarts(cond)
[13:24:22.604]                           for (restart in restarts) {
[13:24:22.604]                             name <- restart$name
[13:24:22.604]                             if (is.null(name)) 
[13:24:22.604]                               next
[13:24:22.604]                             if (!grepl(pattern, name)) 
[13:24:22.604]                               next
[13:24:22.604]                             invokeRestart(restart)
[13:24:22.604]                             muffled <- TRUE
[13:24:22.604]                             break
[13:24:22.604]                           }
[13:24:22.604]                         }
[13:24:22.604]                       }
[13:24:22.604]                       invisible(muffled)
[13:24:22.604]                     }
[13:24:22.604]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.604]                   }
[13:24:22.604]                 }
[13:24:22.604]                 else {
[13:24:22.604]                   if (TRUE) {
[13:24:22.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.604]                     {
[13:24:22.604]                       inherits <- base::inherits
[13:24:22.604]                       invokeRestart <- base::invokeRestart
[13:24:22.604]                       is.null <- base::is.null
[13:24:22.604]                       muffled <- FALSE
[13:24:22.604]                       if (inherits(cond, "message")) {
[13:24:22.604]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.604]                         if (muffled) 
[13:24:22.604]                           invokeRestart("muffleMessage")
[13:24:22.604]                       }
[13:24:22.604]                       else if (inherits(cond, "warning")) {
[13:24:22.604]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.604]                         if (muffled) 
[13:24:22.604]                           invokeRestart("muffleWarning")
[13:24:22.604]                       }
[13:24:22.604]                       else if (inherits(cond, "condition")) {
[13:24:22.604]                         if (!is.null(pattern)) {
[13:24:22.604]                           computeRestarts <- base::computeRestarts
[13:24:22.604]                           grepl <- base::grepl
[13:24:22.604]                           restarts <- computeRestarts(cond)
[13:24:22.604]                           for (restart in restarts) {
[13:24:22.604]                             name <- restart$name
[13:24:22.604]                             if (is.null(name)) 
[13:24:22.604]                               next
[13:24:22.604]                             if (!grepl(pattern, name)) 
[13:24:22.604]                               next
[13:24:22.604]                             invokeRestart(restart)
[13:24:22.604]                             muffled <- TRUE
[13:24:22.604]                             break
[13:24:22.604]                           }
[13:24:22.604]                         }
[13:24:22.604]                       }
[13:24:22.604]                       invisible(muffled)
[13:24:22.604]                     }
[13:24:22.604]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.604]                   }
[13:24:22.604]                 }
[13:24:22.604]             }
[13:24:22.604]         }))
[13:24:22.604]     }, error = function(ex) {
[13:24:22.604]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.604]                 ...future.rng), started = ...future.startTime, 
[13:24:22.604]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.604]             version = "1.8"), class = "FutureResult")
[13:24:22.604]     }, finally = {
[13:24:22.604]         if (!identical(...future.workdir, getwd())) 
[13:24:22.604]             setwd(...future.workdir)
[13:24:22.604]         {
[13:24:22.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.604]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.604]             }
[13:24:22.604]             base::options(...future.oldOptions)
[13:24:22.604]             if (.Platform$OS.type == "windows") {
[13:24:22.604]                 old_names <- names(...future.oldEnvVars)
[13:24:22.604]                 envs <- base::Sys.getenv()
[13:24:22.604]                 names <- names(envs)
[13:24:22.604]                 common <- intersect(names, old_names)
[13:24:22.604]                 added <- setdiff(names, old_names)
[13:24:22.604]                 removed <- setdiff(old_names, names)
[13:24:22.604]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.604]                   envs[common]]
[13:24:22.604]                 NAMES <- toupper(changed)
[13:24:22.604]                 args <- list()
[13:24:22.604]                 for (kk in seq_along(NAMES)) {
[13:24:22.604]                   name <- changed[[kk]]
[13:24:22.604]                   NAME <- NAMES[[kk]]
[13:24:22.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.604]                     next
[13:24:22.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.604]                 }
[13:24:22.604]                 NAMES <- toupper(added)
[13:24:22.604]                 for (kk in seq_along(NAMES)) {
[13:24:22.604]                   name <- added[[kk]]
[13:24:22.604]                   NAME <- NAMES[[kk]]
[13:24:22.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.604]                     next
[13:24:22.604]                   args[[name]] <- ""
[13:24:22.604]                 }
[13:24:22.604]                 NAMES <- toupper(removed)
[13:24:22.604]                 for (kk in seq_along(NAMES)) {
[13:24:22.604]                   name <- removed[[kk]]
[13:24:22.604]                   NAME <- NAMES[[kk]]
[13:24:22.604]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.604]                     next
[13:24:22.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.604]                 }
[13:24:22.604]                 if (length(args) > 0) 
[13:24:22.604]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.604]             }
[13:24:22.604]             else {
[13:24:22.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.604]             }
[13:24:22.604]             {
[13:24:22.604]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.604]                   0L) {
[13:24:22.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.604]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.604]                   base::options(opts)
[13:24:22.604]                 }
[13:24:22.604]                 {
[13:24:22.604]                   {
[13:24:22.604]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.604]                     NULL
[13:24:22.604]                   }
[13:24:22.604]                   options(future.plan = NULL)
[13:24:22.604]                   if (is.na(NA_character_)) 
[13:24:22.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.604]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.604]                     envir = parent.frame()) 
[13:24:22.604]                   {
[13:24:22.604]                     default_workers <- missing(workers)
[13:24:22.604]                     if (is.function(workers)) 
[13:24:22.604]                       workers <- workers()
[13:24:22.604]                     workers <- structure(as.integer(workers), 
[13:24:22.604]                       class = class(workers))
[13:24:22.604]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.604]                       1L)
[13:24:22.604]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.604]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.604]                       if (default_workers) 
[13:24:22.604]                         supportsMulticore(warn = TRUE)
[13:24:22.604]                       return(sequential(..., envir = envir))
[13:24:22.604]                     }
[13:24:22.604]                     oopts <- options(mc.cores = workers)
[13:24:22.604]                     on.exit(options(oopts))
[13:24:22.604]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.604]                       envir = envir)
[13:24:22.604]                     if (!future$lazy) 
[13:24:22.604]                       future <- run(future)
[13:24:22.604]                     invisible(future)
[13:24:22.604]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.604]                 }
[13:24:22.604]             }
[13:24:22.604]         }
[13:24:22.604]     })
[13:24:22.604]     if (TRUE) {
[13:24:22.604]         base::sink(type = "output", split = FALSE)
[13:24:22.604]         if (TRUE) {
[13:24:22.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.604]         }
[13:24:22.604]         else {
[13:24:22.604]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.604]         }
[13:24:22.604]         base::close(...future.stdout)
[13:24:22.604]         ...future.stdout <- NULL
[13:24:22.604]     }
[13:24:22.604]     ...future.result$conditions <- ...future.conditions
[13:24:22.604]     ...future.result$finished <- base::Sys.time()
[13:24:22.604]     ...future.result
[13:24:22.604] }
[13:24:22.607] requestCore(): workers = 2
[13:24:22.608] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:22.618] result() for MulticoreFuture ...
[13:24:22.619] result() for MulticoreFuture ...
[13:24:22.620] result() for MulticoreFuture ... done
[13:24:22.620] result() for MulticoreFuture ... done
[13:24:22.620] result() for MulticoreFuture ...
[13:24:22.620] result() for MulticoreFuture ... done
[13:24:22.622] MulticoreFuture started
[13:24:22.623] - Launch lazy future ... done
[13:24:22.623] run() for ‘MulticoreFuture’ ... done
[13:24:22.624] plan(): Setting new future strategy stack:
[13:24:22.624] List of future strategies:
[13:24:22.624] 1. sequential:
[13:24:22.624]    - args: function (..., envir = parent.frame())
[13:24:22.624]    - tweaked: FALSE
[13:24:22.624]    - call: NULL
[13:24:22.625] plan(): nbrOfWorkers() = 1
[13:24:22.627] plan(): Setting new future strategy stack:
[13:24:22.628] List of future strategies:
[13:24:22.628] 1. multicore:
[13:24:22.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.628]    - tweaked: FALSE
[13:24:22.628]    - call: plan(strategy)
[13:24:22.634] plan(): nbrOfWorkers() = 2
[13:24:22.634] run() for ‘Future’ ...
[13:24:22.634] - state: ‘created’
[13:24:22.635] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.640]   - Field: ‘label’
[13:24:22.640]   - Field: ‘local’
[13:24:22.640]   - Field: ‘owner’
[13:24:22.640]   - Field: ‘envir’
[13:24:22.640]   - Field: ‘workers’
[13:24:22.641]   - Field: ‘packages’
[13:24:22.641]   - Field: ‘gc’
[13:24:22.641]   - Field: ‘job’
[13:24:22.641]   - Field: ‘conditions’
[13:24:22.641]   - Field: ‘expr’
[13:24:22.641]   - Field: ‘uuid’
[13:24:22.642]   - Field: ‘seed’
[13:24:22.642]   - Field: ‘version’
[13:24:22.642]   - Field: ‘result’
[13:24:22.642]   - Field: ‘asynchronous’
[13:24:22.642]   - Field: ‘calls’
[13:24:22.642]   - Field: ‘globals’
[13:24:22.642]   - Field: ‘stdout’
[13:24:22.643]   - Field: ‘earlySignal’
[13:24:22.643]   - Field: ‘lazy’
[13:24:22.643]   - Field: ‘state’
[13:24:22.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.643] - Launch lazy future ...
[13:24:22.644] Packages needed by the future expression (n = 0): <none>
[13:24:22.644] Packages needed by future strategies (n = 0): <none>
[13:24:22.645] {
[13:24:22.645]     {
[13:24:22.645]         {
[13:24:22.645]             ...future.startTime <- base::Sys.time()
[13:24:22.645]             {
[13:24:22.645]                 {
[13:24:22.645]                   {
[13:24:22.645]                     {
[13:24:22.645]                       base::local({
[13:24:22.645]                         has_future <- base::requireNamespace("future", 
[13:24:22.645]                           quietly = TRUE)
[13:24:22.645]                         if (has_future) {
[13:24:22.645]                           ns <- base::getNamespace("future")
[13:24:22.645]                           version <- ns[[".package"]][["version"]]
[13:24:22.645]                           if (is.null(version)) 
[13:24:22.645]                             version <- utils::packageVersion("future")
[13:24:22.645]                         }
[13:24:22.645]                         else {
[13:24:22.645]                           version <- NULL
[13:24:22.645]                         }
[13:24:22.645]                         if (!has_future || version < "1.8.0") {
[13:24:22.645]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.645]                             "", base::R.version$version.string), 
[13:24:22.645]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.645]                               "release", "version")], collapse = " "), 
[13:24:22.645]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.645]                             info)
[13:24:22.645]                           info <- base::paste(info, collapse = "; ")
[13:24:22.645]                           if (!has_future) {
[13:24:22.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.645]                               info)
[13:24:22.645]                           }
[13:24:22.645]                           else {
[13:24:22.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.645]                               info, version)
[13:24:22.645]                           }
[13:24:22.645]                           base::stop(msg)
[13:24:22.645]                         }
[13:24:22.645]                       })
[13:24:22.645]                     }
[13:24:22.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.645]                     base::options(mc.cores = 1L)
[13:24:22.645]                   }
[13:24:22.645]                   options(future.plan = NULL)
[13:24:22.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.645]                 }
[13:24:22.645]                 ...future.workdir <- getwd()
[13:24:22.645]             }
[13:24:22.645]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.645]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.645]         }
[13:24:22.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.645]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.645]             base::names(...future.oldOptions))
[13:24:22.645]     }
[13:24:22.645]     if (FALSE) {
[13:24:22.645]     }
[13:24:22.645]     else {
[13:24:22.645]         if (TRUE) {
[13:24:22.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.645]                 open = "w")
[13:24:22.645]         }
[13:24:22.645]         else {
[13:24:22.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.645]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.645]         }
[13:24:22.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.645]             base::sink(type = "output", split = FALSE)
[13:24:22.645]             base::close(...future.stdout)
[13:24:22.645]         }, add = TRUE)
[13:24:22.645]     }
[13:24:22.645]     ...future.frame <- base::sys.nframe()
[13:24:22.645]     ...future.conditions <- base::list()
[13:24:22.645]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.645]     if (FALSE) {
[13:24:22.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.645]     }
[13:24:22.645]     ...future.result <- base::tryCatch({
[13:24:22.645]         base::withCallingHandlers({
[13:24:22.645]             ...future.value <- base::withVisible(base::local({
[13:24:22.645]                 withCallingHandlers({
[13:24:22.645]                   2
[13:24:22.645]                 }, immediateCondition = function(cond) {
[13:24:22.645]                   save_rds <- function (object, pathname, ...) 
[13:24:22.645]                   {
[13:24:22.645]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.645]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.645]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.645]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.645]                         fi_tmp[["mtime"]])
[13:24:22.645]                     }
[13:24:22.645]                     tryCatch({
[13:24:22.645]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.645]                     }, error = function(ex) {
[13:24:22.645]                       msg <- conditionMessage(ex)
[13:24:22.645]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.645]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.645]                         fi_tmp[["mtime"]], msg)
[13:24:22.645]                       ex$message <- msg
[13:24:22.645]                       stop(ex)
[13:24:22.645]                     })
[13:24:22.645]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.645]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.645]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.645]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.645]                       fi <- file.info(pathname)
[13:24:22.645]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.645]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.645]                         fi[["size"]], fi[["mtime"]])
[13:24:22.645]                       stop(msg)
[13:24:22.645]                     }
[13:24:22.645]                     invisible(pathname)
[13:24:22.645]                   }
[13:24:22.645]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.645]                     rootPath = tempdir()) 
[13:24:22.645]                   {
[13:24:22.645]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.645]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.645]                       tmpdir = path, fileext = ".rds")
[13:24:22.645]                     save_rds(obj, file)
[13:24:22.645]                   }
[13:24:22.645]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.645]                   {
[13:24:22.645]                     inherits <- base::inherits
[13:24:22.645]                     invokeRestart <- base::invokeRestart
[13:24:22.645]                     is.null <- base::is.null
[13:24:22.645]                     muffled <- FALSE
[13:24:22.645]                     if (inherits(cond, "message")) {
[13:24:22.645]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.645]                       if (muffled) 
[13:24:22.645]                         invokeRestart("muffleMessage")
[13:24:22.645]                     }
[13:24:22.645]                     else if (inherits(cond, "warning")) {
[13:24:22.645]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.645]                       if (muffled) 
[13:24:22.645]                         invokeRestart("muffleWarning")
[13:24:22.645]                     }
[13:24:22.645]                     else if (inherits(cond, "condition")) {
[13:24:22.645]                       if (!is.null(pattern)) {
[13:24:22.645]                         computeRestarts <- base::computeRestarts
[13:24:22.645]                         grepl <- base::grepl
[13:24:22.645]                         restarts <- computeRestarts(cond)
[13:24:22.645]                         for (restart in restarts) {
[13:24:22.645]                           name <- restart$name
[13:24:22.645]                           if (is.null(name)) 
[13:24:22.645]                             next
[13:24:22.645]                           if (!grepl(pattern, name)) 
[13:24:22.645]                             next
[13:24:22.645]                           invokeRestart(restart)
[13:24:22.645]                           muffled <- TRUE
[13:24:22.645]                           break
[13:24:22.645]                         }
[13:24:22.645]                       }
[13:24:22.645]                     }
[13:24:22.645]                     invisible(muffled)
[13:24:22.645]                   }
[13:24:22.645]                   muffleCondition(cond)
[13:24:22.645]                 })
[13:24:22.645]             }))
[13:24:22.645]             future::FutureResult(value = ...future.value$value, 
[13:24:22.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.645]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.645]                     ...future.globalenv.names))
[13:24:22.645]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.645]         }, condition = base::local({
[13:24:22.645]             c <- base::c
[13:24:22.645]             inherits <- base::inherits
[13:24:22.645]             invokeRestart <- base::invokeRestart
[13:24:22.645]             length <- base::length
[13:24:22.645]             list <- base::list
[13:24:22.645]             seq.int <- base::seq.int
[13:24:22.645]             signalCondition <- base::signalCondition
[13:24:22.645]             sys.calls <- base::sys.calls
[13:24:22.645]             `[[` <- base::`[[`
[13:24:22.645]             `+` <- base::`+`
[13:24:22.645]             `<<-` <- base::`<<-`
[13:24:22.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.645]                   3L)]
[13:24:22.645]             }
[13:24:22.645]             function(cond) {
[13:24:22.645]                 is_error <- inherits(cond, "error")
[13:24:22.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.645]                   NULL)
[13:24:22.645]                 if (is_error) {
[13:24:22.645]                   sessionInformation <- function() {
[13:24:22.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.645]                       search = base::search(), system = base::Sys.info())
[13:24:22.645]                   }
[13:24:22.645]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.645]                     cond$call), session = sessionInformation(), 
[13:24:22.645]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.645]                   signalCondition(cond)
[13:24:22.645]                 }
[13:24:22.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.645]                 "immediateCondition"))) {
[13:24:22.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.645]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.645]                   if (TRUE && !signal) {
[13:24:22.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.645]                     {
[13:24:22.645]                       inherits <- base::inherits
[13:24:22.645]                       invokeRestart <- base::invokeRestart
[13:24:22.645]                       is.null <- base::is.null
[13:24:22.645]                       muffled <- FALSE
[13:24:22.645]                       if (inherits(cond, "message")) {
[13:24:22.645]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.645]                         if (muffled) 
[13:24:22.645]                           invokeRestart("muffleMessage")
[13:24:22.645]                       }
[13:24:22.645]                       else if (inherits(cond, "warning")) {
[13:24:22.645]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.645]                         if (muffled) 
[13:24:22.645]                           invokeRestart("muffleWarning")
[13:24:22.645]                       }
[13:24:22.645]                       else if (inherits(cond, "condition")) {
[13:24:22.645]                         if (!is.null(pattern)) {
[13:24:22.645]                           computeRestarts <- base::computeRestarts
[13:24:22.645]                           grepl <- base::grepl
[13:24:22.645]                           restarts <- computeRestarts(cond)
[13:24:22.645]                           for (restart in restarts) {
[13:24:22.645]                             name <- restart$name
[13:24:22.645]                             if (is.null(name)) 
[13:24:22.645]                               next
[13:24:22.645]                             if (!grepl(pattern, name)) 
[13:24:22.645]                               next
[13:24:22.645]                             invokeRestart(restart)
[13:24:22.645]                             muffled <- TRUE
[13:24:22.645]                             break
[13:24:22.645]                           }
[13:24:22.645]                         }
[13:24:22.645]                       }
[13:24:22.645]                       invisible(muffled)
[13:24:22.645]                     }
[13:24:22.645]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.645]                   }
[13:24:22.645]                 }
[13:24:22.645]                 else {
[13:24:22.645]                   if (TRUE) {
[13:24:22.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.645]                     {
[13:24:22.645]                       inherits <- base::inherits
[13:24:22.645]                       invokeRestart <- base::invokeRestart
[13:24:22.645]                       is.null <- base::is.null
[13:24:22.645]                       muffled <- FALSE
[13:24:22.645]                       if (inherits(cond, "message")) {
[13:24:22.645]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.645]                         if (muffled) 
[13:24:22.645]                           invokeRestart("muffleMessage")
[13:24:22.645]                       }
[13:24:22.645]                       else if (inherits(cond, "warning")) {
[13:24:22.645]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.645]                         if (muffled) 
[13:24:22.645]                           invokeRestart("muffleWarning")
[13:24:22.645]                       }
[13:24:22.645]                       else if (inherits(cond, "condition")) {
[13:24:22.645]                         if (!is.null(pattern)) {
[13:24:22.645]                           computeRestarts <- base::computeRestarts
[13:24:22.645]                           grepl <- base::grepl
[13:24:22.645]                           restarts <- computeRestarts(cond)
[13:24:22.645]                           for (restart in restarts) {
[13:24:22.645]                             name <- restart$name
[13:24:22.645]                             if (is.null(name)) 
[13:24:22.645]                               next
[13:24:22.645]                             if (!grepl(pattern, name)) 
[13:24:22.645]                               next
[13:24:22.645]                             invokeRestart(restart)
[13:24:22.645]                             muffled <- TRUE
[13:24:22.645]                             break
[13:24:22.645]                           }
[13:24:22.645]                         }
[13:24:22.645]                       }
[13:24:22.645]                       invisible(muffled)
[13:24:22.645]                     }
[13:24:22.645]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.645]                   }
[13:24:22.645]                 }
[13:24:22.645]             }
[13:24:22.645]         }))
[13:24:22.645]     }, error = function(ex) {
[13:24:22.645]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.645]                 ...future.rng), started = ...future.startTime, 
[13:24:22.645]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.645]             version = "1.8"), class = "FutureResult")
[13:24:22.645]     }, finally = {
[13:24:22.645]         if (!identical(...future.workdir, getwd())) 
[13:24:22.645]             setwd(...future.workdir)
[13:24:22.645]         {
[13:24:22.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.645]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.645]             }
[13:24:22.645]             base::options(...future.oldOptions)
[13:24:22.645]             if (.Platform$OS.type == "windows") {
[13:24:22.645]                 old_names <- names(...future.oldEnvVars)
[13:24:22.645]                 envs <- base::Sys.getenv()
[13:24:22.645]                 names <- names(envs)
[13:24:22.645]                 common <- intersect(names, old_names)
[13:24:22.645]                 added <- setdiff(names, old_names)
[13:24:22.645]                 removed <- setdiff(old_names, names)
[13:24:22.645]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.645]                   envs[common]]
[13:24:22.645]                 NAMES <- toupper(changed)
[13:24:22.645]                 args <- list()
[13:24:22.645]                 for (kk in seq_along(NAMES)) {
[13:24:22.645]                   name <- changed[[kk]]
[13:24:22.645]                   NAME <- NAMES[[kk]]
[13:24:22.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.645]                     next
[13:24:22.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.645]                 }
[13:24:22.645]                 NAMES <- toupper(added)
[13:24:22.645]                 for (kk in seq_along(NAMES)) {
[13:24:22.645]                   name <- added[[kk]]
[13:24:22.645]                   NAME <- NAMES[[kk]]
[13:24:22.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.645]                     next
[13:24:22.645]                   args[[name]] <- ""
[13:24:22.645]                 }
[13:24:22.645]                 NAMES <- toupper(removed)
[13:24:22.645]                 for (kk in seq_along(NAMES)) {
[13:24:22.645]                   name <- removed[[kk]]
[13:24:22.645]                   NAME <- NAMES[[kk]]
[13:24:22.645]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.645]                     next
[13:24:22.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.645]                 }
[13:24:22.645]                 if (length(args) > 0) 
[13:24:22.645]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.645]             }
[13:24:22.645]             else {
[13:24:22.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.645]             }
[13:24:22.645]             {
[13:24:22.645]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.645]                   0L) {
[13:24:22.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.645]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.645]                   base::options(opts)
[13:24:22.645]                 }
[13:24:22.645]                 {
[13:24:22.645]                   {
[13:24:22.645]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.645]                     NULL
[13:24:22.645]                   }
[13:24:22.645]                   options(future.plan = NULL)
[13:24:22.645]                   if (is.na(NA_character_)) 
[13:24:22.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.645]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.645]                     envir = parent.frame()) 
[13:24:22.645]                   {
[13:24:22.645]                     default_workers <- missing(workers)
[13:24:22.645]                     if (is.function(workers)) 
[13:24:22.645]                       workers <- workers()
[13:24:22.645]                     workers <- structure(as.integer(workers), 
[13:24:22.645]                       class = class(workers))
[13:24:22.645]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.645]                       1L)
[13:24:22.645]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.645]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.645]                       if (default_workers) 
[13:24:22.645]                         supportsMulticore(warn = TRUE)
[13:24:22.645]                       return(sequential(..., envir = envir))
[13:24:22.645]                     }
[13:24:22.645]                     oopts <- options(mc.cores = workers)
[13:24:22.645]                     on.exit(options(oopts))
[13:24:22.645]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.645]                       envir = envir)
[13:24:22.645]                     if (!future$lazy) 
[13:24:22.645]                       future <- run(future)
[13:24:22.645]                     invisible(future)
[13:24:22.645]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.645]                 }
[13:24:22.645]             }
[13:24:22.645]         }
[13:24:22.645]     })
[13:24:22.645]     if (TRUE) {
[13:24:22.645]         base::sink(type = "output", split = FALSE)
[13:24:22.645]         if (TRUE) {
[13:24:22.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.645]         }
[13:24:22.645]         else {
[13:24:22.645]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.645]         }
[13:24:22.645]         base::close(...future.stdout)
[13:24:22.645]         ...future.stdout <- NULL
[13:24:22.645]     }
[13:24:22.645]     ...future.result$conditions <- ...future.conditions
[13:24:22.645]     ...future.result$finished <- base::Sys.time()
[13:24:22.645]     ...future.result
[13:24:22.645] }
[13:24:22.649] requestCore(): workers = 2
[13:24:22.649] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:22.660] result() for MulticoreFuture ...
[13:24:22.661] result() for MulticoreFuture ...
[13:24:22.661] result() for MulticoreFuture ... done
[13:24:22.661] result() for MulticoreFuture ... done
[13:24:22.661] result() for MulticoreFuture ...
[13:24:22.662] result() for MulticoreFuture ... done
[13:24:22.664] MulticoreFuture started
[13:24:22.665] - Launch lazy future ... done
[13:24:22.665] run() for ‘MulticoreFuture’ ... done
[13:24:22.666] plan(): Setting new future strategy stack:
[13:24:22.666] List of future strategies:
[13:24:22.666] 1. sequential:
[13:24:22.666]    - args: function (..., envir = parent.frame())
[13:24:22.666]    - tweaked: FALSE
[13:24:22.666]    - call: NULL
[13:24:22.667] plan(): nbrOfWorkers() = 1
[13:24:22.669] plan(): Setting new future strategy stack:
[13:24:22.669] List of future strategies:
[13:24:22.669] 1. multicore:
[13:24:22.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.669]    - tweaked: FALSE
[13:24:22.669]    - call: plan(strategy)
[13:24:22.674] plan(): nbrOfWorkers() = 2
[13:24:22.675] Future #2
[13:24:22.675]  length: 2 (resolved future 2)
[13:24:22.675]  length: 1 (resolved future 3)
[13:24:22.686] Future #1
[13:24:22.686]  length: 0 (resolved future 1)
[13:24:22.686] resolve() on list ... DONE
[13:24:22.687] getGlobalsAndPackages() ...
[13:24:22.687] Searching for globals...
[13:24:22.688] 
[13:24:22.688] Searching for globals ... DONE
[13:24:22.688] - globals: [0] <none>
[13:24:22.688] getGlobalsAndPackages() ... DONE
[13:24:22.689] run() for ‘Future’ ...
[13:24:22.689] - state: ‘created’
[13:24:22.689] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.694] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.694]   - Field: ‘label’
[13:24:22.694]   - Field: ‘local’
[13:24:22.695]   - Field: ‘owner’
[13:24:22.695]   - Field: ‘envir’
[13:24:22.695]   - Field: ‘workers’
[13:24:22.695]   - Field: ‘packages’
[13:24:22.695]   - Field: ‘gc’
[13:24:22.695]   - Field: ‘job’
[13:24:22.695]   - Field: ‘conditions’
[13:24:22.696]   - Field: ‘expr’
[13:24:22.696]   - Field: ‘uuid’
[13:24:22.696]   - Field: ‘seed’
[13:24:22.696]   - Field: ‘version’
[13:24:22.696]   - Field: ‘result’
[13:24:22.696]   - Field: ‘asynchronous’
[13:24:22.696]   - Field: ‘calls’
[13:24:22.697]   - Field: ‘globals’
[13:24:22.697]   - Field: ‘stdout’
[13:24:22.697]   - Field: ‘earlySignal’
[13:24:22.697]   - Field: ‘lazy’
[13:24:22.697]   - Field: ‘state’
[13:24:22.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.698] - Launch lazy future ...
[13:24:22.698] Packages needed by the future expression (n = 0): <none>
[13:24:22.698] Packages needed by future strategies (n = 0): <none>
[13:24:22.699] {
[13:24:22.699]     {
[13:24:22.699]         {
[13:24:22.699]             ...future.startTime <- base::Sys.time()
[13:24:22.699]             {
[13:24:22.699]                 {
[13:24:22.699]                   {
[13:24:22.699]                     {
[13:24:22.699]                       base::local({
[13:24:22.699]                         has_future <- base::requireNamespace("future", 
[13:24:22.699]                           quietly = TRUE)
[13:24:22.699]                         if (has_future) {
[13:24:22.699]                           ns <- base::getNamespace("future")
[13:24:22.699]                           version <- ns[[".package"]][["version"]]
[13:24:22.699]                           if (is.null(version)) 
[13:24:22.699]                             version <- utils::packageVersion("future")
[13:24:22.699]                         }
[13:24:22.699]                         else {
[13:24:22.699]                           version <- NULL
[13:24:22.699]                         }
[13:24:22.699]                         if (!has_future || version < "1.8.0") {
[13:24:22.699]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.699]                             "", base::R.version$version.string), 
[13:24:22.699]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.699]                               "release", "version")], collapse = " "), 
[13:24:22.699]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.699]                             info)
[13:24:22.699]                           info <- base::paste(info, collapse = "; ")
[13:24:22.699]                           if (!has_future) {
[13:24:22.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.699]                               info)
[13:24:22.699]                           }
[13:24:22.699]                           else {
[13:24:22.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.699]                               info, version)
[13:24:22.699]                           }
[13:24:22.699]                           base::stop(msg)
[13:24:22.699]                         }
[13:24:22.699]                       })
[13:24:22.699]                     }
[13:24:22.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.699]                     base::options(mc.cores = 1L)
[13:24:22.699]                   }
[13:24:22.699]                   options(future.plan = NULL)
[13:24:22.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.699]                 }
[13:24:22.699]                 ...future.workdir <- getwd()
[13:24:22.699]             }
[13:24:22.699]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.699]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.699]         }
[13:24:22.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.699]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.699]             base::names(...future.oldOptions))
[13:24:22.699]     }
[13:24:22.699]     if (FALSE) {
[13:24:22.699]     }
[13:24:22.699]     else {
[13:24:22.699]         if (TRUE) {
[13:24:22.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.699]                 open = "w")
[13:24:22.699]         }
[13:24:22.699]         else {
[13:24:22.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.699]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.699]         }
[13:24:22.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.699]             base::sink(type = "output", split = FALSE)
[13:24:22.699]             base::close(...future.stdout)
[13:24:22.699]         }, add = TRUE)
[13:24:22.699]     }
[13:24:22.699]     ...future.frame <- base::sys.nframe()
[13:24:22.699]     ...future.conditions <- base::list()
[13:24:22.699]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.699]     if (FALSE) {
[13:24:22.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.699]     }
[13:24:22.699]     ...future.result <- base::tryCatch({
[13:24:22.699]         base::withCallingHandlers({
[13:24:22.699]             ...future.value <- base::withVisible(base::local({
[13:24:22.699]                 withCallingHandlers({
[13:24:22.699]                   1
[13:24:22.699]                 }, immediateCondition = function(cond) {
[13:24:22.699]                   save_rds <- function (object, pathname, ...) 
[13:24:22.699]                   {
[13:24:22.699]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.699]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.699]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.699]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.699]                         fi_tmp[["mtime"]])
[13:24:22.699]                     }
[13:24:22.699]                     tryCatch({
[13:24:22.699]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.699]                     }, error = function(ex) {
[13:24:22.699]                       msg <- conditionMessage(ex)
[13:24:22.699]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.699]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.699]                         fi_tmp[["mtime"]], msg)
[13:24:22.699]                       ex$message <- msg
[13:24:22.699]                       stop(ex)
[13:24:22.699]                     })
[13:24:22.699]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.699]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.699]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.699]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.699]                       fi <- file.info(pathname)
[13:24:22.699]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.699]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.699]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.699]                         fi[["size"]], fi[["mtime"]])
[13:24:22.699]                       stop(msg)
[13:24:22.699]                     }
[13:24:22.699]                     invisible(pathname)
[13:24:22.699]                   }
[13:24:22.699]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.699]                     rootPath = tempdir()) 
[13:24:22.699]                   {
[13:24:22.699]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.699]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.699]                       tmpdir = path, fileext = ".rds")
[13:24:22.699]                     save_rds(obj, file)
[13:24:22.699]                   }
[13:24:22.699]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.699]                   {
[13:24:22.699]                     inherits <- base::inherits
[13:24:22.699]                     invokeRestart <- base::invokeRestart
[13:24:22.699]                     is.null <- base::is.null
[13:24:22.699]                     muffled <- FALSE
[13:24:22.699]                     if (inherits(cond, "message")) {
[13:24:22.699]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.699]                       if (muffled) 
[13:24:22.699]                         invokeRestart("muffleMessage")
[13:24:22.699]                     }
[13:24:22.699]                     else if (inherits(cond, "warning")) {
[13:24:22.699]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.699]                       if (muffled) 
[13:24:22.699]                         invokeRestart("muffleWarning")
[13:24:22.699]                     }
[13:24:22.699]                     else if (inherits(cond, "condition")) {
[13:24:22.699]                       if (!is.null(pattern)) {
[13:24:22.699]                         computeRestarts <- base::computeRestarts
[13:24:22.699]                         grepl <- base::grepl
[13:24:22.699]                         restarts <- computeRestarts(cond)
[13:24:22.699]                         for (restart in restarts) {
[13:24:22.699]                           name <- restart$name
[13:24:22.699]                           if (is.null(name)) 
[13:24:22.699]                             next
[13:24:22.699]                           if (!grepl(pattern, name)) 
[13:24:22.699]                             next
[13:24:22.699]                           invokeRestart(restart)
[13:24:22.699]                           muffled <- TRUE
[13:24:22.699]                           break
[13:24:22.699]                         }
[13:24:22.699]                       }
[13:24:22.699]                     }
[13:24:22.699]                     invisible(muffled)
[13:24:22.699]                   }
[13:24:22.699]                   muffleCondition(cond)
[13:24:22.699]                 })
[13:24:22.699]             }))
[13:24:22.699]             future::FutureResult(value = ...future.value$value, 
[13:24:22.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.699]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.699]                     ...future.globalenv.names))
[13:24:22.699]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.699]         }, condition = base::local({
[13:24:22.699]             c <- base::c
[13:24:22.699]             inherits <- base::inherits
[13:24:22.699]             invokeRestart <- base::invokeRestart
[13:24:22.699]             length <- base::length
[13:24:22.699]             list <- base::list
[13:24:22.699]             seq.int <- base::seq.int
[13:24:22.699]             signalCondition <- base::signalCondition
[13:24:22.699]             sys.calls <- base::sys.calls
[13:24:22.699]             `[[` <- base::`[[`
[13:24:22.699]             `+` <- base::`+`
[13:24:22.699]             `<<-` <- base::`<<-`
[13:24:22.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.699]                   3L)]
[13:24:22.699]             }
[13:24:22.699]             function(cond) {
[13:24:22.699]                 is_error <- inherits(cond, "error")
[13:24:22.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.699]                   NULL)
[13:24:22.699]                 if (is_error) {
[13:24:22.699]                   sessionInformation <- function() {
[13:24:22.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.699]                       search = base::search(), system = base::Sys.info())
[13:24:22.699]                   }
[13:24:22.699]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.699]                     cond$call), session = sessionInformation(), 
[13:24:22.699]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.699]                   signalCondition(cond)
[13:24:22.699]                 }
[13:24:22.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.699]                 "immediateCondition"))) {
[13:24:22.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.699]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.699]                   if (TRUE && !signal) {
[13:24:22.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.699]                     {
[13:24:22.699]                       inherits <- base::inherits
[13:24:22.699]                       invokeRestart <- base::invokeRestart
[13:24:22.699]                       is.null <- base::is.null
[13:24:22.699]                       muffled <- FALSE
[13:24:22.699]                       if (inherits(cond, "message")) {
[13:24:22.699]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.699]                         if (muffled) 
[13:24:22.699]                           invokeRestart("muffleMessage")
[13:24:22.699]                       }
[13:24:22.699]                       else if (inherits(cond, "warning")) {
[13:24:22.699]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.699]                         if (muffled) 
[13:24:22.699]                           invokeRestart("muffleWarning")
[13:24:22.699]                       }
[13:24:22.699]                       else if (inherits(cond, "condition")) {
[13:24:22.699]                         if (!is.null(pattern)) {
[13:24:22.699]                           computeRestarts <- base::computeRestarts
[13:24:22.699]                           grepl <- base::grepl
[13:24:22.699]                           restarts <- computeRestarts(cond)
[13:24:22.699]                           for (restart in restarts) {
[13:24:22.699]                             name <- restart$name
[13:24:22.699]                             if (is.null(name)) 
[13:24:22.699]                               next
[13:24:22.699]                             if (!grepl(pattern, name)) 
[13:24:22.699]                               next
[13:24:22.699]                             invokeRestart(restart)
[13:24:22.699]                             muffled <- TRUE
[13:24:22.699]                             break
[13:24:22.699]                           }
[13:24:22.699]                         }
[13:24:22.699]                       }
[13:24:22.699]                       invisible(muffled)
[13:24:22.699]                     }
[13:24:22.699]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.699]                   }
[13:24:22.699]                 }
[13:24:22.699]                 else {
[13:24:22.699]                   if (TRUE) {
[13:24:22.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.699]                     {
[13:24:22.699]                       inherits <- base::inherits
[13:24:22.699]                       invokeRestart <- base::invokeRestart
[13:24:22.699]                       is.null <- base::is.null
[13:24:22.699]                       muffled <- FALSE
[13:24:22.699]                       if (inherits(cond, "message")) {
[13:24:22.699]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.699]                         if (muffled) 
[13:24:22.699]                           invokeRestart("muffleMessage")
[13:24:22.699]                       }
[13:24:22.699]                       else if (inherits(cond, "warning")) {
[13:24:22.699]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.699]                         if (muffled) 
[13:24:22.699]                           invokeRestart("muffleWarning")
[13:24:22.699]                       }
[13:24:22.699]                       else if (inherits(cond, "condition")) {
[13:24:22.699]                         if (!is.null(pattern)) {
[13:24:22.699]                           computeRestarts <- base::computeRestarts
[13:24:22.699]                           grepl <- base::grepl
[13:24:22.699]                           restarts <- computeRestarts(cond)
[13:24:22.699]                           for (restart in restarts) {
[13:24:22.699]                             name <- restart$name
[13:24:22.699]                             if (is.null(name)) 
[13:24:22.699]                               next
[13:24:22.699]                             if (!grepl(pattern, name)) 
[13:24:22.699]                               next
[13:24:22.699]                             invokeRestart(restart)
[13:24:22.699]                             muffled <- TRUE
[13:24:22.699]                             break
[13:24:22.699]                           }
[13:24:22.699]                         }
[13:24:22.699]                       }
[13:24:22.699]                       invisible(muffled)
[13:24:22.699]                     }
[13:24:22.699]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.699]                   }
[13:24:22.699]                 }
[13:24:22.699]             }
[13:24:22.699]         }))
[13:24:22.699]     }, error = function(ex) {
[13:24:22.699]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.699]                 ...future.rng), started = ...future.startTime, 
[13:24:22.699]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.699]             version = "1.8"), class = "FutureResult")
[13:24:22.699]     }, finally = {
[13:24:22.699]         if (!identical(...future.workdir, getwd())) 
[13:24:22.699]             setwd(...future.workdir)
[13:24:22.699]         {
[13:24:22.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.699]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.699]             }
[13:24:22.699]             base::options(...future.oldOptions)
[13:24:22.699]             if (.Platform$OS.type == "windows") {
[13:24:22.699]                 old_names <- names(...future.oldEnvVars)
[13:24:22.699]                 envs <- base::Sys.getenv()
[13:24:22.699]                 names <- names(envs)
[13:24:22.699]                 common <- intersect(names, old_names)
[13:24:22.699]                 added <- setdiff(names, old_names)
[13:24:22.699]                 removed <- setdiff(old_names, names)
[13:24:22.699]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.699]                   envs[common]]
[13:24:22.699]                 NAMES <- toupper(changed)
[13:24:22.699]                 args <- list()
[13:24:22.699]                 for (kk in seq_along(NAMES)) {
[13:24:22.699]                   name <- changed[[kk]]
[13:24:22.699]                   NAME <- NAMES[[kk]]
[13:24:22.699]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.699]                     next
[13:24:22.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.699]                 }
[13:24:22.699]                 NAMES <- toupper(added)
[13:24:22.699]                 for (kk in seq_along(NAMES)) {
[13:24:22.699]                   name <- added[[kk]]
[13:24:22.699]                   NAME <- NAMES[[kk]]
[13:24:22.699]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.699]                     next
[13:24:22.699]                   args[[name]] <- ""
[13:24:22.699]                 }
[13:24:22.699]                 NAMES <- toupper(removed)
[13:24:22.699]                 for (kk in seq_along(NAMES)) {
[13:24:22.699]                   name <- removed[[kk]]
[13:24:22.699]                   NAME <- NAMES[[kk]]
[13:24:22.699]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.699]                     next
[13:24:22.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.699]                 }
[13:24:22.699]                 if (length(args) > 0) 
[13:24:22.699]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.699]             }
[13:24:22.699]             else {
[13:24:22.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.699]             }
[13:24:22.699]             {
[13:24:22.699]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.699]                   0L) {
[13:24:22.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.699]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.699]                   base::options(opts)
[13:24:22.699]                 }
[13:24:22.699]                 {
[13:24:22.699]                   {
[13:24:22.699]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.699]                     NULL
[13:24:22.699]                   }
[13:24:22.699]                   options(future.plan = NULL)
[13:24:22.699]                   if (is.na(NA_character_)) 
[13:24:22.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.699]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.699]                     envir = parent.frame()) 
[13:24:22.699]                   {
[13:24:22.699]                     default_workers <- missing(workers)
[13:24:22.699]                     if (is.function(workers)) 
[13:24:22.699]                       workers <- workers()
[13:24:22.699]                     workers <- structure(as.integer(workers), 
[13:24:22.699]                       class = class(workers))
[13:24:22.699]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.699]                       1L)
[13:24:22.699]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.699]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.699]                       if (default_workers) 
[13:24:22.699]                         supportsMulticore(warn = TRUE)
[13:24:22.699]                       return(sequential(..., envir = envir))
[13:24:22.699]                     }
[13:24:22.699]                     oopts <- options(mc.cores = workers)
[13:24:22.699]                     on.exit(options(oopts))
[13:24:22.699]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.699]                       envir = envir)
[13:24:22.699]                     if (!future$lazy) 
[13:24:22.699]                       future <- run(future)
[13:24:22.699]                     invisible(future)
[13:24:22.699]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.699]                 }
[13:24:22.699]             }
[13:24:22.699]         }
[13:24:22.699]     })
[13:24:22.699]     if (TRUE) {
[13:24:22.699]         base::sink(type = "output", split = FALSE)
[13:24:22.699]         if (TRUE) {
[13:24:22.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.699]         }
[13:24:22.699]         else {
[13:24:22.699]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.699]         }
[13:24:22.699]         base::close(...future.stdout)
[13:24:22.699]         ...future.stdout <- NULL
[13:24:22.699]     }
[13:24:22.699]     ...future.result$conditions <- ...future.conditions
[13:24:22.699]     ...future.result$finished <- base::Sys.time()
[13:24:22.699]     ...future.result
[13:24:22.699] }
[13:24:22.703] requestCore(): workers = 2
[13:24:22.703] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:22.714] result() for MulticoreFuture ...
[13:24:22.715] result() for MulticoreFuture ...
[13:24:22.719] result() for MulticoreFuture ... done
[13:24:22.719] result() for MulticoreFuture ... done
[13:24:22.720] result() for MulticoreFuture ...
[13:24:22.720] result() for MulticoreFuture ... done
[13:24:22.723] MulticoreFuture started
[13:24:22.723] - Launch lazy future ... done
[13:24:22.724] run() for ‘MulticoreFuture’ ... done
[13:24:22.724] plan(): Setting new future strategy stack:
[13:24:22.725] getGlobalsAndPackages() ...
[13:24:22.725] Searching for globals...
[13:24:22.725] List of future strategies:
[13:24:22.725] 1. sequential:
[13:24:22.725]    - args: function (..., envir = parent.frame())
[13:24:22.725]    - tweaked: FALSE
[13:24:22.725]    - call: NULL
[13:24:22.726] plan(): nbrOfWorkers() = 1
[13:24:22.729] plan(): Setting new future strategy stack:
[13:24:22.729] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:24:22.729] Searching for globals ... DONE
[13:24:22.729] Resolving globals: FALSE
[13:24:22.729] List of future strategies:
[13:24:22.729] 1. multicore:
[13:24:22.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:22.729]    - tweaked: FALSE
[13:24:22.729]    - call: plan(strategy)
[13:24:22.730] 
[13:24:22.730] 
[13:24:22.730] getGlobalsAndPackages() ... DONE
[13:24:22.731] run() for ‘Future’ ...
[13:24:22.731] - state: ‘created’
[13:24:22.731] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:22.734] plan(): nbrOfWorkers() = 2
[13:24:22.737] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:22.737] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:22.737]   - Field: ‘label’
[13:24:22.737]   - Field: ‘local’
[13:24:22.738]   - Field: ‘owner’
[13:24:22.738]   - Field: ‘envir’
[13:24:22.738]   - Field: ‘workers’
[13:24:22.738]   - Field: ‘packages’
[13:24:22.738]   - Field: ‘gc’
[13:24:22.738]   - Field: ‘job’
[13:24:22.738]   - Field: ‘conditions’
[13:24:22.739]   - Field: ‘expr’
[13:24:22.739]   - Field: ‘uuid’
[13:24:22.739]   - Field: ‘seed’
[13:24:22.739]   - Field: ‘version’
[13:24:22.739]   - Field: ‘result’
[13:24:22.739]   - Field: ‘asynchronous’
[13:24:22.740]   - Field: ‘calls’
[13:24:22.740]   - Field: ‘globals’
[13:24:22.740]   - Field: ‘stdout’
[13:24:22.740]   - Field: ‘earlySignal’
[13:24:22.740]   - Field: ‘lazy’
[13:24:22.740]   - Field: ‘state’
[13:24:22.740] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:22.741] - Launch lazy future ...
[13:24:22.741] Packages needed by the future expression (n = 0): <none>
[13:24:22.741] Packages needed by future strategies (n = 0): <none>
[13:24:22.742] {
[13:24:22.742]     {
[13:24:22.742]         {
[13:24:22.742]             ...future.startTime <- base::Sys.time()
[13:24:22.742]             {
[13:24:22.742]                 {
[13:24:22.742]                   {
[13:24:22.742]                     {
[13:24:22.742]                       base::local({
[13:24:22.742]                         has_future <- base::requireNamespace("future", 
[13:24:22.742]                           quietly = TRUE)
[13:24:22.742]                         if (has_future) {
[13:24:22.742]                           ns <- base::getNamespace("future")
[13:24:22.742]                           version <- ns[[".package"]][["version"]]
[13:24:22.742]                           if (is.null(version)) 
[13:24:22.742]                             version <- utils::packageVersion("future")
[13:24:22.742]                         }
[13:24:22.742]                         else {
[13:24:22.742]                           version <- NULL
[13:24:22.742]                         }
[13:24:22.742]                         if (!has_future || version < "1.8.0") {
[13:24:22.742]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:22.742]                             "", base::R.version$version.string), 
[13:24:22.742]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:22.742]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:22.742]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:22.742]                               "release", "version")], collapse = " "), 
[13:24:22.742]                             hostname = base::Sys.info()[["nodename"]])
[13:24:22.742]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:22.742]                             info)
[13:24:22.742]                           info <- base::paste(info, collapse = "; ")
[13:24:22.742]                           if (!has_future) {
[13:24:22.742]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:22.742]                               info)
[13:24:22.742]                           }
[13:24:22.742]                           else {
[13:24:22.742]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:22.742]                               info, version)
[13:24:22.742]                           }
[13:24:22.742]                           base::stop(msg)
[13:24:22.742]                         }
[13:24:22.742]                       })
[13:24:22.742]                     }
[13:24:22.742]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:22.742]                     base::options(mc.cores = 1L)
[13:24:22.742]                   }
[13:24:22.742]                   options(future.plan = NULL)
[13:24:22.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:22.742]                 }
[13:24:22.742]                 ...future.workdir <- getwd()
[13:24:22.742]             }
[13:24:22.742]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:22.742]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:22.742]         }
[13:24:22.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:22.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:22.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:22.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:22.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:22.742]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:22.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:22.742]             base::names(...future.oldOptions))
[13:24:22.742]     }
[13:24:22.742]     if (FALSE) {
[13:24:22.742]     }
[13:24:22.742]     else {
[13:24:22.742]         if (TRUE) {
[13:24:22.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:22.742]                 open = "w")
[13:24:22.742]         }
[13:24:22.742]         else {
[13:24:22.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:22.742]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:22.742]         }
[13:24:22.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:22.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:22.742]             base::sink(type = "output", split = FALSE)
[13:24:22.742]             base::close(...future.stdout)
[13:24:22.742]         }, add = TRUE)
[13:24:22.742]     }
[13:24:22.742]     ...future.frame <- base::sys.nframe()
[13:24:22.742]     ...future.conditions <- base::list()
[13:24:22.742]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:22.742]     if (FALSE) {
[13:24:22.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:22.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:22.742]     }
[13:24:22.742]     ...future.result <- base::tryCatch({
[13:24:22.742]         base::withCallingHandlers({
[13:24:22.742]             ...future.value <- base::withVisible(base::local({
[13:24:22.742]                 withCallingHandlers({
[13:24:22.742]                   {
[13:24:22.742]                     Sys.sleep(0.5)
[13:24:22.742]                     2
[13:24:22.742]                   }
[13:24:22.742]                 }, immediateCondition = function(cond) {
[13:24:22.742]                   save_rds <- function (object, pathname, ...) 
[13:24:22.742]                   {
[13:24:22.742]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:22.742]                     if (file_test("-f", pathname_tmp)) {
[13:24:22.742]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.742]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:22.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.742]                         fi_tmp[["mtime"]])
[13:24:22.742]                     }
[13:24:22.742]                     tryCatch({
[13:24:22.742]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:22.742]                     }, error = function(ex) {
[13:24:22.742]                       msg <- conditionMessage(ex)
[13:24:22.742]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.742]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:22.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.742]                         fi_tmp[["mtime"]], msg)
[13:24:22.742]                       ex$message <- msg
[13:24:22.742]                       stop(ex)
[13:24:22.742]                     })
[13:24:22.742]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:22.742]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:22.742]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:22.742]                       fi_tmp <- file.info(pathname_tmp)
[13:24:22.742]                       fi <- file.info(pathname)
[13:24:22.742]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:22.742]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:22.742]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:22.742]                         fi[["size"]], fi[["mtime"]])
[13:24:22.742]                       stop(msg)
[13:24:22.742]                     }
[13:24:22.742]                     invisible(pathname)
[13:24:22.742]                   }
[13:24:22.742]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:22.742]                     rootPath = tempdir()) 
[13:24:22.742]                   {
[13:24:22.742]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:22.742]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:22.742]                       tmpdir = path, fileext = ".rds")
[13:24:22.742]                     save_rds(obj, file)
[13:24:22.742]                   }
[13:24:22.742]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:22.742]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.742]                   {
[13:24:22.742]                     inherits <- base::inherits
[13:24:22.742]                     invokeRestart <- base::invokeRestart
[13:24:22.742]                     is.null <- base::is.null
[13:24:22.742]                     muffled <- FALSE
[13:24:22.742]                     if (inherits(cond, "message")) {
[13:24:22.742]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:22.742]                       if (muffled) 
[13:24:22.742]                         invokeRestart("muffleMessage")
[13:24:22.742]                     }
[13:24:22.742]                     else if (inherits(cond, "warning")) {
[13:24:22.742]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:22.742]                       if (muffled) 
[13:24:22.742]                         invokeRestart("muffleWarning")
[13:24:22.742]                     }
[13:24:22.742]                     else if (inherits(cond, "condition")) {
[13:24:22.742]                       if (!is.null(pattern)) {
[13:24:22.742]                         computeRestarts <- base::computeRestarts
[13:24:22.742]                         grepl <- base::grepl
[13:24:22.742]                         restarts <- computeRestarts(cond)
[13:24:22.742]                         for (restart in restarts) {
[13:24:22.742]                           name <- restart$name
[13:24:22.742]                           if (is.null(name)) 
[13:24:22.742]                             next
[13:24:22.742]                           if (!grepl(pattern, name)) 
[13:24:22.742]                             next
[13:24:22.742]                           invokeRestart(restart)
[13:24:22.742]                           muffled <- TRUE
[13:24:22.742]                           break
[13:24:22.742]                         }
[13:24:22.742]                       }
[13:24:22.742]                     }
[13:24:22.742]                     invisible(muffled)
[13:24:22.742]                   }
[13:24:22.742]                   muffleCondition(cond)
[13:24:22.742]                 })
[13:24:22.742]             }))
[13:24:22.742]             future::FutureResult(value = ...future.value$value, 
[13:24:22.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.742]                   ...future.rng), globalenv = if (FALSE) 
[13:24:22.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:22.742]                     ...future.globalenv.names))
[13:24:22.742]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:22.742]         }, condition = base::local({
[13:24:22.742]             c <- base::c
[13:24:22.742]             inherits <- base::inherits
[13:24:22.742]             invokeRestart <- base::invokeRestart
[13:24:22.742]             length <- base::length
[13:24:22.742]             list <- base::list
[13:24:22.742]             seq.int <- base::seq.int
[13:24:22.742]             signalCondition <- base::signalCondition
[13:24:22.742]             sys.calls <- base::sys.calls
[13:24:22.742]             `[[` <- base::`[[`
[13:24:22.742]             `+` <- base::`+`
[13:24:22.742]             `<<-` <- base::`<<-`
[13:24:22.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:22.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:22.742]                   3L)]
[13:24:22.742]             }
[13:24:22.742]             function(cond) {
[13:24:22.742]                 is_error <- inherits(cond, "error")
[13:24:22.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:22.742]                   NULL)
[13:24:22.742]                 if (is_error) {
[13:24:22.742]                   sessionInformation <- function() {
[13:24:22.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:22.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:22.742]                       search = base::search(), system = base::Sys.info())
[13:24:22.742]                   }
[13:24:22.742]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:22.742]                     cond$call), session = sessionInformation(), 
[13:24:22.742]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:22.742]                   signalCondition(cond)
[13:24:22.742]                 }
[13:24:22.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:22.742]                 "immediateCondition"))) {
[13:24:22.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:22.742]                   ...future.conditions[[length(...future.conditions) + 
[13:24:22.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:22.742]                   if (TRUE && !signal) {
[13:24:22.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.742]                     {
[13:24:22.742]                       inherits <- base::inherits
[13:24:22.742]                       invokeRestart <- base::invokeRestart
[13:24:22.742]                       is.null <- base::is.null
[13:24:22.742]                       muffled <- FALSE
[13:24:22.742]                       if (inherits(cond, "message")) {
[13:24:22.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.742]                         if (muffled) 
[13:24:22.742]                           invokeRestart("muffleMessage")
[13:24:22.742]                       }
[13:24:22.742]                       else if (inherits(cond, "warning")) {
[13:24:22.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.742]                         if (muffled) 
[13:24:22.742]                           invokeRestart("muffleWarning")
[13:24:22.742]                       }
[13:24:22.742]                       else if (inherits(cond, "condition")) {
[13:24:22.742]                         if (!is.null(pattern)) {
[13:24:22.742]                           computeRestarts <- base::computeRestarts
[13:24:22.742]                           grepl <- base::grepl
[13:24:22.742]                           restarts <- computeRestarts(cond)
[13:24:22.742]                           for (restart in restarts) {
[13:24:22.742]                             name <- restart$name
[13:24:22.742]                             if (is.null(name)) 
[13:24:22.742]                               next
[13:24:22.742]                             if (!grepl(pattern, name)) 
[13:24:22.742]                               next
[13:24:22.742]                             invokeRestart(restart)
[13:24:22.742]                             muffled <- TRUE
[13:24:22.742]                             break
[13:24:22.742]                           }
[13:24:22.742]                         }
[13:24:22.742]                       }
[13:24:22.742]                       invisible(muffled)
[13:24:22.742]                     }
[13:24:22.742]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.742]                   }
[13:24:22.742]                 }
[13:24:22.742]                 else {
[13:24:22.742]                   if (TRUE) {
[13:24:22.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:22.742]                     {
[13:24:22.742]                       inherits <- base::inherits
[13:24:22.742]                       invokeRestart <- base::invokeRestart
[13:24:22.742]                       is.null <- base::is.null
[13:24:22.742]                       muffled <- FALSE
[13:24:22.742]                       if (inherits(cond, "message")) {
[13:24:22.742]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:22.742]                         if (muffled) 
[13:24:22.742]                           invokeRestart("muffleMessage")
[13:24:22.742]                       }
[13:24:22.742]                       else if (inherits(cond, "warning")) {
[13:24:22.742]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:22.742]                         if (muffled) 
[13:24:22.742]                           invokeRestart("muffleWarning")
[13:24:22.742]                       }
[13:24:22.742]                       else if (inherits(cond, "condition")) {
[13:24:22.742]                         if (!is.null(pattern)) {
[13:24:22.742]                           computeRestarts <- base::computeRestarts
[13:24:22.742]                           grepl <- base::grepl
[13:24:22.742]                           restarts <- computeRestarts(cond)
[13:24:22.742]                           for (restart in restarts) {
[13:24:22.742]                             name <- restart$name
[13:24:22.742]                             if (is.null(name)) 
[13:24:22.742]                               next
[13:24:22.742]                             if (!grepl(pattern, name)) 
[13:24:22.742]                               next
[13:24:22.742]                             invokeRestart(restart)
[13:24:22.742]                             muffled <- TRUE
[13:24:22.742]                             break
[13:24:22.742]                           }
[13:24:22.742]                         }
[13:24:22.742]                       }
[13:24:22.742]                       invisible(muffled)
[13:24:22.742]                     }
[13:24:22.742]                     muffleCondition(cond, pattern = "^muffle")
[13:24:22.742]                   }
[13:24:22.742]                 }
[13:24:22.742]             }
[13:24:22.742]         }))
[13:24:22.742]     }, error = function(ex) {
[13:24:22.742]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:22.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:22.742]                 ...future.rng), started = ...future.startTime, 
[13:24:22.742]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:22.742]             version = "1.8"), class = "FutureResult")
[13:24:22.742]     }, finally = {
[13:24:22.742]         if (!identical(...future.workdir, getwd())) 
[13:24:22.742]             setwd(...future.workdir)
[13:24:22.742]         {
[13:24:22.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:22.742]                 ...future.oldOptions$nwarnings <- NULL
[13:24:22.742]             }
[13:24:22.742]             base::options(...future.oldOptions)
[13:24:22.742]             if (.Platform$OS.type == "windows") {
[13:24:22.742]                 old_names <- names(...future.oldEnvVars)
[13:24:22.742]                 envs <- base::Sys.getenv()
[13:24:22.742]                 names <- names(envs)
[13:24:22.742]                 common <- intersect(names, old_names)
[13:24:22.742]                 added <- setdiff(names, old_names)
[13:24:22.742]                 removed <- setdiff(old_names, names)
[13:24:22.742]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:22.742]                   envs[common]]
[13:24:22.742]                 NAMES <- toupper(changed)
[13:24:22.742]                 args <- list()
[13:24:22.742]                 for (kk in seq_along(NAMES)) {
[13:24:22.742]                   name <- changed[[kk]]
[13:24:22.742]                   NAME <- NAMES[[kk]]
[13:24:22.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.742]                     next
[13:24:22.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.742]                 }
[13:24:22.742]                 NAMES <- toupper(added)
[13:24:22.742]                 for (kk in seq_along(NAMES)) {
[13:24:22.742]                   name <- added[[kk]]
[13:24:22.742]                   NAME <- NAMES[[kk]]
[13:24:22.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.742]                     next
[13:24:22.742]                   args[[name]] <- ""
[13:24:22.742]                 }
[13:24:22.742]                 NAMES <- toupper(removed)
[13:24:22.742]                 for (kk in seq_along(NAMES)) {
[13:24:22.742]                   name <- removed[[kk]]
[13:24:22.742]                   NAME <- NAMES[[kk]]
[13:24:22.742]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:22.742]                     next
[13:24:22.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:22.742]                 }
[13:24:22.742]                 if (length(args) > 0) 
[13:24:22.742]                   base::do.call(base::Sys.setenv, args = args)
[13:24:22.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:22.742]             }
[13:24:22.742]             else {
[13:24:22.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:22.742]             }
[13:24:22.742]             {
[13:24:22.742]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:22.742]                   0L) {
[13:24:22.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:22.742]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:22.742]                   base::options(opts)
[13:24:22.742]                 }
[13:24:22.742]                 {
[13:24:22.742]                   {
[13:24:22.742]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:22.742]                     NULL
[13:24:22.742]                   }
[13:24:22.742]                   options(future.plan = NULL)
[13:24:22.742]                   if (is.na(NA_character_)) 
[13:24:22.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:22.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:22.742]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:22.742]                     envir = parent.frame()) 
[13:24:22.742]                   {
[13:24:22.742]                     default_workers <- missing(workers)
[13:24:22.742]                     if (is.function(workers)) 
[13:24:22.742]                       workers <- workers()
[13:24:22.742]                     workers <- structure(as.integer(workers), 
[13:24:22.742]                       class = class(workers))
[13:24:22.742]                     stop_if_not(is.finite(workers), workers >= 
[13:24:22.742]                       1L)
[13:24:22.742]                     if ((workers == 1L && !inherits(workers, 
[13:24:22.742]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:22.742]                       if (default_workers) 
[13:24:22.742]                         supportsMulticore(warn = TRUE)
[13:24:22.742]                       return(sequential(..., envir = envir))
[13:24:22.742]                     }
[13:24:22.742]                     oopts <- options(mc.cores = workers)
[13:24:22.742]                     on.exit(options(oopts))
[13:24:22.742]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:22.742]                       envir = envir)
[13:24:22.742]                     if (!future$lazy) 
[13:24:22.742]                       future <- run(future)
[13:24:22.742]                     invisible(future)
[13:24:22.742]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:22.742]                 }
[13:24:22.742]             }
[13:24:22.742]         }
[13:24:22.742]     })
[13:24:22.742]     if (TRUE) {
[13:24:22.742]         base::sink(type = "output", split = FALSE)
[13:24:22.742]         if (TRUE) {
[13:24:22.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:22.742]         }
[13:24:22.742]         else {
[13:24:22.742]             ...future.result["stdout"] <- base::list(NULL)
[13:24:22.742]         }
[13:24:22.742]         base::close(...future.stdout)
[13:24:22.742]         ...future.stdout <- NULL
[13:24:22.742]     }
[13:24:22.742]     ...future.result$conditions <- ...future.conditions
[13:24:22.742]     ...future.result$finished <- base::Sys.time()
[13:24:22.742]     ...future.result
[13:24:22.742] }
[13:24:22.746] requestCore(): workers = 2
[13:24:22.746] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:22.757] result() for MulticoreFuture ...
[13:24:22.757] result() for MulticoreFuture ...
[13:24:22.758] result() for MulticoreFuture ... done
[13:24:22.758] result() for MulticoreFuture ... done
[13:24:22.758] result() for MulticoreFuture ...
[13:24:22.758] result() for MulticoreFuture ... done
[13:24:22.760] MulticoreFuture started
[13:24:22.761] - Launch lazy future ... done
[13:24:22.761] run() for ‘MulticoreFuture’ ... done
[13:24:22.762] plan(): Setting new future strategy stack:
[13:24:22.762] resolve() on list ...
[13:24:22.762]  recursive: 0
[13:24:22.763]  length: 1
[13:24:22.763] 
[13:24:22.762] List of future strategies:
[13:24:22.762] 1. sequential:
[13:24:22.762]    - args: function (..., envir = parent.frame())
[13:24:22.762]    - tweaked: FALSE
[13:24:22.762]    - call: NULL
[13:24:22.763] plan(): nbrOfWorkers() = 1
[13:24:22.763] Future #1
[13:24:22.764]  length: 0 (resolved future 1)
[13:24:22.764] resolve() on list ... DONE
[13:24:22.765] resolve() on list ...
[13:24:22.765]  recursive: 0
[13:24:22.765]  length: 1
[13:24:22.765] 
[13:24:23.267] plan(): Setting new future strategy stack:
[13:24:23.267] List of future strategies:
[13:24:23.267] 1. multicore:
[13:24:23.267]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.267]    - tweaked: FALSE
[13:24:23.267]    - call: plan(strategy)
[13:24:23.273] plan(): nbrOfWorkers() = 2
[13:24:23.277] Future #1
[13:24:23.277]  length: 0 (resolved future 1)
[13:24:23.277] resolve() on list ... DONE
[13:24:23.278] resolve() on list ...
[13:24:23.278]  recursive: 0
[13:24:23.278]  length: 1
[13:24:23.278] 
[13:24:23.278]  length: 0 (resolved future 1)
[13:24:23.279] resolve() on list ... DONE
[13:24:23.279] resolve() on list ...
[13:24:23.279]  recursive: 0
[13:24:23.279]  length: 4
[13:24:23.279] 
[13:24:23.280] Future #1
[13:24:23.280]  length: 3 (resolved future 1)
[13:24:23.280] Future #2
[13:24:23.280]  length: 2 (resolved future 2)
[13:24:23.281]  length: 1 (resolved future 3)
[13:24:23.281]  length: 0 (resolved future 4)
[13:24:23.281] resolve() on list ... DONE
[13:24:23.281] resolve() on list ...
[13:24:23.281]  recursive: 0
[13:24:23.281]  length: 4
[13:24:23.282] 
[13:24:23.282] Future #1
[13:24:23.282]  length: 3 (resolved future 1)
[13:24:23.282] Future #2
[13:24:23.283]  length: 2 (resolved future 2)
[13:24:23.283]  length: 1 (resolved future 3)
[13:24:23.283]  length: 0 (resolved future 4)
[13:24:23.283] resolve() on list ... DONE
[13:24:23.283] resolve() on list ...
[13:24:23.283]  recursive: 0
[13:24:23.284]  length: 1
[13:24:23.284] 
[13:24:23.284]  length: 0 (resolved future 1)
[13:24:23.284] resolve() on list ... DONE
[13:24:23.284] getGlobalsAndPackages() ...
[13:24:23.284] Searching for globals...
[13:24:23.286] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:23.287] Searching for globals ... DONE
[13:24:23.287] Resolving globals: FALSE
[13:24:23.287] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:23.288] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:23.288] - globals: [1] ‘kk’
[13:24:23.289] 
[13:24:23.289] getGlobalsAndPackages() ... DONE
[13:24:23.289] run() for ‘Future’ ...
[13:24:23.289] - state: ‘created’
[13:24:23.289] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.295] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.295] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.295]   - Field: ‘label’
[13:24:23.295]   - Field: ‘local’
[13:24:23.295]   - Field: ‘owner’
[13:24:23.295]   - Field: ‘envir’
[13:24:23.296]   - Field: ‘workers’
[13:24:23.296]   - Field: ‘packages’
[13:24:23.296]   - Field: ‘gc’
[13:24:23.296]   - Field: ‘job’
[13:24:23.296]   - Field: ‘conditions’
[13:24:23.296]   - Field: ‘expr’
[13:24:23.296]   - Field: ‘uuid’
[13:24:23.297]   - Field: ‘seed’
[13:24:23.297]   - Field: ‘version’
[13:24:23.297]   - Field: ‘result’
[13:24:23.297]   - Field: ‘asynchronous’
[13:24:23.301]   - Field: ‘calls’
[13:24:23.301]   - Field: ‘globals’
[13:24:23.301]   - Field: ‘stdout’
[13:24:23.301]   - Field: ‘earlySignal’
[13:24:23.302]   - Field: ‘lazy’
[13:24:23.302]   - Field: ‘state’
[13:24:23.302] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.302] - Launch lazy future ...
[13:24:23.303] Packages needed by the future expression (n = 0): <none>
[13:24:23.303] Packages needed by future strategies (n = 0): <none>
[13:24:23.304] {
[13:24:23.304]     {
[13:24:23.304]         {
[13:24:23.304]             ...future.startTime <- base::Sys.time()
[13:24:23.304]             {
[13:24:23.304]                 {
[13:24:23.304]                   {
[13:24:23.304]                     {
[13:24:23.304]                       base::local({
[13:24:23.304]                         has_future <- base::requireNamespace("future", 
[13:24:23.304]                           quietly = TRUE)
[13:24:23.304]                         if (has_future) {
[13:24:23.304]                           ns <- base::getNamespace("future")
[13:24:23.304]                           version <- ns[[".package"]][["version"]]
[13:24:23.304]                           if (is.null(version)) 
[13:24:23.304]                             version <- utils::packageVersion("future")
[13:24:23.304]                         }
[13:24:23.304]                         else {
[13:24:23.304]                           version <- NULL
[13:24:23.304]                         }
[13:24:23.304]                         if (!has_future || version < "1.8.0") {
[13:24:23.304]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.304]                             "", base::R.version$version.string), 
[13:24:23.304]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.304]                               "release", "version")], collapse = " "), 
[13:24:23.304]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.304]                             info)
[13:24:23.304]                           info <- base::paste(info, collapse = "; ")
[13:24:23.304]                           if (!has_future) {
[13:24:23.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.304]                               info)
[13:24:23.304]                           }
[13:24:23.304]                           else {
[13:24:23.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.304]                               info, version)
[13:24:23.304]                           }
[13:24:23.304]                           base::stop(msg)
[13:24:23.304]                         }
[13:24:23.304]                       })
[13:24:23.304]                     }
[13:24:23.304]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.304]                     base::options(mc.cores = 1L)
[13:24:23.304]                   }
[13:24:23.304]                   options(future.plan = NULL)
[13:24:23.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.304]                 }
[13:24:23.304]                 ...future.workdir <- getwd()
[13:24:23.304]             }
[13:24:23.304]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.304]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.304]         }
[13:24:23.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.304]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.304]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.304]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.304]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.304]             base::names(...future.oldOptions))
[13:24:23.304]     }
[13:24:23.304]     if (FALSE) {
[13:24:23.304]     }
[13:24:23.304]     else {
[13:24:23.304]         if (TRUE) {
[13:24:23.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.304]                 open = "w")
[13:24:23.304]         }
[13:24:23.304]         else {
[13:24:23.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.304]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.304]         }
[13:24:23.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.304]             base::sink(type = "output", split = FALSE)
[13:24:23.304]             base::close(...future.stdout)
[13:24:23.304]         }, add = TRUE)
[13:24:23.304]     }
[13:24:23.304]     ...future.frame <- base::sys.nframe()
[13:24:23.304]     ...future.conditions <- base::list()
[13:24:23.304]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.304]     if (FALSE) {
[13:24:23.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.304]     }
[13:24:23.304]     ...future.result <- base::tryCatch({
[13:24:23.304]         base::withCallingHandlers({
[13:24:23.304]             ...future.value <- base::withVisible(base::local({
[13:24:23.304]                 withCallingHandlers({
[13:24:23.304]                   {
[13:24:23.304]                     Sys.sleep(0.1)
[13:24:23.304]                     kk
[13:24:23.304]                   }
[13:24:23.304]                 }, immediateCondition = function(cond) {
[13:24:23.304]                   save_rds <- function (object, pathname, ...) 
[13:24:23.304]                   {
[13:24:23.304]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.304]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.304]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.304]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.304]                         fi_tmp[["mtime"]])
[13:24:23.304]                     }
[13:24:23.304]                     tryCatch({
[13:24:23.304]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.304]                     }, error = function(ex) {
[13:24:23.304]                       msg <- conditionMessage(ex)
[13:24:23.304]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.304]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.304]                         fi_tmp[["mtime"]], msg)
[13:24:23.304]                       ex$message <- msg
[13:24:23.304]                       stop(ex)
[13:24:23.304]                     })
[13:24:23.304]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.304]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.304]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.304]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.304]                       fi <- file.info(pathname)
[13:24:23.304]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.304]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.304]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.304]                         fi[["size"]], fi[["mtime"]])
[13:24:23.304]                       stop(msg)
[13:24:23.304]                     }
[13:24:23.304]                     invisible(pathname)
[13:24:23.304]                   }
[13:24:23.304]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.304]                     rootPath = tempdir()) 
[13:24:23.304]                   {
[13:24:23.304]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.304]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.304]                       tmpdir = path, fileext = ".rds")
[13:24:23.304]                     save_rds(obj, file)
[13:24:23.304]                   }
[13:24:23.304]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.304]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.304]                   {
[13:24:23.304]                     inherits <- base::inherits
[13:24:23.304]                     invokeRestart <- base::invokeRestart
[13:24:23.304]                     is.null <- base::is.null
[13:24:23.304]                     muffled <- FALSE
[13:24:23.304]                     if (inherits(cond, "message")) {
[13:24:23.304]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.304]                       if (muffled) 
[13:24:23.304]                         invokeRestart("muffleMessage")
[13:24:23.304]                     }
[13:24:23.304]                     else if (inherits(cond, "warning")) {
[13:24:23.304]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.304]                       if (muffled) 
[13:24:23.304]                         invokeRestart("muffleWarning")
[13:24:23.304]                     }
[13:24:23.304]                     else if (inherits(cond, "condition")) {
[13:24:23.304]                       if (!is.null(pattern)) {
[13:24:23.304]                         computeRestarts <- base::computeRestarts
[13:24:23.304]                         grepl <- base::grepl
[13:24:23.304]                         restarts <- computeRestarts(cond)
[13:24:23.304]                         for (restart in restarts) {
[13:24:23.304]                           name <- restart$name
[13:24:23.304]                           if (is.null(name)) 
[13:24:23.304]                             next
[13:24:23.304]                           if (!grepl(pattern, name)) 
[13:24:23.304]                             next
[13:24:23.304]                           invokeRestart(restart)
[13:24:23.304]                           muffled <- TRUE
[13:24:23.304]                           break
[13:24:23.304]                         }
[13:24:23.304]                       }
[13:24:23.304]                     }
[13:24:23.304]                     invisible(muffled)
[13:24:23.304]                   }
[13:24:23.304]                   muffleCondition(cond)
[13:24:23.304]                 })
[13:24:23.304]             }))
[13:24:23.304]             future::FutureResult(value = ...future.value$value, 
[13:24:23.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.304]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.304]                     ...future.globalenv.names))
[13:24:23.304]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.304]         }, condition = base::local({
[13:24:23.304]             c <- base::c
[13:24:23.304]             inherits <- base::inherits
[13:24:23.304]             invokeRestart <- base::invokeRestart
[13:24:23.304]             length <- base::length
[13:24:23.304]             list <- base::list
[13:24:23.304]             seq.int <- base::seq.int
[13:24:23.304]             signalCondition <- base::signalCondition
[13:24:23.304]             sys.calls <- base::sys.calls
[13:24:23.304]             `[[` <- base::`[[`
[13:24:23.304]             `+` <- base::`+`
[13:24:23.304]             `<<-` <- base::`<<-`
[13:24:23.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.304]                   3L)]
[13:24:23.304]             }
[13:24:23.304]             function(cond) {
[13:24:23.304]                 is_error <- inherits(cond, "error")
[13:24:23.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.304]                   NULL)
[13:24:23.304]                 if (is_error) {
[13:24:23.304]                   sessionInformation <- function() {
[13:24:23.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.304]                       search = base::search(), system = base::Sys.info())
[13:24:23.304]                   }
[13:24:23.304]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.304]                     cond$call), session = sessionInformation(), 
[13:24:23.304]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.304]                   signalCondition(cond)
[13:24:23.304]                 }
[13:24:23.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.304]                 "immediateCondition"))) {
[13:24:23.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.304]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.304]                   if (TRUE && !signal) {
[13:24:23.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.304]                     {
[13:24:23.304]                       inherits <- base::inherits
[13:24:23.304]                       invokeRestart <- base::invokeRestart
[13:24:23.304]                       is.null <- base::is.null
[13:24:23.304]                       muffled <- FALSE
[13:24:23.304]                       if (inherits(cond, "message")) {
[13:24:23.304]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.304]                         if (muffled) 
[13:24:23.304]                           invokeRestart("muffleMessage")
[13:24:23.304]                       }
[13:24:23.304]                       else if (inherits(cond, "warning")) {
[13:24:23.304]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.304]                         if (muffled) 
[13:24:23.304]                           invokeRestart("muffleWarning")
[13:24:23.304]                       }
[13:24:23.304]                       else if (inherits(cond, "condition")) {
[13:24:23.304]                         if (!is.null(pattern)) {
[13:24:23.304]                           computeRestarts <- base::computeRestarts
[13:24:23.304]                           grepl <- base::grepl
[13:24:23.304]                           restarts <- computeRestarts(cond)
[13:24:23.304]                           for (restart in restarts) {
[13:24:23.304]                             name <- restart$name
[13:24:23.304]                             if (is.null(name)) 
[13:24:23.304]                               next
[13:24:23.304]                             if (!grepl(pattern, name)) 
[13:24:23.304]                               next
[13:24:23.304]                             invokeRestart(restart)
[13:24:23.304]                             muffled <- TRUE
[13:24:23.304]                             break
[13:24:23.304]                           }
[13:24:23.304]                         }
[13:24:23.304]                       }
[13:24:23.304]                       invisible(muffled)
[13:24:23.304]                     }
[13:24:23.304]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.304]                   }
[13:24:23.304]                 }
[13:24:23.304]                 else {
[13:24:23.304]                   if (TRUE) {
[13:24:23.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.304]                     {
[13:24:23.304]                       inherits <- base::inherits
[13:24:23.304]                       invokeRestart <- base::invokeRestart
[13:24:23.304]                       is.null <- base::is.null
[13:24:23.304]                       muffled <- FALSE
[13:24:23.304]                       if (inherits(cond, "message")) {
[13:24:23.304]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.304]                         if (muffled) 
[13:24:23.304]                           invokeRestart("muffleMessage")
[13:24:23.304]                       }
[13:24:23.304]                       else if (inherits(cond, "warning")) {
[13:24:23.304]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.304]                         if (muffled) 
[13:24:23.304]                           invokeRestart("muffleWarning")
[13:24:23.304]                       }
[13:24:23.304]                       else if (inherits(cond, "condition")) {
[13:24:23.304]                         if (!is.null(pattern)) {
[13:24:23.304]                           computeRestarts <- base::computeRestarts
[13:24:23.304]                           grepl <- base::grepl
[13:24:23.304]                           restarts <- computeRestarts(cond)
[13:24:23.304]                           for (restart in restarts) {
[13:24:23.304]                             name <- restart$name
[13:24:23.304]                             if (is.null(name)) 
[13:24:23.304]                               next
[13:24:23.304]                             if (!grepl(pattern, name)) 
[13:24:23.304]                               next
[13:24:23.304]                             invokeRestart(restart)
[13:24:23.304]                             muffled <- TRUE
[13:24:23.304]                             break
[13:24:23.304]                           }
[13:24:23.304]                         }
[13:24:23.304]                       }
[13:24:23.304]                       invisible(muffled)
[13:24:23.304]                     }
[13:24:23.304]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.304]                   }
[13:24:23.304]                 }
[13:24:23.304]             }
[13:24:23.304]         }))
[13:24:23.304]     }, error = function(ex) {
[13:24:23.304]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.304]                 ...future.rng), started = ...future.startTime, 
[13:24:23.304]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.304]             version = "1.8"), class = "FutureResult")
[13:24:23.304]     }, finally = {
[13:24:23.304]         if (!identical(...future.workdir, getwd())) 
[13:24:23.304]             setwd(...future.workdir)
[13:24:23.304]         {
[13:24:23.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.304]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.304]             }
[13:24:23.304]             base::options(...future.oldOptions)
[13:24:23.304]             if (.Platform$OS.type == "windows") {
[13:24:23.304]                 old_names <- names(...future.oldEnvVars)
[13:24:23.304]                 envs <- base::Sys.getenv()
[13:24:23.304]                 names <- names(envs)
[13:24:23.304]                 common <- intersect(names, old_names)
[13:24:23.304]                 added <- setdiff(names, old_names)
[13:24:23.304]                 removed <- setdiff(old_names, names)
[13:24:23.304]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.304]                   envs[common]]
[13:24:23.304]                 NAMES <- toupper(changed)
[13:24:23.304]                 args <- list()
[13:24:23.304]                 for (kk in seq_along(NAMES)) {
[13:24:23.304]                   name <- changed[[kk]]
[13:24:23.304]                   NAME <- NAMES[[kk]]
[13:24:23.304]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.304]                     next
[13:24:23.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.304]                 }
[13:24:23.304]                 NAMES <- toupper(added)
[13:24:23.304]                 for (kk in seq_along(NAMES)) {
[13:24:23.304]                   name <- added[[kk]]
[13:24:23.304]                   NAME <- NAMES[[kk]]
[13:24:23.304]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.304]                     next
[13:24:23.304]                   args[[name]] <- ""
[13:24:23.304]                 }
[13:24:23.304]                 NAMES <- toupper(removed)
[13:24:23.304]                 for (kk in seq_along(NAMES)) {
[13:24:23.304]                   name <- removed[[kk]]
[13:24:23.304]                   NAME <- NAMES[[kk]]
[13:24:23.304]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.304]                     next
[13:24:23.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.304]                 }
[13:24:23.304]                 if (length(args) > 0) 
[13:24:23.304]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.304]             }
[13:24:23.304]             else {
[13:24:23.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.304]             }
[13:24:23.304]             {
[13:24:23.304]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.304]                   0L) {
[13:24:23.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.304]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.304]                   base::options(opts)
[13:24:23.304]                 }
[13:24:23.304]                 {
[13:24:23.304]                   {
[13:24:23.304]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.304]                     NULL
[13:24:23.304]                   }
[13:24:23.304]                   options(future.plan = NULL)
[13:24:23.304]                   if (is.na(NA_character_)) 
[13:24:23.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.304]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.304]                     envir = parent.frame()) 
[13:24:23.304]                   {
[13:24:23.304]                     default_workers <- missing(workers)
[13:24:23.304]                     if (is.function(workers)) 
[13:24:23.304]                       workers <- workers()
[13:24:23.304]                     workers <- structure(as.integer(workers), 
[13:24:23.304]                       class = class(workers))
[13:24:23.304]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.304]                       1L)
[13:24:23.304]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.304]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.304]                       if (default_workers) 
[13:24:23.304]                         supportsMulticore(warn = TRUE)
[13:24:23.304]                       return(sequential(..., envir = envir))
[13:24:23.304]                     }
[13:24:23.304]                     oopts <- options(mc.cores = workers)
[13:24:23.304]                     on.exit(options(oopts))
[13:24:23.304]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.304]                       envir = envir)
[13:24:23.304]                     if (!future$lazy) 
[13:24:23.304]                       future <- run(future)
[13:24:23.304]                     invisible(future)
[13:24:23.304]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.304]                 }
[13:24:23.304]             }
[13:24:23.304]         }
[13:24:23.304]     })
[13:24:23.304]     if (TRUE) {
[13:24:23.304]         base::sink(type = "output", split = FALSE)
[13:24:23.304]         if (TRUE) {
[13:24:23.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.304]         }
[13:24:23.304]         else {
[13:24:23.304]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.304]         }
[13:24:23.304]         base::close(...future.stdout)
[13:24:23.304]         ...future.stdout <- NULL
[13:24:23.304]     }
[13:24:23.304]     ...future.result$conditions <- ...future.conditions
[13:24:23.304]     ...future.result$finished <- base::Sys.time()
[13:24:23.304]     ...future.result
[13:24:23.304] }
[13:24:23.307] assign_globals() ...
[13:24:23.308] List of 1
[13:24:23.308]  $ kk: int 1
[13:24:23.308]  - attr(*, "where")=List of 1
[13:24:23.308]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:23.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:23.308]  - attr(*, "resolved")= logi FALSE
[13:24:23.308]  - attr(*, "total_size")= num 56
[13:24:23.308]  - attr(*, "already-done")= logi TRUE
[13:24:23.312] - copied ‘kk’ to environment
[13:24:23.312] assign_globals() ... done
[13:24:23.312] requestCore(): workers = 2
[13:24:23.313] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.323] result() for MulticoreFuture ...
[13:24:23.324] result() for MulticoreFuture ...
[13:24:23.325] result() for MulticoreFuture ... done
[13:24:23.325] result() for MulticoreFuture ... done
[13:24:23.325] result() for MulticoreFuture ...
[13:24:23.325] result() for MulticoreFuture ... done
[13:24:23.327] MulticoreFuture started
[13:24:23.328] - Launch lazy future ... done
[13:24:23.328] run() for ‘MulticoreFuture’ ... done
[13:24:23.329] getGlobalsAndPackages() ...
[13:24:23.329] plan(): Setting new future strategy stack:
[13:24:23.329] Searching for globals...
[13:24:23.329] List of future strategies:
[13:24:23.329] 1. sequential:
[13:24:23.329]    - args: function (..., envir = parent.frame())
[13:24:23.329]    - tweaked: FALSE
[13:24:23.329]    - call: NULL
[13:24:23.330] plan(): nbrOfWorkers() = 1
[13:24:23.332] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:23.333] Searching for globals ... DONE
[13:24:23.333] Resolving globals: FALSE
[13:24:23.334] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:23.334] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:23.335] - globals: [1] ‘kk’
[13:24:23.335] 
[13:24:23.335] getGlobalsAndPackages() ... DONE
[13:24:23.335] run() for ‘Future’ ...
[13:24:23.336] - state: ‘created’
[13:24:23.336] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.341] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.341] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.342]   - Field: ‘label’
[13:24:23.342]   - Field: ‘local’
[13:24:23.342]   - Field: ‘owner’
[13:24:23.342]   - Field: ‘envir’
[13:24:23.342]   - Field: ‘workers’
[13:24:23.342]   - Field: ‘packages’
[13:24:23.343]   - Field: ‘gc’
[13:24:23.343]   - Field: ‘job’
[13:24:23.343]   - Field: ‘conditions’
[13:24:23.343]   - Field: ‘expr’
[13:24:23.343]   - Field: ‘uuid’
[13:24:23.343]   - Field: ‘seed’
[13:24:23.343]   - Field: ‘version’
[13:24:23.344]   - Field: ‘result’
[13:24:23.344]   - Field: ‘asynchronous’
[13:24:23.344]   - Field: ‘calls’
[13:24:23.344]   - Field: ‘globals’
[13:24:23.344]   - Field: ‘stdout’
[13:24:23.344]   - Field: ‘earlySignal’
[13:24:23.344]   - Field: ‘lazy’
[13:24:23.345]   - Field: ‘state’
[13:24:23.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.345] - Launch lazy future ...
[13:24:23.345] Packages needed by the future expression (n = 0): <none>
[13:24:23.346] Packages needed by future strategies (n = 0): <none>
[13:24:23.346] {
[13:24:23.346]     {
[13:24:23.346]         {
[13:24:23.346]             ...future.startTime <- base::Sys.time()
[13:24:23.346]             {
[13:24:23.346]                 {
[13:24:23.346]                   {
[13:24:23.346]                     {
[13:24:23.346]                       base::local({
[13:24:23.346]                         has_future <- base::requireNamespace("future", 
[13:24:23.346]                           quietly = TRUE)
[13:24:23.346]                         if (has_future) {
[13:24:23.346]                           ns <- base::getNamespace("future")
[13:24:23.346]                           version <- ns[[".package"]][["version"]]
[13:24:23.346]                           if (is.null(version)) 
[13:24:23.346]                             version <- utils::packageVersion("future")
[13:24:23.346]                         }
[13:24:23.346]                         else {
[13:24:23.346]                           version <- NULL
[13:24:23.346]                         }
[13:24:23.346]                         if (!has_future || version < "1.8.0") {
[13:24:23.346]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.346]                             "", base::R.version$version.string), 
[13:24:23.346]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.346]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.346]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.346]                               "release", "version")], collapse = " "), 
[13:24:23.346]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.346]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.346]                             info)
[13:24:23.346]                           info <- base::paste(info, collapse = "; ")
[13:24:23.346]                           if (!has_future) {
[13:24:23.346]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.346]                               info)
[13:24:23.346]                           }
[13:24:23.346]                           else {
[13:24:23.346]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.346]                               info, version)
[13:24:23.346]                           }
[13:24:23.346]                           base::stop(msg)
[13:24:23.346]                         }
[13:24:23.346]                       })
[13:24:23.346]                     }
[13:24:23.346]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.346]                     base::options(mc.cores = 1L)
[13:24:23.346]                   }
[13:24:23.346]                   options(future.plan = NULL)
[13:24:23.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.346]                 }
[13:24:23.346]                 ...future.workdir <- getwd()
[13:24:23.346]             }
[13:24:23.346]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.346]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.346]         }
[13:24:23.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.346]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.346]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.346]             base::names(...future.oldOptions))
[13:24:23.346]     }
[13:24:23.346]     if (FALSE) {
[13:24:23.346]     }
[13:24:23.346]     else {
[13:24:23.346]         if (TRUE) {
[13:24:23.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.346]                 open = "w")
[13:24:23.346]         }
[13:24:23.346]         else {
[13:24:23.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.346]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.346]         }
[13:24:23.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.346]             base::sink(type = "output", split = FALSE)
[13:24:23.346]             base::close(...future.stdout)
[13:24:23.346]         }, add = TRUE)
[13:24:23.346]     }
[13:24:23.346]     ...future.frame <- base::sys.nframe()
[13:24:23.346]     ...future.conditions <- base::list()
[13:24:23.346]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.346]     if (FALSE) {
[13:24:23.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.346]     }
[13:24:23.346]     ...future.result <- base::tryCatch({
[13:24:23.346]         base::withCallingHandlers({
[13:24:23.346]             ...future.value <- base::withVisible(base::local({
[13:24:23.346]                 withCallingHandlers({
[13:24:23.346]                   {
[13:24:23.346]                     Sys.sleep(0.1)
[13:24:23.346]                     kk
[13:24:23.346]                   }
[13:24:23.346]                 }, immediateCondition = function(cond) {
[13:24:23.346]                   save_rds <- function (object, pathname, ...) 
[13:24:23.346]                   {
[13:24:23.346]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.346]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.346]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.346]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.346]                         fi_tmp[["mtime"]])
[13:24:23.346]                     }
[13:24:23.346]                     tryCatch({
[13:24:23.346]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.346]                     }, error = function(ex) {
[13:24:23.346]                       msg <- conditionMessage(ex)
[13:24:23.346]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.346]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.346]                         fi_tmp[["mtime"]], msg)
[13:24:23.346]                       ex$message <- msg
[13:24:23.346]                       stop(ex)
[13:24:23.346]                     })
[13:24:23.346]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.346]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.346]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.346]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.346]                       fi <- file.info(pathname)
[13:24:23.346]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.346]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.346]                         fi[["size"]], fi[["mtime"]])
[13:24:23.346]                       stop(msg)
[13:24:23.346]                     }
[13:24:23.346]                     invisible(pathname)
[13:24:23.346]                   }
[13:24:23.346]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.346]                     rootPath = tempdir()) 
[13:24:23.346]                   {
[13:24:23.346]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.346]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.346]                       tmpdir = path, fileext = ".rds")
[13:24:23.346]                     save_rds(obj, file)
[13:24:23.346]                   }
[13:24:23.346]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.346]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.346]                   {
[13:24:23.346]                     inherits <- base::inherits
[13:24:23.346]                     invokeRestart <- base::invokeRestart
[13:24:23.346]                     is.null <- base::is.null
[13:24:23.346]                     muffled <- FALSE
[13:24:23.346]                     if (inherits(cond, "message")) {
[13:24:23.346]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.346]                       if (muffled) 
[13:24:23.346]                         invokeRestart("muffleMessage")
[13:24:23.346]                     }
[13:24:23.346]                     else if (inherits(cond, "warning")) {
[13:24:23.346]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.346]                       if (muffled) 
[13:24:23.346]                         invokeRestart("muffleWarning")
[13:24:23.346]                     }
[13:24:23.346]                     else if (inherits(cond, "condition")) {
[13:24:23.346]                       if (!is.null(pattern)) {
[13:24:23.346]                         computeRestarts <- base::computeRestarts
[13:24:23.346]                         grepl <- base::grepl
[13:24:23.346]                         restarts <- computeRestarts(cond)
[13:24:23.346]                         for (restart in restarts) {
[13:24:23.346]                           name <- restart$name
[13:24:23.346]                           if (is.null(name)) 
[13:24:23.346]                             next
[13:24:23.346]                           if (!grepl(pattern, name)) 
[13:24:23.346]                             next
[13:24:23.346]                           invokeRestart(restart)
[13:24:23.346]                           muffled <- TRUE
[13:24:23.346]                           break
[13:24:23.346]                         }
[13:24:23.346]                       }
[13:24:23.346]                     }
[13:24:23.346]                     invisible(muffled)
[13:24:23.346]                   }
[13:24:23.346]                   muffleCondition(cond)
[13:24:23.346]                 })
[13:24:23.346]             }))
[13:24:23.346]             future::FutureResult(value = ...future.value$value, 
[13:24:23.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.346]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.346]                     ...future.globalenv.names))
[13:24:23.346]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.346]         }, condition = base::local({
[13:24:23.346]             c <- base::c
[13:24:23.346]             inherits <- base::inherits
[13:24:23.346]             invokeRestart <- base::invokeRestart
[13:24:23.346]             length <- base::length
[13:24:23.346]             list <- base::list
[13:24:23.346]             seq.int <- base::seq.int
[13:24:23.346]             signalCondition <- base::signalCondition
[13:24:23.346]             sys.calls <- base::sys.calls
[13:24:23.346]             `[[` <- base::`[[`
[13:24:23.346]             `+` <- base::`+`
[13:24:23.346]             `<<-` <- base::`<<-`
[13:24:23.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.346]                   3L)]
[13:24:23.346]             }
[13:24:23.346]             function(cond) {
[13:24:23.346]                 is_error <- inherits(cond, "error")
[13:24:23.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.346]                   NULL)
[13:24:23.346]                 if (is_error) {
[13:24:23.346]                   sessionInformation <- function() {
[13:24:23.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.346]                       search = base::search(), system = base::Sys.info())
[13:24:23.346]                   }
[13:24:23.346]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.346]                     cond$call), session = sessionInformation(), 
[13:24:23.346]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.346]                   signalCondition(cond)
[13:24:23.346]                 }
[13:24:23.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.346]                 "immediateCondition"))) {
[13:24:23.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.346]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.346]                   if (TRUE && !signal) {
[13:24:23.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.346]                     {
[13:24:23.346]                       inherits <- base::inherits
[13:24:23.346]                       invokeRestart <- base::invokeRestart
[13:24:23.346]                       is.null <- base::is.null
[13:24:23.346]                       muffled <- FALSE
[13:24:23.346]                       if (inherits(cond, "message")) {
[13:24:23.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.346]                         if (muffled) 
[13:24:23.346]                           invokeRestart("muffleMessage")
[13:24:23.346]                       }
[13:24:23.346]                       else if (inherits(cond, "warning")) {
[13:24:23.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.346]                         if (muffled) 
[13:24:23.346]                           invokeRestart("muffleWarning")
[13:24:23.346]                       }
[13:24:23.346]                       else if (inherits(cond, "condition")) {
[13:24:23.346]                         if (!is.null(pattern)) {
[13:24:23.346]                           computeRestarts <- base::computeRestarts
[13:24:23.346]                           grepl <- base::grepl
[13:24:23.346]                           restarts <- computeRestarts(cond)
[13:24:23.346]                           for (restart in restarts) {
[13:24:23.346]                             name <- restart$name
[13:24:23.346]                             if (is.null(name)) 
[13:24:23.346]                               next
[13:24:23.346]                             if (!grepl(pattern, name)) 
[13:24:23.346]                               next
[13:24:23.346]                             invokeRestart(restart)
[13:24:23.346]                             muffled <- TRUE
[13:24:23.346]                             break
[13:24:23.346]                           }
[13:24:23.346]                         }
[13:24:23.346]                       }
[13:24:23.346]                       invisible(muffled)
[13:24:23.346]                     }
[13:24:23.346]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.346]                   }
[13:24:23.346]                 }
[13:24:23.346]                 else {
[13:24:23.346]                   if (TRUE) {
[13:24:23.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.346]                     {
[13:24:23.346]                       inherits <- base::inherits
[13:24:23.346]                       invokeRestart <- base::invokeRestart
[13:24:23.346]                       is.null <- base::is.null
[13:24:23.346]                       muffled <- FALSE
[13:24:23.346]                       if (inherits(cond, "message")) {
[13:24:23.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.346]                         if (muffled) 
[13:24:23.346]                           invokeRestart("muffleMessage")
[13:24:23.346]                       }
[13:24:23.346]                       else if (inherits(cond, "warning")) {
[13:24:23.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.346]                         if (muffled) 
[13:24:23.346]                           invokeRestart("muffleWarning")
[13:24:23.346]                       }
[13:24:23.346]                       else if (inherits(cond, "condition")) {
[13:24:23.346]                         if (!is.null(pattern)) {
[13:24:23.346]                           computeRestarts <- base::computeRestarts
[13:24:23.346]                           grepl <- base::grepl
[13:24:23.346]                           restarts <- computeRestarts(cond)
[13:24:23.346]                           for (restart in restarts) {
[13:24:23.346]                             name <- restart$name
[13:24:23.346]                             if (is.null(name)) 
[13:24:23.346]                               next
[13:24:23.346]                             if (!grepl(pattern, name)) 
[13:24:23.346]                               next
[13:24:23.346]                             invokeRestart(restart)
[13:24:23.346]                             muffled <- TRUE
[13:24:23.346]                             break
[13:24:23.346]                           }
[13:24:23.346]                         }
[13:24:23.346]                       }
[13:24:23.346]                       invisible(muffled)
[13:24:23.346]                     }
[13:24:23.346]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.346]                   }
[13:24:23.346]                 }
[13:24:23.346]             }
[13:24:23.346]         }))
[13:24:23.346]     }, error = function(ex) {
[13:24:23.346]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.346]                 ...future.rng), started = ...future.startTime, 
[13:24:23.346]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.346]             version = "1.8"), class = "FutureResult")
[13:24:23.346]     }, finally = {
[13:24:23.346]         if (!identical(...future.workdir, getwd())) 
[13:24:23.346]             setwd(...future.workdir)
[13:24:23.346]         {
[13:24:23.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.346]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.346]             }
[13:24:23.346]             base::options(...future.oldOptions)
[13:24:23.346]             if (.Platform$OS.type == "windows") {
[13:24:23.346]                 old_names <- names(...future.oldEnvVars)
[13:24:23.346]                 envs <- base::Sys.getenv()
[13:24:23.346]                 names <- names(envs)
[13:24:23.346]                 common <- intersect(names, old_names)
[13:24:23.346]                 added <- setdiff(names, old_names)
[13:24:23.346]                 removed <- setdiff(old_names, names)
[13:24:23.346]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.346]                   envs[common]]
[13:24:23.346]                 NAMES <- toupper(changed)
[13:24:23.346]                 args <- list()
[13:24:23.346]                 for (kk in seq_along(NAMES)) {
[13:24:23.346]                   name <- changed[[kk]]
[13:24:23.346]                   NAME <- NAMES[[kk]]
[13:24:23.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.346]                     next
[13:24:23.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.346]                 }
[13:24:23.346]                 NAMES <- toupper(added)
[13:24:23.346]                 for (kk in seq_along(NAMES)) {
[13:24:23.346]                   name <- added[[kk]]
[13:24:23.346]                   NAME <- NAMES[[kk]]
[13:24:23.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.346]                     next
[13:24:23.346]                   args[[name]] <- ""
[13:24:23.346]                 }
[13:24:23.346]                 NAMES <- toupper(removed)
[13:24:23.346]                 for (kk in seq_along(NAMES)) {
[13:24:23.346]                   name <- removed[[kk]]
[13:24:23.346]                   NAME <- NAMES[[kk]]
[13:24:23.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.346]                     next
[13:24:23.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.346]                 }
[13:24:23.346]                 if (length(args) > 0) 
[13:24:23.346]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.346]             }
[13:24:23.346]             else {
[13:24:23.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.346]             }
[13:24:23.346]             {
[13:24:23.346]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.346]                   0L) {
[13:24:23.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.346]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.346]                   base::options(opts)
[13:24:23.346]                 }
[13:24:23.346]                 {
[13:24:23.346]                   {
[13:24:23.346]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.346]                     NULL
[13:24:23.346]                   }
[13:24:23.346]                   options(future.plan = NULL)
[13:24:23.346]                   if (is.na(NA_character_)) 
[13:24:23.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.346]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.346]                     envir = parent.frame()) 
[13:24:23.346]                   {
[13:24:23.346]                     default_workers <- missing(workers)
[13:24:23.346]                     if (is.function(workers)) 
[13:24:23.346]                       workers <- workers()
[13:24:23.346]                     workers <- structure(as.integer(workers), 
[13:24:23.346]                       class = class(workers))
[13:24:23.346]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.346]                       1L)
[13:24:23.346]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.346]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.346]                       if (default_workers) 
[13:24:23.346]                         supportsMulticore(warn = TRUE)
[13:24:23.346]                       return(sequential(..., envir = envir))
[13:24:23.346]                     }
[13:24:23.346]                     oopts <- options(mc.cores = workers)
[13:24:23.346]                     on.exit(options(oopts))
[13:24:23.346]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.346]                       envir = envir)
[13:24:23.346]                     if (!future$lazy) 
[13:24:23.346]                       future <- run(future)
[13:24:23.346]                     invisible(future)
[13:24:23.346]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.346]                 }
[13:24:23.346]             }
[13:24:23.346]         }
[13:24:23.346]     })
[13:24:23.346]     if (TRUE) {
[13:24:23.346]         base::sink(type = "output", split = FALSE)
[13:24:23.346]         if (TRUE) {
[13:24:23.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.346]         }
[13:24:23.346]         else {
[13:24:23.346]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.346]         }
[13:24:23.346]         base::close(...future.stdout)
[13:24:23.346]         ...future.stdout <- NULL
[13:24:23.346]     }
[13:24:23.346]     ...future.result$conditions <- ...future.conditions
[13:24:23.346]     ...future.result$finished <- base::Sys.time()
[13:24:23.346]     ...future.result
[13:24:23.346] }
[13:24:23.350] assign_globals() ...
[13:24:23.350] List of 1
[13:24:23.350]  $ kk: int 2
[13:24:23.350]  - attr(*, "where")=List of 1
[13:24:23.350]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:23.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:23.350]  - attr(*, "resolved")= logi FALSE
[13:24:23.350]  - attr(*, "total_size")= num 56
[13:24:23.350]  - attr(*, "already-done")= logi TRUE
[13:24:23.354] - copied ‘kk’ to environment
[13:24:23.354] assign_globals() ... done
[13:24:23.354] requestCore(): workers = 2
[13:24:23.355] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.365] result() for MulticoreFuture ...
[13:24:23.366] result() for MulticoreFuture ...
[13:24:23.367] result() for MulticoreFuture ... done
[13:24:23.367] result() for MulticoreFuture ... done
[13:24:23.367] result() for MulticoreFuture ...
[13:24:23.367] result() for MulticoreFuture ... done
[13:24:23.370] MulticoreFuture started
[13:24:23.371] - Launch lazy future ... done
[13:24:23.371] run() for ‘MulticoreFuture’ ... done
[13:24:23.372] getGlobalsAndPackages() ...
[13:24:23.372] plan(): Setting new future strategy stack:
[13:24:23.372] Searching for globals...
[13:24:23.372] List of future strategies:
[13:24:23.372] 1. sequential:
[13:24:23.372]    - args: function (..., envir = parent.frame())
[13:24:23.372]    - tweaked: FALSE
[13:24:23.372]    - call: NULL
[13:24:23.373] plan(): nbrOfWorkers() = 1
[13:24:23.374] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:23.374] Searching for globals ... DONE
[13:24:23.374] Resolving globals: FALSE
[13:24:23.375] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:23.376] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:23.376] - globals: [1] ‘kk’
[13:24:23.376] 
[13:24:23.377] getGlobalsAndPackages() ... DONE
[13:24:23.377] run() for ‘Future’ ...
[13:24:23.377] - state: ‘created’
[13:24:23.377] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.383] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.387]   - Field: ‘label’
[13:24:23.388]   - Field: ‘local’
[13:24:23.388]   - Field: ‘owner’
[13:24:23.388]   - Field: ‘envir’
[13:24:23.389]   - Field: ‘workers’
[13:24:23.389]   - Field: ‘packages’
[13:24:23.389]   - Field: ‘gc’
[13:24:23.390]   - Field: ‘job’
[13:24:23.390]   - Field: ‘conditions’
[13:24:23.390]   - Field: ‘expr’
[13:24:23.390]   - Field: ‘uuid’
[13:24:23.391]   - Field: ‘seed’
[13:24:23.391]   - Field: ‘version’
[13:24:23.391]   - Field: ‘result’
[13:24:23.391]   - Field: ‘asynchronous’
[13:24:23.392]   - Field: ‘calls’
[13:24:23.392]   - Field: ‘globals’
[13:24:23.392]   - Field: ‘stdout’
[13:24:23.392]   - Field: ‘earlySignal’
[13:24:23.392]   - Field: ‘lazy’
[13:24:23.393]   - Field: ‘state’
[13:24:23.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.393] - Launch lazy future ...
[13:24:23.393] Packages needed by the future expression (n = 0): <none>
[13:24:23.394] Packages needed by future strategies (n = 0): <none>
[13:24:23.394] {
[13:24:23.394]     {
[13:24:23.394]         {
[13:24:23.394]             ...future.startTime <- base::Sys.time()
[13:24:23.394]             {
[13:24:23.394]                 {
[13:24:23.394]                   {
[13:24:23.394]                     {
[13:24:23.394]                       base::local({
[13:24:23.394]                         has_future <- base::requireNamespace("future", 
[13:24:23.394]                           quietly = TRUE)
[13:24:23.394]                         if (has_future) {
[13:24:23.394]                           ns <- base::getNamespace("future")
[13:24:23.394]                           version <- ns[[".package"]][["version"]]
[13:24:23.394]                           if (is.null(version)) 
[13:24:23.394]                             version <- utils::packageVersion("future")
[13:24:23.394]                         }
[13:24:23.394]                         else {
[13:24:23.394]                           version <- NULL
[13:24:23.394]                         }
[13:24:23.394]                         if (!has_future || version < "1.8.0") {
[13:24:23.394]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.394]                             "", base::R.version$version.string), 
[13:24:23.394]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.394]                               "release", "version")], collapse = " "), 
[13:24:23.394]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.394]                             info)
[13:24:23.394]                           info <- base::paste(info, collapse = "; ")
[13:24:23.394]                           if (!has_future) {
[13:24:23.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.394]                               info)
[13:24:23.394]                           }
[13:24:23.394]                           else {
[13:24:23.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.394]                               info, version)
[13:24:23.394]                           }
[13:24:23.394]                           base::stop(msg)
[13:24:23.394]                         }
[13:24:23.394]                       })
[13:24:23.394]                     }
[13:24:23.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.394]                     base::options(mc.cores = 1L)
[13:24:23.394]                   }
[13:24:23.394]                   options(future.plan = NULL)
[13:24:23.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.394]                 }
[13:24:23.394]                 ...future.workdir <- getwd()
[13:24:23.394]             }
[13:24:23.394]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.394]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.394]         }
[13:24:23.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.394]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.394]             base::names(...future.oldOptions))
[13:24:23.394]     }
[13:24:23.394]     if (FALSE) {
[13:24:23.394]     }
[13:24:23.394]     else {
[13:24:23.394]         if (TRUE) {
[13:24:23.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.394]                 open = "w")
[13:24:23.394]         }
[13:24:23.394]         else {
[13:24:23.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.394]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.394]         }
[13:24:23.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.394]             base::sink(type = "output", split = FALSE)
[13:24:23.394]             base::close(...future.stdout)
[13:24:23.394]         }, add = TRUE)
[13:24:23.394]     }
[13:24:23.394]     ...future.frame <- base::sys.nframe()
[13:24:23.394]     ...future.conditions <- base::list()
[13:24:23.394]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.394]     if (FALSE) {
[13:24:23.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.394]     }
[13:24:23.394]     ...future.result <- base::tryCatch({
[13:24:23.394]         base::withCallingHandlers({
[13:24:23.394]             ...future.value <- base::withVisible(base::local({
[13:24:23.394]                 withCallingHandlers({
[13:24:23.394]                   {
[13:24:23.394]                     Sys.sleep(0.1)
[13:24:23.394]                     kk
[13:24:23.394]                   }
[13:24:23.394]                 }, immediateCondition = function(cond) {
[13:24:23.394]                   save_rds <- function (object, pathname, ...) 
[13:24:23.394]                   {
[13:24:23.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.394]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.394]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.394]                         fi_tmp[["mtime"]])
[13:24:23.394]                     }
[13:24:23.394]                     tryCatch({
[13:24:23.394]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.394]                     }, error = function(ex) {
[13:24:23.394]                       msg <- conditionMessage(ex)
[13:24:23.394]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.394]                         fi_tmp[["mtime"]], msg)
[13:24:23.394]                       ex$message <- msg
[13:24:23.394]                       stop(ex)
[13:24:23.394]                     })
[13:24:23.394]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.394]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.394]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.394]                       fi <- file.info(pathname)
[13:24:23.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.394]                         fi[["size"]], fi[["mtime"]])
[13:24:23.394]                       stop(msg)
[13:24:23.394]                     }
[13:24:23.394]                     invisible(pathname)
[13:24:23.394]                   }
[13:24:23.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.394]                     rootPath = tempdir()) 
[13:24:23.394]                   {
[13:24:23.394]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.394]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.394]                       tmpdir = path, fileext = ".rds")
[13:24:23.394]                     save_rds(obj, file)
[13:24:23.394]                   }
[13:24:23.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.394]                   {
[13:24:23.394]                     inherits <- base::inherits
[13:24:23.394]                     invokeRestart <- base::invokeRestart
[13:24:23.394]                     is.null <- base::is.null
[13:24:23.394]                     muffled <- FALSE
[13:24:23.394]                     if (inherits(cond, "message")) {
[13:24:23.394]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.394]                       if (muffled) 
[13:24:23.394]                         invokeRestart("muffleMessage")
[13:24:23.394]                     }
[13:24:23.394]                     else if (inherits(cond, "warning")) {
[13:24:23.394]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.394]                       if (muffled) 
[13:24:23.394]                         invokeRestart("muffleWarning")
[13:24:23.394]                     }
[13:24:23.394]                     else if (inherits(cond, "condition")) {
[13:24:23.394]                       if (!is.null(pattern)) {
[13:24:23.394]                         computeRestarts <- base::computeRestarts
[13:24:23.394]                         grepl <- base::grepl
[13:24:23.394]                         restarts <- computeRestarts(cond)
[13:24:23.394]                         for (restart in restarts) {
[13:24:23.394]                           name <- restart$name
[13:24:23.394]                           if (is.null(name)) 
[13:24:23.394]                             next
[13:24:23.394]                           if (!grepl(pattern, name)) 
[13:24:23.394]                             next
[13:24:23.394]                           invokeRestart(restart)
[13:24:23.394]                           muffled <- TRUE
[13:24:23.394]                           break
[13:24:23.394]                         }
[13:24:23.394]                       }
[13:24:23.394]                     }
[13:24:23.394]                     invisible(muffled)
[13:24:23.394]                   }
[13:24:23.394]                   muffleCondition(cond)
[13:24:23.394]                 })
[13:24:23.394]             }))
[13:24:23.394]             future::FutureResult(value = ...future.value$value, 
[13:24:23.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.394]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.394]                     ...future.globalenv.names))
[13:24:23.394]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.394]         }, condition = base::local({
[13:24:23.394]             c <- base::c
[13:24:23.394]             inherits <- base::inherits
[13:24:23.394]             invokeRestart <- base::invokeRestart
[13:24:23.394]             length <- base::length
[13:24:23.394]             list <- base::list
[13:24:23.394]             seq.int <- base::seq.int
[13:24:23.394]             signalCondition <- base::signalCondition
[13:24:23.394]             sys.calls <- base::sys.calls
[13:24:23.394]             `[[` <- base::`[[`
[13:24:23.394]             `+` <- base::`+`
[13:24:23.394]             `<<-` <- base::`<<-`
[13:24:23.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.394]                   3L)]
[13:24:23.394]             }
[13:24:23.394]             function(cond) {
[13:24:23.394]                 is_error <- inherits(cond, "error")
[13:24:23.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.394]                   NULL)
[13:24:23.394]                 if (is_error) {
[13:24:23.394]                   sessionInformation <- function() {
[13:24:23.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.394]                       search = base::search(), system = base::Sys.info())
[13:24:23.394]                   }
[13:24:23.394]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.394]                     cond$call), session = sessionInformation(), 
[13:24:23.394]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.394]                   signalCondition(cond)
[13:24:23.394]                 }
[13:24:23.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.394]                 "immediateCondition"))) {
[13:24:23.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.394]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.394]                   if (TRUE && !signal) {
[13:24:23.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.394]                     {
[13:24:23.394]                       inherits <- base::inherits
[13:24:23.394]                       invokeRestart <- base::invokeRestart
[13:24:23.394]                       is.null <- base::is.null
[13:24:23.394]                       muffled <- FALSE
[13:24:23.394]                       if (inherits(cond, "message")) {
[13:24:23.394]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.394]                         if (muffled) 
[13:24:23.394]                           invokeRestart("muffleMessage")
[13:24:23.394]                       }
[13:24:23.394]                       else if (inherits(cond, "warning")) {
[13:24:23.394]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.394]                         if (muffled) 
[13:24:23.394]                           invokeRestart("muffleWarning")
[13:24:23.394]                       }
[13:24:23.394]                       else if (inherits(cond, "condition")) {
[13:24:23.394]                         if (!is.null(pattern)) {
[13:24:23.394]                           computeRestarts <- base::computeRestarts
[13:24:23.394]                           grepl <- base::grepl
[13:24:23.394]                           restarts <- computeRestarts(cond)
[13:24:23.394]                           for (restart in restarts) {
[13:24:23.394]                             name <- restart$name
[13:24:23.394]                             if (is.null(name)) 
[13:24:23.394]                               next
[13:24:23.394]                             if (!grepl(pattern, name)) 
[13:24:23.394]                               next
[13:24:23.394]                             invokeRestart(restart)
[13:24:23.394]                             muffled <- TRUE
[13:24:23.394]                             break
[13:24:23.394]                           }
[13:24:23.394]                         }
[13:24:23.394]                       }
[13:24:23.394]                       invisible(muffled)
[13:24:23.394]                     }
[13:24:23.394]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.394]                   }
[13:24:23.394]                 }
[13:24:23.394]                 else {
[13:24:23.394]                   if (TRUE) {
[13:24:23.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.394]                     {
[13:24:23.394]                       inherits <- base::inherits
[13:24:23.394]                       invokeRestart <- base::invokeRestart
[13:24:23.394]                       is.null <- base::is.null
[13:24:23.394]                       muffled <- FALSE
[13:24:23.394]                       if (inherits(cond, "message")) {
[13:24:23.394]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.394]                         if (muffled) 
[13:24:23.394]                           invokeRestart("muffleMessage")
[13:24:23.394]                       }
[13:24:23.394]                       else if (inherits(cond, "warning")) {
[13:24:23.394]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.394]                         if (muffled) 
[13:24:23.394]                           invokeRestart("muffleWarning")
[13:24:23.394]                       }
[13:24:23.394]                       else if (inherits(cond, "condition")) {
[13:24:23.394]                         if (!is.null(pattern)) {
[13:24:23.394]                           computeRestarts <- base::computeRestarts
[13:24:23.394]                           grepl <- base::grepl
[13:24:23.394]                           restarts <- computeRestarts(cond)
[13:24:23.394]                           for (restart in restarts) {
[13:24:23.394]                             name <- restart$name
[13:24:23.394]                             if (is.null(name)) 
[13:24:23.394]                               next
[13:24:23.394]                             if (!grepl(pattern, name)) 
[13:24:23.394]                               next
[13:24:23.394]                             invokeRestart(restart)
[13:24:23.394]                             muffled <- TRUE
[13:24:23.394]                             break
[13:24:23.394]                           }
[13:24:23.394]                         }
[13:24:23.394]                       }
[13:24:23.394]                       invisible(muffled)
[13:24:23.394]                     }
[13:24:23.394]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.394]                   }
[13:24:23.394]                 }
[13:24:23.394]             }
[13:24:23.394]         }))
[13:24:23.394]     }, error = function(ex) {
[13:24:23.394]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.394]                 ...future.rng), started = ...future.startTime, 
[13:24:23.394]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.394]             version = "1.8"), class = "FutureResult")
[13:24:23.394]     }, finally = {
[13:24:23.394]         if (!identical(...future.workdir, getwd())) 
[13:24:23.394]             setwd(...future.workdir)
[13:24:23.394]         {
[13:24:23.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.394]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.394]             }
[13:24:23.394]             base::options(...future.oldOptions)
[13:24:23.394]             if (.Platform$OS.type == "windows") {
[13:24:23.394]                 old_names <- names(...future.oldEnvVars)
[13:24:23.394]                 envs <- base::Sys.getenv()
[13:24:23.394]                 names <- names(envs)
[13:24:23.394]                 common <- intersect(names, old_names)
[13:24:23.394]                 added <- setdiff(names, old_names)
[13:24:23.394]                 removed <- setdiff(old_names, names)
[13:24:23.394]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.394]                   envs[common]]
[13:24:23.394]                 NAMES <- toupper(changed)
[13:24:23.394]                 args <- list()
[13:24:23.394]                 for (kk in seq_along(NAMES)) {
[13:24:23.394]                   name <- changed[[kk]]
[13:24:23.394]                   NAME <- NAMES[[kk]]
[13:24:23.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.394]                     next
[13:24:23.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.394]                 }
[13:24:23.394]                 NAMES <- toupper(added)
[13:24:23.394]                 for (kk in seq_along(NAMES)) {
[13:24:23.394]                   name <- added[[kk]]
[13:24:23.394]                   NAME <- NAMES[[kk]]
[13:24:23.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.394]                     next
[13:24:23.394]                   args[[name]] <- ""
[13:24:23.394]                 }
[13:24:23.394]                 NAMES <- toupper(removed)
[13:24:23.394]                 for (kk in seq_along(NAMES)) {
[13:24:23.394]                   name <- removed[[kk]]
[13:24:23.394]                   NAME <- NAMES[[kk]]
[13:24:23.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.394]                     next
[13:24:23.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.394]                 }
[13:24:23.394]                 if (length(args) > 0) 
[13:24:23.394]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.394]             }
[13:24:23.394]             else {
[13:24:23.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.394]             }
[13:24:23.394]             {
[13:24:23.394]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.394]                   0L) {
[13:24:23.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.394]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.394]                   base::options(opts)
[13:24:23.394]                 }
[13:24:23.394]                 {
[13:24:23.394]                   {
[13:24:23.394]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.394]                     NULL
[13:24:23.394]                   }
[13:24:23.394]                   options(future.plan = NULL)
[13:24:23.394]                   if (is.na(NA_character_)) 
[13:24:23.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.394]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.394]                     envir = parent.frame()) 
[13:24:23.394]                   {
[13:24:23.394]                     default_workers <- missing(workers)
[13:24:23.394]                     if (is.function(workers)) 
[13:24:23.394]                       workers <- workers()
[13:24:23.394]                     workers <- structure(as.integer(workers), 
[13:24:23.394]                       class = class(workers))
[13:24:23.394]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.394]                       1L)
[13:24:23.394]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.394]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.394]                       if (default_workers) 
[13:24:23.394]                         supportsMulticore(warn = TRUE)
[13:24:23.394]                       return(sequential(..., envir = envir))
[13:24:23.394]                     }
[13:24:23.394]                     oopts <- options(mc.cores = workers)
[13:24:23.394]                     on.exit(options(oopts))
[13:24:23.394]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.394]                       envir = envir)
[13:24:23.394]                     if (!future$lazy) 
[13:24:23.394]                       future <- run(future)
[13:24:23.394]                     invisible(future)
[13:24:23.394]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.394]                 }
[13:24:23.394]             }
[13:24:23.394]         }
[13:24:23.394]     })
[13:24:23.394]     if (TRUE) {
[13:24:23.394]         base::sink(type = "output", split = FALSE)
[13:24:23.394]         if (TRUE) {
[13:24:23.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.394]         }
[13:24:23.394]         else {
[13:24:23.394]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.394]         }
[13:24:23.394]         base::close(...future.stdout)
[13:24:23.394]         ...future.stdout <- NULL
[13:24:23.394]     }
[13:24:23.394]     ...future.result$conditions <- ...future.conditions
[13:24:23.394]     ...future.result$finished <- base::Sys.time()
[13:24:23.394]     ...future.result
[13:24:23.394] }
[13:24:23.398] assign_globals() ...
[13:24:23.398] List of 1
[13:24:23.398]  $ kk: int 3
[13:24:23.398]  - attr(*, "where")=List of 1
[13:24:23.398]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:23.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:23.398]  - attr(*, "resolved")= logi FALSE
[13:24:23.398]  - attr(*, "total_size")= num 56
[13:24:23.398]  - attr(*, "already-done")= logi TRUE
[13:24:23.402] - copied ‘kk’ to environment
[13:24:23.403] assign_globals() ... done
[13:24:23.403] requestCore(): workers = 2
[13:24:23.403] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.433] plan(): Setting new future strategy stack:
[13:24:23.434] List of future strategies:
[13:24:23.434] 1. multicore:
[13:24:23.434]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.434]    - tweaked: FALSE
[13:24:23.434]    - call: plan(strategy)
[13:24:23.435] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[13:24:23.439] plan(): nbrOfWorkers() = 2
[13:24:23.446] result() for MulticoreFuture ...
[13:24:23.447] result() for MulticoreFuture ...
[13:24:23.447] result() for MulticoreFuture ... done
[13:24:23.447] result() for MulticoreFuture ... done
[13:24:23.447] result() for MulticoreFuture ...
[13:24:23.448] result() for MulticoreFuture ... done
[13:24:23.450] MulticoreFuture started
[13:24:23.451] - Launch lazy future ... done
[13:24:23.451] run() for ‘MulticoreFuture’ ... done
[13:24:23.452] resolve() on list ...
[13:24:23.452] plan(): Setting new future strategy stack:
[13:24:23.452]  recursive: 0
[13:24:23.452]  length: 3
[13:24:23.452] 
[13:24:23.452] Future #1
[13:24:23.452] List of future strategies:
[13:24:23.452] 1. sequential:
[13:24:23.452]    - args: function (..., envir = parent.frame())
[13:24:23.452]    - tweaked: FALSE
[13:24:23.452]    - call: NULL
[13:24:23.453]  length: 2 (resolved future 1)
[13:24:23.453] plan(): nbrOfWorkers() = 1
[13:24:23.475] plan(): Setting new future strategy stack:
[13:24:23.475] List of future strategies:
[13:24:23.475] 1. multicore:
[13:24:23.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.475]    - tweaked: FALSE
[13:24:23.475]    - call: plan(strategy)
[13:24:23.480] plan(): nbrOfWorkers() = 2
[13:24:23.484] Future #2
[13:24:23.484]  length: 1 (resolved future 2)
[13:24:23.556] plan(): Setting new future strategy stack:
[13:24:23.556] List of future strategies:
[13:24:23.556] 1. multicore:
[13:24:23.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.556]    - tweaked: FALSE
[13:24:23.556]    - call: plan(strategy)
[13:24:23.561] plan(): nbrOfWorkers() = 2
[13:24:23.566] Future #3
[13:24:23.567]  length: 0 (resolved future 3)
[13:24:23.567] resolve() on list ... DONE
[13:24:23.567] getGlobalsAndPackages() ...
[13:24:23.567] Searching for globals...
[13:24:23.569] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:23.570] Searching for globals ... DONE
[13:24:23.570] Resolving globals: FALSE
[13:24:23.570] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:23.571] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:23.571] - globals: [1] ‘kk’
[13:24:23.571] 
[13:24:23.572] getGlobalsAndPackages() ... DONE
[13:24:23.572] getGlobalsAndPackages() ...
[13:24:23.572] Searching for globals...
[13:24:23.574] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:23.574] Searching for globals ... DONE
[13:24:23.574] Resolving globals: FALSE
[13:24:23.574] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:23.575] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:23.575] - globals: [1] ‘kk’
[13:24:23.575] 
[13:24:23.575] getGlobalsAndPackages() ... DONE
[13:24:23.576] getGlobalsAndPackages() ...
[13:24:23.576] Searching for globals...
[13:24:23.577] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:23.577] Searching for globals ... DONE
[13:24:23.578] Resolving globals: FALSE
[13:24:23.578] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:23.578] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:23.579] - globals: [1] ‘kk’
[13:24:23.579] 
[13:24:23.579] getGlobalsAndPackages() ... DONE
[13:24:23.579] resolve() on list ...
[13:24:23.579]  recursive: 0
[13:24:23.580]  length: 3
[13:24:23.580] 
[13:24:23.580] run() for ‘Future’ ...
[13:24:23.580] - state: ‘created’
[13:24:23.580] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.585] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.585]   - Field: ‘label’
[13:24:23.585]   - Field: ‘local’
[13:24:23.585]   - Field: ‘owner’
[13:24:23.586]   - Field: ‘envir’
[13:24:23.586]   - Field: ‘workers’
[13:24:23.586]   - Field: ‘packages’
[13:24:23.586]   - Field: ‘gc’
[13:24:23.586]   - Field: ‘job’
[13:24:23.586]   - Field: ‘conditions’
[13:24:23.586]   - Field: ‘expr’
[13:24:23.587]   - Field: ‘uuid’
[13:24:23.587]   - Field: ‘seed’
[13:24:23.587]   - Field: ‘version’
[13:24:23.587]   - Field: ‘result’
[13:24:23.587]   - Field: ‘asynchronous’
[13:24:23.587]   - Field: ‘calls’
[13:24:23.587]   - Field: ‘globals’
[13:24:23.588]   - Field: ‘stdout’
[13:24:23.588]   - Field: ‘earlySignal’
[13:24:23.588]   - Field: ‘lazy’
[13:24:23.588]   - Field: ‘state’
[13:24:23.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.588] - Launch lazy future ...
[13:24:23.589] Packages needed by the future expression (n = 0): <none>
[13:24:23.589] Packages needed by future strategies (n = 0): <none>
[13:24:23.593] {
[13:24:23.593]     {
[13:24:23.593]         {
[13:24:23.593]             ...future.startTime <- base::Sys.time()
[13:24:23.593]             {
[13:24:23.593]                 {
[13:24:23.593]                   {
[13:24:23.593]                     {
[13:24:23.593]                       base::local({
[13:24:23.593]                         has_future <- base::requireNamespace("future", 
[13:24:23.593]                           quietly = TRUE)
[13:24:23.593]                         if (has_future) {
[13:24:23.593]                           ns <- base::getNamespace("future")
[13:24:23.593]                           version <- ns[[".package"]][["version"]]
[13:24:23.593]                           if (is.null(version)) 
[13:24:23.593]                             version <- utils::packageVersion("future")
[13:24:23.593]                         }
[13:24:23.593]                         else {
[13:24:23.593]                           version <- NULL
[13:24:23.593]                         }
[13:24:23.593]                         if (!has_future || version < "1.8.0") {
[13:24:23.593]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.593]                             "", base::R.version$version.string), 
[13:24:23.593]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.593]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.593]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.593]                               "release", "version")], collapse = " "), 
[13:24:23.593]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.593]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.593]                             info)
[13:24:23.593]                           info <- base::paste(info, collapse = "; ")
[13:24:23.593]                           if (!has_future) {
[13:24:23.593]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.593]                               info)
[13:24:23.593]                           }
[13:24:23.593]                           else {
[13:24:23.593]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.593]                               info, version)
[13:24:23.593]                           }
[13:24:23.593]                           base::stop(msg)
[13:24:23.593]                         }
[13:24:23.593]                       })
[13:24:23.593]                     }
[13:24:23.593]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.593]                     base::options(mc.cores = 1L)
[13:24:23.593]                   }
[13:24:23.593]                   options(future.plan = NULL)
[13:24:23.593]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.593]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.593]                 }
[13:24:23.593]                 ...future.workdir <- getwd()
[13:24:23.593]             }
[13:24:23.593]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.593]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.593]         }
[13:24:23.593]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.593]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.593]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.593]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.593]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.593]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.593]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.593]             base::names(...future.oldOptions))
[13:24:23.593]     }
[13:24:23.593]     if (FALSE) {
[13:24:23.593]     }
[13:24:23.593]     else {
[13:24:23.593]         if (TRUE) {
[13:24:23.593]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.593]                 open = "w")
[13:24:23.593]         }
[13:24:23.593]         else {
[13:24:23.593]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.593]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.593]         }
[13:24:23.593]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.593]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.593]             base::sink(type = "output", split = FALSE)
[13:24:23.593]             base::close(...future.stdout)
[13:24:23.593]         }, add = TRUE)
[13:24:23.593]     }
[13:24:23.593]     ...future.frame <- base::sys.nframe()
[13:24:23.593]     ...future.conditions <- base::list()
[13:24:23.593]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.593]     if (FALSE) {
[13:24:23.593]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.593]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.593]     }
[13:24:23.593]     ...future.result <- base::tryCatch({
[13:24:23.593]         base::withCallingHandlers({
[13:24:23.593]             ...future.value <- base::withVisible(base::local({
[13:24:23.593]                 withCallingHandlers({
[13:24:23.593]                   {
[13:24:23.593]                     Sys.sleep(0.1)
[13:24:23.593]                     kk
[13:24:23.593]                   }
[13:24:23.593]                 }, immediateCondition = function(cond) {
[13:24:23.593]                   save_rds <- function (object, pathname, ...) 
[13:24:23.593]                   {
[13:24:23.593]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.593]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.593]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.593]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.593]                         fi_tmp[["mtime"]])
[13:24:23.593]                     }
[13:24:23.593]                     tryCatch({
[13:24:23.593]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.593]                     }, error = function(ex) {
[13:24:23.593]                       msg <- conditionMessage(ex)
[13:24:23.593]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.593]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.593]                         fi_tmp[["mtime"]], msg)
[13:24:23.593]                       ex$message <- msg
[13:24:23.593]                       stop(ex)
[13:24:23.593]                     })
[13:24:23.593]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.593]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.593]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.593]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.593]                       fi <- file.info(pathname)
[13:24:23.593]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.593]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.593]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.593]                         fi[["size"]], fi[["mtime"]])
[13:24:23.593]                       stop(msg)
[13:24:23.593]                     }
[13:24:23.593]                     invisible(pathname)
[13:24:23.593]                   }
[13:24:23.593]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.593]                     rootPath = tempdir()) 
[13:24:23.593]                   {
[13:24:23.593]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.593]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.593]                       tmpdir = path, fileext = ".rds")
[13:24:23.593]                     save_rds(obj, file)
[13:24:23.593]                   }
[13:24:23.593]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.593]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.593]                   {
[13:24:23.593]                     inherits <- base::inherits
[13:24:23.593]                     invokeRestart <- base::invokeRestart
[13:24:23.593]                     is.null <- base::is.null
[13:24:23.593]                     muffled <- FALSE
[13:24:23.593]                     if (inherits(cond, "message")) {
[13:24:23.593]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.593]                       if (muffled) 
[13:24:23.593]                         invokeRestart("muffleMessage")
[13:24:23.593]                     }
[13:24:23.593]                     else if (inherits(cond, "warning")) {
[13:24:23.593]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.593]                       if (muffled) 
[13:24:23.593]                         invokeRestart("muffleWarning")
[13:24:23.593]                     }
[13:24:23.593]                     else if (inherits(cond, "condition")) {
[13:24:23.593]                       if (!is.null(pattern)) {
[13:24:23.593]                         computeRestarts <- base::computeRestarts
[13:24:23.593]                         grepl <- base::grepl
[13:24:23.593]                         restarts <- computeRestarts(cond)
[13:24:23.593]                         for (restart in restarts) {
[13:24:23.593]                           name <- restart$name
[13:24:23.593]                           if (is.null(name)) 
[13:24:23.593]                             next
[13:24:23.593]                           if (!grepl(pattern, name)) 
[13:24:23.593]                             next
[13:24:23.593]                           invokeRestart(restart)
[13:24:23.593]                           muffled <- TRUE
[13:24:23.593]                           break
[13:24:23.593]                         }
[13:24:23.593]                       }
[13:24:23.593]                     }
[13:24:23.593]                     invisible(muffled)
[13:24:23.593]                   }
[13:24:23.593]                   muffleCondition(cond)
[13:24:23.593]                 })
[13:24:23.593]             }))
[13:24:23.593]             future::FutureResult(value = ...future.value$value, 
[13:24:23.593]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.593]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.593]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.593]                     ...future.globalenv.names))
[13:24:23.593]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.593]         }, condition = base::local({
[13:24:23.593]             c <- base::c
[13:24:23.593]             inherits <- base::inherits
[13:24:23.593]             invokeRestart <- base::invokeRestart
[13:24:23.593]             length <- base::length
[13:24:23.593]             list <- base::list
[13:24:23.593]             seq.int <- base::seq.int
[13:24:23.593]             signalCondition <- base::signalCondition
[13:24:23.593]             sys.calls <- base::sys.calls
[13:24:23.593]             `[[` <- base::`[[`
[13:24:23.593]             `+` <- base::`+`
[13:24:23.593]             `<<-` <- base::`<<-`
[13:24:23.593]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.593]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.593]                   3L)]
[13:24:23.593]             }
[13:24:23.593]             function(cond) {
[13:24:23.593]                 is_error <- inherits(cond, "error")
[13:24:23.593]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.593]                   NULL)
[13:24:23.593]                 if (is_error) {
[13:24:23.593]                   sessionInformation <- function() {
[13:24:23.593]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.593]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.593]                       search = base::search(), system = base::Sys.info())
[13:24:23.593]                   }
[13:24:23.593]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.593]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.593]                     cond$call), session = sessionInformation(), 
[13:24:23.593]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.593]                   signalCondition(cond)
[13:24:23.593]                 }
[13:24:23.593]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.593]                 "immediateCondition"))) {
[13:24:23.593]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.593]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.593]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.593]                   if (TRUE && !signal) {
[13:24:23.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.593]                     {
[13:24:23.593]                       inherits <- base::inherits
[13:24:23.593]                       invokeRestart <- base::invokeRestart
[13:24:23.593]                       is.null <- base::is.null
[13:24:23.593]                       muffled <- FALSE
[13:24:23.593]                       if (inherits(cond, "message")) {
[13:24:23.593]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.593]                         if (muffled) 
[13:24:23.593]                           invokeRestart("muffleMessage")
[13:24:23.593]                       }
[13:24:23.593]                       else if (inherits(cond, "warning")) {
[13:24:23.593]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.593]                         if (muffled) 
[13:24:23.593]                           invokeRestart("muffleWarning")
[13:24:23.593]                       }
[13:24:23.593]                       else if (inherits(cond, "condition")) {
[13:24:23.593]                         if (!is.null(pattern)) {
[13:24:23.593]                           computeRestarts <- base::computeRestarts
[13:24:23.593]                           grepl <- base::grepl
[13:24:23.593]                           restarts <- computeRestarts(cond)
[13:24:23.593]                           for (restart in restarts) {
[13:24:23.593]                             name <- restart$name
[13:24:23.593]                             if (is.null(name)) 
[13:24:23.593]                               next
[13:24:23.593]                             if (!grepl(pattern, name)) 
[13:24:23.593]                               next
[13:24:23.593]                             invokeRestart(restart)
[13:24:23.593]                             muffled <- TRUE
[13:24:23.593]                             break
[13:24:23.593]                           }
[13:24:23.593]                         }
[13:24:23.593]                       }
[13:24:23.593]                       invisible(muffled)
[13:24:23.593]                     }
[13:24:23.593]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.593]                   }
[13:24:23.593]                 }
[13:24:23.593]                 else {
[13:24:23.593]                   if (TRUE) {
[13:24:23.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.593]                     {
[13:24:23.593]                       inherits <- base::inherits
[13:24:23.593]                       invokeRestart <- base::invokeRestart
[13:24:23.593]                       is.null <- base::is.null
[13:24:23.593]                       muffled <- FALSE
[13:24:23.593]                       if (inherits(cond, "message")) {
[13:24:23.593]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.593]                         if (muffled) 
[13:24:23.593]                           invokeRestart("muffleMessage")
[13:24:23.593]                       }
[13:24:23.593]                       else if (inherits(cond, "warning")) {
[13:24:23.593]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.593]                         if (muffled) 
[13:24:23.593]                           invokeRestart("muffleWarning")
[13:24:23.593]                       }
[13:24:23.593]                       else if (inherits(cond, "condition")) {
[13:24:23.593]                         if (!is.null(pattern)) {
[13:24:23.593]                           computeRestarts <- base::computeRestarts
[13:24:23.593]                           grepl <- base::grepl
[13:24:23.593]                           restarts <- computeRestarts(cond)
[13:24:23.593]                           for (restart in restarts) {
[13:24:23.593]                             name <- restart$name
[13:24:23.593]                             if (is.null(name)) 
[13:24:23.593]                               next
[13:24:23.593]                             if (!grepl(pattern, name)) 
[13:24:23.593]                               next
[13:24:23.593]                             invokeRestart(restart)
[13:24:23.593]                             muffled <- TRUE
[13:24:23.593]                             break
[13:24:23.593]                           }
[13:24:23.593]                         }
[13:24:23.593]                       }
[13:24:23.593]                       invisible(muffled)
[13:24:23.593]                     }
[13:24:23.593]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.593]                   }
[13:24:23.593]                 }
[13:24:23.593]             }
[13:24:23.593]         }))
[13:24:23.593]     }, error = function(ex) {
[13:24:23.593]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.593]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.593]                 ...future.rng), started = ...future.startTime, 
[13:24:23.593]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.593]             version = "1.8"), class = "FutureResult")
[13:24:23.593]     }, finally = {
[13:24:23.593]         if (!identical(...future.workdir, getwd())) 
[13:24:23.593]             setwd(...future.workdir)
[13:24:23.593]         {
[13:24:23.593]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.593]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.593]             }
[13:24:23.593]             base::options(...future.oldOptions)
[13:24:23.593]             if (.Platform$OS.type == "windows") {
[13:24:23.593]                 old_names <- names(...future.oldEnvVars)
[13:24:23.593]                 envs <- base::Sys.getenv()
[13:24:23.593]                 names <- names(envs)
[13:24:23.593]                 common <- intersect(names, old_names)
[13:24:23.593]                 added <- setdiff(names, old_names)
[13:24:23.593]                 removed <- setdiff(old_names, names)
[13:24:23.593]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.593]                   envs[common]]
[13:24:23.593]                 NAMES <- toupper(changed)
[13:24:23.593]                 args <- list()
[13:24:23.593]                 for (kk in seq_along(NAMES)) {
[13:24:23.593]                   name <- changed[[kk]]
[13:24:23.593]                   NAME <- NAMES[[kk]]
[13:24:23.593]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.593]                     next
[13:24:23.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.593]                 }
[13:24:23.593]                 NAMES <- toupper(added)
[13:24:23.593]                 for (kk in seq_along(NAMES)) {
[13:24:23.593]                   name <- added[[kk]]
[13:24:23.593]                   NAME <- NAMES[[kk]]
[13:24:23.593]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.593]                     next
[13:24:23.593]                   args[[name]] <- ""
[13:24:23.593]                 }
[13:24:23.593]                 NAMES <- toupper(removed)
[13:24:23.593]                 for (kk in seq_along(NAMES)) {
[13:24:23.593]                   name <- removed[[kk]]
[13:24:23.593]                   NAME <- NAMES[[kk]]
[13:24:23.593]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.593]                     next
[13:24:23.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.593]                 }
[13:24:23.593]                 if (length(args) > 0) 
[13:24:23.593]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.593]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.593]             }
[13:24:23.593]             else {
[13:24:23.593]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.593]             }
[13:24:23.593]             {
[13:24:23.593]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.593]                   0L) {
[13:24:23.593]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.593]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.593]                   base::options(opts)
[13:24:23.593]                 }
[13:24:23.593]                 {
[13:24:23.593]                   {
[13:24:23.593]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.593]                     NULL
[13:24:23.593]                   }
[13:24:23.593]                   options(future.plan = NULL)
[13:24:23.593]                   if (is.na(NA_character_)) 
[13:24:23.593]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.593]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.593]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.593]                     envir = parent.frame()) 
[13:24:23.593]                   {
[13:24:23.593]                     default_workers <- missing(workers)
[13:24:23.593]                     if (is.function(workers)) 
[13:24:23.593]                       workers <- workers()
[13:24:23.593]                     workers <- structure(as.integer(workers), 
[13:24:23.593]                       class = class(workers))
[13:24:23.593]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.593]                       1L)
[13:24:23.593]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.593]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.593]                       if (default_workers) 
[13:24:23.593]                         supportsMulticore(warn = TRUE)
[13:24:23.593]                       return(sequential(..., envir = envir))
[13:24:23.593]                     }
[13:24:23.593]                     oopts <- options(mc.cores = workers)
[13:24:23.593]                     on.exit(options(oopts))
[13:24:23.593]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.593]                       envir = envir)
[13:24:23.593]                     if (!future$lazy) 
[13:24:23.593]                       future <- run(future)
[13:24:23.593]                     invisible(future)
[13:24:23.593]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.593]                 }
[13:24:23.593]             }
[13:24:23.593]         }
[13:24:23.593]     })
[13:24:23.593]     if (TRUE) {
[13:24:23.593]         base::sink(type = "output", split = FALSE)
[13:24:23.593]         if (TRUE) {
[13:24:23.593]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.593]         }
[13:24:23.593]         else {
[13:24:23.593]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.593]         }
[13:24:23.593]         base::close(...future.stdout)
[13:24:23.593]         ...future.stdout <- NULL
[13:24:23.593]     }
[13:24:23.593]     ...future.result$conditions <- ...future.conditions
[13:24:23.593]     ...future.result$finished <- base::Sys.time()
[13:24:23.593]     ...future.result
[13:24:23.593] }
[13:24:23.596] assign_globals() ...
[13:24:23.596] List of 1
[13:24:23.596]  $ kk: int 1
[13:24:23.596]  - attr(*, "where")=List of 1
[13:24:23.596]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:23.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:23.596]  - attr(*, "resolved")= logi FALSE
[13:24:23.596]  - attr(*, "total_size")= num 56
[13:24:23.596]  - attr(*, "already-done")= logi TRUE
[13:24:23.601] - copied ‘kk’ to environment
[13:24:23.601] assign_globals() ... done
[13:24:23.601] requestCore(): workers = 2
[13:24:23.601] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.612] result() for MulticoreFuture ...
[13:24:23.613] result() for MulticoreFuture ...
[13:24:23.613] result() for MulticoreFuture ... done
[13:24:23.613] result() for MulticoreFuture ... done
[13:24:23.613] result() for MulticoreFuture ...
[13:24:23.614] result() for MulticoreFuture ... done
[13:24:23.616] MulticoreFuture started
[13:24:23.617] - Launch lazy future ... done
[13:24:23.617] run() for ‘MulticoreFuture’ ... done
[13:24:23.618] plan(): Setting new future strategy stack:
[13:24:23.618] List of future strategies:
[13:24:23.618] 1. sequential:
[13:24:23.618]    - args: function (..., envir = parent.frame())
[13:24:23.618]    - tweaked: FALSE
[13:24:23.618]    - call: NULL
[13:24:23.619] plan(): nbrOfWorkers() = 1
[13:24:23.628] run() for ‘Future’ ...
[13:24:23.628] - state: ‘created’
[13:24:23.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.635]   - Field: ‘label’
[13:24:23.635]   - Field: ‘local’
[13:24:23.635]   - Field: ‘owner’
[13:24:23.635]   - Field: ‘envir’
[13:24:23.635]   - Field: ‘workers’
[13:24:23.636]   - Field: ‘packages’
[13:24:23.636]   - Field: ‘gc’
[13:24:23.636]   - Field: ‘job’
[13:24:23.636]   - Field: ‘conditions’
[13:24:23.636]   - Field: ‘expr’
[13:24:23.636]   - Field: ‘uuid’
[13:24:23.637]   - Field: ‘seed’
[13:24:23.637]   - Field: ‘version’
[13:24:23.637]   - Field: ‘result’
[13:24:23.637]   - Field: ‘asynchronous’
[13:24:23.637]   - Field: ‘calls’
[13:24:23.637]   - Field: ‘globals’
[13:24:23.638]   - Field: ‘stdout’
[13:24:23.638]   - Field: ‘earlySignal’
[13:24:23.638]   - Field: ‘lazy’
[13:24:23.638]   - Field: ‘state’
[13:24:23.638] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.638] - Launch lazy future ...
[13:24:23.639] Packages needed by the future expression (n = 0): <none>
[13:24:23.639] Packages needed by future strategies (n = 0): <none>
[13:24:23.640] {
[13:24:23.640]     {
[13:24:23.640]         {
[13:24:23.640]             ...future.startTime <- base::Sys.time()
[13:24:23.640]             {
[13:24:23.640]                 {
[13:24:23.640]                   {
[13:24:23.640]                     {
[13:24:23.640]                       base::local({
[13:24:23.640]                         has_future <- base::requireNamespace("future", 
[13:24:23.640]                           quietly = TRUE)
[13:24:23.640]                         if (has_future) {
[13:24:23.640]                           ns <- base::getNamespace("future")
[13:24:23.640]                           version <- ns[[".package"]][["version"]]
[13:24:23.640]                           if (is.null(version)) 
[13:24:23.640]                             version <- utils::packageVersion("future")
[13:24:23.640]                         }
[13:24:23.640]                         else {
[13:24:23.640]                           version <- NULL
[13:24:23.640]                         }
[13:24:23.640]                         if (!has_future || version < "1.8.0") {
[13:24:23.640]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.640]                             "", base::R.version$version.string), 
[13:24:23.640]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.640]                               "release", "version")], collapse = " "), 
[13:24:23.640]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.640]                             info)
[13:24:23.640]                           info <- base::paste(info, collapse = "; ")
[13:24:23.640]                           if (!has_future) {
[13:24:23.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.640]                               info)
[13:24:23.640]                           }
[13:24:23.640]                           else {
[13:24:23.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.640]                               info, version)
[13:24:23.640]                           }
[13:24:23.640]                           base::stop(msg)
[13:24:23.640]                         }
[13:24:23.640]                       })
[13:24:23.640]                     }
[13:24:23.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.640]                     base::options(mc.cores = 1L)
[13:24:23.640]                   }
[13:24:23.640]                   options(future.plan = NULL)
[13:24:23.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.640]                 }
[13:24:23.640]                 ...future.workdir <- getwd()
[13:24:23.640]             }
[13:24:23.640]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.640]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.640]         }
[13:24:23.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.640]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.640]             base::names(...future.oldOptions))
[13:24:23.640]     }
[13:24:23.640]     if (FALSE) {
[13:24:23.640]     }
[13:24:23.640]     else {
[13:24:23.640]         if (TRUE) {
[13:24:23.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.640]                 open = "w")
[13:24:23.640]         }
[13:24:23.640]         else {
[13:24:23.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.640]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.640]         }
[13:24:23.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.640]             base::sink(type = "output", split = FALSE)
[13:24:23.640]             base::close(...future.stdout)
[13:24:23.640]         }, add = TRUE)
[13:24:23.640]     }
[13:24:23.640]     ...future.frame <- base::sys.nframe()
[13:24:23.640]     ...future.conditions <- base::list()
[13:24:23.640]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.640]     if (FALSE) {
[13:24:23.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.640]     }
[13:24:23.640]     ...future.result <- base::tryCatch({
[13:24:23.640]         base::withCallingHandlers({
[13:24:23.640]             ...future.value <- base::withVisible(base::local({
[13:24:23.640]                 withCallingHandlers({
[13:24:23.640]                   {
[13:24:23.640]                     Sys.sleep(0.1)
[13:24:23.640]                     kk
[13:24:23.640]                   }
[13:24:23.640]                 }, immediateCondition = function(cond) {
[13:24:23.640]                   save_rds <- function (object, pathname, ...) 
[13:24:23.640]                   {
[13:24:23.640]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.640]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.640]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.640]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.640]                         fi_tmp[["mtime"]])
[13:24:23.640]                     }
[13:24:23.640]                     tryCatch({
[13:24:23.640]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.640]                     }, error = function(ex) {
[13:24:23.640]                       msg <- conditionMessage(ex)
[13:24:23.640]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.640]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.640]                         fi_tmp[["mtime"]], msg)
[13:24:23.640]                       ex$message <- msg
[13:24:23.640]                       stop(ex)
[13:24:23.640]                     })
[13:24:23.640]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.640]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.640]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.640]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.640]                       fi <- file.info(pathname)
[13:24:23.640]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.640]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.640]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.640]                         fi[["size"]], fi[["mtime"]])
[13:24:23.640]                       stop(msg)
[13:24:23.640]                     }
[13:24:23.640]                     invisible(pathname)
[13:24:23.640]                   }
[13:24:23.640]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.640]                     rootPath = tempdir()) 
[13:24:23.640]                   {
[13:24:23.640]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.640]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.640]                       tmpdir = path, fileext = ".rds")
[13:24:23.640]                     save_rds(obj, file)
[13:24:23.640]                   }
[13:24:23.640]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.640]                   {
[13:24:23.640]                     inherits <- base::inherits
[13:24:23.640]                     invokeRestart <- base::invokeRestart
[13:24:23.640]                     is.null <- base::is.null
[13:24:23.640]                     muffled <- FALSE
[13:24:23.640]                     if (inherits(cond, "message")) {
[13:24:23.640]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.640]                       if (muffled) 
[13:24:23.640]                         invokeRestart("muffleMessage")
[13:24:23.640]                     }
[13:24:23.640]                     else if (inherits(cond, "warning")) {
[13:24:23.640]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.640]                       if (muffled) 
[13:24:23.640]                         invokeRestart("muffleWarning")
[13:24:23.640]                     }
[13:24:23.640]                     else if (inherits(cond, "condition")) {
[13:24:23.640]                       if (!is.null(pattern)) {
[13:24:23.640]                         computeRestarts <- base::computeRestarts
[13:24:23.640]                         grepl <- base::grepl
[13:24:23.640]                         restarts <- computeRestarts(cond)
[13:24:23.640]                         for (restart in restarts) {
[13:24:23.640]                           name <- restart$name
[13:24:23.640]                           if (is.null(name)) 
[13:24:23.640]                             next
[13:24:23.640]                           if (!grepl(pattern, name)) 
[13:24:23.640]                             next
[13:24:23.640]                           invokeRestart(restart)
[13:24:23.640]                           muffled <- TRUE
[13:24:23.640]                           break
[13:24:23.640]                         }
[13:24:23.640]                       }
[13:24:23.640]                     }
[13:24:23.640]                     invisible(muffled)
[13:24:23.640]                   }
[13:24:23.640]                   muffleCondition(cond)
[13:24:23.640]                 })
[13:24:23.640]             }))
[13:24:23.640]             future::FutureResult(value = ...future.value$value, 
[13:24:23.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.640]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.640]                     ...future.globalenv.names))
[13:24:23.640]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.640]         }, condition = base::local({
[13:24:23.640]             c <- base::c
[13:24:23.640]             inherits <- base::inherits
[13:24:23.640]             invokeRestart <- base::invokeRestart
[13:24:23.640]             length <- base::length
[13:24:23.640]             list <- base::list
[13:24:23.640]             seq.int <- base::seq.int
[13:24:23.640]             signalCondition <- base::signalCondition
[13:24:23.640]             sys.calls <- base::sys.calls
[13:24:23.640]             `[[` <- base::`[[`
[13:24:23.640]             `+` <- base::`+`
[13:24:23.640]             `<<-` <- base::`<<-`
[13:24:23.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.640]                   3L)]
[13:24:23.640]             }
[13:24:23.640]             function(cond) {
[13:24:23.640]                 is_error <- inherits(cond, "error")
[13:24:23.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.640]                   NULL)
[13:24:23.640]                 if (is_error) {
[13:24:23.640]                   sessionInformation <- function() {
[13:24:23.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.640]                       search = base::search(), system = base::Sys.info())
[13:24:23.640]                   }
[13:24:23.640]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.640]                     cond$call), session = sessionInformation(), 
[13:24:23.640]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.640]                   signalCondition(cond)
[13:24:23.640]                 }
[13:24:23.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.640]                 "immediateCondition"))) {
[13:24:23.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.640]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.640]                   if (TRUE && !signal) {
[13:24:23.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.640]                     {
[13:24:23.640]                       inherits <- base::inherits
[13:24:23.640]                       invokeRestart <- base::invokeRestart
[13:24:23.640]                       is.null <- base::is.null
[13:24:23.640]                       muffled <- FALSE
[13:24:23.640]                       if (inherits(cond, "message")) {
[13:24:23.640]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.640]                         if (muffled) 
[13:24:23.640]                           invokeRestart("muffleMessage")
[13:24:23.640]                       }
[13:24:23.640]                       else if (inherits(cond, "warning")) {
[13:24:23.640]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.640]                         if (muffled) 
[13:24:23.640]                           invokeRestart("muffleWarning")
[13:24:23.640]                       }
[13:24:23.640]                       else if (inherits(cond, "condition")) {
[13:24:23.640]                         if (!is.null(pattern)) {
[13:24:23.640]                           computeRestarts <- base::computeRestarts
[13:24:23.640]                           grepl <- base::grepl
[13:24:23.640]                           restarts <- computeRestarts(cond)
[13:24:23.640]                           for (restart in restarts) {
[13:24:23.640]                             name <- restart$name
[13:24:23.640]                             if (is.null(name)) 
[13:24:23.640]                               next
[13:24:23.640]                             if (!grepl(pattern, name)) 
[13:24:23.640]                               next
[13:24:23.640]                             invokeRestart(restart)
[13:24:23.640]                             muffled <- TRUE
[13:24:23.640]                             break
[13:24:23.640]                           }
[13:24:23.640]                         }
[13:24:23.640]                       }
[13:24:23.640]                       invisible(muffled)
[13:24:23.640]                     }
[13:24:23.640]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.640]                   }
[13:24:23.640]                 }
[13:24:23.640]                 else {
[13:24:23.640]                   if (TRUE) {
[13:24:23.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.640]                     {
[13:24:23.640]                       inherits <- base::inherits
[13:24:23.640]                       invokeRestart <- base::invokeRestart
[13:24:23.640]                       is.null <- base::is.null
[13:24:23.640]                       muffled <- FALSE
[13:24:23.640]                       if (inherits(cond, "message")) {
[13:24:23.640]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.640]                         if (muffled) 
[13:24:23.640]                           invokeRestart("muffleMessage")
[13:24:23.640]                       }
[13:24:23.640]                       else if (inherits(cond, "warning")) {
[13:24:23.640]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.640]                         if (muffled) 
[13:24:23.640]                           invokeRestart("muffleWarning")
[13:24:23.640]                       }
[13:24:23.640]                       else if (inherits(cond, "condition")) {
[13:24:23.640]                         if (!is.null(pattern)) {
[13:24:23.640]                           computeRestarts <- base::computeRestarts
[13:24:23.640]                           grepl <- base::grepl
[13:24:23.640]                           restarts <- computeRestarts(cond)
[13:24:23.640]                           for (restart in restarts) {
[13:24:23.640]                             name <- restart$name
[13:24:23.640]                             if (is.null(name)) 
[13:24:23.640]                               next
[13:24:23.640]                             if (!grepl(pattern, name)) 
[13:24:23.640]                               next
[13:24:23.640]                             invokeRestart(restart)
[13:24:23.640]                             muffled <- TRUE
[13:24:23.640]                             break
[13:24:23.640]                           }
[13:24:23.640]                         }
[13:24:23.640]                       }
[13:24:23.640]                       invisible(muffled)
[13:24:23.640]                     }
[13:24:23.640]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.640]                   }
[13:24:23.640]                 }
[13:24:23.640]             }
[13:24:23.640]         }))
[13:24:23.640]     }, error = function(ex) {
[13:24:23.640]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.640]                 ...future.rng), started = ...future.startTime, 
[13:24:23.640]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.640]             version = "1.8"), class = "FutureResult")
[13:24:23.640]     }, finally = {
[13:24:23.640]         if (!identical(...future.workdir, getwd())) 
[13:24:23.640]             setwd(...future.workdir)
[13:24:23.640]         {
[13:24:23.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.640]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.640]             }
[13:24:23.640]             base::options(...future.oldOptions)
[13:24:23.640]             if (.Platform$OS.type == "windows") {
[13:24:23.640]                 old_names <- names(...future.oldEnvVars)
[13:24:23.640]                 envs <- base::Sys.getenv()
[13:24:23.640]                 names <- names(envs)
[13:24:23.640]                 common <- intersect(names, old_names)
[13:24:23.640]                 added <- setdiff(names, old_names)
[13:24:23.640]                 removed <- setdiff(old_names, names)
[13:24:23.640]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.640]                   envs[common]]
[13:24:23.640]                 NAMES <- toupper(changed)
[13:24:23.640]                 args <- list()
[13:24:23.640]                 for (kk in seq_along(NAMES)) {
[13:24:23.640]                   name <- changed[[kk]]
[13:24:23.640]                   NAME <- NAMES[[kk]]
[13:24:23.640]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.640]                     next
[13:24:23.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.640]                 }
[13:24:23.640]                 NAMES <- toupper(added)
[13:24:23.640]                 for (kk in seq_along(NAMES)) {
[13:24:23.640]                   name <- added[[kk]]
[13:24:23.640]                   NAME <- NAMES[[kk]]
[13:24:23.640]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.640]                     next
[13:24:23.640]                   args[[name]] <- ""
[13:24:23.640]                 }
[13:24:23.640]                 NAMES <- toupper(removed)
[13:24:23.640]                 for (kk in seq_along(NAMES)) {
[13:24:23.640]                   name <- removed[[kk]]
[13:24:23.640]                   NAME <- NAMES[[kk]]
[13:24:23.640]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.640]                     next
[13:24:23.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.640]                 }
[13:24:23.640]                 if (length(args) > 0) 
[13:24:23.640]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.640]             }
[13:24:23.640]             else {
[13:24:23.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.640]             }
[13:24:23.640]             {
[13:24:23.640]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.640]                   0L) {
[13:24:23.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.640]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.640]                   base::options(opts)
[13:24:23.640]                 }
[13:24:23.640]                 {
[13:24:23.640]                   {
[13:24:23.640]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.640]                     NULL
[13:24:23.640]                   }
[13:24:23.640]                   options(future.plan = NULL)
[13:24:23.640]                   if (is.na(NA_character_)) 
[13:24:23.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.640]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.640]                     envir = parent.frame()) 
[13:24:23.640]                   {
[13:24:23.640]                     default_workers <- missing(workers)
[13:24:23.640]                     if (is.function(workers)) 
[13:24:23.640]                       workers <- workers()
[13:24:23.640]                     workers <- structure(as.integer(workers), 
[13:24:23.640]                       class = class(workers))
[13:24:23.640]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.640]                       1L)
[13:24:23.640]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.640]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.640]                       if (default_workers) 
[13:24:23.640]                         supportsMulticore(warn = TRUE)
[13:24:23.640]                       return(sequential(..., envir = envir))
[13:24:23.640]                     }
[13:24:23.640]                     oopts <- options(mc.cores = workers)
[13:24:23.640]                     on.exit(options(oopts))
[13:24:23.640]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.640]                       envir = envir)
[13:24:23.640]                     if (!future$lazy) 
[13:24:23.640]                       future <- run(future)
[13:24:23.640]                     invisible(future)
[13:24:23.640]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.640]                 }
[13:24:23.640]             }
[13:24:23.640]         }
[13:24:23.640]     })
[13:24:23.640]     if (TRUE) {
[13:24:23.640]         base::sink(type = "output", split = FALSE)
[13:24:23.640]         if (TRUE) {
[13:24:23.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.640]         }
[13:24:23.640]         else {
[13:24:23.640]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.640]         }
[13:24:23.640]         base::close(...future.stdout)
[13:24:23.640]         ...future.stdout <- NULL
[13:24:23.640]     }
[13:24:23.640]     ...future.result$conditions <- ...future.conditions
[13:24:23.640]     ...future.result$finished <- base::Sys.time()
[13:24:23.640]     ...future.result
[13:24:23.640] }
[13:24:23.644] assign_globals() ...
[13:24:23.644] List of 1
[13:24:23.644]  $ kk: int 2
[13:24:23.644]  - attr(*, "where")=List of 1
[13:24:23.644]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:23.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:23.644]  - attr(*, "resolved")= logi FALSE
[13:24:23.644]  - attr(*, "total_size")= num 56
[13:24:23.644]  - attr(*, "already-done")= logi TRUE
[13:24:23.648] - copied ‘kk’ to environment
[13:24:23.648] assign_globals() ... done
[13:24:23.648] requestCore(): workers = 2
[13:24:23.649] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.659] result() for MulticoreFuture ...
[13:24:23.661] result() for MulticoreFuture ...
[13:24:23.661] result() for MulticoreFuture ... done
[13:24:23.661] result() for MulticoreFuture ... done
[13:24:23.661] result() for MulticoreFuture ...
[13:24:23.661] result() for MulticoreFuture ... done
[13:24:23.663] MulticoreFuture started
[13:24:23.664] - Launch lazy future ... done
[13:24:23.664] run() for ‘MulticoreFuture’ ... done
[13:24:23.665] plan(): Setting new future strategy stack:
[13:24:23.665] List of future strategies:
[13:24:23.665] 1. sequential:
[13:24:23.665]    - args: function (..., envir = parent.frame())
[13:24:23.665]    - tweaked: FALSE
[13:24:23.665]    - call: NULL
[13:24:23.666] plan(): nbrOfWorkers() = 1
[13:24:23.675] run() for ‘Future’ ...
[13:24:23.675] - state: ‘created’
[13:24:23.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.682] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.682]   - Field: ‘label’
[13:24:23.682]   - Field: ‘local’
[13:24:23.682]   - Field: ‘owner’
[13:24:23.683]   - Field: ‘envir’
[13:24:23.683]   - Field: ‘workers’
[13:24:23.683]   - Field: ‘packages’
[13:24:23.683]   - Field: ‘gc’
[13:24:23.683]   - Field: ‘job’
[13:24:23.683]   - Field: ‘conditions’
[13:24:23.684]   - Field: ‘expr’
[13:24:23.684]   - Field: ‘uuid’
[13:24:23.684]   - Field: ‘seed’
[13:24:23.684]   - Field: ‘version’
[13:24:23.684]   - Field: ‘result’
[13:24:23.684]   - Field: ‘asynchronous’
[13:24:23.684]   - Field: ‘calls’
[13:24:23.685]   - Field: ‘globals’
[13:24:23.685]   - Field: ‘stdout’
[13:24:23.685]   - Field: ‘earlySignal’
[13:24:23.685]   - Field: ‘lazy’
[13:24:23.685]   - Field: ‘state’
[13:24:23.685] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.686] - Launch lazy future ...
[13:24:23.686] Packages needed by the future expression (n = 0): <none>
[13:24:23.686] Packages needed by future strategies (n = 0): <none>
[13:24:23.687] {
[13:24:23.687]     {
[13:24:23.687]         {
[13:24:23.687]             ...future.startTime <- base::Sys.time()
[13:24:23.687]             {
[13:24:23.687]                 {
[13:24:23.687]                   {
[13:24:23.687]                     {
[13:24:23.687]                       base::local({
[13:24:23.687]                         has_future <- base::requireNamespace("future", 
[13:24:23.687]                           quietly = TRUE)
[13:24:23.687]                         if (has_future) {
[13:24:23.687]                           ns <- base::getNamespace("future")
[13:24:23.687]                           version <- ns[[".package"]][["version"]]
[13:24:23.687]                           if (is.null(version)) 
[13:24:23.687]                             version <- utils::packageVersion("future")
[13:24:23.687]                         }
[13:24:23.687]                         else {
[13:24:23.687]                           version <- NULL
[13:24:23.687]                         }
[13:24:23.687]                         if (!has_future || version < "1.8.0") {
[13:24:23.687]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.687]                             "", base::R.version$version.string), 
[13:24:23.687]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.687]                               "release", "version")], collapse = " "), 
[13:24:23.687]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.687]                             info)
[13:24:23.687]                           info <- base::paste(info, collapse = "; ")
[13:24:23.687]                           if (!has_future) {
[13:24:23.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.687]                               info)
[13:24:23.687]                           }
[13:24:23.687]                           else {
[13:24:23.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.687]                               info, version)
[13:24:23.687]                           }
[13:24:23.687]                           base::stop(msg)
[13:24:23.687]                         }
[13:24:23.687]                       })
[13:24:23.687]                     }
[13:24:23.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.687]                     base::options(mc.cores = 1L)
[13:24:23.687]                   }
[13:24:23.687]                   options(future.plan = NULL)
[13:24:23.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.687]                 }
[13:24:23.687]                 ...future.workdir <- getwd()
[13:24:23.687]             }
[13:24:23.687]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.687]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.687]         }
[13:24:23.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.687]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.687]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.687]             base::names(...future.oldOptions))
[13:24:23.687]     }
[13:24:23.687]     if (FALSE) {
[13:24:23.687]     }
[13:24:23.687]     else {
[13:24:23.687]         if (TRUE) {
[13:24:23.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.687]                 open = "w")
[13:24:23.687]         }
[13:24:23.687]         else {
[13:24:23.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.687]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.687]         }
[13:24:23.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.687]             base::sink(type = "output", split = FALSE)
[13:24:23.687]             base::close(...future.stdout)
[13:24:23.687]         }, add = TRUE)
[13:24:23.687]     }
[13:24:23.687]     ...future.frame <- base::sys.nframe()
[13:24:23.687]     ...future.conditions <- base::list()
[13:24:23.687]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.687]     if (FALSE) {
[13:24:23.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.687]     }
[13:24:23.687]     ...future.result <- base::tryCatch({
[13:24:23.687]         base::withCallingHandlers({
[13:24:23.687]             ...future.value <- base::withVisible(base::local({
[13:24:23.687]                 withCallingHandlers({
[13:24:23.687]                   {
[13:24:23.687]                     Sys.sleep(0.1)
[13:24:23.687]                     kk
[13:24:23.687]                   }
[13:24:23.687]                 }, immediateCondition = function(cond) {
[13:24:23.687]                   save_rds <- function (object, pathname, ...) 
[13:24:23.687]                   {
[13:24:23.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.687]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.687]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.687]                         fi_tmp[["mtime"]])
[13:24:23.687]                     }
[13:24:23.687]                     tryCatch({
[13:24:23.687]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.687]                     }, error = function(ex) {
[13:24:23.687]                       msg <- conditionMessage(ex)
[13:24:23.687]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.687]                         fi_tmp[["mtime"]], msg)
[13:24:23.687]                       ex$message <- msg
[13:24:23.687]                       stop(ex)
[13:24:23.687]                     })
[13:24:23.687]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.687]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.687]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.687]                       fi <- file.info(pathname)
[13:24:23.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.687]                         fi[["size"]], fi[["mtime"]])
[13:24:23.687]                       stop(msg)
[13:24:23.687]                     }
[13:24:23.687]                     invisible(pathname)
[13:24:23.687]                   }
[13:24:23.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.687]                     rootPath = tempdir()) 
[13:24:23.687]                   {
[13:24:23.687]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.687]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.687]                       tmpdir = path, fileext = ".rds")
[13:24:23.687]                     save_rds(obj, file)
[13:24:23.687]                   }
[13:24:23.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.687]                   {
[13:24:23.687]                     inherits <- base::inherits
[13:24:23.687]                     invokeRestart <- base::invokeRestart
[13:24:23.687]                     is.null <- base::is.null
[13:24:23.687]                     muffled <- FALSE
[13:24:23.687]                     if (inherits(cond, "message")) {
[13:24:23.687]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.687]                       if (muffled) 
[13:24:23.687]                         invokeRestart("muffleMessage")
[13:24:23.687]                     }
[13:24:23.687]                     else if (inherits(cond, "warning")) {
[13:24:23.687]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.687]                       if (muffled) 
[13:24:23.687]                         invokeRestart("muffleWarning")
[13:24:23.687]                     }
[13:24:23.687]                     else if (inherits(cond, "condition")) {
[13:24:23.687]                       if (!is.null(pattern)) {
[13:24:23.687]                         computeRestarts <- base::computeRestarts
[13:24:23.687]                         grepl <- base::grepl
[13:24:23.687]                         restarts <- computeRestarts(cond)
[13:24:23.687]                         for (restart in restarts) {
[13:24:23.687]                           name <- restart$name
[13:24:23.687]                           if (is.null(name)) 
[13:24:23.687]                             next
[13:24:23.687]                           if (!grepl(pattern, name)) 
[13:24:23.687]                             next
[13:24:23.687]                           invokeRestart(restart)
[13:24:23.687]                           muffled <- TRUE
[13:24:23.687]                           break
[13:24:23.687]                         }
[13:24:23.687]                       }
[13:24:23.687]                     }
[13:24:23.687]                     invisible(muffled)
[13:24:23.687]                   }
[13:24:23.687]                   muffleCondition(cond)
[13:24:23.687]                 })
[13:24:23.687]             }))
[13:24:23.687]             future::FutureResult(value = ...future.value$value, 
[13:24:23.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.687]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.687]                     ...future.globalenv.names))
[13:24:23.687]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.687]         }, condition = base::local({
[13:24:23.687]             c <- base::c
[13:24:23.687]             inherits <- base::inherits
[13:24:23.687]             invokeRestart <- base::invokeRestart
[13:24:23.687]             length <- base::length
[13:24:23.687]             list <- base::list
[13:24:23.687]             seq.int <- base::seq.int
[13:24:23.687]             signalCondition <- base::signalCondition
[13:24:23.687]             sys.calls <- base::sys.calls
[13:24:23.687]             `[[` <- base::`[[`
[13:24:23.687]             `+` <- base::`+`
[13:24:23.687]             `<<-` <- base::`<<-`
[13:24:23.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.687]                   3L)]
[13:24:23.687]             }
[13:24:23.687]             function(cond) {
[13:24:23.687]                 is_error <- inherits(cond, "error")
[13:24:23.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.687]                   NULL)
[13:24:23.687]                 if (is_error) {
[13:24:23.687]                   sessionInformation <- function() {
[13:24:23.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.687]                       search = base::search(), system = base::Sys.info())
[13:24:23.687]                   }
[13:24:23.687]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.687]                     cond$call), session = sessionInformation(), 
[13:24:23.687]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.687]                   signalCondition(cond)
[13:24:23.687]                 }
[13:24:23.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.687]                 "immediateCondition"))) {
[13:24:23.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.687]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.687]                   if (TRUE && !signal) {
[13:24:23.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.687]                     {
[13:24:23.687]                       inherits <- base::inherits
[13:24:23.687]                       invokeRestart <- base::invokeRestart
[13:24:23.687]                       is.null <- base::is.null
[13:24:23.687]                       muffled <- FALSE
[13:24:23.687]                       if (inherits(cond, "message")) {
[13:24:23.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.687]                         if (muffled) 
[13:24:23.687]                           invokeRestart("muffleMessage")
[13:24:23.687]                       }
[13:24:23.687]                       else if (inherits(cond, "warning")) {
[13:24:23.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.687]                         if (muffled) 
[13:24:23.687]                           invokeRestart("muffleWarning")
[13:24:23.687]                       }
[13:24:23.687]                       else if (inherits(cond, "condition")) {
[13:24:23.687]                         if (!is.null(pattern)) {
[13:24:23.687]                           computeRestarts <- base::computeRestarts
[13:24:23.687]                           grepl <- base::grepl
[13:24:23.687]                           restarts <- computeRestarts(cond)
[13:24:23.687]                           for (restart in restarts) {
[13:24:23.687]                             name <- restart$name
[13:24:23.687]                             if (is.null(name)) 
[13:24:23.687]                               next
[13:24:23.687]                             if (!grepl(pattern, name)) 
[13:24:23.687]                               next
[13:24:23.687]                             invokeRestart(restart)
[13:24:23.687]                             muffled <- TRUE
[13:24:23.687]                             break
[13:24:23.687]                           }
[13:24:23.687]                         }
[13:24:23.687]                       }
[13:24:23.687]                       invisible(muffled)
[13:24:23.687]                     }
[13:24:23.687]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.687]                   }
[13:24:23.687]                 }
[13:24:23.687]                 else {
[13:24:23.687]                   if (TRUE) {
[13:24:23.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.687]                     {
[13:24:23.687]                       inherits <- base::inherits
[13:24:23.687]                       invokeRestart <- base::invokeRestart
[13:24:23.687]                       is.null <- base::is.null
[13:24:23.687]                       muffled <- FALSE
[13:24:23.687]                       if (inherits(cond, "message")) {
[13:24:23.687]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.687]                         if (muffled) 
[13:24:23.687]                           invokeRestart("muffleMessage")
[13:24:23.687]                       }
[13:24:23.687]                       else if (inherits(cond, "warning")) {
[13:24:23.687]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.687]                         if (muffled) 
[13:24:23.687]                           invokeRestart("muffleWarning")
[13:24:23.687]                       }
[13:24:23.687]                       else if (inherits(cond, "condition")) {
[13:24:23.687]                         if (!is.null(pattern)) {
[13:24:23.687]                           computeRestarts <- base::computeRestarts
[13:24:23.687]                           grepl <- base::grepl
[13:24:23.687]                           restarts <- computeRestarts(cond)
[13:24:23.687]                           for (restart in restarts) {
[13:24:23.687]                             name <- restart$name
[13:24:23.687]                             if (is.null(name)) 
[13:24:23.687]                               next
[13:24:23.687]                             if (!grepl(pattern, name)) 
[13:24:23.687]                               next
[13:24:23.687]                             invokeRestart(restart)
[13:24:23.687]                             muffled <- TRUE
[13:24:23.687]                             break
[13:24:23.687]                           }
[13:24:23.687]                         }
[13:24:23.687]                       }
[13:24:23.687]                       invisible(muffled)
[13:24:23.687]                     }
[13:24:23.687]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.687]                   }
[13:24:23.687]                 }
[13:24:23.687]             }
[13:24:23.687]         }))
[13:24:23.687]     }, error = function(ex) {
[13:24:23.687]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.687]                 ...future.rng), started = ...future.startTime, 
[13:24:23.687]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.687]             version = "1.8"), class = "FutureResult")
[13:24:23.687]     }, finally = {
[13:24:23.687]         if (!identical(...future.workdir, getwd())) 
[13:24:23.687]             setwd(...future.workdir)
[13:24:23.687]         {
[13:24:23.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.687]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.687]             }
[13:24:23.687]             base::options(...future.oldOptions)
[13:24:23.687]             if (.Platform$OS.type == "windows") {
[13:24:23.687]                 old_names <- names(...future.oldEnvVars)
[13:24:23.687]                 envs <- base::Sys.getenv()
[13:24:23.687]                 names <- names(envs)
[13:24:23.687]                 common <- intersect(names, old_names)
[13:24:23.687]                 added <- setdiff(names, old_names)
[13:24:23.687]                 removed <- setdiff(old_names, names)
[13:24:23.687]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.687]                   envs[common]]
[13:24:23.687]                 NAMES <- toupper(changed)
[13:24:23.687]                 args <- list()
[13:24:23.687]                 for (kk in seq_along(NAMES)) {
[13:24:23.687]                   name <- changed[[kk]]
[13:24:23.687]                   NAME <- NAMES[[kk]]
[13:24:23.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.687]                     next
[13:24:23.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.687]                 }
[13:24:23.687]                 NAMES <- toupper(added)
[13:24:23.687]                 for (kk in seq_along(NAMES)) {
[13:24:23.687]                   name <- added[[kk]]
[13:24:23.687]                   NAME <- NAMES[[kk]]
[13:24:23.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.687]                     next
[13:24:23.687]                   args[[name]] <- ""
[13:24:23.687]                 }
[13:24:23.687]                 NAMES <- toupper(removed)
[13:24:23.687]                 for (kk in seq_along(NAMES)) {
[13:24:23.687]                   name <- removed[[kk]]
[13:24:23.687]                   NAME <- NAMES[[kk]]
[13:24:23.687]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.687]                     next
[13:24:23.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.687]                 }
[13:24:23.687]                 if (length(args) > 0) 
[13:24:23.687]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.687]             }
[13:24:23.687]             else {
[13:24:23.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.687]             }
[13:24:23.687]             {
[13:24:23.687]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.687]                   0L) {
[13:24:23.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.687]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.687]                   base::options(opts)
[13:24:23.687]                 }
[13:24:23.687]                 {
[13:24:23.687]                   {
[13:24:23.687]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.687]                     NULL
[13:24:23.687]                   }
[13:24:23.687]                   options(future.plan = NULL)
[13:24:23.687]                   if (is.na(NA_character_)) 
[13:24:23.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.687]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.687]                     envir = parent.frame()) 
[13:24:23.687]                   {
[13:24:23.687]                     default_workers <- missing(workers)
[13:24:23.687]                     if (is.function(workers)) 
[13:24:23.687]                       workers <- workers()
[13:24:23.687]                     workers <- structure(as.integer(workers), 
[13:24:23.687]                       class = class(workers))
[13:24:23.687]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.687]                       1L)
[13:24:23.687]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.687]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.687]                       if (default_workers) 
[13:24:23.687]                         supportsMulticore(warn = TRUE)
[13:24:23.687]                       return(sequential(..., envir = envir))
[13:24:23.687]                     }
[13:24:23.687]                     oopts <- options(mc.cores = workers)
[13:24:23.687]                     on.exit(options(oopts))
[13:24:23.687]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.687]                       envir = envir)
[13:24:23.687]                     if (!future$lazy) 
[13:24:23.687]                       future <- run(future)
[13:24:23.687]                     invisible(future)
[13:24:23.687]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.687]                 }
[13:24:23.687]             }
[13:24:23.687]         }
[13:24:23.687]     })
[13:24:23.687]     if (TRUE) {
[13:24:23.687]         base::sink(type = "output", split = FALSE)
[13:24:23.687]         if (TRUE) {
[13:24:23.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.687]         }
[13:24:23.687]         else {
[13:24:23.687]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.687]         }
[13:24:23.687]         base::close(...future.stdout)
[13:24:23.687]         ...future.stdout <- NULL
[13:24:23.687]     }
[13:24:23.687]     ...future.result$conditions <- ...future.conditions
[13:24:23.687]     ...future.result$finished <- base::Sys.time()
[13:24:23.687]     ...future.result
[13:24:23.687] }
[13:24:23.691] assign_globals() ...
[13:24:23.691] List of 1
[13:24:23.691]  $ kk: int 3
[13:24:23.691]  - attr(*, "where")=List of 1
[13:24:23.691]   ..$ kk:<environment: R_EmptyEnv> 
[13:24:23.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:24:23.691]  - attr(*, "resolved")= logi FALSE
[13:24:23.691]  - attr(*, "total_size")= num 56
[13:24:23.691]  - attr(*, "already-done")= logi TRUE
[13:24:23.699] - copied ‘kk’ to environment
[13:24:23.699] assign_globals() ... done
[13:24:23.700] requestCore(): workers = 2
[13:24:23.701] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.722] plan(): Setting new future strategy stack:
[13:24:23.722] List of future strategies:
[13:24:23.722] 1. multicore:
[13:24:23.722]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.722]    - tweaked: FALSE
[13:24:23.722]    - call: plan(strategy)
[13:24:23.727] plan(): nbrOfWorkers() = 2
[13:24:23.733] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[13:24:23.744] result() for MulticoreFuture ...
[13:24:23.745] result() for MulticoreFuture ...
[13:24:23.745] result() for MulticoreFuture ... done
[13:24:23.745] result() for MulticoreFuture ... done
[13:24:23.746] result() for MulticoreFuture ...
[13:24:23.746] result() for MulticoreFuture ... done
[13:24:23.749] MulticoreFuture started
[13:24:23.749] - Launch lazy future ... done
[13:24:23.750] run() for ‘MulticoreFuture’ ... done
[13:24:23.750] plan(): Setting new future strategy stack:
[13:24:23.751] List of future strategies:
[13:24:23.751] 1. sequential:
[13:24:23.751]    - args: function (..., envir = parent.frame())
[13:24:23.751]    - tweaked: FALSE
[13:24:23.751]    - call: NULL
[13:24:23.752] plan(): nbrOfWorkers() = 1
[13:24:23.768] plan(): Setting new future strategy stack:
[13:24:23.769] List of future strategies:
[13:24:23.769] 1. multicore:
[13:24:23.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.769]    - tweaked: FALSE
[13:24:23.769]    - call: plan(strategy)
[13:24:23.771] Future #1
[13:24:23.771]  length: 2 (resolved future 1)
[13:24:23.773] plan(): nbrOfWorkers() = 2
[13:24:23.774] Future #2
[13:24:23.774]  length: 1 (resolved future 2)
[13:24:23.855] plan(): Setting new future strategy stack:
[13:24:23.855] List of future strategies:
[13:24:23.855] 1. multicore:
[13:24:23.855]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.855]    - tweaked: FALSE
[13:24:23.855]    - call: plan(strategy)
[13:24:23.861] plan(): nbrOfWorkers() = 2
[13:24:23.862] Future #3
[13:24:23.862]  length: 0 (resolved future 3)
[13:24:23.862] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:24:23.864] resolve() on environment ...
[13:24:23.864]  recursive: 0
[13:24:23.865]  elements: [2] ‘a’, ‘b’
[13:24:23.865]  length: 1 (resolved future 1)
[13:24:23.865]  length: 0 (resolved future 2)
[13:24:23.865] resolve() on environment ... DONE
[13:24:23.866] getGlobalsAndPackages() ...
[13:24:23.866] Searching for globals...
[13:24:23.867] 
[13:24:23.867] Searching for globals ... DONE
[13:24:23.867] - globals: [0] <none>
[13:24:23.867] getGlobalsAndPackages() ... DONE
[13:24:23.868] run() for ‘Future’ ...
[13:24:23.868] - state: ‘created’
[13:24:23.868] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.873] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.874] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.874]   - Field: ‘label’
[13:24:23.874]   - Field: ‘local’
[13:24:23.874]   - Field: ‘owner’
[13:24:23.874]   - Field: ‘envir’
[13:24:23.874]   - Field: ‘workers’
[13:24:23.875]   - Field: ‘packages’
[13:24:23.875]   - Field: ‘gc’
[13:24:23.875]   - Field: ‘job’
[13:24:23.875]   - Field: ‘conditions’
[13:24:23.875]   - Field: ‘expr’
[13:24:23.875]   - Field: ‘uuid’
[13:24:23.875]   - Field: ‘seed’
[13:24:23.876]   - Field: ‘version’
[13:24:23.876]   - Field: ‘result’
[13:24:23.876]   - Field: ‘asynchronous’
[13:24:23.876]   - Field: ‘calls’
[13:24:23.876]   - Field: ‘globals’
[13:24:23.876]   - Field: ‘stdout’
[13:24:23.877]   - Field: ‘earlySignal’
[13:24:23.877]   - Field: ‘lazy’
[13:24:23.877]   - Field: ‘state’
[13:24:23.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.877] - Launch lazy future ...
[13:24:23.878] Packages needed by the future expression (n = 0): <none>
[13:24:23.878] Packages needed by future strategies (n = 0): <none>
[13:24:23.879] {
[13:24:23.879]     {
[13:24:23.879]         {
[13:24:23.879]             ...future.startTime <- base::Sys.time()
[13:24:23.879]             {
[13:24:23.879]                 {
[13:24:23.879]                   {
[13:24:23.879]                     {
[13:24:23.879]                       base::local({
[13:24:23.879]                         has_future <- base::requireNamespace("future", 
[13:24:23.879]                           quietly = TRUE)
[13:24:23.879]                         if (has_future) {
[13:24:23.879]                           ns <- base::getNamespace("future")
[13:24:23.879]                           version <- ns[[".package"]][["version"]]
[13:24:23.879]                           if (is.null(version)) 
[13:24:23.879]                             version <- utils::packageVersion("future")
[13:24:23.879]                         }
[13:24:23.879]                         else {
[13:24:23.879]                           version <- NULL
[13:24:23.879]                         }
[13:24:23.879]                         if (!has_future || version < "1.8.0") {
[13:24:23.879]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.879]                             "", base::R.version$version.string), 
[13:24:23.879]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.879]                               "release", "version")], collapse = " "), 
[13:24:23.879]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.879]                             info)
[13:24:23.879]                           info <- base::paste(info, collapse = "; ")
[13:24:23.879]                           if (!has_future) {
[13:24:23.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.879]                               info)
[13:24:23.879]                           }
[13:24:23.879]                           else {
[13:24:23.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.879]                               info, version)
[13:24:23.879]                           }
[13:24:23.879]                           base::stop(msg)
[13:24:23.879]                         }
[13:24:23.879]                       })
[13:24:23.879]                     }
[13:24:23.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.879]                     base::options(mc.cores = 1L)
[13:24:23.879]                   }
[13:24:23.879]                   options(future.plan = NULL)
[13:24:23.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.879]                 }
[13:24:23.879]                 ...future.workdir <- getwd()
[13:24:23.879]             }
[13:24:23.879]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.879]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.879]         }
[13:24:23.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.879]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.879]             base::names(...future.oldOptions))
[13:24:23.879]     }
[13:24:23.879]     if (FALSE) {
[13:24:23.879]     }
[13:24:23.879]     else {
[13:24:23.879]         if (TRUE) {
[13:24:23.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.879]                 open = "w")
[13:24:23.879]         }
[13:24:23.879]         else {
[13:24:23.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.879]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.879]         }
[13:24:23.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.879]             base::sink(type = "output", split = FALSE)
[13:24:23.879]             base::close(...future.stdout)
[13:24:23.879]         }, add = TRUE)
[13:24:23.879]     }
[13:24:23.879]     ...future.frame <- base::sys.nframe()
[13:24:23.879]     ...future.conditions <- base::list()
[13:24:23.879]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.879]     if (FALSE) {
[13:24:23.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.879]     }
[13:24:23.879]     ...future.result <- base::tryCatch({
[13:24:23.879]         base::withCallingHandlers({
[13:24:23.879]             ...future.value <- base::withVisible(base::local({
[13:24:23.879]                 withCallingHandlers({
[13:24:23.879]                   1
[13:24:23.879]                 }, immediateCondition = function(cond) {
[13:24:23.879]                   save_rds <- function (object, pathname, ...) 
[13:24:23.879]                   {
[13:24:23.879]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.879]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.879]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.879]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.879]                         fi_tmp[["mtime"]])
[13:24:23.879]                     }
[13:24:23.879]                     tryCatch({
[13:24:23.879]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.879]                     }, error = function(ex) {
[13:24:23.879]                       msg <- conditionMessage(ex)
[13:24:23.879]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.879]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.879]                         fi_tmp[["mtime"]], msg)
[13:24:23.879]                       ex$message <- msg
[13:24:23.879]                       stop(ex)
[13:24:23.879]                     })
[13:24:23.879]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.879]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.879]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.879]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.879]                       fi <- file.info(pathname)
[13:24:23.879]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.879]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.879]                         fi[["size"]], fi[["mtime"]])
[13:24:23.879]                       stop(msg)
[13:24:23.879]                     }
[13:24:23.879]                     invisible(pathname)
[13:24:23.879]                   }
[13:24:23.879]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.879]                     rootPath = tempdir()) 
[13:24:23.879]                   {
[13:24:23.879]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.879]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.879]                       tmpdir = path, fileext = ".rds")
[13:24:23.879]                     save_rds(obj, file)
[13:24:23.879]                   }
[13:24:23.879]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.879]                   {
[13:24:23.879]                     inherits <- base::inherits
[13:24:23.879]                     invokeRestart <- base::invokeRestart
[13:24:23.879]                     is.null <- base::is.null
[13:24:23.879]                     muffled <- FALSE
[13:24:23.879]                     if (inherits(cond, "message")) {
[13:24:23.879]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.879]                       if (muffled) 
[13:24:23.879]                         invokeRestart("muffleMessage")
[13:24:23.879]                     }
[13:24:23.879]                     else if (inherits(cond, "warning")) {
[13:24:23.879]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.879]                       if (muffled) 
[13:24:23.879]                         invokeRestart("muffleWarning")
[13:24:23.879]                     }
[13:24:23.879]                     else if (inherits(cond, "condition")) {
[13:24:23.879]                       if (!is.null(pattern)) {
[13:24:23.879]                         computeRestarts <- base::computeRestarts
[13:24:23.879]                         grepl <- base::grepl
[13:24:23.879]                         restarts <- computeRestarts(cond)
[13:24:23.879]                         for (restart in restarts) {
[13:24:23.879]                           name <- restart$name
[13:24:23.879]                           if (is.null(name)) 
[13:24:23.879]                             next
[13:24:23.879]                           if (!grepl(pattern, name)) 
[13:24:23.879]                             next
[13:24:23.879]                           invokeRestart(restart)
[13:24:23.879]                           muffled <- TRUE
[13:24:23.879]                           break
[13:24:23.879]                         }
[13:24:23.879]                       }
[13:24:23.879]                     }
[13:24:23.879]                     invisible(muffled)
[13:24:23.879]                   }
[13:24:23.879]                   muffleCondition(cond)
[13:24:23.879]                 })
[13:24:23.879]             }))
[13:24:23.879]             future::FutureResult(value = ...future.value$value, 
[13:24:23.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.879]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.879]                     ...future.globalenv.names))
[13:24:23.879]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.879]         }, condition = base::local({
[13:24:23.879]             c <- base::c
[13:24:23.879]             inherits <- base::inherits
[13:24:23.879]             invokeRestart <- base::invokeRestart
[13:24:23.879]             length <- base::length
[13:24:23.879]             list <- base::list
[13:24:23.879]             seq.int <- base::seq.int
[13:24:23.879]             signalCondition <- base::signalCondition
[13:24:23.879]             sys.calls <- base::sys.calls
[13:24:23.879]             `[[` <- base::`[[`
[13:24:23.879]             `+` <- base::`+`
[13:24:23.879]             `<<-` <- base::`<<-`
[13:24:23.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.879]                   3L)]
[13:24:23.879]             }
[13:24:23.879]             function(cond) {
[13:24:23.879]                 is_error <- inherits(cond, "error")
[13:24:23.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.879]                   NULL)
[13:24:23.879]                 if (is_error) {
[13:24:23.879]                   sessionInformation <- function() {
[13:24:23.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.879]                       search = base::search(), system = base::Sys.info())
[13:24:23.879]                   }
[13:24:23.879]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.879]                     cond$call), session = sessionInformation(), 
[13:24:23.879]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.879]                   signalCondition(cond)
[13:24:23.879]                 }
[13:24:23.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.879]                 "immediateCondition"))) {
[13:24:23.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.879]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.879]                   if (TRUE && !signal) {
[13:24:23.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.879]                     {
[13:24:23.879]                       inherits <- base::inherits
[13:24:23.879]                       invokeRestart <- base::invokeRestart
[13:24:23.879]                       is.null <- base::is.null
[13:24:23.879]                       muffled <- FALSE
[13:24:23.879]                       if (inherits(cond, "message")) {
[13:24:23.879]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.879]                         if (muffled) 
[13:24:23.879]                           invokeRestart("muffleMessage")
[13:24:23.879]                       }
[13:24:23.879]                       else if (inherits(cond, "warning")) {
[13:24:23.879]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.879]                         if (muffled) 
[13:24:23.879]                           invokeRestart("muffleWarning")
[13:24:23.879]                       }
[13:24:23.879]                       else if (inherits(cond, "condition")) {
[13:24:23.879]                         if (!is.null(pattern)) {
[13:24:23.879]                           computeRestarts <- base::computeRestarts
[13:24:23.879]                           grepl <- base::grepl
[13:24:23.879]                           restarts <- computeRestarts(cond)
[13:24:23.879]                           for (restart in restarts) {
[13:24:23.879]                             name <- restart$name
[13:24:23.879]                             if (is.null(name)) 
[13:24:23.879]                               next
[13:24:23.879]                             if (!grepl(pattern, name)) 
[13:24:23.879]                               next
[13:24:23.879]                             invokeRestart(restart)
[13:24:23.879]                             muffled <- TRUE
[13:24:23.879]                             break
[13:24:23.879]                           }
[13:24:23.879]                         }
[13:24:23.879]                       }
[13:24:23.879]                       invisible(muffled)
[13:24:23.879]                     }
[13:24:23.879]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.879]                   }
[13:24:23.879]                 }
[13:24:23.879]                 else {
[13:24:23.879]                   if (TRUE) {
[13:24:23.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.879]                     {
[13:24:23.879]                       inherits <- base::inherits
[13:24:23.879]                       invokeRestart <- base::invokeRestart
[13:24:23.879]                       is.null <- base::is.null
[13:24:23.879]                       muffled <- FALSE
[13:24:23.879]                       if (inherits(cond, "message")) {
[13:24:23.879]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.879]                         if (muffled) 
[13:24:23.879]                           invokeRestart("muffleMessage")
[13:24:23.879]                       }
[13:24:23.879]                       else if (inherits(cond, "warning")) {
[13:24:23.879]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.879]                         if (muffled) 
[13:24:23.879]                           invokeRestart("muffleWarning")
[13:24:23.879]                       }
[13:24:23.879]                       else if (inherits(cond, "condition")) {
[13:24:23.879]                         if (!is.null(pattern)) {
[13:24:23.879]                           computeRestarts <- base::computeRestarts
[13:24:23.879]                           grepl <- base::grepl
[13:24:23.879]                           restarts <- computeRestarts(cond)
[13:24:23.879]                           for (restart in restarts) {
[13:24:23.879]                             name <- restart$name
[13:24:23.879]                             if (is.null(name)) 
[13:24:23.879]                               next
[13:24:23.879]                             if (!grepl(pattern, name)) 
[13:24:23.879]                               next
[13:24:23.879]                             invokeRestart(restart)
[13:24:23.879]                             muffled <- TRUE
[13:24:23.879]                             break
[13:24:23.879]                           }
[13:24:23.879]                         }
[13:24:23.879]                       }
[13:24:23.879]                       invisible(muffled)
[13:24:23.879]                     }
[13:24:23.879]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.879]                   }
[13:24:23.879]                 }
[13:24:23.879]             }
[13:24:23.879]         }))
[13:24:23.879]     }, error = function(ex) {
[13:24:23.879]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.879]                 ...future.rng), started = ...future.startTime, 
[13:24:23.879]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.879]             version = "1.8"), class = "FutureResult")
[13:24:23.879]     }, finally = {
[13:24:23.879]         if (!identical(...future.workdir, getwd())) 
[13:24:23.879]             setwd(...future.workdir)
[13:24:23.879]         {
[13:24:23.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.879]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.879]             }
[13:24:23.879]             base::options(...future.oldOptions)
[13:24:23.879]             if (.Platform$OS.type == "windows") {
[13:24:23.879]                 old_names <- names(...future.oldEnvVars)
[13:24:23.879]                 envs <- base::Sys.getenv()
[13:24:23.879]                 names <- names(envs)
[13:24:23.879]                 common <- intersect(names, old_names)
[13:24:23.879]                 added <- setdiff(names, old_names)
[13:24:23.879]                 removed <- setdiff(old_names, names)
[13:24:23.879]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.879]                   envs[common]]
[13:24:23.879]                 NAMES <- toupper(changed)
[13:24:23.879]                 args <- list()
[13:24:23.879]                 for (kk in seq_along(NAMES)) {
[13:24:23.879]                   name <- changed[[kk]]
[13:24:23.879]                   NAME <- NAMES[[kk]]
[13:24:23.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.879]                     next
[13:24:23.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.879]                 }
[13:24:23.879]                 NAMES <- toupper(added)
[13:24:23.879]                 for (kk in seq_along(NAMES)) {
[13:24:23.879]                   name <- added[[kk]]
[13:24:23.879]                   NAME <- NAMES[[kk]]
[13:24:23.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.879]                     next
[13:24:23.879]                   args[[name]] <- ""
[13:24:23.879]                 }
[13:24:23.879]                 NAMES <- toupper(removed)
[13:24:23.879]                 for (kk in seq_along(NAMES)) {
[13:24:23.879]                   name <- removed[[kk]]
[13:24:23.879]                   NAME <- NAMES[[kk]]
[13:24:23.879]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.879]                     next
[13:24:23.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.879]                 }
[13:24:23.879]                 if (length(args) > 0) 
[13:24:23.879]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.879]             }
[13:24:23.879]             else {
[13:24:23.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.879]             }
[13:24:23.879]             {
[13:24:23.879]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.879]                   0L) {
[13:24:23.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.879]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.879]                   base::options(opts)
[13:24:23.879]                 }
[13:24:23.879]                 {
[13:24:23.879]                   {
[13:24:23.879]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.879]                     NULL
[13:24:23.879]                   }
[13:24:23.879]                   options(future.plan = NULL)
[13:24:23.879]                   if (is.na(NA_character_)) 
[13:24:23.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.879]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.879]                     envir = parent.frame()) 
[13:24:23.879]                   {
[13:24:23.879]                     default_workers <- missing(workers)
[13:24:23.879]                     if (is.function(workers)) 
[13:24:23.879]                       workers <- workers()
[13:24:23.879]                     workers <- structure(as.integer(workers), 
[13:24:23.879]                       class = class(workers))
[13:24:23.879]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.879]                       1L)
[13:24:23.879]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.879]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.879]                       if (default_workers) 
[13:24:23.879]                         supportsMulticore(warn = TRUE)
[13:24:23.879]                       return(sequential(..., envir = envir))
[13:24:23.879]                     }
[13:24:23.879]                     oopts <- options(mc.cores = workers)
[13:24:23.879]                     on.exit(options(oopts))
[13:24:23.879]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.879]                       envir = envir)
[13:24:23.879]                     if (!future$lazy) 
[13:24:23.879]                       future <- run(future)
[13:24:23.879]                     invisible(future)
[13:24:23.879]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.879]                 }
[13:24:23.879]             }
[13:24:23.879]         }
[13:24:23.879]     })
[13:24:23.879]     if (TRUE) {
[13:24:23.879]         base::sink(type = "output", split = FALSE)
[13:24:23.879]         if (TRUE) {
[13:24:23.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.879]         }
[13:24:23.879]         else {
[13:24:23.879]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.879]         }
[13:24:23.879]         base::close(...future.stdout)
[13:24:23.879]         ...future.stdout <- NULL
[13:24:23.879]     }
[13:24:23.879]     ...future.result$conditions <- ...future.conditions
[13:24:23.879]     ...future.result$finished <- base::Sys.time()
[13:24:23.879]     ...future.result
[13:24:23.879] }
[13:24:23.882] requestCore(): workers = 2
[13:24:23.883] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.893] result() for MulticoreFuture ...
[13:24:23.894] result() for MulticoreFuture ...
[13:24:23.895] result() for MulticoreFuture ... done
[13:24:23.895] result() for MulticoreFuture ... done
[13:24:23.895] result() for MulticoreFuture ...
[13:24:23.895] result() for MulticoreFuture ... done
[13:24:23.898] MulticoreFuture started
[13:24:23.899] - Launch lazy future ... done
[13:24:23.899] run() for ‘MulticoreFuture’ ... done
[13:24:23.899] getGlobalsAndPackages() ...
[13:24:23.899] plan(): Setting new future strategy stack:
[13:24:23.900] Searching for globals...
[13:24:23.900] List of future strategies:
[13:24:23.900] 1. sequential:
[13:24:23.900]    - args: function (..., envir = parent.frame())
[13:24:23.900]    - tweaked: FALSE
[13:24:23.900]    - call: NULL
[13:24:23.900] 
[13:24:23.901] Searching for globals ... DONE
[13:24:23.901] plan(): nbrOfWorkers() = 1
[13:24:23.901] - globals: [0] <none>
[13:24:23.901] getGlobalsAndPackages() ... DONE
[13:24:23.901] run() for ‘Future’ ...
[13:24:23.902] - state: ‘created’
[13:24:23.902] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.903] plan(): Setting new future strategy stack:
[13:24:23.903] List of future strategies:
[13:24:23.903] 1. multicore:
[13:24:23.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.903]    - tweaked: FALSE
[13:24:23.903]    - call: plan(strategy)
[13:24:23.907] plan(): nbrOfWorkers() = 2
[13:24:23.908] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.908] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.908]   - Field: ‘label’
[13:24:23.909]   - Field: ‘local’
[13:24:23.909]   - Field: ‘owner’
[13:24:23.909]   - Field: ‘envir’
[13:24:23.909]   - Field: ‘workers’
[13:24:23.909]   - Field: ‘packages’
[13:24:23.909]   - Field: ‘gc’
[13:24:23.909]   - Field: ‘job’
[13:24:23.910]   - Field: ‘conditions’
[13:24:23.910]   - Field: ‘expr’
[13:24:23.910]   - Field: ‘uuid’
[13:24:23.910]   - Field: ‘seed’
[13:24:23.910]   - Field: ‘version’
[13:24:23.910]   - Field: ‘result’
[13:24:23.910]   - Field: ‘asynchronous’
[13:24:23.911]   - Field: ‘calls’
[13:24:23.911]   - Field: ‘globals’
[13:24:23.911]   - Field: ‘stdout’
[13:24:23.911]   - Field: ‘earlySignal’
[13:24:23.911]   - Field: ‘lazy’
[13:24:23.911]   - Field: ‘state’
[13:24:23.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.912] - Launch lazy future ...
[13:24:23.912] Packages needed by the future expression (n = 0): <none>
[13:24:23.912] Packages needed by future strategies (n = 0): <none>
[13:24:23.913] {
[13:24:23.913]     {
[13:24:23.913]         {
[13:24:23.913]             ...future.startTime <- base::Sys.time()
[13:24:23.913]             {
[13:24:23.913]                 {
[13:24:23.913]                   {
[13:24:23.913]                     {
[13:24:23.913]                       base::local({
[13:24:23.913]                         has_future <- base::requireNamespace("future", 
[13:24:23.913]                           quietly = TRUE)
[13:24:23.913]                         if (has_future) {
[13:24:23.913]                           ns <- base::getNamespace("future")
[13:24:23.913]                           version <- ns[[".package"]][["version"]]
[13:24:23.913]                           if (is.null(version)) 
[13:24:23.913]                             version <- utils::packageVersion("future")
[13:24:23.913]                         }
[13:24:23.913]                         else {
[13:24:23.913]                           version <- NULL
[13:24:23.913]                         }
[13:24:23.913]                         if (!has_future || version < "1.8.0") {
[13:24:23.913]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.913]                             "", base::R.version$version.string), 
[13:24:23.913]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.913]                               "release", "version")], collapse = " "), 
[13:24:23.913]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.913]                             info)
[13:24:23.913]                           info <- base::paste(info, collapse = "; ")
[13:24:23.913]                           if (!has_future) {
[13:24:23.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.913]                               info)
[13:24:23.913]                           }
[13:24:23.913]                           else {
[13:24:23.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.913]                               info, version)
[13:24:23.913]                           }
[13:24:23.913]                           base::stop(msg)
[13:24:23.913]                         }
[13:24:23.913]                       })
[13:24:23.913]                     }
[13:24:23.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.913]                     base::options(mc.cores = 1L)
[13:24:23.913]                   }
[13:24:23.913]                   options(future.plan = NULL)
[13:24:23.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.913]                 }
[13:24:23.913]                 ...future.workdir <- getwd()
[13:24:23.913]             }
[13:24:23.913]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.913]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.913]         }
[13:24:23.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.913]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.913]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.913]             base::names(...future.oldOptions))
[13:24:23.913]     }
[13:24:23.913]     if (FALSE) {
[13:24:23.913]     }
[13:24:23.913]     else {
[13:24:23.913]         if (TRUE) {
[13:24:23.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.913]                 open = "w")
[13:24:23.913]         }
[13:24:23.913]         else {
[13:24:23.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.913]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.913]         }
[13:24:23.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.913]             base::sink(type = "output", split = FALSE)
[13:24:23.913]             base::close(...future.stdout)
[13:24:23.913]         }, add = TRUE)
[13:24:23.913]     }
[13:24:23.913]     ...future.frame <- base::sys.nframe()
[13:24:23.913]     ...future.conditions <- base::list()
[13:24:23.913]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.913]     if (FALSE) {
[13:24:23.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.913]     }
[13:24:23.913]     ...future.result <- base::tryCatch({
[13:24:23.913]         base::withCallingHandlers({
[13:24:23.913]             ...future.value <- base::withVisible(base::local({
[13:24:23.913]                 withCallingHandlers({
[13:24:23.913]                   2
[13:24:23.913]                 }, immediateCondition = function(cond) {
[13:24:23.913]                   save_rds <- function (object, pathname, ...) 
[13:24:23.913]                   {
[13:24:23.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.913]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.913]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.913]                         fi_tmp[["mtime"]])
[13:24:23.913]                     }
[13:24:23.913]                     tryCatch({
[13:24:23.913]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.913]                     }, error = function(ex) {
[13:24:23.913]                       msg <- conditionMessage(ex)
[13:24:23.913]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.913]                         fi_tmp[["mtime"]], msg)
[13:24:23.913]                       ex$message <- msg
[13:24:23.913]                       stop(ex)
[13:24:23.913]                     })
[13:24:23.913]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.913]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.913]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.913]                       fi <- file.info(pathname)
[13:24:23.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.913]                         fi[["size"]], fi[["mtime"]])
[13:24:23.913]                       stop(msg)
[13:24:23.913]                     }
[13:24:23.913]                     invisible(pathname)
[13:24:23.913]                   }
[13:24:23.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.913]                     rootPath = tempdir()) 
[13:24:23.913]                   {
[13:24:23.913]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.913]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.913]                       tmpdir = path, fileext = ".rds")
[13:24:23.913]                     save_rds(obj, file)
[13:24:23.913]                   }
[13:24:23.913]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.913]                   {
[13:24:23.913]                     inherits <- base::inherits
[13:24:23.913]                     invokeRestart <- base::invokeRestart
[13:24:23.913]                     is.null <- base::is.null
[13:24:23.913]                     muffled <- FALSE
[13:24:23.913]                     if (inherits(cond, "message")) {
[13:24:23.913]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.913]                       if (muffled) 
[13:24:23.913]                         invokeRestart("muffleMessage")
[13:24:23.913]                     }
[13:24:23.913]                     else if (inherits(cond, "warning")) {
[13:24:23.913]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.913]                       if (muffled) 
[13:24:23.913]                         invokeRestart("muffleWarning")
[13:24:23.913]                     }
[13:24:23.913]                     else if (inherits(cond, "condition")) {
[13:24:23.913]                       if (!is.null(pattern)) {
[13:24:23.913]                         computeRestarts <- base::computeRestarts
[13:24:23.913]                         grepl <- base::grepl
[13:24:23.913]                         restarts <- computeRestarts(cond)
[13:24:23.913]                         for (restart in restarts) {
[13:24:23.913]                           name <- restart$name
[13:24:23.913]                           if (is.null(name)) 
[13:24:23.913]                             next
[13:24:23.913]                           if (!grepl(pattern, name)) 
[13:24:23.913]                             next
[13:24:23.913]                           invokeRestart(restart)
[13:24:23.913]                           muffled <- TRUE
[13:24:23.913]                           break
[13:24:23.913]                         }
[13:24:23.913]                       }
[13:24:23.913]                     }
[13:24:23.913]                     invisible(muffled)
[13:24:23.913]                   }
[13:24:23.913]                   muffleCondition(cond)
[13:24:23.913]                 })
[13:24:23.913]             }))
[13:24:23.913]             future::FutureResult(value = ...future.value$value, 
[13:24:23.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.913]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.913]                     ...future.globalenv.names))
[13:24:23.913]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.913]         }, condition = base::local({
[13:24:23.913]             c <- base::c
[13:24:23.913]             inherits <- base::inherits
[13:24:23.913]             invokeRestart <- base::invokeRestart
[13:24:23.913]             length <- base::length
[13:24:23.913]             list <- base::list
[13:24:23.913]             seq.int <- base::seq.int
[13:24:23.913]             signalCondition <- base::signalCondition
[13:24:23.913]             sys.calls <- base::sys.calls
[13:24:23.913]             `[[` <- base::`[[`
[13:24:23.913]             `+` <- base::`+`
[13:24:23.913]             `<<-` <- base::`<<-`
[13:24:23.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.913]                   3L)]
[13:24:23.913]             }
[13:24:23.913]             function(cond) {
[13:24:23.913]                 is_error <- inherits(cond, "error")
[13:24:23.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.913]                   NULL)
[13:24:23.913]                 if (is_error) {
[13:24:23.913]                   sessionInformation <- function() {
[13:24:23.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.913]                       search = base::search(), system = base::Sys.info())
[13:24:23.913]                   }
[13:24:23.913]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.913]                     cond$call), session = sessionInformation(), 
[13:24:23.913]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.913]                   signalCondition(cond)
[13:24:23.913]                 }
[13:24:23.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.913]                 "immediateCondition"))) {
[13:24:23.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.913]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.913]                   if (TRUE && !signal) {
[13:24:23.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.913]                     {
[13:24:23.913]                       inherits <- base::inherits
[13:24:23.913]                       invokeRestart <- base::invokeRestart
[13:24:23.913]                       is.null <- base::is.null
[13:24:23.913]                       muffled <- FALSE
[13:24:23.913]                       if (inherits(cond, "message")) {
[13:24:23.913]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.913]                         if (muffled) 
[13:24:23.913]                           invokeRestart("muffleMessage")
[13:24:23.913]                       }
[13:24:23.913]                       else if (inherits(cond, "warning")) {
[13:24:23.913]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.913]                         if (muffled) 
[13:24:23.913]                           invokeRestart("muffleWarning")
[13:24:23.913]                       }
[13:24:23.913]                       else if (inherits(cond, "condition")) {
[13:24:23.913]                         if (!is.null(pattern)) {
[13:24:23.913]                           computeRestarts <- base::computeRestarts
[13:24:23.913]                           grepl <- base::grepl
[13:24:23.913]                           restarts <- computeRestarts(cond)
[13:24:23.913]                           for (restart in restarts) {
[13:24:23.913]                             name <- restart$name
[13:24:23.913]                             if (is.null(name)) 
[13:24:23.913]                               next
[13:24:23.913]                             if (!grepl(pattern, name)) 
[13:24:23.913]                               next
[13:24:23.913]                             invokeRestart(restart)
[13:24:23.913]                             muffled <- TRUE
[13:24:23.913]                             break
[13:24:23.913]                           }
[13:24:23.913]                         }
[13:24:23.913]                       }
[13:24:23.913]                       invisible(muffled)
[13:24:23.913]                     }
[13:24:23.913]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.913]                   }
[13:24:23.913]                 }
[13:24:23.913]                 else {
[13:24:23.913]                   if (TRUE) {
[13:24:23.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.913]                     {
[13:24:23.913]                       inherits <- base::inherits
[13:24:23.913]                       invokeRestart <- base::invokeRestart
[13:24:23.913]                       is.null <- base::is.null
[13:24:23.913]                       muffled <- FALSE
[13:24:23.913]                       if (inherits(cond, "message")) {
[13:24:23.913]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.913]                         if (muffled) 
[13:24:23.913]                           invokeRestart("muffleMessage")
[13:24:23.913]                       }
[13:24:23.913]                       else if (inherits(cond, "warning")) {
[13:24:23.913]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.913]                         if (muffled) 
[13:24:23.913]                           invokeRestart("muffleWarning")
[13:24:23.913]                       }
[13:24:23.913]                       else if (inherits(cond, "condition")) {
[13:24:23.913]                         if (!is.null(pattern)) {
[13:24:23.913]                           computeRestarts <- base::computeRestarts
[13:24:23.913]                           grepl <- base::grepl
[13:24:23.913]                           restarts <- computeRestarts(cond)
[13:24:23.913]                           for (restart in restarts) {
[13:24:23.913]                             name <- restart$name
[13:24:23.913]                             if (is.null(name)) 
[13:24:23.913]                               next
[13:24:23.913]                             if (!grepl(pattern, name)) 
[13:24:23.913]                               next
[13:24:23.913]                             invokeRestart(restart)
[13:24:23.913]                             muffled <- TRUE
[13:24:23.913]                             break
[13:24:23.913]                           }
[13:24:23.913]                         }
[13:24:23.913]                       }
[13:24:23.913]                       invisible(muffled)
[13:24:23.913]                     }
[13:24:23.913]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.913]                   }
[13:24:23.913]                 }
[13:24:23.913]             }
[13:24:23.913]         }))
[13:24:23.913]     }, error = function(ex) {
[13:24:23.913]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.913]                 ...future.rng), started = ...future.startTime, 
[13:24:23.913]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.913]             version = "1.8"), class = "FutureResult")
[13:24:23.913]     }, finally = {
[13:24:23.913]         if (!identical(...future.workdir, getwd())) 
[13:24:23.913]             setwd(...future.workdir)
[13:24:23.913]         {
[13:24:23.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.913]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.913]             }
[13:24:23.913]             base::options(...future.oldOptions)
[13:24:23.913]             if (.Platform$OS.type == "windows") {
[13:24:23.913]                 old_names <- names(...future.oldEnvVars)
[13:24:23.913]                 envs <- base::Sys.getenv()
[13:24:23.913]                 names <- names(envs)
[13:24:23.913]                 common <- intersect(names, old_names)
[13:24:23.913]                 added <- setdiff(names, old_names)
[13:24:23.913]                 removed <- setdiff(old_names, names)
[13:24:23.913]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.913]                   envs[common]]
[13:24:23.913]                 NAMES <- toupper(changed)
[13:24:23.913]                 args <- list()
[13:24:23.913]                 for (kk in seq_along(NAMES)) {
[13:24:23.913]                   name <- changed[[kk]]
[13:24:23.913]                   NAME <- NAMES[[kk]]
[13:24:23.913]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.913]                     next
[13:24:23.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.913]                 }
[13:24:23.913]                 NAMES <- toupper(added)
[13:24:23.913]                 for (kk in seq_along(NAMES)) {
[13:24:23.913]                   name <- added[[kk]]
[13:24:23.913]                   NAME <- NAMES[[kk]]
[13:24:23.913]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.913]                     next
[13:24:23.913]                   args[[name]] <- ""
[13:24:23.913]                 }
[13:24:23.913]                 NAMES <- toupper(removed)
[13:24:23.913]                 for (kk in seq_along(NAMES)) {
[13:24:23.913]                   name <- removed[[kk]]
[13:24:23.913]                   NAME <- NAMES[[kk]]
[13:24:23.913]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.913]                     next
[13:24:23.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.913]                 }
[13:24:23.913]                 if (length(args) > 0) 
[13:24:23.913]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.913]             }
[13:24:23.913]             else {
[13:24:23.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.913]             }
[13:24:23.913]             {
[13:24:23.913]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.913]                   0L) {
[13:24:23.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.913]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.913]                   base::options(opts)
[13:24:23.913]                 }
[13:24:23.913]                 {
[13:24:23.913]                   {
[13:24:23.913]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.913]                     NULL
[13:24:23.913]                   }
[13:24:23.913]                   options(future.plan = NULL)
[13:24:23.913]                   if (is.na(NA_character_)) 
[13:24:23.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.913]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.913]                     envir = parent.frame()) 
[13:24:23.913]                   {
[13:24:23.913]                     default_workers <- missing(workers)
[13:24:23.913]                     if (is.function(workers)) 
[13:24:23.913]                       workers <- workers()
[13:24:23.913]                     workers <- structure(as.integer(workers), 
[13:24:23.913]                       class = class(workers))
[13:24:23.913]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.913]                       1L)
[13:24:23.913]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.913]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.913]                       if (default_workers) 
[13:24:23.913]                         supportsMulticore(warn = TRUE)
[13:24:23.913]                       return(sequential(..., envir = envir))
[13:24:23.913]                     }
[13:24:23.913]                     oopts <- options(mc.cores = workers)
[13:24:23.913]                     on.exit(options(oopts))
[13:24:23.913]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.913]                       envir = envir)
[13:24:23.913]                     if (!future$lazy) 
[13:24:23.913]                       future <- run(future)
[13:24:23.913]                     invisible(future)
[13:24:23.913]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.913]                 }
[13:24:23.913]             }
[13:24:23.913]         }
[13:24:23.913]     })
[13:24:23.913]     if (TRUE) {
[13:24:23.913]         base::sink(type = "output", split = FALSE)
[13:24:23.913]         if (TRUE) {
[13:24:23.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.913]         }
[13:24:23.913]         else {
[13:24:23.913]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.913]         }
[13:24:23.913]         base::close(...future.stdout)
[13:24:23.913]         ...future.stdout <- NULL
[13:24:23.913]     }
[13:24:23.913]     ...future.result$conditions <- ...future.conditions
[13:24:23.913]     ...future.result$finished <- base::Sys.time()
[13:24:23.913]     ...future.result
[13:24:23.913] }
[13:24:23.917] requestCore(): workers = 2
[13:24:23.918] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.928] result() for MulticoreFuture ...
[13:24:23.929] result() for MulticoreFuture ...
[13:24:23.930] result() for MulticoreFuture ... done
[13:24:23.930] result() for MulticoreFuture ... done
[13:24:23.930] result() for MulticoreFuture ...
[13:24:23.930] result() for MulticoreFuture ... done
[13:24:23.933] MulticoreFuture started
[13:24:23.934] - Launch lazy future ... done
[13:24:23.934] run() for ‘MulticoreFuture’ ... done
[13:24:23.934] plan(): Setting new future strategy stack:
[13:24:23.934] List of future strategies:
[13:24:23.934] 1. sequential:
[13:24:23.934]    - args: function (..., envir = parent.frame())
[13:24:23.934]    - tweaked: FALSE
[13:24:23.934]    - call: NULL
[13:24:23.935] resolve() on environment ...
[13:24:23.935] plan(): nbrOfWorkers() = 1
[13:24:23.935]  recursive: 0
[13:24:23.936]  elements: [3] ‘a’, ‘b’, ‘c’
[13:24:23.937] Future #1
[13:24:23.937]  length: 2 (resolved future 1)
[13:24:23.938] plan(): Setting new future strategy stack:
[13:24:23.938] List of future strategies:
[13:24:23.938] 1. multicore:
[13:24:23.938]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:23.938]    - tweaked: FALSE
[13:24:23.938]    - call: plan(strategy)
[13:24:23.948]  length: 1 (resolved future 3)
[13:24:23.949] plan(): nbrOfWorkers() = 2
[13:24:23.958] Future #2
[13:24:23.962]  length: 0 (resolved future 2)
[13:24:23.963] resolve() on environment ... DONE
[13:24:23.965] getGlobalsAndPackages() ...
[13:24:23.966] Searching for globals...
[13:24:23.967] - globals found: [1] ‘{’
[13:24:23.968] Searching for globals ... DONE
[13:24:23.968] Resolving globals: FALSE
[13:24:23.968] 
[13:24:23.969] 
[13:24:23.969] getGlobalsAndPackages() ... DONE
[13:24:23.969] run() for ‘Future’ ...
[13:24:23.969] - state: ‘created’
[13:24:23.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:23.975] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:23.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:23.975]   - Field: ‘label’
[13:24:23.976]   - Field: ‘local’
[13:24:23.976]   - Field: ‘owner’
[13:24:23.976]   - Field: ‘envir’
[13:24:23.976]   - Field: ‘workers’
[13:24:23.976]   - Field: ‘packages’
[13:24:23.976]   - Field: ‘gc’
[13:24:23.977]   - Field: ‘job’
[13:24:23.977]   - Field: ‘conditions’
[13:24:23.977]   - Field: ‘expr’
[13:24:23.977]   - Field: ‘uuid’
[13:24:23.977]   - Field: ‘seed’
[13:24:23.977]   - Field: ‘version’
[13:24:23.977]   - Field: ‘result’
[13:24:23.978]   - Field: ‘asynchronous’
[13:24:23.978]   - Field: ‘calls’
[13:24:23.978]   - Field: ‘globals’
[13:24:23.978]   - Field: ‘stdout’
[13:24:23.978]   - Field: ‘earlySignal’
[13:24:23.978]   - Field: ‘lazy’
[13:24:23.978]   - Field: ‘state’
[13:24:23.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:23.979] - Launch lazy future ...
[13:24:23.979] Packages needed by the future expression (n = 0): <none>
[13:24:23.979] Packages needed by future strategies (n = 0): <none>
[13:24:23.980] {
[13:24:23.980]     {
[13:24:23.980]         {
[13:24:23.980]             ...future.startTime <- base::Sys.time()
[13:24:23.980]             {
[13:24:23.980]                 {
[13:24:23.980]                   {
[13:24:23.980]                     {
[13:24:23.980]                       base::local({
[13:24:23.980]                         has_future <- base::requireNamespace("future", 
[13:24:23.980]                           quietly = TRUE)
[13:24:23.980]                         if (has_future) {
[13:24:23.980]                           ns <- base::getNamespace("future")
[13:24:23.980]                           version <- ns[[".package"]][["version"]]
[13:24:23.980]                           if (is.null(version)) 
[13:24:23.980]                             version <- utils::packageVersion("future")
[13:24:23.980]                         }
[13:24:23.980]                         else {
[13:24:23.980]                           version <- NULL
[13:24:23.980]                         }
[13:24:23.980]                         if (!has_future || version < "1.8.0") {
[13:24:23.980]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:23.980]                             "", base::R.version$version.string), 
[13:24:23.980]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:23.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:23.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:23.980]                               "release", "version")], collapse = " "), 
[13:24:23.980]                             hostname = base::Sys.info()[["nodename"]])
[13:24:23.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:23.980]                             info)
[13:24:23.980]                           info <- base::paste(info, collapse = "; ")
[13:24:23.980]                           if (!has_future) {
[13:24:23.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:23.980]                               info)
[13:24:23.980]                           }
[13:24:23.980]                           else {
[13:24:23.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:23.980]                               info, version)
[13:24:23.980]                           }
[13:24:23.980]                           base::stop(msg)
[13:24:23.980]                         }
[13:24:23.980]                       })
[13:24:23.980]                     }
[13:24:23.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:23.980]                     base::options(mc.cores = 1L)
[13:24:23.980]                   }
[13:24:23.980]                   options(future.plan = NULL)
[13:24:23.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:23.980]                 }
[13:24:23.980]                 ...future.workdir <- getwd()
[13:24:23.980]             }
[13:24:23.980]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:23.980]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:23.980]         }
[13:24:23.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:23.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:23.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:23.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:23.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:23.980]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:23.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:23.980]             base::names(...future.oldOptions))
[13:24:23.980]     }
[13:24:23.980]     if (FALSE) {
[13:24:23.980]     }
[13:24:23.980]     else {
[13:24:23.980]         if (TRUE) {
[13:24:23.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:23.980]                 open = "w")
[13:24:23.980]         }
[13:24:23.980]         else {
[13:24:23.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:23.980]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:23.980]         }
[13:24:23.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:23.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:23.980]             base::sink(type = "output", split = FALSE)
[13:24:23.980]             base::close(...future.stdout)
[13:24:23.980]         }, add = TRUE)
[13:24:23.980]     }
[13:24:23.980]     ...future.frame <- base::sys.nframe()
[13:24:23.980]     ...future.conditions <- base::list()
[13:24:23.980]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:23.980]     if (FALSE) {
[13:24:23.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:23.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:23.980]     }
[13:24:23.980]     ...future.result <- base::tryCatch({
[13:24:23.980]         base::withCallingHandlers({
[13:24:23.980]             ...future.value <- base::withVisible(base::local({
[13:24:23.980]                 withCallingHandlers({
[13:24:23.980]                   {
[13:24:23.980]                     1
[13:24:23.980]                   }
[13:24:23.980]                 }, immediateCondition = function(cond) {
[13:24:23.980]                   save_rds <- function (object, pathname, ...) 
[13:24:23.980]                   {
[13:24:23.980]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:23.980]                     if (file_test("-f", pathname_tmp)) {
[13:24:23.980]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.980]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:23.980]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.980]                         fi_tmp[["mtime"]])
[13:24:23.980]                     }
[13:24:23.980]                     tryCatch({
[13:24:23.980]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:23.980]                     }, error = function(ex) {
[13:24:23.980]                       msg <- conditionMessage(ex)
[13:24:23.980]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.980]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:23.980]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.980]                         fi_tmp[["mtime"]], msg)
[13:24:23.980]                       ex$message <- msg
[13:24:23.980]                       stop(ex)
[13:24:23.980]                     })
[13:24:23.980]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:23.980]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:23.980]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:23.980]                       fi_tmp <- file.info(pathname_tmp)
[13:24:23.980]                       fi <- file.info(pathname)
[13:24:23.980]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:23.980]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:23.980]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:23.980]                         fi[["size"]], fi[["mtime"]])
[13:24:23.980]                       stop(msg)
[13:24:23.980]                     }
[13:24:23.980]                     invisible(pathname)
[13:24:23.980]                   }
[13:24:23.980]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:23.980]                     rootPath = tempdir()) 
[13:24:23.980]                   {
[13:24:23.980]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:23.980]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:23.980]                       tmpdir = path, fileext = ".rds")
[13:24:23.980]                     save_rds(obj, file)
[13:24:23.980]                   }
[13:24:23.980]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:23.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.980]                   {
[13:24:23.980]                     inherits <- base::inherits
[13:24:23.980]                     invokeRestart <- base::invokeRestart
[13:24:23.980]                     is.null <- base::is.null
[13:24:23.980]                     muffled <- FALSE
[13:24:23.980]                     if (inherits(cond, "message")) {
[13:24:23.980]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:23.980]                       if (muffled) 
[13:24:23.980]                         invokeRestart("muffleMessage")
[13:24:23.980]                     }
[13:24:23.980]                     else if (inherits(cond, "warning")) {
[13:24:23.980]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:23.980]                       if (muffled) 
[13:24:23.980]                         invokeRestart("muffleWarning")
[13:24:23.980]                     }
[13:24:23.980]                     else if (inherits(cond, "condition")) {
[13:24:23.980]                       if (!is.null(pattern)) {
[13:24:23.980]                         computeRestarts <- base::computeRestarts
[13:24:23.980]                         grepl <- base::grepl
[13:24:23.980]                         restarts <- computeRestarts(cond)
[13:24:23.980]                         for (restart in restarts) {
[13:24:23.980]                           name <- restart$name
[13:24:23.980]                           if (is.null(name)) 
[13:24:23.980]                             next
[13:24:23.980]                           if (!grepl(pattern, name)) 
[13:24:23.980]                             next
[13:24:23.980]                           invokeRestart(restart)
[13:24:23.980]                           muffled <- TRUE
[13:24:23.980]                           break
[13:24:23.980]                         }
[13:24:23.980]                       }
[13:24:23.980]                     }
[13:24:23.980]                     invisible(muffled)
[13:24:23.980]                   }
[13:24:23.980]                   muffleCondition(cond)
[13:24:23.980]                 })
[13:24:23.980]             }))
[13:24:23.980]             future::FutureResult(value = ...future.value$value, 
[13:24:23.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.980]                   ...future.rng), globalenv = if (FALSE) 
[13:24:23.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:23.980]                     ...future.globalenv.names))
[13:24:23.980]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:23.980]         }, condition = base::local({
[13:24:23.980]             c <- base::c
[13:24:23.980]             inherits <- base::inherits
[13:24:23.980]             invokeRestart <- base::invokeRestart
[13:24:23.980]             length <- base::length
[13:24:23.980]             list <- base::list
[13:24:23.980]             seq.int <- base::seq.int
[13:24:23.980]             signalCondition <- base::signalCondition
[13:24:23.980]             sys.calls <- base::sys.calls
[13:24:23.980]             `[[` <- base::`[[`
[13:24:23.980]             `+` <- base::`+`
[13:24:23.980]             `<<-` <- base::`<<-`
[13:24:23.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:23.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:23.980]                   3L)]
[13:24:23.980]             }
[13:24:23.980]             function(cond) {
[13:24:23.980]                 is_error <- inherits(cond, "error")
[13:24:23.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:23.980]                   NULL)
[13:24:23.980]                 if (is_error) {
[13:24:23.980]                   sessionInformation <- function() {
[13:24:23.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:23.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:23.980]                       search = base::search(), system = base::Sys.info())
[13:24:23.980]                   }
[13:24:23.980]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:23.980]                     cond$call), session = sessionInformation(), 
[13:24:23.980]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:23.980]                   signalCondition(cond)
[13:24:23.980]                 }
[13:24:23.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:23.980]                 "immediateCondition"))) {
[13:24:23.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:23.980]                   ...future.conditions[[length(...future.conditions) + 
[13:24:23.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:23.980]                   if (TRUE && !signal) {
[13:24:23.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.980]                     {
[13:24:23.980]                       inherits <- base::inherits
[13:24:23.980]                       invokeRestart <- base::invokeRestart
[13:24:23.980]                       is.null <- base::is.null
[13:24:23.980]                       muffled <- FALSE
[13:24:23.980]                       if (inherits(cond, "message")) {
[13:24:23.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.980]                         if (muffled) 
[13:24:23.980]                           invokeRestart("muffleMessage")
[13:24:23.980]                       }
[13:24:23.980]                       else if (inherits(cond, "warning")) {
[13:24:23.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.980]                         if (muffled) 
[13:24:23.980]                           invokeRestart("muffleWarning")
[13:24:23.980]                       }
[13:24:23.980]                       else if (inherits(cond, "condition")) {
[13:24:23.980]                         if (!is.null(pattern)) {
[13:24:23.980]                           computeRestarts <- base::computeRestarts
[13:24:23.980]                           grepl <- base::grepl
[13:24:23.980]                           restarts <- computeRestarts(cond)
[13:24:23.980]                           for (restart in restarts) {
[13:24:23.980]                             name <- restart$name
[13:24:23.980]                             if (is.null(name)) 
[13:24:23.980]                               next
[13:24:23.980]                             if (!grepl(pattern, name)) 
[13:24:23.980]                               next
[13:24:23.980]                             invokeRestart(restart)
[13:24:23.980]                             muffled <- TRUE
[13:24:23.980]                             break
[13:24:23.980]                           }
[13:24:23.980]                         }
[13:24:23.980]                       }
[13:24:23.980]                       invisible(muffled)
[13:24:23.980]                     }
[13:24:23.980]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.980]                   }
[13:24:23.980]                 }
[13:24:23.980]                 else {
[13:24:23.980]                   if (TRUE) {
[13:24:23.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:23.980]                     {
[13:24:23.980]                       inherits <- base::inherits
[13:24:23.980]                       invokeRestart <- base::invokeRestart
[13:24:23.980]                       is.null <- base::is.null
[13:24:23.980]                       muffled <- FALSE
[13:24:23.980]                       if (inherits(cond, "message")) {
[13:24:23.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:23.980]                         if (muffled) 
[13:24:23.980]                           invokeRestart("muffleMessage")
[13:24:23.980]                       }
[13:24:23.980]                       else if (inherits(cond, "warning")) {
[13:24:23.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:23.980]                         if (muffled) 
[13:24:23.980]                           invokeRestart("muffleWarning")
[13:24:23.980]                       }
[13:24:23.980]                       else if (inherits(cond, "condition")) {
[13:24:23.980]                         if (!is.null(pattern)) {
[13:24:23.980]                           computeRestarts <- base::computeRestarts
[13:24:23.980]                           grepl <- base::grepl
[13:24:23.980]                           restarts <- computeRestarts(cond)
[13:24:23.980]                           for (restart in restarts) {
[13:24:23.980]                             name <- restart$name
[13:24:23.980]                             if (is.null(name)) 
[13:24:23.980]                               next
[13:24:23.980]                             if (!grepl(pattern, name)) 
[13:24:23.980]                               next
[13:24:23.980]                             invokeRestart(restart)
[13:24:23.980]                             muffled <- TRUE
[13:24:23.980]                             break
[13:24:23.980]                           }
[13:24:23.980]                         }
[13:24:23.980]                       }
[13:24:23.980]                       invisible(muffled)
[13:24:23.980]                     }
[13:24:23.980]                     muffleCondition(cond, pattern = "^muffle")
[13:24:23.980]                   }
[13:24:23.980]                 }
[13:24:23.980]             }
[13:24:23.980]         }))
[13:24:23.980]     }, error = function(ex) {
[13:24:23.980]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:23.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:23.980]                 ...future.rng), started = ...future.startTime, 
[13:24:23.980]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:23.980]             version = "1.8"), class = "FutureResult")
[13:24:23.980]     }, finally = {
[13:24:23.980]         if (!identical(...future.workdir, getwd())) 
[13:24:23.980]             setwd(...future.workdir)
[13:24:23.980]         {
[13:24:23.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:23.980]                 ...future.oldOptions$nwarnings <- NULL
[13:24:23.980]             }
[13:24:23.980]             base::options(...future.oldOptions)
[13:24:23.980]             if (.Platform$OS.type == "windows") {
[13:24:23.980]                 old_names <- names(...future.oldEnvVars)
[13:24:23.980]                 envs <- base::Sys.getenv()
[13:24:23.980]                 names <- names(envs)
[13:24:23.980]                 common <- intersect(names, old_names)
[13:24:23.980]                 added <- setdiff(names, old_names)
[13:24:23.980]                 removed <- setdiff(old_names, names)
[13:24:23.980]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:23.980]                   envs[common]]
[13:24:23.980]                 NAMES <- toupper(changed)
[13:24:23.980]                 args <- list()
[13:24:23.980]                 for (kk in seq_along(NAMES)) {
[13:24:23.980]                   name <- changed[[kk]]
[13:24:23.980]                   NAME <- NAMES[[kk]]
[13:24:23.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.980]                     next
[13:24:23.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.980]                 }
[13:24:23.980]                 NAMES <- toupper(added)
[13:24:23.980]                 for (kk in seq_along(NAMES)) {
[13:24:23.980]                   name <- added[[kk]]
[13:24:23.980]                   NAME <- NAMES[[kk]]
[13:24:23.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.980]                     next
[13:24:23.980]                   args[[name]] <- ""
[13:24:23.980]                 }
[13:24:23.980]                 NAMES <- toupper(removed)
[13:24:23.980]                 for (kk in seq_along(NAMES)) {
[13:24:23.980]                   name <- removed[[kk]]
[13:24:23.980]                   NAME <- NAMES[[kk]]
[13:24:23.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:23.980]                     next
[13:24:23.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:23.980]                 }
[13:24:23.980]                 if (length(args) > 0) 
[13:24:23.980]                   base::do.call(base::Sys.setenv, args = args)
[13:24:23.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:23.980]             }
[13:24:23.980]             else {
[13:24:23.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:23.980]             }
[13:24:23.980]             {
[13:24:23.980]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:23.980]                   0L) {
[13:24:23.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:23.980]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:23.980]                   base::options(opts)
[13:24:23.980]                 }
[13:24:23.980]                 {
[13:24:23.980]                   {
[13:24:23.980]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:23.980]                     NULL
[13:24:23.980]                   }
[13:24:23.980]                   options(future.plan = NULL)
[13:24:23.980]                   if (is.na(NA_character_)) 
[13:24:23.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:23.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:23.980]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:23.980]                     envir = parent.frame()) 
[13:24:23.980]                   {
[13:24:23.980]                     default_workers <- missing(workers)
[13:24:23.980]                     if (is.function(workers)) 
[13:24:23.980]                       workers <- workers()
[13:24:23.980]                     workers <- structure(as.integer(workers), 
[13:24:23.980]                       class = class(workers))
[13:24:23.980]                     stop_if_not(is.finite(workers), workers >= 
[13:24:23.980]                       1L)
[13:24:23.980]                     if ((workers == 1L && !inherits(workers, 
[13:24:23.980]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:23.980]                       if (default_workers) 
[13:24:23.980]                         supportsMulticore(warn = TRUE)
[13:24:23.980]                       return(sequential(..., envir = envir))
[13:24:23.980]                     }
[13:24:23.980]                     oopts <- options(mc.cores = workers)
[13:24:23.980]                     on.exit(options(oopts))
[13:24:23.980]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:23.980]                       envir = envir)
[13:24:23.980]                     if (!future$lazy) 
[13:24:23.980]                       future <- run(future)
[13:24:23.980]                     invisible(future)
[13:24:23.980]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:23.980]                 }
[13:24:23.980]             }
[13:24:23.980]         }
[13:24:23.980]     })
[13:24:23.980]     if (TRUE) {
[13:24:23.980]         base::sink(type = "output", split = FALSE)
[13:24:23.980]         if (TRUE) {
[13:24:23.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:23.980]         }
[13:24:23.980]         else {
[13:24:23.980]             ...future.result["stdout"] <- base::list(NULL)
[13:24:23.980]         }
[13:24:23.980]         base::close(...future.stdout)
[13:24:23.980]         ...future.stdout <- NULL
[13:24:23.980]     }
[13:24:23.980]     ...future.result$conditions <- ...future.conditions
[13:24:23.980]     ...future.result$finished <- base::Sys.time()
[13:24:23.980]     ...future.result
[13:24:23.980] }
[13:24:23.983] requestCore(): workers = 2
[13:24:23.983] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:23.994] result() for MulticoreFuture ...
[13:24:23.995] result() for MulticoreFuture ...
[13:24:23.995] result() for MulticoreFuture ... done
[13:24:23.995] result() for MulticoreFuture ... done
[13:24:23.995] result() for MulticoreFuture ...
[13:24:23.995] result() for MulticoreFuture ... done
[13:24:23.997] MulticoreFuture started
[13:24:23.998] - Launch lazy future ... done
[13:24:23.998] run() for ‘MulticoreFuture’ ... done
[13:24:23.999] plan(): Setting new future strategy stack:
[13:24:24.000] getGlobalsAndPackages() ...
[13:24:24.000] Searching for globals...
[13:24:23.999] List of future strategies:
[13:24:23.999] 1. sequential:
[13:24:23.999]    - args: function (..., envir = parent.frame())
[13:24:23.999]    - tweaked: FALSE
[13:24:23.999]    - call: NULL
[13:24:24.001] plan(): nbrOfWorkers() = 1
[13:24:24.002] - globals found: [1] ‘{’
[13:24:24.002] Searching for globals ... DONE
[13:24:24.003] Resolving globals: FALSE
[13:24:24.003] 
[13:24:24.004] plan(): Setting new future strategy stack:
[13:24:24.004] 
[13:24:24.004] getGlobalsAndPackages() ... DONE
[13:24:24.004] List of future strategies:
[13:24:24.004] 1. multicore:
[13:24:24.004]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.004]    - tweaked: FALSE
[13:24:24.004]    - call: plan(strategy)
[13:24:24.005] run() for ‘Future’ ...
[13:24:24.005] - state: ‘created’
[13:24:24.005] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.010] plan(): nbrOfWorkers() = 2
[13:24:24.011] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.011] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.011]   - Field: ‘label’
[13:24:24.011]   - Field: ‘local’
[13:24:24.012]   - Field: ‘owner’
[13:24:24.012]   - Field: ‘envir’
[13:24:24.012]   - Field: ‘workers’
[13:24:24.012]   - Field: ‘packages’
[13:24:24.012]   - Field: ‘gc’
[13:24:24.012]   - Field: ‘job’
[13:24:24.013]   - Field: ‘conditions’
[13:24:24.013]   - Field: ‘expr’
[13:24:24.013]   - Field: ‘uuid’
[13:24:24.013]   - Field: ‘seed’
[13:24:24.013]   - Field: ‘version’
[13:24:24.013]   - Field: ‘result’
[13:24:24.013]   - Field: ‘asynchronous’
[13:24:24.014]   - Field: ‘calls’
[13:24:24.014]   - Field: ‘globals’
[13:24:24.014]   - Field: ‘stdout’
[13:24:24.014]   - Field: ‘earlySignal’
[13:24:24.014]   - Field: ‘lazy’
[13:24:24.014]   - Field: ‘state’
[13:24:24.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.015] - Launch lazy future ...
[13:24:24.015] Packages needed by the future expression (n = 0): <none>
[13:24:24.015] Packages needed by future strategies (n = 0): <none>
[13:24:24.016] {
[13:24:24.016]     {
[13:24:24.016]         {
[13:24:24.016]             ...future.startTime <- base::Sys.time()
[13:24:24.016]             {
[13:24:24.016]                 {
[13:24:24.016]                   {
[13:24:24.016]                     {
[13:24:24.016]                       base::local({
[13:24:24.016]                         has_future <- base::requireNamespace("future", 
[13:24:24.016]                           quietly = TRUE)
[13:24:24.016]                         if (has_future) {
[13:24:24.016]                           ns <- base::getNamespace("future")
[13:24:24.016]                           version <- ns[[".package"]][["version"]]
[13:24:24.016]                           if (is.null(version)) 
[13:24:24.016]                             version <- utils::packageVersion("future")
[13:24:24.016]                         }
[13:24:24.016]                         else {
[13:24:24.016]                           version <- NULL
[13:24:24.016]                         }
[13:24:24.016]                         if (!has_future || version < "1.8.0") {
[13:24:24.016]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.016]                             "", base::R.version$version.string), 
[13:24:24.016]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.016]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.016]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.016]                               "release", "version")], collapse = " "), 
[13:24:24.016]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.016]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.016]                             info)
[13:24:24.016]                           info <- base::paste(info, collapse = "; ")
[13:24:24.016]                           if (!has_future) {
[13:24:24.016]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.016]                               info)
[13:24:24.016]                           }
[13:24:24.016]                           else {
[13:24:24.016]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.016]                               info, version)
[13:24:24.016]                           }
[13:24:24.016]                           base::stop(msg)
[13:24:24.016]                         }
[13:24:24.016]                       })
[13:24:24.016]                     }
[13:24:24.016]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.016]                     base::options(mc.cores = 1L)
[13:24:24.016]                   }
[13:24:24.016]                   options(future.plan = NULL)
[13:24:24.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.016]                 }
[13:24:24.016]                 ...future.workdir <- getwd()
[13:24:24.016]             }
[13:24:24.016]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.016]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.016]         }
[13:24:24.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.016]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.016]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.016]             base::names(...future.oldOptions))
[13:24:24.016]     }
[13:24:24.016]     if (FALSE) {
[13:24:24.016]     }
[13:24:24.016]     else {
[13:24:24.016]         if (TRUE) {
[13:24:24.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.016]                 open = "w")
[13:24:24.016]         }
[13:24:24.016]         else {
[13:24:24.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.016]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.016]         }
[13:24:24.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.016]             base::sink(type = "output", split = FALSE)
[13:24:24.016]             base::close(...future.stdout)
[13:24:24.016]         }, add = TRUE)
[13:24:24.016]     }
[13:24:24.016]     ...future.frame <- base::sys.nframe()
[13:24:24.016]     ...future.conditions <- base::list()
[13:24:24.016]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.016]     if (FALSE) {
[13:24:24.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.016]     }
[13:24:24.016]     ...future.result <- base::tryCatch({
[13:24:24.016]         base::withCallingHandlers({
[13:24:24.016]             ...future.value <- base::withVisible(base::local({
[13:24:24.016]                 withCallingHandlers({
[13:24:24.016]                   {
[13:24:24.016]                     2
[13:24:24.016]                   }
[13:24:24.016]                 }, immediateCondition = function(cond) {
[13:24:24.016]                   save_rds <- function (object, pathname, ...) 
[13:24:24.016]                   {
[13:24:24.016]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.016]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.016]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.016]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.016]                         fi_tmp[["mtime"]])
[13:24:24.016]                     }
[13:24:24.016]                     tryCatch({
[13:24:24.016]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.016]                     }, error = function(ex) {
[13:24:24.016]                       msg <- conditionMessage(ex)
[13:24:24.016]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.016]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.016]                         fi_tmp[["mtime"]], msg)
[13:24:24.016]                       ex$message <- msg
[13:24:24.016]                       stop(ex)
[13:24:24.016]                     })
[13:24:24.016]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.016]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.016]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.016]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.016]                       fi <- file.info(pathname)
[13:24:24.016]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.016]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.016]                         fi[["size"]], fi[["mtime"]])
[13:24:24.016]                       stop(msg)
[13:24:24.016]                     }
[13:24:24.016]                     invisible(pathname)
[13:24:24.016]                   }
[13:24:24.016]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.016]                     rootPath = tempdir()) 
[13:24:24.016]                   {
[13:24:24.016]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.016]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.016]                       tmpdir = path, fileext = ".rds")
[13:24:24.016]                     save_rds(obj, file)
[13:24:24.016]                   }
[13:24:24.016]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.016]                   {
[13:24:24.016]                     inherits <- base::inherits
[13:24:24.016]                     invokeRestart <- base::invokeRestart
[13:24:24.016]                     is.null <- base::is.null
[13:24:24.016]                     muffled <- FALSE
[13:24:24.016]                     if (inherits(cond, "message")) {
[13:24:24.016]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.016]                       if (muffled) 
[13:24:24.016]                         invokeRestart("muffleMessage")
[13:24:24.016]                     }
[13:24:24.016]                     else if (inherits(cond, "warning")) {
[13:24:24.016]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.016]                       if (muffled) 
[13:24:24.016]                         invokeRestart("muffleWarning")
[13:24:24.016]                     }
[13:24:24.016]                     else if (inherits(cond, "condition")) {
[13:24:24.016]                       if (!is.null(pattern)) {
[13:24:24.016]                         computeRestarts <- base::computeRestarts
[13:24:24.016]                         grepl <- base::grepl
[13:24:24.016]                         restarts <- computeRestarts(cond)
[13:24:24.016]                         for (restart in restarts) {
[13:24:24.016]                           name <- restart$name
[13:24:24.016]                           if (is.null(name)) 
[13:24:24.016]                             next
[13:24:24.016]                           if (!grepl(pattern, name)) 
[13:24:24.016]                             next
[13:24:24.016]                           invokeRestart(restart)
[13:24:24.016]                           muffled <- TRUE
[13:24:24.016]                           break
[13:24:24.016]                         }
[13:24:24.016]                       }
[13:24:24.016]                     }
[13:24:24.016]                     invisible(muffled)
[13:24:24.016]                   }
[13:24:24.016]                   muffleCondition(cond)
[13:24:24.016]                 })
[13:24:24.016]             }))
[13:24:24.016]             future::FutureResult(value = ...future.value$value, 
[13:24:24.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.016]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.016]                     ...future.globalenv.names))
[13:24:24.016]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.016]         }, condition = base::local({
[13:24:24.016]             c <- base::c
[13:24:24.016]             inherits <- base::inherits
[13:24:24.016]             invokeRestart <- base::invokeRestart
[13:24:24.016]             length <- base::length
[13:24:24.016]             list <- base::list
[13:24:24.016]             seq.int <- base::seq.int
[13:24:24.016]             signalCondition <- base::signalCondition
[13:24:24.016]             sys.calls <- base::sys.calls
[13:24:24.016]             `[[` <- base::`[[`
[13:24:24.016]             `+` <- base::`+`
[13:24:24.016]             `<<-` <- base::`<<-`
[13:24:24.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.016]                   3L)]
[13:24:24.016]             }
[13:24:24.016]             function(cond) {
[13:24:24.016]                 is_error <- inherits(cond, "error")
[13:24:24.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.016]                   NULL)
[13:24:24.016]                 if (is_error) {
[13:24:24.016]                   sessionInformation <- function() {
[13:24:24.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.016]                       search = base::search(), system = base::Sys.info())
[13:24:24.016]                   }
[13:24:24.016]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.016]                     cond$call), session = sessionInformation(), 
[13:24:24.016]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.016]                   signalCondition(cond)
[13:24:24.016]                 }
[13:24:24.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.016]                 "immediateCondition"))) {
[13:24:24.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.016]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.016]                   if (TRUE && !signal) {
[13:24:24.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.016]                     {
[13:24:24.016]                       inherits <- base::inherits
[13:24:24.016]                       invokeRestart <- base::invokeRestart
[13:24:24.016]                       is.null <- base::is.null
[13:24:24.016]                       muffled <- FALSE
[13:24:24.016]                       if (inherits(cond, "message")) {
[13:24:24.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.016]                         if (muffled) 
[13:24:24.016]                           invokeRestart("muffleMessage")
[13:24:24.016]                       }
[13:24:24.016]                       else if (inherits(cond, "warning")) {
[13:24:24.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.016]                         if (muffled) 
[13:24:24.016]                           invokeRestart("muffleWarning")
[13:24:24.016]                       }
[13:24:24.016]                       else if (inherits(cond, "condition")) {
[13:24:24.016]                         if (!is.null(pattern)) {
[13:24:24.016]                           computeRestarts <- base::computeRestarts
[13:24:24.016]                           grepl <- base::grepl
[13:24:24.016]                           restarts <- computeRestarts(cond)
[13:24:24.016]                           for (restart in restarts) {
[13:24:24.016]                             name <- restart$name
[13:24:24.016]                             if (is.null(name)) 
[13:24:24.016]                               next
[13:24:24.016]                             if (!grepl(pattern, name)) 
[13:24:24.016]                               next
[13:24:24.016]                             invokeRestart(restart)
[13:24:24.016]                             muffled <- TRUE
[13:24:24.016]                             break
[13:24:24.016]                           }
[13:24:24.016]                         }
[13:24:24.016]                       }
[13:24:24.016]                       invisible(muffled)
[13:24:24.016]                     }
[13:24:24.016]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.016]                   }
[13:24:24.016]                 }
[13:24:24.016]                 else {
[13:24:24.016]                   if (TRUE) {
[13:24:24.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.016]                     {
[13:24:24.016]                       inherits <- base::inherits
[13:24:24.016]                       invokeRestart <- base::invokeRestart
[13:24:24.016]                       is.null <- base::is.null
[13:24:24.016]                       muffled <- FALSE
[13:24:24.016]                       if (inherits(cond, "message")) {
[13:24:24.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.016]                         if (muffled) 
[13:24:24.016]                           invokeRestart("muffleMessage")
[13:24:24.016]                       }
[13:24:24.016]                       else if (inherits(cond, "warning")) {
[13:24:24.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.016]                         if (muffled) 
[13:24:24.016]                           invokeRestart("muffleWarning")
[13:24:24.016]                       }
[13:24:24.016]                       else if (inherits(cond, "condition")) {
[13:24:24.016]                         if (!is.null(pattern)) {
[13:24:24.016]                           computeRestarts <- base::computeRestarts
[13:24:24.016]                           grepl <- base::grepl
[13:24:24.016]                           restarts <- computeRestarts(cond)
[13:24:24.016]                           for (restart in restarts) {
[13:24:24.016]                             name <- restart$name
[13:24:24.016]                             if (is.null(name)) 
[13:24:24.016]                               next
[13:24:24.016]                             if (!grepl(pattern, name)) 
[13:24:24.016]                               next
[13:24:24.016]                             invokeRestart(restart)
[13:24:24.016]                             muffled <- TRUE
[13:24:24.016]                             break
[13:24:24.016]                           }
[13:24:24.016]                         }
[13:24:24.016]                       }
[13:24:24.016]                       invisible(muffled)
[13:24:24.016]                     }
[13:24:24.016]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.016]                   }
[13:24:24.016]                 }
[13:24:24.016]             }
[13:24:24.016]         }))
[13:24:24.016]     }, error = function(ex) {
[13:24:24.016]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.016]                 ...future.rng), started = ...future.startTime, 
[13:24:24.016]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.016]             version = "1.8"), class = "FutureResult")
[13:24:24.016]     }, finally = {
[13:24:24.016]         if (!identical(...future.workdir, getwd())) 
[13:24:24.016]             setwd(...future.workdir)
[13:24:24.016]         {
[13:24:24.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.016]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.016]             }
[13:24:24.016]             base::options(...future.oldOptions)
[13:24:24.016]             if (.Platform$OS.type == "windows") {
[13:24:24.016]                 old_names <- names(...future.oldEnvVars)
[13:24:24.016]                 envs <- base::Sys.getenv()
[13:24:24.016]                 names <- names(envs)
[13:24:24.016]                 common <- intersect(names, old_names)
[13:24:24.016]                 added <- setdiff(names, old_names)
[13:24:24.016]                 removed <- setdiff(old_names, names)
[13:24:24.016]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.016]                   envs[common]]
[13:24:24.016]                 NAMES <- toupper(changed)
[13:24:24.016]                 args <- list()
[13:24:24.016]                 for (kk in seq_along(NAMES)) {
[13:24:24.016]                   name <- changed[[kk]]
[13:24:24.016]                   NAME <- NAMES[[kk]]
[13:24:24.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.016]                     next
[13:24:24.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.016]                 }
[13:24:24.016]                 NAMES <- toupper(added)
[13:24:24.016]                 for (kk in seq_along(NAMES)) {
[13:24:24.016]                   name <- added[[kk]]
[13:24:24.016]                   NAME <- NAMES[[kk]]
[13:24:24.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.016]                     next
[13:24:24.016]                   args[[name]] <- ""
[13:24:24.016]                 }
[13:24:24.016]                 NAMES <- toupper(removed)
[13:24:24.016]                 for (kk in seq_along(NAMES)) {
[13:24:24.016]                   name <- removed[[kk]]
[13:24:24.016]                   NAME <- NAMES[[kk]]
[13:24:24.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.016]                     next
[13:24:24.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.016]                 }
[13:24:24.016]                 if (length(args) > 0) 
[13:24:24.016]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.016]             }
[13:24:24.016]             else {
[13:24:24.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.016]             }
[13:24:24.016]             {
[13:24:24.016]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.016]                   0L) {
[13:24:24.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.016]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.016]                   base::options(opts)
[13:24:24.016]                 }
[13:24:24.016]                 {
[13:24:24.016]                   {
[13:24:24.016]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.016]                     NULL
[13:24:24.016]                   }
[13:24:24.016]                   options(future.plan = NULL)
[13:24:24.016]                   if (is.na(NA_character_)) 
[13:24:24.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.016]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.016]                     envir = parent.frame()) 
[13:24:24.016]                   {
[13:24:24.016]                     default_workers <- missing(workers)
[13:24:24.016]                     if (is.function(workers)) 
[13:24:24.016]                       workers <- workers()
[13:24:24.016]                     workers <- structure(as.integer(workers), 
[13:24:24.016]                       class = class(workers))
[13:24:24.016]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.016]                       1L)
[13:24:24.016]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.016]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.016]                       if (default_workers) 
[13:24:24.016]                         supportsMulticore(warn = TRUE)
[13:24:24.016]                       return(sequential(..., envir = envir))
[13:24:24.016]                     }
[13:24:24.016]                     oopts <- options(mc.cores = workers)
[13:24:24.016]                     on.exit(options(oopts))
[13:24:24.016]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.016]                       envir = envir)
[13:24:24.016]                     if (!future$lazy) 
[13:24:24.016]                       future <- run(future)
[13:24:24.016]                     invisible(future)
[13:24:24.016]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.016]                 }
[13:24:24.016]             }
[13:24:24.016]         }
[13:24:24.016]     })
[13:24:24.016]     if (TRUE) {
[13:24:24.016]         base::sink(type = "output", split = FALSE)
[13:24:24.016]         if (TRUE) {
[13:24:24.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.016]         }
[13:24:24.016]         else {
[13:24:24.016]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.016]         }
[13:24:24.016]         base::close(...future.stdout)
[13:24:24.016]         ...future.stdout <- NULL
[13:24:24.016]     }
[13:24:24.016]     ...future.result$conditions <- ...future.conditions
[13:24:24.016]     ...future.result$finished <- base::Sys.time()
[13:24:24.016]     ...future.result
[13:24:24.016] }
[13:24:24.020] requestCore(): workers = 2
[13:24:24.020] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.031] result() for MulticoreFuture ...
[13:24:24.032] result() for MulticoreFuture ...
[13:24:24.032] result() for MulticoreFuture ... done
[13:24:24.032] result() for MulticoreFuture ... done
[13:24:24.032] result() for MulticoreFuture ...
[13:24:24.032] result() for MulticoreFuture ... done
[13:24:24.035] MulticoreFuture started
[13:24:24.035] - Launch lazy future ... done
[13:24:24.035] run() for ‘MulticoreFuture’ ... done
[13:24:24.036] plan(): Setting new future strategy stack:
[13:24:24.036] List of future strategies:
[13:24:24.036] 1. sequential:
[13:24:24.036]    - args: function (..., envir = parent.frame())
[13:24:24.036]    - tweaked: FALSE
[13:24:24.036]    - call: NULL
[13:24:24.038] resolve() on environment ...
[13:24:24.038] plan(): nbrOfWorkers() = 1
[13:24:24.038]  recursive: 0
[13:24:24.039]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:24:24.040] Future #1
[13:24:24.040]  length: 2 (resolved future 1)
[13:24:24.040] plan(): Setting new future strategy stack:
[13:24:24.041] List of future strategies:
[13:24:24.041] 1. multicore:
[13:24:24.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.041]    - tweaked: FALSE
[13:24:24.041]    - call: plan(strategy)
[13:24:24.046] plan(): nbrOfWorkers() = 2
[13:24:24.046] Future #2
[13:24:24.046]  length: 1 (resolved future 2)
[13:24:24.046]  length: 0 (resolved future 3)
[13:24:24.047] resolve() on environment ... DONE
[13:24:24.047] getGlobalsAndPackages() ...
[13:24:24.048] Searching for globals...
[13:24:24.049] - globals found: [1] ‘{’
[13:24:24.049] Searching for globals ... DONE
[13:24:24.049] Resolving globals: FALSE
[13:24:24.050] 
[13:24:24.050] 
[13:24:24.050] getGlobalsAndPackages() ... DONE
[13:24:24.051] run() for ‘Future’ ...
[13:24:24.051] - state: ‘created’
[13:24:24.051] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.061] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.062] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.062]   - Field: ‘label’
[13:24:24.062]   - Field: ‘local’
[13:24:24.062]   - Field: ‘owner’
[13:24:24.063]   - Field: ‘envir’
[13:24:24.063]   - Field: ‘workers’
[13:24:24.063]   - Field: ‘packages’
[13:24:24.063]   - Field: ‘gc’
[13:24:24.063]   - Field: ‘job’
[13:24:24.064]   - Field: ‘conditions’
[13:24:24.064]   - Field: ‘expr’
[13:24:24.064]   - Field: ‘uuid’
[13:24:24.064]   - Field: ‘seed’
[13:24:24.064]   - Field: ‘version’
[13:24:24.064]   - Field: ‘result’
[13:24:24.065]   - Field: ‘asynchronous’
[13:24:24.065]   - Field: ‘calls’
[13:24:24.065]   - Field: ‘globals’
[13:24:24.065]   - Field: ‘stdout’
[13:24:24.065]   - Field: ‘earlySignal’
[13:24:24.065]   - Field: ‘lazy’
[13:24:24.066]   - Field: ‘state’
[13:24:24.066] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.066] - Launch lazy future ...
[13:24:24.066] Packages needed by the future expression (n = 0): <none>
[13:24:24.067] Packages needed by future strategies (n = 0): <none>
[13:24:24.068] {
[13:24:24.068]     {
[13:24:24.068]         {
[13:24:24.068]             ...future.startTime <- base::Sys.time()
[13:24:24.068]             {
[13:24:24.068]                 {
[13:24:24.068]                   {
[13:24:24.068]                     {
[13:24:24.068]                       base::local({
[13:24:24.068]                         has_future <- base::requireNamespace("future", 
[13:24:24.068]                           quietly = TRUE)
[13:24:24.068]                         if (has_future) {
[13:24:24.068]                           ns <- base::getNamespace("future")
[13:24:24.068]                           version <- ns[[".package"]][["version"]]
[13:24:24.068]                           if (is.null(version)) 
[13:24:24.068]                             version <- utils::packageVersion("future")
[13:24:24.068]                         }
[13:24:24.068]                         else {
[13:24:24.068]                           version <- NULL
[13:24:24.068]                         }
[13:24:24.068]                         if (!has_future || version < "1.8.0") {
[13:24:24.068]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.068]                             "", base::R.version$version.string), 
[13:24:24.068]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.068]                               "release", "version")], collapse = " "), 
[13:24:24.068]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.068]                             info)
[13:24:24.068]                           info <- base::paste(info, collapse = "; ")
[13:24:24.068]                           if (!has_future) {
[13:24:24.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.068]                               info)
[13:24:24.068]                           }
[13:24:24.068]                           else {
[13:24:24.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.068]                               info, version)
[13:24:24.068]                           }
[13:24:24.068]                           base::stop(msg)
[13:24:24.068]                         }
[13:24:24.068]                       })
[13:24:24.068]                     }
[13:24:24.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.068]                     base::options(mc.cores = 1L)
[13:24:24.068]                   }
[13:24:24.068]                   options(future.plan = NULL)
[13:24:24.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.068]                 }
[13:24:24.068]                 ...future.workdir <- getwd()
[13:24:24.068]             }
[13:24:24.068]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.068]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.068]         }
[13:24:24.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.068]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.068]             base::names(...future.oldOptions))
[13:24:24.068]     }
[13:24:24.068]     if (FALSE) {
[13:24:24.068]     }
[13:24:24.068]     else {
[13:24:24.068]         if (TRUE) {
[13:24:24.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.068]                 open = "w")
[13:24:24.068]         }
[13:24:24.068]         else {
[13:24:24.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.068]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.068]         }
[13:24:24.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.068]             base::sink(type = "output", split = FALSE)
[13:24:24.068]             base::close(...future.stdout)
[13:24:24.068]         }, add = TRUE)
[13:24:24.068]     }
[13:24:24.068]     ...future.frame <- base::sys.nframe()
[13:24:24.068]     ...future.conditions <- base::list()
[13:24:24.068]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.068]     if (FALSE) {
[13:24:24.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.068]     }
[13:24:24.068]     ...future.result <- base::tryCatch({
[13:24:24.068]         base::withCallingHandlers({
[13:24:24.068]             ...future.value <- base::withVisible(base::local({
[13:24:24.068]                 withCallingHandlers({
[13:24:24.068]                   {
[13:24:24.068]                     1
[13:24:24.068]                   }
[13:24:24.068]                 }, immediateCondition = function(cond) {
[13:24:24.068]                   save_rds <- function (object, pathname, ...) 
[13:24:24.068]                   {
[13:24:24.068]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.068]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.068]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.068]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.068]                         fi_tmp[["mtime"]])
[13:24:24.068]                     }
[13:24:24.068]                     tryCatch({
[13:24:24.068]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.068]                     }, error = function(ex) {
[13:24:24.068]                       msg <- conditionMessage(ex)
[13:24:24.068]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.068]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.068]                         fi_tmp[["mtime"]], msg)
[13:24:24.068]                       ex$message <- msg
[13:24:24.068]                       stop(ex)
[13:24:24.068]                     })
[13:24:24.068]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.068]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.068]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.068]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.068]                       fi <- file.info(pathname)
[13:24:24.068]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.068]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.068]                         fi[["size"]], fi[["mtime"]])
[13:24:24.068]                       stop(msg)
[13:24:24.068]                     }
[13:24:24.068]                     invisible(pathname)
[13:24:24.068]                   }
[13:24:24.068]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.068]                     rootPath = tempdir()) 
[13:24:24.068]                   {
[13:24:24.068]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.068]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.068]                       tmpdir = path, fileext = ".rds")
[13:24:24.068]                     save_rds(obj, file)
[13:24:24.068]                   }
[13:24:24.068]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.068]                   {
[13:24:24.068]                     inherits <- base::inherits
[13:24:24.068]                     invokeRestart <- base::invokeRestart
[13:24:24.068]                     is.null <- base::is.null
[13:24:24.068]                     muffled <- FALSE
[13:24:24.068]                     if (inherits(cond, "message")) {
[13:24:24.068]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.068]                       if (muffled) 
[13:24:24.068]                         invokeRestart("muffleMessage")
[13:24:24.068]                     }
[13:24:24.068]                     else if (inherits(cond, "warning")) {
[13:24:24.068]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.068]                       if (muffled) 
[13:24:24.068]                         invokeRestart("muffleWarning")
[13:24:24.068]                     }
[13:24:24.068]                     else if (inherits(cond, "condition")) {
[13:24:24.068]                       if (!is.null(pattern)) {
[13:24:24.068]                         computeRestarts <- base::computeRestarts
[13:24:24.068]                         grepl <- base::grepl
[13:24:24.068]                         restarts <- computeRestarts(cond)
[13:24:24.068]                         for (restart in restarts) {
[13:24:24.068]                           name <- restart$name
[13:24:24.068]                           if (is.null(name)) 
[13:24:24.068]                             next
[13:24:24.068]                           if (!grepl(pattern, name)) 
[13:24:24.068]                             next
[13:24:24.068]                           invokeRestart(restart)
[13:24:24.068]                           muffled <- TRUE
[13:24:24.068]                           break
[13:24:24.068]                         }
[13:24:24.068]                       }
[13:24:24.068]                     }
[13:24:24.068]                     invisible(muffled)
[13:24:24.068]                   }
[13:24:24.068]                   muffleCondition(cond)
[13:24:24.068]                 })
[13:24:24.068]             }))
[13:24:24.068]             future::FutureResult(value = ...future.value$value, 
[13:24:24.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.068]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.068]                     ...future.globalenv.names))
[13:24:24.068]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.068]         }, condition = base::local({
[13:24:24.068]             c <- base::c
[13:24:24.068]             inherits <- base::inherits
[13:24:24.068]             invokeRestart <- base::invokeRestart
[13:24:24.068]             length <- base::length
[13:24:24.068]             list <- base::list
[13:24:24.068]             seq.int <- base::seq.int
[13:24:24.068]             signalCondition <- base::signalCondition
[13:24:24.068]             sys.calls <- base::sys.calls
[13:24:24.068]             `[[` <- base::`[[`
[13:24:24.068]             `+` <- base::`+`
[13:24:24.068]             `<<-` <- base::`<<-`
[13:24:24.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.068]                   3L)]
[13:24:24.068]             }
[13:24:24.068]             function(cond) {
[13:24:24.068]                 is_error <- inherits(cond, "error")
[13:24:24.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.068]                   NULL)
[13:24:24.068]                 if (is_error) {
[13:24:24.068]                   sessionInformation <- function() {
[13:24:24.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.068]                       search = base::search(), system = base::Sys.info())
[13:24:24.068]                   }
[13:24:24.068]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.068]                     cond$call), session = sessionInformation(), 
[13:24:24.068]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.068]                   signalCondition(cond)
[13:24:24.068]                 }
[13:24:24.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.068]                 "immediateCondition"))) {
[13:24:24.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.068]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.068]                   if (TRUE && !signal) {
[13:24:24.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.068]                     {
[13:24:24.068]                       inherits <- base::inherits
[13:24:24.068]                       invokeRestart <- base::invokeRestart
[13:24:24.068]                       is.null <- base::is.null
[13:24:24.068]                       muffled <- FALSE
[13:24:24.068]                       if (inherits(cond, "message")) {
[13:24:24.068]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.068]                         if (muffled) 
[13:24:24.068]                           invokeRestart("muffleMessage")
[13:24:24.068]                       }
[13:24:24.068]                       else if (inherits(cond, "warning")) {
[13:24:24.068]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.068]                         if (muffled) 
[13:24:24.068]                           invokeRestart("muffleWarning")
[13:24:24.068]                       }
[13:24:24.068]                       else if (inherits(cond, "condition")) {
[13:24:24.068]                         if (!is.null(pattern)) {
[13:24:24.068]                           computeRestarts <- base::computeRestarts
[13:24:24.068]                           grepl <- base::grepl
[13:24:24.068]                           restarts <- computeRestarts(cond)
[13:24:24.068]                           for (restart in restarts) {
[13:24:24.068]                             name <- restart$name
[13:24:24.068]                             if (is.null(name)) 
[13:24:24.068]                               next
[13:24:24.068]                             if (!grepl(pattern, name)) 
[13:24:24.068]                               next
[13:24:24.068]                             invokeRestart(restart)
[13:24:24.068]                             muffled <- TRUE
[13:24:24.068]                             break
[13:24:24.068]                           }
[13:24:24.068]                         }
[13:24:24.068]                       }
[13:24:24.068]                       invisible(muffled)
[13:24:24.068]                     }
[13:24:24.068]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.068]                   }
[13:24:24.068]                 }
[13:24:24.068]                 else {
[13:24:24.068]                   if (TRUE) {
[13:24:24.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.068]                     {
[13:24:24.068]                       inherits <- base::inherits
[13:24:24.068]                       invokeRestart <- base::invokeRestart
[13:24:24.068]                       is.null <- base::is.null
[13:24:24.068]                       muffled <- FALSE
[13:24:24.068]                       if (inherits(cond, "message")) {
[13:24:24.068]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.068]                         if (muffled) 
[13:24:24.068]                           invokeRestart("muffleMessage")
[13:24:24.068]                       }
[13:24:24.068]                       else if (inherits(cond, "warning")) {
[13:24:24.068]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.068]                         if (muffled) 
[13:24:24.068]                           invokeRestart("muffleWarning")
[13:24:24.068]                       }
[13:24:24.068]                       else if (inherits(cond, "condition")) {
[13:24:24.068]                         if (!is.null(pattern)) {
[13:24:24.068]                           computeRestarts <- base::computeRestarts
[13:24:24.068]                           grepl <- base::grepl
[13:24:24.068]                           restarts <- computeRestarts(cond)
[13:24:24.068]                           for (restart in restarts) {
[13:24:24.068]                             name <- restart$name
[13:24:24.068]                             if (is.null(name)) 
[13:24:24.068]                               next
[13:24:24.068]                             if (!grepl(pattern, name)) 
[13:24:24.068]                               next
[13:24:24.068]                             invokeRestart(restart)
[13:24:24.068]                             muffled <- TRUE
[13:24:24.068]                             break
[13:24:24.068]                           }
[13:24:24.068]                         }
[13:24:24.068]                       }
[13:24:24.068]                       invisible(muffled)
[13:24:24.068]                     }
[13:24:24.068]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.068]                   }
[13:24:24.068]                 }
[13:24:24.068]             }
[13:24:24.068]         }))
[13:24:24.068]     }, error = function(ex) {
[13:24:24.068]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.068]                 ...future.rng), started = ...future.startTime, 
[13:24:24.068]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.068]             version = "1.8"), class = "FutureResult")
[13:24:24.068]     }, finally = {
[13:24:24.068]         if (!identical(...future.workdir, getwd())) 
[13:24:24.068]             setwd(...future.workdir)
[13:24:24.068]         {
[13:24:24.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.068]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.068]             }
[13:24:24.068]             base::options(...future.oldOptions)
[13:24:24.068]             if (.Platform$OS.type == "windows") {
[13:24:24.068]                 old_names <- names(...future.oldEnvVars)
[13:24:24.068]                 envs <- base::Sys.getenv()
[13:24:24.068]                 names <- names(envs)
[13:24:24.068]                 common <- intersect(names, old_names)
[13:24:24.068]                 added <- setdiff(names, old_names)
[13:24:24.068]                 removed <- setdiff(old_names, names)
[13:24:24.068]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.068]                   envs[common]]
[13:24:24.068]                 NAMES <- toupper(changed)
[13:24:24.068]                 args <- list()
[13:24:24.068]                 for (kk in seq_along(NAMES)) {
[13:24:24.068]                   name <- changed[[kk]]
[13:24:24.068]                   NAME <- NAMES[[kk]]
[13:24:24.068]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.068]                     next
[13:24:24.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.068]                 }
[13:24:24.068]                 NAMES <- toupper(added)
[13:24:24.068]                 for (kk in seq_along(NAMES)) {
[13:24:24.068]                   name <- added[[kk]]
[13:24:24.068]                   NAME <- NAMES[[kk]]
[13:24:24.068]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.068]                     next
[13:24:24.068]                   args[[name]] <- ""
[13:24:24.068]                 }
[13:24:24.068]                 NAMES <- toupper(removed)
[13:24:24.068]                 for (kk in seq_along(NAMES)) {
[13:24:24.068]                   name <- removed[[kk]]
[13:24:24.068]                   NAME <- NAMES[[kk]]
[13:24:24.068]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.068]                     next
[13:24:24.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.068]                 }
[13:24:24.068]                 if (length(args) > 0) 
[13:24:24.068]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.068]             }
[13:24:24.068]             else {
[13:24:24.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.068]             }
[13:24:24.068]             {
[13:24:24.068]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.068]                   0L) {
[13:24:24.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.068]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.068]                   base::options(opts)
[13:24:24.068]                 }
[13:24:24.068]                 {
[13:24:24.068]                   {
[13:24:24.068]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.068]                     NULL
[13:24:24.068]                   }
[13:24:24.068]                   options(future.plan = NULL)
[13:24:24.068]                   if (is.na(NA_character_)) 
[13:24:24.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.068]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.068]                     envir = parent.frame()) 
[13:24:24.068]                   {
[13:24:24.068]                     default_workers <- missing(workers)
[13:24:24.068]                     if (is.function(workers)) 
[13:24:24.068]                       workers <- workers()
[13:24:24.068]                     workers <- structure(as.integer(workers), 
[13:24:24.068]                       class = class(workers))
[13:24:24.068]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.068]                       1L)
[13:24:24.068]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.068]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.068]                       if (default_workers) 
[13:24:24.068]                         supportsMulticore(warn = TRUE)
[13:24:24.068]                       return(sequential(..., envir = envir))
[13:24:24.068]                     }
[13:24:24.068]                     oopts <- options(mc.cores = workers)
[13:24:24.068]                     on.exit(options(oopts))
[13:24:24.068]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.068]                       envir = envir)
[13:24:24.068]                     if (!future$lazy) 
[13:24:24.068]                       future <- run(future)
[13:24:24.068]                     invisible(future)
[13:24:24.068]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.068]                 }
[13:24:24.068]             }
[13:24:24.068]         }
[13:24:24.068]     })
[13:24:24.068]     if (TRUE) {
[13:24:24.068]         base::sink(type = "output", split = FALSE)
[13:24:24.068]         if (TRUE) {
[13:24:24.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.068]         }
[13:24:24.068]         else {
[13:24:24.068]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.068]         }
[13:24:24.068]         base::close(...future.stdout)
[13:24:24.068]         ...future.stdout <- NULL
[13:24:24.068]     }
[13:24:24.068]     ...future.result$conditions <- ...future.conditions
[13:24:24.068]     ...future.result$finished <- base::Sys.time()
[13:24:24.068]     ...future.result
[13:24:24.068] }
[13:24:24.071] requestCore(): workers = 2
[13:24:24.071] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.082] result() for MulticoreFuture ...
[13:24:24.083] result() for MulticoreFuture ...
[13:24:24.083] result() for MulticoreFuture ... done
[13:24:24.083] result() for MulticoreFuture ... done
[13:24:24.083] result() for MulticoreFuture ...
[13:24:24.083] result() for MulticoreFuture ... done
[13:24:24.086] MulticoreFuture started
[13:24:24.086] - Launch lazy future ... done
[13:24:24.086] run() for ‘MulticoreFuture’ ... done
[13:24:24.087] plan(): Setting new future strategy stack:
[13:24:24.088] getGlobalsAndPackages() ...
[13:24:24.088] Searching for globals...
[13:24:24.087] List of future strategies:
[13:24:24.087] 1. sequential:
[13:24:24.087]    - args: function (..., envir = parent.frame())
[13:24:24.087]    - tweaked: FALSE
[13:24:24.087]    - call: NULL
[13:24:24.089] plan(): nbrOfWorkers() = 1
[13:24:24.090] - globals found: [1] ‘{’
[13:24:24.090] Searching for globals ... DONE
[13:24:24.091] Resolving globals: FALSE
[13:24:24.091] 
[13:24:24.092] plan(): Setting new future strategy stack:
[13:24:24.092] 
[13:24:24.092] getGlobalsAndPackages() ... DONE
[13:24:24.092] List of future strategies:
[13:24:24.092] 1. multicore:
[13:24:24.092]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.092]    - tweaked: FALSE
[13:24:24.092]    - call: plan(strategy)
[13:24:24.093] run() for ‘Future’ ...
[13:24:24.093] - state: ‘created’
[13:24:24.093] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.098] plan(): nbrOfWorkers() = 2
[13:24:24.098] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.098] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.099]   - Field: ‘label’
[13:24:24.099]   - Field: ‘local’
[13:24:24.099]   - Field: ‘owner’
[13:24:24.099]   - Field: ‘envir’
[13:24:24.099]   - Field: ‘workers’
[13:24:24.099]   - Field: ‘packages’
[13:24:24.100]   - Field: ‘gc’
[13:24:24.100]   - Field: ‘job’
[13:24:24.100]   - Field: ‘conditions’
[13:24:24.100]   - Field: ‘expr’
[13:24:24.100]   - Field: ‘uuid’
[13:24:24.100]   - Field: ‘seed’
[13:24:24.101]   - Field: ‘version’
[13:24:24.101]   - Field: ‘result’
[13:24:24.101]   - Field: ‘asynchronous’
[13:24:24.101]   - Field: ‘calls’
[13:24:24.101]   - Field: ‘globals’
[13:24:24.101]   - Field: ‘stdout’
[13:24:24.102]   - Field: ‘earlySignal’
[13:24:24.102]   - Field: ‘lazy’
[13:24:24.102]   - Field: ‘state’
[13:24:24.102] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.102] - Launch lazy future ...
[13:24:24.103] Packages needed by the future expression (n = 0): <none>
[13:24:24.103] Packages needed by future strategies (n = 0): <none>
[13:24:24.103] {
[13:24:24.103]     {
[13:24:24.103]         {
[13:24:24.103]             ...future.startTime <- base::Sys.time()
[13:24:24.103]             {
[13:24:24.103]                 {
[13:24:24.103]                   {
[13:24:24.103]                     {
[13:24:24.103]                       base::local({
[13:24:24.103]                         has_future <- base::requireNamespace("future", 
[13:24:24.103]                           quietly = TRUE)
[13:24:24.103]                         if (has_future) {
[13:24:24.103]                           ns <- base::getNamespace("future")
[13:24:24.103]                           version <- ns[[".package"]][["version"]]
[13:24:24.103]                           if (is.null(version)) 
[13:24:24.103]                             version <- utils::packageVersion("future")
[13:24:24.103]                         }
[13:24:24.103]                         else {
[13:24:24.103]                           version <- NULL
[13:24:24.103]                         }
[13:24:24.103]                         if (!has_future || version < "1.8.0") {
[13:24:24.103]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.103]                             "", base::R.version$version.string), 
[13:24:24.103]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.103]                               "release", "version")], collapse = " "), 
[13:24:24.103]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.103]                             info)
[13:24:24.103]                           info <- base::paste(info, collapse = "; ")
[13:24:24.103]                           if (!has_future) {
[13:24:24.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.103]                               info)
[13:24:24.103]                           }
[13:24:24.103]                           else {
[13:24:24.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.103]                               info, version)
[13:24:24.103]                           }
[13:24:24.103]                           base::stop(msg)
[13:24:24.103]                         }
[13:24:24.103]                       })
[13:24:24.103]                     }
[13:24:24.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.103]                     base::options(mc.cores = 1L)
[13:24:24.103]                   }
[13:24:24.103]                   options(future.plan = NULL)
[13:24:24.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.103]                 }
[13:24:24.103]                 ...future.workdir <- getwd()
[13:24:24.103]             }
[13:24:24.103]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.103]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.103]         }
[13:24:24.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.103]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.103]             base::names(...future.oldOptions))
[13:24:24.103]     }
[13:24:24.103]     if (FALSE) {
[13:24:24.103]     }
[13:24:24.103]     else {
[13:24:24.103]         if (TRUE) {
[13:24:24.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.103]                 open = "w")
[13:24:24.103]         }
[13:24:24.103]         else {
[13:24:24.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.103]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.103]         }
[13:24:24.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.103]             base::sink(type = "output", split = FALSE)
[13:24:24.103]             base::close(...future.stdout)
[13:24:24.103]         }, add = TRUE)
[13:24:24.103]     }
[13:24:24.103]     ...future.frame <- base::sys.nframe()
[13:24:24.103]     ...future.conditions <- base::list()
[13:24:24.103]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.103]     if (FALSE) {
[13:24:24.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.103]     }
[13:24:24.103]     ...future.result <- base::tryCatch({
[13:24:24.103]         base::withCallingHandlers({
[13:24:24.103]             ...future.value <- base::withVisible(base::local({
[13:24:24.103]                 withCallingHandlers({
[13:24:24.103]                   {
[13:24:24.103]                     2
[13:24:24.103]                   }
[13:24:24.103]                 }, immediateCondition = function(cond) {
[13:24:24.103]                   save_rds <- function (object, pathname, ...) 
[13:24:24.103]                   {
[13:24:24.103]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.103]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.103]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.103]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.103]                         fi_tmp[["mtime"]])
[13:24:24.103]                     }
[13:24:24.103]                     tryCatch({
[13:24:24.103]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.103]                     }, error = function(ex) {
[13:24:24.103]                       msg <- conditionMessage(ex)
[13:24:24.103]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.103]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.103]                         fi_tmp[["mtime"]], msg)
[13:24:24.103]                       ex$message <- msg
[13:24:24.103]                       stop(ex)
[13:24:24.103]                     })
[13:24:24.103]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.103]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.103]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.103]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.103]                       fi <- file.info(pathname)
[13:24:24.103]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.103]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.103]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.103]                         fi[["size"]], fi[["mtime"]])
[13:24:24.103]                       stop(msg)
[13:24:24.103]                     }
[13:24:24.103]                     invisible(pathname)
[13:24:24.103]                   }
[13:24:24.103]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.103]                     rootPath = tempdir()) 
[13:24:24.103]                   {
[13:24:24.103]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.103]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.103]                       tmpdir = path, fileext = ".rds")
[13:24:24.103]                     save_rds(obj, file)
[13:24:24.103]                   }
[13:24:24.103]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.103]                   {
[13:24:24.103]                     inherits <- base::inherits
[13:24:24.103]                     invokeRestart <- base::invokeRestart
[13:24:24.103]                     is.null <- base::is.null
[13:24:24.103]                     muffled <- FALSE
[13:24:24.103]                     if (inherits(cond, "message")) {
[13:24:24.103]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.103]                       if (muffled) 
[13:24:24.103]                         invokeRestart("muffleMessage")
[13:24:24.103]                     }
[13:24:24.103]                     else if (inherits(cond, "warning")) {
[13:24:24.103]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.103]                       if (muffled) 
[13:24:24.103]                         invokeRestart("muffleWarning")
[13:24:24.103]                     }
[13:24:24.103]                     else if (inherits(cond, "condition")) {
[13:24:24.103]                       if (!is.null(pattern)) {
[13:24:24.103]                         computeRestarts <- base::computeRestarts
[13:24:24.103]                         grepl <- base::grepl
[13:24:24.103]                         restarts <- computeRestarts(cond)
[13:24:24.103]                         for (restart in restarts) {
[13:24:24.103]                           name <- restart$name
[13:24:24.103]                           if (is.null(name)) 
[13:24:24.103]                             next
[13:24:24.103]                           if (!grepl(pattern, name)) 
[13:24:24.103]                             next
[13:24:24.103]                           invokeRestart(restart)
[13:24:24.103]                           muffled <- TRUE
[13:24:24.103]                           break
[13:24:24.103]                         }
[13:24:24.103]                       }
[13:24:24.103]                     }
[13:24:24.103]                     invisible(muffled)
[13:24:24.103]                   }
[13:24:24.103]                   muffleCondition(cond)
[13:24:24.103]                 })
[13:24:24.103]             }))
[13:24:24.103]             future::FutureResult(value = ...future.value$value, 
[13:24:24.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.103]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.103]                     ...future.globalenv.names))
[13:24:24.103]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.103]         }, condition = base::local({
[13:24:24.103]             c <- base::c
[13:24:24.103]             inherits <- base::inherits
[13:24:24.103]             invokeRestart <- base::invokeRestart
[13:24:24.103]             length <- base::length
[13:24:24.103]             list <- base::list
[13:24:24.103]             seq.int <- base::seq.int
[13:24:24.103]             signalCondition <- base::signalCondition
[13:24:24.103]             sys.calls <- base::sys.calls
[13:24:24.103]             `[[` <- base::`[[`
[13:24:24.103]             `+` <- base::`+`
[13:24:24.103]             `<<-` <- base::`<<-`
[13:24:24.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.103]                   3L)]
[13:24:24.103]             }
[13:24:24.103]             function(cond) {
[13:24:24.103]                 is_error <- inherits(cond, "error")
[13:24:24.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.103]                   NULL)
[13:24:24.103]                 if (is_error) {
[13:24:24.103]                   sessionInformation <- function() {
[13:24:24.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.103]                       search = base::search(), system = base::Sys.info())
[13:24:24.103]                   }
[13:24:24.103]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.103]                     cond$call), session = sessionInformation(), 
[13:24:24.103]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.103]                   signalCondition(cond)
[13:24:24.103]                 }
[13:24:24.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.103]                 "immediateCondition"))) {
[13:24:24.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.103]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.103]                   if (TRUE && !signal) {
[13:24:24.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.103]                     {
[13:24:24.103]                       inherits <- base::inherits
[13:24:24.103]                       invokeRestart <- base::invokeRestart
[13:24:24.103]                       is.null <- base::is.null
[13:24:24.103]                       muffled <- FALSE
[13:24:24.103]                       if (inherits(cond, "message")) {
[13:24:24.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.103]                         if (muffled) 
[13:24:24.103]                           invokeRestart("muffleMessage")
[13:24:24.103]                       }
[13:24:24.103]                       else if (inherits(cond, "warning")) {
[13:24:24.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.103]                         if (muffled) 
[13:24:24.103]                           invokeRestart("muffleWarning")
[13:24:24.103]                       }
[13:24:24.103]                       else if (inherits(cond, "condition")) {
[13:24:24.103]                         if (!is.null(pattern)) {
[13:24:24.103]                           computeRestarts <- base::computeRestarts
[13:24:24.103]                           grepl <- base::grepl
[13:24:24.103]                           restarts <- computeRestarts(cond)
[13:24:24.103]                           for (restart in restarts) {
[13:24:24.103]                             name <- restart$name
[13:24:24.103]                             if (is.null(name)) 
[13:24:24.103]                               next
[13:24:24.103]                             if (!grepl(pattern, name)) 
[13:24:24.103]                               next
[13:24:24.103]                             invokeRestart(restart)
[13:24:24.103]                             muffled <- TRUE
[13:24:24.103]                             break
[13:24:24.103]                           }
[13:24:24.103]                         }
[13:24:24.103]                       }
[13:24:24.103]                       invisible(muffled)
[13:24:24.103]                     }
[13:24:24.103]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.103]                   }
[13:24:24.103]                 }
[13:24:24.103]                 else {
[13:24:24.103]                   if (TRUE) {
[13:24:24.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.103]                     {
[13:24:24.103]                       inherits <- base::inherits
[13:24:24.103]                       invokeRestart <- base::invokeRestart
[13:24:24.103]                       is.null <- base::is.null
[13:24:24.103]                       muffled <- FALSE
[13:24:24.103]                       if (inherits(cond, "message")) {
[13:24:24.103]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.103]                         if (muffled) 
[13:24:24.103]                           invokeRestart("muffleMessage")
[13:24:24.103]                       }
[13:24:24.103]                       else if (inherits(cond, "warning")) {
[13:24:24.103]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.103]                         if (muffled) 
[13:24:24.103]                           invokeRestart("muffleWarning")
[13:24:24.103]                       }
[13:24:24.103]                       else if (inherits(cond, "condition")) {
[13:24:24.103]                         if (!is.null(pattern)) {
[13:24:24.103]                           computeRestarts <- base::computeRestarts
[13:24:24.103]                           grepl <- base::grepl
[13:24:24.103]                           restarts <- computeRestarts(cond)
[13:24:24.103]                           for (restart in restarts) {
[13:24:24.103]                             name <- restart$name
[13:24:24.103]                             if (is.null(name)) 
[13:24:24.103]                               next
[13:24:24.103]                             if (!grepl(pattern, name)) 
[13:24:24.103]                               next
[13:24:24.103]                             invokeRestart(restart)
[13:24:24.103]                             muffled <- TRUE
[13:24:24.103]                             break
[13:24:24.103]                           }
[13:24:24.103]                         }
[13:24:24.103]                       }
[13:24:24.103]                       invisible(muffled)
[13:24:24.103]                     }
[13:24:24.103]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.103]                   }
[13:24:24.103]                 }
[13:24:24.103]             }
[13:24:24.103]         }))
[13:24:24.103]     }, error = function(ex) {
[13:24:24.103]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.103]                 ...future.rng), started = ...future.startTime, 
[13:24:24.103]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.103]             version = "1.8"), class = "FutureResult")
[13:24:24.103]     }, finally = {
[13:24:24.103]         if (!identical(...future.workdir, getwd())) 
[13:24:24.103]             setwd(...future.workdir)
[13:24:24.103]         {
[13:24:24.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.103]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.103]             }
[13:24:24.103]             base::options(...future.oldOptions)
[13:24:24.103]             if (.Platform$OS.type == "windows") {
[13:24:24.103]                 old_names <- names(...future.oldEnvVars)
[13:24:24.103]                 envs <- base::Sys.getenv()
[13:24:24.103]                 names <- names(envs)
[13:24:24.103]                 common <- intersect(names, old_names)
[13:24:24.103]                 added <- setdiff(names, old_names)
[13:24:24.103]                 removed <- setdiff(old_names, names)
[13:24:24.103]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.103]                   envs[common]]
[13:24:24.103]                 NAMES <- toupper(changed)
[13:24:24.103]                 args <- list()
[13:24:24.103]                 for (kk in seq_along(NAMES)) {
[13:24:24.103]                   name <- changed[[kk]]
[13:24:24.103]                   NAME <- NAMES[[kk]]
[13:24:24.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.103]                     next
[13:24:24.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.103]                 }
[13:24:24.103]                 NAMES <- toupper(added)
[13:24:24.103]                 for (kk in seq_along(NAMES)) {
[13:24:24.103]                   name <- added[[kk]]
[13:24:24.103]                   NAME <- NAMES[[kk]]
[13:24:24.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.103]                     next
[13:24:24.103]                   args[[name]] <- ""
[13:24:24.103]                 }
[13:24:24.103]                 NAMES <- toupper(removed)
[13:24:24.103]                 for (kk in seq_along(NAMES)) {
[13:24:24.103]                   name <- removed[[kk]]
[13:24:24.103]                   NAME <- NAMES[[kk]]
[13:24:24.103]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.103]                     next
[13:24:24.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.103]                 }
[13:24:24.103]                 if (length(args) > 0) 
[13:24:24.103]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.103]             }
[13:24:24.103]             else {
[13:24:24.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.103]             }
[13:24:24.103]             {
[13:24:24.103]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.103]                   0L) {
[13:24:24.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.103]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.103]                   base::options(opts)
[13:24:24.103]                 }
[13:24:24.103]                 {
[13:24:24.103]                   {
[13:24:24.103]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.103]                     NULL
[13:24:24.103]                   }
[13:24:24.103]                   options(future.plan = NULL)
[13:24:24.103]                   if (is.na(NA_character_)) 
[13:24:24.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.103]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.103]                     envir = parent.frame()) 
[13:24:24.103]                   {
[13:24:24.103]                     default_workers <- missing(workers)
[13:24:24.103]                     if (is.function(workers)) 
[13:24:24.103]                       workers <- workers()
[13:24:24.103]                     workers <- structure(as.integer(workers), 
[13:24:24.103]                       class = class(workers))
[13:24:24.103]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.103]                       1L)
[13:24:24.103]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.103]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.103]                       if (default_workers) 
[13:24:24.103]                         supportsMulticore(warn = TRUE)
[13:24:24.103]                       return(sequential(..., envir = envir))
[13:24:24.103]                     }
[13:24:24.103]                     oopts <- options(mc.cores = workers)
[13:24:24.103]                     on.exit(options(oopts))
[13:24:24.103]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.103]                       envir = envir)
[13:24:24.103]                     if (!future$lazy) 
[13:24:24.103]                       future <- run(future)
[13:24:24.103]                     invisible(future)
[13:24:24.103]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.103]                 }
[13:24:24.103]             }
[13:24:24.103]         }
[13:24:24.103]     })
[13:24:24.103]     if (TRUE) {
[13:24:24.103]         base::sink(type = "output", split = FALSE)
[13:24:24.103]         if (TRUE) {
[13:24:24.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.103]         }
[13:24:24.103]         else {
[13:24:24.103]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.103]         }
[13:24:24.103]         base::close(...future.stdout)
[13:24:24.103]         ...future.stdout <- NULL
[13:24:24.103]     }
[13:24:24.103]     ...future.result$conditions <- ...future.conditions
[13:24:24.103]     ...future.result$finished <- base::Sys.time()
[13:24:24.103]     ...future.result
[13:24:24.103] }
[13:24:24.107] requestCore(): workers = 2
[13:24:24.108] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.118] result() for MulticoreFuture ...
[13:24:24.120] result() for MulticoreFuture ...
[13:24:24.120] result() for MulticoreFuture ... done
[13:24:24.120] result() for MulticoreFuture ... done
[13:24:24.120] result() for MulticoreFuture ...
[13:24:24.120] result() for MulticoreFuture ... done
[13:24:24.123] MulticoreFuture started
[13:24:24.124] - Launch lazy future ... done
[13:24:24.124] run() for ‘MulticoreFuture’ ... done
[13:24:24.124] plan(): Setting new future strategy stack:
[13:24:24.125] List of future strategies:
[13:24:24.125] 1. sequential:
[13:24:24.125]    - args: function (..., envir = parent.frame())
[13:24:24.125]    - tweaked: FALSE
[13:24:24.125]    - call: NULL
[13:24:24.126] plan(): nbrOfWorkers() = 1
[13:24:24.126] resolve() on environment ...
[13:24:24.126]  recursive: 0
[13:24:24.127]  elements: [3] ‘a’
[13:24:24.127] Future #1
[13:24:24.127]  length: 2 (resolved future 1)
[13:24:24.128] plan(): Setting new future strategy stack:
[13:24:24.128] List of future strategies:
[13:24:24.128] 1. multicore:
[13:24:24.128]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.128]    - tweaked: FALSE
[13:24:24.128]    - call: plan(strategy)
[13:24:24.133] plan(): nbrOfWorkers() = 2
[13:24:24.133] Future #2
[13:24:24.133]  length: 1 (resolved future 2)
[13:24:24.134]  length: 0 (resolved future 3)
[13:24:24.134] resolve() on environment ... DONE
[13:24:24.135] resolve() on environment ...
[13:24:24.135]  recursive: 0
[13:24:24.136]  elements: [3] ‘b’
[13:24:24.136] Future #1
[13:24:24.136]  length: 2 (resolved future 1)
[13:24:24.136] Future #2
[13:24:24.137]  length: 1 (resolved future 2)
[13:24:24.137]  length: 0 (resolved future 3)
[13:24:24.137] resolve() on environment ... DONE
[13:24:24.138] resolve() on environment ...
[13:24:24.138]  recursive: 0
[13:24:24.138]  elements: [3] ‘c’
[13:24:24.139] Future #1
[13:24:24.139]  length: 2 (resolved future 1)
[13:24:24.139] Future #2
[13:24:24.139]  length: 1 (resolved future 2)
[13:24:24.140]  length: 0 (resolved future 3)
[13:24:24.140] resolve() on environment ... DONE
[13:24:24.141] resolve() on environment ...
[13:24:24.141]  recursive: 0
[13:24:24.141]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:24:24.142] Future #1
[13:24:24.142] result() for MulticoreFuture ...
[13:24:24.147] result() for MulticoreFuture ...
[13:24:24.147] result() for MulticoreFuture ... done
[13:24:24.147] result() for MulticoreFuture ... done
[13:24:24.148] result() for MulticoreFuture ...
[13:24:24.148] result() for MulticoreFuture ... done
[13:24:24.149]  length: 2 (resolved future 1)
[13:24:24.149] Future #2
[13:24:24.149] result() for MulticoreFuture ...
[13:24:24.151] result() for MulticoreFuture ...
[13:24:24.151] result() for MulticoreFuture ... done
[13:24:24.151] result() for MulticoreFuture ... done
[13:24:24.151] result() for MulticoreFuture ...
[13:24:24.151] result() for MulticoreFuture ... done
[13:24:24.152]  length: 1 (resolved future 2)
[13:24:24.152]  length: 0 (resolved future 3)
[13:24:24.152] resolve() on environment ... DONE
[13:24:24.153] resolve() on environment ...
[13:24:24.153]  recursive: 99
[13:24:24.153]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:24:24.153] Future #1
[13:24:24.154] result() for MulticoreFuture ...
[13:24:24.154] result() for MulticoreFuture ... done
[13:24:24.154] result() for MulticoreFuture ...
[13:24:24.154] result() for MulticoreFuture ... done
[13:24:24.154] A MulticoreFuture was resolved
[13:24:24.154]  length: 2 (resolved future 1)
[13:24:24.154] Future #2
[13:24:24.155] result() for MulticoreFuture ...
[13:24:24.155] result() for MulticoreFuture ... done
[13:24:24.155] result() for MulticoreFuture ...
[13:24:24.155] result() for MulticoreFuture ... done
[13:24:24.155] A MulticoreFuture was resolved
[13:24:24.155]  length: 1 (resolved future 2)
[13:24:24.155]  length: 0 (resolved future 3)
[13:24:24.155] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:24:24.156] resolve() on list environment ...
[13:24:24.157]  recursive: 0
[13:24:24.157]  length: 2
[13:24:24.157]  elements: ‘a’, ‘b’
[13:24:24.157]  length: 1 (resolved future 1)
[13:24:24.158]  length: 0 (resolved future 2)
[13:24:24.158] resolve() on list environment ... DONE
[13:24:24.158] getGlobalsAndPackages() ...
[13:24:24.158] Searching for globals...
[13:24:24.158] 
[13:24:24.158] Searching for globals ... DONE
[13:24:24.159] - globals: [0] <none>
[13:24:24.159] getGlobalsAndPackages() ... DONE
[13:24:24.159] run() for ‘Future’ ...
[13:24:24.159] - state: ‘created’
[13:24:24.159] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.163] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.163]   - Field: ‘label’
[13:24:24.164]   - Field: ‘local’
[13:24:24.164]   - Field: ‘owner’
[13:24:24.164]   - Field: ‘envir’
[13:24:24.164]   - Field: ‘workers’
[13:24:24.164]   - Field: ‘packages’
[13:24:24.164]   - Field: ‘gc’
[13:24:24.164]   - Field: ‘job’
[13:24:24.164]   - Field: ‘conditions’
[13:24:24.164]   - Field: ‘expr’
[13:24:24.165]   - Field: ‘uuid’
[13:24:24.165]   - Field: ‘seed’
[13:24:24.165]   - Field: ‘version’
[13:24:24.165]   - Field: ‘result’
[13:24:24.165]   - Field: ‘asynchronous’
[13:24:24.165]   - Field: ‘calls’
[13:24:24.165]   - Field: ‘globals’
[13:24:24.165]   - Field: ‘stdout’
[13:24:24.165]   - Field: ‘earlySignal’
[13:24:24.166]   - Field: ‘lazy’
[13:24:24.166]   - Field: ‘state’
[13:24:24.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.166] - Launch lazy future ...
[13:24:24.166] Packages needed by the future expression (n = 0): <none>
[13:24:24.166] Packages needed by future strategies (n = 0): <none>
[13:24:24.167] {
[13:24:24.167]     {
[13:24:24.167]         {
[13:24:24.167]             ...future.startTime <- base::Sys.time()
[13:24:24.167]             {
[13:24:24.167]                 {
[13:24:24.167]                   {
[13:24:24.167]                     {
[13:24:24.167]                       base::local({
[13:24:24.167]                         has_future <- base::requireNamespace("future", 
[13:24:24.167]                           quietly = TRUE)
[13:24:24.167]                         if (has_future) {
[13:24:24.167]                           ns <- base::getNamespace("future")
[13:24:24.167]                           version <- ns[[".package"]][["version"]]
[13:24:24.167]                           if (is.null(version)) 
[13:24:24.167]                             version <- utils::packageVersion("future")
[13:24:24.167]                         }
[13:24:24.167]                         else {
[13:24:24.167]                           version <- NULL
[13:24:24.167]                         }
[13:24:24.167]                         if (!has_future || version < "1.8.0") {
[13:24:24.167]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.167]                             "", base::R.version$version.string), 
[13:24:24.167]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.167]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.167]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.167]                               "release", "version")], collapse = " "), 
[13:24:24.167]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.167]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.167]                             info)
[13:24:24.167]                           info <- base::paste(info, collapse = "; ")
[13:24:24.167]                           if (!has_future) {
[13:24:24.167]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.167]                               info)
[13:24:24.167]                           }
[13:24:24.167]                           else {
[13:24:24.167]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.167]                               info, version)
[13:24:24.167]                           }
[13:24:24.167]                           base::stop(msg)
[13:24:24.167]                         }
[13:24:24.167]                       })
[13:24:24.167]                     }
[13:24:24.167]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.167]                     base::options(mc.cores = 1L)
[13:24:24.167]                   }
[13:24:24.167]                   options(future.plan = NULL)
[13:24:24.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.167]                 }
[13:24:24.167]                 ...future.workdir <- getwd()
[13:24:24.167]             }
[13:24:24.167]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.167]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.167]         }
[13:24:24.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.167]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.167]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.167]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.167]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.167]             base::names(...future.oldOptions))
[13:24:24.167]     }
[13:24:24.167]     if (FALSE) {
[13:24:24.167]     }
[13:24:24.167]     else {
[13:24:24.167]         if (TRUE) {
[13:24:24.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.167]                 open = "w")
[13:24:24.167]         }
[13:24:24.167]         else {
[13:24:24.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.167]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.167]         }
[13:24:24.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.167]             base::sink(type = "output", split = FALSE)
[13:24:24.167]             base::close(...future.stdout)
[13:24:24.167]         }, add = TRUE)
[13:24:24.167]     }
[13:24:24.167]     ...future.frame <- base::sys.nframe()
[13:24:24.167]     ...future.conditions <- base::list()
[13:24:24.167]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.167]     if (FALSE) {
[13:24:24.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.167]     }
[13:24:24.167]     ...future.result <- base::tryCatch({
[13:24:24.167]         base::withCallingHandlers({
[13:24:24.167]             ...future.value <- base::withVisible(base::local({
[13:24:24.167]                 withCallingHandlers({
[13:24:24.167]                   1
[13:24:24.167]                 }, immediateCondition = function(cond) {
[13:24:24.167]                   save_rds <- function (object, pathname, ...) 
[13:24:24.167]                   {
[13:24:24.167]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.167]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.167]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.167]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.167]                         fi_tmp[["mtime"]])
[13:24:24.167]                     }
[13:24:24.167]                     tryCatch({
[13:24:24.167]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.167]                     }, error = function(ex) {
[13:24:24.167]                       msg <- conditionMessage(ex)
[13:24:24.167]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.167]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.167]                         fi_tmp[["mtime"]], msg)
[13:24:24.167]                       ex$message <- msg
[13:24:24.167]                       stop(ex)
[13:24:24.167]                     })
[13:24:24.167]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.167]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.167]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.167]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.167]                       fi <- file.info(pathname)
[13:24:24.167]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.167]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.167]                         fi[["size"]], fi[["mtime"]])
[13:24:24.167]                       stop(msg)
[13:24:24.167]                     }
[13:24:24.167]                     invisible(pathname)
[13:24:24.167]                   }
[13:24:24.167]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.167]                     rootPath = tempdir()) 
[13:24:24.167]                   {
[13:24:24.167]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.167]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.167]                       tmpdir = path, fileext = ".rds")
[13:24:24.167]                     save_rds(obj, file)
[13:24:24.167]                   }
[13:24:24.167]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.167]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.167]                   {
[13:24:24.167]                     inherits <- base::inherits
[13:24:24.167]                     invokeRestart <- base::invokeRestart
[13:24:24.167]                     is.null <- base::is.null
[13:24:24.167]                     muffled <- FALSE
[13:24:24.167]                     if (inherits(cond, "message")) {
[13:24:24.167]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.167]                       if (muffled) 
[13:24:24.167]                         invokeRestart("muffleMessage")
[13:24:24.167]                     }
[13:24:24.167]                     else if (inherits(cond, "warning")) {
[13:24:24.167]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.167]                       if (muffled) 
[13:24:24.167]                         invokeRestart("muffleWarning")
[13:24:24.167]                     }
[13:24:24.167]                     else if (inherits(cond, "condition")) {
[13:24:24.167]                       if (!is.null(pattern)) {
[13:24:24.167]                         computeRestarts <- base::computeRestarts
[13:24:24.167]                         grepl <- base::grepl
[13:24:24.167]                         restarts <- computeRestarts(cond)
[13:24:24.167]                         for (restart in restarts) {
[13:24:24.167]                           name <- restart$name
[13:24:24.167]                           if (is.null(name)) 
[13:24:24.167]                             next
[13:24:24.167]                           if (!grepl(pattern, name)) 
[13:24:24.167]                             next
[13:24:24.167]                           invokeRestart(restart)
[13:24:24.167]                           muffled <- TRUE
[13:24:24.167]                           break
[13:24:24.167]                         }
[13:24:24.167]                       }
[13:24:24.167]                     }
[13:24:24.167]                     invisible(muffled)
[13:24:24.167]                   }
[13:24:24.167]                   muffleCondition(cond)
[13:24:24.167]                 })
[13:24:24.167]             }))
[13:24:24.167]             future::FutureResult(value = ...future.value$value, 
[13:24:24.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.167]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.167]                     ...future.globalenv.names))
[13:24:24.167]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.167]         }, condition = base::local({
[13:24:24.167]             c <- base::c
[13:24:24.167]             inherits <- base::inherits
[13:24:24.167]             invokeRestart <- base::invokeRestart
[13:24:24.167]             length <- base::length
[13:24:24.167]             list <- base::list
[13:24:24.167]             seq.int <- base::seq.int
[13:24:24.167]             signalCondition <- base::signalCondition
[13:24:24.167]             sys.calls <- base::sys.calls
[13:24:24.167]             `[[` <- base::`[[`
[13:24:24.167]             `+` <- base::`+`
[13:24:24.167]             `<<-` <- base::`<<-`
[13:24:24.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.167]                   3L)]
[13:24:24.167]             }
[13:24:24.167]             function(cond) {
[13:24:24.167]                 is_error <- inherits(cond, "error")
[13:24:24.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.167]                   NULL)
[13:24:24.167]                 if (is_error) {
[13:24:24.167]                   sessionInformation <- function() {
[13:24:24.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.167]                       search = base::search(), system = base::Sys.info())
[13:24:24.167]                   }
[13:24:24.167]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.167]                     cond$call), session = sessionInformation(), 
[13:24:24.167]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.167]                   signalCondition(cond)
[13:24:24.167]                 }
[13:24:24.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.167]                 "immediateCondition"))) {
[13:24:24.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.167]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.167]                   if (TRUE && !signal) {
[13:24:24.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.167]                     {
[13:24:24.167]                       inherits <- base::inherits
[13:24:24.167]                       invokeRestart <- base::invokeRestart
[13:24:24.167]                       is.null <- base::is.null
[13:24:24.167]                       muffled <- FALSE
[13:24:24.167]                       if (inherits(cond, "message")) {
[13:24:24.167]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.167]                         if (muffled) 
[13:24:24.167]                           invokeRestart("muffleMessage")
[13:24:24.167]                       }
[13:24:24.167]                       else if (inherits(cond, "warning")) {
[13:24:24.167]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.167]                         if (muffled) 
[13:24:24.167]                           invokeRestart("muffleWarning")
[13:24:24.167]                       }
[13:24:24.167]                       else if (inherits(cond, "condition")) {
[13:24:24.167]                         if (!is.null(pattern)) {
[13:24:24.167]                           computeRestarts <- base::computeRestarts
[13:24:24.167]                           grepl <- base::grepl
[13:24:24.167]                           restarts <- computeRestarts(cond)
[13:24:24.167]                           for (restart in restarts) {
[13:24:24.167]                             name <- restart$name
[13:24:24.167]                             if (is.null(name)) 
[13:24:24.167]                               next
[13:24:24.167]                             if (!grepl(pattern, name)) 
[13:24:24.167]                               next
[13:24:24.167]                             invokeRestart(restart)
[13:24:24.167]                             muffled <- TRUE
[13:24:24.167]                             break
[13:24:24.167]                           }
[13:24:24.167]                         }
[13:24:24.167]                       }
[13:24:24.167]                       invisible(muffled)
[13:24:24.167]                     }
[13:24:24.167]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.167]                   }
[13:24:24.167]                 }
[13:24:24.167]                 else {
[13:24:24.167]                   if (TRUE) {
[13:24:24.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.167]                     {
[13:24:24.167]                       inherits <- base::inherits
[13:24:24.167]                       invokeRestart <- base::invokeRestart
[13:24:24.167]                       is.null <- base::is.null
[13:24:24.167]                       muffled <- FALSE
[13:24:24.167]                       if (inherits(cond, "message")) {
[13:24:24.167]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.167]                         if (muffled) 
[13:24:24.167]                           invokeRestart("muffleMessage")
[13:24:24.167]                       }
[13:24:24.167]                       else if (inherits(cond, "warning")) {
[13:24:24.167]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.167]                         if (muffled) 
[13:24:24.167]                           invokeRestart("muffleWarning")
[13:24:24.167]                       }
[13:24:24.167]                       else if (inherits(cond, "condition")) {
[13:24:24.167]                         if (!is.null(pattern)) {
[13:24:24.167]                           computeRestarts <- base::computeRestarts
[13:24:24.167]                           grepl <- base::grepl
[13:24:24.167]                           restarts <- computeRestarts(cond)
[13:24:24.167]                           for (restart in restarts) {
[13:24:24.167]                             name <- restart$name
[13:24:24.167]                             if (is.null(name)) 
[13:24:24.167]                               next
[13:24:24.167]                             if (!grepl(pattern, name)) 
[13:24:24.167]                               next
[13:24:24.167]                             invokeRestart(restart)
[13:24:24.167]                             muffled <- TRUE
[13:24:24.167]                             break
[13:24:24.167]                           }
[13:24:24.167]                         }
[13:24:24.167]                       }
[13:24:24.167]                       invisible(muffled)
[13:24:24.167]                     }
[13:24:24.167]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.167]                   }
[13:24:24.167]                 }
[13:24:24.167]             }
[13:24:24.167]         }))
[13:24:24.167]     }, error = function(ex) {
[13:24:24.167]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.167]                 ...future.rng), started = ...future.startTime, 
[13:24:24.167]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.167]             version = "1.8"), class = "FutureResult")
[13:24:24.167]     }, finally = {
[13:24:24.167]         if (!identical(...future.workdir, getwd())) 
[13:24:24.167]             setwd(...future.workdir)
[13:24:24.167]         {
[13:24:24.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.167]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.167]             }
[13:24:24.167]             base::options(...future.oldOptions)
[13:24:24.167]             if (.Platform$OS.type == "windows") {
[13:24:24.167]                 old_names <- names(...future.oldEnvVars)
[13:24:24.167]                 envs <- base::Sys.getenv()
[13:24:24.167]                 names <- names(envs)
[13:24:24.167]                 common <- intersect(names, old_names)
[13:24:24.167]                 added <- setdiff(names, old_names)
[13:24:24.167]                 removed <- setdiff(old_names, names)
[13:24:24.167]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.167]                   envs[common]]
[13:24:24.167]                 NAMES <- toupper(changed)
[13:24:24.167]                 args <- list()
[13:24:24.167]                 for (kk in seq_along(NAMES)) {
[13:24:24.167]                   name <- changed[[kk]]
[13:24:24.167]                   NAME <- NAMES[[kk]]
[13:24:24.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.167]                     next
[13:24:24.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.167]                 }
[13:24:24.167]                 NAMES <- toupper(added)
[13:24:24.167]                 for (kk in seq_along(NAMES)) {
[13:24:24.167]                   name <- added[[kk]]
[13:24:24.167]                   NAME <- NAMES[[kk]]
[13:24:24.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.167]                     next
[13:24:24.167]                   args[[name]] <- ""
[13:24:24.167]                 }
[13:24:24.167]                 NAMES <- toupper(removed)
[13:24:24.167]                 for (kk in seq_along(NAMES)) {
[13:24:24.167]                   name <- removed[[kk]]
[13:24:24.167]                   NAME <- NAMES[[kk]]
[13:24:24.167]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.167]                     next
[13:24:24.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.167]                 }
[13:24:24.167]                 if (length(args) > 0) 
[13:24:24.167]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.167]             }
[13:24:24.167]             else {
[13:24:24.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.167]             }
[13:24:24.167]             {
[13:24:24.167]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.167]                   0L) {
[13:24:24.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.167]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.167]                   base::options(opts)
[13:24:24.167]                 }
[13:24:24.167]                 {
[13:24:24.167]                   {
[13:24:24.167]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.167]                     NULL
[13:24:24.167]                   }
[13:24:24.167]                   options(future.plan = NULL)
[13:24:24.167]                   if (is.na(NA_character_)) 
[13:24:24.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.167]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.167]                     envir = parent.frame()) 
[13:24:24.167]                   {
[13:24:24.167]                     default_workers <- missing(workers)
[13:24:24.167]                     if (is.function(workers)) 
[13:24:24.167]                       workers <- workers()
[13:24:24.167]                     workers <- structure(as.integer(workers), 
[13:24:24.167]                       class = class(workers))
[13:24:24.167]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.167]                       1L)
[13:24:24.167]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.167]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.167]                       if (default_workers) 
[13:24:24.167]                         supportsMulticore(warn = TRUE)
[13:24:24.167]                       return(sequential(..., envir = envir))
[13:24:24.167]                     }
[13:24:24.167]                     oopts <- options(mc.cores = workers)
[13:24:24.167]                     on.exit(options(oopts))
[13:24:24.167]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.167]                       envir = envir)
[13:24:24.167]                     if (!future$lazy) 
[13:24:24.167]                       future <- run(future)
[13:24:24.167]                     invisible(future)
[13:24:24.167]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.167]                 }
[13:24:24.167]             }
[13:24:24.167]         }
[13:24:24.167]     })
[13:24:24.167]     if (TRUE) {
[13:24:24.167]         base::sink(type = "output", split = FALSE)
[13:24:24.167]         if (TRUE) {
[13:24:24.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.167]         }
[13:24:24.167]         else {
[13:24:24.167]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.167]         }
[13:24:24.167]         base::close(...future.stdout)
[13:24:24.167]         ...future.stdout <- NULL
[13:24:24.167]     }
[13:24:24.167]     ...future.result$conditions <- ...future.conditions
[13:24:24.167]     ...future.result$finished <- base::Sys.time()
[13:24:24.167]     ...future.result
[13:24:24.167] }
[13:24:24.169] requestCore(): workers = 2
[13:24:24.171] MulticoreFuture started
[13:24:24.171] - Launch lazy future ... done
[13:24:24.172] run() for ‘MulticoreFuture’ ... done
[13:24:24.172] getGlobalsAndPackages() ...
[13:24:24.172] Searching for globals...
[13:24:24.172] plan(): Setting new future strategy stack:
[13:24:24.173] List of future strategies:
[13:24:24.173] 1. sequential:
[13:24:24.173]    - args: function (..., envir = parent.frame())
[13:24:24.173]    - tweaked: FALSE
[13:24:24.173]    - call: NULL
[13:24:24.173] 
[13:24:24.173] Searching for globals ... DONE
[13:24:24.173] plan(): nbrOfWorkers() = 1
[13:24:24.173] - globals: [0] <none>
[13:24:24.174] getGlobalsAndPackages() ... DONE
[13:24:24.174] run() for ‘Future’ ...
[13:24:24.174] - state: ‘created’
[13:24:24.174] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.175] plan(): Setting new future strategy stack:
[13:24:24.175] List of future strategies:
[13:24:24.175] 1. multicore:
[13:24:24.175]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.175]    - tweaked: FALSE
[13:24:24.175]    - call: plan(strategy)
[13:24:24.180] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.180] plan(): nbrOfWorkers() = 2
[13:24:24.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.181]   - Field: ‘label’
[13:24:24.181]   - Field: ‘local’
[13:24:24.181]   - Field: ‘owner’
[13:24:24.181]   - Field: ‘envir’
[13:24:24.181]   - Field: ‘workers’
[13:24:24.181]   - Field: ‘packages’
[13:24:24.182]   - Field: ‘gc’
[13:24:24.182]   - Field: ‘job’
[13:24:24.182]   - Field: ‘conditions’
[13:24:24.182]   - Field: ‘expr’
[13:24:24.182]   - Field: ‘uuid’
[13:24:24.182]   - Field: ‘seed’
[13:24:24.182]   - Field: ‘version’
[13:24:24.183]   - Field: ‘result’
[13:24:24.183]   - Field: ‘asynchronous’
[13:24:24.183]   - Field: ‘calls’
[13:24:24.183]   - Field: ‘globals’
[13:24:24.183]   - Field: ‘stdout’
[13:24:24.183]   - Field: ‘earlySignal’
[13:24:24.183]   - Field: ‘lazy’
[13:24:24.184]   - Field: ‘state’
[13:24:24.184] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.184] - Launch lazy future ...
[13:24:24.184] Packages needed by the future expression (n = 0): <none>
[13:24:24.185] Packages needed by future strategies (n = 0): <none>
[13:24:24.185] {
[13:24:24.185]     {
[13:24:24.185]         {
[13:24:24.185]             ...future.startTime <- base::Sys.time()
[13:24:24.185]             {
[13:24:24.185]                 {
[13:24:24.185]                   {
[13:24:24.185]                     {
[13:24:24.185]                       base::local({
[13:24:24.185]                         has_future <- base::requireNamespace("future", 
[13:24:24.185]                           quietly = TRUE)
[13:24:24.185]                         if (has_future) {
[13:24:24.185]                           ns <- base::getNamespace("future")
[13:24:24.185]                           version <- ns[[".package"]][["version"]]
[13:24:24.185]                           if (is.null(version)) 
[13:24:24.185]                             version <- utils::packageVersion("future")
[13:24:24.185]                         }
[13:24:24.185]                         else {
[13:24:24.185]                           version <- NULL
[13:24:24.185]                         }
[13:24:24.185]                         if (!has_future || version < "1.8.0") {
[13:24:24.185]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.185]                             "", base::R.version$version.string), 
[13:24:24.185]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.185]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.185]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.185]                               "release", "version")], collapse = " "), 
[13:24:24.185]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.185]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.185]                             info)
[13:24:24.185]                           info <- base::paste(info, collapse = "; ")
[13:24:24.185]                           if (!has_future) {
[13:24:24.185]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.185]                               info)
[13:24:24.185]                           }
[13:24:24.185]                           else {
[13:24:24.185]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.185]                               info, version)
[13:24:24.185]                           }
[13:24:24.185]                           base::stop(msg)
[13:24:24.185]                         }
[13:24:24.185]                       })
[13:24:24.185]                     }
[13:24:24.185]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.185]                     base::options(mc.cores = 1L)
[13:24:24.185]                   }
[13:24:24.185]                   options(future.plan = NULL)
[13:24:24.185]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.185]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.185]                 }
[13:24:24.185]                 ...future.workdir <- getwd()
[13:24:24.185]             }
[13:24:24.185]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.185]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.185]         }
[13:24:24.185]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.185]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.185]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.185]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.185]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.185]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.185]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.185]             base::names(...future.oldOptions))
[13:24:24.185]     }
[13:24:24.185]     if (FALSE) {
[13:24:24.185]     }
[13:24:24.185]     else {
[13:24:24.185]         if (TRUE) {
[13:24:24.185]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.185]                 open = "w")
[13:24:24.185]         }
[13:24:24.185]         else {
[13:24:24.185]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.185]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.185]         }
[13:24:24.185]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.185]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.185]             base::sink(type = "output", split = FALSE)
[13:24:24.185]             base::close(...future.stdout)
[13:24:24.185]         }, add = TRUE)
[13:24:24.185]     }
[13:24:24.185]     ...future.frame <- base::sys.nframe()
[13:24:24.185]     ...future.conditions <- base::list()
[13:24:24.185]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.185]     if (FALSE) {
[13:24:24.185]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.185]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.185]     }
[13:24:24.185]     ...future.result <- base::tryCatch({
[13:24:24.185]         base::withCallingHandlers({
[13:24:24.185]             ...future.value <- base::withVisible(base::local({
[13:24:24.185]                 withCallingHandlers({
[13:24:24.185]                   2
[13:24:24.185]                 }, immediateCondition = function(cond) {
[13:24:24.185]                   save_rds <- function (object, pathname, ...) 
[13:24:24.185]                   {
[13:24:24.185]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.185]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.185]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.185]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.185]                         fi_tmp[["mtime"]])
[13:24:24.185]                     }
[13:24:24.185]                     tryCatch({
[13:24:24.185]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.185]                     }, error = function(ex) {
[13:24:24.185]                       msg <- conditionMessage(ex)
[13:24:24.185]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.185]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.185]                         fi_tmp[["mtime"]], msg)
[13:24:24.185]                       ex$message <- msg
[13:24:24.185]                       stop(ex)
[13:24:24.185]                     })
[13:24:24.185]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.185]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.185]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.185]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.185]                       fi <- file.info(pathname)
[13:24:24.185]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.185]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.185]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.185]                         fi[["size"]], fi[["mtime"]])
[13:24:24.185]                       stop(msg)
[13:24:24.185]                     }
[13:24:24.185]                     invisible(pathname)
[13:24:24.185]                   }
[13:24:24.185]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.185]                     rootPath = tempdir()) 
[13:24:24.185]                   {
[13:24:24.185]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.185]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.185]                       tmpdir = path, fileext = ".rds")
[13:24:24.185]                     save_rds(obj, file)
[13:24:24.185]                   }
[13:24:24.185]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.185]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.185]                   {
[13:24:24.185]                     inherits <- base::inherits
[13:24:24.185]                     invokeRestart <- base::invokeRestart
[13:24:24.185]                     is.null <- base::is.null
[13:24:24.185]                     muffled <- FALSE
[13:24:24.185]                     if (inherits(cond, "message")) {
[13:24:24.185]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.185]                       if (muffled) 
[13:24:24.185]                         invokeRestart("muffleMessage")
[13:24:24.185]                     }
[13:24:24.185]                     else if (inherits(cond, "warning")) {
[13:24:24.185]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.185]                       if (muffled) 
[13:24:24.185]                         invokeRestart("muffleWarning")
[13:24:24.185]                     }
[13:24:24.185]                     else if (inherits(cond, "condition")) {
[13:24:24.185]                       if (!is.null(pattern)) {
[13:24:24.185]                         computeRestarts <- base::computeRestarts
[13:24:24.185]                         grepl <- base::grepl
[13:24:24.185]                         restarts <- computeRestarts(cond)
[13:24:24.185]                         for (restart in restarts) {
[13:24:24.185]                           name <- restart$name
[13:24:24.185]                           if (is.null(name)) 
[13:24:24.185]                             next
[13:24:24.185]                           if (!grepl(pattern, name)) 
[13:24:24.185]                             next
[13:24:24.185]                           invokeRestart(restart)
[13:24:24.185]                           muffled <- TRUE
[13:24:24.185]                           break
[13:24:24.185]                         }
[13:24:24.185]                       }
[13:24:24.185]                     }
[13:24:24.185]                     invisible(muffled)
[13:24:24.185]                   }
[13:24:24.185]                   muffleCondition(cond)
[13:24:24.185]                 })
[13:24:24.185]             }))
[13:24:24.185]             future::FutureResult(value = ...future.value$value, 
[13:24:24.185]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.185]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.185]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.185]                     ...future.globalenv.names))
[13:24:24.185]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.185]         }, condition = base::local({
[13:24:24.185]             c <- base::c
[13:24:24.185]             inherits <- base::inherits
[13:24:24.185]             invokeRestart <- base::invokeRestart
[13:24:24.185]             length <- base::length
[13:24:24.185]             list <- base::list
[13:24:24.185]             seq.int <- base::seq.int
[13:24:24.185]             signalCondition <- base::signalCondition
[13:24:24.185]             sys.calls <- base::sys.calls
[13:24:24.185]             `[[` <- base::`[[`
[13:24:24.185]             `+` <- base::`+`
[13:24:24.185]             `<<-` <- base::`<<-`
[13:24:24.185]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.185]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.185]                   3L)]
[13:24:24.185]             }
[13:24:24.185]             function(cond) {
[13:24:24.185]                 is_error <- inherits(cond, "error")
[13:24:24.185]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.185]                   NULL)
[13:24:24.185]                 if (is_error) {
[13:24:24.185]                   sessionInformation <- function() {
[13:24:24.185]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.185]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.185]                       search = base::search(), system = base::Sys.info())
[13:24:24.185]                   }
[13:24:24.185]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.185]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.185]                     cond$call), session = sessionInformation(), 
[13:24:24.185]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.185]                   signalCondition(cond)
[13:24:24.185]                 }
[13:24:24.185]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.185]                 "immediateCondition"))) {
[13:24:24.185]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.185]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.185]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.185]                   if (TRUE && !signal) {
[13:24:24.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.185]                     {
[13:24:24.185]                       inherits <- base::inherits
[13:24:24.185]                       invokeRestart <- base::invokeRestart
[13:24:24.185]                       is.null <- base::is.null
[13:24:24.185]                       muffled <- FALSE
[13:24:24.185]                       if (inherits(cond, "message")) {
[13:24:24.185]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.185]                         if (muffled) 
[13:24:24.185]                           invokeRestart("muffleMessage")
[13:24:24.185]                       }
[13:24:24.185]                       else if (inherits(cond, "warning")) {
[13:24:24.185]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.185]                         if (muffled) 
[13:24:24.185]                           invokeRestart("muffleWarning")
[13:24:24.185]                       }
[13:24:24.185]                       else if (inherits(cond, "condition")) {
[13:24:24.185]                         if (!is.null(pattern)) {
[13:24:24.185]                           computeRestarts <- base::computeRestarts
[13:24:24.185]                           grepl <- base::grepl
[13:24:24.185]                           restarts <- computeRestarts(cond)
[13:24:24.185]                           for (restart in restarts) {
[13:24:24.185]                             name <- restart$name
[13:24:24.185]                             if (is.null(name)) 
[13:24:24.185]                               next
[13:24:24.185]                             if (!grepl(pattern, name)) 
[13:24:24.185]                               next
[13:24:24.185]                             invokeRestart(restart)
[13:24:24.185]                             muffled <- TRUE
[13:24:24.185]                             break
[13:24:24.185]                           }
[13:24:24.185]                         }
[13:24:24.185]                       }
[13:24:24.185]                       invisible(muffled)
[13:24:24.185]                     }
[13:24:24.185]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.185]                   }
[13:24:24.185]                 }
[13:24:24.185]                 else {
[13:24:24.185]                   if (TRUE) {
[13:24:24.185]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.185]                     {
[13:24:24.185]                       inherits <- base::inherits
[13:24:24.185]                       invokeRestart <- base::invokeRestart
[13:24:24.185]                       is.null <- base::is.null
[13:24:24.185]                       muffled <- FALSE
[13:24:24.185]                       if (inherits(cond, "message")) {
[13:24:24.185]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.185]                         if (muffled) 
[13:24:24.185]                           invokeRestart("muffleMessage")
[13:24:24.185]                       }
[13:24:24.185]                       else if (inherits(cond, "warning")) {
[13:24:24.185]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.185]                         if (muffled) 
[13:24:24.185]                           invokeRestart("muffleWarning")
[13:24:24.185]                       }
[13:24:24.185]                       else if (inherits(cond, "condition")) {
[13:24:24.185]                         if (!is.null(pattern)) {
[13:24:24.185]                           computeRestarts <- base::computeRestarts
[13:24:24.185]                           grepl <- base::grepl
[13:24:24.185]                           restarts <- computeRestarts(cond)
[13:24:24.185]                           for (restart in restarts) {
[13:24:24.185]                             name <- restart$name
[13:24:24.185]                             if (is.null(name)) 
[13:24:24.185]                               next
[13:24:24.185]                             if (!grepl(pattern, name)) 
[13:24:24.185]                               next
[13:24:24.185]                             invokeRestart(restart)
[13:24:24.185]                             muffled <- TRUE
[13:24:24.185]                             break
[13:24:24.185]                           }
[13:24:24.185]                         }
[13:24:24.185]                       }
[13:24:24.185]                       invisible(muffled)
[13:24:24.185]                     }
[13:24:24.185]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.185]                   }
[13:24:24.185]                 }
[13:24:24.185]             }
[13:24:24.185]         }))
[13:24:24.185]     }, error = function(ex) {
[13:24:24.185]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.185]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.185]                 ...future.rng), started = ...future.startTime, 
[13:24:24.185]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.185]             version = "1.8"), class = "FutureResult")
[13:24:24.185]     }, finally = {
[13:24:24.185]         if (!identical(...future.workdir, getwd())) 
[13:24:24.185]             setwd(...future.workdir)
[13:24:24.185]         {
[13:24:24.185]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.185]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.185]             }
[13:24:24.185]             base::options(...future.oldOptions)
[13:24:24.185]             if (.Platform$OS.type == "windows") {
[13:24:24.185]                 old_names <- names(...future.oldEnvVars)
[13:24:24.185]                 envs <- base::Sys.getenv()
[13:24:24.185]                 names <- names(envs)
[13:24:24.185]                 common <- intersect(names, old_names)
[13:24:24.185]                 added <- setdiff(names, old_names)
[13:24:24.185]                 removed <- setdiff(old_names, names)
[13:24:24.185]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.185]                   envs[common]]
[13:24:24.185]                 NAMES <- toupper(changed)
[13:24:24.185]                 args <- list()
[13:24:24.185]                 for (kk in seq_along(NAMES)) {
[13:24:24.185]                   name <- changed[[kk]]
[13:24:24.185]                   NAME <- NAMES[[kk]]
[13:24:24.185]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.185]                     next
[13:24:24.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.185]                 }
[13:24:24.185]                 NAMES <- toupper(added)
[13:24:24.185]                 for (kk in seq_along(NAMES)) {
[13:24:24.185]                   name <- added[[kk]]
[13:24:24.185]                   NAME <- NAMES[[kk]]
[13:24:24.185]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.185]                     next
[13:24:24.185]                   args[[name]] <- ""
[13:24:24.185]                 }
[13:24:24.185]                 NAMES <- toupper(removed)
[13:24:24.185]                 for (kk in seq_along(NAMES)) {
[13:24:24.185]                   name <- removed[[kk]]
[13:24:24.185]                   NAME <- NAMES[[kk]]
[13:24:24.185]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.185]                     next
[13:24:24.185]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.185]                 }
[13:24:24.185]                 if (length(args) > 0) 
[13:24:24.185]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.185]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.185]             }
[13:24:24.185]             else {
[13:24:24.185]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.185]             }
[13:24:24.185]             {
[13:24:24.185]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.185]                   0L) {
[13:24:24.185]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.185]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.185]                   base::options(opts)
[13:24:24.185]                 }
[13:24:24.185]                 {
[13:24:24.185]                   {
[13:24:24.185]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.185]                     NULL
[13:24:24.185]                   }
[13:24:24.185]                   options(future.plan = NULL)
[13:24:24.185]                   if (is.na(NA_character_)) 
[13:24:24.185]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.185]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.185]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.185]                     envir = parent.frame()) 
[13:24:24.185]                   {
[13:24:24.185]                     default_workers <- missing(workers)
[13:24:24.185]                     if (is.function(workers)) 
[13:24:24.185]                       workers <- workers()
[13:24:24.185]                     workers <- structure(as.integer(workers), 
[13:24:24.185]                       class = class(workers))
[13:24:24.185]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.185]                       1L)
[13:24:24.185]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.185]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.185]                       if (default_workers) 
[13:24:24.185]                         supportsMulticore(warn = TRUE)
[13:24:24.185]                       return(sequential(..., envir = envir))
[13:24:24.185]                     }
[13:24:24.185]                     oopts <- options(mc.cores = workers)
[13:24:24.185]                     on.exit(options(oopts))
[13:24:24.185]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.185]                       envir = envir)
[13:24:24.185]                     if (!future$lazy) 
[13:24:24.185]                       future <- run(future)
[13:24:24.185]                     invisible(future)
[13:24:24.185]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.185]                 }
[13:24:24.185]             }
[13:24:24.185]         }
[13:24:24.185]     })
[13:24:24.185]     if (TRUE) {
[13:24:24.185]         base::sink(type = "output", split = FALSE)
[13:24:24.185]         if (TRUE) {
[13:24:24.185]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.185]         }
[13:24:24.185]         else {
[13:24:24.185]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.185]         }
[13:24:24.185]         base::close(...future.stdout)
[13:24:24.185]         ...future.stdout <- NULL
[13:24:24.185]     }
[13:24:24.185]     ...future.result$conditions <- ...future.conditions
[13:24:24.185]     ...future.result$finished <- base::Sys.time()
[13:24:24.185]     ...future.result
[13:24:24.185] }
[13:24:24.189] requestCore(): workers = 2
[13:24:24.191] MulticoreFuture started
[13:24:24.192] - Launch lazy future ... done
[13:24:24.192] run() for ‘MulticoreFuture’ ... done
[13:24:24.193] plan(): Setting new future strategy stack:
[13:24:24.193] resolve() on list environment ...
[13:24:24.193] List of future strategies:
[13:24:24.193] 1. sequential:
[13:24:24.193]    - args: function (..., envir = parent.frame())
[13:24:24.193]    - tweaked: FALSE
[13:24:24.193]    - call: NULL
[13:24:24.194]  recursive: 0
[13:24:24.194] plan(): nbrOfWorkers() = 1
[13:24:24.195]  length: 3
[13:24:24.195]  elements: ‘a’, ‘b’, ‘c’
[13:24:24.195] Future #1
[13:24:24.195]  length: 2 (resolved future 1)
[13:24:24.196] plan(): Setting new future strategy stack:
[13:24:24.196] List of future strategies:
[13:24:24.196] 1. multicore:
[13:24:24.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.196]    - tweaked: FALSE
[13:24:24.196]    - call: plan(strategy)
[13:24:24.206] plan(): nbrOfWorkers() = 2
[13:24:24.206]  length: 1 (resolved future 3)
[13:24:24.217] Future #2
[13:24:24.220]  length: 0 (resolved future 2)
[13:24:24.221] resolve() on list environment ... DONE
[13:24:24.223] getGlobalsAndPackages() ...
[13:24:24.223] Searching for globals...
[13:24:24.225] - globals found: [1] ‘{’
[13:24:24.226] Searching for globals ... DONE
[13:24:24.226] Resolving globals: FALSE
[13:24:24.226] 
[13:24:24.227] 
[13:24:24.227] getGlobalsAndPackages() ... DONE
[13:24:24.227] run() for ‘Future’ ...
[13:24:24.228] - state: ‘created’
[13:24:24.228] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.233] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.233] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.233]   - Field: ‘label’
[13:24:24.234]   - Field: ‘local’
[13:24:24.234]   - Field: ‘owner’
[13:24:24.234]   - Field: ‘envir’
[13:24:24.234]   - Field: ‘workers’
[13:24:24.234]   - Field: ‘packages’
[13:24:24.234]   - Field: ‘gc’
[13:24:24.235]   - Field: ‘job’
[13:24:24.235]   - Field: ‘conditions’
[13:24:24.235]   - Field: ‘expr’
[13:24:24.235]   - Field: ‘uuid’
[13:24:24.235]   - Field: ‘seed’
[13:24:24.235]   - Field: ‘version’
[13:24:24.235]   - Field: ‘result’
[13:24:24.236]   - Field: ‘asynchronous’
[13:24:24.236]   - Field: ‘calls’
[13:24:24.236]   - Field: ‘globals’
[13:24:24.236]   - Field: ‘stdout’
[13:24:24.236]   - Field: ‘earlySignal’
[13:24:24.236]   - Field: ‘lazy’
[13:24:24.236]   - Field: ‘state’
[13:24:24.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.237] - Launch lazy future ...
[13:24:24.237] Packages needed by the future expression (n = 0): <none>
[13:24:24.237] Packages needed by future strategies (n = 0): <none>
[13:24:24.238] {
[13:24:24.238]     {
[13:24:24.238]         {
[13:24:24.238]             ...future.startTime <- base::Sys.time()
[13:24:24.238]             {
[13:24:24.238]                 {
[13:24:24.238]                   {
[13:24:24.238]                     {
[13:24:24.238]                       base::local({
[13:24:24.238]                         has_future <- base::requireNamespace("future", 
[13:24:24.238]                           quietly = TRUE)
[13:24:24.238]                         if (has_future) {
[13:24:24.238]                           ns <- base::getNamespace("future")
[13:24:24.238]                           version <- ns[[".package"]][["version"]]
[13:24:24.238]                           if (is.null(version)) 
[13:24:24.238]                             version <- utils::packageVersion("future")
[13:24:24.238]                         }
[13:24:24.238]                         else {
[13:24:24.238]                           version <- NULL
[13:24:24.238]                         }
[13:24:24.238]                         if (!has_future || version < "1.8.0") {
[13:24:24.238]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.238]                             "", base::R.version$version.string), 
[13:24:24.238]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.238]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.238]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.238]                               "release", "version")], collapse = " "), 
[13:24:24.238]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.238]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.238]                             info)
[13:24:24.238]                           info <- base::paste(info, collapse = "; ")
[13:24:24.238]                           if (!has_future) {
[13:24:24.238]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.238]                               info)
[13:24:24.238]                           }
[13:24:24.238]                           else {
[13:24:24.238]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.238]                               info, version)
[13:24:24.238]                           }
[13:24:24.238]                           base::stop(msg)
[13:24:24.238]                         }
[13:24:24.238]                       })
[13:24:24.238]                     }
[13:24:24.238]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.238]                     base::options(mc.cores = 1L)
[13:24:24.238]                   }
[13:24:24.238]                   options(future.plan = NULL)
[13:24:24.238]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.238]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.238]                 }
[13:24:24.238]                 ...future.workdir <- getwd()
[13:24:24.238]             }
[13:24:24.238]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.238]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.238]         }
[13:24:24.238]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.238]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.238]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.238]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.238]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.238]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.238]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.238]             base::names(...future.oldOptions))
[13:24:24.238]     }
[13:24:24.238]     if (FALSE) {
[13:24:24.238]     }
[13:24:24.238]     else {
[13:24:24.238]         if (TRUE) {
[13:24:24.238]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.238]                 open = "w")
[13:24:24.238]         }
[13:24:24.238]         else {
[13:24:24.238]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.238]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.238]         }
[13:24:24.238]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.238]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.238]             base::sink(type = "output", split = FALSE)
[13:24:24.238]             base::close(...future.stdout)
[13:24:24.238]         }, add = TRUE)
[13:24:24.238]     }
[13:24:24.238]     ...future.frame <- base::sys.nframe()
[13:24:24.238]     ...future.conditions <- base::list()
[13:24:24.238]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.238]     if (FALSE) {
[13:24:24.238]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.238]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.238]     }
[13:24:24.238]     ...future.result <- base::tryCatch({
[13:24:24.238]         base::withCallingHandlers({
[13:24:24.238]             ...future.value <- base::withVisible(base::local({
[13:24:24.238]                 withCallingHandlers({
[13:24:24.238]                   {
[13:24:24.238]                     1
[13:24:24.238]                   }
[13:24:24.238]                 }, immediateCondition = function(cond) {
[13:24:24.238]                   save_rds <- function (object, pathname, ...) 
[13:24:24.238]                   {
[13:24:24.238]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.238]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.238]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.238]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.238]                         fi_tmp[["mtime"]])
[13:24:24.238]                     }
[13:24:24.238]                     tryCatch({
[13:24:24.238]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.238]                     }, error = function(ex) {
[13:24:24.238]                       msg <- conditionMessage(ex)
[13:24:24.238]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.238]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.238]                         fi_tmp[["mtime"]], msg)
[13:24:24.238]                       ex$message <- msg
[13:24:24.238]                       stop(ex)
[13:24:24.238]                     })
[13:24:24.238]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.238]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.238]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.238]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.238]                       fi <- file.info(pathname)
[13:24:24.238]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.238]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.238]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.238]                         fi[["size"]], fi[["mtime"]])
[13:24:24.238]                       stop(msg)
[13:24:24.238]                     }
[13:24:24.238]                     invisible(pathname)
[13:24:24.238]                   }
[13:24:24.238]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.238]                     rootPath = tempdir()) 
[13:24:24.238]                   {
[13:24:24.238]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.238]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.238]                       tmpdir = path, fileext = ".rds")
[13:24:24.238]                     save_rds(obj, file)
[13:24:24.238]                   }
[13:24:24.238]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.238]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.238]                   {
[13:24:24.238]                     inherits <- base::inherits
[13:24:24.238]                     invokeRestart <- base::invokeRestart
[13:24:24.238]                     is.null <- base::is.null
[13:24:24.238]                     muffled <- FALSE
[13:24:24.238]                     if (inherits(cond, "message")) {
[13:24:24.238]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.238]                       if (muffled) 
[13:24:24.238]                         invokeRestart("muffleMessage")
[13:24:24.238]                     }
[13:24:24.238]                     else if (inherits(cond, "warning")) {
[13:24:24.238]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.238]                       if (muffled) 
[13:24:24.238]                         invokeRestart("muffleWarning")
[13:24:24.238]                     }
[13:24:24.238]                     else if (inherits(cond, "condition")) {
[13:24:24.238]                       if (!is.null(pattern)) {
[13:24:24.238]                         computeRestarts <- base::computeRestarts
[13:24:24.238]                         grepl <- base::grepl
[13:24:24.238]                         restarts <- computeRestarts(cond)
[13:24:24.238]                         for (restart in restarts) {
[13:24:24.238]                           name <- restart$name
[13:24:24.238]                           if (is.null(name)) 
[13:24:24.238]                             next
[13:24:24.238]                           if (!grepl(pattern, name)) 
[13:24:24.238]                             next
[13:24:24.238]                           invokeRestart(restart)
[13:24:24.238]                           muffled <- TRUE
[13:24:24.238]                           break
[13:24:24.238]                         }
[13:24:24.238]                       }
[13:24:24.238]                     }
[13:24:24.238]                     invisible(muffled)
[13:24:24.238]                   }
[13:24:24.238]                   muffleCondition(cond)
[13:24:24.238]                 })
[13:24:24.238]             }))
[13:24:24.238]             future::FutureResult(value = ...future.value$value, 
[13:24:24.238]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.238]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.238]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.238]                     ...future.globalenv.names))
[13:24:24.238]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.238]         }, condition = base::local({
[13:24:24.238]             c <- base::c
[13:24:24.238]             inherits <- base::inherits
[13:24:24.238]             invokeRestart <- base::invokeRestart
[13:24:24.238]             length <- base::length
[13:24:24.238]             list <- base::list
[13:24:24.238]             seq.int <- base::seq.int
[13:24:24.238]             signalCondition <- base::signalCondition
[13:24:24.238]             sys.calls <- base::sys.calls
[13:24:24.238]             `[[` <- base::`[[`
[13:24:24.238]             `+` <- base::`+`
[13:24:24.238]             `<<-` <- base::`<<-`
[13:24:24.238]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.238]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.238]                   3L)]
[13:24:24.238]             }
[13:24:24.238]             function(cond) {
[13:24:24.238]                 is_error <- inherits(cond, "error")
[13:24:24.238]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.238]                   NULL)
[13:24:24.238]                 if (is_error) {
[13:24:24.238]                   sessionInformation <- function() {
[13:24:24.238]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.238]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.238]                       search = base::search(), system = base::Sys.info())
[13:24:24.238]                   }
[13:24:24.238]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.238]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.238]                     cond$call), session = sessionInformation(), 
[13:24:24.238]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.238]                   signalCondition(cond)
[13:24:24.238]                 }
[13:24:24.238]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.238]                 "immediateCondition"))) {
[13:24:24.238]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.238]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.238]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.238]                   if (TRUE && !signal) {
[13:24:24.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.238]                     {
[13:24:24.238]                       inherits <- base::inherits
[13:24:24.238]                       invokeRestart <- base::invokeRestart
[13:24:24.238]                       is.null <- base::is.null
[13:24:24.238]                       muffled <- FALSE
[13:24:24.238]                       if (inherits(cond, "message")) {
[13:24:24.238]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.238]                         if (muffled) 
[13:24:24.238]                           invokeRestart("muffleMessage")
[13:24:24.238]                       }
[13:24:24.238]                       else if (inherits(cond, "warning")) {
[13:24:24.238]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.238]                         if (muffled) 
[13:24:24.238]                           invokeRestart("muffleWarning")
[13:24:24.238]                       }
[13:24:24.238]                       else if (inherits(cond, "condition")) {
[13:24:24.238]                         if (!is.null(pattern)) {
[13:24:24.238]                           computeRestarts <- base::computeRestarts
[13:24:24.238]                           grepl <- base::grepl
[13:24:24.238]                           restarts <- computeRestarts(cond)
[13:24:24.238]                           for (restart in restarts) {
[13:24:24.238]                             name <- restart$name
[13:24:24.238]                             if (is.null(name)) 
[13:24:24.238]                               next
[13:24:24.238]                             if (!grepl(pattern, name)) 
[13:24:24.238]                               next
[13:24:24.238]                             invokeRestart(restart)
[13:24:24.238]                             muffled <- TRUE
[13:24:24.238]                             break
[13:24:24.238]                           }
[13:24:24.238]                         }
[13:24:24.238]                       }
[13:24:24.238]                       invisible(muffled)
[13:24:24.238]                     }
[13:24:24.238]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.238]                   }
[13:24:24.238]                 }
[13:24:24.238]                 else {
[13:24:24.238]                   if (TRUE) {
[13:24:24.238]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.238]                     {
[13:24:24.238]                       inherits <- base::inherits
[13:24:24.238]                       invokeRestart <- base::invokeRestart
[13:24:24.238]                       is.null <- base::is.null
[13:24:24.238]                       muffled <- FALSE
[13:24:24.238]                       if (inherits(cond, "message")) {
[13:24:24.238]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.238]                         if (muffled) 
[13:24:24.238]                           invokeRestart("muffleMessage")
[13:24:24.238]                       }
[13:24:24.238]                       else if (inherits(cond, "warning")) {
[13:24:24.238]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.238]                         if (muffled) 
[13:24:24.238]                           invokeRestart("muffleWarning")
[13:24:24.238]                       }
[13:24:24.238]                       else if (inherits(cond, "condition")) {
[13:24:24.238]                         if (!is.null(pattern)) {
[13:24:24.238]                           computeRestarts <- base::computeRestarts
[13:24:24.238]                           grepl <- base::grepl
[13:24:24.238]                           restarts <- computeRestarts(cond)
[13:24:24.238]                           for (restart in restarts) {
[13:24:24.238]                             name <- restart$name
[13:24:24.238]                             if (is.null(name)) 
[13:24:24.238]                               next
[13:24:24.238]                             if (!grepl(pattern, name)) 
[13:24:24.238]                               next
[13:24:24.238]                             invokeRestart(restart)
[13:24:24.238]                             muffled <- TRUE
[13:24:24.238]                             break
[13:24:24.238]                           }
[13:24:24.238]                         }
[13:24:24.238]                       }
[13:24:24.238]                       invisible(muffled)
[13:24:24.238]                     }
[13:24:24.238]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.238]                   }
[13:24:24.238]                 }
[13:24:24.238]             }
[13:24:24.238]         }))
[13:24:24.238]     }, error = function(ex) {
[13:24:24.238]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.238]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.238]                 ...future.rng), started = ...future.startTime, 
[13:24:24.238]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.238]             version = "1.8"), class = "FutureResult")
[13:24:24.238]     }, finally = {
[13:24:24.238]         if (!identical(...future.workdir, getwd())) 
[13:24:24.238]             setwd(...future.workdir)
[13:24:24.238]         {
[13:24:24.238]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.238]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.238]             }
[13:24:24.238]             base::options(...future.oldOptions)
[13:24:24.238]             if (.Platform$OS.type == "windows") {
[13:24:24.238]                 old_names <- names(...future.oldEnvVars)
[13:24:24.238]                 envs <- base::Sys.getenv()
[13:24:24.238]                 names <- names(envs)
[13:24:24.238]                 common <- intersect(names, old_names)
[13:24:24.238]                 added <- setdiff(names, old_names)
[13:24:24.238]                 removed <- setdiff(old_names, names)
[13:24:24.238]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.238]                   envs[common]]
[13:24:24.238]                 NAMES <- toupper(changed)
[13:24:24.238]                 args <- list()
[13:24:24.238]                 for (kk in seq_along(NAMES)) {
[13:24:24.238]                   name <- changed[[kk]]
[13:24:24.238]                   NAME <- NAMES[[kk]]
[13:24:24.238]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.238]                     next
[13:24:24.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.238]                 }
[13:24:24.238]                 NAMES <- toupper(added)
[13:24:24.238]                 for (kk in seq_along(NAMES)) {
[13:24:24.238]                   name <- added[[kk]]
[13:24:24.238]                   NAME <- NAMES[[kk]]
[13:24:24.238]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.238]                     next
[13:24:24.238]                   args[[name]] <- ""
[13:24:24.238]                 }
[13:24:24.238]                 NAMES <- toupper(removed)
[13:24:24.238]                 for (kk in seq_along(NAMES)) {
[13:24:24.238]                   name <- removed[[kk]]
[13:24:24.238]                   NAME <- NAMES[[kk]]
[13:24:24.238]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.238]                     next
[13:24:24.238]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.238]                 }
[13:24:24.238]                 if (length(args) > 0) 
[13:24:24.238]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.238]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.238]             }
[13:24:24.238]             else {
[13:24:24.238]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.238]             }
[13:24:24.238]             {
[13:24:24.238]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.238]                   0L) {
[13:24:24.238]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.238]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.238]                   base::options(opts)
[13:24:24.238]                 }
[13:24:24.238]                 {
[13:24:24.238]                   {
[13:24:24.238]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.238]                     NULL
[13:24:24.238]                   }
[13:24:24.238]                   options(future.plan = NULL)
[13:24:24.238]                   if (is.na(NA_character_)) 
[13:24:24.238]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.238]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.238]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.238]                     envir = parent.frame()) 
[13:24:24.238]                   {
[13:24:24.238]                     default_workers <- missing(workers)
[13:24:24.238]                     if (is.function(workers)) 
[13:24:24.238]                       workers <- workers()
[13:24:24.238]                     workers <- structure(as.integer(workers), 
[13:24:24.238]                       class = class(workers))
[13:24:24.238]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.238]                       1L)
[13:24:24.238]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.238]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.238]                       if (default_workers) 
[13:24:24.238]                         supportsMulticore(warn = TRUE)
[13:24:24.238]                       return(sequential(..., envir = envir))
[13:24:24.238]                     }
[13:24:24.238]                     oopts <- options(mc.cores = workers)
[13:24:24.238]                     on.exit(options(oopts))
[13:24:24.238]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.238]                       envir = envir)
[13:24:24.238]                     if (!future$lazy) 
[13:24:24.238]                       future <- run(future)
[13:24:24.238]                     invisible(future)
[13:24:24.238]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.238]                 }
[13:24:24.238]             }
[13:24:24.238]         }
[13:24:24.238]     })
[13:24:24.238]     if (TRUE) {
[13:24:24.238]         base::sink(type = "output", split = FALSE)
[13:24:24.238]         if (TRUE) {
[13:24:24.238]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.238]         }
[13:24:24.238]         else {
[13:24:24.238]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.238]         }
[13:24:24.238]         base::close(...future.stdout)
[13:24:24.238]         ...future.stdout <- NULL
[13:24:24.238]     }
[13:24:24.238]     ...future.result$conditions <- ...future.conditions
[13:24:24.238]     ...future.result$finished <- base::Sys.time()
[13:24:24.238]     ...future.result
[13:24:24.238] }
[13:24:24.241] requestCore(): workers = 2
[13:24:24.241] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.252] result() for MulticoreFuture ...
[13:24:24.253] result() for MulticoreFuture ...
[13:24:24.253] result() for MulticoreFuture ... done
[13:24:24.253] result() for MulticoreFuture ... done
[13:24:24.254] result() for MulticoreFuture ...
[13:24:24.254] result() for MulticoreFuture ... done
[13:24:24.257] MulticoreFuture started
[13:24:24.257] - Launch lazy future ... done
[13:24:24.257] run() for ‘MulticoreFuture’ ... done
[13:24:24.258] plan(): Setting new future strategy stack:
[13:24:24.259] getGlobalsAndPackages() ...
[13:24:24.258] List of future strategies:
[13:24:24.258] 1. sequential:
[13:24:24.258]    - args: function (..., envir = parent.frame())
[13:24:24.258]    - tweaked: FALSE
[13:24:24.258]    - call: NULL
[13:24:24.259] Searching for globals...
[13:24:24.259] plan(): nbrOfWorkers() = 1
[13:24:24.260] - globals found: [1] ‘{’
[13:24:24.261] Searching for globals ... DONE
[13:24:24.261] Resolving globals: FALSE
[13:24:24.261] 
[13:24:24.261] plan(): Setting new future strategy stack:
[13:24:24.261] 
[13:24:24.262] getGlobalsAndPackages() ... DONE
[13:24:24.261] List of future strategies:
[13:24:24.261] 1. multicore:
[13:24:24.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.261]    - tweaked: FALSE
[13:24:24.261]    - call: plan(strategy)
[13:24:24.262] run() for ‘Future’ ...
[13:24:24.262] - state: ‘created’
[13:24:24.263] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.267] plan(): nbrOfWorkers() = 2
[13:24:24.267] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.268]   - Field: ‘label’
[13:24:24.268]   - Field: ‘local’
[13:24:24.268]   - Field: ‘owner’
[13:24:24.268]   - Field: ‘envir’
[13:24:24.268]   - Field: ‘workers’
[13:24:24.268]   - Field: ‘packages’
[13:24:24.268]   - Field: ‘gc’
[13:24:24.269]   - Field: ‘job’
[13:24:24.269]   - Field: ‘conditions’
[13:24:24.269]   - Field: ‘expr’
[13:24:24.269]   - Field: ‘uuid’
[13:24:24.269]   - Field: ‘seed’
[13:24:24.269]   - Field: ‘version’
[13:24:24.270]   - Field: ‘result’
[13:24:24.270]   - Field: ‘asynchronous’
[13:24:24.270]   - Field: ‘calls’
[13:24:24.270]   - Field: ‘globals’
[13:24:24.270]   - Field: ‘stdout’
[13:24:24.270]   - Field: ‘earlySignal’
[13:24:24.270]   - Field: ‘lazy’
[13:24:24.270]   - Field: ‘state’
[13:24:24.271] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.271] - Launch lazy future ...
[13:24:24.271] Packages needed by the future expression (n = 0): <none>
[13:24:24.271] Packages needed by future strategies (n = 0): <none>
[13:24:24.272] {
[13:24:24.272]     {
[13:24:24.272]         {
[13:24:24.272]             ...future.startTime <- base::Sys.time()
[13:24:24.272]             {
[13:24:24.272]                 {
[13:24:24.272]                   {
[13:24:24.272]                     {
[13:24:24.272]                       base::local({
[13:24:24.272]                         has_future <- base::requireNamespace("future", 
[13:24:24.272]                           quietly = TRUE)
[13:24:24.272]                         if (has_future) {
[13:24:24.272]                           ns <- base::getNamespace("future")
[13:24:24.272]                           version <- ns[[".package"]][["version"]]
[13:24:24.272]                           if (is.null(version)) 
[13:24:24.272]                             version <- utils::packageVersion("future")
[13:24:24.272]                         }
[13:24:24.272]                         else {
[13:24:24.272]                           version <- NULL
[13:24:24.272]                         }
[13:24:24.272]                         if (!has_future || version < "1.8.0") {
[13:24:24.272]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.272]                             "", base::R.version$version.string), 
[13:24:24.272]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.272]                               "release", "version")], collapse = " "), 
[13:24:24.272]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.272]                             info)
[13:24:24.272]                           info <- base::paste(info, collapse = "; ")
[13:24:24.272]                           if (!has_future) {
[13:24:24.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.272]                               info)
[13:24:24.272]                           }
[13:24:24.272]                           else {
[13:24:24.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.272]                               info, version)
[13:24:24.272]                           }
[13:24:24.272]                           base::stop(msg)
[13:24:24.272]                         }
[13:24:24.272]                       })
[13:24:24.272]                     }
[13:24:24.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.272]                     base::options(mc.cores = 1L)
[13:24:24.272]                   }
[13:24:24.272]                   options(future.plan = NULL)
[13:24:24.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.272]                 }
[13:24:24.272]                 ...future.workdir <- getwd()
[13:24:24.272]             }
[13:24:24.272]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.272]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.272]         }
[13:24:24.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.272]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.272]             base::names(...future.oldOptions))
[13:24:24.272]     }
[13:24:24.272]     if (FALSE) {
[13:24:24.272]     }
[13:24:24.272]     else {
[13:24:24.272]         if (TRUE) {
[13:24:24.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.272]                 open = "w")
[13:24:24.272]         }
[13:24:24.272]         else {
[13:24:24.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.272]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.272]         }
[13:24:24.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.272]             base::sink(type = "output", split = FALSE)
[13:24:24.272]             base::close(...future.stdout)
[13:24:24.272]         }, add = TRUE)
[13:24:24.272]     }
[13:24:24.272]     ...future.frame <- base::sys.nframe()
[13:24:24.272]     ...future.conditions <- base::list()
[13:24:24.272]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.272]     if (FALSE) {
[13:24:24.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.272]     }
[13:24:24.272]     ...future.result <- base::tryCatch({
[13:24:24.272]         base::withCallingHandlers({
[13:24:24.272]             ...future.value <- base::withVisible(base::local({
[13:24:24.272]                 withCallingHandlers({
[13:24:24.272]                   {
[13:24:24.272]                     2
[13:24:24.272]                   }
[13:24:24.272]                 }, immediateCondition = function(cond) {
[13:24:24.272]                   save_rds <- function (object, pathname, ...) 
[13:24:24.272]                   {
[13:24:24.272]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.272]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.272]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.272]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.272]                         fi_tmp[["mtime"]])
[13:24:24.272]                     }
[13:24:24.272]                     tryCatch({
[13:24:24.272]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.272]                     }, error = function(ex) {
[13:24:24.272]                       msg <- conditionMessage(ex)
[13:24:24.272]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.272]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.272]                         fi_tmp[["mtime"]], msg)
[13:24:24.272]                       ex$message <- msg
[13:24:24.272]                       stop(ex)
[13:24:24.272]                     })
[13:24:24.272]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.272]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.272]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.272]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.272]                       fi <- file.info(pathname)
[13:24:24.272]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.272]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.272]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.272]                         fi[["size"]], fi[["mtime"]])
[13:24:24.272]                       stop(msg)
[13:24:24.272]                     }
[13:24:24.272]                     invisible(pathname)
[13:24:24.272]                   }
[13:24:24.272]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.272]                     rootPath = tempdir()) 
[13:24:24.272]                   {
[13:24:24.272]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.272]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.272]                       tmpdir = path, fileext = ".rds")
[13:24:24.272]                     save_rds(obj, file)
[13:24:24.272]                   }
[13:24:24.272]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.272]                   {
[13:24:24.272]                     inherits <- base::inherits
[13:24:24.272]                     invokeRestart <- base::invokeRestart
[13:24:24.272]                     is.null <- base::is.null
[13:24:24.272]                     muffled <- FALSE
[13:24:24.272]                     if (inherits(cond, "message")) {
[13:24:24.272]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.272]                       if (muffled) 
[13:24:24.272]                         invokeRestart("muffleMessage")
[13:24:24.272]                     }
[13:24:24.272]                     else if (inherits(cond, "warning")) {
[13:24:24.272]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.272]                       if (muffled) 
[13:24:24.272]                         invokeRestart("muffleWarning")
[13:24:24.272]                     }
[13:24:24.272]                     else if (inherits(cond, "condition")) {
[13:24:24.272]                       if (!is.null(pattern)) {
[13:24:24.272]                         computeRestarts <- base::computeRestarts
[13:24:24.272]                         grepl <- base::grepl
[13:24:24.272]                         restarts <- computeRestarts(cond)
[13:24:24.272]                         for (restart in restarts) {
[13:24:24.272]                           name <- restart$name
[13:24:24.272]                           if (is.null(name)) 
[13:24:24.272]                             next
[13:24:24.272]                           if (!grepl(pattern, name)) 
[13:24:24.272]                             next
[13:24:24.272]                           invokeRestart(restart)
[13:24:24.272]                           muffled <- TRUE
[13:24:24.272]                           break
[13:24:24.272]                         }
[13:24:24.272]                       }
[13:24:24.272]                     }
[13:24:24.272]                     invisible(muffled)
[13:24:24.272]                   }
[13:24:24.272]                   muffleCondition(cond)
[13:24:24.272]                 })
[13:24:24.272]             }))
[13:24:24.272]             future::FutureResult(value = ...future.value$value, 
[13:24:24.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.272]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.272]                     ...future.globalenv.names))
[13:24:24.272]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.272]         }, condition = base::local({
[13:24:24.272]             c <- base::c
[13:24:24.272]             inherits <- base::inherits
[13:24:24.272]             invokeRestart <- base::invokeRestart
[13:24:24.272]             length <- base::length
[13:24:24.272]             list <- base::list
[13:24:24.272]             seq.int <- base::seq.int
[13:24:24.272]             signalCondition <- base::signalCondition
[13:24:24.272]             sys.calls <- base::sys.calls
[13:24:24.272]             `[[` <- base::`[[`
[13:24:24.272]             `+` <- base::`+`
[13:24:24.272]             `<<-` <- base::`<<-`
[13:24:24.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.272]                   3L)]
[13:24:24.272]             }
[13:24:24.272]             function(cond) {
[13:24:24.272]                 is_error <- inherits(cond, "error")
[13:24:24.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.272]                   NULL)
[13:24:24.272]                 if (is_error) {
[13:24:24.272]                   sessionInformation <- function() {
[13:24:24.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.272]                       search = base::search(), system = base::Sys.info())
[13:24:24.272]                   }
[13:24:24.272]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.272]                     cond$call), session = sessionInformation(), 
[13:24:24.272]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.272]                   signalCondition(cond)
[13:24:24.272]                 }
[13:24:24.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.272]                 "immediateCondition"))) {
[13:24:24.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.272]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.272]                   if (TRUE && !signal) {
[13:24:24.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.272]                     {
[13:24:24.272]                       inherits <- base::inherits
[13:24:24.272]                       invokeRestart <- base::invokeRestart
[13:24:24.272]                       is.null <- base::is.null
[13:24:24.272]                       muffled <- FALSE
[13:24:24.272]                       if (inherits(cond, "message")) {
[13:24:24.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.272]                         if (muffled) 
[13:24:24.272]                           invokeRestart("muffleMessage")
[13:24:24.272]                       }
[13:24:24.272]                       else if (inherits(cond, "warning")) {
[13:24:24.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.272]                         if (muffled) 
[13:24:24.272]                           invokeRestart("muffleWarning")
[13:24:24.272]                       }
[13:24:24.272]                       else if (inherits(cond, "condition")) {
[13:24:24.272]                         if (!is.null(pattern)) {
[13:24:24.272]                           computeRestarts <- base::computeRestarts
[13:24:24.272]                           grepl <- base::grepl
[13:24:24.272]                           restarts <- computeRestarts(cond)
[13:24:24.272]                           for (restart in restarts) {
[13:24:24.272]                             name <- restart$name
[13:24:24.272]                             if (is.null(name)) 
[13:24:24.272]                               next
[13:24:24.272]                             if (!grepl(pattern, name)) 
[13:24:24.272]                               next
[13:24:24.272]                             invokeRestart(restart)
[13:24:24.272]                             muffled <- TRUE
[13:24:24.272]                             break
[13:24:24.272]                           }
[13:24:24.272]                         }
[13:24:24.272]                       }
[13:24:24.272]                       invisible(muffled)
[13:24:24.272]                     }
[13:24:24.272]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.272]                   }
[13:24:24.272]                 }
[13:24:24.272]                 else {
[13:24:24.272]                   if (TRUE) {
[13:24:24.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.272]                     {
[13:24:24.272]                       inherits <- base::inherits
[13:24:24.272]                       invokeRestart <- base::invokeRestart
[13:24:24.272]                       is.null <- base::is.null
[13:24:24.272]                       muffled <- FALSE
[13:24:24.272]                       if (inherits(cond, "message")) {
[13:24:24.272]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.272]                         if (muffled) 
[13:24:24.272]                           invokeRestart("muffleMessage")
[13:24:24.272]                       }
[13:24:24.272]                       else if (inherits(cond, "warning")) {
[13:24:24.272]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.272]                         if (muffled) 
[13:24:24.272]                           invokeRestart("muffleWarning")
[13:24:24.272]                       }
[13:24:24.272]                       else if (inherits(cond, "condition")) {
[13:24:24.272]                         if (!is.null(pattern)) {
[13:24:24.272]                           computeRestarts <- base::computeRestarts
[13:24:24.272]                           grepl <- base::grepl
[13:24:24.272]                           restarts <- computeRestarts(cond)
[13:24:24.272]                           for (restart in restarts) {
[13:24:24.272]                             name <- restart$name
[13:24:24.272]                             if (is.null(name)) 
[13:24:24.272]                               next
[13:24:24.272]                             if (!grepl(pattern, name)) 
[13:24:24.272]                               next
[13:24:24.272]                             invokeRestart(restart)
[13:24:24.272]                             muffled <- TRUE
[13:24:24.272]                             break
[13:24:24.272]                           }
[13:24:24.272]                         }
[13:24:24.272]                       }
[13:24:24.272]                       invisible(muffled)
[13:24:24.272]                     }
[13:24:24.272]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.272]                   }
[13:24:24.272]                 }
[13:24:24.272]             }
[13:24:24.272]         }))
[13:24:24.272]     }, error = function(ex) {
[13:24:24.272]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.272]                 ...future.rng), started = ...future.startTime, 
[13:24:24.272]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.272]             version = "1.8"), class = "FutureResult")
[13:24:24.272]     }, finally = {
[13:24:24.272]         if (!identical(...future.workdir, getwd())) 
[13:24:24.272]             setwd(...future.workdir)
[13:24:24.272]         {
[13:24:24.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.272]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.272]             }
[13:24:24.272]             base::options(...future.oldOptions)
[13:24:24.272]             if (.Platform$OS.type == "windows") {
[13:24:24.272]                 old_names <- names(...future.oldEnvVars)
[13:24:24.272]                 envs <- base::Sys.getenv()
[13:24:24.272]                 names <- names(envs)
[13:24:24.272]                 common <- intersect(names, old_names)
[13:24:24.272]                 added <- setdiff(names, old_names)
[13:24:24.272]                 removed <- setdiff(old_names, names)
[13:24:24.272]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.272]                   envs[common]]
[13:24:24.272]                 NAMES <- toupper(changed)
[13:24:24.272]                 args <- list()
[13:24:24.272]                 for (kk in seq_along(NAMES)) {
[13:24:24.272]                   name <- changed[[kk]]
[13:24:24.272]                   NAME <- NAMES[[kk]]
[13:24:24.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.272]                     next
[13:24:24.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.272]                 }
[13:24:24.272]                 NAMES <- toupper(added)
[13:24:24.272]                 for (kk in seq_along(NAMES)) {
[13:24:24.272]                   name <- added[[kk]]
[13:24:24.272]                   NAME <- NAMES[[kk]]
[13:24:24.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.272]                     next
[13:24:24.272]                   args[[name]] <- ""
[13:24:24.272]                 }
[13:24:24.272]                 NAMES <- toupper(removed)
[13:24:24.272]                 for (kk in seq_along(NAMES)) {
[13:24:24.272]                   name <- removed[[kk]]
[13:24:24.272]                   NAME <- NAMES[[kk]]
[13:24:24.272]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.272]                     next
[13:24:24.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.272]                 }
[13:24:24.272]                 if (length(args) > 0) 
[13:24:24.272]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.272]             }
[13:24:24.272]             else {
[13:24:24.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.272]             }
[13:24:24.272]             {
[13:24:24.272]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.272]                   0L) {
[13:24:24.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.272]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.272]                   base::options(opts)
[13:24:24.272]                 }
[13:24:24.272]                 {
[13:24:24.272]                   {
[13:24:24.272]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.272]                     NULL
[13:24:24.272]                   }
[13:24:24.272]                   options(future.plan = NULL)
[13:24:24.272]                   if (is.na(NA_character_)) 
[13:24:24.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.272]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.272]                     envir = parent.frame()) 
[13:24:24.272]                   {
[13:24:24.272]                     default_workers <- missing(workers)
[13:24:24.272]                     if (is.function(workers)) 
[13:24:24.272]                       workers <- workers()
[13:24:24.272]                     workers <- structure(as.integer(workers), 
[13:24:24.272]                       class = class(workers))
[13:24:24.272]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.272]                       1L)
[13:24:24.272]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.272]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.272]                       if (default_workers) 
[13:24:24.272]                         supportsMulticore(warn = TRUE)
[13:24:24.272]                       return(sequential(..., envir = envir))
[13:24:24.272]                     }
[13:24:24.272]                     oopts <- options(mc.cores = workers)
[13:24:24.272]                     on.exit(options(oopts))
[13:24:24.272]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.272]                       envir = envir)
[13:24:24.272]                     if (!future$lazy) 
[13:24:24.272]                       future <- run(future)
[13:24:24.272]                     invisible(future)
[13:24:24.272]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.272]                 }
[13:24:24.272]             }
[13:24:24.272]         }
[13:24:24.272]     })
[13:24:24.272]     if (TRUE) {
[13:24:24.272]         base::sink(type = "output", split = FALSE)
[13:24:24.272]         if (TRUE) {
[13:24:24.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.272]         }
[13:24:24.272]         else {
[13:24:24.272]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.272]         }
[13:24:24.272]         base::close(...future.stdout)
[13:24:24.272]         ...future.stdout <- NULL
[13:24:24.272]     }
[13:24:24.272]     ...future.result$conditions <- ...future.conditions
[13:24:24.272]     ...future.result$finished <- base::Sys.time()
[13:24:24.272]     ...future.result
[13:24:24.272] }
[13:24:24.276] requestCore(): workers = 2
[13:24:24.276] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.287] result() for MulticoreFuture ...
[13:24:24.288] result() for MulticoreFuture ...
[13:24:24.288] result() for MulticoreFuture ... done
[13:24:24.288] result() for MulticoreFuture ... done
[13:24:24.288] result() for MulticoreFuture ...
[13:24:24.289] result() for MulticoreFuture ... done
[13:24:24.291] MulticoreFuture started
[13:24:24.292] - Launch lazy future ... done
[13:24:24.292] run() for ‘MulticoreFuture’ ... done
[13:24:24.292] plan(): Setting new future strategy stack:
[13:24:24.293] List of future strategies:
[13:24:24.293] 1. sequential:
[13:24:24.293]    - args: function (..., envir = parent.frame())
[13:24:24.293]    - tweaked: FALSE
[13:24:24.293]    - call: NULL
[13:24:24.294] resolve() on list environment ...
[13:24:24.294]  recursive: 0
[13:24:24.294] plan(): nbrOfWorkers() = 1
[13:24:24.295]  length: 3
[13:24:24.295]  elements: ‘a’, ‘b’, ‘c’
[13:24:24.296] Future #1
[13:24:24.296]  length: 2 (resolved future 1)
[13:24:24.297] plan(): Setting new future strategy stack:
[13:24:24.297] List of future strategies:
[13:24:24.297] 1. multicore:
[13:24:24.297]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.297]    - tweaked: FALSE
[13:24:24.297]    - call: plan(strategy)
[13:24:24.302] plan(): nbrOfWorkers() = 2
[13:24:24.303] Future #2
[13:24:24.303]  length: 1 (resolved future 2)
[13:24:24.303]  length: 0 (resolved future 3)
[13:24:24.303] resolve() on list environment ... DONE
[13:24:24.304] getGlobalsAndPackages() ...
[13:24:24.304] Searching for globals...
[13:24:24.306] - globals found: [1] ‘{’
[13:24:24.306] Searching for globals ... DONE
[13:24:24.306] Resolving globals: FALSE
[13:24:24.306] 
[13:24:24.311] 
[13:24:24.311] getGlobalsAndPackages() ... DONE
[13:24:24.312] run() for ‘Future’ ...
[13:24:24.313] - state: ‘created’
[13:24:24.313] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.319] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.319]   - Field: ‘label’
[13:24:24.320]   - Field: ‘local’
[13:24:24.320]   - Field: ‘owner’
[13:24:24.320]   - Field: ‘envir’
[13:24:24.320]   - Field: ‘workers’
[13:24:24.320]   - Field: ‘packages’
[13:24:24.321]   - Field: ‘gc’
[13:24:24.321]   - Field: ‘job’
[13:24:24.321]   - Field: ‘conditions’
[13:24:24.321]   - Field: ‘expr’
[13:24:24.321]   - Field: ‘uuid’
[13:24:24.321]   - Field: ‘seed’
[13:24:24.322]   - Field: ‘version’
[13:24:24.322]   - Field: ‘result’
[13:24:24.322]   - Field: ‘asynchronous’
[13:24:24.322]   - Field: ‘calls’
[13:24:24.322]   - Field: ‘globals’
[13:24:24.322]   - Field: ‘stdout’
[13:24:24.323]   - Field: ‘earlySignal’
[13:24:24.323]   - Field: ‘lazy’
[13:24:24.323]   - Field: ‘state’
[13:24:24.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.324] - Launch lazy future ...
[13:24:24.324] Packages needed by the future expression (n = 0): <none>
[13:24:24.324] Packages needed by future strategies (n = 0): <none>
[13:24:24.325] {
[13:24:24.325]     {
[13:24:24.325]         {
[13:24:24.325]             ...future.startTime <- base::Sys.time()
[13:24:24.325]             {
[13:24:24.325]                 {
[13:24:24.325]                   {
[13:24:24.325]                     {
[13:24:24.325]                       base::local({
[13:24:24.325]                         has_future <- base::requireNamespace("future", 
[13:24:24.325]                           quietly = TRUE)
[13:24:24.325]                         if (has_future) {
[13:24:24.325]                           ns <- base::getNamespace("future")
[13:24:24.325]                           version <- ns[[".package"]][["version"]]
[13:24:24.325]                           if (is.null(version)) 
[13:24:24.325]                             version <- utils::packageVersion("future")
[13:24:24.325]                         }
[13:24:24.325]                         else {
[13:24:24.325]                           version <- NULL
[13:24:24.325]                         }
[13:24:24.325]                         if (!has_future || version < "1.8.0") {
[13:24:24.325]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.325]                             "", base::R.version$version.string), 
[13:24:24.325]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.325]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.325]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.325]                               "release", "version")], collapse = " "), 
[13:24:24.325]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.325]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.325]                             info)
[13:24:24.325]                           info <- base::paste(info, collapse = "; ")
[13:24:24.325]                           if (!has_future) {
[13:24:24.325]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.325]                               info)
[13:24:24.325]                           }
[13:24:24.325]                           else {
[13:24:24.325]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.325]                               info, version)
[13:24:24.325]                           }
[13:24:24.325]                           base::stop(msg)
[13:24:24.325]                         }
[13:24:24.325]                       })
[13:24:24.325]                     }
[13:24:24.325]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.325]                     base::options(mc.cores = 1L)
[13:24:24.325]                   }
[13:24:24.325]                   options(future.plan = NULL)
[13:24:24.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.325]                 }
[13:24:24.325]                 ...future.workdir <- getwd()
[13:24:24.325]             }
[13:24:24.325]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.325]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.325]         }
[13:24:24.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.325]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.325]             base::names(...future.oldOptions))
[13:24:24.325]     }
[13:24:24.325]     if (FALSE) {
[13:24:24.325]     }
[13:24:24.325]     else {
[13:24:24.325]         if (TRUE) {
[13:24:24.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.325]                 open = "w")
[13:24:24.325]         }
[13:24:24.325]         else {
[13:24:24.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.325]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.325]         }
[13:24:24.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.325]             base::sink(type = "output", split = FALSE)
[13:24:24.325]             base::close(...future.stdout)
[13:24:24.325]         }, add = TRUE)
[13:24:24.325]     }
[13:24:24.325]     ...future.frame <- base::sys.nframe()
[13:24:24.325]     ...future.conditions <- base::list()
[13:24:24.325]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.325]     if (FALSE) {
[13:24:24.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.325]     }
[13:24:24.325]     ...future.result <- base::tryCatch({
[13:24:24.325]         base::withCallingHandlers({
[13:24:24.325]             ...future.value <- base::withVisible(base::local({
[13:24:24.325]                 withCallingHandlers({
[13:24:24.325]                   {
[13:24:24.325]                     1
[13:24:24.325]                   }
[13:24:24.325]                 }, immediateCondition = function(cond) {
[13:24:24.325]                   save_rds <- function (object, pathname, ...) 
[13:24:24.325]                   {
[13:24:24.325]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.325]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.325]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.325]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.325]                         fi_tmp[["mtime"]])
[13:24:24.325]                     }
[13:24:24.325]                     tryCatch({
[13:24:24.325]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.325]                     }, error = function(ex) {
[13:24:24.325]                       msg <- conditionMessage(ex)
[13:24:24.325]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.325]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.325]                         fi_tmp[["mtime"]], msg)
[13:24:24.325]                       ex$message <- msg
[13:24:24.325]                       stop(ex)
[13:24:24.325]                     })
[13:24:24.325]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.325]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.325]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.325]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.325]                       fi <- file.info(pathname)
[13:24:24.325]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.325]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.325]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.325]                         fi[["size"]], fi[["mtime"]])
[13:24:24.325]                       stop(msg)
[13:24:24.325]                     }
[13:24:24.325]                     invisible(pathname)
[13:24:24.325]                   }
[13:24:24.325]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.325]                     rootPath = tempdir()) 
[13:24:24.325]                   {
[13:24:24.325]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.325]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.325]                       tmpdir = path, fileext = ".rds")
[13:24:24.325]                     save_rds(obj, file)
[13:24:24.325]                   }
[13:24:24.325]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.325]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.325]                   {
[13:24:24.325]                     inherits <- base::inherits
[13:24:24.325]                     invokeRestart <- base::invokeRestart
[13:24:24.325]                     is.null <- base::is.null
[13:24:24.325]                     muffled <- FALSE
[13:24:24.325]                     if (inherits(cond, "message")) {
[13:24:24.325]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.325]                       if (muffled) 
[13:24:24.325]                         invokeRestart("muffleMessage")
[13:24:24.325]                     }
[13:24:24.325]                     else if (inherits(cond, "warning")) {
[13:24:24.325]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.325]                       if (muffled) 
[13:24:24.325]                         invokeRestart("muffleWarning")
[13:24:24.325]                     }
[13:24:24.325]                     else if (inherits(cond, "condition")) {
[13:24:24.325]                       if (!is.null(pattern)) {
[13:24:24.325]                         computeRestarts <- base::computeRestarts
[13:24:24.325]                         grepl <- base::grepl
[13:24:24.325]                         restarts <- computeRestarts(cond)
[13:24:24.325]                         for (restart in restarts) {
[13:24:24.325]                           name <- restart$name
[13:24:24.325]                           if (is.null(name)) 
[13:24:24.325]                             next
[13:24:24.325]                           if (!grepl(pattern, name)) 
[13:24:24.325]                             next
[13:24:24.325]                           invokeRestart(restart)
[13:24:24.325]                           muffled <- TRUE
[13:24:24.325]                           break
[13:24:24.325]                         }
[13:24:24.325]                       }
[13:24:24.325]                     }
[13:24:24.325]                     invisible(muffled)
[13:24:24.325]                   }
[13:24:24.325]                   muffleCondition(cond)
[13:24:24.325]                 })
[13:24:24.325]             }))
[13:24:24.325]             future::FutureResult(value = ...future.value$value, 
[13:24:24.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.325]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.325]                     ...future.globalenv.names))
[13:24:24.325]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.325]         }, condition = base::local({
[13:24:24.325]             c <- base::c
[13:24:24.325]             inherits <- base::inherits
[13:24:24.325]             invokeRestart <- base::invokeRestart
[13:24:24.325]             length <- base::length
[13:24:24.325]             list <- base::list
[13:24:24.325]             seq.int <- base::seq.int
[13:24:24.325]             signalCondition <- base::signalCondition
[13:24:24.325]             sys.calls <- base::sys.calls
[13:24:24.325]             `[[` <- base::`[[`
[13:24:24.325]             `+` <- base::`+`
[13:24:24.325]             `<<-` <- base::`<<-`
[13:24:24.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.325]                   3L)]
[13:24:24.325]             }
[13:24:24.325]             function(cond) {
[13:24:24.325]                 is_error <- inherits(cond, "error")
[13:24:24.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.325]                   NULL)
[13:24:24.325]                 if (is_error) {
[13:24:24.325]                   sessionInformation <- function() {
[13:24:24.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.325]                       search = base::search(), system = base::Sys.info())
[13:24:24.325]                   }
[13:24:24.325]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.325]                     cond$call), session = sessionInformation(), 
[13:24:24.325]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.325]                   signalCondition(cond)
[13:24:24.325]                 }
[13:24:24.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.325]                 "immediateCondition"))) {
[13:24:24.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.325]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.325]                   if (TRUE && !signal) {
[13:24:24.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.325]                     {
[13:24:24.325]                       inherits <- base::inherits
[13:24:24.325]                       invokeRestart <- base::invokeRestart
[13:24:24.325]                       is.null <- base::is.null
[13:24:24.325]                       muffled <- FALSE
[13:24:24.325]                       if (inherits(cond, "message")) {
[13:24:24.325]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.325]                         if (muffled) 
[13:24:24.325]                           invokeRestart("muffleMessage")
[13:24:24.325]                       }
[13:24:24.325]                       else if (inherits(cond, "warning")) {
[13:24:24.325]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.325]                         if (muffled) 
[13:24:24.325]                           invokeRestart("muffleWarning")
[13:24:24.325]                       }
[13:24:24.325]                       else if (inherits(cond, "condition")) {
[13:24:24.325]                         if (!is.null(pattern)) {
[13:24:24.325]                           computeRestarts <- base::computeRestarts
[13:24:24.325]                           grepl <- base::grepl
[13:24:24.325]                           restarts <- computeRestarts(cond)
[13:24:24.325]                           for (restart in restarts) {
[13:24:24.325]                             name <- restart$name
[13:24:24.325]                             if (is.null(name)) 
[13:24:24.325]                               next
[13:24:24.325]                             if (!grepl(pattern, name)) 
[13:24:24.325]                               next
[13:24:24.325]                             invokeRestart(restart)
[13:24:24.325]                             muffled <- TRUE
[13:24:24.325]                             break
[13:24:24.325]                           }
[13:24:24.325]                         }
[13:24:24.325]                       }
[13:24:24.325]                       invisible(muffled)
[13:24:24.325]                     }
[13:24:24.325]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.325]                   }
[13:24:24.325]                 }
[13:24:24.325]                 else {
[13:24:24.325]                   if (TRUE) {
[13:24:24.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.325]                     {
[13:24:24.325]                       inherits <- base::inherits
[13:24:24.325]                       invokeRestart <- base::invokeRestart
[13:24:24.325]                       is.null <- base::is.null
[13:24:24.325]                       muffled <- FALSE
[13:24:24.325]                       if (inherits(cond, "message")) {
[13:24:24.325]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.325]                         if (muffled) 
[13:24:24.325]                           invokeRestart("muffleMessage")
[13:24:24.325]                       }
[13:24:24.325]                       else if (inherits(cond, "warning")) {
[13:24:24.325]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.325]                         if (muffled) 
[13:24:24.325]                           invokeRestart("muffleWarning")
[13:24:24.325]                       }
[13:24:24.325]                       else if (inherits(cond, "condition")) {
[13:24:24.325]                         if (!is.null(pattern)) {
[13:24:24.325]                           computeRestarts <- base::computeRestarts
[13:24:24.325]                           grepl <- base::grepl
[13:24:24.325]                           restarts <- computeRestarts(cond)
[13:24:24.325]                           for (restart in restarts) {
[13:24:24.325]                             name <- restart$name
[13:24:24.325]                             if (is.null(name)) 
[13:24:24.325]                               next
[13:24:24.325]                             if (!grepl(pattern, name)) 
[13:24:24.325]                               next
[13:24:24.325]                             invokeRestart(restart)
[13:24:24.325]                             muffled <- TRUE
[13:24:24.325]                             break
[13:24:24.325]                           }
[13:24:24.325]                         }
[13:24:24.325]                       }
[13:24:24.325]                       invisible(muffled)
[13:24:24.325]                     }
[13:24:24.325]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.325]                   }
[13:24:24.325]                 }
[13:24:24.325]             }
[13:24:24.325]         }))
[13:24:24.325]     }, error = function(ex) {
[13:24:24.325]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.325]                 ...future.rng), started = ...future.startTime, 
[13:24:24.325]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.325]             version = "1.8"), class = "FutureResult")
[13:24:24.325]     }, finally = {
[13:24:24.325]         if (!identical(...future.workdir, getwd())) 
[13:24:24.325]             setwd(...future.workdir)
[13:24:24.325]         {
[13:24:24.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.325]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.325]             }
[13:24:24.325]             base::options(...future.oldOptions)
[13:24:24.325]             if (.Platform$OS.type == "windows") {
[13:24:24.325]                 old_names <- names(...future.oldEnvVars)
[13:24:24.325]                 envs <- base::Sys.getenv()
[13:24:24.325]                 names <- names(envs)
[13:24:24.325]                 common <- intersect(names, old_names)
[13:24:24.325]                 added <- setdiff(names, old_names)
[13:24:24.325]                 removed <- setdiff(old_names, names)
[13:24:24.325]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.325]                   envs[common]]
[13:24:24.325]                 NAMES <- toupper(changed)
[13:24:24.325]                 args <- list()
[13:24:24.325]                 for (kk in seq_along(NAMES)) {
[13:24:24.325]                   name <- changed[[kk]]
[13:24:24.325]                   NAME <- NAMES[[kk]]
[13:24:24.325]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.325]                     next
[13:24:24.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.325]                 }
[13:24:24.325]                 NAMES <- toupper(added)
[13:24:24.325]                 for (kk in seq_along(NAMES)) {
[13:24:24.325]                   name <- added[[kk]]
[13:24:24.325]                   NAME <- NAMES[[kk]]
[13:24:24.325]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.325]                     next
[13:24:24.325]                   args[[name]] <- ""
[13:24:24.325]                 }
[13:24:24.325]                 NAMES <- toupper(removed)
[13:24:24.325]                 for (kk in seq_along(NAMES)) {
[13:24:24.325]                   name <- removed[[kk]]
[13:24:24.325]                   NAME <- NAMES[[kk]]
[13:24:24.325]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.325]                     next
[13:24:24.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.325]                 }
[13:24:24.325]                 if (length(args) > 0) 
[13:24:24.325]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.325]             }
[13:24:24.325]             else {
[13:24:24.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.325]             }
[13:24:24.325]             {
[13:24:24.325]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.325]                   0L) {
[13:24:24.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.325]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.325]                   base::options(opts)
[13:24:24.325]                 }
[13:24:24.325]                 {
[13:24:24.325]                   {
[13:24:24.325]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.325]                     NULL
[13:24:24.325]                   }
[13:24:24.325]                   options(future.plan = NULL)
[13:24:24.325]                   if (is.na(NA_character_)) 
[13:24:24.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.325]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.325]                     envir = parent.frame()) 
[13:24:24.325]                   {
[13:24:24.325]                     default_workers <- missing(workers)
[13:24:24.325]                     if (is.function(workers)) 
[13:24:24.325]                       workers <- workers()
[13:24:24.325]                     workers <- structure(as.integer(workers), 
[13:24:24.325]                       class = class(workers))
[13:24:24.325]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.325]                       1L)
[13:24:24.325]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.325]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.325]                       if (default_workers) 
[13:24:24.325]                         supportsMulticore(warn = TRUE)
[13:24:24.325]                       return(sequential(..., envir = envir))
[13:24:24.325]                     }
[13:24:24.325]                     oopts <- options(mc.cores = workers)
[13:24:24.325]                     on.exit(options(oopts))
[13:24:24.325]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.325]                       envir = envir)
[13:24:24.325]                     if (!future$lazy) 
[13:24:24.325]                       future <- run(future)
[13:24:24.325]                     invisible(future)
[13:24:24.325]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.325]                 }
[13:24:24.325]             }
[13:24:24.325]         }
[13:24:24.325]     })
[13:24:24.325]     if (TRUE) {
[13:24:24.325]         base::sink(type = "output", split = FALSE)
[13:24:24.325]         if (TRUE) {
[13:24:24.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.325]         }
[13:24:24.325]         else {
[13:24:24.325]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.325]         }
[13:24:24.325]         base::close(...future.stdout)
[13:24:24.325]         ...future.stdout <- NULL
[13:24:24.325]     }
[13:24:24.325]     ...future.result$conditions <- ...future.conditions
[13:24:24.325]     ...future.result$finished <- base::Sys.time()
[13:24:24.325]     ...future.result
[13:24:24.325] }
[13:24:24.328] requestCore(): workers = 2
[13:24:24.328] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.339] result() for MulticoreFuture ...
[13:24:24.340] result() for MulticoreFuture ...
[13:24:24.340] result() for MulticoreFuture ... done
[13:24:24.340] result() for MulticoreFuture ... done
[13:24:24.340] result() for MulticoreFuture ...
[13:24:24.340] result() for MulticoreFuture ... done
[13:24:24.343] MulticoreFuture started
[13:24:24.343] - Launch lazy future ... done
[13:24:24.343] run() for ‘MulticoreFuture’ ... done
[13:24:24.344] plan(): Setting new future strategy stack:
[13:24:24.345] getGlobalsAndPackages() ...
[13:24:24.344] List of future strategies:
[13:24:24.344] 1. sequential:
[13:24:24.344]    - args: function (..., envir = parent.frame())
[13:24:24.344]    - tweaked: FALSE
[13:24:24.344]    - call: NULL
[13:24:24.345] Searching for globals...
[13:24:24.346] plan(): nbrOfWorkers() = 1
[13:24:24.348] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:24:24.348] plan(): Setting new future strategy stack:
[13:24:24.348] Searching for globals ... DONE
[13:24:24.349] Resolving globals: FALSE
[13:24:24.349] List of future strategies:
[13:24:24.349] 1. multicore:
[13:24:24.349]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.349]    - tweaked: FALSE
[13:24:24.349]    - call: plan(strategy)
[13:24:24.350] 
[13:24:24.350] 
[13:24:24.350] getGlobalsAndPackages() ... DONE
[13:24:24.351] run() for ‘Future’ ...
[13:24:24.351] - state: ‘created’
[13:24:24.351] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.355] plan(): nbrOfWorkers() = 2
[13:24:24.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.356]   - Field: ‘label’
[13:24:24.357]   - Field: ‘local’
[13:24:24.357]   - Field: ‘owner’
[13:24:24.357]   - Field: ‘envir’
[13:24:24.357]   - Field: ‘workers’
[13:24:24.357]   - Field: ‘packages’
[13:24:24.357]   - Field: ‘gc’
[13:24:24.357]   - Field: ‘job’
[13:24:24.358]   - Field: ‘conditions’
[13:24:24.358]   - Field: ‘expr’
[13:24:24.358]   - Field: ‘uuid’
[13:24:24.358]   - Field: ‘seed’
[13:24:24.358]   - Field: ‘version’
[13:24:24.358]   - Field: ‘result’
[13:24:24.358]   - Field: ‘asynchronous’
[13:24:24.359]   - Field: ‘calls’
[13:24:24.359]   - Field: ‘globals’
[13:24:24.359]   - Field: ‘stdout’
[13:24:24.359]   - Field: ‘earlySignal’
[13:24:24.359]   - Field: ‘lazy’
[13:24:24.359]   - Field: ‘state’
[13:24:24.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.360] - Launch lazy future ...
[13:24:24.360] Packages needed by the future expression (n = 0): <none>
[13:24:24.360] Packages needed by future strategies (n = 0): <none>
[13:24:24.361] {
[13:24:24.361]     {
[13:24:24.361]         {
[13:24:24.361]             ...future.startTime <- base::Sys.time()
[13:24:24.361]             {
[13:24:24.361]                 {
[13:24:24.361]                   {
[13:24:24.361]                     {
[13:24:24.361]                       base::local({
[13:24:24.361]                         has_future <- base::requireNamespace("future", 
[13:24:24.361]                           quietly = TRUE)
[13:24:24.361]                         if (has_future) {
[13:24:24.361]                           ns <- base::getNamespace("future")
[13:24:24.361]                           version <- ns[[".package"]][["version"]]
[13:24:24.361]                           if (is.null(version)) 
[13:24:24.361]                             version <- utils::packageVersion("future")
[13:24:24.361]                         }
[13:24:24.361]                         else {
[13:24:24.361]                           version <- NULL
[13:24:24.361]                         }
[13:24:24.361]                         if (!has_future || version < "1.8.0") {
[13:24:24.361]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.361]                             "", base::R.version$version.string), 
[13:24:24.361]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.361]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.361]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.361]                               "release", "version")], collapse = " "), 
[13:24:24.361]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.361]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.361]                             info)
[13:24:24.361]                           info <- base::paste(info, collapse = "; ")
[13:24:24.361]                           if (!has_future) {
[13:24:24.361]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.361]                               info)
[13:24:24.361]                           }
[13:24:24.361]                           else {
[13:24:24.361]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.361]                               info, version)
[13:24:24.361]                           }
[13:24:24.361]                           base::stop(msg)
[13:24:24.361]                         }
[13:24:24.361]                       })
[13:24:24.361]                     }
[13:24:24.361]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.361]                     base::options(mc.cores = 1L)
[13:24:24.361]                   }
[13:24:24.361]                   options(future.plan = NULL)
[13:24:24.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.361]                 }
[13:24:24.361]                 ...future.workdir <- getwd()
[13:24:24.361]             }
[13:24:24.361]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.361]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.361]         }
[13:24:24.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.361]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.361]             base::names(...future.oldOptions))
[13:24:24.361]     }
[13:24:24.361]     if (FALSE) {
[13:24:24.361]     }
[13:24:24.361]     else {
[13:24:24.361]         if (TRUE) {
[13:24:24.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.361]                 open = "w")
[13:24:24.361]         }
[13:24:24.361]         else {
[13:24:24.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.361]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.361]         }
[13:24:24.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.361]             base::sink(type = "output", split = FALSE)
[13:24:24.361]             base::close(...future.stdout)
[13:24:24.361]         }, add = TRUE)
[13:24:24.361]     }
[13:24:24.361]     ...future.frame <- base::sys.nframe()
[13:24:24.361]     ...future.conditions <- base::list()
[13:24:24.361]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.361]     if (FALSE) {
[13:24:24.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.361]     }
[13:24:24.361]     ...future.result <- base::tryCatch({
[13:24:24.361]         base::withCallingHandlers({
[13:24:24.361]             ...future.value <- base::withVisible(base::local({
[13:24:24.361]                 withCallingHandlers({
[13:24:24.361]                   {
[13:24:24.361]                     Sys.sleep(0.5)
[13:24:24.361]                     2
[13:24:24.361]                   }
[13:24:24.361]                 }, immediateCondition = function(cond) {
[13:24:24.361]                   save_rds <- function (object, pathname, ...) 
[13:24:24.361]                   {
[13:24:24.361]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.361]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.361]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.361]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.361]                         fi_tmp[["mtime"]])
[13:24:24.361]                     }
[13:24:24.361]                     tryCatch({
[13:24:24.361]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.361]                     }, error = function(ex) {
[13:24:24.361]                       msg <- conditionMessage(ex)
[13:24:24.361]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.361]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.361]                         fi_tmp[["mtime"]], msg)
[13:24:24.361]                       ex$message <- msg
[13:24:24.361]                       stop(ex)
[13:24:24.361]                     })
[13:24:24.361]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.361]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.361]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.361]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.361]                       fi <- file.info(pathname)
[13:24:24.361]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.361]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.361]                         fi[["size"]], fi[["mtime"]])
[13:24:24.361]                       stop(msg)
[13:24:24.361]                     }
[13:24:24.361]                     invisible(pathname)
[13:24:24.361]                   }
[13:24:24.361]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.361]                     rootPath = tempdir()) 
[13:24:24.361]                   {
[13:24:24.361]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.361]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.361]                       tmpdir = path, fileext = ".rds")
[13:24:24.361]                     save_rds(obj, file)
[13:24:24.361]                   }
[13:24:24.361]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.361]                   {
[13:24:24.361]                     inherits <- base::inherits
[13:24:24.361]                     invokeRestart <- base::invokeRestart
[13:24:24.361]                     is.null <- base::is.null
[13:24:24.361]                     muffled <- FALSE
[13:24:24.361]                     if (inherits(cond, "message")) {
[13:24:24.361]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.361]                       if (muffled) 
[13:24:24.361]                         invokeRestart("muffleMessage")
[13:24:24.361]                     }
[13:24:24.361]                     else if (inherits(cond, "warning")) {
[13:24:24.361]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.361]                       if (muffled) 
[13:24:24.361]                         invokeRestart("muffleWarning")
[13:24:24.361]                     }
[13:24:24.361]                     else if (inherits(cond, "condition")) {
[13:24:24.361]                       if (!is.null(pattern)) {
[13:24:24.361]                         computeRestarts <- base::computeRestarts
[13:24:24.361]                         grepl <- base::grepl
[13:24:24.361]                         restarts <- computeRestarts(cond)
[13:24:24.361]                         for (restart in restarts) {
[13:24:24.361]                           name <- restart$name
[13:24:24.361]                           if (is.null(name)) 
[13:24:24.361]                             next
[13:24:24.361]                           if (!grepl(pattern, name)) 
[13:24:24.361]                             next
[13:24:24.361]                           invokeRestart(restart)
[13:24:24.361]                           muffled <- TRUE
[13:24:24.361]                           break
[13:24:24.361]                         }
[13:24:24.361]                       }
[13:24:24.361]                     }
[13:24:24.361]                     invisible(muffled)
[13:24:24.361]                   }
[13:24:24.361]                   muffleCondition(cond)
[13:24:24.361]                 })
[13:24:24.361]             }))
[13:24:24.361]             future::FutureResult(value = ...future.value$value, 
[13:24:24.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.361]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.361]                     ...future.globalenv.names))
[13:24:24.361]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.361]         }, condition = base::local({
[13:24:24.361]             c <- base::c
[13:24:24.361]             inherits <- base::inherits
[13:24:24.361]             invokeRestart <- base::invokeRestart
[13:24:24.361]             length <- base::length
[13:24:24.361]             list <- base::list
[13:24:24.361]             seq.int <- base::seq.int
[13:24:24.361]             signalCondition <- base::signalCondition
[13:24:24.361]             sys.calls <- base::sys.calls
[13:24:24.361]             `[[` <- base::`[[`
[13:24:24.361]             `+` <- base::`+`
[13:24:24.361]             `<<-` <- base::`<<-`
[13:24:24.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.361]                   3L)]
[13:24:24.361]             }
[13:24:24.361]             function(cond) {
[13:24:24.361]                 is_error <- inherits(cond, "error")
[13:24:24.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.361]                   NULL)
[13:24:24.361]                 if (is_error) {
[13:24:24.361]                   sessionInformation <- function() {
[13:24:24.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.361]                       search = base::search(), system = base::Sys.info())
[13:24:24.361]                   }
[13:24:24.361]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.361]                     cond$call), session = sessionInformation(), 
[13:24:24.361]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.361]                   signalCondition(cond)
[13:24:24.361]                 }
[13:24:24.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.361]                 "immediateCondition"))) {
[13:24:24.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.361]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.361]                   if (TRUE && !signal) {
[13:24:24.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.361]                     {
[13:24:24.361]                       inherits <- base::inherits
[13:24:24.361]                       invokeRestart <- base::invokeRestart
[13:24:24.361]                       is.null <- base::is.null
[13:24:24.361]                       muffled <- FALSE
[13:24:24.361]                       if (inherits(cond, "message")) {
[13:24:24.361]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.361]                         if (muffled) 
[13:24:24.361]                           invokeRestart("muffleMessage")
[13:24:24.361]                       }
[13:24:24.361]                       else if (inherits(cond, "warning")) {
[13:24:24.361]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.361]                         if (muffled) 
[13:24:24.361]                           invokeRestart("muffleWarning")
[13:24:24.361]                       }
[13:24:24.361]                       else if (inherits(cond, "condition")) {
[13:24:24.361]                         if (!is.null(pattern)) {
[13:24:24.361]                           computeRestarts <- base::computeRestarts
[13:24:24.361]                           grepl <- base::grepl
[13:24:24.361]                           restarts <- computeRestarts(cond)
[13:24:24.361]                           for (restart in restarts) {
[13:24:24.361]                             name <- restart$name
[13:24:24.361]                             if (is.null(name)) 
[13:24:24.361]                               next
[13:24:24.361]                             if (!grepl(pattern, name)) 
[13:24:24.361]                               next
[13:24:24.361]                             invokeRestart(restart)
[13:24:24.361]                             muffled <- TRUE
[13:24:24.361]                             break
[13:24:24.361]                           }
[13:24:24.361]                         }
[13:24:24.361]                       }
[13:24:24.361]                       invisible(muffled)
[13:24:24.361]                     }
[13:24:24.361]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.361]                   }
[13:24:24.361]                 }
[13:24:24.361]                 else {
[13:24:24.361]                   if (TRUE) {
[13:24:24.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.361]                     {
[13:24:24.361]                       inherits <- base::inherits
[13:24:24.361]                       invokeRestart <- base::invokeRestart
[13:24:24.361]                       is.null <- base::is.null
[13:24:24.361]                       muffled <- FALSE
[13:24:24.361]                       if (inherits(cond, "message")) {
[13:24:24.361]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.361]                         if (muffled) 
[13:24:24.361]                           invokeRestart("muffleMessage")
[13:24:24.361]                       }
[13:24:24.361]                       else if (inherits(cond, "warning")) {
[13:24:24.361]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.361]                         if (muffled) 
[13:24:24.361]                           invokeRestart("muffleWarning")
[13:24:24.361]                       }
[13:24:24.361]                       else if (inherits(cond, "condition")) {
[13:24:24.361]                         if (!is.null(pattern)) {
[13:24:24.361]                           computeRestarts <- base::computeRestarts
[13:24:24.361]                           grepl <- base::grepl
[13:24:24.361]                           restarts <- computeRestarts(cond)
[13:24:24.361]                           for (restart in restarts) {
[13:24:24.361]                             name <- restart$name
[13:24:24.361]                             if (is.null(name)) 
[13:24:24.361]                               next
[13:24:24.361]                             if (!grepl(pattern, name)) 
[13:24:24.361]                               next
[13:24:24.361]                             invokeRestart(restart)
[13:24:24.361]                             muffled <- TRUE
[13:24:24.361]                             break
[13:24:24.361]                           }
[13:24:24.361]                         }
[13:24:24.361]                       }
[13:24:24.361]                       invisible(muffled)
[13:24:24.361]                     }
[13:24:24.361]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.361]                   }
[13:24:24.361]                 }
[13:24:24.361]             }
[13:24:24.361]         }))
[13:24:24.361]     }, error = function(ex) {
[13:24:24.361]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.361]                 ...future.rng), started = ...future.startTime, 
[13:24:24.361]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.361]             version = "1.8"), class = "FutureResult")
[13:24:24.361]     }, finally = {
[13:24:24.361]         if (!identical(...future.workdir, getwd())) 
[13:24:24.361]             setwd(...future.workdir)
[13:24:24.361]         {
[13:24:24.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.361]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.361]             }
[13:24:24.361]             base::options(...future.oldOptions)
[13:24:24.361]             if (.Platform$OS.type == "windows") {
[13:24:24.361]                 old_names <- names(...future.oldEnvVars)
[13:24:24.361]                 envs <- base::Sys.getenv()
[13:24:24.361]                 names <- names(envs)
[13:24:24.361]                 common <- intersect(names, old_names)
[13:24:24.361]                 added <- setdiff(names, old_names)
[13:24:24.361]                 removed <- setdiff(old_names, names)
[13:24:24.361]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.361]                   envs[common]]
[13:24:24.361]                 NAMES <- toupper(changed)
[13:24:24.361]                 args <- list()
[13:24:24.361]                 for (kk in seq_along(NAMES)) {
[13:24:24.361]                   name <- changed[[kk]]
[13:24:24.361]                   NAME <- NAMES[[kk]]
[13:24:24.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.361]                     next
[13:24:24.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.361]                 }
[13:24:24.361]                 NAMES <- toupper(added)
[13:24:24.361]                 for (kk in seq_along(NAMES)) {
[13:24:24.361]                   name <- added[[kk]]
[13:24:24.361]                   NAME <- NAMES[[kk]]
[13:24:24.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.361]                     next
[13:24:24.361]                   args[[name]] <- ""
[13:24:24.361]                 }
[13:24:24.361]                 NAMES <- toupper(removed)
[13:24:24.361]                 for (kk in seq_along(NAMES)) {
[13:24:24.361]                   name <- removed[[kk]]
[13:24:24.361]                   NAME <- NAMES[[kk]]
[13:24:24.361]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.361]                     next
[13:24:24.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.361]                 }
[13:24:24.361]                 if (length(args) > 0) 
[13:24:24.361]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.361]             }
[13:24:24.361]             else {
[13:24:24.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.361]             }
[13:24:24.361]             {
[13:24:24.361]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.361]                   0L) {
[13:24:24.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.361]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.361]                   base::options(opts)
[13:24:24.361]                 }
[13:24:24.361]                 {
[13:24:24.361]                   {
[13:24:24.361]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.361]                     NULL
[13:24:24.361]                   }
[13:24:24.361]                   options(future.plan = NULL)
[13:24:24.361]                   if (is.na(NA_character_)) 
[13:24:24.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.361]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.361]                     envir = parent.frame()) 
[13:24:24.361]                   {
[13:24:24.361]                     default_workers <- missing(workers)
[13:24:24.361]                     if (is.function(workers)) 
[13:24:24.361]                       workers <- workers()
[13:24:24.361]                     workers <- structure(as.integer(workers), 
[13:24:24.361]                       class = class(workers))
[13:24:24.361]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.361]                       1L)
[13:24:24.361]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.361]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.361]                       if (default_workers) 
[13:24:24.361]                         supportsMulticore(warn = TRUE)
[13:24:24.361]                       return(sequential(..., envir = envir))
[13:24:24.361]                     }
[13:24:24.361]                     oopts <- options(mc.cores = workers)
[13:24:24.361]                     on.exit(options(oopts))
[13:24:24.361]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.361]                       envir = envir)
[13:24:24.361]                     if (!future$lazy) 
[13:24:24.361]                       future <- run(future)
[13:24:24.361]                     invisible(future)
[13:24:24.361]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.361]                 }
[13:24:24.361]             }
[13:24:24.361]         }
[13:24:24.361]     })
[13:24:24.361]     if (TRUE) {
[13:24:24.361]         base::sink(type = "output", split = FALSE)
[13:24:24.361]         if (TRUE) {
[13:24:24.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.361]         }
[13:24:24.361]         else {
[13:24:24.361]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.361]         }
[13:24:24.361]         base::close(...future.stdout)
[13:24:24.361]         ...future.stdout <- NULL
[13:24:24.361]     }
[13:24:24.361]     ...future.result$conditions <- ...future.conditions
[13:24:24.361]     ...future.result$finished <- base::Sys.time()
[13:24:24.361]     ...future.result
[13:24:24.361] }
[13:24:24.365] requestCore(): workers = 2
[13:24:24.365] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.376] result() for MulticoreFuture ...
[13:24:24.377] result() for MulticoreFuture ...
[13:24:24.377] result() for MulticoreFuture ... done
[13:24:24.377] result() for MulticoreFuture ... done
[13:24:24.377] result() for MulticoreFuture ...
[13:24:24.377] result() for MulticoreFuture ... done
[13:24:24.379] MulticoreFuture started
[13:24:24.380] - Launch lazy future ... done
[13:24:24.380] run() for ‘MulticoreFuture’ ... done
[13:24:24.381] plan(): Setting new future strategy stack:
[13:24:24.382] getGlobalsAndPackages() ...
[13:24:24.382] Searching for globals...
[13:24:24.381] List of future strategies:
[13:24:24.381] 1. sequential:
[13:24:24.381]    - args: function (..., envir = parent.frame())
[13:24:24.381]    - tweaked: FALSE
[13:24:24.381]    - call: NULL
[13:24:24.382] plan(): nbrOfWorkers() = 1
[13:24:24.384] - globals found: [1] ‘{’
[13:24:24.384] Searching for globals ... DONE
[13:24:24.384] Resolving globals: FALSE
[13:24:24.385] 
[13:24:24.385] 
[13:24:24.385] getGlobalsAndPackages() ... DONE
[13:24:24.385] run() for ‘Future’ ...
[13:24:24.386] - state: ‘created’
[13:24:24.386] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:24:24.391] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:24.391] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:24:24.392]   - Field: ‘label’
[13:24:24.392]   - Field: ‘local’
[13:24:24.392]   - Field: ‘owner’
[13:24:24.392]   - Field: ‘envir’
[13:24:24.392]   - Field: ‘workers’
[13:24:24.392]   - Field: ‘packages’
[13:24:24.393]   - Field: ‘gc’
[13:24:24.393]   - Field: ‘job’
[13:24:24.393]   - Field: ‘conditions’
[13:24:24.393]   - Field: ‘expr’
[13:24:24.393]   - Field: ‘uuid’
[13:24:24.393]   - Field: ‘seed’
[13:24:24.393]   - Field: ‘version’
[13:24:24.394]   - Field: ‘result’
[13:24:24.394]   - Field: ‘asynchronous’
[13:24:24.394]   - Field: ‘calls’
[13:24:24.394]   - Field: ‘globals’
[13:24:24.398]   - Field: ‘stdout’
[13:24:24.399]   - Field: ‘earlySignal’
[13:24:24.399]   - Field: ‘lazy’
[13:24:24.399]   - Field: ‘state’
[13:24:24.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:24:24.400] - Launch lazy future ...
[13:24:24.401] Packages needed by the future expression (n = 0): <none>
[13:24:24.401] Packages needed by future strategies (n = 0): <none>
[13:24:24.403] {
[13:24:24.403]     {
[13:24:24.403]         {
[13:24:24.403]             ...future.startTime <- base::Sys.time()
[13:24:24.403]             {
[13:24:24.403]                 {
[13:24:24.403]                   {
[13:24:24.403]                     {
[13:24:24.403]                       base::local({
[13:24:24.403]                         has_future <- base::requireNamespace("future", 
[13:24:24.403]                           quietly = TRUE)
[13:24:24.403]                         if (has_future) {
[13:24:24.403]                           ns <- base::getNamespace("future")
[13:24:24.403]                           version <- ns[[".package"]][["version"]]
[13:24:24.403]                           if (is.null(version)) 
[13:24:24.403]                             version <- utils::packageVersion("future")
[13:24:24.403]                         }
[13:24:24.403]                         else {
[13:24:24.403]                           version <- NULL
[13:24:24.403]                         }
[13:24:24.403]                         if (!has_future || version < "1.8.0") {
[13:24:24.403]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:24.403]                             "", base::R.version$version.string), 
[13:24:24.403]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:24.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:24.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:24.403]                               "release", "version")], collapse = " "), 
[13:24:24.403]                             hostname = base::Sys.info()[["nodename"]])
[13:24:24.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:24.403]                             info)
[13:24:24.403]                           info <- base::paste(info, collapse = "; ")
[13:24:24.403]                           if (!has_future) {
[13:24:24.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:24.403]                               info)
[13:24:24.403]                           }
[13:24:24.403]                           else {
[13:24:24.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:24.403]                               info, version)
[13:24:24.403]                           }
[13:24:24.403]                           base::stop(msg)
[13:24:24.403]                         }
[13:24:24.403]                       })
[13:24:24.403]                     }
[13:24:24.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:24.403]                     base::options(mc.cores = 1L)
[13:24:24.403]                   }
[13:24:24.403]                   options(future.plan = NULL)
[13:24:24.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:24.403]                 }
[13:24:24.403]                 ...future.workdir <- getwd()
[13:24:24.403]             }
[13:24:24.403]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:24.403]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:24.403]         }
[13:24:24.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:24.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:24.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:24.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:24.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:24.403]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:24.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:24.403]             base::names(...future.oldOptions))
[13:24:24.403]     }
[13:24:24.403]     if (FALSE) {
[13:24:24.403]     }
[13:24:24.403]     else {
[13:24:24.403]         if (TRUE) {
[13:24:24.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:24.403]                 open = "w")
[13:24:24.403]         }
[13:24:24.403]         else {
[13:24:24.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:24.403]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:24.403]         }
[13:24:24.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:24.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:24.403]             base::sink(type = "output", split = FALSE)
[13:24:24.403]             base::close(...future.stdout)
[13:24:24.403]         }, add = TRUE)
[13:24:24.403]     }
[13:24:24.403]     ...future.frame <- base::sys.nframe()
[13:24:24.403]     ...future.conditions <- base::list()
[13:24:24.403]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:24.403]     if (FALSE) {
[13:24:24.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:24.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:24.403]     }
[13:24:24.403]     ...future.result <- base::tryCatch({
[13:24:24.403]         base::withCallingHandlers({
[13:24:24.403]             ...future.value <- base::withVisible(base::local({
[13:24:24.403]                 withCallingHandlers({
[13:24:24.403]                   {
[13:24:24.403]                     3
[13:24:24.403]                   }
[13:24:24.403]                 }, immediateCondition = function(cond) {
[13:24:24.403]                   save_rds <- function (object, pathname, ...) 
[13:24:24.403]                   {
[13:24:24.403]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:24:24.403]                     if (file_test("-f", pathname_tmp)) {
[13:24:24.403]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.403]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:24:24.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.403]                         fi_tmp[["mtime"]])
[13:24:24.403]                     }
[13:24:24.403]                     tryCatch({
[13:24:24.403]                       saveRDS(object, file = pathname_tmp, ...)
[13:24:24.403]                     }, error = function(ex) {
[13:24:24.403]                       msg <- conditionMessage(ex)
[13:24:24.403]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.403]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:24:24.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.403]                         fi_tmp[["mtime"]], msg)
[13:24:24.403]                       ex$message <- msg
[13:24:24.403]                       stop(ex)
[13:24:24.403]                     })
[13:24:24.403]                     stopifnot(file_test("-f", pathname_tmp))
[13:24:24.403]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:24:24.403]                     if (!res || file_test("-f", pathname_tmp)) {
[13:24:24.403]                       fi_tmp <- file.info(pathname_tmp)
[13:24:24.403]                       fi <- file.info(pathname)
[13:24:24.403]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:24:24.403]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:24:24.403]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:24:24.403]                         fi[["size"]], fi[["mtime"]])
[13:24:24.403]                       stop(msg)
[13:24:24.403]                     }
[13:24:24.403]                     invisible(pathname)
[13:24:24.403]                   }
[13:24:24.403]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:24:24.403]                     rootPath = tempdir()) 
[13:24:24.403]                   {
[13:24:24.403]                     obj <- list(time = Sys.time(), condition = cond)
[13:24:24.403]                     file <- tempfile(pattern = class(cond)[1], 
[13:24:24.403]                       tmpdir = path, fileext = ".rds")
[13:24:24.403]                     save_rds(obj, file)
[13:24:24.403]                   }
[13:24:24.403]                   saveImmediateCondition(cond, path = "/tmp/RtmpW8gAeu/.future/immediateConditions")
[13:24:24.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.403]                   {
[13:24:24.403]                     inherits <- base::inherits
[13:24:24.403]                     invokeRestart <- base::invokeRestart
[13:24:24.403]                     is.null <- base::is.null
[13:24:24.403]                     muffled <- FALSE
[13:24:24.403]                     if (inherits(cond, "message")) {
[13:24:24.403]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:24.403]                       if (muffled) 
[13:24:24.403]                         invokeRestart("muffleMessage")
[13:24:24.403]                     }
[13:24:24.403]                     else if (inherits(cond, "warning")) {
[13:24:24.403]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:24.403]                       if (muffled) 
[13:24:24.403]                         invokeRestart("muffleWarning")
[13:24:24.403]                     }
[13:24:24.403]                     else if (inherits(cond, "condition")) {
[13:24:24.403]                       if (!is.null(pattern)) {
[13:24:24.403]                         computeRestarts <- base::computeRestarts
[13:24:24.403]                         grepl <- base::grepl
[13:24:24.403]                         restarts <- computeRestarts(cond)
[13:24:24.403]                         for (restart in restarts) {
[13:24:24.403]                           name <- restart$name
[13:24:24.403]                           if (is.null(name)) 
[13:24:24.403]                             next
[13:24:24.403]                           if (!grepl(pattern, name)) 
[13:24:24.403]                             next
[13:24:24.403]                           invokeRestart(restart)
[13:24:24.403]                           muffled <- TRUE
[13:24:24.403]                           break
[13:24:24.403]                         }
[13:24:24.403]                       }
[13:24:24.403]                     }
[13:24:24.403]                     invisible(muffled)
[13:24:24.403]                   }
[13:24:24.403]                   muffleCondition(cond)
[13:24:24.403]                 })
[13:24:24.403]             }))
[13:24:24.403]             future::FutureResult(value = ...future.value$value, 
[13:24:24.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.403]                   ...future.rng), globalenv = if (FALSE) 
[13:24:24.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:24.403]                     ...future.globalenv.names))
[13:24:24.403]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:24.403]         }, condition = base::local({
[13:24:24.403]             c <- base::c
[13:24:24.403]             inherits <- base::inherits
[13:24:24.403]             invokeRestart <- base::invokeRestart
[13:24:24.403]             length <- base::length
[13:24:24.403]             list <- base::list
[13:24:24.403]             seq.int <- base::seq.int
[13:24:24.403]             signalCondition <- base::signalCondition
[13:24:24.403]             sys.calls <- base::sys.calls
[13:24:24.403]             `[[` <- base::`[[`
[13:24:24.403]             `+` <- base::`+`
[13:24:24.403]             `<<-` <- base::`<<-`
[13:24:24.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:24.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:24.403]                   3L)]
[13:24:24.403]             }
[13:24:24.403]             function(cond) {
[13:24:24.403]                 is_error <- inherits(cond, "error")
[13:24:24.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:24.403]                   NULL)
[13:24:24.403]                 if (is_error) {
[13:24:24.403]                   sessionInformation <- function() {
[13:24:24.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:24.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:24.403]                       search = base::search(), system = base::Sys.info())
[13:24:24.403]                   }
[13:24:24.403]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:24.403]                     cond$call), session = sessionInformation(), 
[13:24:24.403]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:24.403]                   signalCondition(cond)
[13:24:24.403]                 }
[13:24:24.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:24.403]                 "immediateCondition"))) {
[13:24:24.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:24.403]                   ...future.conditions[[length(...future.conditions) + 
[13:24:24.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:24.403]                   if (TRUE && !signal) {
[13:24:24.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.403]                     {
[13:24:24.403]                       inherits <- base::inherits
[13:24:24.403]                       invokeRestart <- base::invokeRestart
[13:24:24.403]                       is.null <- base::is.null
[13:24:24.403]                       muffled <- FALSE
[13:24:24.403]                       if (inherits(cond, "message")) {
[13:24:24.403]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.403]                         if (muffled) 
[13:24:24.403]                           invokeRestart("muffleMessage")
[13:24:24.403]                       }
[13:24:24.403]                       else if (inherits(cond, "warning")) {
[13:24:24.403]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.403]                         if (muffled) 
[13:24:24.403]                           invokeRestart("muffleWarning")
[13:24:24.403]                       }
[13:24:24.403]                       else if (inherits(cond, "condition")) {
[13:24:24.403]                         if (!is.null(pattern)) {
[13:24:24.403]                           computeRestarts <- base::computeRestarts
[13:24:24.403]                           grepl <- base::grepl
[13:24:24.403]                           restarts <- computeRestarts(cond)
[13:24:24.403]                           for (restart in restarts) {
[13:24:24.403]                             name <- restart$name
[13:24:24.403]                             if (is.null(name)) 
[13:24:24.403]                               next
[13:24:24.403]                             if (!grepl(pattern, name)) 
[13:24:24.403]                               next
[13:24:24.403]                             invokeRestart(restart)
[13:24:24.403]                             muffled <- TRUE
[13:24:24.403]                             break
[13:24:24.403]                           }
[13:24:24.403]                         }
[13:24:24.403]                       }
[13:24:24.403]                       invisible(muffled)
[13:24:24.403]                     }
[13:24:24.403]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.403]                   }
[13:24:24.403]                 }
[13:24:24.403]                 else {
[13:24:24.403]                   if (TRUE) {
[13:24:24.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:24.403]                     {
[13:24:24.403]                       inherits <- base::inherits
[13:24:24.403]                       invokeRestart <- base::invokeRestart
[13:24:24.403]                       is.null <- base::is.null
[13:24:24.403]                       muffled <- FALSE
[13:24:24.403]                       if (inherits(cond, "message")) {
[13:24:24.403]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:24.403]                         if (muffled) 
[13:24:24.403]                           invokeRestart("muffleMessage")
[13:24:24.403]                       }
[13:24:24.403]                       else if (inherits(cond, "warning")) {
[13:24:24.403]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:24.403]                         if (muffled) 
[13:24:24.403]                           invokeRestart("muffleWarning")
[13:24:24.403]                       }
[13:24:24.403]                       else if (inherits(cond, "condition")) {
[13:24:24.403]                         if (!is.null(pattern)) {
[13:24:24.403]                           computeRestarts <- base::computeRestarts
[13:24:24.403]                           grepl <- base::grepl
[13:24:24.403]                           restarts <- computeRestarts(cond)
[13:24:24.403]                           for (restart in restarts) {
[13:24:24.403]                             name <- restart$name
[13:24:24.403]                             if (is.null(name)) 
[13:24:24.403]                               next
[13:24:24.403]                             if (!grepl(pattern, name)) 
[13:24:24.403]                               next
[13:24:24.403]                             invokeRestart(restart)
[13:24:24.403]                             muffled <- TRUE
[13:24:24.403]                             break
[13:24:24.403]                           }
[13:24:24.403]                         }
[13:24:24.403]                       }
[13:24:24.403]                       invisible(muffled)
[13:24:24.403]                     }
[13:24:24.403]                     muffleCondition(cond, pattern = "^muffle")
[13:24:24.403]                   }
[13:24:24.403]                 }
[13:24:24.403]             }
[13:24:24.403]         }))
[13:24:24.403]     }, error = function(ex) {
[13:24:24.403]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:24.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:24.403]                 ...future.rng), started = ...future.startTime, 
[13:24:24.403]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:24.403]             version = "1.8"), class = "FutureResult")
[13:24:24.403]     }, finally = {
[13:24:24.403]         if (!identical(...future.workdir, getwd())) 
[13:24:24.403]             setwd(...future.workdir)
[13:24:24.403]         {
[13:24:24.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:24.403]                 ...future.oldOptions$nwarnings <- NULL
[13:24:24.403]             }
[13:24:24.403]             base::options(...future.oldOptions)
[13:24:24.403]             if (.Platform$OS.type == "windows") {
[13:24:24.403]                 old_names <- names(...future.oldEnvVars)
[13:24:24.403]                 envs <- base::Sys.getenv()
[13:24:24.403]                 names <- names(envs)
[13:24:24.403]                 common <- intersect(names, old_names)
[13:24:24.403]                 added <- setdiff(names, old_names)
[13:24:24.403]                 removed <- setdiff(old_names, names)
[13:24:24.403]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:24.403]                   envs[common]]
[13:24:24.403]                 NAMES <- toupper(changed)
[13:24:24.403]                 args <- list()
[13:24:24.403]                 for (kk in seq_along(NAMES)) {
[13:24:24.403]                   name <- changed[[kk]]
[13:24:24.403]                   NAME <- NAMES[[kk]]
[13:24:24.403]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.403]                     next
[13:24:24.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.403]                 }
[13:24:24.403]                 NAMES <- toupper(added)
[13:24:24.403]                 for (kk in seq_along(NAMES)) {
[13:24:24.403]                   name <- added[[kk]]
[13:24:24.403]                   NAME <- NAMES[[kk]]
[13:24:24.403]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.403]                     next
[13:24:24.403]                   args[[name]] <- ""
[13:24:24.403]                 }
[13:24:24.403]                 NAMES <- toupper(removed)
[13:24:24.403]                 for (kk in seq_along(NAMES)) {
[13:24:24.403]                   name <- removed[[kk]]
[13:24:24.403]                   NAME <- NAMES[[kk]]
[13:24:24.403]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:24.403]                     next
[13:24:24.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:24.403]                 }
[13:24:24.403]                 if (length(args) > 0) 
[13:24:24.403]                   base::do.call(base::Sys.setenv, args = args)
[13:24:24.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:24.403]             }
[13:24:24.403]             else {
[13:24:24.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:24.403]             }
[13:24:24.403]             {
[13:24:24.403]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:24.403]                   0L) {
[13:24:24.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:24.403]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:24.403]                   base::options(opts)
[13:24:24.403]                 }
[13:24:24.403]                 {
[13:24:24.403]                   {
[13:24:24.403]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:24.403]                     NULL
[13:24:24.403]                   }
[13:24:24.403]                   options(future.plan = NULL)
[13:24:24.403]                   if (is.na(NA_character_)) 
[13:24:24.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:24.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:24.403]                   future::plan(list(function (..., workers = availableCores(constraints = "multicore"), 
[13:24:24.403]                     envir = parent.frame()) 
[13:24:24.403]                   {
[13:24:24.403]                     default_workers <- missing(workers)
[13:24:24.403]                     if (is.function(workers)) 
[13:24:24.403]                       workers <- workers()
[13:24:24.403]                     workers <- structure(as.integer(workers), 
[13:24:24.403]                       class = class(workers))
[13:24:24.403]                     stop_if_not(is.finite(workers), workers >= 
[13:24:24.403]                       1L)
[13:24:24.403]                     if ((workers == 1L && !inherits(workers, 
[13:24:24.403]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[13:24:24.403]                       if (default_workers) 
[13:24:24.403]                         supportsMulticore(warn = TRUE)
[13:24:24.403]                       return(sequential(..., envir = envir))
[13:24:24.403]                     }
[13:24:24.403]                     oopts <- options(mc.cores = workers)
[13:24:24.403]                     on.exit(options(oopts))
[13:24:24.403]                     future <- MulticoreFuture(..., workers = workers, 
[13:24:24.403]                       envir = envir)
[13:24:24.403]                     if (!future$lazy) 
[13:24:24.403]                       future <- run(future)
[13:24:24.403]                     invisible(future)
[13:24:24.403]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:24.403]                 }
[13:24:24.403]             }
[13:24:24.403]         }
[13:24:24.403]     })
[13:24:24.403]     if (TRUE) {
[13:24:24.403]         base::sink(type = "output", split = FALSE)
[13:24:24.403]         if (TRUE) {
[13:24:24.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:24.403]         }
[13:24:24.403]         else {
[13:24:24.403]             ...future.result["stdout"] <- base::list(NULL)
[13:24:24.403]         }
[13:24:24.403]         base::close(...future.stdout)
[13:24:24.403]         ...future.stdout <- NULL
[13:24:24.403]     }
[13:24:24.403]     ...future.result$conditions <- ...future.conditions
[13:24:24.403]     ...future.result$finished <- base::Sys.time()
[13:24:24.403]     ...future.result
[13:24:24.403] }
[13:24:24.406] requestCore(): workers = 2
[13:24:24.406] Poll #1 (0): usedCores() = 2, workers = 2
[13:24:24.417] result() for MulticoreFuture ...
[13:24:24.418] result() for MulticoreFuture ...
[13:24:24.418] result() for MulticoreFuture ... done
[13:24:24.418] result() for MulticoreFuture ... done
[13:24:24.419] result() for MulticoreFuture ...
[13:24:24.419] result() for MulticoreFuture ... done
[13:24:24.422] MulticoreFuture started
[13:24:24.422] - Launch lazy future ... done
[13:24:24.422] run() for ‘MulticoreFuture’ ... done
[13:24:24.423] plan(): Setting new future strategy stack:
[13:24:24.423] List of future strategies:
[13:24:24.423] 1. sequential:
[13:24:24.423]    - args: function (..., envir = parent.frame())
[13:24:24.423]    - tweaked: FALSE
[13:24:24.423]    - call: NULL
[13:24:24.424] plan(): nbrOfWorkers() = 1
[13:24:24.425] resolve() on list environment ...
[13:24:24.425]  recursive: 0
[13:24:24.426]  length: 4
[13:24:24.426]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:24.427] plan(): Setting new future strategy stack:
[13:24:24.427] Future #1
[13:24:24.427]  length: 3 (resolved future 1)
[13:24:24.427] List of future strategies:
[13:24:24.427] 1. multicore:
[13:24:24.427]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.427]    - tweaked: FALSE
[13:24:24.427]    - call: plan(strategy)
[13:24:24.432] plan(): nbrOfWorkers() = 2
[13:24:24.438] Future #3
[13:24:24.438]  length: 2 (resolved future 3)
[13:24:24.438]  length: 1 (resolved future 4)
[13:24:24.886] plan(): Setting new future strategy stack:
[13:24:24.886] List of future strategies:
[13:24:24.886] 1. multicore:
[13:24:24.886]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:24:24.886]    - tweaked: FALSE
[13:24:24.886]    - call: plan(strategy)
[13:24:24.891] plan(): nbrOfWorkers() = 2
[13:24:24.898] Future #2
[13:24:24.899]  length: 0 (resolved future 2)
[13:24:24.899] resolve() on list environment ... DONE
[13:24:24.899] resolve() on list environment ...
[13:24:24.899]  recursive: 0
[13:24:24.901]  length: 4
[13:24:24.901]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:24.901] Future #1
[13:24:24.901]  length: 3 (resolved future 1)
[13:24:24.902] Future #2
[13:24:24.902]  length: 2 (resolved future 2)
[13:24:24.902] Future #3
[13:24:24.902]  length: 1 (resolved future 3)
[13:24:24.902]  length: 0 (resolved future 4)
[13:24:24.903] resolve() on list environment ... DONE
[13:24:24.904] resolve() on list environment ...
[13:24:24.904]  recursive: 0
[13:24:24.905]  length: 4
[13:24:24.905]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:24.905] Future #1
[13:24:24.905]  length: 3 (resolved future 1)
[13:24:24.906] Future #2
[13:24:24.906]  length: 2 (resolved future 2)
[13:24:24.906] Future #3
[13:24:24.906]  length: 1 (resolved future 3)
[13:24:24.906]  length: 0 (resolved future 4)
[13:24:24.907] resolve() on list environment ... DONE
[13:24:24.907] resolve() on list environment ...
[13:24:24.907]  recursive: 0
[13:24:24.908]  length: 4
[13:24:24.909]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:24.909] Future #1
[13:24:24.909]  length: 3 (resolved future 1)
[13:24:24.909] Future #2
[13:24:24.909]  length: 2 (resolved future 2)
[13:24:24.910] Future #3
[13:24:24.910]  length: 1 (resolved future 3)
[13:24:24.910]  length: 0 (resolved future 4)
[13:24:24.910] resolve() on list environment ... DONE
[13:24:24.911] resolve() on list environment ...
[13:24:24.911]  recursive: 0
[13:24:24.912]  length: 4
[13:24:24.912]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:24.912] Future #1
[13:24:24.912] result() for MulticoreFuture ...
[13:24:24.912] result() for MulticoreFuture ... done
[13:24:24.913] result() for MulticoreFuture ...
[13:24:24.913] result() for MulticoreFuture ... done
[13:24:24.913]  length: 3 (resolved future 1)
[13:24:24.913] Future #2
[13:24:24.913] result() for MulticoreFuture ...
[13:24:24.914] result() for MulticoreFuture ...
[13:24:24.914] result() for MulticoreFuture ... done
[13:24:24.915] result() for MulticoreFuture ... done
[13:24:24.915] result() for MulticoreFuture ...
[13:24:24.915] result() for MulticoreFuture ... done
[13:24:24.915]  length: 2 (resolved future 2)
[13:24:24.916] Future #3
[13:24:24.916] result() for MulticoreFuture ...
[13:24:24.917] result() for MulticoreFuture ...
[13:24:24.917] result() for MulticoreFuture ... done
[13:24:24.917] result() for MulticoreFuture ... done
[13:24:24.917] result() for MulticoreFuture ...
[13:24:24.917] result() for MulticoreFuture ... done
[13:24:24.918]  length: 1 (resolved future 3)
[13:24:24.918]  length: 0 (resolved future 4)
[13:24:24.918] resolve() on list environment ... DONE
[13:24:24.919] resolve() on list environment ...
[13:24:24.919]  recursive: 99
[13:24:24.923]  length: 4
[13:24:24.923]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:24.923] Future #1
[13:24:24.923] result() for MulticoreFuture ...
[13:24:24.923] result() for MulticoreFuture ... done
[13:24:24.923] result() for MulticoreFuture ...
[13:24:24.924] result() for MulticoreFuture ... done
[13:24:24.924] A MulticoreFuture was resolved
[13:24:24.924]  length: 3 (resolved future 1)
[13:24:24.924] Future #2
[13:24:24.924] result() for MulticoreFuture ...
[13:24:24.924] result() for MulticoreFuture ... done
[13:24:24.925] result() for MulticoreFuture ...
[13:24:24.925] result() for MulticoreFuture ... done
[13:24:24.925] A MulticoreFuture was resolved
[13:24:24.925]  length: 2 (resolved future 2)
[13:24:24.925] Future #3
[13:24:24.925] result() for MulticoreFuture ...
[13:24:24.925] result() for MulticoreFuture ... done
[13:24:24.925] result() for MulticoreFuture ...
[13:24:24.925] result() for MulticoreFuture ... done
[13:24:24.926] A MulticoreFuture was resolved
[13:24:24.926]  length: 1 (resolved future 3)
[13:24:24.926]  length: 0 (resolved future 4)
[13:24:24.926] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[13:24:24.927] plan(): Setting new future strategy stack:
[13:24:24.927] List of future strategies:
[13:24:24.927] 1. multisession:
[13:24:24.927]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:24:24.927]    - tweaked: FALSE
[13:24:24.927]    - call: plan(strategy)
[13:24:24.927] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:24:24.927] multisession:
[13:24:24.927] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:24:24.927] - tweaked: FALSE
[13:24:24.927] - call: plan(strategy)
[13:24:24.934] getGlobalsAndPackages() ...
[13:24:24.935] Not searching for globals
[13:24:24.935] - globals: [0] <none>
[13:24:24.935] getGlobalsAndPackages() ... DONE
[13:24:24.935] [local output] makeClusterPSOCK() ...
[13:24:24.981] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:24:24.982] [local output] Base port: 11427
[13:24:24.982] [local output] Getting setup options for 2 cluster nodes ...
[13:24:24.982] [local output]  - Node 1 of 2 ...
[13:24:24.982] [local output] localMachine=TRUE => revtunnel=FALSE

[13:24:24.983] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpW8gAeu/worker.rank=1.parallelly.parent=91471.1654fe682e4e.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpW8gAeu/worker.rank=1.parallelly.parent=91471.1654fe682e4e.pid")'’
[13:24:25.174] - Possible to infer worker's PID: TRUE
[13:24:25.174] [local output] Rscript port: 11427

[13:24:25.174] [local output]  - Node 2 of 2 ...
[13:24:25.175] [local output] localMachine=TRUE => revtunnel=FALSE

[13:24:25.175] [local output] Rscript port: 11427

[13:24:25.176] [local output] Getting setup options for 2 cluster nodes ... done
[13:24:25.176] [local output]  - Parallel setup requested for some PSOCK nodes
[13:24:25.176] [local output] Setting up PSOCK nodes in parallel
[13:24:25.176] List of 36
[13:24:25.176]  $ worker          : chr "localhost"
[13:24:25.176]   ..- attr(*, "localhost")= logi TRUE
[13:24:25.176]  $ master          : chr "localhost"
[13:24:25.176]  $ port            : int 11427
[13:24:25.176]  $ connectTimeout  : num 120
[13:24:25.176]  $ timeout         : num 2592000
[13:24:25.176]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:24:25.176]  $ homogeneous     : logi TRUE
[13:24:25.176]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:24:25.176]  $ rscript_envs    : NULL
[13:24:25.176]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:24:25.176]  $ rscript_startup : NULL
[13:24:25.176]  $ rscript_sh      : chr "sh"
[13:24:25.176]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:24:25.176]  $ methods         : logi TRUE
[13:24:25.176]  $ socketOptions   : chr "no-delay"
[13:24:25.176]  $ useXDR          : logi FALSE
[13:24:25.176]  $ outfile         : chr "/dev/null"
[13:24:25.176]  $ renice          : int NA
[13:24:25.176]  $ rshcmd          : NULL
[13:24:25.176]  $ user            : chr(0) 
[13:24:25.176]  $ revtunnel       : logi FALSE
[13:24:25.176]  $ rshlogfile      : NULL
[13:24:25.176]  $ rshopts         : chr(0) 
[13:24:25.176]  $ rank            : int 1
[13:24:25.176]  $ manual          : logi FALSE
[13:24:25.176]  $ dryrun          : logi FALSE
[13:24:25.176]  $ quiet           : logi FALSE
[13:24:25.176]  $ setup_strategy  : chr "parallel"
[13:24:25.176]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:24:25.176]  $ pidfile         : chr "/tmp/RtmpW8gAeu/worker.rank=1.parallelly.parent=91471.1654fe682e4e.pid"
[13:24:25.176]  $ rshcmd_label    : NULL
[13:24:25.176]  $ rsh_call        : NULL
[13:24:25.176]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:24:25.176]  $ localMachine    : logi TRUE
[13:24:25.176]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:24:25.176]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:24:25.176]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:24:25.176]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:24:25.176]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:24:25.176]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:24:25.176]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:24:25.176]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:24:25.176]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:24:25.176]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:24:25.176]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:24:25.176]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:24:25.176]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:24:25.176]  $ arguments       :List of 28
[13:24:25.176]   ..$ worker          : chr "localhost"
[13:24:25.176]   ..$ master          : NULL
[13:24:25.176]   ..$ port            : int 11427
[13:24:25.176]   ..$ connectTimeout  : num 120
[13:24:25.176]   ..$ timeout         : num 2592000
[13:24:25.176]   ..$ rscript         : NULL
[13:24:25.176]   ..$ homogeneous     : NULL
[13:24:25.176]   ..$ rscript_args    : NULL
[13:24:25.176]   ..$ rscript_envs    : NULL
[13:24:25.176]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:24:25.176]   ..$ rscript_startup : NULL
[13:24:25.176]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:24:25.176]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:24:25.176]   ..$ methods         : logi TRUE
[13:24:25.176]   ..$ socketOptions   : chr "no-delay"
[13:24:25.176]   ..$ useXDR          : logi FALSE
[13:24:25.176]   ..$ outfile         : chr "/dev/null"
[13:24:25.176]   ..$ renice          : int NA
[13:24:25.176]   ..$ rshcmd          : NULL
[13:24:25.176]   ..$ user            : NULL
[13:24:25.176]   ..$ revtunnel       : logi NA
[13:24:25.176]   ..$ rshlogfile      : NULL
[13:24:25.176]   ..$ rshopts         : NULL
[13:24:25.176]   ..$ rank            : int 1
[13:24:25.176]   ..$ manual          : logi FALSE
[13:24:25.176]   ..$ dryrun          : logi FALSE
[13:24:25.176]   ..$ quiet           : logi FALSE
[13:24:25.176]   ..$ setup_strategy  : chr "parallel"
[13:24:25.176]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:24:25.193] [local output] System call to launch all workers:
[13:24:25.193] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpW8gAeu/worker.rank=1.parallelly.parent=91471.1654fe682e4e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11427 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:24:25.194] [local output] Starting PSOCK main server
[13:24:25.199] [local output] Workers launched
[13:24:25.200] [local output] Waiting for workers to connect back
[13:24:25.200]  - [local output] 0 workers out of 2 ready
[13:24:25.446]  - [local output] 0 workers out of 2 ready
[13:24:25.447]  - [local output] 1 workers out of 2 ready
[13:24:25.447]  - [local output] 2 workers out of 2 ready
[13:24:25.447] [local output] Launching of workers completed
[13:24:25.448] [local output] Collecting session information from workers
[13:24:25.448] [local output]  - Worker #1 of 2
[13:24:25.449] [local output]  - Worker #2 of 2
[13:24:25.449] [local output] makeClusterPSOCK() ... done
[13:24:25.460] Packages needed by the future expression (n = 0): <none>
[13:24:25.461] Packages needed by future strategies (n = 0): <none>
[13:24:25.461] {
[13:24:25.461]     {
[13:24:25.461]         {
[13:24:25.461]             ...future.startTime <- base::Sys.time()
[13:24:25.461]             {
[13:24:25.461]                 {
[13:24:25.461]                   {
[13:24:25.461]                     {
[13:24:25.461]                       base::local({
[13:24:25.461]                         has_future <- base::requireNamespace("future", 
[13:24:25.461]                           quietly = TRUE)
[13:24:25.461]                         if (has_future) {
[13:24:25.461]                           ns <- base::getNamespace("future")
[13:24:25.461]                           version <- ns[[".package"]][["version"]]
[13:24:25.461]                           if (is.null(version)) 
[13:24:25.461]                             version <- utils::packageVersion("future")
[13:24:25.461]                         }
[13:24:25.461]                         else {
[13:24:25.461]                           version <- NULL
[13:24:25.461]                         }
[13:24:25.461]                         if (!has_future || version < "1.8.0") {
[13:24:25.461]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:25.461]                             "", base::R.version$version.string), 
[13:24:25.461]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:25.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:25.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:25.461]                               "release", "version")], collapse = " "), 
[13:24:25.461]                             hostname = base::Sys.info()[["nodename"]])
[13:24:25.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:25.461]                             info)
[13:24:25.461]                           info <- base::paste(info, collapse = "; ")
[13:24:25.461]                           if (!has_future) {
[13:24:25.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:25.461]                               info)
[13:24:25.461]                           }
[13:24:25.461]                           else {
[13:24:25.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:25.461]                               info, version)
[13:24:25.461]                           }
[13:24:25.461]                           base::stop(msg)
[13:24:25.461]                         }
[13:24:25.461]                       })
[13:24:25.461]                     }
[13:24:25.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:25.461]                     base::options(mc.cores = 1L)
[13:24:25.461]                   }
[13:24:25.461]                   options(future.plan = NULL)
[13:24:25.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:25.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:25.461]                 }
[13:24:25.461]                 ...future.workdir <- getwd()
[13:24:25.461]             }
[13:24:25.461]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:25.461]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:25.461]         }
[13:24:25.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:25.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:25.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:25.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:25.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:25.461]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:25.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:25.461]             base::names(...future.oldOptions))
[13:24:25.461]     }
[13:24:25.461]     if (FALSE) {
[13:24:25.461]     }
[13:24:25.461]     else {
[13:24:25.461]         if (TRUE) {
[13:24:25.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:25.461]                 open = "w")
[13:24:25.461]         }
[13:24:25.461]         else {
[13:24:25.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:25.461]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:25.461]         }
[13:24:25.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:25.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:25.461]             base::sink(type = "output", split = FALSE)
[13:24:25.461]             base::close(...future.stdout)
[13:24:25.461]         }, add = TRUE)
[13:24:25.461]     }
[13:24:25.461]     ...future.frame <- base::sys.nframe()
[13:24:25.461]     ...future.conditions <- base::list()
[13:24:25.461]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:25.461]     if (FALSE) {
[13:24:25.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:25.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:25.461]     }
[13:24:25.461]     ...future.result <- base::tryCatch({
[13:24:25.461]         base::withCallingHandlers({
[13:24:25.461]             ...future.value <- base::withVisible(base::local({
[13:24:25.461]                 ...future.makeSendCondition <- base::local({
[13:24:25.461]                   sendCondition <- NULL
[13:24:25.461]                   function(frame = 1L) {
[13:24:25.461]                     if (is.function(sendCondition)) 
[13:24:25.461]                       return(sendCondition)
[13:24:25.461]                     ns <- getNamespace("parallel")
[13:24:25.461]                     if (exists("sendData", mode = "function", 
[13:24:25.461]                       envir = ns)) {
[13:24:25.461]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:25.461]                         envir = ns)
[13:24:25.461]                       envir <- sys.frame(frame)
[13:24:25.461]                       master <- NULL
[13:24:25.461]                       while (!identical(envir, .GlobalEnv) && 
[13:24:25.461]                         !identical(envir, emptyenv())) {
[13:24:25.461]                         if (exists("master", mode = "list", envir = envir, 
[13:24:25.461]                           inherits = FALSE)) {
[13:24:25.461]                           master <- get("master", mode = "list", 
[13:24:25.461]                             envir = envir, inherits = FALSE)
[13:24:25.461]                           if (inherits(master, c("SOCKnode", 
[13:24:25.461]                             "SOCK0node"))) {
[13:24:25.461]                             sendCondition <<- function(cond) {
[13:24:25.461]                               data <- list(type = "VALUE", value = cond, 
[13:24:25.461]                                 success = TRUE)
[13:24:25.461]                               parallel_sendData(master, data)
[13:24:25.461]                             }
[13:24:25.461]                             return(sendCondition)
[13:24:25.461]                           }
[13:24:25.461]                         }
[13:24:25.461]                         frame <- frame + 1L
[13:24:25.461]                         envir <- sys.frame(frame)
[13:24:25.461]                       }
[13:24:25.461]                     }
[13:24:25.461]                     sendCondition <<- function(cond) NULL
[13:24:25.461]                   }
[13:24:25.461]                 })
[13:24:25.461]                 withCallingHandlers({
[13:24:25.461]                   NA
[13:24:25.461]                 }, immediateCondition = function(cond) {
[13:24:25.461]                   sendCondition <- ...future.makeSendCondition()
[13:24:25.461]                   sendCondition(cond)
[13:24:25.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:25.461]                   {
[13:24:25.461]                     inherits <- base::inherits
[13:24:25.461]                     invokeRestart <- base::invokeRestart
[13:24:25.461]                     is.null <- base::is.null
[13:24:25.461]                     muffled <- FALSE
[13:24:25.461]                     if (inherits(cond, "message")) {
[13:24:25.461]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:25.461]                       if (muffled) 
[13:24:25.461]                         invokeRestart("muffleMessage")
[13:24:25.461]                     }
[13:24:25.461]                     else if (inherits(cond, "warning")) {
[13:24:25.461]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:25.461]                       if (muffled) 
[13:24:25.461]                         invokeRestart("muffleWarning")
[13:24:25.461]                     }
[13:24:25.461]                     else if (inherits(cond, "condition")) {
[13:24:25.461]                       if (!is.null(pattern)) {
[13:24:25.461]                         computeRestarts <- base::computeRestarts
[13:24:25.461]                         grepl <- base::grepl
[13:24:25.461]                         restarts <- computeRestarts(cond)
[13:24:25.461]                         for (restart in restarts) {
[13:24:25.461]                           name <- restart$name
[13:24:25.461]                           if (is.null(name)) 
[13:24:25.461]                             next
[13:24:25.461]                           if (!grepl(pattern, name)) 
[13:24:25.461]                             next
[13:24:25.461]                           invokeRestart(restart)
[13:24:25.461]                           muffled <- TRUE
[13:24:25.461]                           break
[13:24:25.461]                         }
[13:24:25.461]                       }
[13:24:25.461]                     }
[13:24:25.461]                     invisible(muffled)
[13:24:25.461]                   }
[13:24:25.461]                   muffleCondition(cond)
[13:24:25.461]                 })
[13:24:25.461]             }))
[13:24:25.461]             future::FutureResult(value = ...future.value$value, 
[13:24:25.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:25.461]                   ...future.rng), globalenv = if (FALSE) 
[13:24:25.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:25.461]                     ...future.globalenv.names))
[13:24:25.461]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:25.461]         }, condition = base::local({
[13:24:25.461]             c <- base::c
[13:24:25.461]             inherits <- base::inherits
[13:24:25.461]             invokeRestart <- base::invokeRestart
[13:24:25.461]             length <- base::length
[13:24:25.461]             list <- base::list
[13:24:25.461]             seq.int <- base::seq.int
[13:24:25.461]             signalCondition <- base::signalCondition
[13:24:25.461]             sys.calls <- base::sys.calls
[13:24:25.461]             `[[` <- base::`[[`
[13:24:25.461]             `+` <- base::`+`
[13:24:25.461]             `<<-` <- base::`<<-`
[13:24:25.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:25.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:25.461]                   3L)]
[13:24:25.461]             }
[13:24:25.461]             function(cond) {
[13:24:25.461]                 is_error <- inherits(cond, "error")
[13:24:25.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:25.461]                   NULL)
[13:24:25.461]                 if (is_error) {
[13:24:25.461]                   sessionInformation <- function() {
[13:24:25.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:25.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:25.461]                       search = base::search(), system = base::Sys.info())
[13:24:25.461]                   }
[13:24:25.461]                   ...future.conditions[[length(...future.conditions) + 
[13:24:25.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:25.461]                     cond$call), session = sessionInformation(), 
[13:24:25.461]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:25.461]                   signalCondition(cond)
[13:24:25.461]                 }
[13:24:25.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:25.461]                 "immediateCondition"))) {
[13:24:25.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:25.461]                   ...future.conditions[[length(...future.conditions) + 
[13:24:25.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:25.461]                   if (TRUE && !signal) {
[13:24:25.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:25.461]                     {
[13:24:25.461]                       inherits <- base::inherits
[13:24:25.461]                       invokeRestart <- base::invokeRestart
[13:24:25.461]                       is.null <- base::is.null
[13:24:25.461]                       muffled <- FALSE
[13:24:25.461]                       if (inherits(cond, "message")) {
[13:24:25.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:25.461]                         if (muffled) 
[13:24:25.461]                           invokeRestart("muffleMessage")
[13:24:25.461]                       }
[13:24:25.461]                       else if (inherits(cond, "warning")) {
[13:24:25.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:25.461]                         if (muffled) 
[13:24:25.461]                           invokeRestart("muffleWarning")
[13:24:25.461]                       }
[13:24:25.461]                       else if (inherits(cond, "condition")) {
[13:24:25.461]                         if (!is.null(pattern)) {
[13:24:25.461]                           computeRestarts <- base::computeRestarts
[13:24:25.461]                           grepl <- base::grepl
[13:24:25.461]                           restarts <- computeRestarts(cond)
[13:24:25.461]                           for (restart in restarts) {
[13:24:25.461]                             name <- restart$name
[13:24:25.461]                             if (is.null(name)) 
[13:24:25.461]                               next
[13:24:25.461]                             if (!grepl(pattern, name)) 
[13:24:25.461]                               next
[13:24:25.461]                             invokeRestart(restart)
[13:24:25.461]                             muffled <- TRUE
[13:24:25.461]                             break
[13:24:25.461]                           }
[13:24:25.461]                         }
[13:24:25.461]                       }
[13:24:25.461]                       invisible(muffled)
[13:24:25.461]                     }
[13:24:25.461]                     muffleCondition(cond, pattern = "^muffle")
[13:24:25.461]                   }
[13:24:25.461]                 }
[13:24:25.461]                 else {
[13:24:25.461]                   if (TRUE) {
[13:24:25.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:25.461]                     {
[13:24:25.461]                       inherits <- base::inherits
[13:24:25.461]                       invokeRestart <- base::invokeRestart
[13:24:25.461]                       is.null <- base::is.null
[13:24:25.461]                       muffled <- FALSE
[13:24:25.461]                       if (inherits(cond, "message")) {
[13:24:25.461]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:25.461]                         if (muffled) 
[13:24:25.461]                           invokeRestart("muffleMessage")
[13:24:25.461]                       }
[13:24:25.461]                       else if (inherits(cond, "warning")) {
[13:24:25.461]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:25.461]                         if (muffled) 
[13:24:25.461]                           invokeRestart("muffleWarning")
[13:24:25.461]                       }
[13:24:25.461]                       else if (inherits(cond, "condition")) {
[13:24:25.461]                         if (!is.null(pattern)) {
[13:24:25.461]                           computeRestarts <- base::computeRestarts
[13:24:25.461]                           grepl <- base::grepl
[13:24:25.461]                           restarts <- computeRestarts(cond)
[13:24:25.461]                           for (restart in restarts) {
[13:24:25.461]                             name <- restart$name
[13:24:25.461]                             if (is.null(name)) 
[13:24:25.461]                               next
[13:24:25.461]                             if (!grepl(pattern, name)) 
[13:24:25.461]                               next
[13:24:25.461]                             invokeRestart(restart)
[13:24:25.461]                             muffled <- TRUE
[13:24:25.461]                             break
[13:24:25.461]                           }
[13:24:25.461]                         }
[13:24:25.461]                       }
[13:24:25.461]                       invisible(muffled)
[13:24:25.461]                     }
[13:24:25.461]                     muffleCondition(cond, pattern = "^muffle")
[13:24:25.461]                   }
[13:24:25.461]                 }
[13:24:25.461]             }
[13:24:25.461]         }))
[13:24:25.461]     }, error = function(ex) {
[13:24:25.461]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:25.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:25.461]                 ...future.rng), started = ...future.startTime, 
[13:24:25.461]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:25.461]             version = "1.8"), class = "FutureResult")
[13:24:25.461]     }, finally = {
[13:24:25.461]         if (!identical(...future.workdir, getwd())) 
[13:24:25.461]             setwd(...future.workdir)
[13:24:25.461]         {
[13:24:25.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:25.461]                 ...future.oldOptions$nwarnings <- NULL
[13:24:25.461]             }
[13:24:25.461]             base::options(...future.oldOptions)
[13:24:25.461]             if (.Platform$OS.type == "windows") {
[13:24:25.461]                 old_names <- names(...future.oldEnvVars)
[13:24:25.461]                 envs <- base::Sys.getenv()
[13:24:25.461]                 names <- names(envs)
[13:24:25.461]                 common <- intersect(names, old_names)
[13:24:25.461]                 added <- setdiff(names, old_names)
[13:24:25.461]                 removed <- setdiff(old_names, names)
[13:24:25.461]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:25.461]                   envs[common]]
[13:24:25.461]                 NAMES <- toupper(changed)
[13:24:25.461]                 args <- list()
[13:24:25.461]                 for (kk in seq_along(NAMES)) {
[13:24:25.461]                   name <- changed[[kk]]
[13:24:25.461]                   NAME <- NAMES[[kk]]
[13:24:25.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:25.461]                     next
[13:24:25.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:25.461]                 }
[13:24:25.461]                 NAMES <- toupper(added)
[13:24:25.461]                 for (kk in seq_along(NAMES)) {
[13:24:25.461]                   name <- added[[kk]]
[13:24:25.461]                   NAME <- NAMES[[kk]]
[13:24:25.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:25.461]                     next
[13:24:25.461]                   args[[name]] <- ""
[13:24:25.461]                 }
[13:24:25.461]                 NAMES <- toupper(removed)
[13:24:25.461]                 for (kk in seq_along(NAMES)) {
[13:24:25.461]                   name <- removed[[kk]]
[13:24:25.461]                   NAME <- NAMES[[kk]]
[13:24:25.461]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:25.461]                     next
[13:24:25.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:25.461]                 }
[13:24:25.461]                 if (length(args) > 0) 
[13:24:25.461]                   base::do.call(base::Sys.setenv, args = args)
[13:24:25.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:25.461]             }
[13:24:25.461]             else {
[13:24:25.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:25.461]             }
[13:24:25.461]             {
[13:24:25.461]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:25.461]                   0L) {
[13:24:25.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:25.461]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:25.461]                   base::options(opts)
[13:24:25.461]                 }
[13:24:25.461]                 {
[13:24:25.461]                   {
[13:24:25.461]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:25.461]                     NULL
[13:24:25.461]                   }
[13:24:25.461]                   options(future.plan = NULL)
[13:24:25.461]                   if (is.na(NA_character_)) 
[13:24:25.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:25.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:25.461]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:25.461]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:25.461]                     envir = parent.frame()) 
[13:24:25.461]                   {
[13:24:25.461]                     if (is.function(workers)) 
[13:24:25.461]                       workers <- workers()
[13:24:25.461]                     workers <- structure(as.integer(workers), 
[13:24:25.461]                       class = class(workers))
[13:24:25.461]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:25.461]                       workers >= 1)
[13:24:25.461]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:25.461]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:25.461]                     }
[13:24:25.461]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:25.461]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:25.461]                       envir = envir)
[13:24:25.461]                     if (!future$lazy) 
[13:24:25.461]                       future <- run(future)
[13:24:25.461]                     invisible(future)
[13:24:25.461]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:25.461]                 }
[13:24:25.461]             }
[13:24:25.461]         }
[13:24:25.461]     })
[13:24:25.461]     if (TRUE) {
[13:24:25.461]         base::sink(type = "output", split = FALSE)
[13:24:25.461]         if (TRUE) {
[13:24:25.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:25.461]         }
[13:24:25.461]         else {
[13:24:25.461]             ...future.result["stdout"] <- base::list(NULL)
[13:24:25.461]         }
[13:24:25.461]         base::close(...future.stdout)
[13:24:25.461]         ...future.stdout <- NULL
[13:24:25.461]     }
[13:24:25.461]     ...future.result$conditions <- ...future.conditions
[13:24:25.461]     ...future.result$finished <- base::Sys.time()
[13:24:25.461]     ...future.result
[13:24:25.461] }
[13:24:25.516] MultisessionFuture started
[13:24:25.517] result() for ClusterFuture ...
[13:24:25.517] receiveMessageFromWorker() for ClusterFuture ...
[13:24:25.517] - Validating connection of MultisessionFuture
[13:24:25.562] - received message: FutureResult
[13:24:25.562] - Received FutureResult
[13:24:25.562] - Erased future from FutureRegistry
[13:24:25.563] result() for ClusterFuture ...
[13:24:25.563] - result already collected: FutureResult
[13:24:25.563] result() for ClusterFuture ... done
[13:24:25.563] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:25.563] result() for ClusterFuture ... done
[13:24:25.563] result() for ClusterFuture ...
[13:24:25.563] - result already collected: FutureResult
[13:24:25.563] result() for ClusterFuture ... done
[13:24:25.563] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:24:25.567] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[13:24:25.571] getGlobalsAndPackages() ...
[13:24:25.571] Searching for globals...
[13:24:25.573] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:25.573] Searching for globals ... DONE
[13:24:25.573] Resolving globals: FALSE
[13:24:25.573] 
[13:24:25.573] 
[13:24:25.574] getGlobalsAndPackages() ... DONE
[13:24:25.574] run() for ‘Future’ ...
[13:24:25.574] - state: ‘created’
[13:24:25.574] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:25.589] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:25.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:25.589]   - Field: ‘node’
[13:24:25.589]   - Field: ‘label’
[13:24:25.589]   - Field: ‘local’
[13:24:25.590]   - Field: ‘owner’
[13:24:25.590]   - Field: ‘envir’
[13:24:25.590]   - Field: ‘workers’
[13:24:25.590]   - Field: ‘packages’
[13:24:25.590]   - Field: ‘gc’
[13:24:25.590]   - Field: ‘conditions’
[13:24:25.590]   - Field: ‘persistent’
[13:24:25.590]   - Field: ‘expr’
[13:24:25.590]   - Field: ‘uuid’
[13:24:25.590]   - Field: ‘seed’
[13:24:25.591]   - Field: ‘version’
[13:24:25.591]   - Field: ‘result’
[13:24:25.591]   - Field: ‘asynchronous’
[13:24:25.591]   - Field: ‘calls’
[13:24:25.591]   - Field: ‘globals’
[13:24:25.591]   - Field: ‘stdout’
[13:24:25.591]   - Field: ‘earlySignal’
[13:24:25.591]   - Field: ‘lazy’
[13:24:25.592]   - Field: ‘state’
[13:24:25.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:25.592] - Launch lazy future ...
[13:24:25.592] Packages needed by the future expression (n = 0): <none>
[13:24:25.592] Packages needed by future strategies (n = 0): <none>
[13:24:25.593] {
[13:24:25.593]     {
[13:24:25.593]         {
[13:24:25.593]             ...future.startTime <- base::Sys.time()
[13:24:25.593]             {
[13:24:25.593]                 {
[13:24:25.593]                   {
[13:24:25.593]                     {
[13:24:25.593]                       base::local({
[13:24:25.593]                         has_future <- base::requireNamespace("future", 
[13:24:25.593]                           quietly = TRUE)
[13:24:25.593]                         if (has_future) {
[13:24:25.593]                           ns <- base::getNamespace("future")
[13:24:25.593]                           version <- ns[[".package"]][["version"]]
[13:24:25.593]                           if (is.null(version)) 
[13:24:25.593]                             version <- utils::packageVersion("future")
[13:24:25.593]                         }
[13:24:25.593]                         else {
[13:24:25.593]                           version <- NULL
[13:24:25.593]                         }
[13:24:25.593]                         if (!has_future || version < "1.8.0") {
[13:24:25.593]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:25.593]                             "", base::R.version$version.string), 
[13:24:25.593]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:25.593]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:25.593]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:25.593]                               "release", "version")], collapse = " "), 
[13:24:25.593]                             hostname = base::Sys.info()[["nodename"]])
[13:24:25.593]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:25.593]                             info)
[13:24:25.593]                           info <- base::paste(info, collapse = "; ")
[13:24:25.593]                           if (!has_future) {
[13:24:25.593]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:25.593]                               info)
[13:24:25.593]                           }
[13:24:25.593]                           else {
[13:24:25.593]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:25.593]                               info, version)
[13:24:25.593]                           }
[13:24:25.593]                           base::stop(msg)
[13:24:25.593]                         }
[13:24:25.593]                       })
[13:24:25.593]                     }
[13:24:25.593]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:25.593]                     base::options(mc.cores = 1L)
[13:24:25.593]                   }
[13:24:25.593]                   options(future.plan = NULL)
[13:24:25.593]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:25.593]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:25.593]                 }
[13:24:25.593]                 ...future.workdir <- getwd()
[13:24:25.593]             }
[13:24:25.593]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:25.593]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:25.593]         }
[13:24:25.593]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:25.593]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:25.593]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:25.593]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:25.593]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:25.593]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:25.593]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:25.593]             base::names(...future.oldOptions))
[13:24:25.593]     }
[13:24:25.593]     if (FALSE) {
[13:24:25.593]     }
[13:24:25.593]     else {
[13:24:25.593]         if (TRUE) {
[13:24:25.593]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:25.593]                 open = "w")
[13:24:25.593]         }
[13:24:25.593]         else {
[13:24:25.593]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:25.593]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:25.593]         }
[13:24:25.593]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:25.593]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:25.593]             base::sink(type = "output", split = FALSE)
[13:24:25.593]             base::close(...future.stdout)
[13:24:25.593]         }, add = TRUE)
[13:24:25.593]     }
[13:24:25.593]     ...future.frame <- base::sys.nframe()
[13:24:25.593]     ...future.conditions <- base::list()
[13:24:25.593]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:25.593]     if (FALSE) {
[13:24:25.593]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:25.593]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:25.593]     }
[13:24:25.593]     ...future.result <- base::tryCatch({
[13:24:25.593]         base::withCallingHandlers({
[13:24:25.593]             ...future.value <- base::withVisible(base::local({
[13:24:25.593]                 ...future.makeSendCondition <- base::local({
[13:24:25.593]                   sendCondition <- NULL
[13:24:25.593]                   function(frame = 1L) {
[13:24:25.593]                     if (is.function(sendCondition)) 
[13:24:25.593]                       return(sendCondition)
[13:24:25.593]                     ns <- getNamespace("parallel")
[13:24:25.593]                     if (exists("sendData", mode = "function", 
[13:24:25.593]                       envir = ns)) {
[13:24:25.593]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:25.593]                         envir = ns)
[13:24:25.593]                       envir <- sys.frame(frame)
[13:24:25.593]                       master <- NULL
[13:24:25.593]                       while (!identical(envir, .GlobalEnv) && 
[13:24:25.593]                         !identical(envir, emptyenv())) {
[13:24:25.593]                         if (exists("master", mode = "list", envir = envir, 
[13:24:25.593]                           inherits = FALSE)) {
[13:24:25.593]                           master <- get("master", mode = "list", 
[13:24:25.593]                             envir = envir, inherits = FALSE)
[13:24:25.593]                           if (inherits(master, c("SOCKnode", 
[13:24:25.593]                             "SOCK0node"))) {
[13:24:25.593]                             sendCondition <<- function(cond) {
[13:24:25.593]                               data <- list(type = "VALUE", value = cond, 
[13:24:25.593]                                 success = TRUE)
[13:24:25.593]                               parallel_sendData(master, data)
[13:24:25.593]                             }
[13:24:25.593]                             return(sendCondition)
[13:24:25.593]                           }
[13:24:25.593]                         }
[13:24:25.593]                         frame <- frame + 1L
[13:24:25.593]                         envir <- sys.frame(frame)
[13:24:25.593]                       }
[13:24:25.593]                     }
[13:24:25.593]                     sendCondition <<- function(cond) NULL
[13:24:25.593]                   }
[13:24:25.593]                 })
[13:24:25.593]                 withCallingHandlers({
[13:24:25.593]                   {
[13:24:25.593]                     Sys.sleep(0.5)
[13:24:25.593]                     list(a = 1, b = 42L)
[13:24:25.593]                   }
[13:24:25.593]                 }, immediateCondition = function(cond) {
[13:24:25.593]                   sendCondition <- ...future.makeSendCondition()
[13:24:25.593]                   sendCondition(cond)
[13:24:25.593]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:25.593]                   {
[13:24:25.593]                     inherits <- base::inherits
[13:24:25.593]                     invokeRestart <- base::invokeRestart
[13:24:25.593]                     is.null <- base::is.null
[13:24:25.593]                     muffled <- FALSE
[13:24:25.593]                     if (inherits(cond, "message")) {
[13:24:25.593]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:25.593]                       if (muffled) 
[13:24:25.593]                         invokeRestart("muffleMessage")
[13:24:25.593]                     }
[13:24:25.593]                     else if (inherits(cond, "warning")) {
[13:24:25.593]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:25.593]                       if (muffled) 
[13:24:25.593]                         invokeRestart("muffleWarning")
[13:24:25.593]                     }
[13:24:25.593]                     else if (inherits(cond, "condition")) {
[13:24:25.593]                       if (!is.null(pattern)) {
[13:24:25.593]                         computeRestarts <- base::computeRestarts
[13:24:25.593]                         grepl <- base::grepl
[13:24:25.593]                         restarts <- computeRestarts(cond)
[13:24:25.593]                         for (restart in restarts) {
[13:24:25.593]                           name <- restart$name
[13:24:25.593]                           if (is.null(name)) 
[13:24:25.593]                             next
[13:24:25.593]                           if (!grepl(pattern, name)) 
[13:24:25.593]                             next
[13:24:25.593]                           invokeRestart(restart)
[13:24:25.593]                           muffled <- TRUE
[13:24:25.593]                           break
[13:24:25.593]                         }
[13:24:25.593]                       }
[13:24:25.593]                     }
[13:24:25.593]                     invisible(muffled)
[13:24:25.593]                   }
[13:24:25.593]                   muffleCondition(cond)
[13:24:25.593]                 })
[13:24:25.593]             }))
[13:24:25.593]             future::FutureResult(value = ...future.value$value, 
[13:24:25.593]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:25.593]                   ...future.rng), globalenv = if (FALSE) 
[13:24:25.593]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:25.593]                     ...future.globalenv.names))
[13:24:25.593]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:25.593]         }, condition = base::local({
[13:24:25.593]             c <- base::c
[13:24:25.593]             inherits <- base::inherits
[13:24:25.593]             invokeRestart <- base::invokeRestart
[13:24:25.593]             length <- base::length
[13:24:25.593]             list <- base::list
[13:24:25.593]             seq.int <- base::seq.int
[13:24:25.593]             signalCondition <- base::signalCondition
[13:24:25.593]             sys.calls <- base::sys.calls
[13:24:25.593]             `[[` <- base::`[[`
[13:24:25.593]             `+` <- base::`+`
[13:24:25.593]             `<<-` <- base::`<<-`
[13:24:25.593]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:25.593]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:25.593]                   3L)]
[13:24:25.593]             }
[13:24:25.593]             function(cond) {
[13:24:25.593]                 is_error <- inherits(cond, "error")
[13:24:25.593]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:25.593]                   NULL)
[13:24:25.593]                 if (is_error) {
[13:24:25.593]                   sessionInformation <- function() {
[13:24:25.593]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:25.593]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:25.593]                       search = base::search(), system = base::Sys.info())
[13:24:25.593]                   }
[13:24:25.593]                   ...future.conditions[[length(...future.conditions) + 
[13:24:25.593]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:25.593]                     cond$call), session = sessionInformation(), 
[13:24:25.593]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:25.593]                   signalCondition(cond)
[13:24:25.593]                 }
[13:24:25.593]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:25.593]                 "immediateCondition"))) {
[13:24:25.593]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:25.593]                   ...future.conditions[[length(...future.conditions) + 
[13:24:25.593]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:25.593]                   if (TRUE && !signal) {
[13:24:25.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:25.593]                     {
[13:24:25.593]                       inherits <- base::inherits
[13:24:25.593]                       invokeRestart <- base::invokeRestart
[13:24:25.593]                       is.null <- base::is.null
[13:24:25.593]                       muffled <- FALSE
[13:24:25.593]                       if (inherits(cond, "message")) {
[13:24:25.593]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:25.593]                         if (muffled) 
[13:24:25.593]                           invokeRestart("muffleMessage")
[13:24:25.593]                       }
[13:24:25.593]                       else if (inherits(cond, "warning")) {
[13:24:25.593]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:25.593]                         if (muffled) 
[13:24:25.593]                           invokeRestart("muffleWarning")
[13:24:25.593]                       }
[13:24:25.593]                       else if (inherits(cond, "condition")) {
[13:24:25.593]                         if (!is.null(pattern)) {
[13:24:25.593]                           computeRestarts <- base::computeRestarts
[13:24:25.593]                           grepl <- base::grepl
[13:24:25.593]                           restarts <- computeRestarts(cond)
[13:24:25.593]                           for (restart in restarts) {
[13:24:25.593]                             name <- restart$name
[13:24:25.593]                             if (is.null(name)) 
[13:24:25.593]                               next
[13:24:25.593]                             if (!grepl(pattern, name)) 
[13:24:25.593]                               next
[13:24:25.593]                             invokeRestart(restart)
[13:24:25.593]                             muffled <- TRUE
[13:24:25.593]                             break
[13:24:25.593]                           }
[13:24:25.593]                         }
[13:24:25.593]                       }
[13:24:25.593]                       invisible(muffled)
[13:24:25.593]                     }
[13:24:25.593]                     muffleCondition(cond, pattern = "^muffle")
[13:24:25.593]                   }
[13:24:25.593]                 }
[13:24:25.593]                 else {
[13:24:25.593]                   if (TRUE) {
[13:24:25.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:25.593]                     {
[13:24:25.593]                       inherits <- base::inherits
[13:24:25.593]                       invokeRestart <- base::invokeRestart
[13:24:25.593]                       is.null <- base::is.null
[13:24:25.593]                       muffled <- FALSE
[13:24:25.593]                       if (inherits(cond, "message")) {
[13:24:25.593]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:25.593]                         if (muffled) 
[13:24:25.593]                           invokeRestart("muffleMessage")
[13:24:25.593]                       }
[13:24:25.593]                       else if (inherits(cond, "warning")) {
[13:24:25.593]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:25.593]                         if (muffled) 
[13:24:25.593]                           invokeRestart("muffleWarning")
[13:24:25.593]                       }
[13:24:25.593]                       else if (inherits(cond, "condition")) {
[13:24:25.593]                         if (!is.null(pattern)) {
[13:24:25.593]                           computeRestarts <- base::computeRestarts
[13:24:25.593]                           grepl <- base::grepl
[13:24:25.593]                           restarts <- computeRestarts(cond)
[13:24:25.593]                           for (restart in restarts) {
[13:24:25.593]                             name <- restart$name
[13:24:25.593]                             if (is.null(name)) 
[13:24:25.593]                               next
[13:24:25.593]                             if (!grepl(pattern, name)) 
[13:24:25.593]                               next
[13:24:25.593]                             invokeRestart(restart)
[13:24:25.593]                             muffled <- TRUE
[13:24:25.593]                             break
[13:24:25.593]                           }
[13:24:25.593]                         }
[13:24:25.593]                       }
[13:24:25.593]                       invisible(muffled)
[13:24:25.593]                     }
[13:24:25.593]                     muffleCondition(cond, pattern = "^muffle")
[13:24:25.593]                   }
[13:24:25.593]                 }
[13:24:25.593]             }
[13:24:25.593]         }))
[13:24:25.593]     }, error = function(ex) {
[13:24:25.593]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:25.593]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:25.593]                 ...future.rng), started = ...future.startTime, 
[13:24:25.593]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:25.593]             version = "1.8"), class = "FutureResult")
[13:24:25.593]     }, finally = {
[13:24:25.593]         if (!identical(...future.workdir, getwd())) 
[13:24:25.593]             setwd(...future.workdir)
[13:24:25.593]         {
[13:24:25.593]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:25.593]                 ...future.oldOptions$nwarnings <- NULL
[13:24:25.593]             }
[13:24:25.593]             base::options(...future.oldOptions)
[13:24:25.593]             if (.Platform$OS.type == "windows") {
[13:24:25.593]                 old_names <- names(...future.oldEnvVars)
[13:24:25.593]                 envs <- base::Sys.getenv()
[13:24:25.593]                 names <- names(envs)
[13:24:25.593]                 common <- intersect(names, old_names)
[13:24:25.593]                 added <- setdiff(names, old_names)
[13:24:25.593]                 removed <- setdiff(old_names, names)
[13:24:25.593]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:25.593]                   envs[common]]
[13:24:25.593]                 NAMES <- toupper(changed)
[13:24:25.593]                 args <- list()
[13:24:25.593]                 for (kk in seq_along(NAMES)) {
[13:24:25.593]                   name <- changed[[kk]]
[13:24:25.593]                   NAME <- NAMES[[kk]]
[13:24:25.593]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:25.593]                     next
[13:24:25.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:25.593]                 }
[13:24:25.593]                 NAMES <- toupper(added)
[13:24:25.593]                 for (kk in seq_along(NAMES)) {
[13:24:25.593]                   name <- added[[kk]]
[13:24:25.593]                   NAME <- NAMES[[kk]]
[13:24:25.593]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:25.593]                     next
[13:24:25.593]                   args[[name]] <- ""
[13:24:25.593]                 }
[13:24:25.593]                 NAMES <- toupper(removed)
[13:24:25.593]                 for (kk in seq_along(NAMES)) {
[13:24:25.593]                   name <- removed[[kk]]
[13:24:25.593]                   NAME <- NAMES[[kk]]
[13:24:25.593]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:25.593]                     next
[13:24:25.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:25.593]                 }
[13:24:25.593]                 if (length(args) > 0) 
[13:24:25.593]                   base::do.call(base::Sys.setenv, args = args)
[13:24:25.593]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:25.593]             }
[13:24:25.593]             else {
[13:24:25.593]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:25.593]             }
[13:24:25.593]             {
[13:24:25.593]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:25.593]                   0L) {
[13:24:25.593]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:25.593]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:25.593]                   base::options(opts)
[13:24:25.593]                 }
[13:24:25.593]                 {
[13:24:25.593]                   {
[13:24:25.593]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:25.593]                     NULL
[13:24:25.593]                   }
[13:24:25.593]                   options(future.plan = NULL)
[13:24:25.593]                   if (is.na(NA_character_)) 
[13:24:25.593]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:25.593]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:25.593]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:25.593]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:25.593]                     envir = parent.frame()) 
[13:24:25.593]                   {
[13:24:25.593]                     if (is.function(workers)) 
[13:24:25.593]                       workers <- workers()
[13:24:25.593]                     workers <- structure(as.integer(workers), 
[13:24:25.593]                       class = class(workers))
[13:24:25.593]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:25.593]                       workers >= 1)
[13:24:25.593]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:25.593]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:25.593]                     }
[13:24:25.593]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:25.593]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:25.593]                       envir = envir)
[13:24:25.593]                     if (!future$lazy) 
[13:24:25.593]                       future <- run(future)
[13:24:25.593]                     invisible(future)
[13:24:25.593]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:25.593]                 }
[13:24:25.593]             }
[13:24:25.593]         }
[13:24:25.593]     })
[13:24:25.593]     if (TRUE) {
[13:24:25.593]         base::sink(type = "output", split = FALSE)
[13:24:25.593]         if (TRUE) {
[13:24:25.593]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:25.593]         }
[13:24:25.593]         else {
[13:24:25.593]             ...future.result["stdout"] <- base::list(NULL)
[13:24:25.593]         }
[13:24:25.593]         base::close(...future.stdout)
[13:24:25.593]         ...future.stdout <- NULL
[13:24:25.593]     }
[13:24:25.593]     ...future.result$conditions <- ...future.conditions
[13:24:25.593]     ...future.result$finished <- base::Sys.time()
[13:24:25.593]     ...future.result
[13:24:25.593] }
[13:24:25.597] MultisessionFuture started
[13:24:25.597] - Launch lazy future ... done
[13:24:25.597] run() for ‘MultisessionFuture’ ... done
[13:24:26.146] receiveMessageFromWorker() for ClusterFuture ...
[13:24:26.146] - Validating connection of MultisessionFuture
[13:24:26.147] - received message: FutureResult
[13:24:26.147] - Received FutureResult
[13:24:26.147] - Erased future from FutureRegistry
[13:24:26.148] result() for ClusterFuture ...
[13:24:26.148] - result already collected: FutureResult
[13:24:26.148] result() for ClusterFuture ... done
[13:24:26.148] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:26.148] A MultisessionFuture was resolved (result was not collected)
[13:24:26.148] getGlobalsAndPackages() ...
[13:24:26.148] Searching for globals...
[13:24:26.150] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:26.150] Searching for globals ... DONE
[13:24:26.150] Resolving globals: FALSE
[13:24:26.150] 
[13:24:26.151] 
[13:24:26.151] getGlobalsAndPackages() ... DONE
[13:24:26.151] run() for ‘Future’ ...
[13:24:26.151] - state: ‘created’
[13:24:26.151] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:26.166] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:26.166] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:26.166]   - Field: ‘node’
[13:24:26.166]   - Field: ‘label’
[13:24:26.166]   - Field: ‘local’
[13:24:26.166]   - Field: ‘owner’
[13:24:26.167]   - Field: ‘envir’
[13:24:26.167]   - Field: ‘workers’
[13:24:26.167]   - Field: ‘packages’
[13:24:26.167]   - Field: ‘gc’
[13:24:26.167]   - Field: ‘conditions’
[13:24:26.167]   - Field: ‘persistent’
[13:24:26.167]   - Field: ‘expr’
[13:24:26.167]   - Field: ‘uuid’
[13:24:26.167]   - Field: ‘seed’
[13:24:26.168]   - Field: ‘version’
[13:24:26.168]   - Field: ‘result’
[13:24:26.168]   - Field: ‘asynchronous’
[13:24:26.168]   - Field: ‘calls’
[13:24:26.168]   - Field: ‘globals’
[13:24:26.168]   - Field: ‘stdout’
[13:24:26.168]   - Field: ‘earlySignal’
[13:24:26.168]   - Field: ‘lazy’
[13:24:26.169]   - Field: ‘state’
[13:24:26.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:26.169] - Launch lazy future ...
[13:24:26.169] Packages needed by the future expression (n = 0): <none>
[13:24:26.169] Packages needed by future strategies (n = 0): <none>
[13:24:26.170] {
[13:24:26.170]     {
[13:24:26.170]         {
[13:24:26.170]             ...future.startTime <- base::Sys.time()
[13:24:26.170]             {
[13:24:26.170]                 {
[13:24:26.170]                   {
[13:24:26.170]                     {
[13:24:26.170]                       base::local({
[13:24:26.170]                         has_future <- base::requireNamespace("future", 
[13:24:26.170]                           quietly = TRUE)
[13:24:26.170]                         if (has_future) {
[13:24:26.170]                           ns <- base::getNamespace("future")
[13:24:26.170]                           version <- ns[[".package"]][["version"]]
[13:24:26.170]                           if (is.null(version)) 
[13:24:26.170]                             version <- utils::packageVersion("future")
[13:24:26.170]                         }
[13:24:26.170]                         else {
[13:24:26.170]                           version <- NULL
[13:24:26.170]                         }
[13:24:26.170]                         if (!has_future || version < "1.8.0") {
[13:24:26.170]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:26.170]                             "", base::R.version$version.string), 
[13:24:26.170]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:26.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:26.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:26.170]                               "release", "version")], collapse = " "), 
[13:24:26.170]                             hostname = base::Sys.info()[["nodename"]])
[13:24:26.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:26.170]                             info)
[13:24:26.170]                           info <- base::paste(info, collapse = "; ")
[13:24:26.170]                           if (!has_future) {
[13:24:26.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:26.170]                               info)
[13:24:26.170]                           }
[13:24:26.170]                           else {
[13:24:26.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:26.170]                               info, version)
[13:24:26.170]                           }
[13:24:26.170]                           base::stop(msg)
[13:24:26.170]                         }
[13:24:26.170]                       })
[13:24:26.170]                     }
[13:24:26.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:26.170]                     base::options(mc.cores = 1L)
[13:24:26.170]                   }
[13:24:26.170]                   options(future.plan = NULL)
[13:24:26.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:26.170]                 }
[13:24:26.170]                 ...future.workdir <- getwd()
[13:24:26.170]             }
[13:24:26.170]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:26.170]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:26.170]         }
[13:24:26.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:26.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:26.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:26.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:26.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:26.170]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:26.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:26.170]             base::names(...future.oldOptions))
[13:24:26.170]     }
[13:24:26.170]     if (FALSE) {
[13:24:26.170]     }
[13:24:26.170]     else {
[13:24:26.170]         if (TRUE) {
[13:24:26.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:26.170]                 open = "w")
[13:24:26.170]         }
[13:24:26.170]         else {
[13:24:26.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:26.170]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:26.170]         }
[13:24:26.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:26.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:26.170]             base::sink(type = "output", split = FALSE)
[13:24:26.170]             base::close(...future.stdout)
[13:24:26.170]         }, add = TRUE)
[13:24:26.170]     }
[13:24:26.170]     ...future.frame <- base::sys.nframe()
[13:24:26.170]     ...future.conditions <- base::list()
[13:24:26.170]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:26.170]     if (FALSE) {
[13:24:26.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:26.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:26.170]     }
[13:24:26.170]     ...future.result <- base::tryCatch({
[13:24:26.170]         base::withCallingHandlers({
[13:24:26.170]             ...future.value <- base::withVisible(base::local({
[13:24:26.170]                 ...future.makeSendCondition <- base::local({
[13:24:26.170]                   sendCondition <- NULL
[13:24:26.170]                   function(frame = 1L) {
[13:24:26.170]                     if (is.function(sendCondition)) 
[13:24:26.170]                       return(sendCondition)
[13:24:26.170]                     ns <- getNamespace("parallel")
[13:24:26.170]                     if (exists("sendData", mode = "function", 
[13:24:26.170]                       envir = ns)) {
[13:24:26.170]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:26.170]                         envir = ns)
[13:24:26.170]                       envir <- sys.frame(frame)
[13:24:26.170]                       master <- NULL
[13:24:26.170]                       while (!identical(envir, .GlobalEnv) && 
[13:24:26.170]                         !identical(envir, emptyenv())) {
[13:24:26.170]                         if (exists("master", mode = "list", envir = envir, 
[13:24:26.170]                           inherits = FALSE)) {
[13:24:26.170]                           master <- get("master", mode = "list", 
[13:24:26.170]                             envir = envir, inherits = FALSE)
[13:24:26.170]                           if (inherits(master, c("SOCKnode", 
[13:24:26.170]                             "SOCK0node"))) {
[13:24:26.170]                             sendCondition <<- function(cond) {
[13:24:26.170]                               data <- list(type = "VALUE", value = cond, 
[13:24:26.170]                                 success = TRUE)
[13:24:26.170]                               parallel_sendData(master, data)
[13:24:26.170]                             }
[13:24:26.170]                             return(sendCondition)
[13:24:26.170]                           }
[13:24:26.170]                         }
[13:24:26.170]                         frame <- frame + 1L
[13:24:26.170]                         envir <- sys.frame(frame)
[13:24:26.170]                       }
[13:24:26.170]                     }
[13:24:26.170]                     sendCondition <<- function(cond) NULL
[13:24:26.170]                   }
[13:24:26.170]                 })
[13:24:26.170]                 withCallingHandlers({
[13:24:26.170]                   {
[13:24:26.170]                     Sys.sleep(0.5)
[13:24:26.170]                     list(a = 1, b = 42L)
[13:24:26.170]                   }
[13:24:26.170]                 }, immediateCondition = function(cond) {
[13:24:26.170]                   sendCondition <- ...future.makeSendCondition()
[13:24:26.170]                   sendCondition(cond)
[13:24:26.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.170]                   {
[13:24:26.170]                     inherits <- base::inherits
[13:24:26.170]                     invokeRestart <- base::invokeRestart
[13:24:26.170]                     is.null <- base::is.null
[13:24:26.170]                     muffled <- FALSE
[13:24:26.170]                     if (inherits(cond, "message")) {
[13:24:26.170]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:26.170]                       if (muffled) 
[13:24:26.170]                         invokeRestart("muffleMessage")
[13:24:26.170]                     }
[13:24:26.170]                     else if (inherits(cond, "warning")) {
[13:24:26.170]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:26.170]                       if (muffled) 
[13:24:26.170]                         invokeRestart("muffleWarning")
[13:24:26.170]                     }
[13:24:26.170]                     else if (inherits(cond, "condition")) {
[13:24:26.170]                       if (!is.null(pattern)) {
[13:24:26.170]                         computeRestarts <- base::computeRestarts
[13:24:26.170]                         grepl <- base::grepl
[13:24:26.170]                         restarts <- computeRestarts(cond)
[13:24:26.170]                         for (restart in restarts) {
[13:24:26.170]                           name <- restart$name
[13:24:26.170]                           if (is.null(name)) 
[13:24:26.170]                             next
[13:24:26.170]                           if (!grepl(pattern, name)) 
[13:24:26.170]                             next
[13:24:26.170]                           invokeRestart(restart)
[13:24:26.170]                           muffled <- TRUE
[13:24:26.170]                           break
[13:24:26.170]                         }
[13:24:26.170]                       }
[13:24:26.170]                     }
[13:24:26.170]                     invisible(muffled)
[13:24:26.170]                   }
[13:24:26.170]                   muffleCondition(cond)
[13:24:26.170]                 })
[13:24:26.170]             }))
[13:24:26.170]             future::FutureResult(value = ...future.value$value, 
[13:24:26.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.170]                   ...future.rng), globalenv = if (FALSE) 
[13:24:26.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:26.170]                     ...future.globalenv.names))
[13:24:26.170]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:26.170]         }, condition = base::local({
[13:24:26.170]             c <- base::c
[13:24:26.170]             inherits <- base::inherits
[13:24:26.170]             invokeRestart <- base::invokeRestart
[13:24:26.170]             length <- base::length
[13:24:26.170]             list <- base::list
[13:24:26.170]             seq.int <- base::seq.int
[13:24:26.170]             signalCondition <- base::signalCondition
[13:24:26.170]             sys.calls <- base::sys.calls
[13:24:26.170]             `[[` <- base::`[[`
[13:24:26.170]             `+` <- base::`+`
[13:24:26.170]             `<<-` <- base::`<<-`
[13:24:26.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:26.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:26.170]                   3L)]
[13:24:26.170]             }
[13:24:26.170]             function(cond) {
[13:24:26.170]                 is_error <- inherits(cond, "error")
[13:24:26.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:26.170]                   NULL)
[13:24:26.170]                 if (is_error) {
[13:24:26.170]                   sessionInformation <- function() {
[13:24:26.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:26.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:26.170]                       search = base::search(), system = base::Sys.info())
[13:24:26.170]                   }
[13:24:26.170]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:26.170]                     cond$call), session = sessionInformation(), 
[13:24:26.170]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:26.170]                   signalCondition(cond)
[13:24:26.170]                 }
[13:24:26.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:26.170]                 "immediateCondition"))) {
[13:24:26.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:26.170]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:26.170]                   if (TRUE && !signal) {
[13:24:26.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.170]                     {
[13:24:26.170]                       inherits <- base::inherits
[13:24:26.170]                       invokeRestart <- base::invokeRestart
[13:24:26.170]                       is.null <- base::is.null
[13:24:26.170]                       muffled <- FALSE
[13:24:26.170]                       if (inherits(cond, "message")) {
[13:24:26.170]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.170]                         if (muffled) 
[13:24:26.170]                           invokeRestart("muffleMessage")
[13:24:26.170]                       }
[13:24:26.170]                       else if (inherits(cond, "warning")) {
[13:24:26.170]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.170]                         if (muffled) 
[13:24:26.170]                           invokeRestart("muffleWarning")
[13:24:26.170]                       }
[13:24:26.170]                       else if (inherits(cond, "condition")) {
[13:24:26.170]                         if (!is.null(pattern)) {
[13:24:26.170]                           computeRestarts <- base::computeRestarts
[13:24:26.170]                           grepl <- base::grepl
[13:24:26.170]                           restarts <- computeRestarts(cond)
[13:24:26.170]                           for (restart in restarts) {
[13:24:26.170]                             name <- restart$name
[13:24:26.170]                             if (is.null(name)) 
[13:24:26.170]                               next
[13:24:26.170]                             if (!grepl(pattern, name)) 
[13:24:26.170]                               next
[13:24:26.170]                             invokeRestart(restart)
[13:24:26.170]                             muffled <- TRUE
[13:24:26.170]                             break
[13:24:26.170]                           }
[13:24:26.170]                         }
[13:24:26.170]                       }
[13:24:26.170]                       invisible(muffled)
[13:24:26.170]                     }
[13:24:26.170]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.170]                   }
[13:24:26.170]                 }
[13:24:26.170]                 else {
[13:24:26.170]                   if (TRUE) {
[13:24:26.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.170]                     {
[13:24:26.170]                       inherits <- base::inherits
[13:24:26.170]                       invokeRestart <- base::invokeRestart
[13:24:26.170]                       is.null <- base::is.null
[13:24:26.170]                       muffled <- FALSE
[13:24:26.170]                       if (inherits(cond, "message")) {
[13:24:26.170]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.170]                         if (muffled) 
[13:24:26.170]                           invokeRestart("muffleMessage")
[13:24:26.170]                       }
[13:24:26.170]                       else if (inherits(cond, "warning")) {
[13:24:26.170]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.170]                         if (muffled) 
[13:24:26.170]                           invokeRestart("muffleWarning")
[13:24:26.170]                       }
[13:24:26.170]                       else if (inherits(cond, "condition")) {
[13:24:26.170]                         if (!is.null(pattern)) {
[13:24:26.170]                           computeRestarts <- base::computeRestarts
[13:24:26.170]                           grepl <- base::grepl
[13:24:26.170]                           restarts <- computeRestarts(cond)
[13:24:26.170]                           for (restart in restarts) {
[13:24:26.170]                             name <- restart$name
[13:24:26.170]                             if (is.null(name)) 
[13:24:26.170]                               next
[13:24:26.170]                             if (!grepl(pattern, name)) 
[13:24:26.170]                               next
[13:24:26.170]                             invokeRestart(restart)
[13:24:26.170]                             muffled <- TRUE
[13:24:26.170]                             break
[13:24:26.170]                           }
[13:24:26.170]                         }
[13:24:26.170]                       }
[13:24:26.170]                       invisible(muffled)
[13:24:26.170]                     }
[13:24:26.170]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.170]                   }
[13:24:26.170]                 }
[13:24:26.170]             }
[13:24:26.170]         }))
[13:24:26.170]     }, error = function(ex) {
[13:24:26.170]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:26.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.170]                 ...future.rng), started = ...future.startTime, 
[13:24:26.170]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:26.170]             version = "1.8"), class = "FutureResult")
[13:24:26.170]     }, finally = {
[13:24:26.170]         if (!identical(...future.workdir, getwd())) 
[13:24:26.170]             setwd(...future.workdir)
[13:24:26.170]         {
[13:24:26.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:26.170]                 ...future.oldOptions$nwarnings <- NULL
[13:24:26.170]             }
[13:24:26.170]             base::options(...future.oldOptions)
[13:24:26.170]             if (.Platform$OS.type == "windows") {
[13:24:26.170]                 old_names <- names(...future.oldEnvVars)
[13:24:26.170]                 envs <- base::Sys.getenv()
[13:24:26.170]                 names <- names(envs)
[13:24:26.170]                 common <- intersect(names, old_names)
[13:24:26.170]                 added <- setdiff(names, old_names)
[13:24:26.170]                 removed <- setdiff(old_names, names)
[13:24:26.170]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:26.170]                   envs[common]]
[13:24:26.170]                 NAMES <- toupper(changed)
[13:24:26.170]                 args <- list()
[13:24:26.170]                 for (kk in seq_along(NAMES)) {
[13:24:26.170]                   name <- changed[[kk]]
[13:24:26.170]                   NAME <- NAMES[[kk]]
[13:24:26.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.170]                     next
[13:24:26.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.170]                 }
[13:24:26.170]                 NAMES <- toupper(added)
[13:24:26.170]                 for (kk in seq_along(NAMES)) {
[13:24:26.170]                   name <- added[[kk]]
[13:24:26.170]                   NAME <- NAMES[[kk]]
[13:24:26.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.170]                     next
[13:24:26.170]                   args[[name]] <- ""
[13:24:26.170]                 }
[13:24:26.170]                 NAMES <- toupper(removed)
[13:24:26.170]                 for (kk in seq_along(NAMES)) {
[13:24:26.170]                   name <- removed[[kk]]
[13:24:26.170]                   NAME <- NAMES[[kk]]
[13:24:26.170]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.170]                     next
[13:24:26.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.170]                 }
[13:24:26.170]                 if (length(args) > 0) 
[13:24:26.170]                   base::do.call(base::Sys.setenv, args = args)
[13:24:26.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:26.170]             }
[13:24:26.170]             else {
[13:24:26.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:26.170]             }
[13:24:26.170]             {
[13:24:26.170]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:26.170]                   0L) {
[13:24:26.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:26.170]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:26.170]                   base::options(opts)
[13:24:26.170]                 }
[13:24:26.170]                 {
[13:24:26.170]                   {
[13:24:26.170]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:26.170]                     NULL
[13:24:26.170]                   }
[13:24:26.170]                   options(future.plan = NULL)
[13:24:26.170]                   if (is.na(NA_character_)) 
[13:24:26.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:26.170]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:26.170]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:26.170]                     envir = parent.frame()) 
[13:24:26.170]                   {
[13:24:26.170]                     if (is.function(workers)) 
[13:24:26.170]                       workers <- workers()
[13:24:26.170]                     workers <- structure(as.integer(workers), 
[13:24:26.170]                       class = class(workers))
[13:24:26.170]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:26.170]                       workers >= 1)
[13:24:26.170]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:26.170]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:26.170]                     }
[13:24:26.170]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:26.170]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:26.170]                       envir = envir)
[13:24:26.170]                     if (!future$lazy) 
[13:24:26.170]                       future <- run(future)
[13:24:26.170]                     invisible(future)
[13:24:26.170]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:26.170]                 }
[13:24:26.170]             }
[13:24:26.170]         }
[13:24:26.170]     })
[13:24:26.170]     if (TRUE) {
[13:24:26.170]         base::sink(type = "output", split = FALSE)
[13:24:26.170]         if (TRUE) {
[13:24:26.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:26.170]         }
[13:24:26.170]         else {
[13:24:26.170]             ...future.result["stdout"] <- base::list(NULL)
[13:24:26.170]         }
[13:24:26.170]         base::close(...future.stdout)
[13:24:26.170]         ...future.stdout <- NULL
[13:24:26.170]     }
[13:24:26.170]     ...future.result$conditions <- ...future.conditions
[13:24:26.170]     ...future.result$finished <- base::Sys.time()
[13:24:26.170]     ...future.result
[13:24:26.170] }
[13:24:26.173] MultisessionFuture started
[13:24:26.173] - Launch lazy future ... done
[13:24:26.173] run() for ‘MultisessionFuture’ ... done
[13:24:26.722] receiveMessageFromWorker() for ClusterFuture ...
[13:24:26.723] - Validating connection of MultisessionFuture
[13:24:26.723] - received message: FutureResult
[13:24:26.723] - Received FutureResult
[13:24:26.723] - Erased future from FutureRegistry
[13:24:26.723] result() for ClusterFuture ...
[13:24:26.723] - result already collected: FutureResult
[13:24:26.723] result() for ClusterFuture ... done
[13:24:26.724] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:26.724] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:24:26.724] getGlobalsAndPackages() ...
[13:24:26.724] Searching for globals...
[13:24:26.725] - globals found: [2] ‘list’, ‘stop’
[13:24:26.725] Searching for globals ... DONE
[13:24:26.725] Resolving globals: FALSE
[13:24:26.726] 
[13:24:26.726] 
[13:24:26.726] getGlobalsAndPackages() ... DONE
[13:24:26.726] run() for ‘Future’ ...
[13:24:26.726] - state: ‘created’
[13:24:26.726] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:26.743] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:26.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:26.743]   - Field: ‘node’
[13:24:26.743]   - Field: ‘label’
[13:24:26.743]   - Field: ‘local’
[13:24:26.743]   - Field: ‘owner’
[13:24:26.743]   - Field: ‘envir’
[13:24:26.743]   - Field: ‘workers’
[13:24:26.743]   - Field: ‘packages’
[13:24:26.744]   - Field: ‘gc’
[13:24:26.744]   - Field: ‘conditions’
[13:24:26.744]   - Field: ‘persistent’
[13:24:26.744]   - Field: ‘expr’
[13:24:26.744]   - Field: ‘uuid’
[13:24:26.744]   - Field: ‘seed’
[13:24:26.744]   - Field: ‘version’
[13:24:26.744]   - Field: ‘result’
[13:24:26.744]   - Field: ‘asynchronous’
[13:24:26.744]   - Field: ‘calls’
[13:24:26.745]   - Field: ‘globals’
[13:24:26.745]   - Field: ‘stdout’
[13:24:26.745]   - Field: ‘earlySignal’
[13:24:26.745]   - Field: ‘lazy’
[13:24:26.745]   - Field: ‘state’
[13:24:26.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:26.745] - Launch lazy future ...
[13:24:26.745] Packages needed by the future expression (n = 0): <none>
[13:24:26.745] Packages needed by future strategies (n = 0): <none>
[13:24:26.746] {
[13:24:26.746]     {
[13:24:26.746]         {
[13:24:26.746]             ...future.startTime <- base::Sys.time()
[13:24:26.746]             {
[13:24:26.746]                 {
[13:24:26.746]                   {
[13:24:26.746]                     {
[13:24:26.746]                       base::local({
[13:24:26.746]                         has_future <- base::requireNamespace("future", 
[13:24:26.746]                           quietly = TRUE)
[13:24:26.746]                         if (has_future) {
[13:24:26.746]                           ns <- base::getNamespace("future")
[13:24:26.746]                           version <- ns[[".package"]][["version"]]
[13:24:26.746]                           if (is.null(version)) 
[13:24:26.746]                             version <- utils::packageVersion("future")
[13:24:26.746]                         }
[13:24:26.746]                         else {
[13:24:26.746]                           version <- NULL
[13:24:26.746]                         }
[13:24:26.746]                         if (!has_future || version < "1.8.0") {
[13:24:26.746]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:26.746]                             "", base::R.version$version.string), 
[13:24:26.746]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:26.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:26.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:26.746]                               "release", "version")], collapse = " "), 
[13:24:26.746]                             hostname = base::Sys.info()[["nodename"]])
[13:24:26.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:26.746]                             info)
[13:24:26.746]                           info <- base::paste(info, collapse = "; ")
[13:24:26.746]                           if (!has_future) {
[13:24:26.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:26.746]                               info)
[13:24:26.746]                           }
[13:24:26.746]                           else {
[13:24:26.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:26.746]                               info, version)
[13:24:26.746]                           }
[13:24:26.746]                           base::stop(msg)
[13:24:26.746]                         }
[13:24:26.746]                       })
[13:24:26.746]                     }
[13:24:26.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:26.746]                     base::options(mc.cores = 1L)
[13:24:26.746]                   }
[13:24:26.746]                   options(future.plan = NULL)
[13:24:26.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:26.746]                 }
[13:24:26.746]                 ...future.workdir <- getwd()
[13:24:26.746]             }
[13:24:26.746]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:26.746]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:26.746]         }
[13:24:26.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:26.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:26.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:26.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:26.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:26.746]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:26.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:26.746]             base::names(...future.oldOptions))
[13:24:26.746]     }
[13:24:26.746]     if (FALSE) {
[13:24:26.746]     }
[13:24:26.746]     else {
[13:24:26.746]         if (TRUE) {
[13:24:26.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:26.746]                 open = "w")
[13:24:26.746]         }
[13:24:26.746]         else {
[13:24:26.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:26.746]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:26.746]         }
[13:24:26.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:26.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:26.746]             base::sink(type = "output", split = FALSE)
[13:24:26.746]             base::close(...future.stdout)
[13:24:26.746]         }, add = TRUE)
[13:24:26.746]     }
[13:24:26.746]     ...future.frame <- base::sys.nframe()
[13:24:26.746]     ...future.conditions <- base::list()
[13:24:26.746]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:26.746]     if (FALSE) {
[13:24:26.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:26.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:26.746]     }
[13:24:26.746]     ...future.result <- base::tryCatch({
[13:24:26.746]         base::withCallingHandlers({
[13:24:26.746]             ...future.value <- base::withVisible(base::local({
[13:24:26.746]                 ...future.makeSendCondition <- base::local({
[13:24:26.746]                   sendCondition <- NULL
[13:24:26.746]                   function(frame = 1L) {
[13:24:26.746]                     if (is.function(sendCondition)) 
[13:24:26.746]                       return(sendCondition)
[13:24:26.746]                     ns <- getNamespace("parallel")
[13:24:26.746]                     if (exists("sendData", mode = "function", 
[13:24:26.746]                       envir = ns)) {
[13:24:26.746]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:26.746]                         envir = ns)
[13:24:26.746]                       envir <- sys.frame(frame)
[13:24:26.746]                       master <- NULL
[13:24:26.746]                       while (!identical(envir, .GlobalEnv) && 
[13:24:26.746]                         !identical(envir, emptyenv())) {
[13:24:26.746]                         if (exists("master", mode = "list", envir = envir, 
[13:24:26.746]                           inherits = FALSE)) {
[13:24:26.746]                           master <- get("master", mode = "list", 
[13:24:26.746]                             envir = envir, inherits = FALSE)
[13:24:26.746]                           if (inherits(master, c("SOCKnode", 
[13:24:26.746]                             "SOCK0node"))) {
[13:24:26.746]                             sendCondition <<- function(cond) {
[13:24:26.746]                               data <- list(type = "VALUE", value = cond, 
[13:24:26.746]                                 success = TRUE)
[13:24:26.746]                               parallel_sendData(master, data)
[13:24:26.746]                             }
[13:24:26.746]                             return(sendCondition)
[13:24:26.746]                           }
[13:24:26.746]                         }
[13:24:26.746]                         frame <- frame + 1L
[13:24:26.746]                         envir <- sys.frame(frame)
[13:24:26.746]                       }
[13:24:26.746]                     }
[13:24:26.746]                     sendCondition <<- function(cond) NULL
[13:24:26.746]                   }
[13:24:26.746]                 })
[13:24:26.746]                 withCallingHandlers({
[13:24:26.746]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:26.746]                 }, immediateCondition = function(cond) {
[13:24:26.746]                   sendCondition <- ...future.makeSendCondition()
[13:24:26.746]                   sendCondition(cond)
[13:24:26.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.746]                   {
[13:24:26.746]                     inherits <- base::inherits
[13:24:26.746]                     invokeRestart <- base::invokeRestart
[13:24:26.746]                     is.null <- base::is.null
[13:24:26.746]                     muffled <- FALSE
[13:24:26.746]                     if (inherits(cond, "message")) {
[13:24:26.746]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:26.746]                       if (muffled) 
[13:24:26.746]                         invokeRestart("muffleMessage")
[13:24:26.746]                     }
[13:24:26.746]                     else if (inherits(cond, "warning")) {
[13:24:26.746]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:26.746]                       if (muffled) 
[13:24:26.746]                         invokeRestart("muffleWarning")
[13:24:26.746]                     }
[13:24:26.746]                     else if (inherits(cond, "condition")) {
[13:24:26.746]                       if (!is.null(pattern)) {
[13:24:26.746]                         computeRestarts <- base::computeRestarts
[13:24:26.746]                         grepl <- base::grepl
[13:24:26.746]                         restarts <- computeRestarts(cond)
[13:24:26.746]                         for (restart in restarts) {
[13:24:26.746]                           name <- restart$name
[13:24:26.746]                           if (is.null(name)) 
[13:24:26.746]                             next
[13:24:26.746]                           if (!grepl(pattern, name)) 
[13:24:26.746]                             next
[13:24:26.746]                           invokeRestart(restart)
[13:24:26.746]                           muffled <- TRUE
[13:24:26.746]                           break
[13:24:26.746]                         }
[13:24:26.746]                       }
[13:24:26.746]                     }
[13:24:26.746]                     invisible(muffled)
[13:24:26.746]                   }
[13:24:26.746]                   muffleCondition(cond)
[13:24:26.746]                 })
[13:24:26.746]             }))
[13:24:26.746]             future::FutureResult(value = ...future.value$value, 
[13:24:26.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.746]                   ...future.rng), globalenv = if (FALSE) 
[13:24:26.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:26.746]                     ...future.globalenv.names))
[13:24:26.746]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:26.746]         }, condition = base::local({
[13:24:26.746]             c <- base::c
[13:24:26.746]             inherits <- base::inherits
[13:24:26.746]             invokeRestart <- base::invokeRestart
[13:24:26.746]             length <- base::length
[13:24:26.746]             list <- base::list
[13:24:26.746]             seq.int <- base::seq.int
[13:24:26.746]             signalCondition <- base::signalCondition
[13:24:26.746]             sys.calls <- base::sys.calls
[13:24:26.746]             `[[` <- base::`[[`
[13:24:26.746]             `+` <- base::`+`
[13:24:26.746]             `<<-` <- base::`<<-`
[13:24:26.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:26.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:26.746]                   3L)]
[13:24:26.746]             }
[13:24:26.746]             function(cond) {
[13:24:26.746]                 is_error <- inherits(cond, "error")
[13:24:26.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:26.746]                   NULL)
[13:24:26.746]                 if (is_error) {
[13:24:26.746]                   sessionInformation <- function() {
[13:24:26.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:26.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:26.746]                       search = base::search(), system = base::Sys.info())
[13:24:26.746]                   }
[13:24:26.746]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:26.746]                     cond$call), session = sessionInformation(), 
[13:24:26.746]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:26.746]                   signalCondition(cond)
[13:24:26.746]                 }
[13:24:26.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:26.746]                 "immediateCondition"))) {
[13:24:26.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:26.746]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:26.746]                   if (TRUE && !signal) {
[13:24:26.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.746]                     {
[13:24:26.746]                       inherits <- base::inherits
[13:24:26.746]                       invokeRestart <- base::invokeRestart
[13:24:26.746]                       is.null <- base::is.null
[13:24:26.746]                       muffled <- FALSE
[13:24:26.746]                       if (inherits(cond, "message")) {
[13:24:26.746]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.746]                         if (muffled) 
[13:24:26.746]                           invokeRestart("muffleMessage")
[13:24:26.746]                       }
[13:24:26.746]                       else if (inherits(cond, "warning")) {
[13:24:26.746]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.746]                         if (muffled) 
[13:24:26.746]                           invokeRestart("muffleWarning")
[13:24:26.746]                       }
[13:24:26.746]                       else if (inherits(cond, "condition")) {
[13:24:26.746]                         if (!is.null(pattern)) {
[13:24:26.746]                           computeRestarts <- base::computeRestarts
[13:24:26.746]                           grepl <- base::grepl
[13:24:26.746]                           restarts <- computeRestarts(cond)
[13:24:26.746]                           for (restart in restarts) {
[13:24:26.746]                             name <- restart$name
[13:24:26.746]                             if (is.null(name)) 
[13:24:26.746]                               next
[13:24:26.746]                             if (!grepl(pattern, name)) 
[13:24:26.746]                               next
[13:24:26.746]                             invokeRestart(restart)
[13:24:26.746]                             muffled <- TRUE
[13:24:26.746]                             break
[13:24:26.746]                           }
[13:24:26.746]                         }
[13:24:26.746]                       }
[13:24:26.746]                       invisible(muffled)
[13:24:26.746]                     }
[13:24:26.746]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.746]                   }
[13:24:26.746]                 }
[13:24:26.746]                 else {
[13:24:26.746]                   if (TRUE) {
[13:24:26.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.746]                     {
[13:24:26.746]                       inherits <- base::inherits
[13:24:26.746]                       invokeRestart <- base::invokeRestart
[13:24:26.746]                       is.null <- base::is.null
[13:24:26.746]                       muffled <- FALSE
[13:24:26.746]                       if (inherits(cond, "message")) {
[13:24:26.746]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.746]                         if (muffled) 
[13:24:26.746]                           invokeRestart("muffleMessage")
[13:24:26.746]                       }
[13:24:26.746]                       else if (inherits(cond, "warning")) {
[13:24:26.746]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.746]                         if (muffled) 
[13:24:26.746]                           invokeRestart("muffleWarning")
[13:24:26.746]                       }
[13:24:26.746]                       else if (inherits(cond, "condition")) {
[13:24:26.746]                         if (!is.null(pattern)) {
[13:24:26.746]                           computeRestarts <- base::computeRestarts
[13:24:26.746]                           grepl <- base::grepl
[13:24:26.746]                           restarts <- computeRestarts(cond)
[13:24:26.746]                           for (restart in restarts) {
[13:24:26.746]                             name <- restart$name
[13:24:26.746]                             if (is.null(name)) 
[13:24:26.746]                               next
[13:24:26.746]                             if (!grepl(pattern, name)) 
[13:24:26.746]                               next
[13:24:26.746]                             invokeRestart(restart)
[13:24:26.746]                             muffled <- TRUE
[13:24:26.746]                             break
[13:24:26.746]                           }
[13:24:26.746]                         }
[13:24:26.746]                       }
[13:24:26.746]                       invisible(muffled)
[13:24:26.746]                     }
[13:24:26.746]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.746]                   }
[13:24:26.746]                 }
[13:24:26.746]             }
[13:24:26.746]         }))
[13:24:26.746]     }, error = function(ex) {
[13:24:26.746]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:26.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.746]                 ...future.rng), started = ...future.startTime, 
[13:24:26.746]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:26.746]             version = "1.8"), class = "FutureResult")
[13:24:26.746]     }, finally = {
[13:24:26.746]         if (!identical(...future.workdir, getwd())) 
[13:24:26.746]             setwd(...future.workdir)
[13:24:26.746]         {
[13:24:26.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:26.746]                 ...future.oldOptions$nwarnings <- NULL
[13:24:26.746]             }
[13:24:26.746]             base::options(...future.oldOptions)
[13:24:26.746]             if (.Platform$OS.type == "windows") {
[13:24:26.746]                 old_names <- names(...future.oldEnvVars)
[13:24:26.746]                 envs <- base::Sys.getenv()
[13:24:26.746]                 names <- names(envs)
[13:24:26.746]                 common <- intersect(names, old_names)
[13:24:26.746]                 added <- setdiff(names, old_names)
[13:24:26.746]                 removed <- setdiff(old_names, names)
[13:24:26.746]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:26.746]                   envs[common]]
[13:24:26.746]                 NAMES <- toupper(changed)
[13:24:26.746]                 args <- list()
[13:24:26.746]                 for (kk in seq_along(NAMES)) {
[13:24:26.746]                   name <- changed[[kk]]
[13:24:26.746]                   NAME <- NAMES[[kk]]
[13:24:26.746]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.746]                     next
[13:24:26.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.746]                 }
[13:24:26.746]                 NAMES <- toupper(added)
[13:24:26.746]                 for (kk in seq_along(NAMES)) {
[13:24:26.746]                   name <- added[[kk]]
[13:24:26.746]                   NAME <- NAMES[[kk]]
[13:24:26.746]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.746]                     next
[13:24:26.746]                   args[[name]] <- ""
[13:24:26.746]                 }
[13:24:26.746]                 NAMES <- toupper(removed)
[13:24:26.746]                 for (kk in seq_along(NAMES)) {
[13:24:26.746]                   name <- removed[[kk]]
[13:24:26.746]                   NAME <- NAMES[[kk]]
[13:24:26.746]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.746]                     next
[13:24:26.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.746]                 }
[13:24:26.746]                 if (length(args) > 0) 
[13:24:26.746]                   base::do.call(base::Sys.setenv, args = args)
[13:24:26.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:26.746]             }
[13:24:26.746]             else {
[13:24:26.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:26.746]             }
[13:24:26.746]             {
[13:24:26.746]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:26.746]                   0L) {
[13:24:26.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:26.746]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:26.746]                   base::options(opts)
[13:24:26.746]                 }
[13:24:26.746]                 {
[13:24:26.746]                   {
[13:24:26.746]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:26.746]                     NULL
[13:24:26.746]                   }
[13:24:26.746]                   options(future.plan = NULL)
[13:24:26.746]                   if (is.na(NA_character_)) 
[13:24:26.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:26.746]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:26.746]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:26.746]                     envir = parent.frame()) 
[13:24:26.746]                   {
[13:24:26.746]                     if (is.function(workers)) 
[13:24:26.746]                       workers <- workers()
[13:24:26.746]                     workers <- structure(as.integer(workers), 
[13:24:26.746]                       class = class(workers))
[13:24:26.746]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:26.746]                       workers >= 1)
[13:24:26.746]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:26.746]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:26.746]                     }
[13:24:26.746]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:26.746]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:26.746]                       envir = envir)
[13:24:26.746]                     if (!future$lazy) 
[13:24:26.746]                       future <- run(future)
[13:24:26.746]                     invisible(future)
[13:24:26.746]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:26.746]                 }
[13:24:26.746]             }
[13:24:26.746]         }
[13:24:26.746]     })
[13:24:26.746]     if (TRUE) {
[13:24:26.746]         base::sink(type = "output", split = FALSE)
[13:24:26.746]         if (TRUE) {
[13:24:26.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:26.746]         }
[13:24:26.746]         else {
[13:24:26.746]             ...future.result["stdout"] <- base::list(NULL)
[13:24:26.746]         }
[13:24:26.746]         base::close(...future.stdout)
[13:24:26.746]         ...future.stdout <- NULL
[13:24:26.746]     }
[13:24:26.746]     ...future.result$conditions <- ...future.conditions
[13:24:26.746]     ...future.result$finished <- base::Sys.time()
[13:24:26.746]     ...future.result
[13:24:26.746] }
[13:24:26.749] MultisessionFuture started
[13:24:26.749] - Launch lazy future ... done
[13:24:26.749] run() for ‘MultisessionFuture’ ... done
[13:24:26.797] receiveMessageFromWorker() for ClusterFuture ...
[13:24:26.798] - Validating connection of MultisessionFuture
[13:24:26.798] - received message: FutureResult
[13:24:26.798] - Received FutureResult
[13:24:26.798] - Erased future from FutureRegistry
[13:24:26.799] result() for ClusterFuture ...
[13:24:26.799] - result already collected: FutureResult
[13:24:26.799] result() for ClusterFuture ... done
[13:24:26.799] signalConditions() ...
[13:24:26.799]  - include = ‘immediateCondition’
[13:24:26.799]  - exclude = 
[13:24:26.799]  - resignal = FALSE
[13:24:26.799]  - Number of conditions: 1
[13:24:26.799] signalConditions() ... done
[13:24:26.799] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:26.799] A MultisessionFuture was resolved (result was not collected)
[13:24:26.799] getGlobalsAndPackages() ...
[13:24:26.800] Searching for globals...
[13:24:26.800] - globals found: [2] ‘list’, ‘stop’
[13:24:26.800] Searching for globals ... DONE
[13:24:26.801] Resolving globals: FALSE
[13:24:26.801] 
[13:24:26.801] 
[13:24:26.801] getGlobalsAndPackages() ... DONE
[13:24:26.801] run() for ‘Future’ ...
[13:24:26.801] - state: ‘created’
[13:24:26.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:26.815] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:26.815] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:26.815]   - Field: ‘node’
[13:24:26.815]   - Field: ‘label’
[13:24:26.815]   - Field: ‘local’
[13:24:26.815]   - Field: ‘owner’
[13:24:26.815]   - Field: ‘envir’
[13:24:26.816]   - Field: ‘workers’
[13:24:26.816]   - Field: ‘packages’
[13:24:26.816]   - Field: ‘gc’
[13:24:26.816]   - Field: ‘conditions’
[13:24:26.816]   - Field: ‘persistent’
[13:24:26.816]   - Field: ‘expr’
[13:24:26.816]   - Field: ‘uuid’
[13:24:26.816]   - Field: ‘seed’
[13:24:26.816]   - Field: ‘version’
[13:24:26.816]   - Field: ‘result’
[13:24:26.817]   - Field: ‘asynchronous’
[13:24:26.817]   - Field: ‘calls’
[13:24:26.817]   - Field: ‘globals’
[13:24:26.817]   - Field: ‘stdout’
[13:24:26.817]   - Field: ‘earlySignal’
[13:24:26.817]   - Field: ‘lazy’
[13:24:26.817]   - Field: ‘state’
[13:24:26.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:26.817] - Launch lazy future ...
[13:24:26.817] Packages needed by the future expression (n = 0): <none>
[13:24:26.818] Packages needed by future strategies (n = 0): <none>
[13:24:26.818] {
[13:24:26.818]     {
[13:24:26.818]         {
[13:24:26.818]             ...future.startTime <- base::Sys.time()
[13:24:26.818]             {
[13:24:26.818]                 {
[13:24:26.818]                   {
[13:24:26.818]                     {
[13:24:26.818]                       base::local({
[13:24:26.818]                         has_future <- base::requireNamespace("future", 
[13:24:26.818]                           quietly = TRUE)
[13:24:26.818]                         if (has_future) {
[13:24:26.818]                           ns <- base::getNamespace("future")
[13:24:26.818]                           version <- ns[[".package"]][["version"]]
[13:24:26.818]                           if (is.null(version)) 
[13:24:26.818]                             version <- utils::packageVersion("future")
[13:24:26.818]                         }
[13:24:26.818]                         else {
[13:24:26.818]                           version <- NULL
[13:24:26.818]                         }
[13:24:26.818]                         if (!has_future || version < "1.8.0") {
[13:24:26.818]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:26.818]                             "", base::R.version$version.string), 
[13:24:26.818]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:26.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:26.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:26.818]                               "release", "version")], collapse = " "), 
[13:24:26.818]                             hostname = base::Sys.info()[["nodename"]])
[13:24:26.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:26.818]                             info)
[13:24:26.818]                           info <- base::paste(info, collapse = "; ")
[13:24:26.818]                           if (!has_future) {
[13:24:26.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:26.818]                               info)
[13:24:26.818]                           }
[13:24:26.818]                           else {
[13:24:26.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:26.818]                               info, version)
[13:24:26.818]                           }
[13:24:26.818]                           base::stop(msg)
[13:24:26.818]                         }
[13:24:26.818]                       })
[13:24:26.818]                     }
[13:24:26.818]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:26.818]                     base::options(mc.cores = 1L)
[13:24:26.818]                   }
[13:24:26.818]                   options(future.plan = NULL)
[13:24:26.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:26.818]                 }
[13:24:26.818]                 ...future.workdir <- getwd()
[13:24:26.818]             }
[13:24:26.818]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:26.818]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:26.818]         }
[13:24:26.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:26.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:26.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:26.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:26.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:26.818]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:26.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:26.818]             base::names(...future.oldOptions))
[13:24:26.818]     }
[13:24:26.818]     if (FALSE) {
[13:24:26.818]     }
[13:24:26.818]     else {
[13:24:26.818]         if (TRUE) {
[13:24:26.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:26.818]                 open = "w")
[13:24:26.818]         }
[13:24:26.818]         else {
[13:24:26.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:26.818]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:26.818]         }
[13:24:26.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:26.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:26.818]             base::sink(type = "output", split = FALSE)
[13:24:26.818]             base::close(...future.stdout)
[13:24:26.818]         }, add = TRUE)
[13:24:26.818]     }
[13:24:26.818]     ...future.frame <- base::sys.nframe()
[13:24:26.818]     ...future.conditions <- base::list()
[13:24:26.818]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:26.818]     if (FALSE) {
[13:24:26.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:26.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:26.818]     }
[13:24:26.818]     ...future.result <- base::tryCatch({
[13:24:26.818]         base::withCallingHandlers({
[13:24:26.818]             ...future.value <- base::withVisible(base::local({
[13:24:26.818]                 ...future.makeSendCondition <- base::local({
[13:24:26.818]                   sendCondition <- NULL
[13:24:26.818]                   function(frame = 1L) {
[13:24:26.818]                     if (is.function(sendCondition)) 
[13:24:26.818]                       return(sendCondition)
[13:24:26.818]                     ns <- getNamespace("parallel")
[13:24:26.818]                     if (exists("sendData", mode = "function", 
[13:24:26.818]                       envir = ns)) {
[13:24:26.818]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:26.818]                         envir = ns)
[13:24:26.818]                       envir <- sys.frame(frame)
[13:24:26.818]                       master <- NULL
[13:24:26.818]                       while (!identical(envir, .GlobalEnv) && 
[13:24:26.818]                         !identical(envir, emptyenv())) {
[13:24:26.818]                         if (exists("master", mode = "list", envir = envir, 
[13:24:26.818]                           inherits = FALSE)) {
[13:24:26.818]                           master <- get("master", mode = "list", 
[13:24:26.818]                             envir = envir, inherits = FALSE)
[13:24:26.818]                           if (inherits(master, c("SOCKnode", 
[13:24:26.818]                             "SOCK0node"))) {
[13:24:26.818]                             sendCondition <<- function(cond) {
[13:24:26.818]                               data <- list(type = "VALUE", value = cond, 
[13:24:26.818]                                 success = TRUE)
[13:24:26.818]                               parallel_sendData(master, data)
[13:24:26.818]                             }
[13:24:26.818]                             return(sendCondition)
[13:24:26.818]                           }
[13:24:26.818]                         }
[13:24:26.818]                         frame <- frame + 1L
[13:24:26.818]                         envir <- sys.frame(frame)
[13:24:26.818]                       }
[13:24:26.818]                     }
[13:24:26.818]                     sendCondition <<- function(cond) NULL
[13:24:26.818]                   }
[13:24:26.818]                 })
[13:24:26.818]                 withCallingHandlers({
[13:24:26.818]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:26.818]                 }, immediateCondition = function(cond) {
[13:24:26.818]                   sendCondition <- ...future.makeSendCondition()
[13:24:26.818]                   sendCondition(cond)
[13:24:26.818]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.818]                   {
[13:24:26.818]                     inherits <- base::inherits
[13:24:26.818]                     invokeRestart <- base::invokeRestart
[13:24:26.818]                     is.null <- base::is.null
[13:24:26.818]                     muffled <- FALSE
[13:24:26.818]                     if (inherits(cond, "message")) {
[13:24:26.818]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:26.818]                       if (muffled) 
[13:24:26.818]                         invokeRestart("muffleMessage")
[13:24:26.818]                     }
[13:24:26.818]                     else if (inherits(cond, "warning")) {
[13:24:26.818]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:26.818]                       if (muffled) 
[13:24:26.818]                         invokeRestart("muffleWarning")
[13:24:26.818]                     }
[13:24:26.818]                     else if (inherits(cond, "condition")) {
[13:24:26.818]                       if (!is.null(pattern)) {
[13:24:26.818]                         computeRestarts <- base::computeRestarts
[13:24:26.818]                         grepl <- base::grepl
[13:24:26.818]                         restarts <- computeRestarts(cond)
[13:24:26.818]                         for (restart in restarts) {
[13:24:26.818]                           name <- restart$name
[13:24:26.818]                           if (is.null(name)) 
[13:24:26.818]                             next
[13:24:26.818]                           if (!grepl(pattern, name)) 
[13:24:26.818]                             next
[13:24:26.818]                           invokeRestart(restart)
[13:24:26.818]                           muffled <- TRUE
[13:24:26.818]                           break
[13:24:26.818]                         }
[13:24:26.818]                       }
[13:24:26.818]                     }
[13:24:26.818]                     invisible(muffled)
[13:24:26.818]                   }
[13:24:26.818]                   muffleCondition(cond)
[13:24:26.818]                 })
[13:24:26.818]             }))
[13:24:26.818]             future::FutureResult(value = ...future.value$value, 
[13:24:26.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.818]                   ...future.rng), globalenv = if (FALSE) 
[13:24:26.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:26.818]                     ...future.globalenv.names))
[13:24:26.818]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:26.818]         }, condition = base::local({
[13:24:26.818]             c <- base::c
[13:24:26.818]             inherits <- base::inherits
[13:24:26.818]             invokeRestart <- base::invokeRestart
[13:24:26.818]             length <- base::length
[13:24:26.818]             list <- base::list
[13:24:26.818]             seq.int <- base::seq.int
[13:24:26.818]             signalCondition <- base::signalCondition
[13:24:26.818]             sys.calls <- base::sys.calls
[13:24:26.818]             `[[` <- base::`[[`
[13:24:26.818]             `+` <- base::`+`
[13:24:26.818]             `<<-` <- base::`<<-`
[13:24:26.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:26.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:26.818]                   3L)]
[13:24:26.818]             }
[13:24:26.818]             function(cond) {
[13:24:26.818]                 is_error <- inherits(cond, "error")
[13:24:26.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:26.818]                   NULL)
[13:24:26.818]                 if (is_error) {
[13:24:26.818]                   sessionInformation <- function() {
[13:24:26.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:26.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:26.818]                       search = base::search(), system = base::Sys.info())
[13:24:26.818]                   }
[13:24:26.818]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:26.818]                     cond$call), session = sessionInformation(), 
[13:24:26.818]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:26.818]                   signalCondition(cond)
[13:24:26.818]                 }
[13:24:26.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:26.818]                 "immediateCondition"))) {
[13:24:26.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:26.818]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:26.818]                   if (TRUE && !signal) {
[13:24:26.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.818]                     {
[13:24:26.818]                       inherits <- base::inherits
[13:24:26.818]                       invokeRestart <- base::invokeRestart
[13:24:26.818]                       is.null <- base::is.null
[13:24:26.818]                       muffled <- FALSE
[13:24:26.818]                       if (inherits(cond, "message")) {
[13:24:26.818]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.818]                         if (muffled) 
[13:24:26.818]                           invokeRestart("muffleMessage")
[13:24:26.818]                       }
[13:24:26.818]                       else if (inherits(cond, "warning")) {
[13:24:26.818]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.818]                         if (muffled) 
[13:24:26.818]                           invokeRestart("muffleWarning")
[13:24:26.818]                       }
[13:24:26.818]                       else if (inherits(cond, "condition")) {
[13:24:26.818]                         if (!is.null(pattern)) {
[13:24:26.818]                           computeRestarts <- base::computeRestarts
[13:24:26.818]                           grepl <- base::grepl
[13:24:26.818]                           restarts <- computeRestarts(cond)
[13:24:26.818]                           for (restart in restarts) {
[13:24:26.818]                             name <- restart$name
[13:24:26.818]                             if (is.null(name)) 
[13:24:26.818]                               next
[13:24:26.818]                             if (!grepl(pattern, name)) 
[13:24:26.818]                               next
[13:24:26.818]                             invokeRestart(restart)
[13:24:26.818]                             muffled <- TRUE
[13:24:26.818]                             break
[13:24:26.818]                           }
[13:24:26.818]                         }
[13:24:26.818]                       }
[13:24:26.818]                       invisible(muffled)
[13:24:26.818]                     }
[13:24:26.818]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.818]                   }
[13:24:26.818]                 }
[13:24:26.818]                 else {
[13:24:26.818]                   if (TRUE) {
[13:24:26.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.818]                     {
[13:24:26.818]                       inherits <- base::inherits
[13:24:26.818]                       invokeRestart <- base::invokeRestart
[13:24:26.818]                       is.null <- base::is.null
[13:24:26.818]                       muffled <- FALSE
[13:24:26.818]                       if (inherits(cond, "message")) {
[13:24:26.818]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.818]                         if (muffled) 
[13:24:26.818]                           invokeRestart("muffleMessage")
[13:24:26.818]                       }
[13:24:26.818]                       else if (inherits(cond, "warning")) {
[13:24:26.818]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.818]                         if (muffled) 
[13:24:26.818]                           invokeRestart("muffleWarning")
[13:24:26.818]                       }
[13:24:26.818]                       else if (inherits(cond, "condition")) {
[13:24:26.818]                         if (!is.null(pattern)) {
[13:24:26.818]                           computeRestarts <- base::computeRestarts
[13:24:26.818]                           grepl <- base::grepl
[13:24:26.818]                           restarts <- computeRestarts(cond)
[13:24:26.818]                           for (restart in restarts) {
[13:24:26.818]                             name <- restart$name
[13:24:26.818]                             if (is.null(name)) 
[13:24:26.818]                               next
[13:24:26.818]                             if (!grepl(pattern, name)) 
[13:24:26.818]                               next
[13:24:26.818]                             invokeRestart(restart)
[13:24:26.818]                             muffled <- TRUE
[13:24:26.818]                             break
[13:24:26.818]                           }
[13:24:26.818]                         }
[13:24:26.818]                       }
[13:24:26.818]                       invisible(muffled)
[13:24:26.818]                     }
[13:24:26.818]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.818]                   }
[13:24:26.818]                 }
[13:24:26.818]             }
[13:24:26.818]         }))
[13:24:26.818]     }, error = function(ex) {
[13:24:26.818]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:26.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.818]                 ...future.rng), started = ...future.startTime, 
[13:24:26.818]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:26.818]             version = "1.8"), class = "FutureResult")
[13:24:26.818]     }, finally = {
[13:24:26.818]         if (!identical(...future.workdir, getwd())) 
[13:24:26.818]             setwd(...future.workdir)
[13:24:26.818]         {
[13:24:26.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:26.818]                 ...future.oldOptions$nwarnings <- NULL
[13:24:26.818]             }
[13:24:26.818]             base::options(...future.oldOptions)
[13:24:26.818]             if (.Platform$OS.type == "windows") {
[13:24:26.818]                 old_names <- names(...future.oldEnvVars)
[13:24:26.818]                 envs <- base::Sys.getenv()
[13:24:26.818]                 names <- names(envs)
[13:24:26.818]                 common <- intersect(names, old_names)
[13:24:26.818]                 added <- setdiff(names, old_names)
[13:24:26.818]                 removed <- setdiff(old_names, names)
[13:24:26.818]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:26.818]                   envs[common]]
[13:24:26.818]                 NAMES <- toupper(changed)
[13:24:26.818]                 args <- list()
[13:24:26.818]                 for (kk in seq_along(NAMES)) {
[13:24:26.818]                   name <- changed[[kk]]
[13:24:26.818]                   NAME <- NAMES[[kk]]
[13:24:26.818]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.818]                     next
[13:24:26.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.818]                 }
[13:24:26.818]                 NAMES <- toupper(added)
[13:24:26.818]                 for (kk in seq_along(NAMES)) {
[13:24:26.818]                   name <- added[[kk]]
[13:24:26.818]                   NAME <- NAMES[[kk]]
[13:24:26.818]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.818]                     next
[13:24:26.818]                   args[[name]] <- ""
[13:24:26.818]                 }
[13:24:26.818]                 NAMES <- toupper(removed)
[13:24:26.818]                 for (kk in seq_along(NAMES)) {
[13:24:26.818]                   name <- removed[[kk]]
[13:24:26.818]                   NAME <- NAMES[[kk]]
[13:24:26.818]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.818]                     next
[13:24:26.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.818]                 }
[13:24:26.818]                 if (length(args) > 0) 
[13:24:26.818]                   base::do.call(base::Sys.setenv, args = args)
[13:24:26.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:26.818]             }
[13:24:26.818]             else {
[13:24:26.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:26.818]             }
[13:24:26.818]             {
[13:24:26.818]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:26.818]                   0L) {
[13:24:26.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:26.818]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:26.818]                   base::options(opts)
[13:24:26.818]                 }
[13:24:26.818]                 {
[13:24:26.818]                   {
[13:24:26.818]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:26.818]                     NULL
[13:24:26.818]                   }
[13:24:26.818]                   options(future.plan = NULL)
[13:24:26.818]                   if (is.na(NA_character_)) 
[13:24:26.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:26.818]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:26.818]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:26.818]                     envir = parent.frame()) 
[13:24:26.818]                   {
[13:24:26.818]                     if (is.function(workers)) 
[13:24:26.818]                       workers <- workers()
[13:24:26.818]                     workers <- structure(as.integer(workers), 
[13:24:26.818]                       class = class(workers))
[13:24:26.818]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:26.818]                       workers >= 1)
[13:24:26.818]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:26.818]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:26.818]                     }
[13:24:26.818]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:26.818]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:26.818]                       envir = envir)
[13:24:26.818]                     if (!future$lazy) 
[13:24:26.818]                       future <- run(future)
[13:24:26.818]                     invisible(future)
[13:24:26.818]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:26.818]                 }
[13:24:26.818]             }
[13:24:26.818]         }
[13:24:26.818]     })
[13:24:26.818]     if (TRUE) {
[13:24:26.818]         base::sink(type = "output", split = FALSE)
[13:24:26.818]         if (TRUE) {
[13:24:26.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:26.818]         }
[13:24:26.818]         else {
[13:24:26.818]             ...future.result["stdout"] <- base::list(NULL)
[13:24:26.818]         }
[13:24:26.818]         base::close(...future.stdout)
[13:24:26.818]         ...future.stdout <- NULL
[13:24:26.818]     }
[13:24:26.818]     ...future.result$conditions <- ...future.conditions
[13:24:26.818]     ...future.result$finished <- base::Sys.time()
[13:24:26.818]     ...future.result
[13:24:26.818] }
[13:24:26.821] MultisessionFuture started
[13:24:26.821] - Launch lazy future ... done
[13:24:26.821] run() for ‘MultisessionFuture’ ... done
[13:24:26.869] receiveMessageFromWorker() for ClusterFuture ...
[13:24:26.869] - Validating connection of MultisessionFuture
[13:24:26.870] - received message: FutureResult
[13:24:26.870] - Received FutureResult
[13:24:26.870] - Erased future from FutureRegistry
[13:24:26.870] result() for ClusterFuture ...
[13:24:26.870] - result already collected: FutureResult
[13:24:26.870] result() for ClusterFuture ... done
[13:24:26.870] signalConditions() ...
[13:24:26.870]  - include = ‘immediateCondition’
[13:24:26.870]  - exclude = 
[13:24:26.871]  - resignal = FALSE
[13:24:26.871]  - Number of conditions: 1
[13:24:26.871] signalConditions() ... done
[13:24:26.871] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:26.871] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[13:24:26.871] getGlobalsAndPackages() ...
[13:24:26.871] Searching for globals...
[13:24:26.872] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:26.873] Searching for globals ... DONE
[13:24:26.873] Resolving globals: FALSE
[13:24:26.873] 
[13:24:26.873] 
[13:24:26.873] getGlobalsAndPackages() ... DONE
[13:24:26.873] run() for ‘Future’ ...
[13:24:26.874] - state: ‘created’
[13:24:26.874] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:26.890] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:26.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:26.890]   - Field: ‘node’
[13:24:26.890]   - Field: ‘label’
[13:24:26.890]   - Field: ‘local’
[13:24:26.890]   - Field: ‘owner’
[13:24:26.890]   - Field: ‘envir’
[13:24:26.891]   - Field: ‘workers’
[13:24:26.891]   - Field: ‘packages’
[13:24:26.891]   - Field: ‘gc’
[13:24:26.891]   - Field: ‘conditions’
[13:24:26.891]   - Field: ‘persistent’
[13:24:26.891]   - Field: ‘expr’
[13:24:26.891]   - Field: ‘uuid’
[13:24:26.891]   - Field: ‘seed’
[13:24:26.891]   - Field: ‘version’
[13:24:26.891]   - Field: ‘result’
[13:24:26.891]   - Field: ‘asynchronous’
[13:24:26.892]   - Field: ‘calls’
[13:24:26.892]   - Field: ‘globals’
[13:24:26.892]   - Field: ‘stdout’
[13:24:26.892]   - Field: ‘earlySignal’
[13:24:26.892]   - Field: ‘lazy’
[13:24:26.892]   - Field: ‘state’
[13:24:26.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:26.892] - Launch lazy future ...
[13:24:26.893] Packages needed by the future expression (n = 0): <none>
[13:24:26.893] Packages needed by future strategies (n = 0): <none>
[13:24:26.893] {
[13:24:26.893]     {
[13:24:26.893]         {
[13:24:26.893]             ...future.startTime <- base::Sys.time()
[13:24:26.893]             {
[13:24:26.893]                 {
[13:24:26.893]                   {
[13:24:26.893]                     {
[13:24:26.893]                       base::local({
[13:24:26.893]                         has_future <- base::requireNamespace("future", 
[13:24:26.893]                           quietly = TRUE)
[13:24:26.893]                         if (has_future) {
[13:24:26.893]                           ns <- base::getNamespace("future")
[13:24:26.893]                           version <- ns[[".package"]][["version"]]
[13:24:26.893]                           if (is.null(version)) 
[13:24:26.893]                             version <- utils::packageVersion("future")
[13:24:26.893]                         }
[13:24:26.893]                         else {
[13:24:26.893]                           version <- NULL
[13:24:26.893]                         }
[13:24:26.893]                         if (!has_future || version < "1.8.0") {
[13:24:26.893]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:26.893]                             "", base::R.version$version.string), 
[13:24:26.893]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:26.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:26.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:26.893]                               "release", "version")], collapse = " "), 
[13:24:26.893]                             hostname = base::Sys.info()[["nodename"]])
[13:24:26.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:26.893]                             info)
[13:24:26.893]                           info <- base::paste(info, collapse = "; ")
[13:24:26.893]                           if (!has_future) {
[13:24:26.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:26.893]                               info)
[13:24:26.893]                           }
[13:24:26.893]                           else {
[13:24:26.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:26.893]                               info, version)
[13:24:26.893]                           }
[13:24:26.893]                           base::stop(msg)
[13:24:26.893]                         }
[13:24:26.893]                       })
[13:24:26.893]                     }
[13:24:26.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:26.893]                     base::options(mc.cores = 1L)
[13:24:26.893]                   }
[13:24:26.893]                   options(future.plan = NULL)
[13:24:26.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:26.893]                 }
[13:24:26.893]                 ...future.workdir <- getwd()
[13:24:26.893]             }
[13:24:26.893]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:26.893]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:26.893]         }
[13:24:26.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:26.893]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:26.893]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:26.893]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:26.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:26.893]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:26.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:26.893]             base::names(...future.oldOptions))
[13:24:26.893]     }
[13:24:26.893]     if (FALSE) {
[13:24:26.893]     }
[13:24:26.893]     else {
[13:24:26.893]         if (TRUE) {
[13:24:26.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:26.893]                 open = "w")
[13:24:26.893]         }
[13:24:26.893]         else {
[13:24:26.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:26.893]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:26.893]         }
[13:24:26.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:26.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:26.893]             base::sink(type = "output", split = FALSE)
[13:24:26.893]             base::close(...future.stdout)
[13:24:26.893]         }, add = TRUE)
[13:24:26.893]     }
[13:24:26.893]     ...future.frame <- base::sys.nframe()
[13:24:26.893]     ...future.conditions <- base::list()
[13:24:26.893]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:26.893]     if (FALSE) {
[13:24:26.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:26.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:26.893]     }
[13:24:26.893]     ...future.result <- base::tryCatch({
[13:24:26.893]         base::withCallingHandlers({
[13:24:26.893]             ...future.value <- base::withVisible(base::local({
[13:24:26.893]                 ...future.makeSendCondition <- base::local({
[13:24:26.893]                   sendCondition <- NULL
[13:24:26.893]                   function(frame = 1L) {
[13:24:26.893]                     if (is.function(sendCondition)) 
[13:24:26.893]                       return(sendCondition)
[13:24:26.893]                     ns <- getNamespace("parallel")
[13:24:26.893]                     if (exists("sendData", mode = "function", 
[13:24:26.893]                       envir = ns)) {
[13:24:26.893]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:26.893]                         envir = ns)
[13:24:26.893]                       envir <- sys.frame(frame)
[13:24:26.893]                       master <- NULL
[13:24:26.893]                       while (!identical(envir, .GlobalEnv) && 
[13:24:26.893]                         !identical(envir, emptyenv())) {
[13:24:26.893]                         if (exists("master", mode = "list", envir = envir, 
[13:24:26.893]                           inherits = FALSE)) {
[13:24:26.893]                           master <- get("master", mode = "list", 
[13:24:26.893]                             envir = envir, inherits = FALSE)
[13:24:26.893]                           if (inherits(master, c("SOCKnode", 
[13:24:26.893]                             "SOCK0node"))) {
[13:24:26.893]                             sendCondition <<- function(cond) {
[13:24:26.893]                               data <- list(type = "VALUE", value = cond, 
[13:24:26.893]                                 success = TRUE)
[13:24:26.893]                               parallel_sendData(master, data)
[13:24:26.893]                             }
[13:24:26.893]                             return(sendCondition)
[13:24:26.893]                           }
[13:24:26.893]                         }
[13:24:26.893]                         frame <- frame + 1L
[13:24:26.893]                         envir <- sys.frame(frame)
[13:24:26.893]                       }
[13:24:26.893]                     }
[13:24:26.893]                     sendCondition <<- function(cond) NULL
[13:24:26.893]                   }
[13:24:26.893]                 })
[13:24:26.893]                 withCallingHandlers({
[13:24:26.893]                   {
[13:24:26.893]                     Sys.sleep(0.5)
[13:24:26.893]                     list(a = 1, b = 42L)
[13:24:26.893]                   }
[13:24:26.893]                 }, immediateCondition = function(cond) {
[13:24:26.893]                   sendCondition <- ...future.makeSendCondition()
[13:24:26.893]                   sendCondition(cond)
[13:24:26.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.893]                   {
[13:24:26.893]                     inherits <- base::inherits
[13:24:26.893]                     invokeRestart <- base::invokeRestart
[13:24:26.893]                     is.null <- base::is.null
[13:24:26.893]                     muffled <- FALSE
[13:24:26.893]                     if (inherits(cond, "message")) {
[13:24:26.893]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:26.893]                       if (muffled) 
[13:24:26.893]                         invokeRestart("muffleMessage")
[13:24:26.893]                     }
[13:24:26.893]                     else if (inherits(cond, "warning")) {
[13:24:26.893]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:26.893]                       if (muffled) 
[13:24:26.893]                         invokeRestart("muffleWarning")
[13:24:26.893]                     }
[13:24:26.893]                     else if (inherits(cond, "condition")) {
[13:24:26.893]                       if (!is.null(pattern)) {
[13:24:26.893]                         computeRestarts <- base::computeRestarts
[13:24:26.893]                         grepl <- base::grepl
[13:24:26.893]                         restarts <- computeRestarts(cond)
[13:24:26.893]                         for (restart in restarts) {
[13:24:26.893]                           name <- restart$name
[13:24:26.893]                           if (is.null(name)) 
[13:24:26.893]                             next
[13:24:26.893]                           if (!grepl(pattern, name)) 
[13:24:26.893]                             next
[13:24:26.893]                           invokeRestart(restart)
[13:24:26.893]                           muffled <- TRUE
[13:24:26.893]                           break
[13:24:26.893]                         }
[13:24:26.893]                       }
[13:24:26.893]                     }
[13:24:26.893]                     invisible(muffled)
[13:24:26.893]                   }
[13:24:26.893]                   muffleCondition(cond)
[13:24:26.893]                 })
[13:24:26.893]             }))
[13:24:26.893]             future::FutureResult(value = ...future.value$value, 
[13:24:26.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.893]                   ...future.rng), globalenv = if (FALSE) 
[13:24:26.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:26.893]                     ...future.globalenv.names))
[13:24:26.893]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:26.893]         }, condition = base::local({
[13:24:26.893]             c <- base::c
[13:24:26.893]             inherits <- base::inherits
[13:24:26.893]             invokeRestart <- base::invokeRestart
[13:24:26.893]             length <- base::length
[13:24:26.893]             list <- base::list
[13:24:26.893]             seq.int <- base::seq.int
[13:24:26.893]             signalCondition <- base::signalCondition
[13:24:26.893]             sys.calls <- base::sys.calls
[13:24:26.893]             `[[` <- base::`[[`
[13:24:26.893]             `+` <- base::`+`
[13:24:26.893]             `<<-` <- base::`<<-`
[13:24:26.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:26.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:26.893]                   3L)]
[13:24:26.893]             }
[13:24:26.893]             function(cond) {
[13:24:26.893]                 is_error <- inherits(cond, "error")
[13:24:26.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:26.893]                   NULL)
[13:24:26.893]                 if (is_error) {
[13:24:26.893]                   sessionInformation <- function() {
[13:24:26.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:26.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:26.893]                       search = base::search(), system = base::Sys.info())
[13:24:26.893]                   }
[13:24:26.893]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:26.893]                     cond$call), session = sessionInformation(), 
[13:24:26.893]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:26.893]                   signalCondition(cond)
[13:24:26.893]                 }
[13:24:26.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:26.893]                 "immediateCondition"))) {
[13:24:26.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:26.893]                   ...future.conditions[[length(...future.conditions) + 
[13:24:26.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:26.893]                   if (TRUE && !signal) {
[13:24:26.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.893]                     {
[13:24:26.893]                       inherits <- base::inherits
[13:24:26.893]                       invokeRestart <- base::invokeRestart
[13:24:26.893]                       is.null <- base::is.null
[13:24:26.893]                       muffled <- FALSE
[13:24:26.893]                       if (inherits(cond, "message")) {
[13:24:26.893]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.893]                         if (muffled) 
[13:24:26.893]                           invokeRestart("muffleMessage")
[13:24:26.893]                       }
[13:24:26.893]                       else if (inherits(cond, "warning")) {
[13:24:26.893]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.893]                         if (muffled) 
[13:24:26.893]                           invokeRestart("muffleWarning")
[13:24:26.893]                       }
[13:24:26.893]                       else if (inherits(cond, "condition")) {
[13:24:26.893]                         if (!is.null(pattern)) {
[13:24:26.893]                           computeRestarts <- base::computeRestarts
[13:24:26.893]                           grepl <- base::grepl
[13:24:26.893]                           restarts <- computeRestarts(cond)
[13:24:26.893]                           for (restart in restarts) {
[13:24:26.893]                             name <- restart$name
[13:24:26.893]                             if (is.null(name)) 
[13:24:26.893]                               next
[13:24:26.893]                             if (!grepl(pattern, name)) 
[13:24:26.893]                               next
[13:24:26.893]                             invokeRestart(restart)
[13:24:26.893]                             muffled <- TRUE
[13:24:26.893]                             break
[13:24:26.893]                           }
[13:24:26.893]                         }
[13:24:26.893]                       }
[13:24:26.893]                       invisible(muffled)
[13:24:26.893]                     }
[13:24:26.893]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.893]                   }
[13:24:26.893]                 }
[13:24:26.893]                 else {
[13:24:26.893]                   if (TRUE) {
[13:24:26.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:26.893]                     {
[13:24:26.893]                       inherits <- base::inherits
[13:24:26.893]                       invokeRestart <- base::invokeRestart
[13:24:26.893]                       is.null <- base::is.null
[13:24:26.893]                       muffled <- FALSE
[13:24:26.893]                       if (inherits(cond, "message")) {
[13:24:26.893]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:26.893]                         if (muffled) 
[13:24:26.893]                           invokeRestart("muffleMessage")
[13:24:26.893]                       }
[13:24:26.893]                       else if (inherits(cond, "warning")) {
[13:24:26.893]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:26.893]                         if (muffled) 
[13:24:26.893]                           invokeRestart("muffleWarning")
[13:24:26.893]                       }
[13:24:26.893]                       else if (inherits(cond, "condition")) {
[13:24:26.893]                         if (!is.null(pattern)) {
[13:24:26.893]                           computeRestarts <- base::computeRestarts
[13:24:26.893]                           grepl <- base::grepl
[13:24:26.893]                           restarts <- computeRestarts(cond)
[13:24:26.893]                           for (restart in restarts) {
[13:24:26.893]                             name <- restart$name
[13:24:26.893]                             if (is.null(name)) 
[13:24:26.893]                               next
[13:24:26.893]                             if (!grepl(pattern, name)) 
[13:24:26.893]                               next
[13:24:26.893]                             invokeRestart(restart)
[13:24:26.893]                             muffled <- TRUE
[13:24:26.893]                             break
[13:24:26.893]                           }
[13:24:26.893]                         }
[13:24:26.893]                       }
[13:24:26.893]                       invisible(muffled)
[13:24:26.893]                     }
[13:24:26.893]                     muffleCondition(cond, pattern = "^muffle")
[13:24:26.893]                   }
[13:24:26.893]                 }
[13:24:26.893]             }
[13:24:26.893]         }))
[13:24:26.893]     }, error = function(ex) {
[13:24:26.893]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:26.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:26.893]                 ...future.rng), started = ...future.startTime, 
[13:24:26.893]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:26.893]             version = "1.8"), class = "FutureResult")
[13:24:26.893]     }, finally = {
[13:24:26.893]         if (!identical(...future.workdir, getwd())) 
[13:24:26.893]             setwd(...future.workdir)
[13:24:26.893]         {
[13:24:26.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:26.893]                 ...future.oldOptions$nwarnings <- NULL
[13:24:26.893]             }
[13:24:26.893]             base::options(...future.oldOptions)
[13:24:26.893]             if (.Platform$OS.type == "windows") {
[13:24:26.893]                 old_names <- names(...future.oldEnvVars)
[13:24:26.893]                 envs <- base::Sys.getenv()
[13:24:26.893]                 names <- names(envs)
[13:24:26.893]                 common <- intersect(names, old_names)
[13:24:26.893]                 added <- setdiff(names, old_names)
[13:24:26.893]                 removed <- setdiff(old_names, names)
[13:24:26.893]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:26.893]                   envs[common]]
[13:24:26.893]                 NAMES <- toupper(changed)
[13:24:26.893]                 args <- list()
[13:24:26.893]                 for (kk in seq_along(NAMES)) {
[13:24:26.893]                   name <- changed[[kk]]
[13:24:26.893]                   NAME <- NAMES[[kk]]
[13:24:26.893]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.893]                     next
[13:24:26.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.893]                 }
[13:24:26.893]                 NAMES <- toupper(added)
[13:24:26.893]                 for (kk in seq_along(NAMES)) {
[13:24:26.893]                   name <- added[[kk]]
[13:24:26.893]                   NAME <- NAMES[[kk]]
[13:24:26.893]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.893]                     next
[13:24:26.893]                   args[[name]] <- ""
[13:24:26.893]                 }
[13:24:26.893]                 NAMES <- toupper(removed)
[13:24:26.893]                 for (kk in seq_along(NAMES)) {
[13:24:26.893]                   name <- removed[[kk]]
[13:24:26.893]                   NAME <- NAMES[[kk]]
[13:24:26.893]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:26.893]                     next
[13:24:26.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:26.893]                 }
[13:24:26.893]                 if (length(args) > 0) 
[13:24:26.893]                   base::do.call(base::Sys.setenv, args = args)
[13:24:26.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:26.893]             }
[13:24:26.893]             else {
[13:24:26.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:26.893]             }
[13:24:26.893]             {
[13:24:26.893]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:26.893]                   0L) {
[13:24:26.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:26.893]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:26.893]                   base::options(opts)
[13:24:26.893]                 }
[13:24:26.893]                 {
[13:24:26.893]                   {
[13:24:26.893]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:26.893]                     NULL
[13:24:26.893]                   }
[13:24:26.893]                   options(future.plan = NULL)
[13:24:26.893]                   if (is.na(NA_character_)) 
[13:24:26.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:26.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:26.893]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:26.893]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:26.893]                     envir = parent.frame()) 
[13:24:26.893]                   {
[13:24:26.893]                     if (is.function(workers)) 
[13:24:26.893]                       workers <- workers()
[13:24:26.893]                     workers <- structure(as.integer(workers), 
[13:24:26.893]                       class = class(workers))
[13:24:26.893]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:26.893]                       workers >= 1)
[13:24:26.893]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:26.893]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:26.893]                     }
[13:24:26.893]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:26.893]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:26.893]                       envir = envir)
[13:24:26.893]                     if (!future$lazy) 
[13:24:26.893]                       future <- run(future)
[13:24:26.893]                     invisible(future)
[13:24:26.893]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:26.893]                 }
[13:24:26.893]             }
[13:24:26.893]         }
[13:24:26.893]     })
[13:24:26.893]     if (TRUE) {
[13:24:26.893]         base::sink(type = "output", split = FALSE)
[13:24:26.893]         if (TRUE) {
[13:24:26.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:26.893]         }
[13:24:26.893]         else {
[13:24:26.893]             ...future.result["stdout"] <- base::list(NULL)
[13:24:26.893]         }
[13:24:26.893]         base::close(...future.stdout)
[13:24:26.893]         ...future.stdout <- NULL
[13:24:26.893]     }
[13:24:26.893]     ...future.result$conditions <- ...future.conditions
[13:24:26.893]     ...future.result$finished <- base::Sys.time()
[13:24:26.893]     ...future.result
[13:24:26.893] }
[13:24:26.896] MultisessionFuture started
[13:24:26.896] - Launch lazy future ... done
[13:24:26.896] run() for ‘MultisessionFuture’ ... done
[13:24:27.455] receiveMessageFromWorker() for ClusterFuture ...
[13:24:27.455] - Validating connection of MultisessionFuture
[13:24:27.455] - received message: FutureResult
[13:24:27.455] - Received FutureResult
[13:24:27.456] - Erased future from FutureRegistry
[13:24:27.456] result() for ClusterFuture ...
[13:24:27.456] - result already collected: FutureResult
[13:24:27.456] result() for ClusterFuture ... done
[13:24:27.456] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:27.456] A MultisessionFuture was resolved (result was not collected)
[13:24:27.456] getGlobalsAndPackages() ...
[13:24:27.456] Searching for globals...
[13:24:27.457] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:27.458] Searching for globals ... DONE
[13:24:27.458] Resolving globals: FALSE
[13:24:27.458] 
[13:24:27.458] 
[13:24:27.458] getGlobalsAndPackages() ... DONE
[13:24:27.458] run() for ‘Future’ ...
[13:24:27.459] - state: ‘created’
[13:24:27.459] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:27.473] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:27.473] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:27.473]   - Field: ‘node’
[13:24:27.473]   - Field: ‘label’
[13:24:27.473]   - Field: ‘local’
[13:24:27.473]   - Field: ‘owner’
[13:24:27.473]   - Field: ‘envir’
[13:24:27.473]   - Field: ‘workers’
[13:24:27.474]   - Field: ‘packages’
[13:24:27.474]   - Field: ‘gc’
[13:24:27.474]   - Field: ‘conditions’
[13:24:27.474]   - Field: ‘persistent’
[13:24:27.474]   - Field: ‘expr’
[13:24:27.474]   - Field: ‘uuid’
[13:24:27.474]   - Field: ‘seed’
[13:24:27.474]   - Field: ‘version’
[13:24:27.474]   - Field: ‘result’
[13:24:27.474]   - Field: ‘asynchronous’
[13:24:27.474]   - Field: ‘calls’
[13:24:27.475]   - Field: ‘globals’
[13:24:27.475]   - Field: ‘stdout’
[13:24:27.475]   - Field: ‘earlySignal’
[13:24:27.475]   - Field: ‘lazy’
[13:24:27.475]   - Field: ‘state’
[13:24:27.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:27.475] - Launch lazy future ...
[13:24:27.475] Packages needed by the future expression (n = 0): <none>
[13:24:27.475] Packages needed by future strategies (n = 0): <none>
[13:24:27.476] {
[13:24:27.476]     {
[13:24:27.476]         {
[13:24:27.476]             ...future.startTime <- base::Sys.time()
[13:24:27.476]             {
[13:24:27.476]                 {
[13:24:27.476]                   {
[13:24:27.476]                     {
[13:24:27.476]                       base::local({
[13:24:27.476]                         has_future <- base::requireNamespace("future", 
[13:24:27.476]                           quietly = TRUE)
[13:24:27.476]                         if (has_future) {
[13:24:27.476]                           ns <- base::getNamespace("future")
[13:24:27.476]                           version <- ns[[".package"]][["version"]]
[13:24:27.476]                           if (is.null(version)) 
[13:24:27.476]                             version <- utils::packageVersion("future")
[13:24:27.476]                         }
[13:24:27.476]                         else {
[13:24:27.476]                           version <- NULL
[13:24:27.476]                         }
[13:24:27.476]                         if (!has_future || version < "1.8.0") {
[13:24:27.476]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:27.476]                             "", base::R.version$version.string), 
[13:24:27.476]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:27.476]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:27.476]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:27.476]                               "release", "version")], collapse = " "), 
[13:24:27.476]                             hostname = base::Sys.info()[["nodename"]])
[13:24:27.476]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:27.476]                             info)
[13:24:27.476]                           info <- base::paste(info, collapse = "; ")
[13:24:27.476]                           if (!has_future) {
[13:24:27.476]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:27.476]                               info)
[13:24:27.476]                           }
[13:24:27.476]                           else {
[13:24:27.476]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:27.476]                               info, version)
[13:24:27.476]                           }
[13:24:27.476]                           base::stop(msg)
[13:24:27.476]                         }
[13:24:27.476]                       })
[13:24:27.476]                     }
[13:24:27.476]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:27.476]                     base::options(mc.cores = 1L)
[13:24:27.476]                   }
[13:24:27.476]                   options(future.plan = NULL)
[13:24:27.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:27.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:27.476]                 }
[13:24:27.476]                 ...future.workdir <- getwd()
[13:24:27.476]             }
[13:24:27.476]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:27.476]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:27.476]         }
[13:24:27.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:27.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:27.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:27.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:27.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:27.476]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:27.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:27.476]             base::names(...future.oldOptions))
[13:24:27.476]     }
[13:24:27.476]     if (FALSE) {
[13:24:27.476]     }
[13:24:27.476]     else {
[13:24:27.476]         if (TRUE) {
[13:24:27.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:27.476]                 open = "w")
[13:24:27.476]         }
[13:24:27.476]         else {
[13:24:27.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:27.476]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:27.476]         }
[13:24:27.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:27.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:27.476]             base::sink(type = "output", split = FALSE)
[13:24:27.476]             base::close(...future.stdout)
[13:24:27.476]         }, add = TRUE)
[13:24:27.476]     }
[13:24:27.476]     ...future.frame <- base::sys.nframe()
[13:24:27.476]     ...future.conditions <- base::list()
[13:24:27.476]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:27.476]     if (FALSE) {
[13:24:27.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:27.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:27.476]     }
[13:24:27.476]     ...future.result <- base::tryCatch({
[13:24:27.476]         base::withCallingHandlers({
[13:24:27.476]             ...future.value <- base::withVisible(base::local({
[13:24:27.476]                 ...future.makeSendCondition <- base::local({
[13:24:27.476]                   sendCondition <- NULL
[13:24:27.476]                   function(frame = 1L) {
[13:24:27.476]                     if (is.function(sendCondition)) 
[13:24:27.476]                       return(sendCondition)
[13:24:27.476]                     ns <- getNamespace("parallel")
[13:24:27.476]                     if (exists("sendData", mode = "function", 
[13:24:27.476]                       envir = ns)) {
[13:24:27.476]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:27.476]                         envir = ns)
[13:24:27.476]                       envir <- sys.frame(frame)
[13:24:27.476]                       master <- NULL
[13:24:27.476]                       while (!identical(envir, .GlobalEnv) && 
[13:24:27.476]                         !identical(envir, emptyenv())) {
[13:24:27.476]                         if (exists("master", mode = "list", envir = envir, 
[13:24:27.476]                           inherits = FALSE)) {
[13:24:27.476]                           master <- get("master", mode = "list", 
[13:24:27.476]                             envir = envir, inherits = FALSE)
[13:24:27.476]                           if (inherits(master, c("SOCKnode", 
[13:24:27.476]                             "SOCK0node"))) {
[13:24:27.476]                             sendCondition <<- function(cond) {
[13:24:27.476]                               data <- list(type = "VALUE", value = cond, 
[13:24:27.476]                                 success = TRUE)
[13:24:27.476]                               parallel_sendData(master, data)
[13:24:27.476]                             }
[13:24:27.476]                             return(sendCondition)
[13:24:27.476]                           }
[13:24:27.476]                         }
[13:24:27.476]                         frame <- frame + 1L
[13:24:27.476]                         envir <- sys.frame(frame)
[13:24:27.476]                       }
[13:24:27.476]                     }
[13:24:27.476]                     sendCondition <<- function(cond) NULL
[13:24:27.476]                   }
[13:24:27.476]                 })
[13:24:27.476]                 withCallingHandlers({
[13:24:27.476]                   {
[13:24:27.476]                     Sys.sleep(0.5)
[13:24:27.476]                     list(a = 1, b = 42L)
[13:24:27.476]                   }
[13:24:27.476]                 }, immediateCondition = function(cond) {
[13:24:27.476]                   sendCondition <- ...future.makeSendCondition()
[13:24:27.476]                   sendCondition(cond)
[13:24:27.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:27.476]                   {
[13:24:27.476]                     inherits <- base::inherits
[13:24:27.476]                     invokeRestart <- base::invokeRestart
[13:24:27.476]                     is.null <- base::is.null
[13:24:27.476]                     muffled <- FALSE
[13:24:27.476]                     if (inherits(cond, "message")) {
[13:24:27.476]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:27.476]                       if (muffled) 
[13:24:27.476]                         invokeRestart("muffleMessage")
[13:24:27.476]                     }
[13:24:27.476]                     else if (inherits(cond, "warning")) {
[13:24:27.476]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:27.476]                       if (muffled) 
[13:24:27.476]                         invokeRestart("muffleWarning")
[13:24:27.476]                     }
[13:24:27.476]                     else if (inherits(cond, "condition")) {
[13:24:27.476]                       if (!is.null(pattern)) {
[13:24:27.476]                         computeRestarts <- base::computeRestarts
[13:24:27.476]                         grepl <- base::grepl
[13:24:27.476]                         restarts <- computeRestarts(cond)
[13:24:27.476]                         for (restart in restarts) {
[13:24:27.476]                           name <- restart$name
[13:24:27.476]                           if (is.null(name)) 
[13:24:27.476]                             next
[13:24:27.476]                           if (!grepl(pattern, name)) 
[13:24:27.476]                             next
[13:24:27.476]                           invokeRestart(restart)
[13:24:27.476]                           muffled <- TRUE
[13:24:27.476]                           break
[13:24:27.476]                         }
[13:24:27.476]                       }
[13:24:27.476]                     }
[13:24:27.476]                     invisible(muffled)
[13:24:27.476]                   }
[13:24:27.476]                   muffleCondition(cond)
[13:24:27.476]                 })
[13:24:27.476]             }))
[13:24:27.476]             future::FutureResult(value = ...future.value$value, 
[13:24:27.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:27.476]                   ...future.rng), globalenv = if (FALSE) 
[13:24:27.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:27.476]                     ...future.globalenv.names))
[13:24:27.476]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:27.476]         }, condition = base::local({
[13:24:27.476]             c <- base::c
[13:24:27.476]             inherits <- base::inherits
[13:24:27.476]             invokeRestart <- base::invokeRestart
[13:24:27.476]             length <- base::length
[13:24:27.476]             list <- base::list
[13:24:27.476]             seq.int <- base::seq.int
[13:24:27.476]             signalCondition <- base::signalCondition
[13:24:27.476]             sys.calls <- base::sys.calls
[13:24:27.476]             `[[` <- base::`[[`
[13:24:27.476]             `+` <- base::`+`
[13:24:27.476]             `<<-` <- base::`<<-`
[13:24:27.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:27.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:27.476]                   3L)]
[13:24:27.476]             }
[13:24:27.476]             function(cond) {
[13:24:27.476]                 is_error <- inherits(cond, "error")
[13:24:27.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:27.476]                   NULL)
[13:24:27.476]                 if (is_error) {
[13:24:27.476]                   sessionInformation <- function() {
[13:24:27.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:27.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:27.476]                       search = base::search(), system = base::Sys.info())
[13:24:27.476]                   }
[13:24:27.476]                   ...future.conditions[[length(...future.conditions) + 
[13:24:27.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:27.476]                     cond$call), session = sessionInformation(), 
[13:24:27.476]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:27.476]                   signalCondition(cond)
[13:24:27.476]                 }
[13:24:27.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:27.476]                 "immediateCondition"))) {
[13:24:27.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:27.476]                   ...future.conditions[[length(...future.conditions) + 
[13:24:27.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:27.476]                   if (TRUE && !signal) {
[13:24:27.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:27.476]                     {
[13:24:27.476]                       inherits <- base::inherits
[13:24:27.476]                       invokeRestart <- base::invokeRestart
[13:24:27.476]                       is.null <- base::is.null
[13:24:27.476]                       muffled <- FALSE
[13:24:27.476]                       if (inherits(cond, "message")) {
[13:24:27.476]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:27.476]                         if (muffled) 
[13:24:27.476]                           invokeRestart("muffleMessage")
[13:24:27.476]                       }
[13:24:27.476]                       else if (inherits(cond, "warning")) {
[13:24:27.476]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:27.476]                         if (muffled) 
[13:24:27.476]                           invokeRestart("muffleWarning")
[13:24:27.476]                       }
[13:24:27.476]                       else if (inherits(cond, "condition")) {
[13:24:27.476]                         if (!is.null(pattern)) {
[13:24:27.476]                           computeRestarts <- base::computeRestarts
[13:24:27.476]                           grepl <- base::grepl
[13:24:27.476]                           restarts <- computeRestarts(cond)
[13:24:27.476]                           for (restart in restarts) {
[13:24:27.476]                             name <- restart$name
[13:24:27.476]                             if (is.null(name)) 
[13:24:27.476]                               next
[13:24:27.476]                             if (!grepl(pattern, name)) 
[13:24:27.476]                               next
[13:24:27.476]                             invokeRestart(restart)
[13:24:27.476]                             muffled <- TRUE
[13:24:27.476]                             break
[13:24:27.476]                           }
[13:24:27.476]                         }
[13:24:27.476]                       }
[13:24:27.476]                       invisible(muffled)
[13:24:27.476]                     }
[13:24:27.476]                     muffleCondition(cond, pattern = "^muffle")
[13:24:27.476]                   }
[13:24:27.476]                 }
[13:24:27.476]                 else {
[13:24:27.476]                   if (TRUE) {
[13:24:27.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:27.476]                     {
[13:24:27.476]                       inherits <- base::inherits
[13:24:27.476]                       invokeRestart <- base::invokeRestart
[13:24:27.476]                       is.null <- base::is.null
[13:24:27.476]                       muffled <- FALSE
[13:24:27.476]                       if (inherits(cond, "message")) {
[13:24:27.476]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:27.476]                         if (muffled) 
[13:24:27.476]                           invokeRestart("muffleMessage")
[13:24:27.476]                       }
[13:24:27.476]                       else if (inherits(cond, "warning")) {
[13:24:27.476]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:27.476]                         if (muffled) 
[13:24:27.476]                           invokeRestart("muffleWarning")
[13:24:27.476]                       }
[13:24:27.476]                       else if (inherits(cond, "condition")) {
[13:24:27.476]                         if (!is.null(pattern)) {
[13:24:27.476]                           computeRestarts <- base::computeRestarts
[13:24:27.476]                           grepl <- base::grepl
[13:24:27.476]                           restarts <- computeRestarts(cond)
[13:24:27.476]                           for (restart in restarts) {
[13:24:27.476]                             name <- restart$name
[13:24:27.476]                             if (is.null(name)) 
[13:24:27.476]                               next
[13:24:27.476]                             if (!grepl(pattern, name)) 
[13:24:27.476]                               next
[13:24:27.476]                             invokeRestart(restart)
[13:24:27.476]                             muffled <- TRUE
[13:24:27.476]                             break
[13:24:27.476]                           }
[13:24:27.476]                         }
[13:24:27.476]                       }
[13:24:27.476]                       invisible(muffled)
[13:24:27.476]                     }
[13:24:27.476]                     muffleCondition(cond, pattern = "^muffle")
[13:24:27.476]                   }
[13:24:27.476]                 }
[13:24:27.476]             }
[13:24:27.476]         }))
[13:24:27.476]     }, error = function(ex) {
[13:24:27.476]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:27.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:27.476]                 ...future.rng), started = ...future.startTime, 
[13:24:27.476]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:27.476]             version = "1.8"), class = "FutureResult")
[13:24:27.476]     }, finally = {
[13:24:27.476]         if (!identical(...future.workdir, getwd())) 
[13:24:27.476]             setwd(...future.workdir)
[13:24:27.476]         {
[13:24:27.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:27.476]                 ...future.oldOptions$nwarnings <- NULL
[13:24:27.476]             }
[13:24:27.476]             base::options(...future.oldOptions)
[13:24:27.476]             if (.Platform$OS.type == "windows") {
[13:24:27.476]                 old_names <- names(...future.oldEnvVars)
[13:24:27.476]                 envs <- base::Sys.getenv()
[13:24:27.476]                 names <- names(envs)
[13:24:27.476]                 common <- intersect(names, old_names)
[13:24:27.476]                 added <- setdiff(names, old_names)
[13:24:27.476]                 removed <- setdiff(old_names, names)
[13:24:27.476]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:27.476]                   envs[common]]
[13:24:27.476]                 NAMES <- toupper(changed)
[13:24:27.476]                 args <- list()
[13:24:27.476]                 for (kk in seq_along(NAMES)) {
[13:24:27.476]                   name <- changed[[kk]]
[13:24:27.476]                   NAME <- NAMES[[kk]]
[13:24:27.476]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:27.476]                     next
[13:24:27.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:27.476]                 }
[13:24:27.476]                 NAMES <- toupper(added)
[13:24:27.476]                 for (kk in seq_along(NAMES)) {
[13:24:27.476]                   name <- added[[kk]]
[13:24:27.476]                   NAME <- NAMES[[kk]]
[13:24:27.476]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:27.476]                     next
[13:24:27.476]                   args[[name]] <- ""
[13:24:27.476]                 }
[13:24:27.476]                 NAMES <- toupper(removed)
[13:24:27.476]                 for (kk in seq_along(NAMES)) {
[13:24:27.476]                   name <- removed[[kk]]
[13:24:27.476]                   NAME <- NAMES[[kk]]
[13:24:27.476]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:27.476]                     next
[13:24:27.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:27.476]                 }
[13:24:27.476]                 if (length(args) > 0) 
[13:24:27.476]                   base::do.call(base::Sys.setenv, args = args)
[13:24:27.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:27.476]             }
[13:24:27.476]             else {
[13:24:27.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:27.476]             }
[13:24:27.476]             {
[13:24:27.476]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:27.476]                   0L) {
[13:24:27.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:27.476]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:27.476]                   base::options(opts)
[13:24:27.476]                 }
[13:24:27.476]                 {
[13:24:27.476]                   {
[13:24:27.476]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:27.476]                     NULL
[13:24:27.476]                   }
[13:24:27.476]                   options(future.plan = NULL)
[13:24:27.476]                   if (is.na(NA_character_)) 
[13:24:27.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:27.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:27.476]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:27.476]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:27.476]                     envir = parent.frame()) 
[13:24:27.476]                   {
[13:24:27.476]                     if (is.function(workers)) 
[13:24:27.476]                       workers <- workers()
[13:24:27.476]                     workers <- structure(as.integer(workers), 
[13:24:27.476]                       class = class(workers))
[13:24:27.476]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:27.476]                       workers >= 1)
[13:24:27.476]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:27.476]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:27.476]                     }
[13:24:27.476]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:27.476]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:27.476]                       envir = envir)
[13:24:27.476]                     if (!future$lazy) 
[13:24:27.476]                       future <- run(future)
[13:24:27.476]                     invisible(future)
[13:24:27.476]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:27.476]                 }
[13:24:27.476]             }
[13:24:27.476]         }
[13:24:27.476]     })
[13:24:27.476]     if (TRUE) {
[13:24:27.476]         base::sink(type = "output", split = FALSE)
[13:24:27.476]         if (TRUE) {
[13:24:27.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:27.476]         }
[13:24:27.476]         else {
[13:24:27.476]             ...future.result["stdout"] <- base::list(NULL)
[13:24:27.476]         }
[13:24:27.476]         base::close(...future.stdout)
[13:24:27.476]         ...future.stdout <- NULL
[13:24:27.476]     }
[13:24:27.476]     ...future.result$conditions <- ...future.conditions
[13:24:27.476]     ...future.result$finished <- base::Sys.time()
[13:24:27.476]     ...future.result
[13:24:27.476] }
[13:24:27.479] MultisessionFuture started
[13:24:27.479] - Launch lazy future ... done
[13:24:27.479] run() for ‘MultisessionFuture’ ... done
[13:24:28.026] receiveMessageFromWorker() for ClusterFuture ...
[13:24:28.027] - Validating connection of MultisessionFuture
[13:24:28.027] - received message: FutureResult
[13:24:28.027] - Received FutureResult
[13:24:28.027] - Erased future from FutureRegistry
[13:24:28.027] result() for ClusterFuture ...
[13:24:28.027] - result already collected: FutureResult
[13:24:28.027] result() for ClusterFuture ... done
[13:24:28.028] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:28.028] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:24:28.028] getGlobalsAndPackages() ...
[13:24:28.028] Searching for globals...
[13:24:28.029] - globals found: [2] ‘list’, ‘stop’
[13:24:28.029] Searching for globals ... DONE
[13:24:28.029] Resolving globals: FALSE
[13:24:28.029] 
[13:24:28.029] 
[13:24:28.029] getGlobalsAndPackages() ... DONE
[13:24:28.030] run() for ‘Future’ ...
[13:24:28.030] - state: ‘created’
[13:24:28.030] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:28.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:28.044] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:28.045]   - Field: ‘node’
[13:24:28.045]   - Field: ‘label’
[13:24:28.045]   - Field: ‘local’
[13:24:28.045]   - Field: ‘owner’
[13:24:28.045]   - Field: ‘envir’
[13:24:28.045]   - Field: ‘workers’
[13:24:28.045]   - Field: ‘packages’
[13:24:28.045]   - Field: ‘gc’
[13:24:28.045]   - Field: ‘conditions’
[13:24:28.046]   - Field: ‘persistent’
[13:24:28.046]   - Field: ‘expr’
[13:24:28.046]   - Field: ‘uuid’
[13:24:28.046]   - Field: ‘seed’
[13:24:28.046]   - Field: ‘version’
[13:24:28.046]   - Field: ‘result’
[13:24:28.046]   - Field: ‘asynchronous’
[13:24:28.046]   - Field: ‘calls’
[13:24:28.046]   - Field: ‘globals’
[13:24:28.046]   - Field: ‘stdout’
[13:24:28.046]   - Field: ‘earlySignal’
[13:24:28.047]   - Field: ‘lazy’
[13:24:28.047]   - Field: ‘state’
[13:24:28.047] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:28.047] - Launch lazy future ...
[13:24:28.047] Packages needed by the future expression (n = 0): <none>
[13:24:28.047] Packages needed by future strategies (n = 0): <none>
[13:24:28.048] {
[13:24:28.048]     {
[13:24:28.048]         {
[13:24:28.048]             ...future.startTime <- base::Sys.time()
[13:24:28.048]             {
[13:24:28.048]                 {
[13:24:28.048]                   {
[13:24:28.048]                     {
[13:24:28.048]                       base::local({
[13:24:28.048]                         has_future <- base::requireNamespace("future", 
[13:24:28.048]                           quietly = TRUE)
[13:24:28.048]                         if (has_future) {
[13:24:28.048]                           ns <- base::getNamespace("future")
[13:24:28.048]                           version <- ns[[".package"]][["version"]]
[13:24:28.048]                           if (is.null(version)) 
[13:24:28.048]                             version <- utils::packageVersion("future")
[13:24:28.048]                         }
[13:24:28.048]                         else {
[13:24:28.048]                           version <- NULL
[13:24:28.048]                         }
[13:24:28.048]                         if (!has_future || version < "1.8.0") {
[13:24:28.048]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:28.048]                             "", base::R.version$version.string), 
[13:24:28.048]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:28.048]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:28.048]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:28.048]                               "release", "version")], collapse = " "), 
[13:24:28.048]                             hostname = base::Sys.info()[["nodename"]])
[13:24:28.048]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:28.048]                             info)
[13:24:28.048]                           info <- base::paste(info, collapse = "; ")
[13:24:28.048]                           if (!has_future) {
[13:24:28.048]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:28.048]                               info)
[13:24:28.048]                           }
[13:24:28.048]                           else {
[13:24:28.048]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:28.048]                               info, version)
[13:24:28.048]                           }
[13:24:28.048]                           base::stop(msg)
[13:24:28.048]                         }
[13:24:28.048]                       })
[13:24:28.048]                     }
[13:24:28.048]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:28.048]                     base::options(mc.cores = 1L)
[13:24:28.048]                   }
[13:24:28.048]                   options(future.plan = NULL)
[13:24:28.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:28.048]                 }
[13:24:28.048]                 ...future.workdir <- getwd()
[13:24:28.048]             }
[13:24:28.048]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:28.048]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:28.048]         }
[13:24:28.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:28.048]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:28.048]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:28.048]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:28.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:28.048]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:28.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:28.048]             base::names(...future.oldOptions))
[13:24:28.048]     }
[13:24:28.048]     if (FALSE) {
[13:24:28.048]     }
[13:24:28.048]     else {
[13:24:28.048]         if (TRUE) {
[13:24:28.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:28.048]                 open = "w")
[13:24:28.048]         }
[13:24:28.048]         else {
[13:24:28.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:28.048]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:28.048]         }
[13:24:28.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:28.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:28.048]             base::sink(type = "output", split = FALSE)
[13:24:28.048]             base::close(...future.stdout)
[13:24:28.048]         }, add = TRUE)
[13:24:28.048]     }
[13:24:28.048]     ...future.frame <- base::sys.nframe()
[13:24:28.048]     ...future.conditions <- base::list()
[13:24:28.048]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:28.048]     if (FALSE) {
[13:24:28.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:28.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:28.048]     }
[13:24:28.048]     ...future.result <- base::tryCatch({
[13:24:28.048]         base::withCallingHandlers({
[13:24:28.048]             ...future.value <- base::withVisible(base::local({
[13:24:28.048]                 ...future.makeSendCondition <- base::local({
[13:24:28.048]                   sendCondition <- NULL
[13:24:28.048]                   function(frame = 1L) {
[13:24:28.048]                     if (is.function(sendCondition)) 
[13:24:28.048]                       return(sendCondition)
[13:24:28.048]                     ns <- getNamespace("parallel")
[13:24:28.048]                     if (exists("sendData", mode = "function", 
[13:24:28.048]                       envir = ns)) {
[13:24:28.048]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:28.048]                         envir = ns)
[13:24:28.048]                       envir <- sys.frame(frame)
[13:24:28.048]                       master <- NULL
[13:24:28.048]                       while (!identical(envir, .GlobalEnv) && 
[13:24:28.048]                         !identical(envir, emptyenv())) {
[13:24:28.048]                         if (exists("master", mode = "list", envir = envir, 
[13:24:28.048]                           inherits = FALSE)) {
[13:24:28.048]                           master <- get("master", mode = "list", 
[13:24:28.048]                             envir = envir, inherits = FALSE)
[13:24:28.048]                           if (inherits(master, c("SOCKnode", 
[13:24:28.048]                             "SOCK0node"))) {
[13:24:28.048]                             sendCondition <<- function(cond) {
[13:24:28.048]                               data <- list(type = "VALUE", value = cond, 
[13:24:28.048]                                 success = TRUE)
[13:24:28.048]                               parallel_sendData(master, data)
[13:24:28.048]                             }
[13:24:28.048]                             return(sendCondition)
[13:24:28.048]                           }
[13:24:28.048]                         }
[13:24:28.048]                         frame <- frame + 1L
[13:24:28.048]                         envir <- sys.frame(frame)
[13:24:28.048]                       }
[13:24:28.048]                     }
[13:24:28.048]                     sendCondition <<- function(cond) NULL
[13:24:28.048]                   }
[13:24:28.048]                 })
[13:24:28.048]                 withCallingHandlers({
[13:24:28.048]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:28.048]                 }, immediateCondition = function(cond) {
[13:24:28.048]                   sendCondition <- ...future.makeSendCondition()
[13:24:28.048]                   sendCondition(cond)
[13:24:28.048]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.048]                   {
[13:24:28.048]                     inherits <- base::inherits
[13:24:28.048]                     invokeRestart <- base::invokeRestart
[13:24:28.048]                     is.null <- base::is.null
[13:24:28.048]                     muffled <- FALSE
[13:24:28.048]                     if (inherits(cond, "message")) {
[13:24:28.048]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:28.048]                       if (muffled) 
[13:24:28.048]                         invokeRestart("muffleMessage")
[13:24:28.048]                     }
[13:24:28.048]                     else if (inherits(cond, "warning")) {
[13:24:28.048]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:28.048]                       if (muffled) 
[13:24:28.048]                         invokeRestart("muffleWarning")
[13:24:28.048]                     }
[13:24:28.048]                     else if (inherits(cond, "condition")) {
[13:24:28.048]                       if (!is.null(pattern)) {
[13:24:28.048]                         computeRestarts <- base::computeRestarts
[13:24:28.048]                         grepl <- base::grepl
[13:24:28.048]                         restarts <- computeRestarts(cond)
[13:24:28.048]                         for (restart in restarts) {
[13:24:28.048]                           name <- restart$name
[13:24:28.048]                           if (is.null(name)) 
[13:24:28.048]                             next
[13:24:28.048]                           if (!grepl(pattern, name)) 
[13:24:28.048]                             next
[13:24:28.048]                           invokeRestart(restart)
[13:24:28.048]                           muffled <- TRUE
[13:24:28.048]                           break
[13:24:28.048]                         }
[13:24:28.048]                       }
[13:24:28.048]                     }
[13:24:28.048]                     invisible(muffled)
[13:24:28.048]                   }
[13:24:28.048]                   muffleCondition(cond)
[13:24:28.048]                 })
[13:24:28.048]             }))
[13:24:28.048]             future::FutureResult(value = ...future.value$value, 
[13:24:28.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.048]                   ...future.rng), globalenv = if (FALSE) 
[13:24:28.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:28.048]                     ...future.globalenv.names))
[13:24:28.048]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:28.048]         }, condition = base::local({
[13:24:28.048]             c <- base::c
[13:24:28.048]             inherits <- base::inherits
[13:24:28.048]             invokeRestart <- base::invokeRestart
[13:24:28.048]             length <- base::length
[13:24:28.048]             list <- base::list
[13:24:28.048]             seq.int <- base::seq.int
[13:24:28.048]             signalCondition <- base::signalCondition
[13:24:28.048]             sys.calls <- base::sys.calls
[13:24:28.048]             `[[` <- base::`[[`
[13:24:28.048]             `+` <- base::`+`
[13:24:28.048]             `<<-` <- base::`<<-`
[13:24:28.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:28.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:28.048]                   3L)]
[13:24:28.048]             }
[13:24:28.048]             function(cond) {
[13:24:28.048]                 is_error <- inherits(cond, "error")
[13:24:28.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:28.048]                   NULL)
[13:24:28.048]                 if (is_error) {
[13:24:28.048]                   sessionInformation <- function() {
[13:24:28.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:28.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:28.048]                       search = base::search(), system = base::Sys.info())
[13:24:28.048]                   }
[13:24:28.048]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:28.048]                     cond$call), session = sessionInformation(), 
[13:24:28.048]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:28.048]                   signalCondition(cond)
[13:24:28.048]                 }
[13:24:28.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:28.048]                 "immediateCondition"))) {
[13:24:28.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:28.048]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:28.048]                   if (TRUE && !signal) {
[13:24:28.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.048]                     {
[13:24:28.048]                       inherits <- base::inherits
[13:24:28.048]                       invokeRestart <- base::invokeRestart
[13:24:28.048]                       is.null <- base::is.null
[13:24:28.048]                       muffled <- FALSE
[13:24:28.048]                       if (inherits(cond, "message")) {
[13:24:28.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.048]                         if (muffled) 
[13:24:28.048]                           invokeRestart("muffleMessage")
[13:24:28.048]                       }
[13:24:28.048]                       else if (inherits(cond, "warning")) {
[13:24:28.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.048]                         if (muffled) 
[13:24:28.048]                           invokeRestart("muffleWarning")
[13:24:28.048]                       }
[13:24:28.048]                       else if (inherits(cond, "condition")) {
[13:24:28.048]                         if (!is.null(pattern)) {
[13:24:28.048]                           computeRestarts <- base::computeRestarts
[13:24:28.048]                           grepl <- base::grepl
[13:24:28.048]                           restarts <- computeRestarts(cond)
[13:24:28.048]                           for (restart in restarts) {
[13:24:28.048]                             name <- restart$name
[13:24:28.048]                             if (is.null(name)) 
[13:24:28.048]                               next
[13:24:28.048]                             if (!grepl(pattern, name)) 
[13:24:28.048]                               next
[13:24:28.048]                             invokeRestart(restart)
[13:24:28.048]                             muffled <- TRUE
[13:24:28.048]                             break
[13:24:28.048]                           }
[13:24:28.048]                         }
[13:24:28.048]                       }
[13:24:28.048]                       invisible(muffled)
[13:24:28.048]                     }
[13:24:28.048]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.048]                   }
[13:24:28.048]                 }
[13:24:28.048]                 else {
[13:24:28.048]                   if (TRUE) {
[13:24:28.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.048]                     {
[13:24:28.048]                       inherits <- base::inherits
[13:24:28.048]                       invokeRestart <- base::invokeRestart
[13:24:28.048]                       is.null <- base::is.null
[13:24:28.048]                       muffled <- FALSE
[13:24:28.048]                       if (inherits(cond, "message")) {
[13:24:28.048]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.048]                         if (muffled) 
[13:24:28.048]                           invokeRestart("muffleMessage")
[13:24:28.048]                       }
[13:24:28.048]                       else if (inherits(cond, "warning")) {
[13:24:28.048]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.048]                         if (muffled) 
[13:24:28.048]                           invokeRestart("muffleWarning")
[13:24:28.048]                       }
[13:24:28.048]                       else if (inherits(cond, "condition")) {
[13:24:28.048]                         if (!is.null(pattern)) {
[13:24:28.048]                           computeRestarts <- base::computeRestarts
[13:24:28.048]                           grepl <- base::grepl
[13:24:28.048]                           restarts <- computeRestarts(cond)
[13:24:28.048]                           for (restart in restarts) {
[13:24:28.048]                             name <- restart$name
[13:24:28.048]                             if (is.null(name)) 
[13:24:28.048]                               next
[13:24:28.048]                             if (!grepl(pattern, name)) 
[13:24:28.048]                               next
[13:24:28.048]                             invokeRestart(restart)
[13:24:28.048]                             muffled <- TRUE
[13:24:28.048]                             break
[13:24:28.048]                           }
[13:24:28.048]                         }
[13:24:28.048]                       }
[13:24:28.048]                       invisible(muffled)
[13:24:28.048]                     }
[13:24:28.048]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.048]                   }
[13:24:28.048]                 }
[13:24:28.048]             }
[13:24:28.048]         }))
[13:24:28.048]     }, error = function(ex) {
[13:24:28.048]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:28.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.048]                 ...future.rng), started = ...future.startTime, 
[13:24:28.048]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:28.048]             version = "1.8"), class = "FutureResult")
[13:24:28.048]     }, finally = {
[13:24:28.048]         if (!identical(...future.workdir, getwd())) 
[13:24:28.048]             setwd(...future.workdir)
[13:24:28.048]         {
[13:24:28.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:28.048]                 ...future.oldOptions$nwarnings <- NULL
[13:24:28.048]             }
[13:24:28.048]             base::options(...future.oldOptions)
[13:24:28.048]             if (.Platform$OS.type == "windows") {
[13:24:28.048]                 old_names <- names(...future.oldEnvVars)
[13:24:28.048]                 envs <- base::Sys.getenv()
[13:24:28.048]                 names <- names(envs)
[13:24:28.048]                 common <- intersect(names, old_names)
[13:24:28.048]                 added <- setdiff(names, old_names)
[13:24:28.048]                 removed <- setdiff(old_names, names)
[13:24:28.048]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:28.048]                   envs[common]]
[13:24:28.048]                 NAMES <- toupper(changed)
[13:24:28.048]                 args <- list()
[13:24:28.048]                 for (kk in seq_along(NAMES)) {
[13:24:28.048]                   name <- changed[[kk]]
[13:24:28.048]                   NAME <- NAMES[[kk]]
[13:24:28.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.048]                     next
[13:24:28.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.048]                 }
[13:24:28.048]                 NAMES <- toupper(added)
[13:24:28.048]                 for (kk in seq_along(NAMES)) {
[13:24:28.048]                   name <- added[[kk]]
[13:24:28.048]                   NAME <- NAMES[[kk]]
[13:24:28.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.048]                     next
[13:24:28.048]                   args[[name]] <- ""
[13:24:28.048]                 }
[13:24:28.048]                 NAMES <- toupper(removed)
[13:24:28.048]                 for (kk in seq_along(NAMES)) {
[13:24:28.048]                   name <- removed[[kk]]
[13:24:28.048]                   NAME <- NAMES[[kk]]
[13:24:28.048]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.048]                     next
[13:24:28.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.048]                 }
[13:24:28.048]                 if (length(args) > 0) 
[13:24:28.048]                   base::do.call(base::Sys.setenv, args = args)
[13:24:28.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:28.048]             }
[13:24:28.048]             else {
[13:24:28.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:28.048]             }
[13:24:28.048]             {
[13:24:28.048]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:28.048]                   0L) {
[13:24:28.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:28.048]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:28.048]                   base::options(opts)
[13:24:28.048]                 }
[13:24:28.048]                 {
[13:24:28.048]                   {
[13:24:28.048]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:28.048]                     NULL
[13:24:28.048]                   }
[13:24:28.048]                   options(future.plan = NULL)
[13:24:28.048]                   if (is.na(NA_character_)) 
[13:24:28.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:28.048]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:28.048]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:28.048]                     envir = parent.frame()) 
[13:24:28.048]                   {
[13:24:28.048]                     if (is.function(workers)) 
[13:24:28.048]                       workers <- workers()
[13:24:28.048]                     workers <- structure(as.integer(workers), 
[13:24:28.048]                       class = class(workers))
[13:24:28.048]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:28.048]                       workers >= 1)
[13:24:28.048]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:28.048]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:28.048]                     }
[13:24:28.048]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:28.048]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:28.048]                       envir = envir)
[13:24:28.048]                     if (!future$lazy) 
[13:24:28.048]                       future <- run(future)
[13:24:28.048]                     invisible(future)
[13:24:28.048]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:28.048]                 }
[13:24:28.048]             }
[13:24:28.048]         }
[13:24:28.048]     })
[13:24:28.048]     if (TRUE) {
[13:24:28.048]         base::sink(type = "output", split = FALSE)
[13:24:28.048]         if (TRUE) {
[13:24:28.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:28.048]         }
[13:24:28.048]         else {
[13:24:28.048]             ...future.result["stdout"] <- base::list(NULL)
[13:24:28.048]         }
[13:24:28.048]         base::close(...future.stdout)
[13:24:28.048]         ...future.stdout <- NULL
[13:24:28.048]     }
[13:24:28.048]     ...future.result$conditions <- ...future.conditions
[13:24:28.048]     ...future.result$finished <- base::Sys.time()
[13:24:28.048]     ...future.result
[13:24:28.048] }
[13:24:28.051] MultisessionFuture started
[13:24:28.051] - Launch lazy future ... done
[13:24:28.051] run() for ‘MultisessionFuture’ ... done
[13:24:28.097] receiveMessageFromWorker() for ClusterFuture ...
[13:24:28.098] - Validating connection of MultisessionFuture
[13:24:28.098] - received message: FutureResult
[13:24:28.098] - Received FutureResult
[13:24:28.099] - Erased future from FutureRegistry
[13:24:28.099] result() for ClusterFuture ...
[13:24:28.099] - result already collected: FutureResult
[13:24:28.099] result() for ClusterFuture ... done
[13:24:28.099] signalConditions() ...
[13:24:28.099]  - include = ‘immediateCondition’
[13:24:28.099]  - exclude = 
[13:24:28.099]  - resignal = FALSE
[13:24:28.100]  - Number of conditions: 1
[13:24:28.100] signalConditions() ... done
[13:24:28.100] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:28.100] A MultisessionFuture was resolved (result was not collected)
[13:24:28.100] getGlobalsAndPackages() ...
[13:24:28.100] Searching for globals...
[13:24:28.101] - globals found: [2] ‘list’, ‘stop’
[13:24:28.101] Searching for globals ... DONE
[13:24:28.101] Resolving globals: FALSE
[13:24:28.101] 
[13:24:28.102] 
[13:24:28.102] getGlobalsAndPackages() ... DONE
[13:24:28.102] run() for ‘Future’ ...
[13:24:28.102] - state: ‘created’
[13:24:28.102] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:28.117] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:28.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:28.117]   - Field: ‘node’
[13:24:28.117]   - Field: ‘label’
[13:24:28.119]   - Field: ‘local’
[13:24:28.119]   - Field: ‘owner’
[13:24:28.119]   - Field: ‘envir’
[13:24:28.119]   - Field: ‘workers’
[13:24:28.119]   - Field: ‘packages’
[13:24:28.120]   - Field: ‘gc’
[13:24:28.120]   - Field: ‘conditions’
[13:24:28.120]   - Field: ‘persistent’
[13:24:28.120]   - Field: ‘expr’
[13:24:28.120]   - Field: ‘uuid’
[13:24:28.120]   - Field: ‘seed’
[13:24:28.120]   - Field: ‘version’
[13:24:28.120]   - Field: ‘result’
[13:24:28.120]   - Field: ‘asynchronous’
[13:24:28.120]   - Field: ‘calls’
[13:24:28.120]   - Field: ‘globals’
[13:24:28.121]   - Field: ‘stdout’
[13:24:28.121]   - Field: ‘earlySignal’
[13:24:28.121]   - Field: ‘lazy’
[13:24:28.121]   - Field: ‘state’
[13:24:28.121] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:28.121] - Launch lazy future ...
[13:24:28.121] Packages needed by the future expression (n = 0): <none>
[13:24:28.121] Packages needed by future strategies (n = 0): <none>
[13:24:28.122] {
[13:24:28.122]     {
[13:24:28.122]         {
[13:24:28.122]             ...future.startTime <- base::Sys.time()
[13:24:28.122]             {
[13:24:28.122]                 {
[13:24:28.122]                   {
[13:24:28.122]                     {
[13:24:28.122]                       base::local({
[13:24:28.122]                         has_future <- base::requireNamespace("future", 
[13:24:28.122]                           quietly = TRUE)
[13:24:28.122]                         if (has_future) {
[13:24:28.122]                           ns <- base::getNamespace("future")
[13:24:28.122]                           version <- ns[[".package"]][["version"]]
[13:24:28.122]                           if (is.null(version)) 
[13:24:28.122]                             version <- utils::packageVersion("future")
[13:24:28.122]                         }
[13:24:28.122]                         else {
[13:24:28.122]                           version <- NULL
[13:24:28.122]                         }
[13:24:28.122]                         if (!has_future || version < "1.8.0") {
[13:24:28.122]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:28.122]                             "", base::R.version$version.string), 
[13:24:28.122]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:28.122]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:28.122]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:28.122]                               "release", "version")], collapse = " "), 
[13:24:28.122]                             hostname = base::Sys.info()[["nodename"]])
[13:24:28.122]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:28.122]                             info)
[13:24:28.122]                           info <- base::paste(info, collapse = "; ")
[13:24:28.122]                           if (!has_future) {
[13:24:28.122]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:28.122]                               info)
[13:24:28.122]                           }
[13:24:28.122]                           else {
[13:24:28.122]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:28.122]                               info, version)
[13:24:28.122]                           }
[13:24:28.122]                           base::stop(msg)
[13:24:28.122]                         }
[13:24:28.122]                       })
[13:24:28.122]                     }
[13:24:28.122]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:28.122]                     base::options(mc.cores = 1L)
[13:24:28.122]                   }
[13:24:28.122]                   options(future.plan = NULL)
[13:24:28.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:28.122]                 }
[13:24:28.122]                 ...future.workdir <- getwd()
[13:24:28.122]             }
[13:24:28.122]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:28.122]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:28.122]         }
[13:24:28.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:28.122]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:28.122]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:28.122]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:28.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:28.122]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:28.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:28.122]             base::names(...future.oldOptions))
[13:24:28.122]     }
[13:24:28.122]     if (FALSE) {
[13:24:28.122]     }
[13:24:28.122]     else {
[13:24:28.122]         if (TRUE) {
[13:24:28.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:28.122]                 open = "w")
[13:24:28.122]         }
[13:24:28.122]         else {
[13:24:28.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:28.122]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:28.122]         }
[13:24:28.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:28.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:28.122]             base::sink(type = "output", split = FALSE)
[13:24:28.122]             base::close(...future.stdout)
[13:24:28.122]         }, add = TRUE)
[13:24:28.122]     }
[13:24:28.122]     ...future.frame <- base::sys.nframe()
[13:24:28.122]     ...future.conditions <- base::list()
[13:24:28.122]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:28.122]     if (FALSE) {
[13:24:28.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:28.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:28.122]     }
[13:24:28.122]     ...future.result <- base::tryCatch({
[13:24:28.122]         base::withCallingHandlers({
[13:24:28.122]             ...future.value <- base::withVisible(base::local({
[13:24:28.122]                 ...future.makeSendCondition <- base::local({
[13:24:28.122]                   sendCondition <- NULL
[13:24:28.122]                   function(frame = 1L) {
[13:24:28.122]                     if (is.function(sendCondition)) 
[13:24:28.122]                       return(sendCondition)
[13:24:28.122]                     ns <- getNamespace("parallel")
[13:24:28.122]                     if (exists("sendData", mode = "function", 
[13:24:28.122]                       envir = ns)) {
[13:24:28.122]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:28.122]                         envir = ns)
[13:24:28.122]                       envir <- sys.frame(frame)
[13:24:28.122]                       master <- NULL
[13:24:28.122]                       while (!identical(envir, .GlobalEnv) && 
[13:24:28.122]                         !identical(envir, emptyenv())) {
[13:24:28.122]                         if (exists("master", mode = "list", envir = envir, 
[13:24:28.122]                           inherits = FALSE)) {
[13:24:28.122]                           master <- get("master", mode = "list", 
[13:24:28.122]                             envir = envir, inherits = FALSE)
[13:24:28.122]                           if (inherits(master, c("SOCKnode", 
[13:24:28.122]                             "SOCK0node"))) {
[13:24:28.122]                             sendCondition <<- function(cond) {
[13:24:28.122]                               data <- list(type = "VALUE", value = cond, 
[13:24:28.122]                                 success = TRUE)
[13:24:28.122]                               parallel_sendData(master, data)
[13:24:28.122]                             }
[13:24:28.122]                             return(sendCondition)
[13:24:28.122]                           }
[13:24:28.122]                         }
[13:24:28.122]                         frame <- frame + 1L
[13:24:28.122]                         envir <- sys.frame(frame)
[13:24:28.122]                       }
[13:24:28.122]                     }
[13:24:28.122]                     sendCondition <<- function(cond) NULL
[13:24:28.122]                   }
[13:24:28.122]                 })
[13:24:28.122]                 withCallingHandlers({
[13:24:28.122]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:28.122]                 }, immediateCondition = function(cond) {
[13:24:28.122]                   sendCondition <- ...future.makeSendCondition()
[13:24:28.122]                   sendCondition(cond)
[13:24:28.122]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.122]                   {
[13:24:28.122]                     inherits <- base::inherits
[13:24:28.122]                     invokeRestart <- base::invokeRestart
[13:24:28.122]                     is.null <- base::is.null
[13:24:28.122]                     muffled <- FALSE
[13:24:28.122]                     if (inherits(cond, "message")) {
[13:24:28.122]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:28.122]                       if (muffled) 
[13:24:28.122]                         invokeRestart("muffleMessage")
[13:24:28.122]                     }
[13:24:28.122]                     else if (inherits(cond, "warning")) {
[13:24:28.122]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:28.122]                       if (muffled) 
[13:24:28.122]                         invokeRestart("muffleWarning")
[13:24:28.122]                     }
[13:24:28.122]                     else if (inherits(cond, "condition")) {
[13:24:28.122]                       if (!is.null(pattern)) {
[13:24:28.122]                         computeRestarts <- base::computeRestarts
[13:24:28.122]                         grepl <- base::grepl
[13:24:28.122]                         restarts <- computeRestarts(cond)
[13:24:28.122]                         for (restart in restarts) {
[13:24:28.122]                           name <- restart$name
[13:24:28.122]                           if (is.null(name)) 
[13:24:28.122]                             next
[13:24:28.122]                           if (!grepl(pattern, name)) 
[13:24:28.122]                             next
[13:24:28.122]                           invokeRestart(restart)
[13:24:28.122]                           muffled <- TRUE
[13:24:28.122]                           break
[13:24:28.122]                         }
[13:24:28.122]                       }
[13:24:28.122]                     }
[13:24:28.122]                     invisible(muffled)
[13:24:28.122]                   }
[13:24:28.122]                   muffleCondition(cond)
[13:24:28.122]                 })
[13:24:28.122]             }))
[13:24:28.122]             future::FutureResult(value = ...future.value$value, 
[13:24:28.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.122]                   ...future.rng), globalenv = if (FALSE) 
[13:24:28.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:28.122]                     ...future.globalenv.names))
[13:24:28.122]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:28.122]         }, condition = base::local({
[13:24:28.122]             c <- base::c
[13:24:28.122]             inherits <- base::inherits
[13:24:28.122]             invokeRestart <- base::invokeRestart
[13:24:28.122]             length <- base::length
[13:24:28.122]             list <- base::list
[13:24:28.122]             seq.int <- base::seq.int
[13:24:28.122]             signalCondition <- base::signalCondition
[13:24:28.122]             sys.calls <- base::sys.calls
[13:24:28.122]             `[[` <- base::`[[`
[13:24:28.122]             `+` <- base::`+`
[13:24:28.122]             `<<-` <- base::`<<-`
[13:24:28.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:28.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:28.122]                   3L)]
[13:24:28.122]             }
[13:24:28.122]             function(cond) {
[13:24:28.122]                 is_error <- inherits(cond, "error")
[13:24:28.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:28.122]                   NULL)
[13:24:28.122]                 if (is_error) {
[13:24:28.122]                   sessionInformation <- function() {
[13:24:28.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:28.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:28.122]                       search = base::search(), system = base::Sys.info())
[13:24:28.122]                   }
[13:24:28.122]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:28.122]                     cond$call), session = sessionInformation(), 
[13:24:28.122]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:28.122]                   signalCondition(cond)
[13:24:28.122]                 }
[13:24:28.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:28.122]                 "immediateCondition"))) {
[13:24:28.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:28.122]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:28.122]                   if (TRUE && !signal) {
[13:24:28.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.122]                     {
[13:24:28.122]                       inherits <- base::inherits
[13:24:28.122]                       invokeRestart <- base::invokeRestart
[13:24:28.122]                       is.null <- base::is.null
[13:24:28.122]                       muffled <- FALSE
[13:24:28.122]                       if (inherits(cond, "message")) {
[13:24:28.122]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.122]                         if (muffled) 
[13:24:28.122]                           invokeRestart("muffleMessage")
[13:24:28.122]                       }
[13:24:28.122]                       else if (inherits(cond, "warning")) {
[13:24:28.122]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.122]                         if (muffled) 
[13:24:28.122]                           invokeRestart("muffleWarning")
[13:24:28.122]                       }
[13:24:28.122]                       else if (inherits(cond, "condition")) {
[13:24:28.122]                         if (!is.null(pattern)) {
[13:24:28.122]                           computeRestarts <- base::computeRestarts
[13:24:28.122]                           grepl <- base::grepl
[13:24:28.122]                           restarts <- computeRestarts(cond)
[13:24:28.122]                           for (restart in restarts) {
[13:24:28.122]                             name <- restart$name
[13:24:28.122]                             if (is.null(name)) 
[13:24:28.122]                               next
[13:24:28.122]                             if (!grepl(pattern, name)) 
[13:24:28.122]                               next
[13:24:28.122]                             invokeRestart(restart)
[13:24:28.122]                             muffled <- TRUE
[13:24:28.122]                             break
[13:24:28.122]                           }
[13:24:28.122]                         }
[13:24:28.122]                       }
[13:24:28.122]                       invisible(muffled)
[13:24:28.122]                     }
[13:24:28.122]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.122]                   }
[13:24:28.122]                 }
[13:24:28.122]                 else {
[13:24:28.122]                   if (TRUE) {
[13:24:28.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.122]                     {
[13:24:28.122]                       inherits <- base::inherits
[13:24:28.122]                       invokeRestart <- base::invokeRestart
[13:24:28.122]                       is.null <- base::is.null
[13:24:28.122]                       muffled <- FALSE
[13:24:28.122]                       if (inherits(cond, "message")) {
[13:24:28.122]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.122]                         if (muffled) 
[13:24:28.122]                           invokeRestart("muffleMessage")
[13:24:28.122]                       }
[13:24:28.122]                       else if (inherits(cond, "warning")) {
[13:24:28.122]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.122]                         if (muffled) 
[13:24:28.122]                           invokeRestart("muffleWarning")
[13:24:28.122]                       }
[13:24:28.122]                       else if (inherits(cond, "condition")) {
[13:24:28.122]                         if (!is.null(pattern)) {
[13:24:28.122]                           computeRestarts <- base::computeRestarts
[13:24:28.122]                           grepl <- base::grepl
[13:24:28.122]                           restarts <- computeRestarts(cond)
[13:24:28.122]                           for (restart in restarts) {
[13:24:28.122]                             name <- restart$name
[13:24:28.122]                             if (is.null(name)) 
[13:24:28.122]                               next
[13:24:28.122]                             if (!grepl(pattern, name)) 
[13:24:28.122]                               next
[13:24:28.122]                             invokeRestart(restart)
[13:24:28.122]                             muffled <- TRUE
[13:24:28.122]                             break
[13:24:28.122]                           }
[13:24:28.122]                         }
[13:24:28.122]                       }
[13:24:28.122]                       invisible(muffled)
[13:24:28.122]                     }
[13:24:28.122]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.122]                   }
[13:24:28.122]                 }
[13:24:28.122]             }
[13:24:28.122]         }))
[13:24:28.122]     }, error = function(ex) {
[13:24:28.122]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:28.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.122]                 ...future.rng), started = ...future.startTime, 
[13:24:28.122]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:28.122]             version = "1.8"), class = "FutureResult")
[13:24:28.122]     }, finally = {
[13:24:28.122]         if (!identical(...future.workdir, getwd())) 
[13:24:28.122]             setwd(...future.workdir)
[13:24:28.122]         {
[13:24:28.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:28.122]                 ...future.oldOptions$nwarnings <- NULL
[13:24:28.122]             }
[13:24:28.122]             base::options(...future.oldOptions)
[13:24:28.122]             if (.Platform$OS.type == "windows") {
[13:24:28.122]                 old_names <- names(...future.oldEnvVars)
[13:24:28.122]                 envs <- base::Sys.getenv()
[13:24:28.122]                 names <- names(envs)
[13:24:28.122]                 common <- intersect(names, old_names)
[13:24:28.122]                 added <- setdiff(names, old_names)
[13:24:28.122]                 removed <- setdiff(old_names, names)
[13:24:28.122]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:28.122]                   envs[common]]
[13:24:28.122]                 NAMES <- toupper(changed)
[13:24:28.122]                 args <- list()
[13:24:28.122]                 for (kk in seq_along(NAMES)) {
[13:24:28.122]                   name <- changed[[kk]]
[13:24:28.122]                   NAME <- NAMES[[kk]]
[13:24:28.122]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.122]                     next
[13:24:28.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.122]                 }
[13:24:28.122]                 NAMES <- toupper(added)
[13:24:28.122]                 for (kk in seq_along(NAMES)) {
[13:24:28.122]                   name <- added[[kk]]
[13:24:28.122]                   NAME <- NAMES[[kk]]
[13:24:28.122]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.122]                     next
[13:24:28.122]                   args[[name]] <- ""
[13:24:28.122]                 }
[13:24:28.122]                 NAMES <- toupper(removed)
[13:24:28.122]                 for (kk in seq_along(NAMES)) {
[13:24:28.122]                   name <- removed[[kk]]
[13:24:28.122]                   NAME <- NAMES[[kk]]
[13:24:28.122]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.122]                     next
[13:24:28.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.122]                 }
[13:24:28.122]                 if (length(args) > 0) 
[13:24:28.122]                   base::do.call(base::Sys.setenv, args = args)
[13:24:28.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:28.122]             }
[13:24:28.122]             else {
[13:24:28.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:28.122]             }
[13:24:28.122]             {
[13:24:28.122]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:28.122]                   0L) {
[13:24:28.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:28.122]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:28.122]                   base::options(opts)
[13:24:28.122]                 }
[13:24:28.122]                 {
[13:24:28.122]                   {
[13:24:28.122]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:28.122]                     NULL
[13:24:28.122]                   }
[13:24:28.122]                   options(future.plan = NULL)
[13:24:28.122]                   if (is.na(NA_character_)) 
[13:24:28.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:28.122]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:28.122]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:28.122]                     envir = parent.frame()) 
[13:24:28.122]                   {
[13:24:28.122]                     if (is.function(workers)) 
[13:24:28.122]                       workers <- workers()
[13:24:28.122]                     workers <- structure(as.integer(workers), 
[13:24:28.122]                       class = class(workers))
[13:24:28.122]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:28.122]                       workers >= 1)
[13:24:28.122]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:28.122]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:28.122]                     }
[13:24:28.122]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:28.122]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:28.122]                       envir = envir)
[13:24:28.122]                     if (!future$lazy) 
[13:24:28.122]                       future <- run(future)
[13:24:28.122]                     invisible(future)
[13:24:28.122]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:28.122]                 }
[13:24:28.122]             }
[13:24:28.122]         }
[13:24:28.122]     })
[13:24:28.122]     if (TRUE) {
[13:24:28.122]         base::sink(type = "output", split = FALSE)
[13:24:28.122]         if (TRUE) {
[13:24:28.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:28.122]         }
[13:24:28.122]         else {
[13:24:28.122]             ...future.result["stdout"] <- base::list(NULL)
[13:24:28.122]         }
[13:24:28.122]         base::close(...future.stdout)
[13:24:28.122]         ...future.stdout <- NULL
[13:24:28.122]     }
[13:24:28.122]     ...future.result$conditions <- ...future.conditions
[13:24:28.122]     ...future.result$finished <- base::Sys.time()
[13:24:28.122]     ...future.result
[13:24:28.122] }
[13:24:28.125] MultisessionFuture started
[13:24:28.125] - Launch lazy future ... done
[13:24:28.125] run() for ‘MultisessionFuture’ ... done
[13:24:28.173] receiveMessageFromWorker() for ClusterFuture ...
[13:24:28.173] - Validating connection of MultisessionFuture
[13:24:28.174] - received message: FutureResult
[13:24:28.174] - Received FutureResult
[13:24:28.174] - Erased future from FutureRegistry
[13:24:28.174] result() for ClusterFuture ...
[13:24:28.174] - result already collected: FutureResult
[13:24:28.174] result() for ClusterFuture ... done
[13:24:28.174] signalConditions() ...
[13:24:28.174]  - include = ‘immediateCondition’
[13:24:28.175]  - exclude = 
[13:24:28.175]  - resignal = FALSE
[13:24:28.175]  - Number of conditions: 1
[13:24:28.175] signalConditions() ... done
[13:24:28.175] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:28.175] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[13:24:28.175] getGlobalsAndPackages() ...
[13:24:28.175] Searching for globals...
[13:24:28.177] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:28.177] Searching for globals ... DONE
[13:24:28.177] Resolving globals: FALSE
[13:24:28.177] 
[13:24:28.177] 
[13:24:28.177] getGlobalsAndPackages() ... DONE
[13:24:28.178] run() for ‘Future’ ...
[13:24:28.178] - state: ‘created’
[13:24:28.178] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:28.191] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:28.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:28.191]   - Field: ‘node’
[13:24:28.192]   - Field: ‘label’
[13:24:28.192]   - Field: ‘local’
[13:24:28.192]   - Field: ‘owner’
[13:24:28.192]   - Field: ‘envir’
[13:24:28.192]   - Field: ‘workers’
[13:24:28.192]   - Field: ‘packages’
[13:24:28.192]   - Field: ‘gc’
[13:24:28.192]   - Field: ‘conditions’
[13:24:28.192]   - Field: ‘persistent’
[13:24:28.192]   - Field: ‘expr’
[13:24:28.193]   - Field: ‘uuid’
[13:24:28.193]   - Field: ‘seed’
[13:24:28.193]   - Field: ‘version’
[13:24:28.193]   - Field: ‘result’
[13:24:28.193]   - Field: ‘asynchronous’
[13:24:28.193]   - Field: ‘calls’
[13:24:28.193]   - Field: ‘globals’
[13:24:28.193]   - Field: ‘stdout’
[13:24:28.193]   - Field: ‘earlySignal’
[13:24:28.193]   - Field: ‘lazy’
[13:24:28.193]   - Field: ‘state’
[13:24:28.194] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:28.194] - Launch lazy future ...
[13:24:28.194] Packages needed by the future expression (n = 0): <none>
[13:24:28.194] Packages needed by future strategies (n = 0): <none>
[13:24:28.194] {
[13:24:28.194]     {
[13:24:28.194]         {
[13:24:28.194]             ...future.startTime <- base::Sys.time()
[13:24:28.194]             {
[13:24:28.194]                 {
[13:24:28.194]                   {
[13:24:28.194]                     {
[13:24:28.194]                       base::local({
[13:24:28.194]                         has_future <- base::requireNamespace("future", 
[13:24:28.194]                           quietly = TRUE)
[13:24:28.194]                         if (has_future) {
[13:24:28.194]                           ns <- base::getNamespace("future")
[13:24:28.194]                           version <- ns[[".package"]][["version"]]
[13:24:28.194]                           if (is.null(version)) 
[13:24:28.194]                             version <- utils::packageVersion("future")
[13:24:28.194]                         }
[13:24:28.194]                         else {
[13:24:28.194]                           version <- NULL
[13:24:28.194]                         }
[13:24:28.194]                         if (!has_future || version < "1.8.0") {
[13:24:28.194]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:28.194]                             "", base::R.version$version.string), 
[13:24:28.194]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:28.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:28.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:28.194]                               "release", "version")], collapse = " "), 
[13:24:28.194]                             hostname = base::Sys.info()[["nodename"]])
[13:24:28.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:28.194]                             info)
[13:24:28.194]                           info <- base::paste(info, collapse = "; ")
[13:24:28.194]                           if (!has_future) {
[13:24:28.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:28.194]                               info)
[13:24:28.194]                           }
[13:24:28.194]                           else {
[13:24:28.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:28.194]                               info, version)
[13:24:28.194]                           }
[13:24:28.194]                           base::stop(msg)
[13:24:28.194]                         }
[13:24:28.194]                       })
[13:24:28.194]                     }
[13:24:28.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:28.194]                     base::options(mc.cores = 1L)
[13:24:28.194]                   }
[13:24:28.194]                   options(future.plan = NULL)
[13:24:28.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:28.194]                 }
[13:24:28.194]                 ...future.workdir <- getwd()
[13:24:28.194]             }
[13:24:28.194]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:28.194]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:28.194]         }
[13:24:28.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:28.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:28.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:28.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:28.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:28.194]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:28.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:28.194]             base::names(...future.oldOptions))
[13:24:28.194]     }
[13:24:28.194]     if (FALSE) {
[13:24:28.194]     }
[13:24:28.194]     else {
[13:24:28.194]         if (TRUE) {
[13:24:28.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:28.194]                 open = "w")
[13:24:28.194]         }
[13:24:28.194]         else {
[13:24:28.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:28.194]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:28.194]         }
[13:24:28.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:28.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:28.194]             base::sink(type = "output", split = FALSE)
[13:24:28.194]             base::close(...future.stdout)
[13:24:28.194]         }, add = TRUE)
[13:24:28.194]     }
[13:24:28.194]     ...future.frame <- base::sys.nframe()
[13:24:28.194]     ...future.conditions <- base::list()
[13:24:28.194]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:28.194]     if (FALSE) {
[13:24:28.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:28.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:28.194]     }
[13:24:28.194]     ...future.result <- base::tryCatch({
[13:24:28.194]         base::withCallingHandlers({
[13:24:28.194]             ...future.value <- base::withVisible(base::local({
[13:24:28.194]                 ...future.makeSendCondition <- base::local({
[13:24:28.194]                   sendCondition <- NULL
[13:24:28.194]                   function(frame = 1L) {
[13:24:28.194]                     if (is.function(sendCondition)) 
[13:24:28.194]                       return(sendCondition)
[13:24:28.194]                     ns <- getNamespace("parallel")
[13:24:28.194]                     if (exists("sendData", mode = "function", 
[13:24:28.194]                       envir = ns)) {
[13:24:28.194]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:28.194]                         envir = ns)
[13:24:28.194]                       envir <- sys.frame(frame)
[13:24:28.194]                       master <- NULL
[13:24:28.194]                       while (!identical(envir, .GlobalEnv) && 
[13:24:28.194]                         !identical(envir, emptyenv())) {
[13:24:28.194]                         if (exists("master", mode = "list", envir = envir, 
[13:24:28.194]                           inherits = FALSE)) {
[13:24:28.194]                           master <- get("master", mode = "list", 
[13:24:28.194]                             envir = envir, inherits = FALSE)
[13:24:28.194]                           if (inherits(master, c("SOCKnode", 
[13:24:28.194]                             "SOCK0node"))) {
[13:24:28.194]                             sendCondition <<- function(cond) {
[13:24:28.194]                               data <- list(type = "VALUE", value = cond, 
[13:24:28.194]                                 success = TRUE)
[13:24:28.194]                               parallel_sendData(master, data)
[13:24:28.194]                             }
[13:24:28.194]                             return(sendCondition)
[13:24:28.194]                           }
[13:24:28.194]                         }
[13:24:28.194]                         frame <- frame + 1L
[13:24:28.194]                         envir <- sys.frame(frame)
[13:24:28.194]                       }
[13:24:28.194]                     }
[13:24:28.194]                     sendCondition <<- function(cond) NULL
[13:24:28.194]                   }
[13:24:28.194]                 })
[13:24:28.194]                 withCallingHandlers({
[13:24:28.194]                   {
[13:24:28.194]                     Sys.sleep(0.5)
[13:24:28.194]                     list(a = 1, b = 42L)
[13:24:28.194]                   }
[13:24:28.194]                 }, immediateCondition = function(cond) {
[13:24:28.194]                   sendCondition <- ...future.makeSendCondition()
[13:24:28.194]                   sendCondition(cond)
[13:24:28.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.194]                   {
[13:24:28.194]                     inherits <- base::inherits
[13:24:28.194]                     invokeRestart <- base::invokeRestart
[13:24:28.194]                     is.null <- base::is.null
[13:24:28.194]                     muffled <- FALSE
[13:24:28.194]                     if (inherits(cond, "message")) {
[13:24:28.194]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:28.194]                       if (muffled) 
[13:24:28.194]                         invokeRestart("muffleMessage")
[13:24:28.194]                     }
[13:24:28.194]                     else if (inherits(cond, "warning")) {
[13:24:28.194]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:28.194]                       if (muffled) 
[13:24:28.194]                         invokeRestart("muffleWarning")
[13:24:28.194]                     }
[13:24:28.194]                     else if (inherits(cond, "condition")) {
[13:24:28.194]                       if (!is.null(pattern)) {
[13:24:28.194]                         computeRestarts <- base::computeRestarts
[13:24:28.194]                         grepl <- base::grepl
[13:24:28.194]                         restarts <- computeRestarts(cond)
[13:24:28.194]                         for (restart in restarts) {
[13:24:28.194]                           name <- restart$name
[13:24:28.194]                           if (is.null(name)) 
[13:24:28.194]                             next
[13:24:28.194]                           if (!grepl(pattern, name)) 
[13:24:28.194]                             next
[13:24:28.194]                           invokeRestart(restart)
[13:24:28.194]                           muffled <- TRUE
[13:24:28.194]                           break
[13:24:28.194]                         }
[13:24:28.194]                       }
[13:24:28.194]                     }
[13:24:28.194]                     invisible(muffled)
[13:24:28.194]                   }
[13:24:28.194]                   muffleCondition(cond)
[13:24:28.194]                 })
[13:24:28.194]             }))
[13:24:28.194]             future::FutureResult(value = ...future.value$value, 
[13:24:28.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.194]                   ...future.rng), globalenv = if (FALSE) 
[13:24:28.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:28.194]                     ...future.globalenv.names))
[13:24:28.194]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:28.194]         }, condition = base::local({
[13:24:28.194]             c <- base::c
[13:24:28.194]             inherits <- base::inherits
[13:24:28.194]             invokeRestart <- base::invokeRestart
[13:24:28.194]             length <- base::length
[13:24:28.194]             list <- base::list
[13:24:28.194]             seq.int <- base::seq.int
[13:24:28.194]             signalCondition <- base::signalCondition
[13:24:28.194]             sys.calls <- base::sys.calls
[13:24:28.194]             `[[` <- base::`[[`
[13:24:28.194]             `+` <- base::`+`
[13:24:28.194]             `<<-` <- base::`<<-`
[13:24:28.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:28.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:28.194]                   3L)]
[13:24:28.194]             }
[13:24:28.194]             function(cond) {
[13:24:28.194]                 is_error <- inherits(cond, "error")
[13:24:28.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:28.194]                   NULL)
[13:24:28.194]                 if (is_error) {
[13:24:28.194]                   sessionInformation <- function() {
[13:24:28.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:28.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:28.194]                       search = base::search(), system = base::Sys.info())
[13:24:28.194]                   }
[13:24:28.194]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:28.194]                     cond$call), session = sessionInformation(), 
[13:24:28.194]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:28.194]                   signalCondition(cond)
[13:24:28.194]                 }
[13:24:28.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:28.194]                 "immediateCondition"))) {
[13:24:28.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:28.194]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:28.194]                   if (TRUE && !signal) {
[13:24:28.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.194]                     {
[13:24:28.194]                       inherits <- base::inherits
[13:24:28.194]                       invokeRestart <- base::invokeRestart
[13:24:28.194]                       is.null <- base::is.null
[13:24:28.194]                       muffled <- FALSE
[13:24:28.194]                       if (inherits(cond, "message")) {
[13:24:28.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.194]                         if (muffled) 
[13:24:28.194]                           invokeRestart("muffleMessage")
[13:24:28.194]                       }
[13:24:28.194]                       else if (inherits(cond, "warning")) {
[13:24:28.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.194]                         if (muffled) 
[13:24:28.194]                           invokeRestart("muffleWarning")
[13:24:28.194]                       }
[13:24:28.194]                       else if (inherits(cond, "condition")) {
[13:24:28.194]                         if (!is.null(pattern)) {
[13:24:28.194]                           computeRestarts <- base::computeRestarts
[13:24:28.194]                           grepl <- base::grepl
[13:24:28.194]                           restarts <- computeRestarts(cond)
[13:24:28.194]                           for (restart in restarts) {
[13:24:28.194]                             name <- restart$name
[13:24:28.194]                             if (is.null(name)) 
[13:24:28.194]                               next
[13:24:28.194]                             if (!grepl(pattern, name)) 
[13:24:28.194]                               next
[13:24:28.194]                             invokeRestart(restart)
[13:24:28.194]                             muffled <- TRUE
[13:24:28.194]                             break
[13:24:28.194]                           }
[13:24:28.194]                         }
[13:24:28.194]                       }
[13:24:28.194]                       invisible(muffled)
[13:24:28.194]                     }
[13:24:28.194]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.194]                   }
[13:24:28.194]                 }
[13:24:28.194]                 else {
[13:24:28.194]                   if (TRUE) {
[13:24:28.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.194]                     {
[13:24:28.194]                       inherits <- base::inherits
[13:24:28.194]                       invokeRestart <- base::invokeRestart
[13:24:28.194]                       is.null <- base::is.null
[13:24:28.194]                       muffled <- FALSE
[13:24:28.194]                       if (inherits(cond, "message")) {
[13:24:28.194]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.194]                         if (muffled) 
[13:24:28.194]                           invokeRestart("muffleMessage")
[13:24:28.194]                       }
[13:24:28.194]                       else if (inherits(cond, "warning")) {
[13:24:28.194]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.194]                         if (muffled) 
[13:24:28.194]                           invokeRestart("muffleWarning")
[13:24:28.194]                       }
[13:24:28.194]                       else if (inherits(cond, "condition")) {
[13:24:28.194]                         if (!is.null(pattern)) {
[13:24:28.194]                           computeRestarts <- base::computeRestarts
[13:24:28.194]                           grepl <- base::grepl
[13:24:28.194]                           restarts <- computeRestarts(cond)
[13:24:28.194]                           for (restart in restarts) {
[13:24:28.194]                             name <- restart$name
[13:24:28.194]                             if (is.null(name)) 
[13:24:28.194]                               next
[13:24:28.194]                             if (!grepl(pattern, name)) 
[13:24:28.194]                               next
[13:24:28.194]                             invokeRestart(restart)
[13:24:28.194]                             muffled <- TRUE
[13:24:28.194]                             break
[13:24:28.194]                           }
[13:24:28.194]                         }
[13:24:28.194]                       }
[13:24:28.194]                       invisible(muffled)
[13:24:28.194]                     }
[13:24:28.194]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.194]                   }
[13:24:28.194]                 }
[13:24:28.194]             }
[13:24:28.194]         }))
[13:24:28.194]     }, error = function(ex) {
[13:24:28.194]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:28.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.194]                 ...future.rng), started = ...future.startTime, 
[13:24:28.194]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:28.194]             version = "1.8"), class = "FutureResult")
[13:24:28.194]     }, finally = {
[13:24:28.194]         if (!identical(...future.workdir, getwd())) 
[13:24:28.194]             setwd(...future.workdir)
[13:24:28.194]         {
[13:24:28.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:28.194]                 ...future.oldOptions$nwarnings <- NULL
[13:24:28.194]             }
[13:24:28.194]             base::options(...future.oldOptions)
[13:24:28.194]             if (.Platform$OS.type == "windows") {
[13:24:28.194]                 old_names <- names(...future.oldEnvVars)
[13:24:28.194]                 envs <- base::Sys.getenv()
[13:24:28.194]                 names <- names(envs)
[13:24:28.194]                 common <- intersect(names, old_names)
[13:24:28.194]                 added <- setdiff(names, old_names)
[13:24:28.194]                 removed <- setdiff(old_names, names)
[13:24:28.194]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:28.194]                   envs[common]]
[13:24:28.194]                 NAMES <- toupper(changed)
[13:24:28.194]                 args <- list()
[13:24:28.194]                 for (kk in seq_along(NAMES)) {
[13:24:28.194]                   name <- changed[[kk]]
[13:24:28.194]                   NAME <- NAMES[[kk]]
[13:24:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.194]                     next
[13:24:28.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.194]                 }
[13:24:28.194]                 NAMES <- toupper(added)
[13:24:28.194]                 for (kk in seq_along(NAMES)) {
[13:24:28.194]                   name <- added[[kk]]
[13:24:28.194]                   NAME <- NAMES[[kk]]
[13:24:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.194]                     next
[13:24:28.194]                   args[[name]] <- ""
[13:24:28.194]                 }
[13:24:28.194]                 NAMES <- toupper(removed)
[13:24:28.194]                 for (kk in seq_along(NAMES)) {
[13:24:28.194]                   name <- removed[[kk]]
[13:24:28.194]                   NAME <- NAMES[[kk]]
[13:24:28.194]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.194]                     next
[13:24:28.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.194]                 }
[13:24:28.194]                 if (length(args) > 0) 
[13:24:28.194]                   base::do.call(base::Sys.setenv, args = args)
[13:24:28.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:28.194]             }
[13:24:28.194]             else {
[13:24:28.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:28.194]             }
[13:24:28.194]             {
[13:24:28.194]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:28.194]                   0L) {
[13:24:28.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:28.194]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:28.194]                   base::options(opts)
[13:24:28.194]                 }
[13:24:28.194]                 {
[13:24:28.194]                   {
[13:24:28.194]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:28.194]                     NULL
[13:24:28.194]                   }
[13:24:28.194]                   options(future.plan = NULL)
[13:24:28.194]                   if (is.na(NA_character_)) 
[13:24:28.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:28.194]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:28.194]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:28.194]                     envir = parent.frame()) 
[13:24:28.194]                   {
[13:24:28.194]                     if (is.function(workers)) 
[13:24:28.194]                       workers <- workers()
[13:24:28.194]                     workers <- structure(as.integer(workers), 
[13:24:28.194]                       class = class(workers))
[13:24:28.194]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:28.194]                       workers >= 1)
[13:24:28.194]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:28.194]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:28.194]                     }
[13:24:28.194]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:28.194]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:28.194]                       envir = envir)
[13:24:28.194]                     if (!future$lazy) 
[13:24:28.194]                       future <- run(future)
[13:24:28.194]                     invisible(future)
[13:24:28.194]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:28.194]                 }
[13:24:28.194]             }
[13:24:28.194]         }
[13:24:28.194]     })
[13:24:28.194]     if (TRUE) {
[13:24:28.194]         base::sink(type = "output", split = FALSE)
[13:24:28.194]         if (TRUE) {
[13:24:28.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:28.194]         }
[13:24:28.194]         else {
[13:24:28.194]             ...future.result["stdout"] <- base::list(NULL)
[13:24:28.194]         }
[13:24:28.194]         base::close(...future.stdout)
[13:24:28.194]         ...future.stdout <- NULL
[13:24:28.194]     }
[13:24:28.194]     ...future.result$conditions <- ...future.conditions
[13:24:28.194]     ...future.result$finished <- base::Sys.time()
[13:24:28.194]     ...future.result
[13:24:28.194] }
[13:24:28.198] MultisessionFuture started
[13:24:28.198] - Launch lazy future ... done
[13:24:28.198] run() for ‘MultisessionFuture’ ... done
[13:24:28.198] getGlobalsAndPackages() ...
[13:24:28.198] Searching for globals...
[13:24:28.199] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:28.199] Searching for globals ... DONE
[13:24:28.199] Resolving globals: FALSE
[13:24:28.200] 
[13:24:28.200] 
[13:24:28.200] getGlobalsAndPackages() ... DONE
- w/ exception ...
[13:24:28.200] getGlobalsAndPackages() ...
[13:24:28.200] Searching for globals...
[13:24:28.201] - globals found: [2] ‘list’, ‘stop’
[13:24:28.201] Searching for globals ... DONE
[13:24:28.201] Resolving globals: FALSE
[13:24:28.201] 
[13:24:28.201] 
[13:24:28.201] getGlobalsAndPackages() ... DONE
[13:24:28.202] run() for ‘Future’ ...
[13:24:28.202] - state: ‘created’
[13:24:28.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:28.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:28.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:28.218]   - Field: ‘node’
[13:24:28.218]   - Field: ‘label’
[13:24:28.218]   - Field: ‘local’
[13:24:28.218]   - Field: ‘owner’
[13:24:28.218]   - Field: ‘envir’
[13:24:28.218]   - Field: ‘workers’
[13:24:28.218]   - Field: ‘packages’
[13:24:28.218]   - Field: ‘gc’
[13:24:28.218]   - Field: ‘conditions’
[13:24:28.218]   - Field: ‘persistent’
[13:24:28.219]   - Field: ‘expr’
[13:24:28.219]   - Field: ‘uuid’
[13:24:28.219]   - Field: ‘seed’
[13:24:28.219]   - Field: ‘version’
[13:24:28.219]   - Field: ‘result’
[13:24:28.219]   - Field: ‘asynchronous’
[13:24:28.219]   - Field: ‘calls’
[13:24:28.219]   - Field: ‘globals’
[13:24:28.219]   - Field: ‘stdout’
[13:24:28.219]   - Field: ‘earlySignal’
[13:24:28.219]   - Field: ‘lazy’
[13:24:28.220]   - Field: ‘state’
[13:24:28.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:28.220] - Launch lazy future ...
[13:24:28.220] Packages needed by the future expression (n = 0): <none>
[13:24:28.220] Packages needed by future strategies (n = 0): <none>
[13:24:28.221] {
[13:24:28.221]     {
[13:24:28.221]         {
[13:24:28.221]             ...future.startTime <- base::Sys.time()
[13:24:28.221]             {
[13:24:28.221]                 {
[13:24:28.221]                   {
[13:24:28.221]                     {
[13:24:28.221]                       base::local({
[13:24:28.221]                         has_future <- base::requireNamespace("future", 
[13:24:28.221]                           quietly = TRUE)
[13:24:28.221]                         if (has_future) {
[13:24:28.221]                           ns <- base::getNamespace("future")
[13:24:28.221]                           version <- ns[[".package"]][["version"]]
[13:24:28.221]                           if (is.null(version)) 
[13:24:28.221]                             version <- utils::packageVersion("future")
[13:24:28.221]                         }
[13:24:28.221]                         else {
[13:24:28.221]                           version <- NULL
[13:24:28.221]                         }
[13:24:28.221]                         if (!has_future || version < "1.8.0") {
[13:24:28.221]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:28.221]                             "", base::R.version$version.string), 
[13:24:28.221]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:28.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:28.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:28.221]                               "release", "version")], collapse = " "), 
[13:24:28.221]                             hostname = base::Sys.info()[["nodename"]])
[13:24:28.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:28.221]                             info)
[13:24:28.221]                           info <- base::paste(info, collapse = "; ")
[13:24:28.221]                           if (!has_future) {
[13:24:28.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:28.221]                               info)
[13:24:28.221]                           }
[13:24:28.221]                           else {
[13:24:28.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:28.221]                               info, version)
[13:24:28.221]                           }
[13:24:28.221]                           base::stop(msg)
[13:24:28.221]                         }
[13:24:28.221]                       })
[13:24:28.221]                     }
[13:24:28.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:28.221]                     base::options(mc.cores = 1L)
[13:24:28.221]                   }
[13:24:28.221]                   options(future.plan = NULL)
[13:24:28.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:28.221]                 }
[13:24:28.221]                 ...future.workdir <- getwd()
[13:24:28.221]             }
[13:24:28.221]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:28.221]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:28.221]         }
[13:24:28.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:28.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:28.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:28.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:28.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:28.221]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:28.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:28.221]             base::names(...future.oldOptions))
[13:24:28.221]     }
[13:24:28.221]     if (FALSE) {
[13:24:28.221]     }
[13:24:28.221]     else {
[13:24:28.221]         if (TRUE) {
[13:24:28.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:28.221]                 open = "w")
[13:24:28.221]         }
[13:24:28.221]         else {
[13:24:28.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:28.221]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:28.221]         }
[13:24:28.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:28.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:28.221]             base::sink(type = "output", split = FALSE)
[13:24:28.221]             base::close(...future.stdout)
[13:24:28.221]         }, add = TRUE)
[13:24:28.221]     }
[13:24:28.221]     ...future.frame <- base::sys.nframe()
[13:24:28.221]     ...future.conditions <- base::list()
[13:24:28.221]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:28.221]     if (FALSE) {
[13:24:28.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:28.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:28.221]     }
[13:24:28.221]     ...future.result <- base::tryCatch({
[13:24:28.221]         base::withCallingHandlers({
[13:24:28.221]             ...future.value <- base::withVisible(base::local({
[13:24:28.221]                 ...future.makeSendCondition <- base::local({
[13:24:28.221]                   sendCondition <- NULL
[13:24:28.221]                   function(frame = 1L) {
[13:24:28.221]                     if (is.function(sendCondition)) 
[13:24:28.221]                       return(sendCondition)
[13:24:28.221]                     ns <- getNamespace("parallel")
[13:24:28.221]                     if (exists("sendData", mode = "function", 
[13:24:28.221]                       envir = ns)) {
[13:24:28.221]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:28.221]                         envir = ns)
[13:24:28.221]                       envir <- sys.frame(frame)
[13:24:28.221]                       master <- NULL
[13:24:28.221]                       while (!identical(envir, .GlobalEnv) && 
[13:24:28.221]                         !identical(envir, emptyenv())) {
[13:24:28.221]                         if (exists("master", mode = "list", envir = envir, 
[13:24:28.221]                           inherits = FALSE)) {
[13:24:28.221]                           master <- get("master", mode = "list", 
[13:24:28.221]                             envir = envir, inherits = FALSE)
[13:24:28.221]                           if (inherits(master, c("SOCKnode", 
[13:24:28.221]                             "SOCK0node"))) {
[13:24:28.221]                             sendCondition <<- function(cond) {
[13:24:28.221]                               data <- list(type = "VALUE", value = cond, 
[13:24:28.221]                                 success = TRUE)
[13:24:28.221]                               parallel_sendData(master, data)
[13:24:28.221]                             }
[13:24:28.221]                             return(sendCondition)
[13:24:28.221]                           }
[13:24:28.221]                         }
[13:24:28.221]                         frame <- frame + 1L
[13:24:28.221]                         envir <- sys.frame(frame)
[13:24:28.221]                       }
[13:24:28.221]                     }
[13:24:28.221]                     sendCondition <<- function(cond) NULL
[13:24:28.221]                   }
[13:24:28.221]                 })
[13:24:28.221]                 withCallingHandlers({
[13:24:28.221]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:28.221]                 }, immediateCondition = function(cond) {
[13:24:28.221]                   sendCondition <- ...future.makeSendCondition()
[13:24:28.221]                   sendCondition(cond)
[13:24:28.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.221]                   {
[13:24:28.221]                     inherits <- base::inherits
[13:24:28.221]                     invokeRestart <- base::invokeRestart
[13:24:28.221]                     is.null <- base::is.null
[13:24:28.221]                     muffled <- FALSE
[13:24:28.221]                     if (inherits(cond, "message")) {
[13:24:28.221]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:28.221]                       if (muffled) 
[13:24:28.221]                         invokeRestart("muffleMessage")
[13:24:28.221]                     }
[13:24:28.221]                     else if (inherits(cond, "warning")) {
[13:24:28.221]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:28.221]                       if (muffled) 
[13:24:28.221]                         invokeRestart("muffleWarning")
[13:24:28.221]                     }
[13:24:28.221]                     else if (inherits(cond, "condition")) {
[13:24:28.221]                       if (!is.null(pattern)) {
[13:24:28.221]                         computeRestarts <- base::computeRestarts
[13:24:28.221]                         grepl <- base::grepl
[13:24:28.221]                         restarts <- computeRestarts(cond)
[13:24:28.221]                         for (restart in restarts) {
[13:24:28.221]                           name <- restart$name
[13:24:28.221]                           if (is.null(name)) 
[13:24:28.221]                             next
[13:24:28.221]                           if (!grepl(pattern, name)) 
[13:24:28.221]                             next
[13:24:28.221]                           invokeRestart(restart)
[13:24:28.221]                           muffled <- TRUE
[13:24:28.221]                           break
[13:24:28.221]                         }
[13:24:28.221]                       }
[13:24:28.221]                     }
[13:24:28.221]                     invisible(muffled)
[13:24:28.221]                   }
[13:24:28.221]                   muffleCondition(cond)
[13:24:28.221]                 })
[13:24:28.221]             }))
[13:24:28.221]             future::FutureResult(value = ...future.value$value, 
[13:24:28.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.221]                   ...future.rng), globalenv = if (FALSE) 
[13:24:28.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:28.221]                     ...future.globalenv.names))
[13:24:28.221]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:28.221]         }, condition = base::local({
[13:24:28.221]             c <- base::c
[13:24:28.221]             inherits <- base::inherits
[13:24:28.221]             invokeRestart <- base::invokeRestart
[13:24:28.221]             length <- base::length
[13:24:28.221]             list <- base::list
[13:24:28.221]             seq.int <- base::seq.int
[13:24:28.221]             signalCondition <- base::signalCondition
[13:24:28.221]             sys.calls <- base::sys.calls
[13:24:28.221]             `[[` <- base::`[[`
[13:24:28.221]             `+` <- base::`+`
[13:24:28.221]             `<<-` <- base::`<<-`
[13:24:28.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:28.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:28.221]                   3L)]
[13:24:28.221]             }
[13:24:28.221]             function(cond) {
[13:24:28.221]                 is_error <- inherits(cond, "error")
[13:24:28.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:28.221]                   NULL)
[13:24:28.221]                 if (is_error) {
[13:24:28.221]                   sessionInformation <- function() {
[13:24:28.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:28.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:28.221]                       search = base::search(), system = base::Sys.info())
[13:24:28.221]                   }
[13:24:28.221]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:28.221]                     cond$call), session = sessionInformation(), 
[13:24:28.221]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:28.221]                   signalCondition(cond)
[13:24:28.221]                 }
[13:24:28.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:28.221]                 "immediateCondition"))) {
[13:24:28.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:28.221]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:28.221]                   if (TRUE && !signal) {
[13:24:28.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.221]                     {
[13:24:28.221]                       inherits <- base::inherits
[13:24:28.221]                       invokeRestart <- base::invokeRestart
[13:24:28.221]                       is.null <- base::is.null
[13:24:28.221]                       muffled <- FALSE
[13:24:28.221]                       if (inherits(cond, "message")) {
[13:24:28.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.221]                         if (muffled) 
[13:24:28.221]                           invokeRestart("muffleMessage")
[13:24:28.221]                       }
[13:24:28.221]                       else if (inherits(cond, "warning")) {
[13:24:28.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.221]                         if (muffled) 
[13:24:28.221]                           invokeRestart("muffleWarning")
[13:24:28.221]                       }
[13:24:28.221]                       else if (inherits(cond, "condition")) {
[13:24:28.221]                         if (!is.null(pattern)) {
[13:24:28.221]                           computeRestarts <- base::computeRestarts
[13:24:28.221]                           grepl <- base::grepl
[13:24:28.221]                           restarts <- computeRestarts(cond)
[13:24:28.221]                           for (restart in restarts) {
[13:24:28.221]                             name <- restart$name
[13:24:28.221]                             if (is.null(name)) 
[13:24:28.221]                               next
[13:24:28.221]                             if (!grepl(pattern, name)) 
[13:24:28.221]                               next
[13:24:28.221]                             invokeRestart(restart)
[13:24:28.221]                             muffled <- TRUE
[13:24:28.221]                             break
[13:24:28.221]                           }
[13:24:28.221]                         }
[13:24:28.221]                       }
[13:24:28.221]                       invisible(muffled)
[13:24:28.221]                     }
[13:24:28.221]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.221]                   }
[13:24:28.221]                 }
[13:24:28.221]                 else {
[13:24:28.221]                   if (TRUE) {
[13:24:28.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.221]                     {
[13:24:28.221]                       inherits <- base::inherits
[13:24:28.221]                       invokeRestart <- base::invokeRestart
[13:24:28.221]                       is.null <- base::is.null
[13:24:28.221]                       muffled <- FALSE
[13:24:28.221]                       if (inherits(cond, "message")) {
[13:24:28.221]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.221]                         if (muffled) 
[13:24:28.221]                           invokeRestart("muffleMessage")
[13:24:28.221]                       }
[13:24:28.221]                       else if (inherits(cond, "warning")) {
[13:24:28.221]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.221]                         if (muffled) 
[13:24:28.221]                           invokeRestart("muffleWarning")
[13:24:28.221]                       }
[13:24:28.221]                       else if (inherits(cond, "condition")) {
[13:24:28.221]                         if (!is.null(pattern)) {
[13:24:28.221]                           computeRestarts <- base::computeRestarts
[13:24:28.221]                           grepl <- base::grepl
[13:24:28.221]                           restarts <- computeRestarts(cond)
[13:24:28.221]                           for (restart in restarts) {
[13:24:28.221]                             name <- restart$name
[13:24:28.221]                             if (is.null(name)) 
[13:24:28.221]                               next
[13:24:28.221]                             if (!grepl(pattern, name)) 
[13:24:28.221]                               next
[13:24:28.221]                             invokeRestart(restart)
[13:24:28.221]                             muffled <- TRUE
[13:24:28.221]                             break
[13:24:28.221]                           }
[13:24:28.221]                         }
[13:24:28.221]                       }
[13:24:28.221]                       invisible(muffled)
[13:24:28.221]                     }
[13:24:28.221]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.221]                   }
[13:24:28.221]                 }
[13:24:28.221]             }
[13:24:28.221]         }))
[13:24:28.221]     }, error = function(ex) {
[13:24:28.221]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:28.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.221]                 ...future.rng), started = ...future.startTime, 
[13:24:28.221]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:28.221]             version = "1.8"), class = "FutureResult")
[13:24:28.221]     }, finally = {
[13:24:28.221]         if (!identical(...future.workdir, getwd())) 
[13:24:28.221]             setwd(...future.workdir)
[13:24:28.221]         {
[13:24:28.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:28.221]                 ...future.oldOptions$nwarnings <- NULL
[13:24:28.221]             }
[13:24:28.221]             base::options(...future.oldOptions)
[13:24:28.221]             if (.Platform$OS.type == "windows") {
[13:24:28.221]                 old_names <- names(...future.oldEnvVars)
[13:24:28.221]                 envs <- base::Sys.getenv()
[13:24:28.221]                 names <- names(envs)
[13:24:28.221]                 common <- intersect(names, old_names)
[13:24:28.221]                 added <- setdiff(names, old_names)
[13:24:28.221]                 removed <- setdiff(old_names, names)
[13:24:28.221]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:28.221]                   envs[common]]
[13:24:28.221]                 NAMES <- toupper(changed)
[13:24:28.221]                 args <- list()
[13:24:28.221]                 for (kk in seq_along(NAMES)) {
[13:24:28.221]                   name <- changed[[kk]]
[13:24:28.221]                   NAME <- NAMES[[kk]]
[13:24:28.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.221]                     next
[13:24:28.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.221]                 }
[13:24:28.221]                 NAMES <- toupper(added)
[13:24:28.221]                 for (kk in seq_along(NAMES)) {
[13:24:28.221]                   name <- added[[kk]]
[13:24:28.221]                   NAME <- NAMES[[kk]]
[13:24:28.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.221]                     next
[13:24:28.221]                   args[[name]] <- ""
[13:24:28.221]                 }
[13:24:28.221]                 NAMES <- toupper(removed)
[13:24:28.221]                 for (kk in seq_along(NAMES)) {
[13:24:28.221]                   name <- removed[[kk]]
[13:24:28.221]                   NAME <- NAMES[[kk]]
[13:24:28.221]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.221]                     next
[13:24:28.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.221]                 }
[13:24:28.221]                 if (length(args) > 0) 
[13:24:28.221]                   base::do.call(base::Sys.setenv, args = args)
[13:24:28.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:28.221]             }
[13:24:28.221]             else {
[13:24:28.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:28.221]             }
[13:24:28.221]             {
[13:24:28.221]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:28.221]                   0L) {
[13:24:28.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:28.221]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:28.221]                   base::options(opts)
[13:24:28.221]                 }
[13:24:28.221]                 {
[13:24:28.221]                   {
[13:24:28.221]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:28.221]                     NULL
[13:24:28.221]                   }
[13:24:28.221]                   options(future.plan = NULL)
[13:24:28.221]                   if (is.na(NA_character_)) 
[13:24:28.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:28.221]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:28.221]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:28.221]                     envir = parent.frame()) 
[13:24:28.221]                   {
[13:24:28.221]                     if (is.function(workers)) 
[13:24:28.221]                       workers <- workers()
[13:24:28.221]                     workers <- structure(as.integer(workers), 
[13:24:28.221]                       class = class(workers))
[13:24:28.221]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:28.221]                       workers >= 1)
[13:24:28.221]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:28.221]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:28.221]                     }
[13:24:28.221]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:28.221]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:28.221]                       envir = envir)
[13:24:28.221]                     if (!future$lazy) 
[13:24:28.221]                       future <- run(future)
[13:24:28.221]                     invisible(future)
[13:24:28.221]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:28.221]                 }
[13:24:28.221]             }
[13:24:28.221]         }
[13:24:28.221]     })
[13:24:28.221]     if (TRUE) {
[13:24:28.221]         base::sink(type = "output", split = FALSE)
[13:24:28.221]         if (TRUE) {
[13:24:28.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:28.221]         }
[13:24:28.221]         else {
[13:24:28.221]             ...future.result["stdout"] <- base::list(NULL)
[13:24:28.221]         }
[13:24:28.221]         base::close(...future.stdout)
[13:24:28.221]         ...future.stdout <- NULL
[13:24:28.221]     }
[13:24:28.221]     ...future.result$conditions <- ...future.conditions
[13:24:28.221]     ...future.result$finished <- base::Sys.time()
[13:24:28.221]     ...future.result
[13:24:28.221] }
[13:24:28.274] MultisessionFuture started
[13:24:28.274] - Launch lazy future ... done
[13:24:28.274] run() for ‘MultisessionFuture’ ... done
[13:24:28.274] getGlobalsAndPackages() ...
[13:24:28.274] Searching for globals...
[13:24:28.275] - globals found: [2] ‘list’, ‘stop’
[13:24:28.276] Searching for globals ... DONE
[13:24:28.276] Resolving globals: FALSE
[13:24:28.276] 
[13:24:28.276] 
[13:24:28.277] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[13:24:28.277] getGlobalsAndPackages() ...
[13:24:28.277] Searching for globals...
[13:24:28.279] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:28.279] Searching for globals ... DONE
[13:24:28.280] Resolving globals: FALSE
[13:24:28.280] 
[13:24:28.280] 
[13:24:28.280] getGlobalsAndPackages() ... DONE
[13:24:28.281] run() for ‘Future’ ...
[13:24:28.281] - state: ‘created’
[13:24:28.281] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:28.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:28.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:28.297]   - Field: ‘node’
[13:24:28.297]   - Field: ‘label’
[13:24:28.297]   - Field: ‘local’
[13:24:28.297]   - Field: ‘owner’
[13:24:28.297]   - Field: ‘envir’
[13:24:28.297]   - Field: ‘workers’
[13:24:28.297]   - Field: ‘packages’
[13:24:28.297]   - Field: ‘gc’
[13:24:28.298]   - Field: ‘conditions’
[13:24:28.298]   - Field: ‘persistent’
[13:24:28.298]   - Field: ‘expr’
[13:24:28.298]   - Field: ‘uuid’
[13:24:28.298]   - Field: ‘seed’
[13:24:28.298]   - Field: ‘version’
[13:24:28.298]   - Field: ‘result’
[13:24:28.298]   - Field: ‘asynchronous’
[13:24:28.298]   - Field: ‘calls’
[13:24:28.298]   - Field: ‘globals’
[13:24:28.298]   - Field: ‘stdout’
[13:24:28.299]   - Field: ‘earlySignal’
[13:24:28.299]   - Field: ‘lazy’
[13:24:28.299]   - Field: ‘state’
[13:24:28.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:28.299] - Launch lazy future ...
[13:24:28.299] Packages needed by the future expression (n = 0): <none>
[13:24:28.299] Packages needed by future strategies (n = 0): <none>
[13:24:28.300] {
[13:24:28.300]     {
[13:24:28.300]         {
[13:24:28.300]             ...future.startTime <- base::Sys.time()
[13:24:28.300]             {
[13:24:28.300]                 {
[13:24:28.300]                   {
[13:24:28.300]                     {
[13:24:28.300]                       base::local({
[13:24:28.300]                         has_future <- base::requireNamespace("future", 
[13:24:28.300]                           quietly = TRUE)
[13:24:28.300]                         if (has_future) {
[13:24:28.300]                           ns <- base::getNamespace("future")
[13:24:28.300]                           version <- ns[[".package"]][["version"]]
[13:24:28.300]                           if (is.null(version)) 
[13:24:28.300]                             version <- utils::packageVersion("future")
[13:24:28.300]                         }
[13:24:28.300]                         else {
[13:24:28.300]                           version <- NULL
[13:24:28.300]                         }
[13:24:28.300]                         if (!has_future || version < "1.8.0") {
[13:24:28.300]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:28.300]                             "", base::R.version$version.string), 
[13:24:28.300]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:28.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:28.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:28.300]                               "release", "version")], collapse = " "), 
[13:24:28.300]                             hostname = base::Sys.info()[["nodename"]])
[13:24:28.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:28.300]                             info)
[13:24:28.300]                           info <- base::paste(info, collapse = "; ")
[13:24:28.300]                           if (!has_future) {
[13:24:28.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:28.300]                               info)
[13:24:28.300]                           }
[13:24:28.300]                           else {
[13:24:28.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:28.300]                               info, version)
[13:24:28.300]                           }
[13:24:28.300]                           base::stop(msg)
[13:24:28.300]                         }
[13:24:28.300]                       })
[13:24:28.300]                     }
[13:24:28.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:28.300]                     base::options(mc.cores = 1L)
[13:24:28.300]                   }
[13:24:28.300]                   options(future.plan = NULL)
[13:24:28.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:28.300]                 }
[13:24:28.300]                 ...future.workdir <- getwd()
[13:24:28.300]             }
[13:24:28.300]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:28.300]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:28.300]         }
[13:24:28.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:28.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:28.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:28.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:28.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:28.300]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:28.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:28.300]             base::names(...future.oldOptions))
[13:24:28.300]     }
[13:24:28.300]     if (FALSE) {
[13:24:28.300]     }
[13:24:28.300]     else {
[13:24:28.300]         if (TRUE) {
[13:24:28.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:28.300]                 open = "w")
[13:24:28.300]         }
[13:24:28.300]         else {
[13:24:28.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:28.300]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:28.300]         }
[13:24:28.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:28.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:28.300]             base::sink(type = "output", split = FALSE)
[13:24:28.300]             base::close(...future.stdout)
[13:24:28.300]         }, add = TRUE)
[13:24:28.300]     }
[13:24:28.300]     ...future.frame <- base::sys.nframe()
[13:24:28.300]     ...future.conditions <- base::list()
[13:24:28.300]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:28.300]     if (FALSE) {
[13:24:28.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:28.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:28.300]     }
[13:24:28.300]     ...future.result <- base::tryCatch({
[13:24:28.300]         base::withCallingHandlers({
[13:24:28.300]             ...future.value <- base::withVisible(base::local({
[13:24:28.300]                 ...future.makeSendCondition <- base::local({
[13:24:28.300]                   sendCondition <- NULL
[13:24:28.300]                   function(frame = 1L) {
[13:24:28.300]                     if (is.function(sendCondition)) 
[13:24:28.300]                       return(sendCondition)
[13:24:28.300]                     ns <- getNamespace("parallel")
[13:24:28.300]                     if (exists("sendData", mode = "function", 
[13:24:28.300]                       envir = ns)) {
[13:24:28.300]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:28.300]                         envir = ns)
[13:24:28.300]                       envir <- sys.frame(frame)
[13:24:28.300]                       master <- NULL
[13:24:28.300]                       while (!identical(envir, .GlobalEnv) && 
[13:24:28.300]                         !identical(envir, emptyenv())) {
[13:24:28.300]                         if (exists("master", mode = "list", envir = envir, 
[13:24:28.300]                           inherits = FALSE)) {
[13:24:28.300]                           master <- get("master", mode = "list", 
[13:24:28.300]                             envir = envir, inherits = FALSE)
[13:24:28.300]                           if (inherits(master, c("SOCKnode", 
[13:24:28.300]                             "SOCK0node"))) {
[13:24:28.300]                             sendCondition <<- function(cond) {
[13:24:28.300]                               data <- list(type = "VALUE", value = cond, 
[13:24:28.300]                                 success = TRUE)
[13:24:28.300]                               parallel_sendData(master, data)
[13:24:28.300]                             }
[13:24:28.300]                             return(sendCondition)
[13:24:28.300]                           }
[13:24:28.300]                         }
[13:24:28.300]                         frame <- frame + 1L
[13:24:28.300]                         envir <- sys.frame(frame)
[13:24:28.300]                       }
[13:24:28.300]                     }
[13:24:28.300]                     sendCondition <<- function(cond) NULL
[13:24:28.300]                   }
[13:24:28.300]                 })
[13:24:28.300]                 withCallingHandlers({
[13:24:28.300]                   {
[13:24:28.300]                     Sys.sleep(0.5)
[13:24:28.300]                     list(a = 1, b = 42L)
[13:24:28.300]                   }
[13:24:28.300]                 }, immediateCondition = function(cond) {
[13:24:28.300]                   sendCondition <- ...future.makeSendCondition()
[13:24:28.300]                   sendCondition(cond)
[13:24:28.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.300]                   {
[13:24:28.300]                     inherits <- base::inherits
[13:24:28.300]                     invokeRestart <- base::invokeRestart
[13:24:28.300]                     is.null <- base::is.null
[13:24:28.300]                     muffled <- FALSE
[13:24:28.300]                     if (inherits(cond, "message")) {
[13:24:28.300]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:28.300]                       if (muffled) 
[13:24:28.300]                         invokeRestart("muffleMessage")
[13:24:28.300]                     }
[13:24:28.300]                     else if (inherits(cond, "warning")) {
[13:24:28.300]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:28.300]                       if (muffled) 
[13:24:28.300]                         invokeRestart("muffleWarning")
[13:24:28.300]                     }
[13:24:28.300]                     else if (inherits(cond, "condition")) {
[13:24:28.300]                       if (!is.null(pattern)) {
[13:24:28.300]                         computeRestarts <- base::computeRestarts
[13:24:28.300]                         grepl <- base::grepl
[13:24:28.300]                         restarts <- computeRestarts(cond)
[13:24:28.300]                         for (restart in restarts) {
[13:24:28.300]                           name <- restart$name
[13:24:28.300]                           if (is.null(name)) 
[13:24:28.300]                             next
[13:24:28.300]                           if (!grepl(pattern, name)) 
[13:24:28.300]                             next
[13:24:28.300]                           invokeRestart(restart)
[13:24:28.300]                           muffled <- TRUE
[13:24:28.300]                           break
[13:24:28.300]                         }
[13:24:28.300]                       }
[13:24:28.300]                     }
[13:24:28.300]                     invisible(muffled)
[13:24:28.300]                   }
[13:24:28.300]                   muffleCondition(cond)
[13:24:28.300]                 })
[13:24:28.300]             }))
[13:24:28.300]             future::FutureResult(value = ...future.value$value, 
[13:24:28.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.300]                   ...future.rng), globalenv = if (FALSE) 
[13:24:28.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:28.300]                     ...future.globalenv.names))
[13:24:28.300]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:28.300]         }, condition = base::local({
[13:24:28.300]             c <- base::c
[13:24:28.300]             inherits <- base::inherits
[13:24:28.300]             invokeRestart <- base::invokeRestart
[13:24:28.300]             length <- base::length
[13:24:28.300]             list <- base::list
[13:24:28.300]             seq.int <- base::seq.int
[13:24:28.300]             signalCondition <- base::signalCondition
[13:24:28.300]             sys.calls <- base::sys.calls
[13:24:28.300]             `[[` <- base::`[[`
[13:24:28.300]             `+` <- base::`+`
[13:24:28.300]             `<<-` <- base::`<<-`
[13:24:28.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:28.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:28.300]                   3L)]
[13:24:28.300]             }
[13:24:28.300]             function(cond) {
[13:24:28.300]                 is_error <- inherits(cond, "error")
[13:24:28.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:28.300]                   NULL)
[13:24:28.300]                 if (is_error) {
[13:24:28.300]                   sessionInformation <- function() {
[13:24:28.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:28.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:28.300]                       search = base::search(), system = base::Sys.info())
[13:24:28.300]                   }
[13:24:28.300]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:28.300]                     cond$call), session = sessionInformation(), 
[13:24:28.300]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:28.300]                   signalCondition(cond)
[13:24:28.300]                 }
[13:24:28.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:28.300]                 "immediateCondition"))) {
[13:24:28.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:28.300]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:28.300]                   if (TRUE && !signal) {
[13:24:28.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.300]                     {
[13:24:28.300]                       inherits <- base::inherits
[13:24:28.300]                       invokeRestart <- base::invokeRestart
[13:24:28.300]                       is.null <- base::is.null
[13:24:28.300]                       muffled <- FALSE
[13:24:28.300]                       if (inherits(cond, "message")) {
[13:24:28.300]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.300]                         if (muffled) 
[13:24:28.300]                           invokeRestart("muffleMessage")
[13:24:28.300]                       }
[13:24:28.300]                       else if (inherits(cond, "warning")) {
[13:24:28.300]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.300]                         if (muffled) 
[13:24:28.300]                           invokeRestart("muffleWarning")
[13:24:28.300]                       }
[13:24:28.300]                       else if (inherits(cond, "condition")) {
[13:24:28.300]                         if (!is.null(pattern)) {
[13:24:28.300]                           computeRestarts <- base::computeRestarts
[13:24:28.300]                           grepl <- base::grepl
[13:24:28.300]                           restarts <- computeRestarts(cond)
[13:24:28.300]                           for (restart in restarts) {
[13:24:28.300]                             name <- restart$name
[13:24:28.300]                             if (is.null(name)) 
[13:24:28.300]                               next
[13:24:28.300]                             if (!grepl(pattern, name)) 
[13:24:28.300]                               next
[13:24:28.300]                             invokeRestart(restart)
[13:24:28.300]                             muffled <- TRUE
[13:24:28.300]                             break
[13:24:28.300]                           }
[13:24:28.300]                         }
[13:24:28.300]                       }
[13:24:28.300]                       invisible(muffled)
[13:24:28.300]                     }
[13:24:28.300]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.300]                   }
[13:24:28.300]                 }
[13:24:28.300]                 else {
[13:24:28.300]                   if (TRUE) {
[13:24:28.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.300]                     {
[13:24:28.300]                       inherits <- base::inherits
[13:24:28.300]                       invokeRestart <- base::invokeRestart
[13:24:28.300]                       is.null <- base::is.null
[13:24:28.300]                       muffled <- FALSE
[13:24:28.300]                       if (inherits(cond, "message")) {
[13:24:28.300]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.300]                         if (muffled) 
[13:24:28.300]                           invokeRestart("muffleMessage")
[13:24:28.300]                       }
[13:24:28.300]                       else if (inherits(cond, "warning")) {
[13:24:28.300]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.300]                         if (muffled) 
[13:24:28.300]                           invokeRestart("muffleWarning")
[13:24:28.300]                       }
[13:24:28.300]                       else if (inherits(cond, "condition")) {
[13:24:28.300]                         if (!is.null(pattern)) {
[13:24:28.300]                           computeRestarts <- base::computeRestarts
[13:24:28.300]                           grepl <- base::grepl
[13:24:28.300]                           restarts <- computeRestarts(cond)
[13:24:28.300]                           for (restart in restarts) {
[13:24:28.300]                             name <- restart$name
[13:24:28.300]                             if (is.null(name)) 
[13:24:28.300]                               next
[13:24:28.300]                             if (!grepl(pattern, name)) 
[13:24:28.300]                               next
[13:24:28.300]                             invokeRestart(restart)
[13:24:28.300]                             muffled <- TRUE
[13:24:28.300]                             break
[13:24:28.300]                           }
[13:24:28.300]                         }
[13:24:28.300]                       }
[13:24:28.300]                       invisible(muffled)
[13:24:28.300]                     }
[13:24:28.300]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.300]                   }
[13:24:28.300]                 }
[13:24:28.300]             }
[13:24:28.300]         }))
[13:24:28.300]     }, error = function(ex) {
[13:24:28.300]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:28.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.300]                 ...future.rng), started = ...future.startTime, 
[13:24:28.300]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:28.300]             version = "1.8"), class = "FutureResult")
[13:24:28.300]     }, finally = {
[13:24:28.300]         if (!identical(...future.workdir, getwd())) 
[13:24:28.300]             setwd(...future.workdir)
[13:24:28.300]         {
[13:24:28.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:28.300]                 ...future.oldOptions$nwarnings <- NULL
[13:24:28.300]             }
[13:24:28.300]             base::options(...future.oldOptions)
[13:24:28.300]             if (.Platform$OS.type == "windows") {
[13:24:28.300]                 old_names <- names(...future.oldEnvVars)
[13:24:28.300]                 envs <- base::Sys.getenv()
[13:24:28.300]                 names <- names(envs)
[13:24:28.300]                 common <- intersect(names, old_names)
[13:24:28.300]                 added <- setdiff(names, old_names)
[13:24:28.300]                 removed <- setdiff(old_names, names)
[13:24:28.300]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:28.300]                   envs[common]]
[13:24:28.300]                 NAMES <- toupper(changed)
[13:24:28.300]                 args <- list()
[13:24:28.300]                 for (kk in seq_along(NAMES)) {
[13:24:28.300]                   name <- changed[[kk]]
[13:24:28.300]                   NAME <- NAMES[[kk]]
[13:24:28.300]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.300]                     next
[13:24:28.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.300]                 }
[13:24:28.300]                 NAMES <- toupper(added)
[13:24:28.300]                 for (kk in seq_along(NAMES)) {
[13:24:28.300]                   name <- added[[kk]]
[13:24:28.300]                   NAME <- NAMES[[kk]]
[13:24:28.300]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.300]                     next
[13:24:28.300]                   args[[name]] <- ""
[13:24:28.300]                 }
[13:24:28.300]                 NAMES <- toupper(removed)
[13:24:28.300]                 for (kk in seq_along(NAMES)) {
[13:24:28.300]                   name <- removed[[kk]]
[13:24:28.300]                   NAME <- NAMES[[kk]]
[13:24:28.300]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.300]                     next
[13:24:28.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.300]                 }
[13:24:28.300]                 if (length(args) > 0) 
[13:24:28.300]                   base::do.call(base::Sys.setenv, args = args)
[13:24:28.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:28.300]             }
[13:24:28.300]             else {
[13:24:28.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:28.300]             }
[13:24:28.300]             {
[13:24:28.300]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:28.300]                   0L) {
[13:24:28.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:28.300]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:28.300]                   base::options(opts)
[13:24:28.300]                 }
[13:24:28.300]                 {
[13:24:28.300]                   {
[13:24:28.300]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:28.300]                     NULL
[13:24:28.300]                   }
[13:24:28.300]                   options(future.plan = NULL)
[13:24:28.300]                   if (is.na(NA_character_)) 
[13:24:28.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:28.300]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:28.300]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:28.300]                     envir = parent.frame()) 
[13:24:28.300]                   {
[13:24:28.300]                     if (is.function(workers)) 
[13:24:28.300]                       workers <- workers()
[13:24:28.300]                     workers <- structure(as.integer(workers), 
[13:24:28.300]                       class = class(workers))
[13:24:28.300]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:28.300]                       workers >= 1)
[13:24:28.300]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:28.300]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:28.300]                     }
[13:24:28.300]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:28.300]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:28.300]                       envir = envir)
[13:24:28.300]                     if (!future$lazy) 
[13:24:28.300]                       future <- run(future)
[13:24:28.300]                     invisible(future)
[13:24:28.300]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:28.300]                 }
[13:24:28.300]             }
[13:24:28.300]         }
[13:24:28.300]     })
[13:24:28.300]     if (TRUE) {
[13:24:28.300]         base::sink(type = "output", split = FALSE)
[13:24:28.300]         if (TRUE) {
[13:24:28.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:28.300]         }
[13:24:28.300]         else {
[13:24:28.300]             ...future.result["stdout"] <- base::list(NULL)
[13:24:28.300]         }
[13:24:28.300]         base::close(...future.stdout)
[13:24:28.300]         ...future.stdout <- NULL
[13:24:28.300]     }
[13:24:28.300]     ...future.result$conditions <- ...future.conditions
[13:24:28.300]     ...future.result$finished <- base::Sys.time()
[13:24:28.300]     ...future.result
[13:24:28.300] }
[13:24:28.302] Poll #1 (0): usedNodes() = 2, workers = 2
[13:24:28.323] receiveMessageFromWorker() for ClusterFuture ...
[13:24:28.324] - Validating connection of MultisessionFuture
[13:24:28.324] - received message: FutureResult
[13:24:28.324] - Received FutureResult
[13:24:28.324] - Erased future from FutureRegistry
[13:24:28.324] result() for ClusterFuture ...
[13:24:28.325] - result already collected: FutureResult
[13:24:28.325] result() for ClusterFuture ... done
[13:24:28.325] signalConditions() ...
[13:24:28.325]  - include = ‘immediateCondition’
[13:24:28.325]  - exclude = 
[13:24:28.325]  - resignal = FALSE
[13:24:28.325]  - Number of conditions: 1
[13:24:28.325] signalConditions() ... done
[13:24:28.325] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:28.325] result() for ClusterFuture ...
[13:24:28.325] - result already collected: FutureResult
[13:24:28.326] result() for ClusterFuture ... done
[13:24:28.326] result() for ClusterFuture ...
[13:24:28.326] - result already collected: FutureResult
[13:24:28.326] result() for ClusterFuture ... done
[13:24:28.326] signalConditions() ...
[13:24:28.326]  - include = ‘immediateCondition’
[13:24:28.326]  - exclude = 
[13:24:28.326]  - resignal = FALSE
[13:24:28.326]  - Number of conditions: 1
[13:24:28.326] signalConditions() ... done
[13:24:28.327] MultisessionFuture started
[13:24:28.327] - Launch lazy future ... done
[13:24:28.328] run() for ‘MultisessionFuture’ ... done
[13:24:28.874] receiveMessageFromWorker() for ClusterFuture ...
[13:24:28.874] - Validating connection of MultisessionFuture
[13:24:28.875] - received message: FutureResult
[13:24:28.875] - Received FutureResult
[13:24:28.875] - Erased future from FutureRegistry
[13:24:28.875] result() for ClusterFuture ...
[13:24:28.875] - result already collected: FutureResult
[13:24:28.875] result() for ClusterFuture ... done
[13:24:28.875] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:28.875] A MultisessionFuture was resolved (result was not collected)
[13:24:28.876] getGlobalsAndPackages() ...
[13:24:28.876] Searching for globals...
[13:24:28.877] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:28.877] Searching for globals ... DONE
[13:24:28.877] Resolving globals: FALSE
[13:24:28.877] 
[13:24:28.877] 
[13:24:28.878] getGlobalsAndPackages() ... DONE
[13:24:28.878] run() for ‘Future’ ...
[13:24:28.878] - state: ‘created’
[13:24:28.878] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:28.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:28.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:28.892]   - Field: ‘node’
[13:24:28.892]   - Field: ‘label’
[13:24:28.892]   - Field: ‘local’
[13:24:28.892]   - Field: ‘owner’
[13:24:28.892]   - Field: ‘envir’
[13:24:28.892]   - Field: ‘workers’
[13:24:28.892]   - Field: ‘packages’
[13:24:28.893]   - Field: ‘gc’
[13:24:28.893]   - Field: ‘conditions’
[13:24:28.893]   - Field: ‘persistent’
[13:24:28.893]   - Field: ‘expr’
[13:24:28.893]   - Field: ‘uuid’
[13:24:28.893]   - Field: ‘seed’
[13:24:28.893]   - Field: ‘version’
[13:24:28.893]   - Field: ‘result’
[13:24:28.893]   - Field: ‘asynchronous’
[13:24:28.893]   - Field: ‘calls’
[13:24:28.894]   - Field: ‘globals’
[13:24:28.894]   - Field: ‘stdout’
[13:24:28.894]   - Field: ‘earlySignal’
[13:24:28.894]   - Field: ‘lazy’
[13:24:28.894]   - Field: ‘state’
[13:24:28.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:28.894] - Launch lazy future ...
[13:24:28.894] Packages needed by the future expression (n = 0): <none>
[13:24:28.894] Packages needed by future strategies (n = 0): <none>
[13:24:28.895] {
[13:24:28.895]     {
[13:24:28.895]         {
[13:24:28.895]             ...future.startTime <- base::Sys.time()
[13:24:28.895]             {
[13:24:28.895]                 {
[13:24:28.895]                   {
[13:24:28.895]                     {
[13:24:28.895]                       base::local({
[13:24:28.895]                         has_future <- base::requireNamespace("future", 
[13:24:28.895]                           quietly = TRUE)
[13:24:28.895]                         if (has_future) {
[13:24:28.895]                           ns <- base::getNamespace("future")
[13:24:28.895]                           version <- ns[[".package"]][["version"]]
[13:24:28.895]                           if (is.null(version)) 
[13:24:28.895]                             version <- utils::packageVersion("future")
[13:24:28.895]                         }
[13:24:28.895]                         else {
[13:24:28.895]                           version <- NULL
[13:24:28.895]                         }
[13:24:28.895]                         if (!has_future || version < "1.8.0") {
[13:24:28.895]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:28.895]                             "", base::R.version$version.string), 
[13:24:28.895]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:28.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:28.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:28.895]                               "release", "version")], collapse = " "), 
[13:24:28.895]                             hostname = base::Sys.info()[["nodename"]])
[13:24:28.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:28.895]                             info)
[13:24:28.895]                           info <- base::paste(info, collapse = "; ")
[13:24:28.895]                           if (!has_future) {
[13:24:28.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:28.895]                               info)
[13:24:28.895]                           }
[13:24:28.895]                           else {
[13:24:28.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:28.895]                               info, version)
[13:24:28.895]                           }
[13:24:28.895]                           base::stop(msg)
[13:24:28.895]                         }
[13:24:28.895]                       })
[13:24:28.895]                     }
[13:24:28.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:28.895]                     base::options(mc.cores = 1L)
[13:24:28.895]                   }
[13:24:28.895]                   options(future.plan = NULL)
[13:24:28.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:28.895]                 }
[13:24:28.895]                 ...future.workdir <- getwd()
[13:24:28.895]             }
[13:24:28.895]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:28.895]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:28.895]         }
[13:24:28.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:28.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:28.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:28.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:28.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:28.895]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:28.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:28.895]             base::names(...future.oldOptions))
[13:24:28.895]     }
[13:24:28.895]     if (FALSE) {
[13:24:28.895]     }
[13:24:28.895]     else {
[13:24:28.895]         if (TRUE) {
[13:24:28.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:28.895]                 open = "w")
[13:24:28.895]         }
[13:24:28.895]         else {
[13:24:28.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:28.895]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:28.895]         }
[13:24:28.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:28.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:28.895]             base::sink(type = "output", split = FALSE)
[13:24:28.895]             base::close(...future.stdout)
[13:24:28.895]         }, add = TRUE)
[13:24:28.895]     }
[13:24:28.895]     ...future.frame <- base::sys.nframe()
[13:24:28.895]     ...future.conditions <- base::list()
[13:24:28.895]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:28.895]     if (FALSE) {
[13:24:28.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:28.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:28.895]     }
[13:24:28.895]     ...future.result <- base::tryCatch({
[13:24:28.895]         base::withCallingHandlers({
[13:24:28.895]             ...future.value <- base::withVisible(base::local({
[13:24:28.895]                 ...future.makeSendCondition <- base::local({
[13:24:28.895]                   sendCondition <- NULL
[13:24:28.895]                   function(frame = 1L) {
[13:24:28.895]                     if (is.function(sendCondition)) 
[13:24:28.895]                       return(sendCondition)
[13:24:28.895]                     ns <- getNamespace("parallel")
[13:24:28.895]                     if (exists("sendData", mode = "function", 
[13:24:28.895]                       envir = ns)) {
[13:24:28.895]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:28.895]                         envir = ns)
[13:24:28.895]                       envir <- sys.frame(frame)
[13:24:28.895]                       master <- NULL
[13:24:28.895]                       while (!identical(envir, .GlobalEnv) && 
[13:24:28.895]                         !identical(envir, emptyenv())) {
[13:24:28.895]                         if (exists("master", mode = "list", envir = envir, 
[13:24:28.895]                           inherits = FALSE)) {
[13:24:28.895]                           master <- get("master", mode = "list", 
[13:24:28.895]                             envir = envir, inherits = FALSE)
[13:24:28.895]                           if (inherits(master, c("SOCKnode", 
[13:24:28.895]                             "SOCK0node"))) {
[13:24:28.895]                             sendCondition <<- function(cond) {
[13:24:28.895]                               data <- list(type = "VALUE", value = cond, 
[13:24:28.895]                                 success = TRUE)
[13:24:28.895]                               parallel_sendData(master, data)
[13:24:28.895]                             }
[13:24:28.895]                             return(sendCondition)
[13:24:28.895]                           }
[13:24:28.895]                         }
[13:24:28.895]                         frame <- frame + 1L
[13:24:28.895]                         envir <- sys.frame(frame)
[13:24:28.895]                       }
[13:24:28.895]                     }
[13:24:28.895]                     sendCondition <<- function(cond) NULL
[13:24:28.895]                   }
[13:24:28.895]                 })
[13:24:28.895]                 withCallingHandlers({
[13:24:28.895]                   {
[13:24:28.895]                     Sys.sleep(0.5)
[13:24:28.895]                     list(a = 1, b = 42L)
[13:24:28.895]                   }
[13:24:28.895]                 }, immediateCondition = function(cond) {
[13:24:28.895]                   sendCondition <- ...future.makeSendCondition()
[13:24:28.895]                   sendCondition(cond)
[13:24:28.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.895]                   {
[13:24:28.895]                     inherits <- base::inherits
[13:24:28.895]                     invokeRestart <- base::invokeRestart
[13:24:28.895]                     is.null <- base::is.null
[13:24:28.895]                     muffled <- FALSE
[13:24:28.895]                     if (inherits(cond, "message")) {
[13:24:28.895]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:28.895]                       if (muffled) 
[13:24:28.895]                         invokeRestart("muffleMessage")
[13:24:28.895]                     }
[13:24:28.895]                     else if (inherits(cond, "warning")) {
[13:24:28.895]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:28.895]                       if (muffled) 
[13:24:28.895]                         invokeRestart("muffleWarning")
[13:24:28.895]                     }
[13:24:28.895]                     else if (inherits(cond, "condition")) {
[13:24:28.895]                       if (!is.null(pattern)) {
[13:24:28.895]                         computeRestarts <- base::computeRestarts
[13:24:28.895]                         grepl <- base::grepl
[13:24:28.895]                         restarts <- computeRestarts(cond)
[13:24:28.895]                         for (restart in restarts) {
[13:24:28.895]                           name <- restart$name
[13:24:28.895]                           if (is.null(name)) 
[13:24:28.895]                             next
[13:24:28.895]                           if (!grepl(pattern, name)) 
[13:24:28.895]                             next
[13:24:28.895]                           invokeRestart(restart)
[13:24:28.895]                           muffled <- TRUE
[13:24:28.895]                           break
[13:24:28.895]                         }
[13:24:28.895]                       }
[13:24:28.895]                     }
[13:24:28.895]                     invisible(muffled)
[13:24:28.895]                   }
[13:24:28.895]                   muffleCondition(cond)
[13:24:28.895]                 })
[13:24:28.895]             }))
[13:24:28.895]             future::FutureResult(value = ...future.value$value, 
[13:24:28.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.895]                   ...future.rng), globalenv = if (FALSE) 
[13:24:28.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:28.895]                     ...future.globalenv.names))
[13:24:28.895]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:28.895]         }, condition = base::local({
[13:24:28.895]             c <- base::c
[13:24:28.895]             inherits <- base::inherits
[13:24:28.895]             invokeRestart <- base::invokeRestart
[13:24:28.895]             length <- base::length
[13:24:28.895]             list <- base::list
[13:24:28.895]             seq.int <- base::seq.int
[13:24:28.895]             signalCondition <- base::signalCondition
[13:24:28.895]             sys.calls <- base::sys.calls
[13:24:28.895]             `[[` <- base::`[[`
[13:24:28.895]             `+` <- base::`+`
[13:24:28.895]             `<<-` <- base::`<<-`
[13:24:28.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:28.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:28.895]                   3L)]
[13:24:28.895]             }
[13:24:28.895]             function(cond) {
[13:24:28.895]                 is_error <- inherits(cond, "error")
[13:24:28.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:28.895]                   NULL)
[13:24:28.895]                 if (is_error) {
[13:24:28.895]                   sessionInformation <- function() {
[13:24:28.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:28.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:28.895]                       search = base::search(), system = base::Sys.info())
[13:24:28.895]                   }
[13:24:28.895]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:28.895]                     cond$call), session = sessionInformation(), 
[13:24:28.895]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:28.895]                   signalCondition(cond)
[13:24:28.895]                 }
[13:24:28.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:28.895]                 "immediateCondition"))) {
[13:24:28.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:28.895]                   ...future.conditions[[length(...future.conditions) + 
[13:24:28.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:28.895]                   if (TRUE && !signal) {
[13:24:28.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.895]                     {
[13:24:28.895]                       inherits <- base::inherits
[13:24:28.895]                       invokeRestart <- base::invokeRestart
[13:24:28.895]                       is.null <- base::is.null
[13:24:28.895]                       muffled <- FALSE
[13:24:28.895]                       if (inherits(cond, "message")) {
[13:24:28.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.895]                         if (muffled) 
[13:24:28.895]                           invokeRestart("muffleMessage")
[13:24:28.895]                       }
[13:24:28.895]                       else if (inherits(cond, "warning")) {
[13:24:28.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.895]                         if (muffled) 
[13:24:28.895]                           invokeRestart("muffleWarning")
[13:24:28.895]                       }
[13:24:28.895]                       else if (inherits(cond, "condition")) {
[13:24:28.895]                         if (!is.null(pattern)) {
[13:24:28.895]                           computeRestarts <- base::computeRestarts
[13:24:28.895]                           grepl <- base::grepl
[13:24:28.895]                           restarts <- computeRestarts(cond)
[13:24:28.895]                           for (restart in restarts) {
[13:24:28.895]                             name <- restart$name
[13:24:28.895]                             if (is.null(name)) 
[13:24:28.895]                               next
[13:24:28.895]                             if (!grepl(pattern, name)) 
[13:24:28.895]                               next
[13:24:28.895]                             invokeRestart(restart)
[13:24:28.895]                             muffled <- TRUE
[13:24:28.895]                             break
[13:24:28.895]                           }
[13:24:28.895]                         }
[13:24:28.895]                       }
[13:24:28.895]                       invisible(muffled)
[13:24:28.895]                     }
[13:24:28.895]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.895]                   }
[13:24:28.895]                 }
[13:24:28.895]                 else {
[13:24:28.895]                   if (TRUE) {
[13:24:28.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:28.895]                     {
[13:24:28.895]                       inherits <- base::inherits
[13:24:28.895]                       invokeRestart <- base::invokeRestart
[13:24:28.895]                       is.null <- base::is.null
[13:24:28.895]                       muffled <- FALSE
[13:24:28.895]                       if (inherits(cond, "message")) {
[13:24:28.895]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:28.895]                         if (muffled) 
[13:24:28.895]                           invokeRestart("muffleMessage")
[13:24:28.895]                       }
[13:24:28.895]                       else if (inherits(cond, "warning")) {
[13:24:28.895]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:28.895]                         if (muffled) 
[13:24:28.895]                           invokeRestart("muffleWarning")
[13:24:28.895]                       }
[13:24:28.895]                       else if (inherits(cond, "condition")) {
[13:24:28.895]                         if (!is.null(pattern)) {
[13:24:28.895]                           computeRestarts <- base::computeRestarts
[13:24:28.895]                           grepl <- base::grepl
[13:24:28.895]                           restarts <- computeRestarts(cond)
[13:24:28.895]                           for (restart in restarts) {
[13:24:28.895]                             name <- restart$name
[13:24:28.895]                             if (is.null(name)) 
[13:24:28.895]                               next
[13:24:28.895]                             if (!grepl(pattern, name)) 
[13:24:28.895]                               next
[13:24:28.895]                             invokeRestart(restart)
[13:24:28.895]                             muffled <- TRUE
[13:24:28.895]                             break
[13:24:28.895]                           }
[13:24:28.895]                         }
[13:24:28.895]                       }
[13:24:28.895]                       invisible(muffled)
[13:24:28.895]                     }
[13:24:28.895]                     muffleCondition(cond, pattern = "^muffle")
[13:24:28.895]                   }
[13:24:28.895]                 }
[13:24:28.895]             }
[13:24:28.895]         }))
[13:24:28.895]     }, error = function(ex) {
[13:24:28.895]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:28.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:28.895]                 ...future.rng), started = ...future.startTime, 
[13:24:28.895]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:28.895]             version = "1.8"), class = "FutureResult")
[13:24:28.895]     }, finally = {
[13:24:28.895]         if (!identical(...future.workdir, getwd())) 
[13:24:28.895]             setwd(...future.workdir)
[13:24:28.895]         {
[13:24:28.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:28.895]                 ...future.oldOptions$nwarnings <- NULL
[13:24:28.895]             }
[13:24:28.895]             base::options(...future.oldOptions)
[13:24:28.895]             if (.Platform$OS.type == "windows") {
[13:24:28.895]                 old_names <- names(...future.oldEnvVars)
[13:24:28.895]                 envs <- base::Sys.getenv()
[13:24:28.895]                 names <- names(envs)
[13:24:28.895]                 common <- intersect(names, old_names)
[13:24:28.895]                 added <- setdiff(names, old_names)
[13:24:28.895]                 removed <- setdiff(old_names, names)
[13:24:28.895]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:28.895]                   envs[common]]
[13:24:28.895]                 NAMES <- toupper(changed)
[13:24:28.895]                 args <- list()
[13:24:28.895]                 for (kk in seq_along(NAMES)) {
[13:24:28.895]                   name <- changed[[kk]]
[13:24:28.895]                   NAME <- NAMES[[kk]]
[13:24:28.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.895]                     next
[13:24:28.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.895]                 }
[13:24:28.895]                 NAMES <- toupper(added)
[13:24:28.895]                 for (kk in seq_along(NAMES)) {
[13:24:28.895]                   name <- added[[kk]]
[13:24:28.895]                   NAME <- NAMES[[kk]]
[13:24:28.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.895]                     next
[13:24:28.895]                   args[[name]] <- ""
[13:24:28.895]                 }
[13:24:28.895]                 NAMES <- toupper(removed)
[13:24:28.895]                 for (kk in seq_along(NAMES)) {
[13:24:28.895]                   name <- removed[[kk]]
[13:24:28.895]                   NAME <- NAMES[[kk]]
[13:24:28.895]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:28.895]                     next
[13:24:28.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:28.895]                 }
[13:24:28.895]                 if (length(args) > 0) 
[13:24:28.895]                   base::do.call(base::Sys.setenv, args = args)
[13:24:28.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:28.895]             }
[13:24:28.895]             else {
[13:24:28.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:28.895]             }
[13:24:28.895]             {
[13:24:28.895]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:28.895]                   0L) {
[13:24:28.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:28.895]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:28.895]                   base::options(opts)
[13:24:28.895]                 }
[13:24:28.895]                 {
[13:24:28.895]                   {
[13:24:28.895]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:28.895]                     NULL
[13:24:28.895]                   }
[13:24:28.895]                   options(future.plan = NULL)
[13:24:28.895]                   if (is.na(NA_character_)) 
[13:24:28.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:28.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:28.895]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:28.895]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:28.895]                     envir = parent.frame()) 
[13:24:28.895]                   {
[13:24:28.895]                     if (is.function(workers)) 
[13:24:28.895]                       workers <- workers()
[13:24:28.895]                     workers <- structure(as.integer(workers), 
[13:24:28.895]                       class = class(workers))
[13:24:28.895]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:28.895]                       workers >= 1)
[13:24:28.895]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:28.895]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:28.895]                     }
[13:24:28.895]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:28.895]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:28.895]                       envir = envir)
[13:24:28.895]                     if (!future$lazy) 
[13:24:28.895]                       future <- run(future)
[13:24:28.895]                     invisible(future)
[13:24:28.895]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:28.895]                 }
[13:24:28.895]             }
[13:24:28.895]         }
[13:24:28.895]     })
[13:24:28.895]     if (TRUE) {
[13:24:28.895]         base::sink(type = "output", split = FALSE)
[13:24:28.895]         if (TRUE) {
[13:24:28.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:28.895]         }
[13:24:28.895]         else {
[13:24:28.895]             ...future.result["stdout"] <- base::list(NULL)
[13:24:28.895]         }
[13:24:28.895]         base::close(...future.stdout)
[13:24:28.895]         ...future.stdout <- NULL
[13:24:28.895]     }
[13:24:28.895]     ...future.result$conditions <- ...future.conditions
[13:24:28.895]     ...future.result$finished <- base::Sys.time()
[13:24:28.895]     ...future.result
[13:24:28.895] }
[13:24:28.898] MultisessionFuture started
[13:24:28.898] - Launch lazy future ... done
[13:24:28.899] run() for ‘MultisessionFuture’ ... done
[13:24:29.446] receiveMessageFromWorker() for ClusterFuture ...
[13:24:29.446] - Validating connection of MultisessionFuture
[13:24:29.447] - received message: FutureResult
[13:24:29.447] - Received FutureResult
[13:24:29.447] - Erased future from FutureRegistry
[13:24:29.447] result() for ClusterFuture ...
[13:24:29.447] - result already collected: FutureResult
[13:24:29.447] result() for ClusterFuture ... done
[13:24:29.447] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:29.447] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:24:29.448] getGlobalsAndPackages() ...
[13:24:29.448] Searching for globals...
[13:24:29.448] - globals found: [2] ‘list’, ‘stop’
[13:24:29.448] Searching for globals ... DONE
[13:24:29.449] Resolving globals: FALSE
[13:24:29.449] 
[13:24:29.449] 
[13:24:29.449] getGlobalsAndPackages() ... DONE
[13:24:29.449] run() for ‘Future’ ...
[13:24:29.449] - state: ‘created’
[13:24:29.450] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:29.465] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:29.466] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:29.466]   - Field: ‘node’
[13:24:29.466]   - Field: ‘label’
[13:24:29.466]   - Field: ‘local’
[13:24:29.466]   - Field: ‘owner’
[13:24:29.466]   - Field: ‘envir’
[13:24:29.466]   - Field: ‘workers’
[13:24:29.466]   - Field: ‘packages’
[13:24:29.466]   - Field: ‘gc’
[13:24:29.466]   - Field: ‘conditions’
[13:24:29.466]   - Field: ‘persistent’
[13:24:29.467]   - Field: ‘expr’
[13:24:29.467]   - Field: ‘uuid’
[13:24:29.467]   - Field: ‘seed’
[13:24:29.467]   - Field: ‘version’
[13:24:29.467]   - Field: ‘result’
[13:24:29.467]   - Field: ‘asynchronous’
[13:24:29.467]   - Field: ‘calls’
[13:24:29.467]   - Field: ‘globals’
[13:24:29.467]   - Field: ‘stdout’
[13:24:29.467]   - Field: ‘earlySignal’
[13:24:29.467]   - Field: ‘lazy’
[13:24:29.468]   - Field: ‘state’
[13:24:29.468] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:29.468] - Launch lazy future ...
[13:24:29.468] Packages needed by the future expression (n = 0): <none>
[13:24:29.468] Packages needed by future strategies (n = 0): <none>
[13:24:29.469] {
[13:24:29.469]     {
[13:24:29.469]         {
[13:24:29.469]             ...future.startTime <- base::Sys.time()
[13:24:29.469]             {
[13:24:29.469]                 {
[13:24:29.469]                   {
[13:24:29.469]                     {
[13:24:29.469]                       base::local({
[13:24:29.469]                         has_future <- base::requireNamespace("future", 
[13:24:29.469]                           quietly = TRUE)
[13:24:29.469]                         if (has_future) {
[13:24:29.469]                           ns <- base::getNamespace("future")
[13:24:29.469]                           version <- ns[[".package"]][["version"]]
[13:24:29.469]                           if (is.null(version)) 
[13:24:29.469]                             version <- utils::packageVersion("future")
[13:24:29.469]                         }
[13:24:29.469]                         else {
[13:24:29.469]                           version <- NULL
[13:24:29.469]                         }
[13:24:29.469]                         if (!has_future || version < "1.8.0") {
[13:24:29.469]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:29.469]                             "", base::R.version$version.string), 
[13:24:29.469]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:29.469]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:29.469]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:29.469]                               "release", "version")], collapse = " "), 
[13:24:29.469]                             hostname = base::Sys.info()[["nodename"]])
[13:24:29.469]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:29.469]                             info)
[13:24:29.469]                           info <- base::paste(info, collapse = "; ")
[13:24:29.469]                           if (!has_future) {
[13:24:29.469]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:29.469]                               info)
[13:24:29.469]                           }
[13:24:29.469]                           else {
[13:24:29.469]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:29.469]                               info, version)
[13:24:29.469]                           }
[13:24:29.469]                           base::stop(msg)
[13:24:29.469]                         }
[13:24:29.469]                       })
[13:24:29.469]                     }
[13:24:29.469]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:29.469]                     base::options(mc.cores = 1L)
[13:24:29.469]                   }
[13:24:29.469]                   options(future.plan = NULL)
[13:24:29.469]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:29.469]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:29.469]                 }
[13:24:29.469]                 ...future.workdir <- getwd()
[13:24:29.469]             }
[13:24:29.469]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:29.469]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:29.469]         }
[13:24:29.469]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:29.469]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:29.469]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:29.469]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:29.469]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:29.469]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:29.469]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:29.469]             base::names(...future.oldOptions))
[13:24:29.469]     }
[13:24:29.469]     if (FALSE) {
[13:24:29.469]     }
[13:24:29.469]     else {
[13:24:29.469]         if (TRUE) {
[13:24:29.469]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:29.469]                 open = "w")
[13:24:29.469]         }
[13:24:29.469]         else {
[13:24:29.469]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:29.469]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:29.469]         }
[13:24:29.469]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:29.469]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:29.469]             base::sink(type = "output", split = FALSE)
[13:24:29.469]             base::close(...future.stdout)
[13:24:29.469]         }, add = TRUE)
[13:24:29.469]     }
[13:24:29.469]     ...future.frame <- base::sys.nframe()
[13:24:29.469]     ...future.conditions <- base::list()
[13:24:29.469]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:29.469]     if (FALSE) {
[13:24:29.469]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:29.469]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:29.469]     }
[13:24:29.469]     ...future.result <- base::tryCatch({
[13:24:29.469]         base::withCallingHandlers({
[13:24:29.469]             ...future.value <- base::withVisible(base::local({
[13:24:29.469]                 ...future.makeSendCondition <- base::local({
[13:24:29.469]                   sendCondition <- NULL
[13:24:29.469]                   function(frame = 1L) {
[13:24:29.469]                     if (is.function(sendCondition)) 
[13:24:29.469]                       return(sendCondition)
[13:24:29.469]                     ns <- getNamespace("parallel")
[13:24:29.469]                     if (exists("sendData", mode = "function", 
[13:24:29.469]                       envir = ns)) {
[13:24:29.469]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:29.469]                         envir = ns)
[13:24:29.469]                       envir <- sys.frame(frame)
[13:24:29.469]                       master <- NULL
[13:24:29.469]                       while (!identical(envir, .GlobalEnv) && 
[13:24:29.469]                         !identical(envir, emptyenv())) {
[13:24:29.469]                         if (exists("master", mode = "list", envir = envir, 
[13:24:29.469]                           inherits = FALSE)) {
[13:24:29.469]                           master <- get("master", mode = "list", 
[13:24:29.469]                             envir = envir, inherits = FALSE)
[13:24:29.469]                           if (inherits(master, c("SOCKnode", 
[13:24:29.469]                             "SOCK0node"))) {
[13:24:29.469]                             sendCondition <<- function(cond) {
[13:24:29.469]                               data <- list(type = "VALUE", value = cond, 
[13:24:29.469]                                 success = TRUE)
[13:24:29.469]                               parallel_sendData(master, data)
[13:24:29.469]                             }
[13:24:29.469]                             return(sendCondition)
[13:24:29.469]                           }
[13:24:29.469]                         }
[13:24:29.469]                         frame <- frame + 1L
[13:24:29.469]                         envir <- sys.frame(frame)
[13:24:29.469]                       }
[13:24:29.469]                     }
[13:24:29.469]                     sendCondition <<- function(cond) NULL
[13:24:29.469]                   }
[13:24:29.469]                 })
[13:24:29.469]                 withCallingHandlers({
[13:24:29.469]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:29.469]                 }, immediateCondition = function(cond) {
[13:24:29.469]                   sendCondition <- ...future.makeSendCondition()
[13:24:29.469]                   sendCondition(cond)
[13:24:29.469]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.469]                   {
[13:24:29.469]                     inherits <- base::inherits
[13:24:29.469]                     invokeRestart <- base::invokeRestart
[13:24:29.469]                     is.null <- base::is.null
[13:24:29.469]                     muffled <- FALSE
[13:24:29.469]                     if (inherits(cond, "message")) {
[13:24:29.469]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:29.469]                       if (muffled) 
[13:24:29.469]                         invokeRestart("muffleMessage")
[13:24:29.469]                     }
[13:24:29.469]                     else if (inherits(cond, "warning")) {
[13:24:29.469]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:29.469]                       if (muffled) 
[13:24:29.469]                         invokeRestart("muffleWarning")
[13:24:29.469]                     }
[13:24:29.469]                     else if (inherits(cond, "condition")) {
[13:24:29.469]                       if (!is.null(pattern)) {
[13:24:29.469]                         computeRestarts <- base::computeRestarts
[13:24:29.469]                         grepl <- base::grepl
[13:24:29.469]                         restarts <- computeRestarts(cond)
[13:24:29.469]                         for (restart in restarts) {
[13:24:29.469]                           name <- restart$name
[13:24:29.469]                           if (is.null(name)) 
[13:24:29.469]                             next
[13:24:29.469]                           if (!grepl(pattern, name)) 
[13:24:29.469]                             next
[13:24:29.469]                           invokeRestart(restart)
[13:24:29.469]                           muffled <- TRUE
[13:24:29.469]                           break
[13:24:29.469]                         }
[13:24:29.469]                       }
[13:24:29.469]                     }
[13:24:29.469]                     invisible(muffled)
[13:24:29.469]                   }
[13:24:29.469]                   muffleCondition(cond)
[13:24:29.469]                 })
[13:24:29.469]             }))
[13:24:29.469]             future::FutureResult(value = ...future.value$value, 
[13:24:29.469]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:29.469]                   ...future.rng), globalenv = if (FALSE) 
[13:24:29.469]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:29.469]                     ...future.globalenv.names))
[13:24:29.469]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:29.469]         }, condition = base::local({
[13:24:29.469]             c <- base::c
[13:24:29.469]             inherits <- base::inherits
[13:24:29.469]             invokeRestart <- base::invokeRestart
[13:24:29.469]             length <- base::length
[13:24:29.469]             list <- base::list
[13:24:29.469]             seq.int <- base::seq.int
[13:24:29.469]             signalCondition <- base::signalCondition
[13:24:29.469]             sys.calls <- base::sys.calls
[13:24:29.469]             `[[` <- base::`[[`
[13:24:29.469]             `+` <- base::`+`
[13:24:29.469]             `<<-` <- base::`<<-`
[13:24:29.469]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:29.469]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:29.469]                   3L)]
[13:24:29.469]             }
[13:24:29.469]             function(cond) {
[13:24:29.469]                 is_error <- inherits(cond, "error")
[13:24:29.469]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:29.469]                   NULL)
[13:24:29.469]                 if (is_error) {
[13:24:29.469]                   sessionInformation <- function() {
[13:24:29.469]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:29.469]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:29.469]                       search = base::search(), system = base::Sys.info())
[13:24:29.469]                   }
[13:24:29.469]                   ...future.conditions[[length(...future.conditions) + 
[13:24:29.469]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:29.469]                     cond$call), session = sessionInformation(), 
[13:24:29.469]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:29.469]                   signalCondition(cond)
[13:24:29.469]                 }
[13:24:29.469]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:29.469]                 "immediateCondition"))) {
[13:24:29.469]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:29.469]                   ...future.conditions[[length(...future.conditions) + 
[13:24:29.469]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:29.469]                   if (TRUE && !signal) {
[13:24:29.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.469]                     {
[13:24:29.469]                       inherits <- base::inherits
[13:24:29.469]                       invokeRestart <- base::invokeRestart
[13:24:29.469]                       is.null <- base::is.null
[13:24:29.469]                       muffled <- FALSE
[13:24:29.469]                       if (inherits(cond, "message")) {
[13:24:29.469]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:29.469]                         if (muffled) 
[13:24:29.469]                           invokeRestart("muffleMessage")
[13:24:29.469]                       }
[13:24:29.469]                       else if (inherits(cond, "warning")) {
[13:24:29.469]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:29.469]                         if (muffled) 
[13:24:29.469]                           invokeRestart("muffleWarning")
[13:24:29.469]                       }
[13:24:29.469]                       else if (inherits(cond, "condition")) {
[13:24:29.469]                         if (!is.null(pattern)) {
[13:24:29.469]                           computeRestarts <- base::computeRestarts
[13:24:29.469]                           grepl <- base::grepl
[13:24:29.469]                           restarts <- computeRestarts(cond)
[13:24:29.469]                           for (restart in restarts) {
[13:24:29.469]                             name <- restart$name
[13:24:29.469]                             if (is.null(name)) 
[13:24:29.469]                               next
[13:24:29.469]                             if (!grepl(pattern, name)) 
[13:24:29.469]                               next
[13:24:29.469]                             invokeRestart(restart)
[13:24:29.469]                             muffled <- TRUE
[13:24:29.469]                             break
[13:24:29.469]                           }
[13:24:29.469]                         }
[13:24:29.469]                       }
[13:24:29.469]                       invisible(muffled)
[13:24:29.469]                     }
[13:24:29.469]                     muffleCondition(cond, pattern = "^muffle")
[13:24:29.469]                   }
[13:24:29.469]                 }
[13:24:29.469]                 else {
[13:24:29.469]                   if (TRUE) {
[13:24:29.469]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.469]                     {
[13:24:29.469]                       inherits <- base::inherits
[13:24:29.469]                       invokeRestart <- base::invokeRestart
[13:24:29.469]                       is.null <- base::is.null
[13:24:29.469]                       muffled <- FALSE
[13:24:29.469]                       if (inherits(cond, "message")) {
[13:24:29.469]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:29.469]                         if (muffled) 
[13:24:29.469]                           invokeRestart("muffleMessage")
[13:24:29.469]                       }
[13:24:29.469]                       else if (inherits(cond, "warning")) {
[13:24:29.469]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:29.469]                         if (muffled) 
[13:24:29.469]                           invokeRestart("muffleWarning")
[13:24:29.469]                       }
[13:24:29.469]                       else if (inherits(cond, "condition")) {
[13:24:29.469]                         if (!is.null(pattern)) {
[13:24:29.469]                           computeRestarts <- base::computeRestarts
[13:24:29.469]                           grepl <- base::grepl
[13:24:29.469]                           restarts <- computeRestarts(cond)
[13:24:29.469]                           for (restart in restarts) {
[13:24:29.469]                             name <- restart$name
[13:24:29.469]                             if (is.null(name)) 
[13:24:29.469]                               next
[13:24:29.469]                             if (!grepl(pattern, name)) 
[13:24:29.469]                               next
[13:24:29.469]                             invokeRestart(restart)
[13:24:29.469]                             muffled <- TRUE
[13:24:29.469]                             break
[13:24:29.469]                           }
[13:24:29.469]                         }
[13:24:29.469]                       }
[13:24:29.469]                       invisible(muffled)
[13:24:29.469]                     }
[13:24:29.469]                     muffleCondition(cond, pattern = "^muffle")
[13:24:29.469]                   }
[13:24:29.469]                 }
[13:24:29.469]             }
[13:24:29.469]         }))
[13:24:29.469]     }, error = function(ex) {
[13:24:29.469]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:29.469]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:29.469]                 ...future.rng), started = ...future.startTime, 
[13:24:29.469]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:29.469]             version = "1.8"), class = "FutureResult")
[13:24:29.469]     }, finally = {
[13:24:29.469]         if (!identical(...future.workdir, getwd())) 
[13:24:29.469]             setwd(...future.workdir)
[13:24:29.469]         {
[13:24:29.469]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:29.469]                 ...future.oldOptions$nwarnings <- NULL
[13:24:29.469]             }
[13:24:29.469]             base::options(...future.oldOptions)
[13:24:29.469]             if (.Platform$OS.type == "windows") {
[13:24:29.469]                 old_names <- names(...future.oldEnvVars)
[13:24:29.469]                 envs <- base::Sys.getenv()
[13:24:29.469]                 names <- names(envs)
[13:24:29.469]                 common <- intersect(names, old_names)
[13:24:29.469]                 added <- setdiff(names, old_names)
[13:24:29.469]                 removed <- setdiff(old_names, names)
[13:24:29.469]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:29.469]                   envs[common]]
[13:24:29.469]                 NAMES <- toupper(changed)
[13:24:29.469]                 args <- list()
[13:24:29.469]                 for (kk in seq_along(NAMES)) {
[13:24:29.469]                   name <- changed[[kk]]
[13:24:29.469]                   NAME <- NAMES[[kk]]
[13:24:29.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.469]                     next
[13:24:29.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:29.469]                 }
[13:24:29.469]                 NAMES <- toupper(added)
[13:24:29.469]                 for (kk in seq_along(NAMES)) {
[13:24:29.469]                   name <- added[[kk]]
[13:24:29.469]                   NAME <- NAMES[[kk]]
[13:24:29.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.469]                     next
[13:24:29.469]                   args[[name]] <- ""
[13:24:29.469]                 }
[13:24:29.469]                 NAMES <- toupper(removed)
[13:24:29.469]                 for (kk in seq_along(NAMES)) {
[13:24:29.469]                   name <- removed[[kk]]
[13:24:29.469]                   NAME <- NAMES[[kk]]
[13:24:29.469]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.469]                     next
[13:24:29.469]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:29.469]                 }
[13:24:29.469]                 if (length(args) > 0) 
[13:24:29.469]                   base::do.call(base::Sys.setenv, args = args)
[13:24:29.469]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:29.469]             }
[13:24:29.469]             else {
[13:24:29.469]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:29.469]             }
[13:24:29.469]             {
[13:24:29.469]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:29.469]                   0L) {
[13:24:29.469]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:29.469]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:29.469]                   base::options(opts)
[13:24:29.469]                 }
[13:24:29.469]                 {
[13:24:29.469]                   {
[13:24:29.469]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:29.469]                     NULL
[13:24:29.469]                   }
[13:24:29.469]                   options(future.plan = NULL)
[13:24:29.469]                   if (is.na(NA_character_)) 
[13:24:29.469]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:29.469]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:29.469]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:29.469]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:29.469]                     envir = parent.frame()) 
[13:24:29.469]                   {
[13:24:29.469]                     if (is.function(workers)) 
[13:24:29.469]                       workers <- workers()
[13:24:29.469]                     workers <- structure(as.integer(workers), 
[13:24:29.469]                       class = class(workers))
[13:24:29.469]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:29.469]                       workers >= 1)
[13:24:29.469]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:29.469]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:29.469]                     }
[13:24:29.469]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:29.469]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:29.469]                       envir = envir)
[13:24:29.469]                     if (!future$lazy) 
[13:24:29.469]                       future <- run(future)
[13:24:29.469]                     invisible(future)
[13:24:29.469]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:29.469]                 }
[13:24:29.469]             }
[13:24:29.469]         }
[13:24:29.469]     })
[13:24:29.469]     if (TRUE) {
[13:24:29.469]         base::sink(type = "output", split = FALSE)
[13:24:29.469]         if (TRUE) {
[13:24:29.469]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:29.469]         }
[13:24:29.469]         else {
[13:24:29.469]             ...future.result["stdout"] <- base::list(NULL)
[13:24:29.469]         }
[13:24:29.469]         base::close(...future.stdout)
[13:24:29.469]         ...future.stdout <- NULL
[13:24:29.469]     }
[13:24:29.469]     ...future.result$conditions <- ...future.conditions
[13:24:29.469]     ...future.result$finished <- base::Sys.time()
[13:24:29.469]     ...future.result
[13:24:29.469] }
[13:24:29.472] MultisessionFuture started
[13:24:29.472] - Launch lazy future ... done
[13:24:29.472] run() for ‘MultisessionFuture’ ... done
[13:24:29.517] receiveMessageFromWorker() for ClusterFuture ...
[13:24:29.517] - Validating connection of MultisessionFuture
[13:24:29.518] - received message: FutureResult
[13:24:29.518] - Received FutureResult
[13:24:29.518] - Erased future from FutureRegistry
[13:24:29.518] result() for ClusterFuture ...
[13:24:29.518] - result already collected: FutureResult
[13:24:29.518] result() for ClusterFuture ... done
[13:24:29.518] signalConditions() ...
[13:24:29.518]  - include = ‘immediateCondition’
[13:24:29.519]  - exclude = 
[13:24:29.519]  - resignal = FALSE
[13:24:29.519]  - Number of conditions: 1
[13:24:29.519] signalConditions() ... done
[13:24:29.519] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:29.519] A MultisessionFuture was resolved (result was not collected)
[13:24:29.519] getGlobalsAndPackages() ...
[13:24:29.519] Searching for globals...
[13:24:29.520] - globals found: [2] ‘list’, ‘stop’
[13:24:29.520] Searching for globals ... DONE
[13:24:29.520] Resolving globals: FALSE
[13:24:29.520] 
[13:24:29.521] 
[13:24:29.521] getGlobalsAndPackages() ... DONE
[13:24:29.521] run() for ‘Future’ ...
[13:24:29.521] - state: ‘created’
[13:24:29.521] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:29.535] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:29.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:29.535]   - Field: ‘node’
[13:24:29.535]   - Field: ‘label’
[13:24:29.535]   - Field: ‘local’
[13:24:29.536]   - Field: ‘owner’
[13:24:29.536]   - Field: ‘envir’
[13:24:29.536]   - Field: ‘workers’
[13:24:29.536]   - Field: ‘packages’
[13:24:29.536]   - Field: ‘gc’
[13:24:29.536]   - Field: ‘conditions’
[13:24:29.536]   - Field: ‘persistent’
[13:24:29.536]   - Field: ‘expr’
[13:24:29.536]   - Field: ‘uuid’
[13:24:29.536]   - Field: ‘seed’
[13:24:29.537]   - Field: ‘version’
[13:24:29.537]   - Field: ‘result’
[13:24:29.537]   - Field: ‘asynchronous’
[13:24:29.537]   - Field: ‘calls’
[13:24:29.537]   - Field: ‘globals’
[13:24:29.537]   - Field: ‘stdout’
[13:24:29.537]   - Field: ‘earlySignal’
[13:24:29.537]   - Field: ‘lazy’
[13:24:29.537]   - Field: ‘state’
[13:24:29.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:29.537] - Launch lazy future ...
[13:24:29.538] Packages needed by the future expression (n = 0): <none>
[13:24:29.538] Packages needed by future strategies (n = 0): <none>
[13:24:29.538] {
[13:24:29.538]     {
[13:24:29.538]         {
[13:24:29.538]             ...future.startTime <- base::Sys.time()
[13:24:29.538]             {
[13:24:29.538]                 {
[13:24:29.538]                   {
[13:24:29.538]                     {
[13:24:29.538]                       base::local({
[13:24:29.538]                         has_future <- base::requireNamespace("future", 
[13:24:29.538]                           quietly = TRUE)
[13:24:29.538]                         if (has_future) {
[13:24:29.538]                           ns <- base::getNamespace("future")
[13:24:29.538]                           version <- ns[[".package"]][["version"]]
[13:24:29.538]                           if (is.null(version)) 
[13:24:29.538]                             version <- utils::packageVersion("future")
[13:24:29.538]                         }
[13:24:29.538]                         else {
[13:24:29.538]                           version <- NULL
[13:24:29.538]                         }
[13:24:29.538]                         if (!has_future || version < "1.8.0") {
[13:24:29.538]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:29.538]                             "", base::R.version$version.string), 
[13:24:29.538]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:29.538]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:29.538]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:29.538]                               "release", "version")], collapse = " "), 
[13:24:29.538]                             hostname = base::Sys.info()[["nodename"]])
[13:24:29.538]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:29.538]                             info)
[13:24:29.538]                           info <- base::paste(info, collapse = "; ")
[13:24:29.538]                           if (!has_future) {
[13:24:29.538]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:29.538]                               info)
[13:24:29.538]                           }
[13:24:29.538]                           else {
[13:24:29.538]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:29.538]                               info, version)
[13:24:29.538]                           }
[13:24:29.538]                           base::stop(msg)
[13:24:29.538]                         }
[13:24:29.538]                       })
[13:24:29.538]                     }
[13:24:29.538]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:29.538]                     base::options(mc.cores = 1L)
[13:24:29.538]                   }
[13:24:29.538]                   options(future.plan = NULL)
[13:24:29.538]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:29.538]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:29.538]                 }
[13:24:29.538]                 ...future.workdir <- getwd()
[13:24:29.538]             }
[13:24:29.538]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:29.538]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:29.538]         }
[13:24:29.538]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:29.538]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:29.538]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:29.538]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:29.538]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:29.538]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:29.538]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:29.538]             base::names(...future.oldOptions))
[13:24:29.538]     }
[13:24:29.538]     if (FALSE) {
[13:24:29.538]     }
[13:24:29.538]     else {
[13:24:29.538]         if (TRUE) {
[13:24:29.538]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:29.538]                 open = "w")
[13:24:29.538]         }
[13:24:29.538]         else {
[13:24:29.538]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:29.538]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:29.538]         }
[13:24:29.538]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:29.538]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:29.538]             base::sink(type = "output", split = FALSE)
[13:24:29.538]             base::close(...future.stdout)
[13:24:29.538]         }, add = TRUE)
[13:24:29.538]     }
[13:24:29.538]     ...future.frame <- base::sys.nframe()
[13:24:29.538]     ...future.conditions <- base::list()
[13:24:29.538]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:29.538]     if (FALSE) {
[13:24:29.538]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:29.538]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:29.538]     }
[13:24:29.538]     ...future.result <- base::tryCatch({
[13:24:29.538]         base::withCallingHandlers({
[13:24:29.538]             ...future.value <- base::withVisible(base::local({
[13:24:29.538]                 ...future.makeSendCondition <- base::local({
[13:24:29.538]                   sendCondition <- NULL
[13:24:29.538]                   function(frame = 1L) {
[13:24:29.538]                     if (is.function(sendCondition)) 
[13:24:29.538]                       return(sendCondition)
[13:24:29.538]                     ns <- getNamespace("parallel")
[13:24:29.538]                     if (exists("sendData", mode = "function", 
[13:24:29.538]                       envir = ns)) {
[13:24:29.538]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:29.538]                         envir = ns)
[13:24:29.538]                       envir <- sys.frame(frame)
[13:24:29.538]                       master <- NULL
[13:24:29.538]                       while (!identical(envir, .GlobalEnv) && 
[13:24:29.538]                         !identical(envir, emptyenv())) {
[13:24:29.538]                         if (exists("master", mode = "list", envir = envir, 
[13:24:29.538]                           inherits = FALSE)) {
[13:24:29.538]                           master <- get("master", mode = "list", 
[13:24:29.538]                             envir = envir, inherits = FALSE)
[13:24:29.538]                           if (inherits(master, c("SOCKnode", 
[13:24:29.538]                             "SOCK0node"))) {
[13:24:29.538]                             sendCondition <<- function(cond) {
[13:24:29.538]                               data <- list(type = "VALUE", value = cond, 
[13:24:29.538]                                 success = TRUE)
[13:24:29.538]                               parallel_sendData(master, data)
[13:24:29.538]                             }
[13:24:29.538]                             return(sendCondition)
[13:24:29.538]                           }
[13:24:29.538]                         }
[13:24:29.538]                         frame <- frame + 1L
[13:24:29.538]                         envir <- sys.frame(frame)
[13:24:29.538]                       }
[13:24:29.538]                     }
[13:24:29.538]                     sendCondition <<- function(cond) NULL
[13:24:29.538]                   }
[13:24:29.538]                 })
[13:24:29.538]                 withCallingHandlers({
[13:24:29.538]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:29.538]                 }, immediateCondition = function(cond) {
[13:24:29.538]                   sendCondition <- ...future.makeSendCondition()
[13:24:29.538]                   sendCondition(cond)
[13:24:29.538]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.538]                   {
[13:24:29.538]                     inherits <- base::inherits
[13:24:29.538]                     invokeRestart <- base::invokeRestart
[13:24:29.538]                     is.null <- base::is.null
[13:24:29.538]                     muffled <- FALSE
[13:24:29.538]                     if (inherits(cond, "message")) {
[13:24:29.538]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:29.538]                       if (muffled) 
[13:24:29.538]                         invokeRestart("muffleMessage")
[13:24:29.538]                     }
[13:24:29.538]                     else if (inherits(cond, "warning")) {
[13:24:29.538]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:29.538]                       if (muffled) 
[13:24:29.538]                         invokeRestart("muffleWarning")
[13:24:29.538]                     }
[13:24:29.538]                     else if (inherits(cond, "condition")) {
[13:24:29.538]                       if (!is.null(pattern)) {
[13:24:29.538]                         computeRestarts <- base::computeRestarts
[13:24:29.538]                         grepl <- base::grepl
[13:24:29.538]                         restarts <- computeRestarts(cond)
[13:24:29.538]                         for (restart in restarts) {
[13:24:29.538]                           name <- restart$name
[13:24:29.538]                           if (is.null(name)) 
[13:24:29.538]                             next
[13:24:29.538]                           if (!grepl(pattern, name)) 
[13:24:29.538]                             next
[13:24:29.538]                           invokeRestart(restart)
[13:24:29.538]                           muffled <- TRUE
[13:24:29.538]                           break
[13:24:29.538]                         }
[13:24:29.538]                       }
[13:24:29.538]                     }
[13:24:29.538]                     invisible(muffled)
[13:24:29.538]                   }
[13:24:29.538]                   muffleCondition(cond)
[13:24:29.538]                 })
[13:24:29.538]             }))
[13:24:29.538]             future::FutureResult(value = ...future.value$value, 
[13:24:29.538]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:29.538]                   ...future.rng), globalenv = if (FALSE) 
[13:24:29.538]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:29.538]                     ...future.globalenv.names))
[13:24:29.538]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:29.538]         }, condition = base::local({
[13:24:29.538]             c <- base::c
[13:24:29.538]             inherits <- base::inherits
[13:24:29.538]             invokeRestart <- base::invokeRestart
[13:24:29.538]             length <- base::length
[13:24:29.538]             list <- base::list
[13:24:29.538]             seq.int <- base::seq.int
[13:24:29.538]             signalCondition <- base::signalCondition
[13:24:29.538]             sys.calls <- base::sys.calls
[13:24:29.538]             `[[` <- base::`[[`
[13:24:29.538]             `+` <- base::`+`
[13:24:29.538]             `<<-` <- base::`<<-`
[13:24:29.538]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:29.538]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:29.538]                   3L)]
[13:24:29.538]             }
[13:24:29.538]             function(cond) {
[13:24:29.538]                 is_error <- inherits(cond, "error")
[13:24:29.538]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:29.538]                   NULL)
[13:24:29.538]                 if (is_error) {
[13:24:29.538]                   sessionInformation <- function() {
[13:24:29.538]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:29.538]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:29.538]                       search = base::search(), system = base::Sys.info())
[13:24:29.538]                   }
[13:24:29.538]                   ...future.conditions[[length(...future.conditions) + 
[13:24:29.538]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:29.538]                     cond$call), session = sessionInformation(), 
[13:24:29.538]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:29.538]                   signalCondition(cond)
[13:24:29.538]                 }
[13:24:29.538]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:29.538]                 "immediateCondition"))) {
[13:24:29.538]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:29.538]                   ...future.conditions[[length(...future.conditions) + 
[13:24:29.538]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:29.538]                   if (TRUE && !signal) {
[13:24:29.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.538]                     {
[13:24:29.538]                       inherits <- base::inherits
[13:24:29.538]                       invokeRestart <- base::invokeRestart
[13:24:29.538]                       is.null <- base::is.null
[13:24:29.538]                       muffled <- FALSE
[13:24:29.538]                       if (inherits(cond, "message")) {
[13:24:29.538]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:29.538]                         if (muffled) 
[13:24:29.538]                           invokeRestart("muffleMessage")
[13:24:29.538]                       }
[13:24:29.538]                       else if (inherits(cond, "warning")) {
[13:24:29.538]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:29.538]                         if (muffled) 
[13:24:29.538]                           invokeRestart("muffleWarning")
[13:24:29.538]                       }
[13:24:29.538]                       else if (inherits(cond, "condition")) {
[13:24:29.538]                         if (!is.null(pattern)) {
[13:24:29.538]                           computeRestarts <- base::computeRestarts
[13:24:29.538]                           grepl <- base::grepl
[13:24:29.538]                           restarts <- computeRestarts(cond)
[13:24:29.538]                           for (restart in restarts) {
[13:24:29.538]                             name <- restart$name
[13:24:29.538]                             if (is.null(name)) 
[13:24:29.538]                               next
[13:24:29.538]                             if (!grepl(pattern, name)) 
[13:24:29.538]                               next
[13:24:29.538]                             invokeRestart(restart)
[13:24:29.538]                             muffled <- TRUE
[13:24:29.538]                             break
[13:24:29.538]                           }
[13:24:29.538]                         }
[13:24:29.538]                       }
[13:24:29.538]                       invisible(muffled)
[13:24:29.538]                     }
[13:24:29.538]                     muffleCondition(cond, pattern = "^muffle")
[13:24:29.538]                   }
[13:24:29.538]                 }
[13:24:29.538]                 else {
[13:24:29.538]                   if (TRUE) {
[13:24:29.538]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.538]                     {
[13:24:29.538]                       inherits <- base::inherits
[13:24:29.538]                       invokeRestart <- base::invokeRestart
[13:24:29.538]                       is.null <- base::is.null
[13:24:29.538]                       muffled <- FALSE
[13:24:29.538]                       if (inherits(cond, "message")) {
[13:24:29.538]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:29.538]                         if (muffled) 
[13:24:29.538]                           invokeRestart("muffleMessage")
[13:24:29.538]                       }
[13:24:29.538]                       else if (inherits(cond, "warning")) {
[13:24:29.538]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:29.538]                         if (muffled) 
[13:24:29.538]                           invokeRestart("muffleWarning")
[13:24:29.538]                       }
[13:24:29.538]                       else if (inherits(cond, "condition")) {
[13:24:29.538]                         if (!is.null(pattern)) {
[13:24:29.538]                           computeRestarts <- base::computeRestarts
[13:24:29.538]                           grepl <- base::grepl
[13:24:29.538]                           restarts <- computeRestarts(cond)
[13:24:29.538]                           for (restart in restarts) {
[13:24:29.538]                             name <- restart$name
[13:24:29.538]                             if (is.null(name)) 
[13:24:29.538]                               next
[13:24:29.538]                             if (!grepl(pattern, name)) 
[13:24:29.538]                               next
[13:24:29.538]                             invokeRestart(restart)
[13:24:29.538]                             muffled <- TRUE
[13:24:29.538]                             break
[13:24:29.538]                           }
[13:24:29.538]                         }
[13:24:29.538]                       }
[13:24:29.538]                       invisible(muffled)
[13:24:29.538]                     }
[13:24:29.538]                     muffleCondition(cond, pattern = "^muffle")
[13:24:29.538]                   }
[13:24:29.538]                 }
[13:24:29.538]             }
[13:24:29.538]         }))
[13:24:29.538]     }, error = function(ex) {
[13:24:29.538]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:29.538]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:29.538]                 ...future.rng), started = ...future.startTime, 
[13:24:29.538]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:29.538]             version = "1.8"), class = "FutureResult")
[13:24:29.538]     }, finally = {
[13:24:29.538]         if (!identical(...future.workdir, getwd())) 
[13:24:29.538]             setwd(...future.workdir)
[13:24:29.538]         {
[13:24:29.538]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:29.538]                 ...future.oldOptions$nwarnings <- NULL
[13:24:29.538]             }
[13:24:29.538]             base::options(...future.oldOptions)
[13:24:29.538]             if (.Platform$OS.type == "windows") {
[13:24:29.538]                 old_names <- names(...future.oldEnvVars)
[13:24:29.538]                 envs <- base::Sys.getenv()
[13:24:29.538]                 names <- names(envs)
[13:24:29.538]                 common <- intersect(names, old_names)
[13:24:29.538]                 added <- setdiff(names, old_names)
[13:24:29.538]                 removed <- setdiff(old_names, names)
[13:24:29.538]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:29.538]                   envs[common]]
[13:24:29.538]                 NAMES <- toupper(changed)
[13:24:29.538]                 args <- list()
[13:24:29.538]                 for (kk in seq_along(NAMES)) {
[13:24:29.538]                   name <- changed[[kk]]
[13:24:29.538]                   NAME <- NAMES[[kk]]
[13:24:29.538]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.538]                     next
[13:24:29.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:29.538]                 }
[13:24:29.538]                 NAMES <- toupper(added)
[13:24:29.538]                 for (kk in seq_along(NAMES)) {
[13:24:29.538]                   name <- added[[kk]]
[13:24:29.538]                   NAME <- NAMES[[kk]]
[13:24:29.538]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.538]                     next
[13:24:29.538]                   args[[name]] <- ""
[13:24:29.538]                 }
[13:24:29.538]                 NAMES <- toupper(removed)
[13:24:29.538]                 for (kk in seq_along(NAMES)) {
[13:24:29.538]                   name <- removed[[kk]]
[13:24:29.538]                   NAME <- NAMES[[kk]]
[13:24:29.538]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.538]                     next
[13:24:29.538]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:29.538]                 }
[13:24:29.538]                 if (length(args) > 0) 
[13:24:29.538]                   base::do.call(base::Sys.setenv, args = args)
[13:24:29.538]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:29.538]             }
[13:24:29.538]             else {
[13:24:29.538]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:29.538]             }
[13:24:29.538]             {
[13:24:29.538]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:29.538]                   0L) {
[13:24:29.538]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:29.538]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:29.538]                   base::options(opts)
[13:24:29.538]                 }
[13:24:29.538]                 {
[13:24:29.538]                   {
[13:24:29.538]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:29.538]                     NULL
[13:24:29.538]                   }
[13:24:29.538]                   options(future.plan = NULL)
[13:24:29.538]                   if (is.na(NA_character_)) 
[13:24:29.538]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:29.538]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:29.538]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:29.538]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:29.538]                     envir = parent.frame()) 
[13:24:29.538]                   {
[13:24:29.538]                     if (is.function(workers)) 
[13:24:29.538]                       workers <- workers()
[13:24:29.538]                     workers <- structure(as.integer(workers), 
[13:24:29.538]                       class = class(workers))
[13:24:29.538]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:29.538]                       workers >= 1)
[13:24:29.538]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:29.538]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:29.538]                     }
[13:24:29.538]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:29.538]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:29.538]                       envir = envir)
[13:24:29.538]                     if (!future$lazy) 
[13:24:29.538]                       future <- run(future)
[13:24:29.538]                     invisible(future)
[13:24:29.538]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:29.538]                 }
[13:24:29.538]             }
[13:24:29.538]         }
[13:24:29.538]     })
[13:24:29.538]     if (TRUE) {
[13:24:29.538]         base::sink(type = "output", split = FALSE)
[13:24:29.538]         if (TRUE) {
[13:24:29.538]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:29.538]         }
[13:24:29.538]         else {
[13:24:29.538]             ...future.result["stdout"] <- base::list(NULL)
[13:24:29.538]         }
[13:24:29.538]         base::close(...future.stdout)
[13:24:29.538]         ...future.stdout <- NULL
[13:24:29.538]     }
[13:24:29.538]     ...future.result$conditions <- ...future.conditions
[13:24:29.538]     ...future.result$finished <- base::Sys.time()
[13:24:29.538]     ...future.result
[13:24:29.538] }
[13:24:29.542] MultisessionFuture started
[13:24:29.542] - Launch lazy future ... done
[13:24:29.542] run() for ‘MultisessionFuture’ ... done
[13:24:29.589] receiveMessageFromWorker() for ClusterFuture ...
[13:24:29.589] - Validating connection of MultisessionFuture
[13:24:29.590] - received message: FutureResult
[13:24:29.590] - Received FutureResult
[13:24:29.590] - Erased future from FutureRegistry
[13:24:29.590] result() for ClusterFuture ...
[13:24:29.590] - result already collected: FutureResult
[13:24:29.590] result() for ClusterFuture ... done
[13:24:29.591] signalConditions() ...
[13:24:29.591]  - include = ‘immediateCondition’
[13:24:29.591]  - exclude = 
[13:24:29.591]  - resignal = FALSE
[13:24:29.591]  - Number of conditions: 1
[13:24:29.591] signalConditions() ... done
[13:24:29.591] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:29.591] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[13:24:29.591] getGlobalsAndPackages() ...
[13:24:29.592] Searching for globals...
[13:24:29.593] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:29.593] Searching for globals ... DONE
[13:24:29.593] Resolving globals: FALSE
[13:24:29.593] 
[13:24:29.593] 
[13:24:29.593] getGlobalsAndPackages() ... DONE
[13:24:29.594] run() for ‘Future’ ...
[13:24:29.594] - state: ‘created’
[13:24:29.594] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:29.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:29.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:29.609]   - Field: ‘node’
[13:24:29.610]   - Field: ‘label’
[13:24:29.610]   - Field: ‘local’
[13:24:29.610]   - Field: ‘owner’
[13:24:29.610]   - Field: ‘envir’
[13:24:29.610]   - Field: ‘workers’
[13:24:29.610]   - Field: ‘packages’
[13:24:29.610]   - Field: ‘gc’
[13:24:29.610]   - Field: ‘conditions’
[13:24:29.610]   - Field: ‘persistent’
[13:24:29.610]   - Field: ‘expr’
[13:24:29.611]   - Field: ‘uuid’
[13:24:29.611]   - Field: ‘seed’
[13:24:29.611]   - Field: ‘version’
[13:24:29.611]   - Field: ‘result’
[13:24:29.611]   - Field: ‘asynchronous’
[13:24:29.611]   - Field: ‘calls’
[13:24:29.611]   - Field: ‘globals’
[13:24:29.611]   - Field: ‘stdout’
[13:24:29.611]   - Field: ‘earlySignal’
[13:24:29.611]   - Field: ‘lazy’
[13:24:29.611]   - Field: ‘state’
[13:24:29.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:29.612] - Launch lazy future ...
[13:24:29.612] Packages needed by the future expression (n = 0): <none>
[13:24:29.612] Packages needed by future strategies (n = 0): <none>
[13:24:29.613] {
[13:24:29.613]     {
[13:24:29.613]         {
[13:24:29.613]             ...future.startTime <- base::Sys.time()
[13:24:29.613]             {
[13:24:29.613]                 {
[13:24:29.613]                   {
[13:24:29.613]                     {
[13:24:29.613]                       base::local({
[13:24:29.613]                         has_future <- base::requireNamespace("future", 
[13:24:29.613]                           quietly = TRUE)
[13:24:29.613]                         if (has_future) {
[13:24:29.613]                           ns <- base::getNamespace("future")
[13:24:29.613]                           version <- ns[[".package"]][["version"]]
[13:24:29.613]                           if (is.null(version)) 
[13:24:29.613]                             version <- utils::packageVersion("future")
[13:24:29.613]                         }
[13:24:29.613]                         else {
[13:24:29.613]                           version <- NULL
[13:24:29.613]                         }
[13:24:29.613]                         if (!has_future || version < "1.8.0") {
[13:24:29.613]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:29.613]                             "", base::R.version$version.string), 
[13:24:29.613]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:29.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:29.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:29.613]                               "release", "version")], collapse = " "), 
[13:24:29.613]                             hostname = base::Sys.info()[["nodename"]])
[13:24:29.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:29.613]                             info)
[13:24:29.613]                           info <- base::paste(info, collapse = "; ")
[13:24:29.613]                           if (!has_future) {
[13:24:29.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:29.613]                               info)
[13:24:29.613]                           }
[13:24:29.613]                           else {
[13:24:29.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:29.613]                               info, version)
[13:24:29.613]                           }
[13:24:29.613]                           base::stop(msg)
[13:24:29.613]                         }
[13:24:29.613]                       })
[13:24:29.613]                     }
[13:24:29.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:29.613]                     base::options(mc.cores = 1L)
[13:24:29.613]                   }
[13:24:29.613]                   options(future.plan = NULL)
[13:24:29.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:29.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:29.613]                 }
[13:24:29.613]                 ...future.workdir <- getwd()
[13:24:29.613]             }
[13:24:29.613]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:29.613]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:29.613]         }
[13:24:29.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:29.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:29.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:29.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:29.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:29.613]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:29.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:29.613]             base::names(...future.oldOptions))
[13:24:29.613]     }
[13:24:29.613]     if (FALSE) {
[13:24:29.613]     }
[13:24:29.613]     else {
[13:24:29.613]         if (TRUE) {
[13:24:29.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:29.613]                 open = "w")
[13:24:29.613]         }
[13:24:29.613]         else {
[13:24:29.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:29.613]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:29.613]         }
[13:24:29.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:29.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:29.613]             base::sink(type = "output", split = FALSE)
[13:24:29.613]             base::close(...future.stdout)
[13:24:29.613]         }, add = TRUE)
[13:24:29.613]     }
[13:24:29.613]     ...future.frame <- base::sys.nframe()
[13:24:29.613]     ...future.conditions <- base::list()
[13:24:29.613]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:29.613]     if (FALSE) {
[13:24:29.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:29.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:29.613]     }
[13:24:29.613]     ...future.result <- base::tryCatch({
[13:24:29.613]         base::withCallingHandlers({
[13:24:29.613]             ...future.value <- base::withVisible(base::local({
[13:24:29.613]                 ...future.makeSendCondition <- base::local({
[13:24:29.613]                   sendCondition <- NULL
[13:24:29.613]                   function(frame = 1L) {
[13:24:29.613]                     if (is.function(sendCondition)) 
[13:24:29.613]                       return(sendCondition)
[13:24:29.613]                     ns <- getNamespace("parallel")
[13:24:29.613]                     if (exists("sendData", mode = "function", 
[13:24:29.613]                       envir = ns)) {
[13:24:29.613]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:29.613]                         envir = ns)
[13:24:29.613]                       envir <- sys.frame(frame)
[13:24:29.613]                       master <- NULL
[13:24:29.613]                       while (!identical(envir, .GlobalEnv) && 
[13:24:29.613]                         !identical(envir, emptyenv())) {
[13:24:29.613]                         if (exists("master", mode = "list", envir = envir, 
[13:24:29.613]                           inherits = FALSE)) {
[13:24:29.613]                           master <- get("master", mode = "list", 
[13:24:29.613]                             envir = envir, inherits = FALSE)
[13:24:29.613]                           if (inherits(master, c("SOCKnode", 
[13:24:29.613]                             "SOCK0node"))) {
[13:24:29.613]                             sendCondition <<- function(cond) {
[13:24:29.613]                               data <- list(type = "VALUE", value = cond, 
[13:24:29.613]                                 success = TRUE)
[13:24:29.613]                               parallel_sendData(master, data)
[13:24:29.613]                             }
[13:24:29.613]                             return(sendCondition)
[13:24:29.613]                           }
[13:24:29.613]                         }
[13:24:29.613]                         frame <- frame + 1L
[13:24:29.613]                         envir <- sys.frame(frame)
[13:24:29.613]                       }
[13:24:29.613]                     }
[13:24:29.613]                     sendCondition <<- function(cond) NULL
[13:24:29.613]                   }
[13:24:29.613]                 })
[13:24:29.613]                 withCallingHandlers({
[13:24:29.613]                   {
[13:24:29.613]                     Sys.sleep(0.5)
[13:24:29.613]                     list(a = 1, b = 42L)
[13:24:29.613]                   }
[13:24:29.613]                 }, immediateCondition = function(cond) {
[13:24:29.613]                   sendCondition <- ...future.makeSendCondition()
[13:24:29.613]                   sendCondition(cond)
[13:24:29.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.613]                   {
[13:24:29.613]                     inherits <- base::inherits
[13:24:29.613]                     invokeRestart <- base::invokeRestart
[13:24:29.613]                     is.null <- base::is.null
[13:24:29.613]                     muffled <- FALSE
[13:24:29.613]                     if (inherits(cond, "message")) {
[13:24:29.613]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:29.613]                       if (muffled) 
[13:24:29.613]                         invokeRestart("muffleMessage")
[13:24:29.613]                     }
[13:24:29.613]                     else if (inherits(cond, "warning")) {
[13:24:29.613]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:29.613]                       if (muffled) 
[13:24:29.613]                         invokeRestart("muffleWarning")
[13:24:29.613]                     }
[13:24:29.613]                     else if (inherits(cond, "condition")) {
[13:24:29.613]                       if (!is.null(pattern)) {
[13:24:29.613]                         computeRestarts <- base::computeRestarts
[13:24:29.613]                         grepl <- base::grepl
[13:24:29.613]                         restarts <- computeRestarts(cond)
[13:24:29.613]                         for (restart in restarts) {
[13:24:29.613]                           name <- restart$name
[13:24:29.613]                           if (is.null(name)) 
[13:24:29.613]                             next
[13:24:29.613]                           if (!grepl(pattern, name)) 
[13:24:29.613]                             next
[13:24:29.613]                           invokeRestart(restart)
[13:24:29.613]                           muffled <- TRUE
[13:24:29.613]                           break
[13:24:29.613]                         }
[13:24:29.613]                       }
[13:24:29.613]                     }
[13:24:29.613]                     invisible(muffled)
[13:24:29.613]                   }
[13:24:29.613]                   muffleCondition(cond)
[13:24:29.613]                 })
[13:24:29.613]             }))
[13:24:29.613]             future::FutureResult(value = ...future.value$value, 
[13:24:29.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:29.613]                   ...future.rng), globalenv = if (FALSE) 
[13:24:29.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:29.613]                     ...future.globalenv.names))
[13:24:29.613]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:29.613]         }, condition = base::local({
[13:24:29.613]             c <- base::c
[13:24:29.613]             inherits <- base::inherits
[13:24:29.613]             invokeRestart <- base::invokeRestart
[13:24:29.613]             length <- base::length
[13:24:29.613]             list <- base::list
[13:24:29.613]             seq.int <- base::seq.int
[13:24:29.613]             signalCondition <- base::signalCondition
[13:24:29.613]             sys.calls <- base::sys.calls
[13:24:29.613]             `[[` <- base::`[[`
[13:24:29.613]             `+` <- base::`+`
[13:24:29.613]             `<<-` <- base::`<<-`
[13:24:29.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:29.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:29.613]                   3L)]
[13:24:29.613]             }
[13:24:29.613]             function(cond) {
[13:24:29.613]                 is_error <- inherits(cond, "error")
[13:24:29.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:29.613]                   NULL)
[13:24:29.613]                 if (is_error) {
[13:24:29.613]                   sessionInformation <- function() {
[13:24:29.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:29.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:29.613]                       search = base::search(), system = base::Sys.info())
[13:24:29.613]                   }
[13:24:29.613]                   ...future.conditions[[length(...future.conditions) + 
[13:24:29.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:29.613]                     cond$call), session = sessionInformation(), 
[13:24:29.613]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:29.613]                   signalCondition(cond)
[13:24:29.613]                 }
[13:24:29.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:29.613]                 "immediateCondition"))) {
[13:24:29.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:29.613]                   ...future.conditions[[length(...future.conditions) + 
[13:24:29.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:29.613]                   if (TRUE && !signal) {
[13:24:29.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.613]                     {
[13:24:29.613]                       inherits <- base::inherits
[13:24:29.613]                       invokeRestart <- base::invokeRestart
[13:24:29.613]                       is.null <- base::is.null
[13:24:29.613]                       muffled <- FALSE
[13:24:29.613]                       if (inherits(cond, "message")) {
[13:24:29.613]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:29.613]                         if (muffled) 
[13:24:29.613]                           invokeRestart("muffleMessage")
[13:24:29.613]                       }
[13:24:29.613]                       else if (inherits(cond, "warning")) {
[13:24:29.613]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:29.613]                         if (muffled) 
[13:24:29.613]                           invokeRestart("muffleWarning")
[13:24:29.613]                       }
[13:24:29.613]                       else if (inherits(cond, "condition")) {
[13:24:29.613]                         if (!is.null(pattern)) {
[13:24:29.613]                           computeRestarts <- base::computeRestarts
[13:24:29.613]                           grepl <- base::grepl
[13:24:29.613]                           restarts <- computeRestarts(cond)
[13:24:29.613]                           for (restart in restarts) {
[13:24:29.613]                             name <- restart$name
[13:24:29.613]                             if (is.null(name)) 
[13:24:29.613]                               next
[13:24:29.613]                             if (!grepl(pattern, name)) 
[13:24:29.613]                               next
[13:24:29.613]                             invokeRestart(restart)
[13:24:29.613]                             muffled <- TRUE
[13:24:29.613]                             break
[13:24:29.613]                           }
[13:24:29.613]                         }
[13:24:29.613]                       }
[13:24:29.613]                       invisible(muffled)
[13:24:29.613]                     }
[13:24:29.613]                     muffleCondition(cond, pattern = "^muffle")
[13:24:29.613]                   }
[13:24:29.613]                 }
[13:24:29.613]                 else {
[13:24:29.613]                   if (TRUE) {
[13:24:29.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:29.613]                     {
[13:24:29.613]                       inherits <- base::inherits
[13:24:29.613]                       invokeRestart <- base::invokeRestart
[13:24:29.613]                       is.null <- base::is.null
[13:24:29.613]                       muffled <- FALSE
[13:24:29.613]                       if (inherits(cond, "message")) {
[13:24:29.613]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:29.613]                         if (muffled) 
[13:24:29.613]                           invokeRestart("muffleMessage")
[13:24:29.613]                       }
[13:24:29.613]                       else if (inherits(cond, "warning")) {
[13:24:29.613]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:29.613]                         if (muffled) 
[13:24:29.613]                           invokeRestart("muffleWarning")
[13:24:29.613]                       }
[13:24:29.613]                       else if (inherits(cond, "condition")) {
[13:24:29.613]                         if (!is.null(pattern)) {
[13:24:29.613]                           computeRestarts <- base::computeRestarts
[13:24:29.613]                           grepl <- base::grepl
[13:24:29.613]                           restarts <- computeRestarts(cond)
[13:24:29.613]                           for (restart in restarts) {
[13:24:29.613]                             name <- restart$name
[13:24:29.613]                             if (is.null(name)) 
[13:24:29.613]                               next
[13:24:29.613]                             if (!grepl(pattern, name)) 
[13:24:29.613]                               next
[13:24:29.613]                             invokeRestart(restart)
[13:24:29.613]                             muffled <- TRUE
[13:24:29.613]                             break
[13:24:29.613]                           }
[13:24:29.613]                         }
[13:24:29.613]                       }
[13:24:29.613]                       invisible(muffled)
[13:24:29.613]                     }
[13:24:29.613]                     muffleCondition(cond, pattern = "^muffle")
[13:24:29.613]                   }
[13:24:29.613]                 }
[13:24:29.613]             }
[13:24:29.613]         }))
[13:24:29.613]     }, error = function(ex) {
[13:24:29.613]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:29.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:29.613]                 ...future.rng), started = ...future.startTime, 
[13:24:29.613]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:29.613]             version = "1.8"), class = "FutureResult")
[13:24:29.613]     }, finally = {
[13:24:29.613]         if (!identical(...future.workdir, getwd())) 
[13:24:29.613]             setwd(...future.workdir)
[13:24:29.613]         {
[13:24:29.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:29.613]                 ...future.oldOptions$nwarnings <- NULL
[13:24:29.613]             }
[13:24:29.613]             base::options(...future.oldOptions)
[13:24:29.613]             if (.Platform$OS.type == "windows") {
[13:24:29.613]                 old_names <- names(...future.oldEnvVars)
[13:24:29.613]                 envs <- base::Sys.getenv()
[13:24:29.613]                 names <- names(envs)
[13:24:29.613]                 common <- intersect(names, old_names)
[13:24:29.613]                 added <- setdiff(names, old_names)
[13:24:29.613]                 removed <- setdiff(old_names, names)
[13:24:29.613]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:29.613]                   envs[common]]
[13:24:29.613]                 NAMES <- toupper(changed)
[13:24:29.613]                 args <- list()
[13:24:29.613]                 for (kk in seq_along(NAMES)) {
[13:24:29.613]                   name <- changed[[kk]]
[13:24:29.613]                   NAME <- NAMES[[kk]]
[13:24:29.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.613]                     next
[13:24:29.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:29.613]                 }
[13:24:29.613]                 NAMES <- toupper(added)
[13:24:29.613]                 for (kk in seq_along(NAMES)) {
[13:24:29.613]                   name <- added[[kk]]
[13:24:29.613]                   NAME <- NAMES[[kk]]
[13:24:29.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.613]                     next
[13:24:29.613]                   args[[name]] <- ""
[13:24:29.613]                 }
[13:24:29.613]                 NAMES <- toupper(removed)
[13:24:29.613]                 for (kk in seq_along(NAMES)) {
[13:24:29.613]                   name <- removed[[kk]]
[13:24:29.613]                   NAME <- NAMES[[kk]]
[13:24:29.613]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:29.613]                     next
[13:24:29.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:29.613]                 }
[13:24:29.613]                 if (length(args) > 0) 
[13:24:29.613]                   base::do.call(base::Sys.setenv, args = args)
[13:24:29.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:29.613]             }
[13:24:29.613]             else {
[13:24:29.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:29.613]             }
[13:24:29.613]             {
[13:24:29.613]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:29.613]                   0L) {
[13:24:29.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:29.613]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:29.613]                   base::options(opts)
[13:24:29.613]                 }
[13:24:29.613]                 {
[13:24:29.613]                   {
[13:24:29.613]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:29.613]                     NULL
[13:24:29.613]                   }
[13:24:29.613]                   options(future.plan = NULL)
[13:24:29.613]                   if (is.na(NA_character_)) 
[13:24:29.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:29.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:29.613]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:29.613]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:29.613]                     envir = parent.frame()) 
[13:24:29.613]                   {
[13:24:29.613]                     if (is.function(workers)) 
[13:24:29.613]                       workers <- workers()
[13:24:29.613]                     workers <- structure(as.integer(workers), 
[13:24:29.613]                       class = class(workers))
[13:24:29.613]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:29.613]                       workers >= 1)
[13:24:29.613]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:29.613]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:29.613]                     }
[13:24:29.613]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:29.613]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:29.613]                       envir = envir)
[13:24:29.613]                     if (!future$lazy) 
[13:24:29.613]                       future <- run(future)
[13:24:29.613]                     invisible(future)
[13:24:29.613]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:29.613]                 }
[13:24:29.613]             }
[13:24:29.613]         }
[13:24:29.613]     })
[13:24:29.613]     if (TRUE) {
[13:24:29.613]         base::sink(type = "output", split = FALSE)
[13:24:29.613]         if (TRUE) {
[13:24:29.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:29.613]         }
[13:24:29.613]         else {
[13:24:29.613]             ...future.result["stdout"] <- base::list(NULL)
[13:24:29.613]         }
[13:24:29.613]         base::close(...future.stdout)
[13:24:29.613]         ...future.stdout <- NULL
[13:24:29.613]     }
[13:24:29.613]     ...future.result$conditions <- ...future.conditions
[13:24:29.613]     ...future.result$finished <- base::Sys.time()
[13:24:29.613]     ...future.result
[13:24:29.613] }
[13:24:29.616] MultisessionFuture started
[13:24:29.616] - Launch lazy future ... done
[13:24:29.616] run() for ‘MultisessionFuture’ ... done
[13:24:30.162] receiveMessageFromWorker() for ClusterFuture ...
[13:24:30.162] - Validating connection of MultisessionFuture
[13:24:30.163] - received message: FutureResult
[13:24:30.163] - Received FutureResult
[13:24:30.163] - Erased future from FutureRegistry
[13:24:30.163] result() for ClusterFuture ...
[13:24:30.163] - result already collected: FutureResult
[13:24:30.163] result() for ClusterFuture ... done
[13:24:30.163] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:30.163] A MultisessionFuture was resolved (result was not collected)
[13:24:30.164] getGlobalsAndPackages() ...
[13:24:30.164] Searching for globals...
[13:24:30.165] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:30.165] Searching for globals ... DONE
[13:24:30.165] Resolving globals: FALSE
[13:24:30.166] 
[13:24:30.166] 
[13:24:30.166] getGlobalsAndPackages() ... DONE
[13:24:30.166] run() for ‘Future’ ...
[13:24:30.166] - state: ‘created’
[13:24:30.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:30.180] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:30.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:30.180]   - Field: ‘node’
[13:24:30.181]   - Field: ‘label’
[13:24:30.181]   - Field: ‘local’
[13:24:30.181]   - Field: ‘owner’
[13:24:30.181]   - Field: ‘envir’
[13:24:30.181]   - Field: ‘workers’
[13:24:30.181]   - Field: ‘packages’
[13:24:30.181]   - Field: ‘gc’
[13:24:30.181]   - Field: ‘conditions’
[13:24:30.181]   - Field: ‘persistent’
[13:24:30.181]   - Field: ‘expr’
[13:24:30.181]   - Field: ‘uuid’
[13:24:30.182]   - Field: ‘seed’
[13:24:30.182]   - Field: ‘version’
[13:24:30.182]   - Field: ‘result’
[13:24:30.182]   - Field: ‘asynchronous’
[13:24:30.182]   - Field: ‘calls’
[13:24:30.182]   - Field: ‘globals’
[13:24:30.182]   - Field: ‘stdout’
[13:24:30.182]   - Field: ‘earlySignal’
[13:24:30.182]   - Field: ‘lazy’
[13:24:30.182]   - Field: ‘state’
[13:24:30.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:30.183] - Launch lazy future ...
[13:24:30.183] Packages needed by the future expression (n = 0): <none>
[13:24:30.183] Packages needed by future strategies (n = 0): <none>
[13:24:30.183] {
[13:24:30.183]     {
[13:24:30.183]         {
[13:24:30.183]             ...future.startTime <- base::Sys.time()
[13:24:30.183]             {
[13:24:30.183]                 {
[13:24:30.183]                   {
[13:24:30.183]                     {
[13:24:30.183]                       base::local({
[13:24:30.183]                         has_future <- base::requireNamespace("future", 
[13:24:30.183]                           quietly = TRUE)
[13:24:30.183]                         if (has_future) {
[13:24:30.183]                           ns <- base::getNamespace("future")
[13:24:30.183]                           version <- ns[[".package"]][["version"]]
[13:24:30.183]                           if (is.null(version)) 
[13:24:30.183]                             version <- utils::packageVersion("future")
[13:24:30.183]                         }
[13:24:30.183]                         else {
[13:24:30.183]                           version <- NULL
[13:24:30.183]                         }
[13:24:30.183]                         if (!has_future || version < "1.8.0") {
[13:24:30.183]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:30.183]                             "", base::R.version$version.string), 
[13:24:30.183]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:30.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:30.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:30.183]                               "release", "version")], collapse = " "), 
[13:24:30.183]                             hostname = base::Sys.info()[["nodename"]])
[13:24:30.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:30.183]                             info)
[13:24:30.183]                           info <- base::paste(info, collapse = "; ")
[13:24:30.183]                           if (!has_future) {
[13:24:30.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:30.183]                               info)
[13:24:30.183]                           }
[13:24:30.183]                           else {
[13:24:30.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:30.183]                               info, version)
[13:24:30.183]                           }
[13:24:30.183]                           base::stop(msg)
[13:24:30.183]                         }
[13:24:30.183]                       })
[13:24:30.183]                     }
[13:24:30.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:30.183]                     base::options(mc.cores = 1L)
[13:24:30.183]                   }
[13:24:30.183]                   options(future.plan = NULL)
[13:24:30.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:30.183]                 }
[13:24:30.183]                 ...future.workdir <- getwd()
[13:24:30.183]             }
[13:24:30.183]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:30.183]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:30.183]         }
[13:24:30.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:30.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:30.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:30.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:30.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:30.183]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:30.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:30.183]             base::names(...future.oldOptions))
[13:24:30.183]     }
[13:24:30.183]     if (FALSE) {
[13:24:30.183]     }
[13:24:30.183]     else {
[13:24:30.183]         if (TRUE) {
[13:24:30.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:30.183]                 open = "w")
[13:24:30.183]         }
[13:24:30.183]         else {
[13:24:30.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:30.183]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:30.183]         }
[13:24:30.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:30.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:30.183]             base::sink(type = "output", split = FALSE)
[13:24:30.183]             base::close(...future.stdout)
[13:24:30.183]         }, add = TRUE)
[13:24:30.183]     }
[13:24:30.183]     ...future.frame <- base::sys.nframe()
[13:24:30.183]     ...future.conditions <- base::list()
[13:24:30.183]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:30.183]     if (FALSE) {
[13:24:30.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:30.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:30.183]     }
[13:24:30.183]     ...future.result <- base::tryCatch({
[13:24:30.183]         base::withCallingHandlers({
[13:24:30.183]             ...future.value <- base::withVisible(base::local({
[13:24:30.183]                 ...future.makeSendCondition <- base::local({
[13:24:30.183]                   sendCondition <- NULL
[13:24:30.183]                   function(frame = 1L) {
[13:24:30.183]                     if (is.function(sendCondition)) 
[13:24:30.183]                       return(sendCondition)
[13:24:30.183]                     ns <- getNamespace("parallel")
[13:24:30.183]                     if (exists("sendData", mode = "function", 
[13:24:30.183]                       envir = ns)) {
[13:24:30.183]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:30.183]                         envir = ns)
[13:24:30.183]                       envir <- sys.frame(frame)
[13:24:30.183]                       master <- NULL
[13:24:30.183]                       while (!identical(envir, .GlobalEnv) && 
[13:24:30.183]                         !identical(envir, emptyenv())) {
[13:24:30.183]                         if (exists("master", mode = "list", envir = envir, 
[13:24:30.183]                           inherits = FALSE)) {
[13:24:30.183]                           master <- get("master", mode = "list", 
[13:24:30.183]                             envir = envir, inherits = FALSE)
[13:24:30.183]                           if (inherits(master, c("SOCKnode", 
[13:24:30.183]                             "SOCK0node"))) {
[13:24:30.183]                             sendCondition <<- function(cond) {
[13:24:30.183]                               data <- list(type = "VALUE", value = cond, 
[13:24:30.183]                                 success = TRUE)
[13:24:30.183]                               parallel_sendData(master, data)
[13:24:30.183]                             }
[13:24:30.183]                             return(sendCondition)
[13:24:30.183]                           }
[13:24:30.183]                         }
[13:24:30.183]                         frame <- frame + 1L
[13:24:30.183]                         envir <- sys.frame(frame)
[13:24:30.183]                       }
[13:24:30.183]                     }
[13:24:30.183]                     sendCondition <<- function(cond) NULL
[13:24:30.183]                   }
[13:24:30.183]                 })
[13:24:30.183]                 withCallingHandlers({
[13:24:30.183]                   {
[13:24:30.183]                     Sys.sleep(0.5)
[13:24:30.183]                     list(a = 1, b = 42L)
[13:24:30.183]                   }
[13:24:30.183]                 }, immediateCondition = function(cond) {
[13:24:30.183]                   sendCondition <- ...future.makeSendCondition()
[13:24:30.183]                   sendCondition(cond)
[13:24:30.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.183]                   {
[13:24:30.183]                     inherits <- base::inherits
[13:24:30.183]                     invokeRestart <- base::invokeRestart
[13:24:30.183]                     is.null <- base::is.null
[13:24:30.183]                     muffled <- FALSE
[13:24:30.183]                     if (inherits(cond, "message")) {
[13:24:30.183]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:30.183]                       if (muffled) 
[13:24:30.183]                         invokeRestart("muffleMessage")
[13:24:30.183]                     }
[13:24:30.183]                     else if (inherits(cond, "warning")) {
[13:24:30.183]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:30.183]                       if (muffled) 
[13:24:30.183]                         invokeRestart("muffleWarning")
[13:24:30.183]                     }
[13:24:30.183]                     else if (inherits(cond, "condition")) {
[13:24:30.183]                       if (!is.null(pattern)) {
[13:24:30.183]                         computeRestarts <- base::computeRestarts
[13:24:30.183]                         grepl <- base::grepl
[13:24:30.183]                         restarts <- computeRestarts(cond)
[13:24:30.183]                         for (restart in restarts) {
[13:24:30.183]                           name <- restart$name
[13:24:30.183]                           if (is.null(name)) 
[13:24:30.183]                             next
[13:24:30.183]                           if (!grepl(pattern, name)) 
[13:24:30.183]                             next
[13:24:30.183]                           invokeRestart(restart)
[13:24:30.183]                           muffled <- TRUE
[13:24:30.183]                           break
[13:24:30.183]                         }
[13:24:30.183]                       }
[13:24:30.183]                     }
[13:24:30.183]                     invisible(muffled)
[13:24:30.183]                   }
[13:24:30.183]                   muffleCondition(cond)
[13:24:30.183]                 })
[13:24:30.183]             }))
[13:24:30.183]             future::FutureResult(value = ...future.value$value, 
[13:24:30.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.183]                   ...future.rng), globalenv = if (FALSE) 
[13:24:30.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:30.183]                     ...future.globalenv.names))
[13:24:30.183]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:30.183]         }, condition = base::local({
[13:24:30.183]             c <- base::c
[13:24:30.183]             inherits <- base::inherits
[13:24:30.183]             invokeRestart <- base::invokeRestart
[13:24:30.183]             length <- base::length
[13:24:30.183]             list <- base::list
[13:24:30.183]             seq.int <- base::seq.int
[13:24:30.183]             signalCondition <- base::signalCondition
[13:24:30.183]             sys.calls <- base::sys.calls
[13:24:30.183]             `[[` <- base::`[[`
[13:24:30.183]             `+` <- base::`+`
[13:24:30.183]             `<<-` <- base::`<<-`
[13:24:30.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:30.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:30.183]                   3L)]
[13:24:30.183]             }
[13:24:30.183]             function(cond) {
[13:24:30.183]                 is_error <- inherits(cond, "error")
[13:24:30.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:30.183]                   NULL)
[13:24:30.183]                 if (is_error) {
[13:24:30.183]                   sessionInformation <- function() {
[13:24:30.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:30.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:30.183]                       search = base::search(), system = base::Sys.info())
[13:24:30.183]                   }
[13:24:30.183]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:30.183]                     cond$call), session = sessionInformation(), 
[13:24:30.183]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:30.183]                   signalCondition(cond)
[13:24:30.183]                 }
[13:24:30.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:30.183]                 "immediateCondition"))) {
[13:24:30.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:30.183]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:30.183]                   if (TRUE && !signal) {
[13:24:30.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.183]                     {
[13:24:30.183]                       inherits <- base::inherits
[13:24:30.183]                       invokeRestart <- base::invokeRestart
[13:24:30.183]                       is.null <- base::is.null
[13:24:30.183]                       muffled <- FALSE
[13:24:30.183]                       if (inherits(cond, "message")) {
[13:24:30.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.183]                         if (muffled) 
[13:24:30.183]                           invokeRestart("muffleMessage")
[13:24:30.183]                       }
[13:24:30.183]                       else if (inherits(cond, "warning")) {
[13:24:30.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.183]                         if (muffled) 
[13:24:30.183]                           invokeRestart("muffleWarning")
[13:24:30.183]                       }
[13:24:30.183]                       else if (inherits(cond, "condition")) {
[13:24:30.183]                         if (!is.null(pattern)) {
[13:24:30.183]                           computeRestarts <- base::computeRestarts
[13:24:30.183]                           grepl <- base::grepl
[13:24:30.183]                           restarts <- computeRestarts(cond)
[13:24:30.183]                           for (restart in restarts) {
[13:24:30.183]                             name <- restart$name
[13:24:30.183]                             if (is.null(name)) 
[13:24:30.183]                               next
[13:24:30.183]                             if (!grepl(pattern, name)) 
[13:24:30.183]                               next
[13:24:30.183]                             invokeRestart(restart)
[13:24:30.183]                             muffled <- TRUE
[13:24:30.183]                             break
[13:24:30.183]                           }
[13:24:30.183]                         }
[13:24:30.183]                       }
[13:24:30.183]                       invisible(muffled)
[13:24:30.183]                     }
[13:24:30.183]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.183]                   }
[13:24:30.183]                 }
[13:24:30.183]                 else {
[13:24:30.183]                   if (TRUE) {
[13:24:30.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.183]                     {
[13:24:30.183]                       inherits <- base::inherits
[13:24:30.183]                       invokeRestart <- base::invokeRestart
[13:24:30.183]                       is.null <- base::is.null
[13:24:30.183]                       muffled <- FALSE
[13:24:30.183]                       if (inherits(cond, "message")) {
[13:24:30.183]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.183]                         if (muffled) 
[13:24:30.183]                           invokeRestart("muffleMessage")
[13:24:30.183]                       }
[13:24:30.183]                       else if (inherits(cond, "warning")) {
[13:24:30.183]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.183]                         if (muffled) 
[13:24:30.183]                           invokeRestart("muffleWarning")
[13:24:30.183]                       }
[13:24:30.183]                       else if (inherits(cond, "condition")) {
[13:24:30.183]                         if (!is.null(pattern)) {
[13:24:30.183]                           computeRestarts <- base::computeRestarts
[13:24:30.183]                           grepl <- base::grepl
[13:24:30.183]                           restarts <- computeRestarts(cond)
[13:24:30.183]                           for (restart in restarts) {
[13:24:30.183]                             name <- restart$name
[13:24:30.183]                             if (is.null(name)) 
[13:24:30.183]                               next
[13:24:30.183]                             if (!grepl(pattern, name)) 
[13:24:30.183]                               next
[13:24:30.183]                             invokeRestart(restart)
[13:24:30.183]                             muffled <- TRUE
[13:24:30.183]                             break
[13:24:30.183]                           }
[13:24:30.183]                         }
[13:24:30.183]                       }
[13:24:30.183]                       invisible(muffled)
[13:24:30.183]                     }
[13:24:30.183]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.183]                   }
[13:24:30.183]                 }
[13:24:30.183]             }
[13:24:30.183]         }))
[13:24:30.183]     }, error = function(ex) {
[13:24:30.183]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:30.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.183]                 ...future.rng), started = ...future.startTime, 
[13:24:30.183]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:30.183]             version = "1.8"), class = "FutureResult")
[13:24:30.183]     }, finally = {
[13:24:30.183]         if (!identical(...future.workdir, getwd())) 
[13:24:30.183]             setwd(...future.workdir)
[13:24:30.183]         {
[13:24:30.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:30.183]                 ...future.oldOptions$nwarnings <- NULL
[13:24:30.183]             }
[13:24:30.183]             base::options(...future.oldOptions)
[13:24:30.183]             if (.Platform$OS.type == "windows") {
[13:24:30.183]                 old_names <- names(...future.oldEnvVars)
[13:24:30.183]                 envs <- base::Sys.getenv()
[13:24:30.183]                 names <- names(envs)
[13:24:30.183]                 common <- intersect(names, old_names)
[13:24:30.183]                 added <- setdiff(names, old_names)
[13:24:30.183]                 removed <- setdiff(old_names, names)
[13:24:30.183]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:30.183]                   envs[common]]
[13:24:30.183]                 NAMES <- toupper(changed)
[13:24:30.183]                 args <- list()
[13:24:30.183]                 for (kk in seq_along(NAMES)) {
[13:24:30.183]                   name <- changed[[kk]]
[13:24:30.183]                   NAME <- NAMES[[kk]]
[13:24:30.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.183]                     next
[13:24:30.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.183]                 }
[13:24:30.183]                 NAMES <- toupper(added)
[13:24:30.183]                 for (kk in seq_along(NAMES)) {
[13:24:30.183]                   name <- added[[kk]]
[13:24:30.183]                   NAME <- NAMES[[kk]]
[13:24:30.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.183]                     next
[13:24:30.183]                   args[[name]] <- ""
[13:24:30.183]                 }
[13:24:30.183]                 NAMES <- toupper(removed)
[13:24:30.183]                 for (kk in seq_along(NAMES)) {
[13:24:30.183]                   name <- removed[[kk]]
[13:24:30.183]                   NAME <- NAMES[[kk]]
[13:24:30.183]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.183]                     next
[13:24:30.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.183]                 }
[13:24:30.183]                 if (length(args) > 0) 
[13:24:30.183]                   base::do.call(base::Sys.setenv, args = args)
[13:24:30.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:30.183]             }
[13:24:30.183]             else {
[13:24:30.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:30.183]             }
[13:24:30.183]             {
[13:24:30.183]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:30.183]                   0L) {
[13:24:30.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:30.183]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:30.183]                   base::options(opts)
[13:24:30.183]                 }
[13:24:30.183]                 {
[13:24:30.183]                   {
[13:24:30.183]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:30.183]                     NULL
[13:24:30.183]                   }
[13:24:30.183]                   options(future.plan = NULL)
[13:24:30.183]                   if (is.na(NA_character_)) 
[13:24:30.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:30.183]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:30.183]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:30.183]                     envir = parent.frame()) 
[13:24:30.183]                   {
[13:24:30.183]                     if (is.function(workers)) 
[13:24:30.183]                       workers <- workers()
[13:24:30.183]                     workers <- structure(as.integer(workers), 
[13:24:30.183]                       class = class(workers))
[13:24:30.183]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:30.183]                       workers >= 1)
[13:24:30.183]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:30.183]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:30.183]                     }
[13:24:30.183]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:30.183]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:30.183]                       envir = envir)
[13:24:30.183]                     if (!future$lazy) 
[13:24:30.183]                       future <- run(future)
[13:24:30.183]                     invisible(future)
[13:24:30.183]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:30.183]                 }
[13:24:30.183]             }
[13:24:30.183]         }
[13:24:30.183]     })
[13:24:30.183]     if (TRUE) {
[13:24:30.183]         base::sink(type = "output", split = FALSE)
[13:24:30.183]         if (TRUE) {
[13:24:30.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:30.183]         }
[13:24:30.183]         else {
[13:24:30.183]             ...future.result["stdout"] <- base::list(NULL)
[13:24:30.183]         }
[13:24:30.183]         base::close(...future.stdout)
[13:24:30.183]         ...future.stdout <- NULL
[13:24:30.183]     }
[13:24:30.183]     ...future.result$conditions <- ...future.conditions
[13:24:30.183]     ...future.result$finished <- base::Sys.time()
[13:24:30.183]     ...future.result
[13:24:30.183] }
[13:24:30.187] MultisessionFuture started
[13:24:30.187] - Launch lazy future ... done
[13:24:30.187] run() for ‘MultisessionFuture’ ... done
[13:24:30.734] receiveMessageFromWorker() for ClusterFuture ...
[13:24:30.734] - Validating connection of MultisessionFuture
[13:24:30.734] - received message: FutureResult
[13:24:30.735] - Received FutureResult
[13:24:30.735] - Erased future from FutureRegistry
[13:24:30.735] result() for ClusterFuture ...
[13:24:30.735] - result already collected: FutureResult
[13:24:30.735] result() for ClusterFuture ... done
[13:24:30.735] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:30.735] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:24:30.735] getGlobalsAndPackages() ...
[13:24:30.735] Searching for globals...
[13:24:30.736] - globals found: [2] ‘list’, ‘stop’
[13:24:30.736] Searching for globals ... DONE
[13:24:30.736] Resolving globals: FALSE
[13:24:30.737] 
[13:24:30.737] 
[13:24:30.737] getGlobalsAndPackages() ... DONE
[13:24:30.737] run() for ‘Future’ ...
[13:24:30.737] - state: ‘created’
[13:24:30.737] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:30.751] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:30.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:30.751]   - Field: ‘node’
[13:24:30.752]   - Field: ‘label’
[13:24:30.752]   - Field: ‘local’
[13:24:30.752]   - Field: ‘owner’
[13:24:30.752]   - Field: ‘envir’
[13:24:30.752]   - Field: ‘workers’
[13:24:30.752]   - Field: ‘packages’
[13:24:30.752]   - Field: ‘gc’
[13:24:30.752]   - Field: ‘conditions’
[13:24:30.752]   - Field: ‘persistent’
[13:24:30.752]   - Field: ‘expr’
[13:24:30.753]   - Field: ‘uuid’
[13:24:30.753]   - Field: ‘seed’
[13:24:30.753]   - Field: ‘version’
[13:24:30.753]   - Field: ‘result’
[13:24:30.753]   - Field: ‘asynchronous’
[13:24:30.753]   - Field: ‘calls’
[13:24:30.753]   - Field: ‘globals’
[13:24:30.753]   - Field: ‘stdout’
[13:24:30.753]   - Field: ‘earlySignal’
[13:24:30.753]   - Field: ‘lazy’
[13:24:30.753]   - Field: ‘state’
[13:24:30.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:30.754] - Launch lazy future ...
[13:24:30.754] Packages needed by the future expression (n = 0): <none>
[13:24:30.754] Packages needed by future strategies (n = 0): <none>
[13:24:30.754] {
[13:24:30.754]     {
[13:24:30.754]         {
[13:24:30.754]             ...future.startTime <- base::Sys.time()
[13:24:30.754]             {
[13:24:30.754]                 {
[13:24:30.754]                   {
[13:24:30.754]                     {
[13:24:30.754]                       base::local({
[13:24:30.754]                         has_future <- base::requireNamespace("future", 
[13:24:30.754]                           quietly = TRUE)
[13:24:30.754]                         if (has_future) {
[13:24:30.754]                           ns <- base::getNamespace("future")
[13:24:30.754]                           version <- ns[[".package"]][["version"]]
[13:24:30.754]                           if (is.null(version)) 
[13:24:30.754]                             version <- utils::packageVersion("future")
[13:24:30.754]                         }
[13:24:30.754]                         else {
[13:24:30.754]                           version <- NULL
[13:24:30.754]                         }
[13:24:30.754]                         if (!has_future || version < "1.8.0") {
[13:24:30.754]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:30.754]                             "", base::R.version$version.string), 
[13:24:30.754]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:30.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:30.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:30.754]                               "release", "version")], collapse = " "), 
[13:24:30.754]                             hostname = base::Sys.info()[["nodename"]])
[13:24:30.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:30.754]                             info)
[13:24:30.754]                           info <- base::paste(info, collapse = "; ")
[13:24:30.754]                           if (!has_future) {
[13:24:30.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:30.754]                               info)
[13:24:30.754]                           }
[13:24:30.754]                           else {
[13:24:30.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:30.754]                               info, version)
[13:24:30.754]                           }
[13:24:30.754]                           base::stop(msg)
[13:24:30.754]                         }
[13:24:30.754]                       })
[13:24:30.754]                     }
[13:24:30.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:30.754]                     base::options(mc.cores = 1L)
[13:24:30.754]                   }
[13:24:30.754]                   options(future.plan = NULL)
[13:24:30.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:30.754]                 }
[13:24:30.754]                 ...future.workdir <- getwd()
[13:24:30.754]             }
[13:24:30.754]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:30.754]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:30.754]         }
[13:24:30.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:30.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:30.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:30.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:30.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:30.754]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:30.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:30.754]             base::names(...future.oldOptions))
[13:24:30.754]     }
[13:24:30.754]     if (FALSE) {
[13:24:30.754]     }
[13:24:30.754]     else {
[13:24:30.754]         if (TRUE) {
[13:24:30.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:30.754]                 open = "w")
[13:24:30.754]         }
[13:24:30.754]         else {
[13:24:30.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:30.754]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:30.754]         }
[13:24:30.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:30.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:30.754]             base::sink(type = "output", split = FALSE)
[13:24:30.754]             base::close(...future.stdout)
[13:24:30.754]         }, add = TRUE)
[13:24:30.754]     }
[13:24:30.754]     ...future.frame <- base::sys.nframe()
[13:24:30.754]     ...future.conditions <- base::list()
[13:24:30.754]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:30.754]     if (FALSE) {
[13:24:30.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:30.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:30.754]     }
[13:24:30.754]     ...future.result <- base::tryCatch({
[13:24:30.754]         base::withCallingHandlers({
[13:24:30.754]             ...future.value <- base::withVisible(base::local({
[13:24:30.754]                 ...future.makeSendCondition <- base::local({
[13:24:30.754]                   sendCondition <- NULL
[13:24:30.754]                   function(frame = 1L) {
[13:24:30.754]                     if (is.function(sendCondition)) 
[13:24:30.754]                       return(sendCondition)
[13:24:30.754]                     ns <- getNamespace("parallel")
[13:24:30.754]                     if (exists("sendData", mode = "function", 
[13:24:30.754]                       envir = ns)) {
[13:24:30.754]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:30.754]                         envir = ns)
[13:24:30.754]                       envir <- sys.frame(frame)
[13:24:30.754]                       master <- NULL
[13:24:30.754]                       while (!identical(envir, .GlobalEnv) && 
[13:24:30.754]                         !identical(envir, emptyenv())) {
[13:24:30.754]                         if (exists("master", mode = "list", envir = envir, 
[13:24:30.754]                           inherits = FALSE)) {
[13:24:30.754]                           master <- get("master", mode = "list", 
[13:24:30.754]                             envir = envir, inherits = FALSE)
[13:24:30.754]                           if (inherits(master, c("SOCKnode", 
[13:24:30.754]                             "SOCK0node"))) {
[13:24:30.754]                             sendCondition <<- function(cond) {
[13:24:30.754]                               data <- list(type = "VALUE", value = cond, 
[13:24:30.754]                                 success = TRUE)
[13:24:30.754]                               parallel_sendData(master, data)
[13:24:30.754]                             }
[13:24:30.754]                             return(sendCondition)
[13:24:30.754]                           }
[13:24:30.754]                         }
[13:24:30.754]                         frame <- frame + 1L
[13:24:30.754]                         envir <- sys.frame(frame)
[13:24:30.754]                       }
[13:24:30.754]                     }
[13:24:30.754]                     sendCondition <<- function(cond) NULL
[13:24:30.754]                   }
[13:24:30.754]                 })
[13:24:30.754]                 withCallingHandlers({
[13:24:30.754]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:30.754]                 }, immediateCondition = function(cond) {
[13:24:30.754]                   sendCondition <- ...future.makeSendCondition()
[13:24:30.754]                   sendCondition(cond)
[13:24:30.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.754]                   {
[13:24:30.754]                     inherits <- base::inherits
[13:24:30.754]                     invokeRestart <- base::invokeRestart
[13:24:30.754]                     is.null <- base::is.null
[13:24:30.754]                     muffled <- FALSE
[13:24:30.754]                     if (inherits(cond, "message")) {
[13:24:30.754]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:30.754]                       if (muffled) 
[13:24:30.754]                         invokeRestart("muffleMessage")
[13:24:30.754]                     }
[13:24:30.754]                     else if (inherits(cond, "warning")) {
[13:24:30.754]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:30.754]                       if (muffled) 
[13:24:30.754]                         invokeRestart("muffleWarning")
[13:24:30.754]                     }
[13:24:30.754]                     else if (inherits(cond, "condition")) {
[13:24:30.754]                       if (!is.null(pattern)) {
[13:24:30.754]                         computeRestarts <- base::computeRestarts
[13:24:30.754]                         grepl <- base::grepl
[13:24:30.754]                         restarts <- computeRestarts(cond)
[13:24:30.754]                         for (restart in restarts) {
[13:24:30.754]                           name <- restart$name
[13:24:30.754]                           if (is.null(name)) 
[13:24:30.754]                             next
[13:24:30.754]                           if (!grepl(pattern, name)) 
[13:24:30.754]                             next
[13:24:30.754]                           invokeRestart(restart)
[13:24:30.754]                           muffled <- TRUE
[13:24:30.754]                           break
[13:24:30.754]                         }
[13:24:30.754]                       }
[13:24:30.754]                     }
[13:24:30.754]                     invisible(muffled)
[13:24:30.754]                   }
[13:24:30.754]                   muffleCondition(cond)
[13:24:30.754]                 })
[13:24:30.754]             }))
[13:24:30.754]             future::FutureResult(value = ...future.value$value, 
[13:24:30.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.754]                   ...future.rng), globalenv = if (FALSE) 
[13:24:30.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:30.754]                     ...future.globalenv.names))
[13:24:30.754]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:30.754]         }, condition = base::local({
[13:24:30.754]             c <- base::c
[13:24:30.754]             inherits <- base::inherits
[13:24:30.754]             invokeRestart <- base::invokeRestart
[13:24:30.754]             length <- base::length
[13:24:30.754]             list <- base::list
[13:24:30.754]             seq.int <- base::seq.int
[13:24:30.754]             signalCondition <- base::signalCondition
[13:24:30.754]             sys.calls <- base::sys.calls
[13:24:30.754]             `[[` <- base::`[[`
[13:24:30.754]             `+` <- base::`+`
[13:24:30.754]             `<<-` <- base::`<<-`
[13:24:30.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:30.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:30.754]                   3L)]
[13:24:30.754]             }
[13:24:30.754]             function(cond) {
[13:24:30.754]                 is_error <- inherits(cond, "error")
[13:24:30.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:30.754]                   NULL)
[13:24:30.754]                 if (is_error) {
[13:24:30.754]                   sessionInformation <- function() {
[13:24:30.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:30.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:30.754]                       search = base::search(), system = base::Sys.info())
[13:24:30.754]                   }
[13:24:30.754]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:30.754]                     cond$call), session = sessionInformation(), 
[13:24:30.754]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:30.754]                   signalCondition(cond)
[13:24:30.754]                 }
[13:24:30.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:30.754]                 "immediateCondition"))) {
[13:24:30.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:30.754]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:30.754]                   if (TRUE && !signal) {
[13:24:30.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.754]                     {
[13:24:30.754]                       inherits <- base::inherits
[13:24:30.754]                       invokeRestart <- base::invokeRestart
[13:24:30.754]                       is.null <- base::is.null
[13:24:30.754]                       muffled <- FALSE
[13:24:30.754]                       if (inherits(cond, "message")) {
[13:24:30.754]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.754]                         if (muffled) 
[13:24:30.754]                           invokeRestart("muffleMessage")
[13:24:30.754]                       }
[13:24:30.754]                       else if (inherits(cond, "warning")) {
[13:24:30.754]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.754]                         if (muffled) 
[13:24:30.754]                           invokeRestart("muffleWarning")
[13:24:30.754]                       }
[13:24:30.754]                       else if (inherits(cond, "condition")) {
[13:24:30.754]                         if (!is.null(pattern)) {
[13:24:30.754]                           computeRestarts <- base::computeRestarts
[13:24:30.754]                           grepl <- base::grepl
[13:24:30.754]                           restarts <- computeRestarts(cond)
[13:24:30.754]                           for (restart in restarts) {
[13:24:30.754]                             name <- restart$name
[13:24:30.754]                             if (is.null(name)) 
[13:24:30.754]                               next
[13:24:30.754]                             if (!grepl(pattern, name)) 
[13:24:30.754]                               next
[13:24:30.754]                             invokeRestart(restart)
[13:24:30.754]                             muffled <- TRUE
[13:24:30.754]                             break
[13:24:30.754]                           }
[13:24:30.754]                         }
[13:24:30.754]                       }
[13:24:30.754]                       invisible(muffled)
[13:24:30.754]                     }
[13:24:30.754]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.754]                   }
[13:24:30.754]                 }
[13:24:30.754]                 else {
[13:24:30.754]                   if (TRUE) {
[13:24:30.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.754]                     {
[13:24:30.754]                       inherits <- base::inherits
[13:24:30.754]                       invokeRestart <- base::invokeRestart
[13:24:30.754]                       is.null <- base::is.null
[13:24:30.754]                       muffled <- FALSE
[13:24:30.754]                       if (inherits(cond, "message")) {
[13:24:30.754]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.754]                         if (muffled) 
[13:24:30.754]                           invokeRestart("muffleMessage")
[13:24:30.754]                       }
[13:24:30.754]                       else if (inherits(cond, "warning")) {
[13:24:30.754]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.754]                         if (muffled) 
[13:24:30.754]                           invokeRestart("muffleWarning")
[13:24:30.754]                       }
[13:24:30.754]                       else if (inherits(cond, "condition")) {
[13:24:30.754]                         if (!is.null(pattern)) {
[13:24:30.754]                           computeRestarts <- base::computeRestarts
[13:24:30.754]                           grepl <- base::grepl
[13:24:30.754]                           restarts <- computeRestarts(cond)
[13:24:30.754]                           for (restart in restarts) {
[13:24:30.754]                             name <- restart$name
[13:24:30.754]                             if (is.null(name)) 
[13:24:30.754]                               next
[13:24:30.754]                             if (!grepl(pattern, name)) 
[13:24:30.754]                               next
[13:24:30.754]                             invokeRestart(restart)
[13:24:30.754]                             muffled <- TRUE
[13:24:30.754]                             break
[13:24:30.754]                           }
[13:24:30.754]                         }
[13:24:30.754]                       }
[13:24:30.754]                       invisible(muffled)
[13:24:30.754]                     }
[13:24:30.754]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.754]                   }
[13:24:30.754]                 }
[13:24:30.754]             }
[13:24:30.754]         }))
[13:24:30.754]     }, error = function(ex) {
[13:24:30.754]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:30.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.754]                 ...future.rng), started = ...future.startTime, 
[13:24:30.754]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:30.754]             version = "1.8"), class = "FutureResult")
[13:24:30.754]     }, finally = {
[13:24:30.754]         if (!identical(...future.workdir, getwd())) 
[13:24:30.754]             setwd(...future.workdir)
[13:24:30.754]         {
[13:24:30.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:30.754]                 ...future.oldOptions$nwarnings <- NULL
[13:24:30.754]             }
[13:24:30.754]             base::options(...future.oldOptions)
[13:24:30.754]             if (.Platform$OS.type == "windows") {
[13:24:30.754]                 old_names <- names(...future.oldEnvVars)
[13:24:30.754]                 envs <- base::Sys.getenv()
[13:24:30.754]                 names <- names(envs)
[13:24:30.754]                 common <- intersect(names, old_names)
[13:24:30.754]                 added <- setdiff(names, old_names)
[13:24:30.754]                 removed <- setdiff(old_names, names)
[13:24:30.754]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:30.754]                   envs[common]]
[13:24:30.754]                 NAMES <- toupper(changed)
[13:24:30.754]                 args <- list()
[13:24:30.754]                 for (kk in seq_along(NAMES)) {
[13:24:30.754]                   name <- changed[[kk]]
[13:24:30.754]                   NAME <- NAMES[[kk]]
[13:24:30.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.754]                     next
[13:24:30.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.754]                 }
[13:24:30.754]                 NAMES <- toupper(added)
[13:24:30.754]                 for (kk in seq_along(NAMES)) {
[13:24:30.754]                   name <- added[[kk]]
[13:24:30.754]                   NAME <- NAMES[[kk]]
[13:24:30.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.754]                     next
[13:24:30.754]                   args[[name]] <- ""
[13:24:30.754]                 }
[13:24:30.754]                 NAMES <- toupper(removed)
[13:24:30.754]                 for (kk in seq_along(NAMES)) {
[13:24:30.754]                   name <- removed[[kk]]
[13:24:30.754]                   NAME <- NAMES[[kk]]
[13:24:30.754]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.754]                     next
[13:24:30.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.754]                 }
[13:24:30.754]                 if (length(args) > 0) 
[13:24:30.754]                   base::do.call(base::Sys.setenv, args = args)
[13:24:30.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:30.754]             }
[13:24:30.754]             else {
[13:24:30.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:30.754]             }
[13:24:30.754]             {
[13:24:30.754]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:30.754]                   0L) {
[13:24:30.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:30.754]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:30.754]                   base::options(opts)
[13:24:30.754]                 }
[13:24:30.754]                 {
[13:24:30.754]                   {
[13:24:30.754]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:30.754]                     NULL
[13:24:30.754]                   }
[13:24:30.754]                   options(future.plan = NULL)
[13:24:30.754]                   if (is.na(NA_character_)) 
[13:24:30.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:30.754]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:30.754]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:30.754]                     envir = parent.frame()) 
[13:24:30.754]                   {
[13:24:30.754]                     if (is.function(workers)) 
[13:24:30.754]                       workers <- workers()
[13:24:30.754]                     workers <- structure(as.integer(workers), 
[13:24:30.754]                       class = class(workers))
[13:24:30.754]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:30.754]                       workers >= 1)
[13:24:30.754]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:30.754]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:30.754]                     }
[13:24:30.754]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:30.754]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:30.754]                       envir = envir)
[13:24:30.754]                     if (!future$lazy) 
[13:24:30.754]                       future <- run(future)
[13:24:30.754]                     invisible(future)
[13:24:30.754]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:30.754]                 }
[13:24:30.754]             }
[13:24:30.754]         }
[13:24:30.754]     })
[13:24:30.754]     if (TRUE) {
[13:24:30.754]         base::sink(type = "output", split = FALSE)
[13:24:30.754]         if (TRUE) {
[13:24:30.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:30.754]         }
[13:24:30.754]         else {
[13:24:30.754]             ...future.result["stdout"] <- base::list(NULL)
[13:24:30.754]         }
[13:24:30.754]         base::close(...future.stdout)
[13:24:30.754]         ...future.stdout <- NULL
[13:24:30.754]     }
[13:24:30.754]     ...future.result$conditions <- ...future.conditions
[13:24:30.754]     ...future.result$finished <- base::Sys.time()
[13:24:30.754]     ...future.result
[13:24:30.754] }
[13:24:30.758] MultisessionFuture started
[13:24:30.758] - Launch lazy future ... done
[13:24:30.758] run() for ‘MultisessionFuture’ ... done
[13:24:30.805] receiveMessageFromWorker() for ClusterFuture ...
[13:24:30.805] - Validating connection of MultisessionFuture
[13:24:30.806] - received message: FutureResult
[13:24:30.806] - Received FutureResult
[13:24:30.806] - Erased future from FutureRegistry
[13:24:30.806] result() for ClusterFuture ...
[13:24:30.806] - result already collected: FutureResult
[13:24:30.806] result() for ClusterFuture ... done
[13:24:30.806] signalConditions() ...
[13:24:30.806]  - include = ‘immediateCondition’
[13:24:30.807]  - exclude = 
[13:24:30.807]  - resignal = FALSE
[13:24:30.807]  - Number of conditions: 1
[13:24:30.807] signalConditions() ... done
[13:24:30.807] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:30.807] A MultisessionFuture was resolved (result was not collected)
[13:24:30.807] getGlobalsAndPackages() ...
[13:24:30.807] Searching for globals...
[13:24:30.808] - globals found: [2] ‘list’, ‘stop’
[13:24:30.808] Searching for globals ... DONE
[13:24:30.808] Resolving globals: FALSE
[13:24:30.808] 
[13:24:30.809] 
[13:24:30.809] getGlobalsAndPackages() ... DONE
[13:24:30.809] run() for ‘Future’ ...
[13:24:30.809] - state: ‘created’
[13:24:30.809] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:30.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:30.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:30.826]   - Field: ‘node’
[13:24:30.826]   - Field: ‘label’
[13:24:30.826]   - Field: ‘local’
[13:24:30.826]   - Field: ‘owner’
[13:24:30.826]   - Field: ‘envir’
[13:24:30.826]   - Field: ‘workers’
[13:24:30.826]   - Field: ‘packages’
[13:24:30.826]   - Field: ‘gc’
[13:24:30.827]   - Field: ‘conditions’
[13:24:30.827]   - Field: ‘persistent’
[13:24:30.827]   - Field: ‘expr’
[13:24:30.827]   - Field: ‘uuid’
[13:24:30.827]   - Field: ‘seed’
[13:24:30.827]   - Field: ‘version’
[13:24:30.827]   - Field: ‘result’
[13:24:30.827]   - Field: ‘asynchronous’
[13:24:30.827]   - Field: ‘calls’
[13:24:30.827]   - Field: ‘globals’
[13:24:30.827]   - Field: ‘stdout’
[13:24:30.828]   - Field: ‘earlySignal’
[13:24:30.828]   - Field: ‘lazy’
[13:24:30.828]   - Field: ‘state’
[13:24:30.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:30.828] - Launch lazy future ...
[13:24:30.828] Packages needed by the future expression (n = 0): <none>
[13:24:30.828] Packages needed by future strategies (n = 0): <none>
[13:24:30.829] {
[13:24:30.829]     {
[13:24:30.829]         {
[13:24:30.829]             ...future.startTime <- base::Sys.time()
[13:24:30.829]             {
[13:24:30.829]                 {
[13:24:30.829]                   {
[13:24:30.829]                     {
[13:24:30.829]                       base::local({
[13:24:30.829]                         has_future <- base::requireNamespace("future", 
[13:24:30.829]                           quietly = TRUE)
[13:24:30.829]                         if (has_future) {
[13:24:30.829]                           ns <- base::getNamespace("future")
[13:24:30.829]                           version <- ns[[".package"]][["version"]]
[13:24:30.829]                           if (is.null(version)) 
[13:24:30.829]                             version <- utils::packageVersion("future")
[13:24:30.829]                         }
[13:24:30.829]                         else {
[13:24:30.829]                           version <- NULL
[13:24:30.829]                         }
[13:24:30.829]                         if (!has_future || version < "1.8.0") {
[13:24:30.829]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:30.829]                             "", base::R.version$version.string), 
[13:24:30.829]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:30.829]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:30.829]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:30.829]                               "release", "version")], collapse = " "), 
[13:24:30.829]                             hostname = base::Sys.info()[["nodename"]])
[13:24:30.829]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:30.829]                             info)
[13:24:30.829]                           info <- base::paste(info, collapse = "; ")
[13:24:30.829]                           if (!has_future) {
[13:24:30.829]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:30.829]                               info)
[13:24:30.829]                           }
[13:24:30.829]                           else {
[13:24:30.829]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:30.829]                               info, version)
[13:24:30.829]                           }
[13:24:30.829]                           base::stop(msg)
[13:24:30.829]                         }
[13:24:30.829]                       })
[13:24:30.829]                     }
[13:24:30.829]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:30.829]                     base::options(mc.cores = 1L)
[13:24:30.829]                   }
[13:24:30.829]                   options(future.plan = NULL)
[13:24:30.829]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.829]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:30.829]                 }
[13:24:30.829]                 ...future.workdir <- getwd()
[13:24:30.829]             }
[13:24:30.829]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:30.829]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:30.829]         }
[13:24:30.829]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:30.829]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:30.829]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:30.829]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:30.829]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:30.829]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:30.829]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:30.829]             base::names(...future.oldOptions))
[13:24:30.829]     }
[13:24:30.829]     if (FALSE) {
[13:24:30.829]     }
[13:24:30.829]     else {
[13:24:30.829]         if (TRUE) {
[13:24:30.829]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:30.829]                 open = "w")
[13:24:30.829]         }
[13:24:30.829]         else {
[13:24:30.829]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:30.829]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:30.829]         }
[13:24:30.829]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:30.829]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:30.829]             base::sink(type = "output", split = FALSE)
[13:24:30.829]             base::close(...future.stdout)
[13:24:30.829]         }, add = TRUE)
[13:24:30.829]     }
[13:24:30.829]     ...future.frame <- base::sys.nframe()
[13:24:30.829]     ...future.conditions <- base::list()
[13:24:30.829]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:30.829]     if (FALSE) {
[13:24:30.829]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:30.829]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:30.829]     }
[13:24:30.829]     ...future.result <- base::tryCatch({
[13:24:30.829]         base::withCallingHandlers({
[13:24:30.829]             ...future.value <- base::withVisible(base::local({
[13:24:30.829]                 ...future.makeSendCondition <- base::local({
[13:24:30.829]                   sendCondition <- NULL
[13:24:30.829]                   function(frame = 1L) {
[13:24:30.829]                     if (is.function(sendCondition)) 
[13:24:30.829]                       return(sendCondition)
[13:24:30.829]                     ns <- getNamespace("parallel")
[13:24:30.829]                     if (exists("sendData", mode = "function", 
[13:24:30.829]                       envir = ns)) {
[13:24:30.829]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:30.829]                         envir = ns)
[13:24:30.829]                       envir <- sys.frame(frame)
[13:24:30.829]                       master <- NULL
[13:24:30.829]                       while (!identical(envir, .GlobalEnv) && 
[13:24:30.829]                         !identical(envir, emptyenv())) {
[13:24:30.829]                         if (exists("master", mode = "list", envir = envir, 
[13:24:30.829]                           inherits = FALSE)) {
[13:24:30.829]                           master <- get("master", mode = "list", 
[13:24:30.829]                             envir = envir, inherits = FALSE)
[13:24:30.829]                           if (inherits(master, c("SOCKnode", 
[13:24:30.829]                             "SOCK0node"))) {
[13:24:30.829]                             sendCondition <<- function(cond) {
[13:24:30.829]                               data <- list(type = "VALUE", value = cond, 
[13:24:30.829]                                 success = TRUE)
[13:24:30.829]                               parallel_sendData(master, data)
[13:24:30.829]                             }
[13:24:30.829]                             return(sendCondition)
[13:24:30.829]                           }
[13:24:30.829]                         }
[13:24:30.829]                         frame <- frame + 1L
[13:24:30.829]                         envir <- sys.frame(frame)
[13:24:30.829]                       }
[13:24:30.829]                     }
[13:24:30.829]                     sendCondition <<- function(cond) NULL
[13:24:30.829]                   }
[13:24:30.829]                 })
[13:24:30.829]                 withCallingHandlers({
[13:24:30.829]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:30.829]                 }, immediateCondition = function(cond) {
[13:24:30.829]                   sendCondition <- ...future.makeSendCondition()
[13:24:30.829]                   sendCondition(cond)
[13:24:30.829]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.829]                   {
[13:24:30.829]                     inherits <- base::inherits
[13:24:30.829]                     invokeRestart <- base::invokeRestart
[13:24:30.829]                     is.null <- base::is.null
[13:24:30.829]                     muffled <- FALSE
[13:24:30.829]                     if (inherits(cond, "message")) {
[13:24:30.829]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:30.829]                       if (muffled) 
[13:24:30.829]                         invokeRestart("muffleMessage")
[13:24:30.829]                     }
[13:24:30.829]                     else if (inherits(cond, "warning")) {
[13:24:30.829]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:30.829]                       if (muffled) 
[13:24:30.829]                         invokeRestart("muffleWarning")
[13:24:30.829]                     }
[13:24:30.829]                     else if (inherits(cond, "condition")) {
[13:24:30.829]                       if (!is.null(pattern)) {
[13:24:30.829]                         computeRestarts <- base::computeRestarts
[13:24:30.829]                         grepl <- base::grepl
[13:24:30.829]                         restarts <- computeRestarts(cond)
[13:24:30.829]                         for (restart in restarts) {
[13:24:30.829]                           name <- restart$name
[13:24:30.829]                           if (is.null(name)) 
[13:24:30.829]                             next
[13:24:30.829]                           if (!grepl(pattern, name)) 
[13:24:30.829]                             next
[13:24:30.829]                           invokeRestart(restart)
[13:24:30.829]                           muffled <- TRUE
[13:24:30.829]                           break
[13:24:30.829]                         }
[13:24:30.829]                       }
[13:24:30.829]                     }
[13:24:30.829]                     invisible(muffled)
[13:24:30.829]                   }
[13:24:30.829]                   muffleCondition(cond)
[13:24:30.829]                 })
[13:24:30.829]             }))
[13:24:30.829]             future::FutureResult(value = ...future.value$value, 
[13:24:30.829]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.829]                   ...future.rng), globalenv = if (FALSE) 
[13:24:30.829]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:30.829]                     ...future.globalenv.names))
[13:24:30.829]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:30.829]         }, condition = base::local({
[13:24:30.829]             c <- base::c
[13:24:30.829]             inherits <- base::inherits
[13:24:30.829]             invokeRestart <- base::invokeRestart
[13:24:30.829]             length <- base::length
[13:24:30.829]             list <- base::list
[13:24:30.829]             seq.int <- base::seq.int
[13:24:30.829]             signalCondition <- base::signalCondition
[13:24:30.829]             sys.calls <- base::sys.calls
[13:24:30.829]             `[[` <- base::`[[`
[13:24:30.829]             `+` <- base::`+`
[13:24:30.829]             `<<-` <- base::`<<-`
[13:24:30.829]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:30.829]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:30.829]                   3L)]
[13:24:30.829]             }
[13:24:30.829]             function(cond) {
[13:24:30.829]                 is_error <- inherits(cond, "error")
[13:24:30.829]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:30.829]                   NULL)
[13:24:30.829]                 if (is_error) {
[13:24:30.829]                   sessionInformation <- function() {
[13:24:30.829]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:30.829]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:30.829]                       search = base::search(), system = base::Sys.info())
[13:24:30.829]                   }
[13:24:30.829]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.829]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:30.829]                     cond$call), session = sessionInformation(), 
[13:24:30.829]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:30.829]                   signalCondition(cond)
[13:24:30.829]                 }
[13:24:30.829]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:30.829]                 "immediateCondition"))) {
[13:24:30.829]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:30.829]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.829]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:30.829]                   if (TRUE && !signal) {
[13:24:30.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.829]                     {
[13:24:30.829]                       inherits <- base::inherits
[13:24:30.829]                       invokeRestart <- base::invokeRestart
[13:24:30.829]                       is.null <- base::is.null
[13:24:30.829]                       muffled <- FALSE
[13:24:30.829]                       if (inherits(cond, "message")) {
[13:24:30.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.829]                         if (muffled) 
[13:24:30.829]                           invokeRestart("muffleMessage")
[13:24:30.829]                       }
[13:24:30.829]                       else if (inherits(cond, "warning")) {
[13:24:30.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.829]                         if (muffled) 
[13:24:30.829]                           invokeRestart("muffleWarning")
[13:24:30.829]                       }
[13:24:30.829]                       else if (inherits(cond, "condition")) {
[13:24:30.829]                         if (!is.null(pattern)) {
[13:24:30.829]                           computeRestarts <- base::computeRestarts
[13:24:30.829]                           grepl <- base::grepl
[13:24:30.829]                           restarts <- computeRestarts(cond)
[13:24:30.829]                           for (restart in restarts) {
[13:24:30.829]                             name <- restart$name
[13:24:30.829]                             if (is.null(name)) 
[13:24:30.829]                               next
[13:24:30.829]                             if (!grepl(pattern, name)) 
[13:24:30.829]                               next
[13:24:30.829]                             invokeRestart(restart)
[13:24:30.829]                             muffled <- TRUE
[13:24:30.829]                             break
[13:24:30.829]                           }
[13:24:30.829]                         }
[13:24:30.829]                       }
[13:24:30.829]                       invisible(muffled)
[13:24:30.829]                     }
[13:24:30.829]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.829]                   }
[13:24:30.829]                 }
[13:24:30.829]                 else {
[13:24:30.829]                   if (TRUE) {
[13:24:30.829]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.829]                     {
[13:24:30.829]                       inherits <- base::inherits
[13:24:30.829]                       invokeRestart <- base::invokeRestart
[13:24:30.829]                       is.null <- base::is.null
[13:24:30.829]                       muffled <- FALSE
[13:24:30.829]                       if (inherits(cond, "message")) {
[13:24:30.829]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.829]                         if (muffled) 
[13:24:30.829]                           invokeRestart("muffleMessage")
[13:24:30.829]                       }
[13:24:30.829]                       else if (inherits(cond, "warning")) {
[13:24:30.829]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.829]                         if (muffled) 
[13:24:30.829]                           invokeRestart("muffleWarning")
[13:24:30.829]                       }
[13:24:30.829]                       else if (inherits(cond, "condition")) {
[13:24:30.829]                         if (!is.null(pattern)) {
[13:24:30.829]                           computeRestarts <- base::computeRestarts
[13:24:30.829]                           grepl <- base::grepl
[13:24:30.829]                           restarts <- computeRestarts(cond)
[13:24:30.829]                           for (restart in restarts) {
[13:24:30.829]                             name <- restart$name
[13:24:30.829]                             if (is.null(name)) 
[13:24:30.829]                               next
[13:24:30.829]                             if (!grepl(pattern, name)) 
[13:24:30.829]                               next
[13:24:30.829]                             invokeRestart(restart)
[13:24:30.829]                             muffled <- TRUE
[13:24:30.829]                             break
[13:24:30.829]                           }
[13:24:30.829]                         }
[13:24:30.829]                       }
[13:24:30.829]                       invisible(muffled)
[13:24:30.829]                     }
[13:24:30.829]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.829]                   }
[13:24:30.829]                 }
[13:24:30.829]             }
[13:24:30.829]         }))
[13:24:30.829]     }, error = function(ex) {
[13:24:30.829]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:30.829]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.829]                 ...future.rng), started = ...future.startTime, 
[13:24:30.829]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:30.829]             version = "1.8"), class = "FutureResult")
[13:24:30.829]     }, finally = {
[13:24:30.829]         if (!identical(...future.workdir, getwd())) 
[13:24:30.829]             setwd(...future.workdir)
[13:24:30.829]         {
[13:24:30.829]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:30.829]                 ...future.oldOptions$nwarnings <- NULL
[13:24:30.829]             }
[13:24:30.829]             base::options(...future.oldOptions)
[13:24:30.829]             if (.Platform$OS.type == "windows") {
[13:24:30.829]                 old_names <- names(...future.oldEnvVars)
[13:24:30.829]                 envs <- base::Sys.getenv()
[13:24:30.829]                 names <- names(envs)
[13:24:30.829]                 common <- intersect(names, old_names)
[13:24:30.829]                 added <- setdiff(names, old_names)
[13:24:30.829]                 removed <- setdiff(old_names, names)
[13:24:30.829]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:30.829]                   envs[common]]
[13:24:30.829]                 NAMES <- toupper(changed)
[13:24:30.829]                 args <- list()
[13:24:30.829]                 for (kk in seq_along(NAMES)) {
[13:24:30.829]                   name <- changed[[kk]]
[13:24:30.829]                   NAME <- NAMES[[kk]]
[13:24:30.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.829]                     next
[13:24:30.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.829]                 }
[13:24:30.829]                 NAMES <- toupper(added)
[13:24:30.829]                 for (kk in seq_along(NAMES)) {
[13:24:30.829]                   name <- added[[kk]]
[13:24:30.829]                   NAME <- NAMES[[kk]]
[13:24:30.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.829]                     next
[13:24:30.829]                   args[[name]] <- ""
[13:24:30.829]                 }
[13:24:30.829]                 NAMES <- toupper(removed)
[13:24:30.829]                 for (kk in seq_along(NAMES)) {
[13:24:30.829]                   name <- removed[[kk]]
[13:24:30.829]                   NAME <- NAMES[[kk]]
[13:24:30.829]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.829]                     next
[13:24:30.829]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.829]                 }
[13:24:30.829]                 if (length(args) > 0) 
[13:24:30.829]                   base::do.call(base::Sys.setenv, args = args)
[13:24:30.829]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:30.829]             }
[13:24:30.829]             else {
[13:24:30.829]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:30.829]             }
[13:24:30.829]             {
[13:24:30.829]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:30.829]                   0L) {
[13:24:30.829]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:30.829]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:30.829]                   base::options(opts)
[13:24:30.829]                 }
[13:24:30.829]                 {
[13:24:30.829]                   {
[13:24:30.829]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:30.829]                     NULL
[13:24:30.829]                   }
[13:24:30.829]                   options(future.plan = NULL)
[13:24:30.829]                   if (is.na(NA_character_)) 
[13:24:30.829]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.829]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:30.829]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:30.829]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:30.829]                     envir = parent.frame()) 
[13:24:30.829]                   {
[13:24:30.829]                     if (is.function(workers)) 
[13:24:30.829]                       workers <- workers()
[13:24:30.829]                     workers <- structure(as.integer(workers), 
[13:24:30.829]                       class = class(workers))
[13:24:30.829]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:30.829]                       workers >= 1)
[13:24:30.829]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:30.829]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:30.829]                     }
[13:24:30.829]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:30.829]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:30.829]                       envir = envir)
[13:24:30.829]                     if (!future$lazy) 
[13:24:30.829]                       future <- run(future)
[13:24:30.829]                     invisible(future)
[13:24:30.829]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:30.829]                 }
[13:24:30.829]             }
[13:24:30.829]         }
[13:24:30.829]     })
[13:24:30.829]     if (TRUE) {
[13:24:30.829]         base::sink(type = "output", split = FALSE)
[13:24:30.829]         if (TRUE) {
[13:24:30.829]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:30.829]         }
[13:24:30.829]         else {
[13:24:30.829]             ...future.result["stdout"] <- base::list(NULL)
[13:24:30.829]         }
[13:24:30.829]         base::close(...future.stdout)
[13:24:30.829]         ...future.stdout <- NULL
[13:24:30.829]     }
[13:24:30.829]     ...future.result$conditions <- ...future.conditions
[13:24:30.829]     ...future.result$finished <- base::Sys.time()
[13:24:30.829]     ...future.result
[13:24:30.829] }
[13:24:30.832] MultisessionFuture started
[13:24:30.832] - Launch lazy future ... done
[13:24:30.832] run() for ‘MultisessionFuture’ ... done
[13:24:30.877] receiveMessageFromWorker() for ClusterFuture ...
[13:24:30.877] - Validating connection of MultisessionFuture
[13:24:30.878] - received message: FutureResult
[13:24:30.878] - Received FutureResult
[13:24:30.878] - Erased future from FutureRegistry
[13:24:30.878] result() for ClusterFuture ...
[13:24:30.878] - result already collected: FutureResult
[13:24:30.879] result() for ClusterFuture ... done
[13:24:30.879] signalConditions() ...
[13:24:30.879]  - include = ‘immediateCondition’
[13:24:30.879]  - exclude = 
[13:24:30.879]  - resignal = FALSE
[13:24:30.879]  - Number of conditions: 1
[13:24:30.879] signalConditions() ... done
[13:24:30.879] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:30.879] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[13:24:30.879] getGlobalsAndPackages() ...
[13:24:30.880] Searching for globals...
[13:24:30.881] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:30.881] Searching for globals ... DONE
[13:24:30.881] Resolving globals: FALSE
[13:24:30.881] 
[13:24:30.881] 
[13:24:30.882] getGlobalsAndPackages() ... DONE
[13:24:30.882] run() for ‘Future’ ...
[13:24:30.882] - state: ‘created’
[13:24:30.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:30.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:30.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:30.896]   - Field: ‘node’
[13:24:30.896]   - Field: ‘label’
[13:24:30.896]   - Field: ‘local’
[13:24:30.897]   - Field: ‘owner’
[13:24:30.897]   - Field: ‘envir’
[13:24:30.897]   - Field: ‘workers’
[13:24:30.897]   - Field: ‘packages’
[13:24:30.897]   - Field: ‘gc’
[13:24:30.897]   - Field: ‘conditions’
[13:24:30.897]   - Field: ‘persistent’
[13:24:30.897]   - Field: ‘expr’
[13:24:30.897]   - Field: ‘uuid’
[13:24:30.897]   - Field: ‘seed’
[13:24:30.897]   - Field: ‘version’
[13:24:30.898]   - Field: ‘result’
[13:24:30.898]   - Field: ‘asynchronous’
[13:24:30.898]   - Field: ‘calls’
[13:24:30.898]   - Field: ‘globals’
[13:24:30.898]   - Field: ‘stdout’
[13:24:30.898]   - Field: ‘earlySignal’
[13:24:30.898]   - Field: ‘lazy’
[13:24:30.898]   - Field: ‘state’
[13:24:30.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:30.898] - Launch lazy future ...
[13:24:30.899] Packages needed by the future expression (n = 0): <none>
[13:24:30.899] Packages needed by future strategies (n = 0): <none>
[13:24:30.899] {
[13:24:30.899]     {
[13:24:30.899]         {
[13:24:30.899]             ...future.startTime <- base::Sys.time()
[13:24:30.899]             {
[13:24:30.899]                 {
[13:24:30.899]                   {
[13:24:30.899]                     {
[13:24:30.899]                       base::local({
[13:24:30.899]                         has_future <- base::requireNamespace("future", 
[13:24:30.899]                           quietly = TRUE)
[13:24:30.899]                         if (has_future) {
[13:24:30.899]                           ns <- base::getNamespace("future")
[13:24:30.899]                           version <- ns[[".package"]][["version"]]
[13:24:30.899]                           if (is.null(version)) 
[13:24:30.899]                             version <- utils::packageVersion("future")
[13:24:30.899]                         }
[13:24:30.899]                         else {
[13:24:30.899]                           version <- NULL
[13:24:30.899]                         }
[13:24:30.899]                         if (!has_future || version < "1.8.0") {
[13:24:30.899]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:30.899]                             "", base::R.version$version.string), 
[13:24:30.899]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:30.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:30.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:30.899]                               "release", "version")], collapse = " "), 
[13:24:30.899]                             hostname = base::Sys.info()[["nodename"]])
[13:24:30.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:30.899]                             info)
[13:24:30.899]                           info <- base::paste(info, collapse = "; ")
[13:24:30.899]                           if (!has_future) {
[13:24:30.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:30.899]                               info)
[13:24:30.899]                           }
[13:24:30.899]                           else {
[13:24:30.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:30.899]                               info, version)
[13:24:30.899]                           }
[13:24:30.899]                           base::stop(msg)
[13:24:30.899]                         }
[13:24:30.899]                       })
[13:24:30.899]                     }
[13:24:30.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:30.899]                     base::options(mc.cores = 1L)
[13:24:30.899]                   }
[13:24:30.899]                   options(future.plan = NULL)
[13:24:30.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:30.899]                 }
[13:24:30.899]                 ...future.workdir <- getwd()
[13:24:30.899]             }
[13:24:30.899]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:30.899]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:30.899]         }
[13:24:30.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:30.899]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:30.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:30.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:30.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:30.899]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:30.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:30.899]             base::names(...future.oldOptions))
[13:24:30.899]     }
[13:24:30.899]     if (FALSE) {
[13:24:30.899]     }
[13:24:30.899]     else {
[13:24:30.899]         if (TRUE) {
[13:24:30.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:30.899]                 open = "w")
[13:24:30.899]         }
[13:24:30.899]         else {
[13:24:30.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:30.899]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:30.899]         }
[13:24:30.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:30.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:30.899]             base::sink(type = "output", split = FALSE)
[13:24:30.899]             base::close(...future.stdout)
[13:24:30.899]         }, add = TRUE)
[13:24:30.899]     }
[13:24:30.899]     ...future.frame <- base::sys.nframe()
[13:24:30.899]     ...future.conditions <- base::list()
[13:24:30.899]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:30.899]     if (FALSE) {
[13:24:30.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:30.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:30.899]     }
[13:24:30.899]     ...future.result <- base::tryCatch({
[13:24:30.899]         base::withCallingHandlers({
[13:24:30.899]             ...future.value <- base::withVisible(base::local({
[13:24:30.899]                 ...future.makeSendCondition <- base::local({
[13:24:30.899]                   sendCondition <- NULL
[13:24:30.899]                   function(frame = 1L) {
[13:24:30.899]                     if (is.function(sendCondition)) 
[13:24:30.899]                       return(sendCondition)
[13:24:30.899]                     ns <- getNamespace("parallel")
[13:24:30.899]                     if (exists("sendData", mode = "function", 
[13:24:30.899]                       envir = ns)) {
[13:24:30.899]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:30.899]                         envir = ns)
[13:24:30.899]                       envir <- sys.frame(frame)
[13:24:30.899]                       master <- NULL
[13:24:30.899]                       while (!identical(envir, .GlobalEnv) && 
[13:24:30.899]                         !identical(envir, emptyenv())) {
[13:24:30.899]                         if (exists("master", mode = "list", envir = envir, 
[13:24:30.899]                           inherits = FALSE)) {
[13:24:30.899]                           master <- get("master", mode = "list", 
[13:24:30.899]                             envir = envir, inherits = FALSE)
[13:24:30.899]                           if (inherits(master, c("SOCKnode", 
[13:24:30.899]                             "SOCK0node"))) {
[13:24:30.899]                             sendCondition <<- function(cond) {
[13:24:30.899]                               data <- list(type = "VALUE", value = cond, 
[13:24:30.899]                                 success = TRUE)
[13:24:30.899]                               parallel_sendData(master, data)
[13:24:30.899]                             }
[13:24:30.899]                             return(sendCondition)
[13:24:30.899]                           }
[13:24:30.899]                         }
[13:24:30.899]                         frame <- frame + 1L
[13:24:30.899]                         envir <- sys.frame(frame)
[13:24:30.899]                       }
[13:24:30.899]                     }
[13:24:30.899]                     sendCondition <<- function(cond) NULL
[13:24:30.899]                   }
[13:24:30.899]                 })
[13:24:30.899]                 withCallingHandlers({
[13:24:30.899]                   {
[13:24:30.899]                     Sys.sleep(0.5)
[13:24:30.899]                     list(a = 1, b = 42L)
[13:24:30.899]                   }
[13:24:30.899]                 }, immediateCondition = function(cond) {
[13:24:30.899]                   sendCondition <- ...future.makeSendCondition()
[13:24:30.899]                   sendCondition(cond)
[13:24:30.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.899]                   {
[13:24:30.899]                     inherits <- base::inherits
[13:24:30.899]                     invokeRestart <- base::invokeRestart
[13:24:30.899]                     is.null <- base::is.null
[13:24:30.899]                     muffled <- FALSE
[13:24:30.899]                     if (inherits(cond, "message")) {
[13:24:30.899]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:30.899]                       if (muffled) 
[13:24:30.899]                         invokeRestart("muffleMessage")
[13:24:30.899]                     }
[13:24:30.899]                     else if (inherits(cond, "warning")) {
[13:24:30.899]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:30.899]                       if (muffled) 
[13:24:30.899]                         invokeRestart("muffleWarning")
[13:24:30.899]                     }
[13:24:30.899]                     else if (inherits(cond, "condition")) {
[13:24:30.899]                       if (!is.null(pattern)) {
[13:24:30.899]                         computeRestarts <- base::computeRestarts
[13:24:30.899]                         grepl <- base::grepl
[13:24:30.899]                         restarts <- computeRestarts(cond)
[13:24:30.899]                         for (restart in restarts) {
[13:24:30.899]                           name <- restart$name
[13:24:30.899]                           if (is.null(name)) 
[13:24:30.899]                             next
[13:24:30.899]                           if (!grepl(pattern, name)) 
[13:24:30.899]                             next
[13:24:30.899]                           invokeRestart(restart)
[13:24:30.899]                           muffled <- TRUE
[13:24:30.899]                           break
[13:24:30.899]                         }
[13:24:30.899]                       }
[13:24:30.899]                     }
[13:24:30.899]                     invisible(muffled)
[13:24:30.899]                   }
[13:24:30.899]                   muffleCondition(cond)
[13:24:30.899]                 })
[13:24:30.899]             }))
[13:24:30.899]             future::FutureResult(value = ...future.value$value, 
[13:24:30.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.899]                   ...future.rng), globalenv = if (FALSE) 
[13:24:30.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:30.899]                     ...future.globalenv.names))
[13:24:30.899]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:30.899]         }, condition = base::local({
[13:24:30.899]             c <- base::c
[13:24:30.899]             inherits <- base::inherits
[13:24:30.899]             invokeRestart <- base::invokeRestart
[13:24:30.899]             length <- base::length
[13:24:30.899]             list <- base::list
[13:24:30.899]             seq.int <- base::seq.int
[13:24:30.899]             signalCondition <- base::signalCondition
[13:24:30.899]             sys.calls <- base::sys.calls
[13:24:30.899]             `[[` <- base::`[[`
[13:24:30.899]             `+` <- base::`+`
[13:24:30.899]             `<<-` <- base::`<<-`
[13:24:30.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:30.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:30.899]                   3L)]
[13:24:30.899]             }
[13:24:30.899]             function(cond) {
[13:24:30.899]                 is_error <- inherits(cond, "error")
[13:24:30.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:30.899]                   NULL)
[13:24:30.899]                 if (is_error) {
[13:24:30.899]                   sessionInformation <- function() {
[13:24:30.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:30.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:30.899]                       search = base::search(), system = base::Sys.info())
[13:24:30.899]                   }
[13:24:30.899]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:30.899]                     cond$call), session = sessionInformation(), 
[13:24:30.899]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:30.899]                   signalCondition(cond)
[13:24:30.899]                 }
[13:24:30.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:30.899]                 "immediateCondition"))) {
[13:24:30.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:30.899]                   ...future.conditions[[length(...future.conditions) + 
[13:24:30.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:30.899]                   if (TRUE && !signal) {
[13:24:30.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.899]                     {
[13:24:30.899]                       inherits <- base::inherits
[13:24:30.899]                       invokeRestart <- base::invokeRestart
[13:24:30.899]                       is.null <- base::is.null
[13:24:30.899]                       muffled <- FALSE
[13:24:30.899]                       if (inherits(cond, "message")) {
[13:24:30.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.899]                         if (muffled) 
[13:24:30.899]                           invokeRestart("muffleMessage")
[13:24:30.899]                       }
[13:24:30.899]                       else if (inherits(cond, "warning")) {
[13:24:30.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.899]                         if (muffled) 
[13:24:30.899]                           invokeRestart("muffleWarning")
[13:24:30.899]                       }
[13:24:30.899]                       else if (inherits(cond, "condition")) {
[13:24:30.899]                         if (!is.null(pattern)) {
[13:24:30.899]                           computeRestarts <- base::computeRestarts
[13:24:30.899]                           grepl <- base::grepl
[13:24:30.899]                           restarts <- computeRestarts(cond)
[13:24:30.899]                           for (restart in restarts) {
[13:24:30.899]                             name <- restart$name
[13:24:30.899]                             if (is.null(name)) 
[13:24:30.899]                               next
[13:24:30.899]                             if (!grepl(pattern, name)) 
[13:24:30.899]                               next
[13:24:30.899]                             invokeRestart(restart)
[13:24:30.899]                             muffled <- TRUE
[13:24:30.899]                             break
[13:24:30.899]                           }
[13:24:30.899]                         }
[13:24:30.899]                       }
[13:24:30.899]                       invisible(muffled)
[13:24:30.899]                     }
[13:24:30.899]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.899]                   }
[13:24:30.899]                 }
[13:24:30.899]                 else {
[13:24:30.899]                   if (TRUE) {
[13:24:30.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:30.899]                     {
[13:24:30.899]                       inherits <- base::inherits
[13:24:30.899]                       invokeRestart <- base::invokeRestart
[13:24:30.899]                       is.null <- base::is.null
[13:24:30.899]                       muffled <- FALSE
[13:24:30.899]                       if (inherits(cond, "message")) {
[13:24:30.899]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:30.899]                         if (muffled) 
[13:24:30.899]                           invokeRestart("muffleMessage")
[13:24:30.899]                       }
[13:24:30.899]                       else if (inherits(cond, "warning")) {
[13:24:30.899]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:30.899]                         if (muffled) 
[13:24:30.899]                           invokeRestart("muffleWarning")
[13:24:30.899]                       }
[13:24:30.899]                       else if (inherits(cond, "condition")) {
[13:24:30.899]                         if (!is.null(pattern)) {
[13:24:30.899]                           computeRestarts <- base::computeRestarts
[13:24:30.899]                           grepl <- base::grepl
[13:24:30.899]                           restarts <- computeRestarts(cond)
[13:24:30.899]                           for (restart in restarts) {
[13:24:30.899]                             name <- restart$name
[13:24:30.899]                             if (is.null(name)) 
[13:24:30.899]                               next
[13:24:30.899]                             if (!grepl(pattern, name)) 
[13:24:30.899]                               next
[13:24:30.899]                             invokeRestart(restart)
[13:24:30.899]                             muffled <- TRUE
[13:24:30.899]                             break
[13:24:30.899]                           }
[13:24:30.899]                         }
[13:24:30.899]                       }
[13:24:30.899]                       invisible(muffled)
[13:24:30.899]                     }
[13:24:30.899]                     muffleCondition(cond, pattern = "^muffle")
[13:24:30.899]                   }
[13:24:30.899]                 }
[13:24:30.899]             }
[13:24:30.899]         }))
[13:24:30.899]     }, error = function(ex) {
[13:24:30.899]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:30.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:30.899]                 ...future.rng), started = ...future.startTime, 
[13:24:30.899]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:30.899]             version = "1.8"), class = "FutureResult")
[13:24:30.899]     }, finally = {
[13:24:30.899]         if (!identical(...future.workdir, getwd())) 
[13:24:30.899]             setwd(...future.workdir)
[13:24:30.899]         {
[13:24:30.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:30.899]                 ...future.oldOptions$nwarnings <- NULL
[13:24:30.899]             }
[13:24:30.899]             base::options(...future.oldOptions)
[13:24:30.899]             if (.Platform$OS.type == "windows") {
[13:24:30.899]                 old_names <- names(...future.oldEnvVars)
[13:24:30.899]                 envs <- base::Sys.getenv()
[13:24:30.899]                 names <- names(envs)
[13:24:30.899]                 common <- intersect(names, old_names)
[13:24:30.899]                 added <- setdiff(names, old_names)
[13:24:30.899]                 removed <- setdiff(old_names, names)
[13:24:30.899]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:30.899]                   envs[common]]
[13:24:30.899]                 NAMES <- toupper(changed)
[13:24:30.899]                 args <- list()
[13:24:30.899]                 for (kk in seq_along(NAMES)) {
[13:24:30.899]                   name <- changed[[kk]]
[13:24:30.899]                   NAME <- NAMES[[kk]]
[13:24:30.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.899]                     next
[13:24:30.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.899]                 }
[13:24:30.899]                 NAMES <- toupper(added)
[13:24:30.899]                 for (kk in seq_along(NAMES)) {
[13:24:30.899]                   name <- added[[kk]]
[13:24:30.899]                   NAME <- NAMES[[kk]]
[13:24:30.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.899]                     next
[13:24:30.899]                   args[[name]] <- ""
[13:24:30.899]                 }
[13:24:30.899]                 NAMES <- toupper(removed)
[13:24:30.899]                 for (kk in seq_along(NAMES)) {
[13:24:30.899]                   name <- removed[[kk]]
[13:24:30.899]                   NAME <- NAMES[[kk]]
[13:24:30.899]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:30.899]                     next
[13:24:30.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:30.899]                 }
[13:24:30.899]                 if (length(args) > 0) 
[13:24:30.899]                   base::do.call(base::Sys.setenv, args = args)
[13:24:30.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:30.899]             }
[13:24:30.899]             else {
[13:24:30.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:30.899]             }
[13:24:30.899]             {
[13:24:30.899]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:30.899]                   0L) {
[13:24:30.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:30.899]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:30.899]                   base::options(opts)
[13:24:30.899]                 }
[13:24:30.899]                 {
[13:24:30.899]                   {
[13:24:30.899]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:30.899]                     NULL
[13:24:30.899]                   }
[13:24:30.899]                   options(future.plan = NULL)
[13:24:30.899]                   if (is.na(NA_character_)) 
[13:24:30.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:30.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:30.899]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:30.899]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:30.899]                     envir = parent.frame()) 
[13:24:30.899]                   {
[13:24:30.899]                     if (is.function(workers)) 
[13:24:30.899]                       workers <- workers()
[13:24:30.899]                     workers <- structure(as.integer(workers), 
[13:24:30.899]                       class = class(workers))
[13:24:30.899]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:30.899]                       workers >= 1)
[13:24:30.899]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:30.899]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:30.899]                     }
[13:24:30.899]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:30.899]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:30.899]                       envir = envir)
[13:24:30.899]                     if (!future$lazy) 
[13:24:30.899]                       future <- run(future)
[13:24:30.899]                     invisible(future)
[13:24:30.899]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:30.899]                 }
[13:24:30.899]             }
[13:24:30.899]         }
[13:24:30.899]     })
[13:24:30.899]     if (TRUE) {
[13:24:30.899]         base::sink(type = "output", split = FALSE)
[13:24:30.899]         if (TRUE) {
[13:24:30.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:30.899]         }
[13:24:30.899]         else {
[13:24:30.899]             ...future.result["stdout"] <- base::list(NULL)
[13:24:30.899]         }
[13:24:30.899]         base::close(...future.stdout)
[13:24:30.899]         ...future.stdout <- NULL
[13:24:30.899]     }
[13:24:30.899]     ...future.result$conditions <- ...future.conditions
[13:24:30.899]     ...future.result$finished <- base::Sys.time()
[13:24:30.899]     ...future.result
[13:24:30.899] }
[13:24:30.902] MultisessionFuture started
[13:24:30.902] - Launch lazy future ... done
[13:24:30.903] run() for ‘MultisessionFuture’ ... done
[13:24:31.450] receiveMessageFromWorker() for ClusterFuture ...
[13:24:31.450] - Validating connection of MultisessionFuture
[13:24:31.451] - received message: FutureResult
[13:24:31.451] - Received FutureResult
[13:24:31.451] - Erased future from FutureRegistry
[13:24:31.451] result() for ClusterFuture ...
[13:24:31.451] - result already collected: FutureResult
[13:24:31.451] result() for ClusterFuture ... done
[13:24:31.451] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:31.451] A MultisessionFuture was resolved (result was not collected)
[13:24:31.451] getGlobalsAndPackages() ...
[13:24:31.452] Searching for globals...
[13:24:31.453] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:31.453] Searching for globals ... DONE
[13:24:31.453] Resolving globals: FALSE
[13:24:31.453] 
[13:24:31.453] 
[13:24:31.454] getGlobalsAndPackages() ... DONE
[13:24:31.454] run() for ‘Future’ ...
[13:24:31.454] - state: ‘created’
[13:24:31.454] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:31.469] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:31.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:31.469]   - Field: ‘node’
[13:24:31.469]   - Field: ‘label’
[13:24:31.469]   - Field: ‘local’
[13:24:31.469]   - Field: ‘owner’
[13:24:31.470]   - Field: ‘envir’
[13:24:31.470]   - Field: ‘workers’
[13:24:31.470]   - Field: ‘packages’
[13:24:31.470]   - Field: ‘gc’
[13:24:31.470]   - Field: ‘conditions’
[13:24:31.470]   - Field: ‘persistent’
[13:24:31.470]   - Field: ‘expr’
[13:24:31.470]   - Field: ‘uuid’
[13:24:31.470]   - Field: ‘seed’
[13:24:31.470]   - Field: ‘version’
[13:24:31.471]   - Field: ‘result’
[13:24:31.471]   - Field: ‘asynchronous’
[13:24:31.471]   - Field: ‘calls’
[13:24:31.471]   - Field: ‘globals’
[13:24:31.471]   - Field: ‘stdout’
[13:24:31.471]   - Field: ‘earlySignal’
[13:24:31.471]   - Field: ‘lazy’
[13:24:31.471]   - Field: ‘state’
[13:24:31.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:31.471] - Launch lazy future ...
[13:24:31.472] Packages needed by the future expression (n = 0): <none>
[13:24:31.472] Packages needed by future strategies (n = 0): <none>
[13:24:31.472] {
[13:24:31.472]     {
[13:24:31.472]         {
[13:24:31.472]             ...future.startTime <- base::Sys.time()
[13:24:31.472]             {
[13:24:31.472]                 {
[13:24:31.472]                   {
[13:24:31.472]                     {
[13:24:31.472]                       base::local({
[13:24:31.472]                         has_future <- base::requireNamespace("future", 
[13:24:31.472]                           quietly = TRUE)
[13:24:31.472]                         if (has_future) {
[13:24:31.472]                           ns <- base::getNamespace("future")
[13:24:31.472]                           version <- ns[[".package"]][["version"]]
[13:24:31.472]                           if (is.null(version)) 
[13:24:31.472]                             version <- utils::packageVersion("future")
[13:24:31.472]                         }
[13:24:31.472]                         else {
[13:24:31.472]                           version <- NULL
[13:24:31.472]                         }
[13:24:31.472]                         if (!has_future || version < "1.8.0") {
[13:24:31.472]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:31.472]                             "", base::R.version$version.string), 
[13:24:31.472]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:31.472]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:31.472]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:31.472]                               "release", "version")], collapse = " "), 
[13:24:31.472]                             hostname = base::Sys.info()[["nodename"]])
[13:24:31.472]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:31.472]                             info)
[13:24:31.472]                           info <- base::paste(info, collapse = "; ")
[13:24:31.472]                           if (!has_future) {
[13:24:31.472]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:31.472]                               info)
[13:24:31.472]                           }
[13:24:31.472]                           else {
[13:24:31.472]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:31.472]                               info, version)
[13:24:31.472]                           }
[13:24:31.472]                           base::stop(msg)
[13:24:31.472]                         }
[13:24:31.472]                       })
[13:24:31.472]                     }
[13:24:31.472]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:31.472]                     base::options(mc.cores = 1L)
[13:24:31.472]                   }
[13:24:31.472]                   options(future.plan = NULL)
[13:24:31.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:31.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:31.472]                 }
[13:24:31.472]                 ...future.workdir <- getwd()
[13:24:31.472]             }
[13:24:31.472]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:31.472]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:31.472]         }
[13:24:31.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:31.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:31.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:31.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:31.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:31.472]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:31.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:31.472]             base::names(...future.oldOptions))
[13:24:31.472]     }
[13:24:31.472]     if (FALSE) {
[13:24:31.472]     }
[13:24:31.472]     else {
[13:24:31.472]         if (TRUE) {
[13:24:31.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:31.472]                 open = "w")
[13:24:31.472]         }
[13:24:31.472]         else {
[13:24:31.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:31.472]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:31.472]         }
[13:24:31.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:31.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:31.472]             base::sink(type = "output", split = FALSE)
[13:24:31.472]             base::close(...future.stdout)
[13:24:31.472]         }, add = TRUE)
[13:24:31.472]     }
[13:24:31.472]     ...future.frame <- base::sys.nframe()
[13:24:31.472]     ...future.conditions <- base::list()
[13:24:31.472]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:31.472]     if (FALSE) {
[13:24:31.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:31.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:31.472]     }
[13:24:31.472]     ...future.result <- base::tryCatch({
[13:24:31.472]         base::withCallingHandlers({
[13:24:31.472]             ...future.value <- base::withVisible(base::local({
[13:24:31.472]                 ...future.makeSendCondition <- base::local({
[13:24:31.472]                   sendCondition <- NULL
[13:24:31.472]                   function(frame = 1L) {
[13:24:31.472]                     if (is.function(sendCondition)) 
[13:24:31.472]                       return(sendCondition)
[13:24:31.472]                     ns <- getNamespace("parallel")
[13:24:31.472]                     if (exists("sendData", mode = "function", 
[13:24:31.472]                       envir = ns)) {
[13:24:31.472]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:31.472]                         envir = ns)
[13:24:31.472]                       envir <- sys.frame(frame)
[13:24:31.472]                       master <- NULL
[13:24:31.472]                       while (!identical(envir, .GlobalEnv) && 
[13:24:31.472]                         !identical(envir, emptyenv())) {
[13:24:31.472]                         if (exists("master", mode = "list", envir = envir, 
[13:24:31.472]                           inherits = FALSE)) {
[13:24:31.472]                           master <- get("master", mode = "list", 
[13:24:31.472]                             envir = envir, inherits = FALSE)
[13:24:31.472]                           if (inherits(master, c("SOCKnode", 
[13:24:31.472]                             "SOCK0node"))) {
[13:24:31.472]                             sendCondition <<- function(cond) {
[13:24:31.472]                               data <- list(type = "VALUE", value = cond, 
[13:24:31.472]                                 success = TRUE)
[13:24:31.472]                               parallel_sendData(master, data)
[13:24:31.472]                             }
[13:24:31.472]                             return(sendCondition)
[13:24:31.472]                           }
[13:24:31.472]                         }
[13:24:31.472]                         frame <- frame + 1L
[13:24:31.472]                         envir <- sys.frame(frame)
[13:24:31.472]                       }
[13:24:31.472]                     }
[13:24:31.472]                     sendCondition <<- function(cond) NULL
[13:24:31.472]                   }
[13:24:31.472]                 })
[13:24:31.472]                 withCallingHandlers({
[13:24:31.472]                   {
[13:24:31.472]                     Sys.sleep(0.5)
[13:24:31.472]                     list(a = 1, b = 42L)
[13:24:31.472]                   }
[13:24:31.472]                 }, immediateCondition = function(cond) {
[13:24:31.472]                   sendCondition <- ...future.makeSendCondition()
[13:24:31.472]                   sendCondition(cond)
[13:24:31.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:31.472]                   {
[13:24:31.472]                     inherits <- base::inherits
[13:24:31.472]                     invokeRestart <- base::invokeRestart
[13:24:31.472]                     is.null <- base::is.null
[13:24:31.472]                     muffled <- FALSE
[13:24:31.472]                     if (inherits(cond, "message")) {
[13:24:31.472]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:31.472]                       if (muffled) 
[13:24:31.472]                         invokeRestart("muffleMessage")
[13:24:31.472]                     }
[13:24:31.472]                     else if (inherits(cond, "warning")) {
[13:24:31.472]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:31.472]                       if (muffled) 
[13:24:31.472]                         invokeRestart("muffleWarning")
[13:24:31.472]                     }
[13:24:31.472]                     else if (inherits(cond, "condition")) {
[13:24:31.472]                       if (!is.null(pattern)) {
[13:24:31.472]                         computeRestarts <- base::computeRestarts
[13:24:31.472]                         grepl <- base::grepl
[13:24:31.472]                         restarts <- computeRestarts(cond)
[13:24:31.472]                         for (restart in restarts) {
[13:24:31.472]                           name <- restart$name
[13:24:31.472]                           if (is.null(name)) 
[13:24:31.472]                             next
[13:24:31.472]                           if (!grepl(pattern, name)) 
[13:24:31.472]                             next
[13:24:31.472]                           invokeRestart(restart)
[13:24:31.472]                           muffled <- TRUE
[13:24:31.472]                           break
[13:24:31.472]                         }
[13:24:31.472]                       }
[13:24:31.472]                     }
[13:24:31.472]                     invisible(muffled)
[13:24:31.472]                   }
[13:24:31.472]                   muffleCondition(cond)
[13:24:31.472]                 })
[13:24:31.472]             }))
[13:24:31.472]             future::FutureResult(value = ...future.value$value, 
[13:24:31.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:31.472]                   ...future.rng), globalenv = if (FALSE) 
[13:24:31.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:31.472]                     ...future.globalenv.names))
[13:24:31.472]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:31.472]         }, condition = base::local({
[13:24:31.472]             c <- base::c
[13:24:31.472]             inherits <- base::inherits
[13:24:31.472]             invokeRestart <- base::invokeRestart
[13:24:31.472]             length <- base::length
[13:24:31.472]             list <- base::list
[13:24:31.472]             seq.int <- base::seq.int
[13:24:31.472]             signalCondition <- base::signalCondition
[13:24:31.472]             sys.calls <- base::sys.calls
[13:24:31.472]             `[[` <- base::`[[`
[13:24:31.472]             `+` <- base::`+`
[13:24:31.472]             `<<-` <- base::`<<-`
[13:24:31.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:31.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:31.472]                   3L)]
[13:24:31.472]             }
[13:24:31.472]             function(cond) {
[13:24:31.472]                 is_error <- inherits(cond, "error")
[13:24:31.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:31.472]                   NULL)
[13:24:31.472]                 if (is_error) {
[13:24:31.472]                   sessionInformation <- function() {
[13:24:31.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:31.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:31.472]                       search = base::search(), system = base::Sys.info())
[13:24:31.472]                   }
[13:24:31.472]                   ...future.conditions[[length(...future.conditions) + 
[13:24:31.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:31.472]                     cond$call), session = sessionInformation(), 
[13:24:31.472]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:31.472]                   signalCondition(cond)
[13:24:31.472]                 }
[13:24:31.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:31.472]                 "immediateCondition"))) {
[13:24:31.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:31.472]                   ...future.conditions[[length(...future.conditions) + 
[13:24:31.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:31.472]                   if (TRUE && !signal) {
[13:24:31.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:31.472]                     {
[13:24:31.472]                       inherits <- base::inherits
[13:24:31.472]                       invokeRestart <- base::invokeRestart
[13:24:31.472]                       is.null <- base::is.null
[13:24:31.472]                       muffled <- FALSE
[13:24:31.472]                       if (inherits(cond, "message")) {
[13:24:31.472]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:31.472]                         if (muffled) 
[13:24:31.472]                           invokeRestart("muffleMessage")
[13:24:31.472]                       }
[13:24:31.472]                       else if (inherits(cond, "warning")) {
[13:24:31.472]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:31.472]                         if (muffled) 
[13:24:31.472]                           invokeRestart("muffleWarning")
[13:24:31.472]                       }
[13:24:31.472]                       else if (inherits(cond, "condition")) {
[13:24:31.472]                         if (!is.null(pattern)) {
[13:24:31.472]                           computeRestarts <- base::computeRestarts
[13:24:31.472]                           grepl <- base::grepl
[13:24:31.472]                           restarts <- computeRestarts(cond)
[13:24:31.472]                           for (restart in restarts) {
[13:24:31.472]                             name <- restart$name
[13:24:31.472]                             if (is.null(name)) 
[13:24:31.472]                               next
[13:24:31.472]                             if (!grepl(pattern, name)) 
[13:24:31.472]                               next
[13:24:31.472]                             invokeRestart(restart)
[13:24:31.472]                             muffled <- TRUE
[13:24:31.472]                             break
[13:24:31.472]                           }
[13:24:31.472]                         }
[13:24:31.472]                       }
[13:24:31.472]                       invisible(muffled)
[13:24:31.472]                     }
[13:24:31.472]                     muffleCondition(cond, pattern = "^muffle")
[13:24:31.472]                   }
[13:24:31.472]                 }
[13:24:31.472]                 else {
[13:24:31.472]                   if (TRUE) {
[13:24:31.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:31.472]                     {
[13:24:31.472]                       inherits <- base::inherits
[13:24:31.472]                       invokeRestart <- base::invokeRestart
[13:24:31.472]                       is.null <- base::is.null
[13:24:31.472]                       muffled <- FALSE
[13:24:31.472]                       if (inherits(cond, "message")) {
[13:24:31.472]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:31.472]                         if (muffled) 
[13:24:31.472]                           invokeRestart("muffleMessage")
[13:24:31.472]                       }
[13:24:31.472]                       else if (inherits(cond, "warning")) {
[13:24:31.472]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:31.472]                         if (muffled) 
[13:24:31.472]                           invokeRestart("muffleWarning")
[13:24:31.472]                       }
[13:24:31.472]                       else if (inherits(cond, "condition")) {
[13:24:31.472]                         if (!is.null(pattern)) {
[13:24:31.472]                           computeRestarts <- base::computeRestarts
[13:24:31.472]                           grepl <- base::grepl
[13:24:31.472]                           restarts <- computeRestarts(cond)
[13:24:31.472]                           for (restart in restarts) {
[13:24:31.472]                             name <- restart$name
[13:24:31.472]                             if (is.null(name)) 
[13:24:31.472]                               next
[13:24:31.472]                             if (!grepl(pattern, name)) 
[13:24:31.472]                               next
[13:24:31.472]                             invokeRestart(restart)
[13:24:31.472]                             muffled <- TRUE
[13:24:31.472]                             break
[13:24:31.472]                           }
[13:24:31.472]                         }
[13:24:31.472]                       }
[13:24:31.472]                       invisible(muffled)
[13:24:31.472]                     }
[13:24:31.472]                     muffleCondition(cond, pattern = "^muffle")
[13:24:31.472]                   }
[13:24:31.472]                 }
[13:24:31.472]             }
[13:24:31.472]         }))
[13:24:31.472]     }, error = function(ex) {
[13:24:31.472]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:31.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:31.472]                 ...future.rng), started = ...future.startTime, 
[13:24:31.472]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:31.472]             version = "1.8"), class = "FutureResult")
[13:24:31.472]     }, finally = {
[13:24:31.472]         if (!identical(...future.workdir, getwd())) 
[13:24:31.472]             setwd(...future.workdir)
[13:24:31.472]         {
[13:24:31.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:31.472]                 ...future.oldOptions$nwarnings <- NULL
[13:24:31.472]             }
[13:24:31.472]             base::options(...future.oldOptions)
[13:24:31.472]             if (.Platform$OS.type == "windows") {
[13:24:31.472]                 old_names <- names(...future.oldEnvVars)
[13:24:31.472]                 envs <- base::Sys.getenv()
[13:24:31.472]                 names <- names(envs)
[13:24:31.472]                 common <- intersect(names, old_names)
[13:24:31.472]                 added <- setdiff(names, old_names)
[13:24:31.472]                 removed <- setdiff(old_names, names)
[13:24:31.472]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:31.472]                   envs[common]]
[13:24:31.472]                 NAMES <- toupper(changed)
[13:24:31.472]                 args <- list()
[13:24:31.472]                 for (kk in seq_along(NAMES)) {
[13:24:31.472]                   name <- changed[[kk]]
[13:24:31.472]                   NAME <- NAMES[[kk]]
[13:24:31.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:31.472]                     next
[13:24:31.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:31.472]                 }
[13:24:31.472]                 NAMES <- toupper(added)
[13:24:31.472]                 for (kk in seq_along(NAMES)) {
[13:24:31.472]                   name <- added[[kk]]
[13:24:31.472]                   NAME <- NAMES[[kk]]
[13:24:31.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:31.472]                     next
[13:24:31.472]                   args[[name]] <- ""
[13:24:31.472]                 }
[13:24:31.472]                 NAMES <- toupper(removed)
[13:24:31.472]                 for (kk in seq_along(NAMES)) {
[13:24:31.472]                   name <- removed[[kk]]
[13:24:31.472]                   NAME <- NAMES[[kk]]
[13:24:31.472]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:31.472]                     next
[13:24:31.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:31.472]                 }
[13:24:31.472]                 if (length(args) > 0) 
[13:24:31.472]                   base::do.call(base::Sys.setenv, args = args)
[13:24:31.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:31.472]             }
[13:24:31.472]             else {
[13:24:31.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:31.472]             }
[13:24:31.472]             {
[13:24:31.472]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:31.472]                   0L) {
[13:24:31.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:31.472]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:31.472]                   base::options(opts)
[13:24:31.472]                 }
[13:24:31.472]                 {
[13:24:31.472]                   {
[13:24:31.472]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:31.472]                     NULL
[13:24:31.472]                   }
[13:24:31.472]                   options(future.plan = NULL)
[13:24:31.472]                   if (is.na(NA_character_)) 
[13:24:31.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:31.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:31.472]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:31.472]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:31.472]                     envir = parent.frame()) 
[13:24:31.472]                   {
[13:24:31.472]                     if (is.function(workers)) 
[13:24:31.472]                       workers <- workers()
[13:24:31.472]                     workers <- structure(as.integer(workers), 
[13:24:31.472]                       class = class(workers))
[13:24:31.472]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:31.472]                       workers >= 1)
[13:24:31.472]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:31.472]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:31.472]                     }
[13:24:31.472]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:31.472]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:31.472]                       envir = envir)
[13:24:31.472]                     if (!future$lazy) 
[13:24:31.472]                       future <- run(future)
[13:24:31.472]                     invisible(future)
[13:24:31.472]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:31.472]                 }
[13:24:31.472]             }
[13:24:31.472]         }
[13:24:31.472]     })
[13:24:31.472]     if (TRUE) {
[13:24:31.472]         base::sink(type = "output", split = FALSE)
[13:24:31.472]         if (TRUE) {
[13:24:31.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:31.472]         }
[13:24:31.472]         else {
[13:24:31.472]             ...future.result["stdout"] <- base::list(NULL)
[13:24:31.472]         }
[13:24:31.472]         base::close(...future.stdout)
[13:24:31.472]         ...future.stdout <- NULL
[13:24:31.472]     }
[13:24:31.472]     ...future.result$conditions <- ...future.conditions
[13:24:31.472]     ...future.result$finished <- base::Sys.time()
[13:24:31.472]     ...future.result
[13:24:31.472] }
[13:24:31.475] MultisessionFuture started
[13:24:31.476] - Launch lazy future ... done
[13:24:31.476] run() for ‘MultisessionFuture’ ... done
[13:24:32.022] receiveMessageFromWorker() for ClusterFuture ...
[13:24:32.022] - Validating connection of MultisessionFuture
[13:24:32.022] - received message: FutureResult
[13:24:32.022] - Received FutureResult
[13:24:32.023] - Erased future from FutureRegistry
[13:24:32.023] result() for ClusterFuture ...
[13:24:32.023] - result already collected: FutureResult
[13:24:32.023] result() for ClusterFuture ... done
[13:24:32.023] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:32.023] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:24:32.023] getGlobalsAndPackages() ...
[13:24:32.023] Searching for globals...
[13:24:32.024] - globals found: [2] ‘list’, ‘stop’
[13:24:32.024] Searching for globals ... DONE
[13:24:32.024] Resolving globals: FALSE
[13:24:32.025] 
[13:24:32.025] 
[13:24:32.025] getGlobalsAndPackages() ... DONE
[13:24:32.025] run() for ‘Future’ ...
[13:24:32.025] - state: ‘created’
[13:24:32.025] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:32.039] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:32.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:32.040]   - Field: ‘node’
[13:24:32.040]   - Field: ‘label’
[13:24:32.040]   - Field: ‘local’
[13:24:32.040]   - Field: ‘owner’
[13:24:32.040]   - Field: ‘envir’
[13:24:32.040]   - Field: ‘workers’
[13:24:32.040]   - Field: ‘packages’
[13:24:32.040]   - Field: ‘gc’
[13:24:32.041]   - Field: ‘conditions’
[13:24:32.041]   - Field: ‘persistent’
[13:24:32.041]   - Field: ‘expr’
[13:24:32.041]   - Field: ‘uuid’
[13:24:32.041]   - Field: ‘seed’
[13:24:32.041]   - Field: ‘version’
[13:24:32.041]   - Field: ‘result’
[13:24:32.041]   - Field: ‘asynchronous’
[13:24:32.041]   - Field: ‘calls’
[13:24:32.041]   - Field: ‘globals’
[13:24:32.041]   - Field: ‘stdout’
[13:24:32.042]   - Field: ‘earlySignal’
[13:24:32.042]   - Field: ‘lazy’
[13:24:32.042]   - Field: ‘state’
[13:24:32.042] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:32.042] - Launch lazy future ...
[13:24:32.042] Packages needed by the future expression (n = 0): <none>
[13:24:32.042] Packages needed by future strategies (n = 0): <none>
[13:24:32.043] {
[13:24:32.043]     {
[13:24:32.043]         {
[13:24:32.043]             ...future.startTime <- base::Sys.time()
[13:24:32.043]             {
[13:24:32.043]                 {
[13:24:32.043]                   {
[13:24:32.043]                     {
[13:24:32.043]                       base::local({
[13:24:32.043]                         has_future <- base::requireNamespace("future", 
[13:24:32.043]                           quietly = TRUE)
[13:24:32.043]                         if (has_future) {
[13:24:32.043]                           ns <- base::getNamespace("future")
[13:24:32.043]                           version <- ns[[".package"]][["version"]]
[13:24:32.043]                           if (is.null(version)) 
[13:24:32.043]                             version <- utils::packageVersion("future")
[13:24:32.043]                         }
[13:24:32.043]                         else {
[13:24:32.043]                           version <- NULL
[13:24:32.043]                         }
[13:24:32.043]                         if (!has_future || version < "1.8.0") {
[13:24:32.043]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:32.043]                             "", base::R.version$version.string), 
[13:24:32.043]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:32.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:32.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:32.043]                               "release", "version")], collapse = " "), 
[13:24:32.043]                             hostname = base::Sys.info()[["nodename"]])
[13:24:32.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:32.043]                             info)
[13:24:32.043]                           info <- base::paste(info, collapse = "; ")
[13:24:32.043]                           if (!has_future) {
[13:24:32.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:32.043]                               info)
[13:24:32.043]                           }
[13:24:32.043]                           else {
[13:24:32.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:32.043]                               info, version)
[13:24:32.043]                           }
[13:24:32.043]                           base::stop(msg)
[13:24:32.043]                         }
[13:24:32.043]                       })
[13:24:32.043]                     }
[13:24:32.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:32.043]                     base::options(mc.cores = 1L)
[13:24:32.043]                   }
[13:24:32.043]                   options(future.plan = NULL)
[13:24:32.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:32.043]                 }
[13:24:32.043]                 ...future.workdir <- getwd()
[13:24:32.043]             }
[13:24:32.043]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:32.043]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:32.043]         }
[13:24:32.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:32.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:32.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:32.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:32.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:32.043]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:32.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:32.043]             base::names(...future.oldOptions))
[13:24:32.043]     }
[13:24:32.043]     if (FALSE) {
[13:24:32.043]     }
[13:24:32.043]     else {
[13:24:32.043]         if (TRUE) {
[13:24:32.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:32.043]                 open = "w")
[13:24:32.043]         }
[13:24:32.043]         else {
[13:24:32.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:32.043]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:32.043]         }
[13:24:32.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:32.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:32.043]             base::sink(type = "output", split = FALSE)
[13:24:32.043]             base::close(...future.stdout)
[13:24:32.043]         }, add = TRUE)
[13:24:32.043]     }
[13:24:32.043]     ...future.frame <- base::sys.nframe()
[13:24:32.043]     ...future.conditions <- base::list()
[13:24:32.043]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:32.043]     if (FALSE) {
[13:24:32.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:32.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:32.043]     }
[13:24:32.043]     ...future.result <- base::tryCatch({
[13:24:32.043]         base::withCallingHandlers({
[13:24:32.043]             ...future.value <- base::withVisible(base::local({
[13:24:32.043]                 ...future.makeSendCondition <- base::local({
[13:24:32.043]                   sendCondition <- NULL
[13:24:32.043]                   function(frame = 1L) {
[13:24:32.043]                     if (is.function(sendCondition)) 
[13:24:32.043]                       return(sendCondition)
[13:24:32.043]                     ns <- getNamespace("parallel")
[13:24:32.043]                     if (exists("sendData", mode = "function", 
[13:24:32.043]                       envir = ns)) {
[13:24:32.043]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:32.043]                         envir = ns)
[13:24:32.043]                       envir <- sys.frame(frame)
[13:24:32.043]                       master <- NULL
[13:24:32.043]                       while (!identical(envir, .GlobalEnv) && 
[13:24:32.043]                         !identical(envir, emptyenv())) {
[13:24:32.043]                         if (exists("master", mode = "list", envir = envir, 
[13:24:32.043]                           inherits = FALSE)) {
[13:24:32.043]                           master <- get("master", mode = "list", 
[13:24:32.043]                             envir = envir, inherits = FALSE)
[13:24:32.043]                           if (inherits(master, c("SOCKnode", 
[13:24:32.043]                             "SOCK0node"))) {
[13:24:32.043]                             sendCondition <<- function(cond) {
[13:24:32.043]                               data <- list(type = "VALUE", value = cond, 
[13:24:32.043]                                 success = TRUE)
[13:24:32.043]                               parallel_sendData(master, data)
[13:24:32.043]                             }
[13:24:32.043]                             return(sendCondition)
[13:24:32.043]                           }
[13:24:32.043]                         }
[13:24:32.043]                         frame <- frame + 1L
[13:24:32.043]                         envir <- sys.frame(frame)
[13:24:32.043]                       }
[13:24:32.043]                     }
[13:24:32.043]                     sendCondition <<- function(cond) NULL
[13:24:32.043]                   }
[13:24:32.043]                 })
[13:24:32.043]                 withCallingHandlers({
[13:24:32.043]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:32.043]                 }, immediateCondition = function(cond) {
[13:24:32.043]                   sendCondition <- ...future.makeSendCondition()
[13:24:32.043]                   sendCondition(cond)
[13:24:32.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.043]                   {
[13:24:32.043]                     inherits <- base::inherits
[13:24:32.043]                     invokeRestart <- base::invokeRestart
[13:24:32.043]                     is.null <- base::is.null
[13:24:32.043]                     muffled <- FALSE
[13:24:32.043]                     if (inherits(cond, "message")) {
[13:24:32.043]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:32.043]                       if (muffled) 
[13:24:32.043]                         invokeRestart("muffleMessage")
[13:24:32.043]                     }
[13:24:32.043]                     else if (inherits(cond, "warning")) {
[13:24:32.043]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:32.043]                       if (muffled) 
[13:24:32.043]                         invokeRestart("muffleWarning")
[13:24:32.043]                     }
[13:24:32.043]                     else if (inherits(cond, "condition")) {
[13:24:32.043]                       if (!is.null(pattern)) {
[13:24:32.043]                         computeRestarts <- base::computeRestarts
[13:24:32.043]                         grepl <- base::grepl
[13:24:32.043]                         restarts <- computeRestarts(cond)
[13:24:32.043]                         for (restart in restarts) {
[13:24:32.043]                           name <- restart$name
[13:24:32.043]                           if (is.null(name)) 
[13:24:32.043]                             next
[13:24:32.043]                           if (!grepl(pattern, name)) 
[13:24:32.043]                             next
[13:24:32.043]                           invokeRestart(restart)
[13:24:32.043]                           muffled <- TRUE
[13:24:32.043]                           break
[13:24:32.043]                         }
[13:24:32.043]                       }
[13:24:32.043]                     }
[13:24:32.043]                     invisible(muffled)
[13:24:32.043]                   }
[13:24:32.043]                   muffleCondition(cond)
[13:24:32.043]                 })
[13:24:32.043]             }))
[13:24:32.043]             future::FutureResult(value = ...future.value$value, 
[13:24:32.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.043]                   ...future.rng), globalenv = if (FALSE) 
[13:24:32.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:32.043]                     ...future.globalenv.names))
[13:24:32.043]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:32.043]         }, condition = base::local({
[13:24:32.043]             c <- base::c
[13:24:32.043]             inherits <- base::inherits
[13:24:32.043]             invokeRestart <- base::invokeRestart
[13:24:32.043]             length <- base::length
[13:24:32.043]             list <- base::list
[13:24:32.043]             seq.int <- base::seq.int
[13:24:32.043]             signalCondition <- base::signalCondition
[13:24:32.043]             sys.calls <- base::sys.calls
[13:24:32.043]             `[[` <- base::`[[`
[13:24:32.043]             `+` <- base::`+`
[13:24:32.043]             `<<-` <- base::`<<-`
[13:24:32.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:32.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:32.043]                   3L)]
[13:24:32.043]             }
[13:24:32.043]             function(cond) {
[13:24:32.043]                 is_error <- inherits(cond, "error")
[13:24:32.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:32.043]                   NULL)
[13:24:32.043]                 if (is_error) {
[13:24:32.043]                   sessionInformation <- function() {
[13:24:32.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:32.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:32.043]                       search = base::search(), system = base::Sys.info())
[13:24:32.043]                   }
[13:24:32.043]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:32.043]                     cond$call), session = sessionInformation(), 
[13:24:32.043]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:32.043]                   signalCondition(cond)
[13:24:32.043]                 }
[13:24:32.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:32.043]                 "immediateCondition"))) {
[13:24:32.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:32.043]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:32.043]                   if (TRUE && !signal) {
[13:24:32.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.043]                     {
[13:24:32.043]                       inherits <- base::inherits
[13:24:32.043]                       invokeRestart <- base::invokeRestart
[13:24:32.043]                       is.null <- base::is.null
[13:24:32.043]                       muffled <- FALSE
[13:24:32.043]                       if (inherits(cond, "message")) {
[13:24:32.043]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.043]                         if (muffled) 
[13:24:32.043]                           invokeRestart("muffleMessage")
[13:24:32.043]                       }
[13:24:32.043]                       else if (inherits(cond, "warning")) {
[13:24:32.043]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.043]                         if (muffled) 
[13:24:32.043]                           invokeRestart("muffleWarning")
[13:24:32.043]                       }
[13:24:32.043]                       else if (inherits(cond, "condition")) {
[13:24:32.043]                         if (!is.null(pattern)) {
[13:24:32.043]                           computeRestarts <- base::computeRestarts
[13:24:32.043]                           grepl <- base::grepl
[13:24:32.043]                           restarts <- computeRestarts(cond)
[13:24:32.043]                           for (restart in restarts) {
[13:24:32.043]                             name <- restart$name
[13:24:32.043]                             if (is.null(name)) 
[13:24:32.043]                               next
[13:24:32.043]                             if (!grepl(pattern, name)) 
[13:24:32.043]                               next
[13:24:32.043]                             invokeRestart(restart)
[13:24:32.043]                             muffled <- TRUE
[13:24:32.043]                             break
[13:24:32.043]                           }
[13:24:32.043]                         }
[13:24:32.043]                       }
[13:24:32.043]                       invisible(muffled)
[13:24:32.043]                     }
[13:24:32.043]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.043]                   }
[13:24:32.043]                 }
[13:24:32.043]                 else {
[13:24:32.043]                   if (TRUE) {
[13:24:32.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.043]                     {
[13:24:32.043]                       inherits <- base::inherits
[13:24:32.043]                       invokeRestart <- base::invokeRestart
[13:24:32.043]                       is.null <- base::is.null
[13:24:32.043]                       muffled <- FALSE
[13:24:32.043]                       if (inherits(cond, "message")) {
[13:24:32.043]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.043]                         if (muffled) 
[13:24:32.043]                           invokeRestart("muffleMessage")
[13:24:32.043]                       }
[13:24:32.043]                       else if (inherits(cond, "warning")) {
[13:24:32.043]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.043]                         if (muffled) 
[13:24:32.043]                           invokeRestart("muffleWarning")
[13:24:32.043]                       }
[13:24:32.043]                       else if (inherits(cond, "condition")) {
[13:24:32.043]                         if (!is.null(pattern)) {
[13:24:32.043]                           computeRestarts <- base::computeRestarts
[13:24:32.043]                           grepl <- base::grepl
[13:24:32.043]                           restarts <- computeRestarts(cond)
[13:24:32.043]                           for (restart in restarts) {
[13:24:32.043]                             name <- restart$name
[13:24:32.043]                             if (is.null(name)) 
[13:24:32.043]                               next
[13:24:32.043]                             if (!grepl(pattern, name)) 
[13:24:32.043]                               next
[13:24:32.043]                             invokeRestart(restart)
[13:24:32.043]                             muffled <- TRUE
[13:24:32.043]                             break
[13:24:32.043]                           }
[13:24:32.043]                         }
[13:24:32.043]                       }
[13:24:32.043]                       invisible(muffled)
[13:24:32.043]                     }
[13:24:32.043]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.043]                   }
[13:24:32.043]                 }
[13:24:32.043]             }
[13:24:32.043]         }))
[13:24:32.043]     }, error = function(ex) {
[13:24:32.043]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:32.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.043]                 ...future.rng), started = ...future.startTime, 
[13:24:32.043]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:32.043]             version = "1.8"), class = "FutureResult")
[13:24:32.043]     }, finally = {
[13:24:32.043]         if (!identical(...future.workdir, getwd())) 
[13:24:32.043]             setwd(...future.workdir)
[13:24:32.043]         {
[13:24:32.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:32.043]                 ...future.oldOptions$nwarnings <- NULL
[13:24:32.043]             }
[13:24:32.043]             base::options(...future.oldOptions)
[13:24:32.043]             if (.Platform$OS.type == "windows") {
[13:24:32.043]                 old_names <- names(...future.oldEnvVars)
[13:24:32.043]                 envs <- base::Sys.getenv()
[13:24:32.043]                 names <- names(envs)
[13:24:32.043]                 common <- intersect(names, old_names)
[13:24:32.043]                 added <- setdiff(names, old_names)
[13:24:32.043]                 removed <- setdiff(old_names, names)
[13:24:32.043]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:32.043]                   envs[common]]
[13:24:32.043]                 NAMES <- toupper(changed)
[13:24:32.043]                 args <- list()
[13:24:32.043]                 for (kk in seq_along(NAMES)) {
[13:24:32.043]                   name <- changed[[kk]]
[13:24:32.043]                   NAME <- NAMES[[kk]]
[13:24:32.043]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.043]                     next
[13:24:32.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.043]                 }
[13:24:32.043]                 NAMES <- toupper(added)
[13:24:32.043]                 for (kk in seq_along(NAMES)) {
[13:24:32.043]                   name <- added[[kk]]
[13:24:32.043]                   NAME <- NAMES[[kk]]
[13:24:32.043]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.043]                     next
[13:24:32.043]                   args[[name]] <- ""
[13:24:32.043]                 }
[13:24:32.043]                 NAMES <- toupper(removed)
[13:24:32.043]                 for (kk in seq_along(NAMES)) {
[13:24:32.043]                   name <- removed[[kk]]
[13:24:32.043]                   NAME <- NAMES[[kk]]
[13:24:32.043]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.043]                     next
[13:24:32.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.043]                 }
[13:24:32.043]                 if (length(args) > 0) 
[13:24:32.043]                   base::do.call(base::Sys.setenv, args = args)
[13:24:32.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:32.043]             }
[13:24:32.043]             else {
[13:24:32.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:32.043]             }
[13:24:32.043]             {
[13:24:32.043]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:32.043]                   0L) {
[13:24:32.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:32.043]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:32.043]                   base::options(opts)
[13:24:32.043]                 }
[13:24:32.043]                 {
[13:24:32.043]                   {
[13:24:32.043]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:32.043]                     NULL
[13:24:32.043]                   }
[13:24:32.043]                   options(future.plan = NULL)
[13:24:32.043]                   if (is.na(NA_character_)) 
[13:24:32.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:32.043]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:32.043]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:32.043]                     envir = parent.frame()) 
[13:24:32.043]                   {
[13:24:32.043]                     if (is.function(workers)) 
[13:24:32.043]                       workers <- workers()
[13:24:32.043]                     workers <- structure(as.integer(workers), 
[13:24:32.043]                       class = class(workers))
[13:24:32.043]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:32.043]                       workers >= 1)
[13:24:32.043]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:32.043]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:32.043]                     }
[13:24:32.043]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:32.043]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:32.043]                       envir = envir)
[13:24:32.043]                     if (!future$lazy) 
[13:24:32.043]                       future <- run(future)
[13:24:32.043]                     invisible(future)
[13:24:32.043]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:32.043]                 }
[13:24:32.043]             }
[13:24:32.043]         }
[13:24:32.043]     })
[13:24:32.043]     if (TRUE) {
[13:24:32.043]         base::sink(type = "output", split = FALSE)
[13:24:32.043]         if (TRUE) {
[13:24:32.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:32.043]         }
[13:24:32.043]         else {
[13:24:32.043]             ...future.result["stdout"] <- base::list(NULL)
[13:24:32.043]         }
[13:24:32.043]         base::close(...future.stdout)
[13:24:32.043]         ...future.stdout <- NULL
[13:24:32.043]     }
[13:24:32.043]     ...future.result$conditions <- ...future.conditions
[13:24:32.043]     ...future.result$finished <- base::Sys.time()
[13:24:32.043]     ...future.result
[13:24:32.043] }
[13:24:32.046] MultisessionFuture started
[13:24:32.046] - Launch lazy future ... done
[13:24:32.046] run() for ‘MultisessionFuture’ ... done
[13:24:32.093] receiveMessageFromWorker() for ClusterFuture ...
[13:24:32.094] - Validating connection of MultisessionFuture
[13:24:32.094] - received message: FutureResult
[13:24:32.094] - Received FutureResult
[13:24:32.094] - Erased future from FutureRegistry
[13:24:32.095] result() for ClusterFuture ...
[13:24:32.095] - result already collected: FutureResult
[13:24:32.095] result() for ClusterFuture ... done
[13:24:32.095] signalConditions() ...
[13:24:32.095]  - include = ‘immediateCondition’
[13:24:32.095]  - exclude = 
[13:24:32.095]  - resignal = FALSE
[13:24:32.095]  - Number of conditions: 1
[13:24:32.095] signalConditions() ... done
[13:24:32.095] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:32.095] A MultisessionFuture was resolved (result was not collected)
[13:24:32.096] getGlobalsAndPackages() ...
[13:24:32.096] Searching for globals...
[13:24:32.096] - globals found: [2] ‘list’, ‘stop’
[13:24:32.097] Searching for globals ... DONE
[13:24:32.097] Resolving globals: FALSE
[13:24:32.097] 
[13:24:32.097] 
[13:24:32.097] getGlobalsAndPackages() ... DONE
[13:24:32.097] run() for ‘Future’ ...
[13:24:32.098] - state: ‘created’
[13:24:32.098] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:32.111] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:32.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:32.112]   - Field: ‘node’
[13:24:32.112]   - Field: ‘label’
[13:24:32.112]   - Field: ‘local’
[13:24:32.112]   - Field: ‘owner’
[13:24:32.112]   - Field: ‘envir’
[13:24:32.112]   - Field: ‘workers’
[13:24:32.112]   - Field: ‘packages’
[13:24:32.112]   - Field: ‘gc’
[13:24:32.112]   - Field: ‘conditions’
[13:24:32.113]   - Field: ‘persistent’
[13:24:32.113]   - Field: ‘expr’
[13:24:32.113]   - Field: ‘uuid’
[13:24:32.113]   - Field: ‘seed’
[13:24:32.113]   - Field: ‘version’
[13:24:32.113]   - Field: ‘result’
[13:24:32.113]   - Field: ‘asynchronous’
[13:24:32.113]   - Field: ‘calls’
[13:24:32.113]   - Field: ‘globals’
[13:24:32.113]   - Field: ‘stdout’
[13:24:32.113]   - Field: ‘earlySignal’
[13:24:32.114]   - Field: ‘lazy’
[13:24:32.114]   - Field: ‘state’
[13:24:32.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:32.114] - Launch lazy future ...
[13:24:32.114] Packages needed by the future expression (n = 0): <none>
[13:24:32.114] Packages needed by future strategies (n = 0): <none>
[13:24:32.115] {
[13:24:32.115]     {
[13:24:32.115]         {
[13:24:32.115]             ...future.startTime <- base::Sys.time()
[13:24:32.115]             {
[13:24:32.115]                 {
[13:24:32.115]                   {
[13:24:32.115]                     {
[13:24:32.115]                       base::local({
[13:24:32.115]                         has_future <- base::requireNamespace("future", 
[13:24:32.115]                           quietly = TRUE)
[13:24:32.115]                         if (has_future) {
[13:24:32.115]                           ns <- base::getNamespace("future")
[13:24:32.115]                           version <- ns[[".package"]][["version"]]
[13:24:32.115]                           if (is.null(version)) 
[13:24:32.115]                             version <- utils::packageVersion("future")
[13:24:32.115]                         }
[13:24:32.115]                         else {
[13:24:32.115]                           version <- NULL
[13:24:32.115]                         }
[13:24:32.115]                         if (!has_future || version < "1.8.0") {
[13:24:32.115]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:32.115]                             "", base::R.version$version.string), 
[13:24:32.115]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:32.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:32.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:32.115]                               "release", "version")], collapse = " "), 
[13:24:32.115]                             hostname = base::Sys.info()[["nodename"]])
[13:24:32.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:32.115]                             info)
[13:24:32.115]                           info <- base::paste(info, collapse = "; ")
[13:24:32.115]                           if (!has_future) {
[13:24:32.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:32.115]                               info)
[13:24:32.115]                           }
[13:24:32.115]                           else {
[13:24:32.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:32.115]                               info, version)
[13:24:32.115]                           }
[13:24:32.115]                           base::stop(msg)
[13:24:32.115]                         }
[13:24:32.115]                       })
[13:24:32.115]                     }
[13:24:32.115]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:32.115]                     base::options(mc.cores = 1L)
[13:24:32.115]                   }
[13:24:32.115]                   options(future.plan = NULL)
[13:24:32.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:32.115]                 }
[13:24:32.115]                 ...future.workdir <- getwd()
[13:24:32.115]             }
[13:24:32.115]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:32.115]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:32.115]         }
[13:24:32.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:32.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:32.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:32.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:32.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:32.115]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:32.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:32.115]             base::names(...future.oldOptions))
[13:24:32.115]     }
[13:24:32.115]     if (FALSE) {
[13:24:32.115]     }
[13:24:32.115]     else {
[13:24:32.115]         if (TRUE) {
[13:24:32.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:32.115]                 open = "w")
[13:24:32.115]         }
[13:24:32.115]         else {
[13:24:32.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:32.115]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:32.115]         }
[13:24:32.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:32.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:32.115]             base::sink(type = "output", split = FALSE)
[13:24:32.115]             base::close(...future.stdout)
[13:24:32.115]         }, add = TRUE)
[13:24:32.115]     }
[13:24:32.115]     ...future.frame <- base::sys.nframe()
[13:24:32.115]     ...future.conditions <- base::list()
[13:24:32.115]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:32.115]     if (FALSE) {
[13:24:32.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:32.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:32.115]     }
[13:24:32.115]     ...future.result <- base::tryCatch({
[13:24:32.115]         base::withCallingHandlers({
[13:24:32.115]             ...future.value <- base::withVisible(base::local({
[13:24:32.115]                 ...future.makeSendCondition <- base::local({
[13:24:32.115]                   sendCondition <- NULL
[13:24:32.115]                   function(frame = 1L) {
[13:24:32.115]                     if (is.function(sendCondition)) 
[13:24:32.115]                       return(sendCondition)
[13:24:32.115]                     ns <- getNamespace("parallel")
[13:24:32.115]                     if (exists("sendData", mode = "function", 
[13:24:32.115]                       envir = ns)) {
[13:24:32.115]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:32.115]                         envir = ns)
[13:24:32.115]                       envir <- sys.frame(frame)
[13:24:32.115]                       master <- NULL
[13:24:32.115]                       while (!identical(envir, .GlobalEnv) && 
[13:24:32.115]                         !identical(envir, emptyenv())) {
[13:24:32.115]                         if (exists("master", mode = "list", envir = envir, 
[13:24:32.115]                           inherits = FALSE)) {
[13:24:32.115]                           master <- get("master", mode = "list", 
[13:24:32.115]                             envir = envir, inherits = FALSE)
[13:24:32.115]                           if (inherits(master, c("SOCKnode", 
[13:24:32.115]                             "SOCK0node"))) {
[13:24:32.115]                             sendCondition <<- function(cond) {
[13:24:32.115]                               data <- list(type = "VALUE", value = cond, 
[13:24:32.115]                                 success = TRUE)
[13:24:32.115]                               parallel_sendData(master, data)
[13:24:32.115]                             }
[13:24:32.115]                             return(sendCondition)
[13:24:32.115]                           }
[13:24:32.115]                         }
[13:24:32.115]                         frame <- frame + 1L
[13:24:32.115]                         envir <- sys.frame(frame)
[13:24:32.115]                       }
[13:24:32.115]                     }
[13:24:32.115]                     sendCondition <<- function(cond) NULL
[13:24:32.115]                   }
[13:24:32.115]                 })
[13:24:32.115]                 withCallingHandlers({
[13:24:32.115]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:32.115]                 }, immediateCondition = function(cond) {
[13:24:32.115]                   sendCondition <- ...future.makeSendCondition()
[13:24:32.115]                   sendCondition(cond)
[13:24:32.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.115]                   {
[13:24:32.115]                     inherits <- base::inherits
[13:24:32.115]                     invokeRestart <- base::invokeRestart
[13:24:32.115]                     is.null <- base::is.null
[13:24:32.115]                     muffled <- FALSE
[13:24:32.115]                     if (inherits(cond, "message")) {
[13:24:32.115]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:32.115]                       if (muffled) 
[13:24:32.115]                         invokeRestart("muffleMessage")
[13:24:32.115]                     }
[13:24:32.115]                     else if (inherits(cond, "warning")) {
[13:24:32.115]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:32.115]                       if (muffled) 
[13:24:32.115]                         invokeRestart("muffleWarning")
[13:24:32.115]                     }
[13:24:32.115]                     else if (inherits(cond, "condition")) {
[13:24:32.115]                       if (!is.null(pattern)) {
[13:24:32.115]                         computeRestarts <- base::computeRestarts
[13:24:32.115]                         grepl <- base::grepl
[13:24:32.115]                         restarts <- computeRestarts(cond)
[13:24:32.115]                         for (restart in restarts) {
[13:24:32.115]                           name <- restart$name
[13:24:32.115]                           if (is.null(name)) 
[13:24:32.115]                             next
[13:24:32.115]                           if (!grepl(pattern, name)) 
[13:24:32.115]                             next
[13:24:32.115]                           invokeRestart(restart)
[13:24:32.115]                           muffled <- TRUE
[13:24:32.115]                           break
[13:24:32.115]                         }
[13:24:32.115]                       }
[13:24:32.115]                     }
[13:24:32.115]                     invisible(muffled)
[13:24:32.115]                   }
[13:24:32.115]                   muffleCondition(cond)
[13:24:32.115]                 })
[13:24:32.115]             }))
[13:24:32.115]             future::FutureResult(value = ...future.value$value, 
[13:24:32.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.115]                   ...future.rng), globalenv = if (FALSE) 
[13:24:32.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:32.115]                     ...future.globalenv.names))
[13:24:32.115]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:32.115]         }, condition = base::local({
[13:24:32.115]             c <- base::c
[13:24:32.115]             inherits <- base::inherits
[13:24:32.115]             invokeRestart <- base::invokeRestart
[13:24:32.115]             length <- base::length
[13:24:32.115]             list <- base::list
[13:24:32.115]             seq.int <- base::seq.int
[13:24:32.115]             signalCondition <- base::signalCondition
[13:24:32.115]             sys.calls <- base::sys.calls
[13:24:32.115]             `[[` <- base::`[[`
[13:24:32.115]             `+` <- base::`+`
[13:24:32.115]             `<<-` <- base::`<<-`
[13:24:32.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:32.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:32.115]                   3L)]
[13:24:32.115]             }
[13:24:32.115]             function(cond) {
[13:24:32.115]                 is_error <- inherits(cond, "error")
[13:24:32.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:32.115]                   NULL)
[13:24:32.115]                 if (is_error) {
[13:24:32.115]                   sessionInformation <- function() {
[13:24:32.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:32.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:32.115]                       search = base::search(), system = base::Sys.info())
[13:24:32.115]                   }
[13:24:32.115]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:32.115]                     cond$call), session = sessionInformation(), 
[13:24:32.115]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:32.115]                   signalCondition(cond)
[13:24:32.115]                 }
[13:24:32.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:32.115]                 "immediateCondition"))) {
[13:24:32.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:32.115]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:32.115]                   if (TRUE && !signal) {
[13:24:32.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.115]                     {
[13:24:32.115]                       inherits <- base::inherits
[13:24:32.115]                       invokeRestart <- base::invokeRestart
[13:24:32.115]                       is.null <- base::is.null
[13:24:32.115]                       muffled <- FALSE
[13:24:32.115]                       if (inherits(cond, "message")) {
[13:24:32.115]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.115]                         if (muffled) 
[13:24:32.115]                           invokeRestart("muffleMessage")
[13:24:32.115]                       }
[13:24:32.115]                       else if (inherits(cond, "warning")) {
[13:24:32.115]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.115]                         if (muffled) 
[13:24:32.115]                           invokeRestart("muffleWarning")
[13:24:32.115]                       }
[13:24:32.115]                       else if (inherits(cond, "condition")) {
[13:24:32.115]                         if (!is.null(pattern)) {
[13:24:32.115]                           computeRestarts <- base::computeRestarts
[13:24:32.115]                           grepl <- base::grepl
[13:24:32.115]                           restarts <- computeRestarts(cond)
[13:24:32.115]                           for (restart in restarts) {
[13:24:32.115]                             name <- restart$name
[13:24:32.115]                             if (is.null(name)) 
[13:24:32.115]                               next
[13:24:32.115]                             if (!grepl(pattern, name)) 
[13:24:32.115]                               next
[13:24:32.115]                             invokeRestart(restart)
[13:24:32.115]                             muffled <- TRUE
[13:24:32.115]                             break
[13:24:32.115]                           }
[13:24:32.115]                         }
[13:24:32.115]                       }
[13:24:32.115]                       invisible(muffled)
[13:24:32.115]                     }
[13:24:32.115]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.115]                   }
[13:24:32.115]                 }
[13:24:32.115]                 else {
[13:24:32.115]                   if (TRUE) {
[13:24:32.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.115]                     {
[13:24:32.115]                       inherits <- base::inherits
[13:24:32.115]                       invokeRestart <- base::invokeRestart
[13:24:32.115]                       is.null <- base::is.null
[13:24:32.115]                       muffled <- FALSE
[13:24:32.115]                       if (inherits(cond, "message")) {
[13:24:32.115]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.115]                         if (muffled) 
[13:24:32.115]                           invokeRestart("muffleMessage")
[13:24:32.115]                       }
[13:24:32.115]                       else if (inherits(cond, "warning")) {
[13:24:32.115]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.115]                         if (muffled) 
[13:24:32.115]                           invokeRestart("muffleWarning")
[13:24:32.115]                       }
[13:24:32.115]                       else if (inherits(cond, "condition")) {
[13:24:32.115]                         if (!is.null(pattern)) {
[13:24:32.115]                           computeRestarts <- base::computeRestarts
[13:24:32.115]                           grepl <- base::grepl
[13:24:32.115]                           restarts <- computeRestarts(cond)
[13:24:32.115]                           for (restart in restarts) {
[13:24:32.115]                             name <- restart$name
[13:24:32.115]                             if (is.null(name)) 
[13:24:32.115]                               next
[13:24:32.115]                             if (!grepl(pattern, name)) 
[13:24:32.115]                               next
[13:24:32.115]                             invokeRestart(restart)
[13:24:32.115]                             muffled <- TRUE
[13:24:32.115]                             break
[13:24:32.115]                           }
[13:24:32.115]                         }
[13:24:32.115]                       }
[13:24:32.115]                       invisible(muffled)
[13:24:32.115]                     }
[13:24:32.115]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.115]                   }
[13:24:32.115]                 }
[13:24:32.115]             }
[13:24:32.115]         }))
[13:24:32.115]     }, error = function(ex) {
[13:24:32.115]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:32.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.115]                 ...future.rng), started = ...future.startTime, 
[13:24:32.115]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:32.115]             version = "1.8"), class = "FutureResult")
[13:24:32.115]     }, finally = {
[13:24:32.115]         if (!identical(...future.workdir, getwd())) 
[13:24:32.115]             setwd(...future.workdir)
[13:24:32.115]         {
[13:24:32.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:32.115]                 ...future.oldOptions$nwarnings <- NULL
[13:24:32.115]             }
[13:24:32.115]             base::options(...future.oldOptions)
[13:24:32.115]             if (.Platform$OS.type == "windows") {
[13:24:32.115]                 old_names <- names(...future.oldEnvVars)
[13:24:32.115]                 envs <- base::Sys.getenv()
[13:24:32.115]                 names <- names(envs)
[13:24:32.115]                 common <- intersect(names, old_names)
[13:24:32.115]                 added <- setdiff(names, old_names)
[13:24:32.115]                 removed <- setdiff(old_names, names)
[13:24:32.115]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:32.115]                   envs[common]]
[13:24:32.115]                 NAMES <- toupper(changed)
[13:24:32.115]                 args <- list()
[13:24:32.115]                 for (kk in seq_along(NAMES)) {
[13:24:32.115]                   name <- changed[[kk]]
[13:24:32.115]                   NAME <- NAMES[[kk]]
[13:24:32.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.115]                     next
[13:24:32.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.115]                 }
[13:24:32.115]                 NAMES <- toupper(added)
[13:24:32.115]                 for (kk in seq_along(NAMES)) {
[13:24:32.115]                   name <- added[[kk]]
[13:24:32.115]                   NAME <- NAMES[[kk]]
[13:24:32.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.115]                     next
[13:24:32.115]                   args[[name]] <- ""
[13:24:32.115]                 }
[13:24:32.115]                 NAMES <- toupper(removed)
[13:24:32.115]                 for (kk in seq_along(NAMES)) {
[13:24:32.115]                   name <- removed[[kk]]
[13:24:32.115]                   NAME <- NAMES[[kk]]
[13:24:32.115]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.115]                     next
[13:24:32.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.115]                 }
[13:24:32.115]                 if (length(args) > 0) 
[13:24:32.115]                   base::do.call(base::Sys.setenv, args = args)
[13:24:32.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:32.115]             }
[13:24:32.115]             else {
[13:24:32.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:32.115]             }
[13:24:32.115]             {
[13:24:32.115]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:32.115]                   0L) {
[13:24:32.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:32.115]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:32.115]                   base::options(opts)
[13:24:32.115]                 }
[13:24:32.115]                 {
[13:24:32.115]                   {
[13:24:32.115]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:32.115]                     NULL
[13:24:32.115]                   }
[13:24:32.115]                   options(future.plan = NULL)
[13:24:32.115]                   if (is.na(NA_character_)) 
[13:24:32.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:32.115]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:32.115]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:32.115]                     envir = parent.frame()) 
[13:24:32.115]                   {
[13:24:32.115]                     if (is.function(workers)) 
[13:24:32.115]                       workers <- workers()
[13:24:32.115]                     workers <- structure(as.integer(workers), 
[13:24:32.115]                       class = class(workers))
[13:24:32.115]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:32.115]                       workers >= 1)
[13:24:32.115]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:32.115]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:32.115]                     }
[13:24:32.115]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:32.115]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:32.115]                       envir = envir)
[13:24:32.115]                     if (!future$lazy) 
[13:24:32.115]                       future <- run(future)
[13:24:32.115]                     invisible(future)
[13:24:32.115]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:32.115]                 }
[13:24:32.115]             }
[13:24:32.115]         }
[13:24:32.115]     })
[13:24:32.115]     if (TRUE) {
[13:24:32.115]         base::sink(type = "output", split = FALSE)
[13:24:32.115]         if (TRUE) {
[13:24:32.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:32.115]         }
[13:24:32.115]         else {
[13:24:32.115]             ...future.result["stdout"] <- base::list(NULL)
[13:24:32.115]         }
[13:24:32.115]         base::close(...future.stdout)
[13:24:32.115]         ...future.stdout <- NULL
[13:24:32.115]     }
[13:24:32.115]     ...future.result$conditions <- ...future.conditions
[13:24:32.115]     ...future.result$finished <- base::Sys.time()
[13:24:32.115]     ...future.result
[13:24:32.115] }
[13:24:32.118] MultisessionFuture started
[13:24:32.118] - Launch lazy future ... done
[13:24:32.118] run() for ‘MultisessionFuture’ ... done
[13:24:32.165] receiveMessageFromWorker() for ClusterFuture ...
[13:24:32.166] - Validating connection of MultisessionFuture
[13:24:32.166] - received message: FutureResult
[13:24:32.166] - Received FutureResult
[13:24:32.166] - Erased future from FutureRegistry
[13:24:32.166] result() for ClusterFuture ...
[13:24:32.167] - result already collected: FutureResult
[13:24:32.167] result() for ClusterFuture ... done
[13:24:32.167] signalConditions() ...
[13:24:32.167]  - include = ‘immediateCondition’
[13:24:32.167]  - exclude = 
[13:24:32.167]  - resignal = FALSE
[13:24:32.167]  - Number of conditions: 1
[13:24:32.167] signalConditions() ... done
[13:24:32.167] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:32.167] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[13:24:32.168] getGlobalsAndPackages() ...
[13:24:32.168] Searching for globals...
[13:24:32.169] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:32.169] Searching for globals ... DONE
[13:24:32.169] Resolving globals: FALSE
[13:24:32.170] 
[13:24:32.170] 
[13:24:32.170] getGlobalsAndPackages() ... DONE
[13:24:32.170] run() for ‘Future’ ...
[13:24:32.170] - state: ‘created’
[13:24:32.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:32.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:32.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:32.187]   - Field: ‘node’
[13:24:32.187]   - Field: ‘label’
[13:24:32.188]   - Field: ‘local’
[13:24:32.188]   - Field: ‘owner’
[13:24:32.188]   - Field: ‘envir’
[13:24:32.188]   - Field: ‘workers’
[13:24:32.188]   - Field: ‘packages’
[13:24:32.188]   - Field: ‘gc’
[13:24:32.188]   - Field: ‘conditions’
[13:24:32.188]   - Field: ‘persistent’
[13:24:32.188]   - Field: ‘expr’
[13:24:32.188]   - Field: ‘uuid’
[13:24:32.189]   - Field: ‘seed’
[13:24:32.189]   - Field: ‘version’
[13:24:32.189]   - Field: ‘result’
[13:24:32.189]   - Field: ‘asynchronous’
[13:24:32.189]   - Field: ‘calls’
[13:24:32.189]   - Field: ‘globals’
[13:24:32.189]   - Field: ‘stdout’
[13:24:32.189]   - Field: ‘earlySignal’
[13:24:32.189]   - Field: ‘lazy’
[13:24:32.189]   - Field: ‘state’
[13:24:32.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:32.190] - Launch lazy future ...
[13:24:32.190] Packages needed by the future expression (n = 0): <none>
[13:24:32.190] Packages needed by future strategies (n = 0): <none>
[13:24:32.190] {
[13:24:32.190]     {
[13:24:32.190]         {
[13:24:32.190]             ...future.startTime <- base::Sys.time()
[13:24:32.190]             {
[13:24:32.190]                 {
[13:24:32.190]                   {
[13:24:32.190]                     {
[13:24:32.190]                       base::local({
[13:24:32.190]                         has_future <- base::requireNamespace("future", 
[13:24:32.190]                           quietly = TRUE)
[13:24:32.190]                         if (has_future) {
[13:24:32.190]                           ns <- base::getNamespace("future")
[13:24:32.190]                           version <- ns[[".package"]][["version"]]
[13:24:32.190]                           if (is.null(version)) 
[13:24:32.190]                             version <- utils::packageVersion("future")
[13:24:32.190]                         }
[13:24:32.190]                         else {
[13:24:32.190]                           version <- NULL
[13:24:32.190]                         }
[13:24:32.190]                         if (!has_future || version < "1.8.0") {
[13:24:32.190]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:32.190]                             "", base::R.version$version.string), 
[13:24:32.190]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:32.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:32.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:32.190]                               "release", "version")], collapse = " "), 
[13:24:32.190]                             hostname = base::Sys.info()[["nodename"]])
[13:24:32.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:32.190]                             info)
[13:24:32.190]                           info <- base::paste(info, collapse = "; ")
[13:24:32.190]                           if (!has_future) {
[13:24:32.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:32.190]                               info)
[13:24:32.190]                           }
[13:24:32.190]                           else {
[13:24:32.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:32.190]                               info, version)
[13:24:32.190]                           }
[13:24:32.190]                           base::stop(msg)
[13:24:32.190]                         }
[13:24:32.190]                       })
[13:24:32.190]                     }
[13:24:32.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:32.190]                     base::options(mc.cores = 1L)
[13:24:32.190]                   }
[13:24:32.190]                   options(future.plan = NULL)
[13:24:32.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:32.190]                 }
[13:24:32.190]                 ...future.workdir <- getwd()
[13:24:32.190]             }
[13:24:32.190]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:32.190]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:32.190]         }
[13:24:32.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:32.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:32.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:32.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:32.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:32.190]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:32.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:32.190]             base::names(...future.oldOptions))
[13:24:32.190]     }
[13:24:32.190]     if (FALSE) {
[13:24:32.190]     }
[13:24:32.190]     else {
[13:24:32.190]         if (TRUE) {
[13:24:32.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:32.190]                 open = "w")
[13:24:32.190]         }
[13:24:32.190]         else {
[13:24:32.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:32.190]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:32.190]         }
[13:24:32.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:32.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:32.190]             base::sink(type = "output", split = FALSE)
[13:24:32.190]             base::close(...future.stdout)
[13:24:32.190]         }, add = TRUE)
[13:24:32.190]     }
[13:24:32.190]     ...future.frame <- base::sys.nframe()
[13:24:32.190]     ...future.conditions <- base::list()
[13:24:32.190]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:32.190]     if (FALSE) {
[13:24:32.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:32.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:32.190]     }
[13:24:32.190]     ...future.result <- base::tryCatch({
[13:24:32.190]         base::withCallingHandlers({
[13:24:32.190]             ...future.value <- base::withVisible(base::local({
[13:24:32.190]                 ...future.makeSendCondition <- base::local({
[13:24:32.190]                   sendCondition <- NULL
[13:24:32.190]                   function(frame = 1L) {
[13:24:32.190]                     if (is.function(sendCondition)) 
[13:24:32.190]                       return(sendCondition)
[13:24:32.190]                     ns <- getNamespace("parallel")
[13:24:32.190]                     if (exists("sendData", mode = "function", 
[13:24:32.190]                       envir = ns)) {
[13:24:32.190]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:32.190]                         envir = ns)
[13:24:32.190]                       envir <- sys.frame(frame)
[13:24:32.190]                       master <- NULL
[13:24:32.190]                       while (!identical(envir, .GlobalEnv) && 
[13:24:32.190]                         !identical(envir, emptyenv())) {
[13:24:32.190]                         if (exists("master", mode = "list", envir = envir, 
[13:24:32.190]                           inherits = FALSE)) {
[13:24:32.190]                           master <- get("master", mode = "list", 
[13:24:32.190]                             envir = envir, inherits = FALSE)
[13:24:32.190]                           if (inherits(master, c("SOCKnode", 
[13:24:32.190]                             "SOCK0node"))) {
[13:24:32.190]                             sendCondition <<- function(cond) {
[13:24:32.190]                               data <- list(type = "VALUE", value = cond, 
[13:24:32.190]                                 success = TRUE)
[13:24:32.190]                               parallel_sendData(master, data)
[13:24:32.190]                             }
[13:24:32.190]                             return(sendCondition)
[13:24:32.190]                           }
[13:24:32.190]                         }
[13:24:32.190]                         frame <- frame + 1L
[13:24:32.190]                         envir <- sys.frame(frame)
[13:24:32.190]                       }
[13:24:32.190]                     }
[13:24:32.190]                     sendCondition <<- function(cond) NULL
[13:24:32.190]                   }
[13:24:32.190]                 })
[13:24:32.190]                 withCallingHandlers({
[13:24:32.190]                   {
[13:24:32.190]                     Sys.sleep(0.5)
[13:24:32.190]                     list(a = 1, b = 42L)
[13:24:32.190]                   }
[13:24:32.190]                 }, immediateCondition = function(cond) {
[13:24:32.190]                   sendCondition <- ...future.makeSendCondition()
[13:24:32.190]                   sendCondition(cond)
[13:24:32.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.190]                   {
[13:24:32.190]                     inherits <- base::inherits
[13:24:32.190]                     invokeRestart <- base::invokeRestart
[13:24:32.190]                     is.null <- base::is.null
[13:24:32.190]                     muffled <- FALSE
[13:24:32.190]                     if (inherits(cond, "message")) {
[13:24:32.190]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:32.190]                       if (muffled) 
[13:24:32.190]                         invokeRestart("muffleMessage")
[13:24:32.190]                     }
[13:24:32.190]                     else if (inherits(cond, "warning")) {
[13:24:32.190]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:32.190]                       if (muffled) 
[13:24:32.190]                         invokeRestart("muffleWarning")
[13:24:32.190]                     }
[13:24:32.190]                     else if (inherits(cond, "condition")) {
[13:24:32.190]                       if (!is.null(pattern)) {
[13:24:32.190]                         computeRestarts <- base::computeRestarts
[13:24:32.190]                         grepl <- base::grepl
[13:24:32.190]                         restarts <- computeRestarts(cond)
[13:24:32.190]                         for (restart in restarts) {
[13:24:32.190]                           name <- restart$name
[13:24:32.190]                           if (is.null(name)) 
[13:24:32.190]                             next
[13:24:32.190]                           if (!grepl(pattern, name)) 
[13:24:32.190]                             next
[13:24:32.190]                           invokeRestart(restart)
[13:24:32.190]                           muffled <- TRUE
[13:24:32.190]                           break
[13:24:32.190]                         }
[13:24:32.190]                       }
[13:24:32.190]                     }
[13:24:32.190]                     invisible(muffled)
[13:24:32.190]                   }
[13:24:32.190]                   muffleCondition(cond)
[13:24:32.190]                 })
[13:24:32.190]             }))
[13:24:32.190]             future::FutureResult(value = ...future.value$value, 
[13:24:32.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.190]                   ...future.rng), globalenv = if (FALSE) 
[13:24:32.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:32.190]                     ...future.globalenv.names))
[13:24:32.190]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:32.190]         }, condition = base::local({
[13:24:32.190]             c <- base::c
[13:24:32.190]             inherits <- base::inherits
[13:24:32.190]             invokeRestart <- base::invokeRestart
[13:24:32.190]             length <- base::length
[13:24:32.190]             list <- base::list
[13:24:32.190]             seq.int <- base::seq.int
[13:24:32.190]             signalCondition <- base::signalCondition
[13:24:32.190]             sys.calls <- base::sys.calls
[13:24:32.190]             `[[` <- base::`[[`
[13:24:32.190]             `+` <- base::`+`
[13:24:32.190]             `<<-` <- base::`<<-`
[13:24:32.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:32.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:32.190]                   3L)]
[13:24:32.190]             }
[13:24:32.190]             function(cond) {
[13:24:32.190]                 is_error <- inherits(cond, "error")
[13:24:32.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:32.190]                   NULL)
[13:24:32.190]                 if (is_error) {
[13:24:32.190]                   sessionInformation <- function() {
[13:24:32.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:32.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:32.190]                       search = base::search(), system = base::Sys.info())
[13:24:32.190]                   }
[13:24:32.190]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:32.190]                     cond$call), session = sessionInformation(), 
[13:24:32.190]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:32.190]                   signalCondition(cond)
[13:24:32.190]                 }
[13:24:32.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:32.190]                 "immediateCondition"))) {
[13:24:32.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:32.190]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:32.190]                   if (TRUE && !signal) {
[13:24:32.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.190]                     {
[13:24:32.190]                       inherits <- base::inherits
[13:24:32.190]                       invokeRestart <- base::invokeRestart
[13:24:32.190]                       is.null <- base::is.null
[13:24:32.190]                       muffled <- FALSE
[13:24:32.190]                       if (inherits(cond, "message")) {
[13:24:32.190]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.190]                         if (muffled) 
[13:24:32.190]                           invokeRestart("muffleMessage")
[13:24:32.190]                       }
[13:24:32.190]                       else if (inherits(cond, "warning")) {
[13:24:32.190]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.190]                         if (muffled) 
[13:24:32.190]                           invokeRestart("muffleWarning")
[13:24:32.190]                       }
[13:24:32.190]                       else if (inherits(cond, "condition")) {
[13:24:32.190]                         if (!is.null(pattern)) {
[13:24:32.190]                           computeRestarts <- base::computeRestarts
[13:24:32.190]                           grepl <- base::grepl
[13:24:32.190]                           restarts <- computeRestarts(cond)
[13:24:32.190]                           for (restart in restarts) {
[13:24:32.190]                             name <- restart$name
[13:24:32.190]                             if (is.null(name)) 
[13:24:32.190]                               next
[13:24:32.190]                             if (!grepl(pattern, name)) 
[13:24:32.190]                               next
[13:24:32.190]                             invokeRestart(restart)
[13:24:32.190]                             muffled <- TRUE
[13:24:32.190]                             break
[13:24:32.190]                           }
[13:24:32.190]                         }
[13:24:32.190]                       }
[13:24:32.190]                       invisible(muffled)
[13:24:32.190]                     }
[13:24:32.190]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.190]                   }
[13:24:32.190]                 }
[13:24:32.190]                 else {
[13:24:32.190]                   if (TRUE) {
[13:24:32.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.190]                     {
[13:24:32.190]                       inherits <- base::inherits
[13:24:32.190]                       invokeRestart <- base::invokeRestart
[13:24:32.190]                       is.null <- base::is.null
[13:24:32.190]                       muffled <- FALSE
[13:24:32.190]                       if (inherits(cond, "message")) {
[13:24:32.190]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.190]                         if (muffled) 
[13:24:32.190]                           invokeRestart("muffleMessage")
[13:24:32.190]                       }
[13:24:32.190]                       else if (inherits(cond, "warning")) {
[13:24:32.190]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.190]                         if (muffled) 
[13:24:32.190]                           invokeRestart("muffleWarning")
[13:24:32.190]                       }
[13:24:32.190]                       else if (inherits(cond, "condition")) {
[13:24:32.190]                         if (!is.null(pattern)) {
[13:24:32.190]                           computeRestarts <- base::computeRestarts
[13:24:32.190]                           grepl <- base::grepl
[13:24:32.190]                           restarts <- computeRestarts(cond)
[13:24:32.190]                           for (restart in restarts) {
[13:24:32.190]                             name <- restart$name
[13:24:32.190]                             if (is.null(name)) 
[13:24:32.190]                               next
[13:24:32.190]                             if (!grepl(pattern, name)) 
[13:24:32.190]                               next
[13:24:32.190]                             invokeRestart(restart)
[13:24:32.190]                             muffled <- TRUE
[13:24:32.190]                             break
[13:24:32.190]                           }
[13:24:32.190]                         }
[13:24:32.190]                       }
[13:24:32.190]                       invisible(muffled)
[13:24:32.190]                     }
[13:24:32.190]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.190]                   }
[13:24:32.190]                 }
[13:24:32.190]             }
[13:24:32.190]         }))
[13:24:32.190]     }, error = function(ex) {
[13:24:32.190]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:32.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.190]                 ...future.rng), started = ...future.startTime, 
[13:24:32.190]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:32.190]             version = "1.8"), class = "FutureResult")
[13:24:32.190]     }, finally = {
[13:24:32.190]         if (!identical(...future.workdir, getwd())) 
[13:24:32.190]             setwd(...future.workdir)
[13:24:32.190]         {
[13:24:32.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:32.190]                 ...future.oldOptions$nwarnings <- NULL
[13:24:32.190]             }
[13:24:32.190]             base::options(...future.oldOptions)
[13:24:32.190]             if (.Platform$OS.type == "windows") {
[13:24:32.190]                 old_names <- names(...future.oldEnvVars)
[13:24:32.190]                 envs <- base::Sys.getenv()
[13:24:32.190]                 names <- names(envs)
[13:24:32.190]                 common <- intersect(names, old_names)
[13:24:32.190]                 added <- setdiff(names, old_names)
[13:24:32.190]                 removed <- setdiff(old_names, names)
[13:24:32.190]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:32.190]                   envs[common]]
[13:24:32.190]                 NAMES <- toupper(changed)
[13:24:32.190]                 args <- list()
[13:24:32.190]                 for (kk in seq_along(NAMES)) {
[13:24:32.190]                   name <- changed[[kk]]
[13:24:32.190]                   NAME <- NAMES[[kk]]
[13:24:32.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.190]                     next
[13:24:32.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.190]                 }
[13:24:32.190]                 NAMES <- toupper(added)
[13:24:32.190]                 for (kk in seq_along(NAMES)) {
[13:24:32.190]                   name <- added[[kk]]
[13:24:32.190]                   NAME <- NAMES[[kk]]
[13:24:32.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.190]                     next
[13:24:32.190]                   args[[name]] <- ""
[13:24:32.190]                 }
[13:24:32.190]                 NAMES <- toupper(removed)
[13:24:32.190]                 for (kk in seq_along(NAMES)) {
[13:24:32.190]                   name <- removed[[kk]]
[13:24:32.190]                   NAME <- NAMES[[kk]]
[13:24:32.190]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.190]                     next
[13:24:32.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.190]                 }
[13:24:32.190]                 if (length(args) > 0) 
[13:24:32.190]                   base::do.call(base::Sys.setenv, args = args)
[13:24:32.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:32.190]             }
[13:24:32.190]             else {
[13:24:32.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:32.190]             }
[13:24:32.190]             {
[13:24:32.190]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:32.190]                   0L) {
[13:24:32.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:32.190]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:32.190]                   base::options(opts)
[13:24:32.190]                 }
[13:24:32.190]                 {
[13:24:32.190]                   {
[13:24:32.190]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:32.190]                     NULL
[13:24:32.190]                   }
[13:24:32.190]                   options(future.plan = NULL)
[13:24:32.190]                   if (is.na(NA_character_)) 
[13:24:32.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:32.190]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:32.190]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:32.190]                     envir = parent.frame()) 
[13:24:32.190]                   {
[13:24:32.190]                     if (is.function(workers)) 
[13:24:32.190]                       workers <- workers()
[13:24:32.190]                     workers <- structure(as.integer(workers), 
[13:24:32.190]                       class = class(workers))
[13:24:32.190]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:32.190]                       workers >= 1)
[13:24:32.190]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:32.190]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:32.190]                     }
[13:24:32.190]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:32.190]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:32.190]                       envir = envir)
[13:24:32.190]                     if (!future$lazy) 
[13:24:32.190]                       future <- run(future)
[13:24:32.190]                     invisible(future)
[13:24:32.190]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:32.190]                 }
[13:24:32.190]             }
[13:24:32.190]         }
[13:24:32.190]     })
[13:24:32.190]     if (TRUE) {
[13:24:32.190]         base::sink(type = "output", split = FALSE)
[13:24:32.190]         if (TRUE) {
[13:24:32.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:32.190]         }
[13:24:32.190]         else {
[13:24:32.190]             ...future.result["stdout"] <- base::list(NULL)
[13:24:32.190]         }
[13:24:32.190]         base::close(...future.stdout)
[13:24:32.190]         ...future.stdout <- NULL
[13:24:32.190]     }
[13:24:32.190]     ...future.result$conditions <- ...future.conditions
[13:24:32.190]     ...future.result$finished <- base::Sys.time()
[13:24:32.190]     ...future.result
[13:24:32.190] }
[13:24:32.194] MultisessionFuture started
[13:24:32.194] - Launch lazy future ... done
[13:24:32.194] run() for ‘MultisessionFuture’ ... done
[13:24:32.742] receiveMessageFromWorker() for ClusterFuture ...
[13:24:32.742] - Validating connection of MultisessionFuture
[13:24:32.742] - received message: FutureResult
[13:24:32.743] - Received FutureResult
[13:24:32.743] - Erased future from FutureRegistry
[13:24:32.743] result() for ClusterFuture ...
[13:24:32.743] - result already collected: FutureResult
[13:24:32.743] result() for ClusterFuture ... done
[13:24:32.743] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:32.743] A MultisessionFuture was resolved (result was not collected)
[13:24:32.743] getGlobalsAndPackages() ...
[13:24:32.743] Searching for globals...
[13:24:32.745] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:32.745] Searching for globals ... DONE
[13:24:32.745] Resolving globals: FALSE
[13:24:32.745] 
[13:24:32.745] 
[13:24:32.745] getGlobalsAndPackages() ... DONE
[13:24:32.746] run() for ‘Future’ ...
[13:24:32.746] - state: ‘created’
[13:24:32.746] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:32.760] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:32.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:32.760]   - Field: ‘node’
[13:24:32.760]   - Field: ‘label’
[13:24:32.760]   - Field: ‘local’
[13:24:32.760]   - Field: ‘owner’
[13:24:32.761]   - Field: ‘envir’
[13:24:32.761]   - Field: ‘workers’
[13:24:32.761]   - Field: ‘packages’
[13:24:32.761]   - Field: ‘gc’
[13:24:32.761]   - Field: ‘conditions’
[13:24:32.761]   - Field: ‘persistent’
[13:24:32.761]   - Field: ‘expr’
[13:24:32.761]   - Field: ‘uuid’
[13:24:32.761]   - Field: ‘seed’
[13:24:32.761]   - Field: ‘version’
[13:24:32.762]   - Field: ‘result’
[13:24:32.762]   - Field: ‘asynchronous’
[13:24:32.762]   - Field: ‘calls’
[13:24:32.762]   - Field: ‘globals’
[13:24:32.762]   - Field: ‘stdout’
[13:24:32.762]   - Field: ‘earlySignal’
[13:24:32.762]   - Field: ‘lazy’
[13:24:32.762]   - Field: ‘state’
[13:24:32.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:32.762] - Launch lazy future ...
[13:24:32.763] Packages needed by the future expression (n = 0): <none>
[13:24:32.763] Packages needed by future strategies (n = 0): <none>
[13:24:32.763] {
[13:24:32.763]     {
[13:24:32.763]         {
[13:24:32.763]             ...future.startTime <- base::Sys.time()
[13:24:32.763]             {
[13:24:32.763]                 {
[13:24:32.763]                   {
[13:24:32.763]                     {
[13:24:32.763]                       base::local({
[13:24:32.763]                         has_future <- base::requireNamespace("future", 
[13:24:32.763]                           quietly = TRUE)
[13:24:32.763]                         if (has_future) {
[13:24:32.763]                           ns <- base::getNamespace("future")
[13:24:32.763]                           version <- ns[[".package"]][["version"]]
[13:24:32.763]                           if (is.null(version)) 
[13:24:32.763]                             version <- utils::packageVersion("future")
[13:24:32.763]                         }
[13:24:32.763]                         else {
[13:24:32.763]                           version <- NULL
[13:24:32.763]                         }
[13:24:32.763]                         if (!has_future || version < "1.8.0") {
[13:24:32.763]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:32.763]                             "", base::R.version$version.string), 
[13:24:32.763]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:32.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:32.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:32.763]                               "release", "version")], collapse = " "), 
[13:24:32.763]                             hostname = base::Sys.info()[["nodename"]])
[13:24:32.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:32.763]                             info)
[13:24:32.763]                           info <- base::paste(info, collapse = "; ")
[13:24:32.763]                           if (!has_future) {
[13:24:32.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:32.763]                               info)
[13:24:32.763]                           }
[13:24:32.763]                           else {
[13:24:32.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:32.763]                               info, version)
[13:24:32.763]                           }
[13:24:32.763]                           base::stop(msg)
[13:24:32.763]                         }
[13:24:32.763]                       })
[13:24:32.763]                     }
[13:24:32.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:32.763]                     base::options(mc.cores = 1L)
[13:24:32.763]                   }
[13:24:32.763]                   options(future.plan = NULL)
[13:24:32.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:32.763]                 }
[13:24:32.763]                 ...future.workdir <- getwd()
[13:24:32.763]             }
[13:24:32.763]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:32.763]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:32.763]         }
[13:24:32.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:32.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:32.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:32.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:32.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:32.763]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:32.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:32.763]             base::names(...future.oldOptions))
[13:24:32.763]     }
[13:24:32.763]     if (FALSE) {
[13:24:32.763]     }
[13:24:32.763]     else {
[13:24:32.763]         if (TRUE) {
[13:24:32.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:32.763]                 open = "w")
[13:24:32.763]         }
[13:24:32.763]         else {
[13:24:32.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:32.763]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:32.763]         }
[13:24:32.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:32.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:32.763]             base::sink(type = "output", split = FALSE)
[13:24:32.763]             base::close(...future.stdout)
[13:24:32.763]         }, add = TRUE)
[13:24:32.763]     }
[13:24:32.763]     ...future.frame <- base::sys.nframe()
[13:24:32.763]     ...future.conditions <- base::list()
[13:24:32.763]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:32.763]     if (FALSE) {
[13:24:32.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:32.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:32.763]     }
[13:24:32.763]     ...future.result <- base::tryCatch({
[13:24:32.763]         base::withCallingHandlers({
[13:24:32.763]             ...future.value <- base::withVisible(base::local({
[13:24:32.763]                 ...future.makeSendCondition <- base::local({
[13:24:32.763]                   sendCondition <- NULL
[13:24:32.763]                   function(frame = 1L) {
[13:24:32.763]                     if (is.function(sendCondition)) 
[13:24:32.763]                       return(sendCondition)
[13:24:32.763]                     ns <- getNamespace("parallel")
[13:24:32.763]                     if (exists("sendData", mode = "function", 
[13:24:32.763]                       envir = ns)) {
[13:24:32.763]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:32.763]                         envir = ns)
[13:24:32.763]                       envir <- sys.frame(frame)
[13:24:32.763]                       master <- NULL
[13:24:32.763]                       while (!identical(envir, .GlobalEnv) && 
[13:24:32.763]                         !identical(envir, emptyenv())) {
[13:24:32.763]                         if (exists("master", mode = "list", envir = envir, 
[13:24:32.763]                           inherits = FALSE)) {
[13:24:32.763]                           master <- get("master", mode = "list", 
[13:24:32.763]                             envir = envir, inherits = FALSE)
[13:24:32.763]                           if (inherits(master, c("SOCKnode", 
[13:24:32.763]                             "SOCK0node"))) {
[13:24:32.763]                             sendCondition <<- function(cond) {
[13:24:32.763]                               data <- list(type = "VALUE", value = cond, 
[13:24:32.763]                                 success = TRUE)
[13:24:32.763]                               parallel_sendData(master, data)
[13:24:32.763]                             }
[13:24:32.763]                             return(sendCondition)
[13:24:32.763]                           }
[13:24:32.763]                         }
[13:24:32.763]                         frame <- frame + 1L
[13:24:32.763]                         envir <- sys.frame(frame)
[13:24:32.763]                       }
[13:24:32.763]                     }
[13:24:32.763]                     sendCondition <<- function(cond) NULL
[13:24:32.763]                   }
[13:24:32.763]                 })
[13:24:32.763]                 withCallingHandlers({
[13:24:32.763]                   {
[13:24:32.763]                     Sys.sleep(0.5)
[13:24:32.763]                     list(a = 1, b = 42L)
[13:24:32.763]                   }
[13:24:32.763]                 }, immediateCondition = function(cond) {
[13:24:32.763]                   sendCondition <- ...future.makeSendCondition()
[13:24:32.763]                   sendCondition(cond)
[13:24:32.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.763]                   {
[13:24:32.763]                     inherits <- base::inherits
[13:24:32.763]                     invokeRestart <- base::invokeRestart
[13:24:32.763]                     is.null <- base::is.null
[13:24:32.763]                     muffled <- FALSE
[13:24:32.763]                     if (inherits(cond, "message")) {
[13:24:32.763]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:32.763]                       if (muffled) 
[13:24:32.763]                         invokeRestart("muffleMessage")
[13:24:32.763]                     }
[13:24:32.763]                     else if (inherits(cond, "warning")) {
[13:24:32.763]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:32.763]                       if (muffled) 
[13:24:32.763]                         invokeRestart("muffleWarning")
[13:24:32.763]                     }
[13:24:32.763]                     else if (inherits(cond, "condition")) {
[13:24:32.763]                       if (!is.null(pattern)) {
[13:24:32.763]                         computeRestarts <- base::computeRestarts
[13:24:32.763]                         grepl <- base::grepl
[13:24:32.763]                         restarts <- computeRestarts(cond)
[13:24:32.763]                         for (restart in restarts) {
[13:24:32.763]                           name <- restart$name
[13:24:32.763]                           if (is.null(name)) 
[13:24:32.763]                             next
[13:24:32.763]                           if (!grepl(pattern, name)) 
[13:24:32.763]                             next
[13:24:32.763]                           invokeRestart(restart)
[13:24:32.763]                           muffled <- TRUE
[13:24:32.763]                           break
[13:24:32.763]                         }
[13:24:32.763]                       }
[13:24:32.763]                     }
[13:24:32.763]                     invisible(muffled)
[13:24:32.763]                   }
[13:24:32.763]                   muffleCondition(cond)
[13:24:32.763]                 })
[13:24:32.763]             }))
[13:24:32.763]             future::FutureResult(value = ...future.value$value, 
[13:24:32.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.763]                   ...future.rng), globalenv = if (FALSE) 
[13:24:32.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:32.763]                     ...future.globalenv.names))
[13:24:32.763]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:32.763]         }, condition = base::local({
[13:24:32.763]             c <- base::c
[13:24:32.763]             inherits <- base::inherits
[13:24:32.763]             invokeRestart <- base::invokeRestart
[13:24:32.763]             length <- base::length
[13:24:32.763]             list <- base::list
[13:24:32.763]             seq.int <- base::seq.int
[13:24:32.763]             signalCondition <- base::signalCondition
[13:24:32.763]             sys.calls <- base::sys.calls
[13:24:32.763]             `[[` <- base::`[[`
[13:24:32.763]             `+` <- base::`+`
[13:24:32.763]             `<<-` <- base::`<<-`
[13:24:32.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:32.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:32.763]                   3L)]
[13:24:32.763]             }
[13:24:32.763]             function(cond) {
[13:24:32.763]                 is_error <- inherits(cond, "error")
[13:24:32.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:32.763]                   NULL)
[13:24:32.763]                 if (is_error) {
[13:24:32.763]                   sessionInformation <- function() {
[13:24:32.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:32.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:32.763]                       search = base::search(), system = base::Sys.info())
[13:24:32.763]                   }
[13:24:32.763]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:32.763]                     cond$call), session = sessionInformation(), 
[13:24:32.763]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:32.763]                   signalCondition(cond)
[13:24:32.763]                 }
[13:24:32.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:32.763]                 "immediateCondition"))) {
[13:24:32.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:32.763]                   ...future.conditions[[length(...future.conditions) + 
[13:24:32.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:32.763]                   if (TRUE && !signal) {
[13:24:32.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.763]                     {
[13:24:32.763]                       inherits <- base::inherits
[13:24:32.763]                       invokeRestart <- base::invokeRestart
[13:24:32.763]                       is.null <- base::is.null
[13:24:32.763]                       muffled <- FALSE
[13:24:32.763]                       if (inherits(cond, "message")) {
[13:24:32.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.763]                         if (muffled) 
[13:24:32.763]                           invokeRestart("muffleMessage")
[13:24:32.763]                       }
[13:24:32.763]                       else if (inherits(cond, "warning")) {
[13:24:32.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.763]                         if (muffled) 
[13:24:32.763]                           invokeRestart("muffleWarning")
[13:24:32.763]                       }
[13:24:32.763]                       else if (inherits(cond, "condition")) {
[13:24:32.763]                         if (!is.null(pattern)) {
[13:24:32.763]                           computeRestarts <- base::computeRestarts
[13:24:32.763]                           grepl <- base::grepl
[13:24:32.763]                           restarts <- computeRestarts(cond)
[13:24:32.763]                           for (restart in restarts) {
[13:24:32.763]                             name <- restart$name
[13:24:32.763]                             if (is.null(name)) 
[13:24:32.763]                               next
[13:24:32.763]                             if (!grepl(pattern, name)) 
[13:24:32.763]                               next
[13:24:32.763]                             invokeRestart(restart)
[13:24:32.763]                             muffled <- TRUE
[13:24:32.763]                             break
[13:24:32.763]                           }
[13:24:32.763]                         }
[13:24:32.763]                       }
[13:24:32.763]                       invisible(muffled)
[13:24:32.763]                     }
[13:24:32.763]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.763]                   }
[13:24:32.763]                 }
[13:24:32.763]                 else {
[13:24:32.763]                   if (TRUE) {
[13:24:32.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:32.763]                     {
[13:24:32.763]                       inherits <- base::inherits
[13:24:32.763]                       invokeRestart <- base::invokeRestart
[13:24:32.763]                       is.null <- base::is.null
[13:24:32.763]                       muffled <- FALSE
[13:24:32.763]                       if (inherits(cond, "message")) {
[13:24:32.763]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:32.763]                         if (muffled) 
[13:24:32.763]                           invokeRestart("muffleMessage")
[13:24:32.763]                       }
[13:24:32.763]                       else if (inherits(cond, "warning")) {
[13:24:32.763]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:32.763]                         if (muffled) 
[13:24:32.763]                           invokeRestart("muffleWarning")
[13:24:32.763]                       }
[13:24:32.763]                       else if (inherits(cond, "condition")) {
[13:24:32.763]                         if (!is.null(pattern)) {
[13:24:32.763]                           computeRestarts <- base::computeRestarts
[13:24:32.763]                           grepl <- base::grepl
[13:24:32.763]                           restarts <- computeRestarts(cond)
[13:24:32.763]                           for (restart in restarts) {
[13:24:32.763]                             name <- restart$name
[13:24:32.763]                             if (is.null(name)) 
[13:24:32.763]                               next
[13:24:32.763]                             if (!grepl(pattern, name)) 
[13:24:32.763]                               next
[13:24:32.763]                             invokeRestart(restart)
[13:24:32.763]                             muffled <- TRUE
[13:24:32.763]                             break
[13:24:32.763]                           }
[13:24:32.763]                         }
[13:24:32.763]                       }
[13:24:32.763]                       invisible(muffled)
[13:24:32.763]                     }
[13:24:32.763]                     muffleCondition(cond, pattern = "^muffle")
[13:24:32.763]                   }
[13:24:32.763]                 }
[13:24:32.763]             }
[13:24:32.763]         }))
[13:24:32.763]     }, error = function(ex) {
[13:24:32.763]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:32.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:32.763]                 ...future.rng), started = ...future.startTime, 
[13:24:32.763]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:32.763]             version = "1.8"), class = "FutureResult")
[13:24:32.763]     }, finally = {
[13:24:32.763]         if (!identical(...future.workdir, getwd())) 
[13:24:32.763]             setwd(...future.workdir)
[13:24:32.763]         {
[13:24:32.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:32.763]                 ...future.oldOptions$nwarnings <- NULL
[13:24:32.763]             }
[13:24:32.763]             base::options(...future.oldOptions)
[13:24:32.763]             if (.Platform$OS.type == "windows") {
[13:24:32.763]                 old_names <- names(...future.oldEnvVars)
[13:24:32.763]                 envs <- base::Sys.getenv()
[13:24:32.763]                 names <- names(envs)
[13:24:32.763]                 common <- intersect(names, old_names)
[13:24:32.763]                 added <- setdiff(names, old_names)
[13:24:32.763]                 removed <- setdiff(old_names, names)
[13:24:32.763]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:32.763]                   envs[common]]
[13:24:32.763]                 NAMES <- toupper(changed)
[13:24:32.763]                 args <- list()
[13:24:32.763]                 for (kk in seq_along(NAMES)) {
[13:24:32.763]                   name <- changed[[kk]]
[13:24:32.763]                   NAME <- NAMES[[kk]]
[13:24:32.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.763]                     next
[13:24:32.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.763]                 }
[13:24:32.763]                 NAMES <- toupper(added)
[13:24:32.763]                 for (kk in seq_along(NAMES)) {
[13:24:32.763]                   name <- added[[kk]]
[13:24:32.763]                   NAME <- NAMES[[kk]]
[13:24:32.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.763]                     next
[13:24:32.763]                   args[[name]] <- ""
[13:24:32.763]                 }
[13:24:32.763]                 NAMES <- toupper(removed)
[13:24:32.763]                 for (kk in seq_along(NAMES)) {
[13:24:32.763]                   name <- removed[[kk]]
[13:24:32.763]                   NAME <- NAMES[[kk]]
[13:24:32.763]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:32.763]                     next
[13:24:32.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:32.763]                 }
[13:24:32.763]                 if (length(args) > 0) 
[13:24:32.763]                   base::do.call(base::Sys.setenv, args = args)
[13:24:32.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:32.763]             }
[13:24:32.763]             else {
[13:24:32.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:32.763]             }
[13:24:32.763]             {
[13:24:32.763]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:32.763]                   0L) {
[13:24:32.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:32.763]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:32.763]                   base::options(opts)
[13:24:32.763]                 }
[13:24:32.763]                 {
[13:24:32.763]                   {
[13:24:32.763]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:32.763]                     NULL
[13:24:32.763]                   }
[13:24:32.763]                   options(future.plan = NULL)
[13:24:32.763]                   if (is.na(NA_character_)) 
[13:24:32.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:32.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:32.763]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:32.763]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:32.763]                     envir = parent.frame()) 
[13:24:32.763]                   {
[13:24:32.763]                     if (is.function(workers)) 
[13:24:32.763]                       workers <- workers()
[13:24:32.763]                     workers <- structure(as.integer(workers), 
[13:24:32.763]                       class = class(workers))
[13:24:32.763]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:32.763]                       workers >= 1)
[13:24:32.763]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:32.763]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:32.763]                     }
[13:24:32.763]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:32.763]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:32.763]                       envir = envir)
[13:24:32.763]                     if (!future$lazy) 
[13:24:32.763]                       future <- run(future)
[13:24:32.763]                     invisible(future)
[13:24:32.763]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:32.763]                 }
[13:24:32.763]             }
[13:24:32.763]         }
[13:24:32.763]     })
[13:24:32.763]     if (TRUE) {
[13:24:32.763]         base::sink(type = "output", split = FALSE)
[13:24:32.763]         if (TRUE) {
[13:24:32.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:32.763]         }
[13:24:32.763]         else {
[13:24:32.763]             ...future.result["stdout"] <- base::list(NULL)
[13:24:32.763]         }
[13:24:32.763]         base::close(...future.stdout)
[13:24:32.763]         ...future.stdout <- NULL
[13:24:32.763]     }
[13:24:32.763]     ...future.result$conditions <- ...future.conditions
[13:24:32.763]     ...future.result$finished <- base::Sys.time()
[13:24:32.763]     ...future.result
[13:24:32.763] }
[13:24:32.767] MultisessionFuture started
[13:24:32.767] - Launch lazy future ... done
[13:24:32.767] run() for ‘MultisessionFuture’ ... done
[13:24:33.314] receiveMessageFromWorker() for ClusterFuture ...
[13:24:33.314] - Validating connection of MultisessionFuture
[13:24:33.314] - received message: FutureResult
[13:24:33.315] - Received FutureResult
[13:24:33.315] - Erased future from FutureRegistry
[13:24:33.315] result() for ClusterFuture ...
[13:24:33.315] - result already collected: FutureResult
[13:24:33.315] result() for ClusterFuture ... done
[13:24:33.315] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:33.315] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[13:24:33.315] getGlobalsAndPackages() ...
[13:24:33.316] Searching for globals...
[13:24:33.316] - globals found: [2] ‘list’, ‘stop’
[13:24:33.316] Searching for globals ... DONE
[13:24:33.316] Resolving globals: FALSE
[13:24:33.317] 
[13:24:33.317] 
[13:24:33.317] getGlobalsAndPackages() ... DONE
[13:24:33.317] run() for ‘Future’ ...
[13:24:33.317] - state: ‘created’
[13:24:33.317] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:33.331] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:33.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:33.332]   - Field: ‘node’
[13:24:33.332]   - Field: ‘label’
[13:24:33.332]   - Field: ‘local’
[13:24:33.332]   - Field: ‘owner’
[13:24:33.332]   - Field: ‘envir’
[13:24:33.332]   - Field: ‘workers’
[13:24:33.332]   - Field: ‘packages’
[13:24:33.332]   - Field: ‘gc’
[13:24:33.332]   - Field: ‘conditions’
[13:24:33.332]   - Field: ‘persistent’
[13:24:33.333]   - Field: ‘expr’
[13:24:33.333]   - Field: ‘uuid’
[13:24:33.333]   - Field: ‘seed’
[13:24:33.333]   - Field: ‘version’
[13:24:33.333]   - Field: ‘result’
[13:24:33.333]   - Field: ‘asynchronous’
[13:24:33.333]   - Field: ‘calls’
[13:24:33.333]   - Field: ‘globals’
[13:24:33.333]   - Field: ‘stdout’
[13:24:33.333]   - Field: ‘earlySignal’
[13:24:33.333]   - Field: ‘lazy’
[13:24:33.334]   - Field: ‘state’
[13:24:33.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:33.334] - Launch lazy future ...
[13:24:33.334] Packages needed by the future expression (n = 0): <none>
[13:24:33.334] Packages needed by future strategies (n = 0): <none>
[13:24:33.335] {
[13:24:33.335]     {
[13:24:33.335]         {
[13:24:33.335]             ...future.startTime <- base::Sys.time()
[13:24:33.335]             {
[13:24:33.335]                 {
[13:24:33.335]                   {
[13:24:33.335]                     {
[13:24:33.335]                       base::local({
[13:24:33.335]                         has_future <- base::requireNamespace("future", 
[13:24:33.335]                           quietly = TRUE)
[13:24:33.335]                         if (has_future) {
[13:24:33.335]                           ns <- base::getNamespace("future")
[13:24:33.335]                           version <- ns[[".package"]][["version"]]
[13:24:33.335]                           if (is.null(version)) 
[13:24:33.335]                             version <- utils::packageVersion("future")
[13:24:33.335]                         }
[13:24:33.335]                         else {
[13:24:33.335]                           version <- NULL
[13:24:33.335]                         }
[13:24:33.335]                         if (!has_future || version < "1.8.0") {
[13:24:33.335]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:33.335]                             "", base::R.version$version.string), 
[13:24:33.335]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:33.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:33.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:33.335]                               "release", "version")], collapse = " "), 
[13:24:33.335]                             hostname = base::Sys.info()[["nodename"]])
[13:24:33.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:33.335]                             info)
[13:24:33.335]                           info <- base::paste(info, collapse = "; ")
[13:24:33.335]                           if (!has_future) {
[13:24:33.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:33.335]                               info)
[13:24:33.335]                           }
[13:24:33.335]                           else {
[13:24:33.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:33.335]                               info, version)
[13:24:33.335]                           }
[13:24:33.335]                           base::stop(msg)
[13:24:33.335]                         }
[13:24:33.335]                       })
[13:24:33.335]                     }
[13:24:33.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:33.335]                     base::options(mc.cores = 1L)
[13:24:33.335]                   }
[13:24:33.335]                   options(future.plan = NULL)
[13:24:33.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:33.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:33.335]                 }
[13:24:33.335]                 ...future.workdir <- getwd()
[13:24:33.335]             }
[13:24:33.335]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:33.335]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:33.335]         }
[13:24:33.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:33.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:33.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:33.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:33.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:33.335]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:33.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:33.335]             base::names(...future.oldOptions))
[13:24:33.335]     }
[13:24:33.335]     if (FALSE) {
[13:24:33.335]     }
[13:24:33.335]     else {
[13:24:33.335]         if (TRUE) {
[13:24:33.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:33.335]                 open = "w")
[13:24:33.335]         }
[13:24:33.335]         else {
[13:24:33.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:33.335]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:33.335]         }
[13:24:33.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:33.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:33.335]             base::sink(type = "output", split = FALSE)
[13:24:33.335]             base::close(...future.stdout)
[13:24:33.335]         }, add = TRUE)
[13:24:33.335]     }
[13:24:33.335]     ...future.frame <- base::sys.nframe()
[13:24:33.335]     ...future.conditions <- base::list()
[13:24:33.335]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:33.335]     if (FALSE) {
[13:24:33.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:33.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:33.335]     }
[13:24:33.335]     ...future.result <- base::tryCatch({
[13:24:33.335]         base::withCallingHandlers({
[13:24:33.335]             ...future.value <- base::withVisible(base::local({
[13:24:33.335]                 ...future.makeSendCondition <- base::local({
[13:24:33.335]                   sendCondition <- NULL
[13:24:33.335]                   function(frame = 1L) {
[13:24:33.335]                     if (is.function(sendCondition)) 
[13:24:33.335]                       return(sendCondition)
[13:24:33.335]                     ns <- getNamespace("parallel")
[13:24:33.335]                     if (exists("sendData", mode = "function", 
[13:24:33.335]                       envir = ns)) {
[13:24:33.335]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:33.335]                         envir = ns)
[13:24:33.335]                       envir <- sys.frame(frame)
[13:24:33.335]                       master <- NULL
[13:24:33.335]                       while (!identical(envir, .GlobalEnv) && 
[13:24:33.335]                         !identical(envir, emptyenv())) {
[13:24:33.335]                         if (exists("master", mode = "list", envir = envir, 
[13:24:33.335]                           inherits = FALSE)) {
[13:24:33.335]                           master <- get("master", mode = "list", 
[13:24:33.335]                             envir = envir, inherits = FALSE)
[13:24:33.335]                           if (inherits(master, c("SOCKnode", 
[13:24:33.335]                             "SOCK0node"))) {
[13:24:33.335]                             sendCondition <<- function(cond) {
[13:24:33.335]                               data <- list(type = "VALUE", value = cond, 
[13:24:33.335]                                 success = TRUE)
[13:24:33.335]                               parallel_sendData(master, data)
[13:24:33.335]                             }
[13:24:33.335]                             return(sendCondition)
[13:24:33.335]                           }
[13:24:33.335]                         }
[13:24:33.335]                         frame <- frame + 1L
[13:24:33.335]                         envir <- sys.frame(frame)
[13:24:33.335]                       }
[13:24:33.335]                     }
[13:24:33.335]                     sendCondition <<- function(cond) NULL
[13:24:33.335]                   }
[13:24:33.335]                 })
[13:24:33.335]                 withCallingHandlers({
[13:24:33.335]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:33.335]                 }, immediateCondition = function(cond) {
[13:24:33.335]                   sendCondition <- ...future.makeSendCondition()
[13:24:33.335]                   sendCondition(cond)
[13:24:33.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.335]                   {
[13:24:33.335]                     inherits <- base::inherits
[13:24:33.335]                     invokeRestart <- base::invokeRestart
[13:24:33.335]                     is.null <- base::is.null
[13:24:33.335]                     muffled <- FALSE
[13:24:33.335]                     if (inherits(cond, "message")) {
[13:24:33.335]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:33.335]                       if (muffled) 
[13:24:33.335]                         invokeRestart("muffleMessage")
[13:24:33.335]                     }
[13:24:33.335]                     else if (inherits(cond, "warning")) {
[13:24:33.335]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:33.335]                       if (muffled) 
[13:24:33.335]                         invokeRestart("muffleWarning")
[13:24:33.335]                     }
[13:24:33.335]                     else if (inherits(cond, "condition")) {
[13:24:33.335]                       if (!is.null(pattern)) {
[13:24:33.335]                         computeRestarts <- base::computeRestarts
[13:24:33.335]                         grepl <- base::grepl
[13:24:33.335]                         restarts <- computeRestarts(cond)
[13:24:33.335]                         for (restart in restarts) {
[13:24:33.335]                           name <- restart$name
[13:24:33.335]                           if (is.null(name)) 
[13:24:33.335]                             next
[13:24:33.335]                           if (!grepl(pattern, name)) 
[13:24:33.335]                             next
[13:24:33.335]                           invokeRestart(restart)
[13:24:33.335]                           muffled <- TRUE
[13:24:33.335]                           break
[13:24:33.335]                         }
[13:24:33.335]                       }
[13:24:33.335]                     }
[13:24:33.335]                     invisible(muffled)
[13:24:33.335]                   }
[13:24:33.335]                   muffleCondition(cond)
[13:24:33.335]                 })
[13:24:33.335]             }))
[13:24:33.335]             future::FutureResult(value = ...future.value$value, 
[13:24:33.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:33.335]                   ...future.rng), globalenv = if (FALSE) 
[13:24:33.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:33.335]                     ...future.globalenv.names))
[13:24:33.335]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:33.335]         }, condition = base::local({
[13:24:33.335]             c <- base::c
[13:24:33.335]             inherits <- base::inherits
[13:24:33.335]             invokeRestart <- base::invokeRestart
[13:24:33.335]             length <- base::length
[13:24:33.335]             list <- base::list
[13:24:33.335]             seq.int <- base::seq.int
[13:24:33.335]             signalCondition <- base::signalCondition
[13:24:33.335]             sys.calls <- base::sys.calls
[13:24:33.335]             `[[` <- base::`[[`
[13:24:33.335]             `+` <- base::`+`
[13:24:33.335]             `<<-` <- base::`<<-`
[13:24:33.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:33.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:33.335]                   3L)]
[13:24:33.335]             }
[13:24:33.335]             function(cond) {
[13:24:33.335]                 is_error <- inherits(cond, "error")
[13:24:33.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:33.335]                   NULL)
[13:24:33.335]                 if (is_error) {
[13:24:33.335]                   sessionInformation <- function() {
[13:24:33.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:33.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:33.335]                       search = base::search(), system = base::Sys.info())
[13:24:33.335]                   }
[13:24:33.335]                   ...future.conditions[[length(...future.conditions) + 
[13:24:33.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:33.335]                     cond$call), session = sessionInformation(), 
[13:24:33.335]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:33.335]                   signalCondition(cond)
[13:24:33.335]                 }
[13:24:33.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:33.335]                 "immediateCondition"))) {
[13:24:33.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:33.335]                   ...future.conditions[[length(...future.conditions) + 
[13:24:33.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:33.335]                   if (TRUE && !signal) {
[13:24:33.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.335]                     {
[13:24:33.335]                       inherits <- base::inherits
[13:24:33.335]                       invokeRestart <- base::invokeRestart
[13:24:33.335]                       is.null <- base::is.null
[13:24:33.335]                       muffled <- FALSE
[13:24:33.335]                       if (inherits(cond, "message")) {
[13:24:33.335]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:33.335]                         if (muffled) 
[13:24:33.335]                           invokeRestart("muffleMessage")
[13:24:33.335]                       }
[13:24:33.335]                       else if (inherits(cond, "warning")) {
[13:24:33.335]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:33.335]                         if (muffled) 
[13:24:33.335]                           invokeRestart("muffleWarning")
[13:24:33.335]                       }
[13:24:33.335]                       else if (inherits(cond, "condition")) {
[13:24:33.335]                         if (!is.null(pattern)) {
[13:24:33.335]                           computeRestarts <- base::computeRestarts
[13:24:33.335]                           grepl <- base::grepl
[13:24:33.335]                           restarts <- computeRestarts(cond)
[13:24:33.335]                           for (restart in restarts) {
[13:24:33.335]                             name <- restart$name
[13:24:33.335]                             if (is.null(name)) 
[13:24:33.335]                               next
[13:24:33.335]                             if (!grepl(pattern, name)) 
[13:24:33.335]                               next
[13:24:33.335]                             invokeRestart(restart)
[13:24:33.335]                             muffled <- TRUE
[13:24:33.335]                             break
[13:24:33.335]                           }
[13:24:33.335]                         }
[13:24:33.335]                       }
[13:24:33.335]                       invisible(muffled)
[13:24:33.335]                     }
[13:24:33.335]                     muffleCondition(cond, pattern = "^muffle")
[13:24:33.335]                   }
[13:24:33.335]                 }
[13:24:33.335]                 else {
[13:24:33.335]                   if (TRUE) {
[13:24:33.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.335]                     {
[13:24:33.335]                       inherits <- base::inherits
[13:24:33.335]                       invokeRestart <- base::invokeRestart
[13:24:33.335]                       is.null <- base::is.null
[13:24:33.335]                       muffled <- FALSE
[13:24:33.335]                       if (inherits(cond, "message")) {
[13:24:33.335]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:33.335]                         if (muffled) 
[13:24:33.335]                           invokeRestart("muffleMessage")
[13:24:33.335]                       }
[13:24:33.335]                       else if (inherits(cond, "warning")) {
[13:24:33.335]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:33.335]                         if (muffled) 
[13:24:33.335]                           invokeRestart("muffleWarning")
[13:24:33.335]                       }
[13:24:33.335]                       else if (inherits(cond, "condition")) {
[13:24:33.335]                         if (!is.null(pattern)) {
[13:24:33.335]                           computeRestarts <- base::computeRestarts
[13:24:33.335]                           grepl <- base::grepl
[13:24:33.335]                           restarts <- computeRestarts(cond)
[13:24:33.335]                           for (restart in restarts) {
[13:24:33.335]                             name <- restart$name
[13:24:33.335]                             if (is.null(name)) 
[13:24:33.335]                               next
[13:24:33.335]                             if (!grepl(pattern, name)) 
[13:24:33.335]                               next
[13:24:33.335]                             invokeRestart(restart)
[13:24:33.335]                             muffled <- TRUE
[13:24:33.335]                             break
[13:24:33.335]                           }
[13:24:33.335]                         }
[13:24:33.335]                       }
[13:24:33.335]                       invisible(muffled)
[13:24:33.335]                     }
[13:24:33.335]                     muffleCondition(cond, pattern = "^muffle")
[13:24:33.335]                   }
[13:24:33.335]                 }
[13:24:33.335]             }
[13:24:33.335]         }))
[13:24:33.335]     }, error = function(ex) {
[13:24:33.335]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:33.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:33.335]                 ...future.rng), started = ...future.startTime, 
[13:24:33.335]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:33.335]             version = "1.8"), class = "FutureResult")
[13:24:33.335]     }, finally = {
[13:24:33.335]         if (!identical(...future.workdir, getwd())) 
[13:24:33.335]             setwd(...future.workdir)
[13:24:33.335]         {
[13:24:33.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:33.335]                 ...future.oldOptions$nwarnings <- NULL
[13:24:33.335]             }
[13:24:33.335]             base::options(...future.oldOptions)
[13:24:33.335]             if (.Platform$OS.type == "windows") {
[13:24:33.335]                 old_names <- names(...future.oldEnvVars)
[13:24:33.335]                 envs <- base::Sys.getenv()
[13:24:33.335]                 names <- names(envs)
[13:24:33.335]                 common <- intersect(names, old_names)
[13:24:33.335]                 added <- setdiff(names, old_names)
[13:24:33.335]                 removed <- setdiff(old_names, names)
[13:24:33.335]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:33.335]                   envs[common]]
[13:24:33.335]                 NAMES <- toupper(changed)
[13:24:33.335]                 args <- list()
[13:24:33.335]                 for (kk in seq_along(NAMES)) {
[13:24:33.335]                   name <- changed[[kk]]
[13:24:33.335]                   NAME <- NAMES[[kk]]
[13:24:33.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.335]                     next
[13:24:33.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:33.335]                 }
[13:24:33.335]                 NAMES <- toupper(added)
[13:24:33.335]                 for (kk in seq_along(NAMES)) {
[13:24:33.335]                   name <- added[[kk]]
[13:24:33.335]                   NAME <- NAMES[[kk]]
[13:24:33.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.335]                     next
[13:24:33.335]                   args[[name]] <- ""
[13:24:33.335]                 }
[13:24:33.335]                 NAMES <- toupper(removed)
[13:24:33.335]                 for (kk in seq_along(NAMES)) {
[13:24:33.335]                   name <- removed[[kk]]
[13:24:33.335]                   NAME <- NAMES[[kk]]
[13:24:33.335]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.335]                     next
[13:24:33.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:33.335]                 }
[13:24:33.335]                 if (length(args) > 0) 
[13:24:33.335]                   base::do.call(base::Sys.setenv, args = args)
[13:24:33.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:33.335]             }
[13:24:33.335]             else {
[13:24:33.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:33.335]             }
[13:24:33.335]             {
[13:24:33.335]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:33.335]                   0L) {
[13:24:33.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:33.335]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:33.335]                   base::options(opts)
[13:24:33.335]                 }
[13:24:33.335]                 {
[13:24:33.335]                   {
[13:24:33.335]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:33.335]                     NULL
[13:24:33.335]                   }
[13:24:33.335]                   options(future.plan = NULL)
[13:24:33.335]                   if (is.na(NA_character_)) 
[13:24:33.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:33.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:33.335]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:33.335]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:33.335]                     envir = parent.frame()) 
[13:24:33.335]                   {
[13:24:33.335]                     if (is.function(workers)) 
[13:24:33.335]                       workers <- workers()
[13:24:33.335]                     workers <- structure(as.integer(workers), 
[13:24:33.335]                       class = class(workers))
[13:24:33.335]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:33.335]                       workers >= 1)
[13:24:33.335]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:33.335]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:33.335]                     }
[13:24:33.335]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:33.335]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:33.335]                       envir = envir)
[13:24:33.335]                     if (!future$lazy) 
[13:24:33.335]                       future <- run(future)
[13:24:33.335]                     invisible(future)
[13:24:33.335]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:33.335]                 }
[13:24:33.335]             }
[13:24:33.335]         }
[13:24:33.335]     })
[13:24:33.335]     if (TRUE) {
[13:24:33.335]         base::sink(type = "output", split = FALSE)
[13:24:33.335]         if (TRUE) {
[13:24:33.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:33.335]         }
[13:24:33.335]         else {
[13:24:33.335]             ...future.result["stdout"] <- base::list(NULL)
[13:24:33.335]         }
[13:24:33.335]         base::close(...future.stdout)
[13:24:33.335]         ...future.stdout <- NULL
[13:24:33.335]     }
[13:24:33.335]     ...future.result$conditions <- ...future.conditions
[13:24:33.335]     ...future.result$finished <- base::Sys.time()
[13:24:33.335]     ...future.result
[13:24:33.335] }
[13:24:33.338] MultisessionFuture started
[13:24:33.338] - Launch lazy future ... done
[13:24:33.338] run() for ‘MultisessionFuture’ ... done
[13:24:33.385] receiveMessageFromWorker() for ClusterFuture ...
[13:24:33.385] - Validating connection of MultisessionFuture
[13:24:33.386] - received message: FutureResult
[13:24:33.386] - Received FutureResult
[13:24:33.386] - Erased future from FutureRegistry
[13:24:33.386] result() for ClusterFuture ...
[13:24:33.386] - result already collected: FutureResult
[13:24:33.387] result() for ClusterFuture ... done
[13:24:33.387] signalConditions() ...
[13:24:33.387]  - include = ‘immediateCondition’
[13:24:33.387]  - exclude = 
[13:24:33.387]  - resignal = FALSE
[13:24:33.387]  - Number of conditions: 1
[13:24:33.387] signalConditions() ... done
[13:24:33.387] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:33.387] A MultisessionFuture was resolved (result was not collected)
[13:24:33.387] getGlobalsAndPackages() ...
[13:24:33.387] Searching for globals...
[13:24:33.388] - globals found: [2] ‘list’, ‘stop’
[13:24:33.388] Searching for globals ... DONE
[13:24:33.388] Resolving globals: FALSE
[13:24:33.389] 
[13:24:33.389] 
[13:24:33.389] getGlobalsAndPackages() ... DONE
[13:24:33.389] run() for ‘Future’ ...
[13:24:33.389] - state: ‘created’
[13:24:33.389] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:33.403] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:33.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:33.403]   - Field: ‘node’
[13:24:33.404]   - Field: ‘label’
[13:24:33.404]   - Field: ‘local’
[13:24:33.404]   - Field: ‘owner’
[13:24:33.404]   - Field: ‘envir’
[13:24:33.404]   - Field: ‘workers’
[13:24:33.404]   - Field: ‘packages’
[13:24:33.404]   - Field: ‘gc’
[13:24:33.404]   - Field: ‘conditions’
[13:24:33.404]   - Field: ‘persistent’
[13:24:33.405]   - Field: ‘expr’
[13:24:33.405]   - Field: ‘uuid’
[13:24:33.405]   - Field: ‘seed’
[13:24:33.405]   - Field: ‘version’
[13:24:33.405]   - Field: ‘result’
[13:24:33.405]   - Field: ‘asynchronous’
[13:24:33.405]   - Field: ‘calls’
[13:24:33.405]   - Field: ‘globals’
[13:24:33.405]   - Field: ‘stdout’
[13:24:33.405]   - Field: ‘earlySignal’
[13:24:33.405]   - Field: ‘lazy’
[13:24:33.406]   - Field: ‘state’
[13:24:33.406] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:33.406] - Launch lazy future ...
[13:24:33.406] Packages needed by the future expression (n = 0): <none>
[13:24:33.406] Packages needed by future strategies (n = 0): <none>
[13:24:33.407] {
[13:24:33.407]     {
[13:24:33.407]         {
[13:24:33.407]             ...future.startTime <- base::Sys.time()
[13:24:33.407]             {
[13:24:33.407]                 {
[13:24:33.407]                   {
[13:24:33.407]                     {
[13:24:33.407]                       base::local({
[13:24:33.407]                         has_future <- base::requireNamespace("future", 
[13:24:33.407]                           quietly = TRUE)
[13:24:33.407]                         if (has_future) {
[13:24:33.407]                           ns <- base::getNamespace("future")
[13:24:33.407]                           version <- ns[[".package"]][["version"]]
[13:24:33.407]                           if (is.null(version)) 
[13:24:33.407]                             version <- utils::packageVersion("future")
[13:24:33.407]                         }
[13:24:33.407]                         else {
[13:24:33.407]                           version <- NULL
[13:24:33.407]                         }
[13:24:33.407]                         if (!has_future || version < "1.8.0") {
[13:24:33.407]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:33.407]                             "", base::R.version$version.string), 
[13:24:33.407]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:33.407]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:33.407]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:33.407]                               "release", "version")], collapse = " "), 
[13:24:33.407]                             hostname = base::Sys.info()[["nodename"]])
[13:24:33.407]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:33.407]                             info)
[13:24:33.407]                           info <- base::paste(info, collapse = "; ")
[13:24:33.407]                           if (!has_future) {
[13:24:33.407]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:33.407]                               info)
[13:24:33.407]                           }
[13:24:33.407]                           else {
[13:24:33.407]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:33.407]                               info, version)
[13:24:33.407]                           }
[13:24:33.407]                           base::stop(msg)
[13:24:33.407]                         }
[13:24:33.407]                       })
[13:24:33.407]                     }
[13:24:33.407]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:33.407]                     base::options(mc.cores = 1L)
[13:24:33.407]                   }
[13:24:33.407]                   options(future.plan = NULL)
[13:24:33.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:33.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:33.407]                 }
[13:24:33.407]                 ...future.workdir <- getwd()
[13:24:33.407]             }
[13:24:33.407]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:33.407]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:33.407]         }
[13:24:33.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:33.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:33.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:33.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:33.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:33.407]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:33.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:33.407]             base::names(...future.oldOptions))
[13:24:33.407]     }
[13:24:33.407]     if (FALSE) {
[13:24:33.407]     }
[13:24:33.407]     else {
[13:24:33.407]         if (TRUE) {
[13:24:33.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:33.407]                 open = "w")
[13:24:33.407]         }
[13:24:33.407]         else {
[13:24:33.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:33.407]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:33.407]         }
[13:24:33.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:33.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:33.407]             base::sink(type = "output", split = FALSE)
[13:24:33.407]             base::close(...future.stdout)
[13:24:33.407]         }, add = TRUE)
[13:24:33.407]     }
[13:24:33.407]     ...future.frame <- base::sys.nframe()
[13:24:33.407]     ...future.conditions <- base::list()
[13:24:33.407]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:33.407]     if (FALSE) {
[13:24:33.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:33.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:33.407]     }
[13:24:33.407]     ...future.result <- base::tryCatch({
[13:24:33.407]         base::withCallingHandlers({
[13:24:33.407]             ...future.value <- base::withVisible(base::local({
[13:24:33.407]                 ...future.makeSendCondition <- base::local({
[13:24:33.407]                   sendCondition <- NULL
[13:24:33.407]                   function(frame = 1L) {
[13:24:33.407]                     if (is.function(sendCondition)) 
[13:24:33.407]                       return(sendCondition)
[13:24:33.407]                     ns <- getNamespace("parallel")
[13:24:33.407]                     if (exists("sendData", mode = "function", 
[13:24:33.407]                       envir = ns)) {
[13:24:33.407]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:33.407]                         envir = ns)
[13:24:33.407]                       envir <- sys.frame(frame)
[13:24:33.407]                       master <- NULL
[13:24:33.407]                       while (!identical(envir, .GlobalEnv) && 
[13:24:33.407]                         !identical(envir, emptyenv())) {
[13:24:33.407]                         if (exists("master", mode = "list", envir = envir, 
[13:24:33.407]                           inherits = FALSE)) {
[13:24:33.407]                           master <- get("master", mode = "list", 
[13:24:33.407]                             envir = envir, inherits = FALSE)
[13:24:33.407]                           if (inherits(master, c("SOCKnode", 
[13:24:33.407]                             "SOCK0node"))) {
[13:24:33.407]                             sendCondition <<- function(cond) {
[13:24:33.407]                               data <- list(type = "VALUE", value = cond, 
[13:24:33.407]                                 success = TRUE)
[13:24:33.407]                               parallel_sendData(master, data)
[13:24:33.407]                             }
[13:24:33.407]                             return(sendCondition)
[13:24:33.407]                           }
[13:24:33.407]                         }
[13:24:33.407]                         frame <- frame + 1L
[13:24:33.407]                         envir <- sys.frame(frame)
[13:24:33.407]                       }
[13:24:33.407]                     }
[13:24:33.407]                     sendCondition <<- function(cond) NULL
[13:24:33.407]                   }
[13:24:33.407]                 })
[13:24:33.407]                 withCallingHandlers({
[13:24:33.407]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:33.407]                 }, immediateCondition = function(cond) {
[13:24:33.407]                   sendCondition <- ...future.makeSendCondition()
[13:24:33.407]                   sendCondition(cond)
[13:24:33.407]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.407]                   {
[13:24:33.407]                     inherits <- base::inherits
[13:24:33.407]                     invokeRestart <- base::invokeRestart
[13:24:33.407]                     is.null <- base::is.null
[13:24:33.407]                     muffled <- FALSE
[13:24:33.407]                     if (inherits(cond, "message")) {
[13:24:33.407]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:33.407]                       if (muffled) 
[13:24:33.407]                         invokeRestart("muffleMessage")
[13:24:33.407]                     }
[13:24:33.407]                     else if (inherits(cond, "warning")) {
[13:24:33.407]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:33.407]                       if (muffled) 
[13:24:33.407]                         invokeRestart("muffleWarning")
[13:24:33.407]                     }
[13:24:33.407]                     else if (inherits(cond, "condition")) {
[13:24:33.407]                       if (!is.null(pattern)) {
[13:24:33.407]                         computeRestarts <- base::computeRestarts
[13:24:33.407]                         grepl <- base::grepl
[13:24:33.407]                         restarts <- computeRestarts(cond)
[13:24:33.407]                         for (restart in restarts) {
[13:24:33.407]                           name <- restart$name
[13:24:33.407]                           if (is.null(name)) 
[13:24:33.407]                             next
[13:24:33.407]                           if (!grepl(pattern, name)) 
[13:24:33.407]                             next
[13:24:33.407]                           invokeRestart(restart)
[13:24:33.407]                           muffled <- TRUE
[13:24:33.407]                           break
[13:24:33.407]                         }
[13:24:33.407]                       }
[13:24:33.407]                     }
[13:24:33.407]                     invisible(muffled)
[13:24:33.407]                   }
[13:24:33.407]                   muffleCondition(cond)
[13:24:33.407]                 })
[13:24:33.407]             }))
[13:24:33.407]             future::FutureResult(value = ...future.value$value, 
[13:24:33.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:33.407]                   ...future.rng), globalenv = if (FALSE) 
[13:24:33.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:33.407]                     ...future.globalenv.names))
[13:24:33.407]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:33.407]         }, condition = base::local({
[13:24:33.407]             c <- base::c
[13:24:33.407]             inherits <- base::inherits
[13:24:33.407]             invokeRestart <- base::invokeRestart
[13:24:33.407]             length <- base::length
[13:24:33.407]             list <- base::list
[13:24:33.407]             seq.int <- base::seq.int
[13:24:33.407]             signalCondition <- base::signalCondition
[13:24:33.407]             sys.calls <- base::sys.calls
[13:24:33.407]             `[[` <- base::`[[`
[13:24:33.407]             `+` <- base::`+`
[13:24:33.407]             `<<-` <- base::`<<-`
[13:24:33.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:33.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:33.407]                   3L)]
[13:24:33.407]             }
[13:24:33.407]             function(cond) {
[13:24:33.407]                 is_error <- inherits(cond, "error")
[13:24:33.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:33.407]                   NULL)
[13:24:33.407]                 if (is_error) {
[13:24:33.407]                   sessionInformation <- function() {
[13:24:33.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:33.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:33.407]                       search = base::search(), system = base::Sys.info())
[13:24:33.407]                   }
[13:24:33.407]                   ...future.conditions[[length(...future.conditions) + 
[13:24:33.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:33.407]                     cond$call), session = sessionInformation(), 
[13:24:33.407]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:33.407]                   signalCondition(cond)
[13:24:33.407]                 }
[13:24:33.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:33.407]                 "immediateCondition"))) {
[13:24:33.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:33.407]                   ...future.conditions[[length(...future.conditions) + 
[13:24:33.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:33.407]                   if (TRUE && !signal) {
[13:24:33.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.407]                     {
[13:24:33.407]                       inherits <- base::inherits
[13:24:33.407]                       invokeRestart <- base::invokeRestart
[13:24:33.407]                       is.null <- base::is.null
[13:24:33.407]                       muffled <- FALSE
[13:24:33.407]                       if (inherits(cond, "message")) {
[13:24:33.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:33.407]                         if (muffled) 
[13:24:33.407]                           invokeRestart("muffleMessage")
[13:24:33.407]                       }
[13:24:33.407]                       else if (inherits(cond, "warning")) {
[13:24:33.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:33.407]                         if (muffled) 
[13:24:33.407]                           invokeRestart("muffleWarning")
[13:24:33.407]                       }
[13:24:33.407]                       else if (inherits(cond, "condition")) {
[13:24:33.407]                         if (!is.null(pattern)) {
[13:24:33.407]                           computeRestarts <- base::computeRestarts
[13:24:33.407]                           grepl <- base::grepl
[13:24:33.407]                           restarts <- computeRestarts(cond)
[13:24:33.407]                           for (restart in restarts) {
[13:24:33.407]                             name <- restart$name
[13:24:33.407]                             if (is.null(name)) 
[13:24:33.407]                               next
[13:24:33.407]                             if (!grepl(pattern, name)) 
[13:24:33.407]                               next
[13:24:33.407]                             invokeRestart(restart)
[13:24:33.407]                             muffled <- TRUE
[13:24:33.407]                             break
[13:24:33.407]                           }
[13:24:33.407]                         }
[13:24:33.407]                       }
[13:24:33.407]                       invisible(muffled)
[13:24:33.407]                     }
[13:24:33.407]                     muffleCondition(cond, pattern = "^muffle")
[13:24:33.407]                   }
[13:24:33.407]                 }
[13:24:33.407]                 else {
[13:24:33.407]                   if (TRUE) {
[13:24:33.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.407]                     {
[13:24:33.407]                       inherits <- base::inherits
[13:24:33.407]                       invokeRestart <- base::invokeRestart
[13:24:33.407]                       is.null <- base::is.null
[13:24:33.407]                       muffled <- FALSE
[13:24:33.407]                       if (inherits(cond, "message")) {
[13:24:33.407]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:33.407]                         if (muffled) 
[13:24:33.407]                           invokeRestart("muffleMessage")
[13:24:33.407]                       }
[13:24:33.407]                       else if (inherits(cond, "warning")) {
[13:24:33.407]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:33.407]                         if (muffled) 
[13:24:33.407]                           invokeRestart("muffleWarning")
[13:24:33.407]                       }
[13:24:33.407]                       else if (inherits(cond, "condition")) {
[13:24:33.407]                         if (!is.null(pattern)) {
[13:24:33.407]                           computeRestarts <- base::computeRestarts
[13:24:33.407]                           grepl <- base::grepl
[13:24:33.407]                           restarts <- computeRestarts(cond)
[13:24:33.407]                           for (restart in restarts) {
[13:24:33.407]                             name <- restart$name
[13:24:33.407]                             if (is.null(name)) 
[13:24:33.407]                               next
[13:24:33.407]                             if (!grepl(pattern, name)) 
[13:24:33.407]                               next
[13:24:33.407]                             invokeRestart(restart)
[13:24:33.407]                             muffled <- TRUE
[13:24:33.407]                             break
[13:24:33.407]                           }
[13:24:33.407]                         }
[13:24:33.407]                       }
[13:24:33.407]                       invisible(muffled)
[13:24:33.407]                     }
[13:24:33.407]                     muffleCondition(cond, pattern = "^muffle")
[13:24:33.407]                   }
[13:24:33.407]                 }
[13:24:33.407]             }
[13:24:33.407]         }))
[13:24:33.407]     }, error = function(ex) {
[13:24:33.407]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:33.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:33.407]                 ...future.rng), started = ...future.startTime, 
[13:24:33.407]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:33.407]             version = "1.8"), class = "FutureResult")
[13:24:33.407]     }, finally = {
[13:24:33.407]         if (!identical(...future.workdir, getwd())) 
[13:24:33.407]             setwd(...future.workdir)
[13:24:33.407]         {
[13:24:33.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:33.407]                 ...future.oldOptions$nwarnings <- NULL
[13:24:33.407]             }
[13:24:33.407]             base::options(...future.oldOptions)
[13:24:33.407]             if (.Platform$OS.type == "windows") {
[13:24:33.407]                 old_names <- names(...future.oldEnvVars)
[13:24:33.407]                 envs <- base::Sys.getenv()
[13:24:33.407]                 names <- names(envs)
[13:24:33.407]                 common <- intersect(names, old_names)
[13:24:33.407]                 added <- setdiff(names, old_names)
[13:24:33.407]                 removed <- setdiff(old_names, names)
[13:24:33.407]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:33.407]                   envs[common]]
[13:24:33.407]                 NAMES <- toupper(changed)
[13:24:33.407]                 args <- list()
[13:24:33.407]                 for (kk in seq_along(NAMES)) {
[13:24:33.407]                   name <- changed[[kk]]
[13:24:33.407]                   NAME <- NAMES[[kk]]
[13:24:33.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.407]                     next
[13:24:33.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:33.407]                 }
[13:24:33.407]                 NAMES <- toupper(added)
[13:24:33.407]                 for (kk in seq_along(NAMES)) {
[13:24:33.407]                   name <- added[[kk]]
[13:24:33.407]                   NAME <- NAMES[[kk]]
[13:24:33.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.407]                     next
[13:24:33.407]                   args[[name]] <- ""
[13:24:33.407]                 }
[13:24:33.407]                 NAMES <- toupper(removed)
[13:24:33.407]                 for (kk in seq_along(NAMES)) {
[13:24:33.407]                   name <- removed[[kk]]
[13:24:33.407]                   NAME <- NAMES[[kk]]
[13:24:33.407]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.407]                     next
[13:24:33.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:33.407]                 }
[13:24:33.407]                 if (length(args) > 0) 
[13:24:33.407]                   base::do.call(base::Sys.setenv, args = args)
[13:24:33.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:33.407]             }
[13:24:33.407]             else {
[13:24:33.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:33.407]             }
[13:24:33.407]             {
[13:24:33.407]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:33.407]                   0L) {
[13:24:33.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:33.407]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:33.407]                   base::options(opts)
[13:24:33.407]                 }
[13:24:33.407]                 {
[13:24:33.407]                   {
[13:24:33.407]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:33.407]                     NULL
[13:24:33.407]                   }
[13:24:33.407]                   options(future.plan = NULL)
[13:24:33.407]                   if (is.na(NA_character_)) 
[13:24:33.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:33.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:33.407]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:33.407]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:33.407]                     envir = parent.frame()) 
[13:24:33.407]                   {
[13:24:33.407]                     if (is.function(workers)) 
[13:24:33.407]                       workers <- workers()
[13:24:33.407]                     workers <- structure(as.integer(workers), 
[13:24:33.407]                       class = class(workers))
[13:24:33.407]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:33.407]                       workers >= 1)
[13:24:33.407]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:33.407]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:33.407]                     }
[13:24:33.407]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:33.407]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:33.407]                       envir = envir)
[13:24:33.407]                     if (!future$lazy) 
[13:24:33.407]                       future <- run(future)
[13:24:33.407]                     invisible(future)
[13:24:33.407]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:33.407]                 }
[13:24:33.407]             }
[13:24:33.407]         }
[13:24:33.407]     })
[13:24:33.407]     if (TRUE) {
[13:24:33.407]         base::sink(type = "output", split = FALSE)
[13:24:33.407]         if (TRUE) {
[13:24:33.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:33.407]         }
[13:24:33.407]         else {
[13:24:33.407]             ...future.result["stdout"] <- base::list(NULL)
[13:24:33.407]         }
[13:24:33.407]         base::close(...future.stdout)
[13:24:33.407]         ...future.stdout <- NULL
[13:24:33.407]     }
[13:24:33.407]     ...future.result$conditions <- ...future.conditions
[13:24:33.407]     ...future.result$finished <- base::Sys.time()
[13:24:33.407]     ...future.result
[13:24:33.407] }
[13:24:33.410] MultisessionFuture started
[13:24:33.410] - Launch lazy future ... done
[13:24:33.410] run() for ‘MultisessionFuture’ ... done
[13:24:33.457] receiveMessageFromWorker() for ClusterFuture ...
[13:24:33.458] - Validating connection of MultisessionFuture
[13:24:33.458] - received message: FutureResult
[13:24:33.458] - Received FutureResult
[13:24:33.458] - Erased future from FutureRegistry
[13:24:33.458] result() for ClusterFuture ...
[13:24:33.459] - result already collected: FutureResult
[13:24:33.459] result() for ClusterFuture ... done
[13:24:33.459] signalConditions() ...
[13:24:33.459]  - include = ‘immediateCondition’
[13:24:33.459]  - exclude = 
[13:24:33.459]  - resignal = FALSE
[13:24:33.459]  - Number of conditions: 1
[13:24:33.459] signalConditions() ... done
[13:24:33.459] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:33.459] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[13:24:33.460] getGlobalsAndPackages() ...
[13:24:33.460] Searching for globals...
[13:24:33.461] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:33.461] Searching for globals ... DONE
[13:24:33.461] Resolving globals: FALSE
[13:24:33.462] 
[13:24:33.462] 
[13:24:33.462] getGlobalsAndPackages() ... DONE
[13:24:33.462] run() for ‘Future’ ...
[13:24:33.462] - state: ‘created’
[13:24:33.462] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:33.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:33.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:33.477]   - Field: ‘node’
[13:24:33.477]   - Field: ‘label’
[13:24:33.477]   - Field: ‘local’
[13:24:33.477]   - Field: ‘owner’
[13:24:33.477]   - Field: ‘envir’
[13:24:33.477]   - Field: ‘workers’
[13:24:33.477]   - Field: ‘packages’
[13:24:33.477]   - Field: ‘gc’
[13:24:33.477]   - Field: ‘conditions’
[13:24:33.478]   - Field: ‘persistent’
[13:24:33.478]   - Field: ‘expr’
[13:24:33.478]   - Field: ‘uuid’
[13:24:33.478]   - Field: ‘seed’
[13:24:33.478]   - Field: ‘version’
[13:24:33.478]   - Field: ‘result’
[13:24:33.478]   - Field: ‘asynchronous’
[13:24:33.478]   - Field: ‘calls’
[13:24:33.478]   - Field: ‘globals’
[13:24:33.478]   - Field: ‘stdout’
[13:24:33.478]   - Field: ‘earlySignal’
[13:24:33.479]   - Field: ‘lazy’
[13:24:33.479]   - Field: ‘state’
[13:24:33.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:33.479] - Launch lazy future ...
[13:24:33.479] Packages needed by the future expression (n = 0): <none>
[13:24:33.479] Packages needed by future strategies (n = 0): <none>
[13:24:33.480] {
[13:24:33.480]     {
[13:24:33.480]         {
[13:24:33.480]             ...future.startTime <- base::Sys.time()
[13:24:33.480]             {
[13:24:33.480]                 {
[13:24:33.480]                   {
[13:24:33.480]                     {
[13:24:33.480]                       base::local({
[13:24:33.480]                         has_future <- base::requireNamespace("future", 
[13:24:33.480]                           quietly = TRUE)
[13:24:33.480]                         if (has_future) {
[13:24:33.480]                           ns <- base::getNamespace("future")
[13:24:33.480]                           version <- ns[[".package"]][["version"]]
[13:24:33.480]                           if (is.null(version)) 
[13:24:33.480]                             version <- utils::packageVersion("future")
[13:24:33.480]                         }
[13:24:33.480]                         else {
[13:24:33.480]                           version <- NULL
[13:24:33.480]                         }
[13:24:33.480]                         if (!has_future || version < "1.8.0") {
[13:24:33.480]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:33.480]                             "", base::R.version$version.string), 
[13:24:33.480]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:33.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:33.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:33.480]                               "release", "version")], collapse = " "), 
[13:24:33.480]                             hostname = base::Sys.info()[["nodename"]])
[13:24:33.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:33.480]                             info)
[13:24:33.480]                           info <- base::paste(info, collapse = "; ")
[13:24:33.480]                           if (!has_future) {
[13:24:33.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:33.480]                               info)
[13:24:33.480]                           }
[13:24:33.480]                           else {
[13:24:33.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:33.480]                               info, version)
[13:24:33.480]                           }
[13:24:33.480]                           base::stop(msg)
[13:24:33.480]                         }
[13:24:33.480]                       })
[13:24:33.480]                     }
[13:24:33.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:33.480]                     base::options(mc.cores = 1L)
[13:24:33.480]                   }
[13:24:33.480]                   options(future.plan = NULL)
[13:24:33.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:33.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:33.480]                 }
[13:24:33.480]                 ...future.workdir <- getwd()
[13:24:33.480]             }
[13:24:33.480]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:33.480]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:33.480]         }
[13:24:33.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:33.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:33.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:33.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:33.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:33.480]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:33.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:33.480]             base::names(...future.oldOptions))
[13:24:33.480]     }
[13:24:33.480]     if (FALSE) {
[13:24:33.480]     }
[13:24:33.480]     else {
[13:24:33.480]         if (TRUE) {
[13:24:33.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:33.480]                 open = "w")
[13:24:33.480]         }
[13:24:33.480]         else {
[13:24:33.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:33.480]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:33.480]         }
[13:24:33.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:33.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:33.480]             base::sink(type = "output", split = FALSE)
[13:24:33.480]             base::close(...future.stdout)
[13:24:33.480]         }, add = TRUE)
[13:24:33.480]     }
[13:24:33.480]     ...future.frame <- base::sys.nframe()
[13:24:33.480]     ...future.conditions <- base::list()
[13:24:33.480]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:33.480]     if (FALSE) {
[13:24:33.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:33.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:33.480]     }
[13:24:33.480]     ...future.result <- base::tryCatch({
[13:24:33.480]         base::withCallingHandlers({
[13:24:33.480]             ...future.value <- base::withVisible(base::local({
[13:24:33.480]                 ...future.makeSendCondition <- base::local({
[13:24:33.480]                   sendCondition <- NULL
[13:24:33.480]                   function(frame = 1L) {
[13:24:33.480]                     if (is.function(sendCondition)) 
[13:24:33.480]                       return(sendCondition)
[13:24:33.480]                     ns <- getNamespace("parallel")
[13:24:33.480]                     if (exists("sendData", mode = "function", 
[13:24:33.480]                       envir = ns)) {
[13:24:33.480]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:33.480]                         envir = ns)
[13:24:33.480]                       envir <- sys.frame(frame)
[13:24:33.480]                       master <- NULL
[13:24:33.480]                       while (!identical(envir, .GlobalEnv) && 
[13:24:33.480]                         !identical(envir, emptyenv())) {
[13:24:33.480]                         if (exists("master", mode = "list", envir = envir, 
[13:24:33.480]                           inherits = FALSE)) {
[13:24:33.480]                           master <- get("master", mode = "list", 
[13:24:33.480]                             envir = envir, inherits = FALSE)
[13:24:33.480]                           if (inherits(master, c("SOCKnode", 
[13:24:33.480]                             "SOCK0node"))) {
[13:24:33.480]                             sendCondition <<- function(cond) {
[13:24:33.480]                               data <- list(type = "VALUE", value = cond, 
[13:24:33.480]                                 success = TRUE)
[13:24:33.480]                               parallel_sendData(master, data)
[13:24:33.480]                             }
[13:24:33.480]                             return(sendCondition)
[13:24:33.480]                           }
[13:24:33.480]                         }
[13:24:33.480]                         frame <- frame + 1L
[13:24:33.480]                         envir <- sys.frame(frame)
[13:24:33.480]                       }
[13:24:33.480]                     }
[13:24:33.480]                     sendCondition <<- function(cond) NULL
[13:24:33.480]                   }
[13:24:33.480]                 })
[13:24:33.480]                 withCallingHandlers({
[13:24:33.480]                   {
[13:24:33.480]                     Sys.sleep(0.5)
[13:24:33.480]                     list(a = 1, b = 42L)
[13:24:33.480]                   }
[13:24:33.480]                 }, immediateCondition = function(cond) {
[13:24:33.480]                   sendCondition <- ...future.makeSendCondition()
[13:24:33.480]                   sendCondition(cond)
[13:24:33.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.480]                   {
[13:24:33.480]                     inherits <- base::inherits
[13:24:33.480]                     invokeRestart <- base::invokeRestart
[13:24:33.480]                     is.null <- base::is.null
[13:24:33.480]                     muffled <- FALSE
[13:24:33.480]                     if (inherits(cond, "message")) {
[13:24:33.480]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:33.480]                       if (muffled) 
[13:24:33.480]                         invokeRestart("muffleMessage")
[13:24:33.480]                     }
[13:24:33.480]                     else if (inherits(cond, "warning")) {
[13:24:33.480]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:33.480]                       if (muffled) 
[13:24:33.480]                         invokeRestart("muffleWarning")
[13:24:33.480]                     }
[13:24:33.480]                     else if (inherits(cond, "condition")) {
[13:24:33.480]                       if (!is.null(pattern)) {
[13:24:33.480]                         computeRestarts <- base::computeRestarts
[13:24:33.480]                         grepl <- base::grepl
[13:24:33.480]                         restarts <- computeRestarts(cond)
[13:24:33.480]                         for (restart in restarts) {
[13:24:33.480]                           name <- restart$name
[13:24:33.480]                           if (is.null(name)) 
[13:24:33.480]                             next
[13:24:33.480]                           if (!grepl(pattern, name)) 
[13:24:33.480]                             next
[13:24:33.480]                           invokeRestart(restart)
[13:24:33.480]                           muffled <- TRUE
[13:24:33.480]                           break
[13:24:33.480]                         }
[13:24:33.480]                       }
[13:24:33.480]                     }
[13:24:33.480]                     invisible(muffled)
[13:24:33.480]                   }
[13:24:33.480]                   muffleCondition(cond)
[13:24:33.480]                 })
[13:24:33.480]             }))
[13:24:33.480]             future::FutureResult(value = ...future.value$value, 
[13:24:33.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:33.480]                   ...future.rng), globalenv = if (FALSE) 
[13:24:33.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:33.480]                     ...future.globalenv.names))
[13:24:33.480]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:33.480]         }, condition = base::local({
[13:24:33.480]             c <- base::c
[13:24:33.480]             inherits <- base::inherits
[13:24:33.480]             invokeRestart <- base::invokeRestart
[13:24:33.480]             length <- base::length
[13:24:33.480]             list <- base::list
[13:24:33.480]             seq.int <- base::seq.int
[13:24:33.480]             signalCondition <- base::signalCondition
[13:24:33.480]             sys.calls <- base::sys.calls
[13:24:33.480]             `[[` <- base::`[[`
[13:24:33.480]             `+` <- base::`+`
[13:24:33.480]             `<<-` <- base::`<<-`
[13:24:33.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:33.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:33.480]                   3L)]
[13:24:33.480]             }
[13:24:33.480]             function(cond) {
[13:24:33.480]                 is_error <- inherits(cond, "error")
[13:24:33.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:33.480]                   NULL)
[13:24:33.480]                 if (is_error) {
[13:24:33.480]                   sessionInformation <- function() {
[13:24:33.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:33.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:33.480]                       search = base::search(), system = base::Sys.info())
[13:24:33.480]                   }
[13:24:33.480]                   ...future.conditions[[length(...future.conditions) + 
[13:24:33.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:33.480]                     cond$call), session = sessionInformation(), 
[13:24:33.480]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:33.480]                   signalCondition(cond)
[13:24:33.480]                 }
[13:24:33.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:33.480]                 "immediateCondition"))) {
[13:24:33.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:33.480]                   ...future.conditions[[length(...future.conditions) + 
[13:24:33.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:33.480]                   if (TRUE && !signal) {
[13:24:33.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.480]                     {
[13:24:33.480]                       inherits <- base::inherits
[13:24:33.480]                       invokeRestart <- base::invokeRestart
[13:24:33.480]                       is.null <- base::is.null
[13:24:33.480]                       muffled <- FALSE
[13:24:33.480]                       if (inherits(cond, "message")) {
[13:24:33.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:33.480]                         if (muffled) 
[13:24:33.480]                           invokeRestart("muffleMessage")
[13:24:33.480]                       }
[13:24:33.480]                       else if (inherits(cond, "warning")) {
[13:24:33.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:33.480]                         if (muffled) 
[13:24:33.480]                           invokeRestart("muffleWarning")
[13:24:33.480]                       }
[13:24:33.480]                       else if (inherits(cond, "condition")) {
[13:24:33.480]                         if (!is.null(pattern)) {
[13:24:33.480]                           computeRestarts <- base::computeRestarts
[13:24:33.480]                           grepl <- base::grepl
[13:24:33.480]                           restarts <- computeRestarts(cond)
[13:24:33.480]                           for (restart in restarts) {
[13:24:33.480]                             name <- restart$name
[13:24:33.480]                             if (is.null(name)) 
[13:24:33.480]                               next
[13:24:33.480]                             if (!grepl(pattern, name)) 
[13:24:33.480]                               next
[13:24:33.480]                             invokeRestart(restart)
[13:24:33.480]                             muffled <- TRUE
[13:24:33.480]                             break
[13:24:33.480]                           }
[13:24:33.480]                         }
[13:24:33.480]                       }
[13:24:33.480]                       invisible(muffled)
[13:24:33.480]                     }
[13:24:33.480]                     muffleCondition(cond, pattern = "^muffle")
[13:24:33.480]                   }
[13:24:33.480]                 }
[13:24:33.480]                 else {
[13:24:33.480]                   if (TRUE) {
[13:24:33.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:33.480]                     {
[13:24:33.480]                       inherits <- base::inherits
[13:24:33.480]                       invokeRestart <- base::invokeRestart
[13:24:33.480]                       is.null <- base::is.null
[13:24:33.480]                       muffled <- FALSE
[13:24:33.480]                       if (inherits(cond, "message")) {
[13:24:33.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:33.480]                         if (muffled) 
[13:24:33.480]                           invokeRestart("muffleMessage")
[13:24:33.480]                       }
[13:24:33.480]                       else if (inherits(cond, "warning")) {
[13:24:33.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:33.480]                         if (muffled) 
[13:24:33.480]                           invokeRestart("muffleWarning")
[13:24:33.480]                       }
[13:24:33.480]                       else if (inherits(cond, "condition")) {
[13:24:33.480]                         if (!is.null(pattern)) {
[13:24:33.480]                           computeRestarts <- base::computeRestarts
[13:24:33.480]                           grepl <- base::grepl
[13:24:33.480]                           restarts <- computeRestarts(cond)
[13:24:33.480]                           for (restart in restarts) {
[13:24:33.480]                             name <- restart$name
[13:24:33.480]                             if (is.null(name)) 
[13:24:33.480]                               next
[13:24:33.480]                             if (!grepl(pattern, name)) 
[13:24:33.480]                               next
[13:24:33.480]                             invokeRestart(restart)
[13:24:33.480]                             muffled <- TRUE
[13:24:33.480]                             break
[13:24:33.480]                           }
[13:24:33.480]                         }
[13:24:33.480]                       }
[13:24:33.480]                       invisible(muffled)
[13:24:33.480]                     }
[13:24:33.480]                     muffleCondition(cond, pattern = "^muffle")
[13:24:33.480]                   }
[13:24:33.480]                 }
[13:24:33.480]             }
[13:24:33.480]         }))
[13:24:33.480]     }, error = function(ex) {
[13:24:33.480]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:33.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:33.480]                 ...future.rng), started = ...future.startTime, 
[13:24:33.480]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:33.480]             version = "1.8"), class = "FutureResult")
[13:24:33.480]     }, finally = {
[13:24:33.480]         if (!identical(...future.workdir, getwd())) 
[13:24:33.480]             setwd(...future.workdir)
[13:24:33.480]         {
[13:24:33.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:33.480]                 ...future.oldOptions$nwarnings <- NULL
[13:24:33.480]             }
[13:24:33.480]             base::options(...future.oldOptions)
[13:24:33.480]             if (.Platform$OS.type == "windows") {
[13:24:33.480]                 old_names <- names(...future.oldEnvVars)
[13:24:33.480]                 envs <- base::Sys.getenv()
[13:24:33.480]                 names <- names(envs)
[13:24:33.480]                 common <- intersect(names, old_names)
[13:24:33.480]                 added <- setdiff(names, old_names)
[13:24:33.480]                 removed <- setdiff(old_names, names)
[13:24:33.480]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:33.480]                   envs[common]]
[13:24:33.480]                 NAMES <- toupper(changed)
[13:24:33.480]                 args <- list()
[13:24:33.480]                 for (kk in seq_along(NAMES)) {
[13:24:33.480]                   name <- changed[[kk]]
[13:24:33.480]                   NAME <- NAMES[[kk]]
[13:24:33.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.480]                     next
[13:24:33.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:33.480]                 }
[13:24:33.480]                 NAMES <- toupper(added)
[13:24:33.480]                 for (kk in seq_along(NAMES)) {
[13:24:33.480]                   name <- added[[kk]]
[13:24:33.480]                   NAME <- NAMES[[kk]]
[13:24:33.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.480]                     next
[13:24:33.480]                   args[[name]] <- ""
[13:24:33.480]                 }
[13:24:33.480]                 NAMES <- toupper(removed)
[13:24:33.480]                 for (kk in seq_along(NAMES)) {
[13:24:33.480]                   name <- removed[[kk]]
[13:24:33.480]                   NAME <- NAMES[[kk]]
[13:24:33.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:33.480]                     next
[13:24:33.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:33.480]                 }
[13:24:33.480]                 if (length(args) > 0) 
[13:24:33.480]                   base::do.call(base::Sys.setenv, args = args)
[13:24:33.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:33.480]             }
[13:24:33.480]             else {
[13:24:33.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:33.480]             }
[13:24:33.480]             {
[13:24:33.480]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:33.480]                   0L) {
[13:24:33.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:33.480]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:33.480]                   base::options(opts)
[13:24:33.480]                 }
[13:24:33.480]                 {
[13:24:33.480]                   {
[13:24:33.480]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:33.480]                     NULL
[13:24:33.480]                   }
[13:24:33.480]                   options(future.plan = NULL)
[13:24:33.480]                   if (is.na(NA_character_)) 
[13:24:33.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:33.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:33.480]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:33.480]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:33.480]                     envir = parent.frame()) 
[13:24:33.480]                   {
[13:24:33.480]                     if (is.function(workers)) 
[13:24:33.480]                       workers <- workers()
[13:24:33.480]                     workers <- structure(as.integer(workers), 
[13:24:33.480]                       class = class(workers))
[13:24:33.480]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:33.480]                       workers >= 1)
[13:24:33.480]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:33.480]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:33.480]                     }
[13:24:33.480]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:33.480]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:33.480]                       envir = envir)
[13:24:33.480]                     if (!future$lazy) 
[13:24:33.480]                       future <- run(future)
[13:24:33.480]                     invisible(future)
[13:24:33.480]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:33.480]                 }
[13:24:33.480]             }
[13:24:33.480]         }
[13:24:33.480]     })
[13:24:33.480]     if (TRUE) {
[13:24:33.480]         base::sink(type = "output", split = FALSE)
[13:24:33.480]         if (TRUE) {
[13:24:33.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:33.480]         }
[13:24:33.480]         else {
[13:24:33.480]             ...future.result["stdout"] <- base::list(NULL)
[13:24:33.480]         }
[13:24:33.480]         base::close(...future.stdout)
[13:24:33.480]         ...future.stdout <- NULL
[13:24:33.480]     }
[13:24:33.480]     ...future.result$conditions <- ...future.conditions
[13:24:33.480]     ...future.result$finished <- base::Sys.time()
[13:24:33.480]     ...future.result
[13:24:33.480] }
[13:24:33.483] MultisessionFuture started
[13:24:33.483] - Launch lazy future ... done
[13:24:33.483] run() for ‘MultisessionFuture’ ... done
[13:24:34.034] receiveMessageFromWorker() for ClusterFuture ...
[13:24:34.034] - Validating connection of MultisessionFuture
[13:24:34.034] - received message: FutureResult
[13:24:34.035] - Received FutureResult
[13:24:34.035] - Erased future from FutureRegistry
[13:24:34.035] result() for ClusterFuture ...
[13:24:34.035] - result already collected: FutureResult
[13:24:34.035] result() for ClusterFuture ... done
[13:24:34.035] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:34.035] A MultisessionFuture was resolved
[13:24:34.035] getGlobalsAndPackages() ...
[13:24:34.035] Searching for globals...
[13:24:34.037] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:34.037] Searching for globals ... DONE
[13:24:34.037] Resolving globals: FALSE
[13:24:34.037] 
[13:24:34.037] 
[13:24:34.037] getGlobalsAndPackages() ... DONE
[13:24:34.038] run() for ‘Future’ ...
[13:24:34.038] - state: ‘created’
[13:24:34.038] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:34.052] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:34.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:34.052]   - Field: ‘node’
[13:24:34.052]   - Field: ‘label’
[13:24:34.053]   - Field: ‘local’
[13:24:34.053]   - Field: ‘owner’
[13:24:34.053]   - Field: ‘envir’
[13:24:34.053]   - Field: ‘workers’
[13:24:34.053]   - Field: ‘packages’
[13:24:34.053]   - Field: ‘gc’
[13:24:34.053]   - Field: ‘conditions’
[13:24:34.053]   - Field: ‘persistent’
[13:24:34.053]   - Field: ‘expr’
[13:24:34.053]   - Field: ‘uuid’
[13:24:34.053]   - Field: ‘seed’
[13:24:34.053]   - Field: ‘version’
[13:24:34.054]   - Field: ‘result’
[13:24:34.054]   - Field: ‘asynchronous’
[13:24:34.054]   - Field: ‘calls’
[13:24:34.054]   - Field: ‘globals’
[13:24:34.054]   - Field: ‘stdout’
[13:24:34.054]   - Field: ‘earlySignal’
[13:24:34.054]   - Field: ‘lazy’
[13:24:34.054]   - Field: ‘state’
[13:24:34.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:34.055] - Launch lazy future ...
[13:24:34.055] Packages needed by the future expression (n = 0): <none>
[13:24:34.055] Packages needed by future strategies (n = 0): <none>
[13:24:34.056] {
[13:24:34.056]     {
[13:24:34.056]         {
[13:24:34.056]             ...future.startTime <- base::Sys.time()
[13:24:34.056]             {
[13:24:34.056]                 {
[13:24:34.056]                   {
[13:24:34.056]                     {
[13:24:34.056]                       base::local({
[13:24:34.056]                         has_future <- base::requireNamespace("future", 
[13:24:34.056]                           quietly = TRUE)
[13:24:34.056]                         if (has_future) {
[13:24:34.056]                           ns <- base::getNamespace("future")
[13:24:34.056]                           version <- ns[[".package"]][["version"]]
[13:24:34.056]                           if (is.null(version)) 
[13:24:34.056]                             version <- utils::packageVersion("future")
[13:24:34.056]                         }
[13:24:34.056]                         else {
[13:24:34.056]                           version <- NULL
[13:24:34.056]                         }
[13:24:34.056]                         if (!has_future || version < "1.8.0") {
[13:24:34.056]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:34.056]                             "", base::R.version$version.string), 
[13:24:34.056]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:34.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:34.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:34.056]                               "release", "version")], collapse = " "), 
[13:24:34.056]                             hostname = base::Sys.info()[["nodename"]])
[13:24:34.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:34.056]                             info)
[13:24:34.056]                           info <- base::paste(info, collapse = "; ")
[13:24:34.056]                           if (!has_future) {
[13:24:34.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:34.056]                               info)
[13:24:34.056]                           }
[13:24:34.056]                           else {
[13:24:34.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:34.056]                               info, version)
[13:24:34.056]                           }
[13:24:34.056]                           base::stop(msg)
[13:24:34.056]                         }
[13:24:34.056]                       })
[13:24:34.056]                     }
[13:24:34.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:34.056]                     base::options(mc.cores = 1L)
[13:24:34.056]                   }
[13:24:34.056]                   options(future.plan = NULL)
[13:24:34.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:34.056]                 }
[13:24:34.056]                 ...future.workdir <- getwd()
[13:24:34.056]             }
[13:24:34.056]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:34.056]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:34.056]         }
[13:24:34.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:34.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:34.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:34.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:34.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:34.056]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:34.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:34.056]             base::names(...future.oldOptions))
[13:24:34.056]     }
[13:24:34.056]     if (FALSE) {
[13:24:34.056]     }
[13:24:34.056]     else {
[13:24:34.056]         if (TRUE) {
[13:24:34.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:34.056]                 open = "w")
[13:24:34.056]         }
[13:24:34.056]         else {
[13:24:34.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:34.056]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:34.056]         }
[13:24:34.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:34.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:34.056]             base::sink(type = "output", split = FALSE)
[13:24:34.056]             base::close(...future.stdout)
[13:24:34.056]         }, add = TRUE)
[13:24:34.056]     }
[13:24:34.056]     ...future.frame <- base::sys.nframe()
[13:24:34.056]     ...future.conditions <- base::list()
[13:24:34.056]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:34.056]     if (FALSE) {
[13:24:34.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:34.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:34.056]     }
[13:24:34.056]     ...future.result <- base::tryCatch({
[13:24:34.056]         base::withCallingHandlers({
[13:24:34.056]             ...future.value <- base::withVisible(base::local({
[13:24:34.056]                 ...future.makeSendCondition <- base::local({
[13:24:34.056]                   sendCondition <- NULL
[13:24:34.056]                   function(frame = 1L) {
[13:24:34.056]                     if (is.function(sendCondition)) 
[13:24:34.056]                       return(sendCondition)
[13:24:34.056]                     ns <- getNamespace("parallel")
[13:24:34.056]                     if (exists("sendData", mode = "function", 
[13:24:34.056]                       envir = ns)) {
[13:24:34.056]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:34.056]                         envir = ns)
[13:24:34.056]                       envir <- sys.frame(frame)
[13:24:34.056]                       master <- NULL
[13:24:34.056]                       while (!identical(envir, .GlobalEnv) && 
[13:24:34.056]                         !identical(envir, emptyenv())) {
[13:24:34.056]                         if (exists("master", mode = "list", envir = envir, 
[13:24:34.056]                           inherits = FALSE)) {
[13:24:34.056]                           master <- get("master", mode = "list", 
[13:24:34.056]                             envir = envir, inherits = FALSE)
[13:24:34.056]                           if (inherits(master, c("SOCKnode", 
[13:24:34.056]                             "SOCK0node"))) {
[13:24:34.056]                             sendCondition <<- function(cond) {
[13:24:34.056]                               data <- list(type = "VALUE", value = cond, 
[13:24:34.056]                                 success = TRUE)
[13:24:34.056]                               parallel_sendData(master, data)
[13:24:34.056]                             }
[13:24:34.056]                             return(sendCondition)
[13:24:34.056]                           }
[13:24:34.056]                         }
[13:24:34.056]                         frame <- frame + 1L
[13:24:34.056]                         envir <- sys.frame(frame)
[13:24:34.056]                       }
[13:24:34.056]                     }
[13:24:34.056]                     sendCondition <<- function(cond) NULL
[13:24:34.056]                   }
[13:24:34.056]                 })
[13:24:34.056]                 withCallingHandlers({
[13:24:34.056]                   {
[13:24:34.056]                     Sys.sleep(0.5)
[13:24:34.056]                     list(a = 1, b = 42L)
[13:24:34.056]                   }
[13:24:34.056]                 }, immediateCondition = function(cond) {
[13:24:34.056]                   sendCondition <- ...future.makeSendCondition()
[13:24:34.056]                   sendCondition(cond)
[13:24:34.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.056]                   {
[13:24:34.056]                     inherits <- base::inherits
[13:24:34.056]                     invokeRestart <- base::invokeRestart
[13:24:34.056]                     is.null <- base::is.null
[13:24:34.056]                     muffled <- FALSE
[13:24:34.056]                     if (inherits(cond, "message")) {
[13:24:34.056]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:34.056]                       if (muffled) 
[13:24:34.056]                         invokeRestart("muffleMessage")
[13:24:34.056]                     }
[13:24:34.056]                     else if (inherits(cond, "warning")) {
[13:24:34.056]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:34.056]                       if (muffled) 
[13:24:34.056]                         invokeRestart("muffleWarning")
[13:24:34.056]                     }
[13:24:34.056]                     else if (inherits(cond, "condition")) {
[13:24:34.056]                       if (!is.null(pattern)) {
[13:24:34.056]                         computeRestarts <- base::computeRestarts
[13:24:34.056]                         grepl <- base::grepl
[13:24:34.056]                         restarts <- computeRestarts(cond)
[13:24:34.056]                         for (restart in restarts) {
[13:24:34.056]                           name <- restart$name
[13:24:34.056]                           if (is.null(name)) 
[13:24:34.056]                             next
[13:24:34.056]                           if (!grepl(pattern, name)) 
[13:24:34.056]                             next
[13:24:34.056]                           invokeRestart(restart)
[13:24:34.056]                           muffled <- TRUE
[13:24:34.056]                           break
[13:24:34.056]                         }
[13:24:34.056]                       }
[13:24:34.056]                     }
[13:24:34.056]                     invisible(muffled)
[13:24:34.056]                   }
[13:24:34.056]                   muffleCondition(cond)
[13:24:34.056]                 })
[13:24:34.056]             }))
[13:24:34.056]             future::FutureResult(value = ...future.value$value, 
[13:24:34.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.056]                   ...future.rng), globalenv = if (FALSE) 
[13:24:34.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:34.056]                     ...future.globalenv.names))
[13:24:34.056]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:34.056]         }, condition = base::local({
[13:24:34.056]             c <- base::c
[13:24:34.056]             inherits <- base::inherits
[13:24:34.056]             invokeRestart <- base::invokeRestart
[13:24:34.056]             length <- base::length
[13:24:34.056]             list <- base::list
[13:24:34.056]             seq.int <- base::seq.int
[13:24:34.056]             signalCondition <- base::signalCondition
[13:24:34.056]             sys.calls <- base::sys.calls
[13:24:34.056]             `[[` <- base::`[[`
[13:24:34.056]             `+` <- base::`+`
[13:24:34.056]             `<<-` <- base::`<<-`
[13:24:34.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:34.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:34.056]                   3L)]
[13:24:34.056]             }
[13:24:34.056]             function(cond) {
[13:24:34.056]                 is_error <- inherits(cond, "error")
[13:24:34.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:34.056]                   NULL)
[13:24:34.056]                 if (is_error) {
[13:24:34.056]                   sessionInformation <- function() {
[13:24:34.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:34.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:34.056]                       search = base::search(), system = base::Sys.info())
[13:24:34.056]                   }
[13:24:34.056]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:34.056]                     cond$call), session = sessionInformation(), 
[13:24:34.056]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:34.056]                   signalCondition(cond)
[13:24:34.056]                 }
[13:24:34.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:34.056]                 "immediateCondition"))) {
[13:24:34.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:34.056]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:34.056]                   if (TRUE && !signal) {
[13:24:34.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.056]                     {
[13:24:34.056]                       inherits <- base::inherits
[13:24:34.056]                       invokeRestart <- base::invokeRestart
[13:24:34.056]                       is.null <- base::is.null
[13:24:34.056]                       muffled <- FALSE
[13:24:34.056]                       if (inherits(cond, "message")) {
[13:24:34.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.056]                         if (muffled) 
[13:24:34.056]                           invokeRestart("muffleMessage")
[13:24:34.056]                       }
[13:24:34.056]                       else if (inherits(cond, "warning")) {
[13:24:34.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.056]                         if (muffled) 
[13:24:34.056]                           invokeRestart("muffleWarning")
[13:24:34.056]                       }
[13:24:34.056]                       else if (inherits(cond, "condition")) {
[13:24:34.056]                         if (!is.null(pattern)) {
[13:24:34.056]                           computeRestarts <- base::computeRestarts
[13:24:34.056]                           grepl <- base::grepl
[13:24:34.056]                           restarts <- computeRestarts(cond)
[13:24:34.056]                           for (restart in restarts) {
[13:24:34.056]                             name <- restart$name
[13:24:34.056]                             if (is.null(name)) 
[13:24:34.056]                               next
[13:24:34.056]                             if (!grepl(pattern, name)) 
[13:24:34.056]                               next
[13:24:34.056]                             invokeRestart(restart)
[13:24:34.056]                             muffled <- TRUE
[13:24:34.056]                             break
[13:24:34.056]                           }
[13:24:34.056]                         }
[13:24:34.056]                       }
[13:24:34.056]                       invisible(muffled)
[13:24:34.056]                     }
[13:24:34.056]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.056]                   }
[13:24:34.056]                 }
[13:24:34.056]                 else {
[13:24:34.056]                   if (TRUE) {
[13:24:34.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.056]                     {
[13:24:34.056]                       inherits <- base::inherits
[13:24:34.056]                       invokeRestart <- base::invokeRestart
[13:24:34.056]                       is.null <- base::is.null
[13:24:34.056]                       muffled <- FALSE
[13:24:34.056]                       if (inherits(cond, "message")) {
[13:24:34.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.056]                         if (muffled) 
[13:24:34.056]                           invokeRestart("muffleMessage")
[13:24:34.056]                       }
[13:24:34.056]                       else if (inherits(cond, "warning")) {
[13:24:34.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.056]                         if (muffled) 
[13:24:34.056]                           invokeRestart("muffleWarning")
[13:24:34.056]                       }
[13:24:34.056]                       else if (inherits(cond, "condition")) {
[13:24:34.056]                         if (!is.null(pattern)) {
[13:24:34.056]                           computeRestarts <- base::computeRestarts
[13:24:34.056]                           grepl <- base::grepl
[13:24:34.056]                           restarts <- computeRestarts(cond)
[13:24:34.056]                           for (restart in restarts) {
[13:24:34.056]                             name <- restart$name
[13:24:34.056]                             if (is.null(name)) 
[13:24:34.056]                               next
[13:24:34.056]                             if (!grepl(pattern, name)) 
[13:24:34.056]                               next
[13:24:34.056]                             invokeRestart(restart)
[13:24:34.056]                             muffled <- TRUE
[13:24:34.056]                             break
[13:24:34.056]                           }
[13:24:34.056]                         }
[13:24:34.056]                       }
[13:24:34.056]                       invisible(muffled)
[13:24:34.056]                     }
[13:24:34.056]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.056]                   }
[13:24:34.056]                 }
[13:24:34.056]             }
[13:24:34.056]         }))
[13:24:34.056]     }, error = function(ex) {
[13:24:34.056]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:34.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.056]                 ...future.rng), started = ...future.startTime, 
[13:24:34.056]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:34.056]             version = "1.8"), class = "FutureResult")
[13:24:34.056]     }, finally = {
[13:24:34.056]         if (!identical(...future.workdir, getwd())) 
[13:24:34.056]             setwd(...future.workdir)
[13:24:34.056]         {
[13:24:34.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:34.056]                 ...future.oldOptions$nwarnings <- NULL
[13:24:34.056]             }
[13:24:34.056]             base::options(...future.oldOptions)
[13:24:34.056]             if (.Platform$OS.type == "windows") {
[13:24:34.056]                 old_names <- names(...future.oldEnvVars)
[13:24:34.056]                 envs <- base::Sys.getenv()
[13:24:34.056]                 names <- names(envs)
[13:24:34.056]                 common <- intersect(names, old_names)
[13:24:34.056]                 added <- setdiff(names, old_names)
[13:24:34.056]                 removed <- setdiff(old_names, names)
[13:24:34.056]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:34.056]                   envs[common]]
[13:24:34.056]                 NAMES <- toupper(changed)
[13:24:34.056]                 args <- list()
[13:24:34.056]                 for (kk in seq_along(NAMES)) {
[13:24:34.056]                   name <- changed[[kk]]
[13:24:34.056]                   NAME <- NAMES[[kk]]
[13:24:34.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.056]                     next
[13:24:34.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.056]                 }
[13:24:34.056]                 NAMES <- toupper(added)
[13:24:34.056]                 for (kk in seq_along(NAMES)) {
[13:24:34.056]                   name <- added[[kk]]
[13:24:34.056]                   NAME <- NAMES[[kk]]
[13:24:34.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.056]                     next
[13:24:34.056]                   args[[name]] <- ""
[13:24:34.056]                 }
[13:24:34.056]                 NAMES <- toupper(removed)
[13:24:34.056]                 for (kk in seq_along(NAMES)) {
[13:24:34.056]                   name <- removed[[kk]]
[13:24:34.056]                   NAME <- NAMES[[kk]]
[13:24:34.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.056]                     next
[13:24:34.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.056]                 }
[13:24:34.056]                 if (length(args) > 0) 
[13:24:34.056]                   base::do.call(base::Sys.setenv, args = args)
[13:24:34.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:34.056]             }
[13:24:34.056]             else {
[13:24:34.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:34.056]             }
[13:24:34.056]             {
[13:24:34.056]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:34.056]                   0L) {
[13:24:34.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:34.056]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:34.056]                   base::options(opts)
[13:24:34.056]                 }
[13:24:34.056]                 {
[13:24:34.056]                   {
[13:24:34.056]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:34.056]                     NULL
[13:24:34.056]                   }
[13:24:34.056]                   options(future.plan = NULL)
[13:24:34.056]                   if (is.na(NA_character_)) 
[13:24:34.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:34.056]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:34.056]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:34.056]                     envir = parent.frame()) 
[13:24:34.056]                   {
[13:24:34.056]                     if (is.function(workers)) 
[13:24:34.056]                       workers <- workers()
[13:24:34.056]                     workers <- structure(as.integer(workers), 
[13:24:34.056]                       class = class(workers))
[13:24:34.056]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:34.056]                       workers >= 1)
[13:24:34.056]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:34.056]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:34.056]                     }
[13:24:34.056]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:34.056]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:34.056]                       envir = envir)
[13:24:34.056]                     if (!future$lazy) 
[13:24:34.056]                       future <- run(future)
[13:24:34.056]                     invisible(future)
[13:24:34.056]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:34.056]                 }
[13:24:34.056]             }
[13:24:34.056]         }
[13:24:34.056]     })
[13:24:34.056]     if (TRUE) {
[13:24:34.056]         base::sink(type = "output", split = FALSE)
[13:24:34.056]         if (TRUE) {
[13:24:34.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:34.056]         }
[13:24:34.056]         else {
[13:24:34.056]             ...future.result["stdout"] <- base::list(NULL)
[13:24:34.056]         }
[13:24:34.056]         base::close(...future.stdout)
[13:24:34.056]         ...future.stdout <- NULL
[13:24:34.056]     }
[13:24:34.056]     ...future.result$conditions <- ...future.conditions
[13:24:34.056]     ...future.result$finished <- base::Sys.time()
[13:24:34.056]     ...future.result
[13:24:34.056] }
[13:24:34.060] MultisessionFuture started
[13:24:34.060] - Launch lazy future ... done
[13:24:34.060] run() for ‘MultisessionFuture’ ... done
[13:24:34.606] receiveMessageFromWorker() for ClusterFuture ...
[13:24:34.607] - Validating connection of MultisessionFuture
[13:24:34.607] - received message: FutureResult
[13:24:34.607] - Received FutureResult
[13:24:34.607] - Erased future from FutureRegistry
[13:24:34.607] result() for ClusterFuture ...
[13:24:34.607] - result already collected: FutureResult
[13:24:34.607] result() for ClusterFuture ... done
[13:24:34.607] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:34.607] A MultisessionFuture was resolved
- w/ exception ...
[13:24:34.608] getGlobalsAndPackages() ...
[13:24:34.608] Searching for globals...
[13:24:34.609] - globals found: [2] ‘list’, ‘stop’
[13:24:34.609] Searching for globals ... DONE
[13:24:34.609] Resolving globals: FALSE
[13:24:34.609] 
[13:24:34.609] 
[13:24:34.609] getGlobalsAndPackages() ... DONE
[13:24:34.610] run() for ‘Future’ ...
[13:24:34.610] - state: ‘created’
[13:24:34.610] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:34.624] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:34.624] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:34.624]   - Field: ‘node’
[13:24:34.624]   - Field: ‘label’
[13:24:34.624]   - Field: ‘local’
[13:24:34.624]   - Field: ‘owner’
[13:24:34.624]   - Field: ‘envir’
[13:24:34.625]   - Field: ‘workers’
[13:24:34.625]   - Field: ‘packages’
[13:24:34.625]   - Field: ‘gc’
[13:24:34.625]   - Field: ‘conditions’
[13:24:34.625]   - Field: ‘persistent’
[13:24:34.625]   - Field: ‘expr’
[13:24:34.625]   - Field: ‘uuid’
[13:24:34.625]   - Field: ‘seed’
[13:24:34.625]   - Field: ‘version’
[13:24:34.625]   - Field: ‘result’
[13:24:34.625]   - Field: ‘asynchronous’
[13:24:34.626]   - Field: ‘calls’
[13:24:34.626]   - Field: ‘globals’
[13:24:34.626]   - Field: ‘stdout’
[13:24:34.626]   - Field: ‘earlySignal’
[13:24:34.626]   - Field: ‘lazy’
[13:24:34.626]   - Field: ‘state’
[13:24:34.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:34.626] - Launch lazy future ...
[13:24:34.626] Packages needed by the future expression (n = 0): <none>
[13:24:34.627] Packages needed by future strategies (n = 0): <none>
[13:24:34.627] {
[13:24:34.627]     {
[13:24:34.627]         {
[13:24:34.627]             ...future.startTime <- base::Sys.time()
[13:24:34.627]             {
[13:24:34.627]                 {
[13:24:34.627]                   {
[13:24:34.627]                     {
[13:24:34.627]                       base::local({
[13:24:34.627]                         has_future <- base::requireNamespace("future", 
[13:24:34.627]                           quietly = TRUE)
[13:24:34.627]                         if (has_future) {
[13:24:34.627]                           ns <- base::getNamespace("future")
[13:24:34.627]                           version <- ns[[".package"]][["version"]]
[13:24:34.627]                           if (is.null(version)) 
[13:24:34.627]                             version <- utils::packageVersion("future")
[13:24:34.627]                         }
[13:24:34.627]                         else {
[13:24:34.627]                           version <- NULL
[13:24:34.627]                         }
[13:24:34.627]                         if (!has_future || version < "1.8.0") {
[13:24:34.627]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:34.627]                             "", base::R.version$version.string), 
[13:24:34.627]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:34.627]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:34.627]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:34.627]                               "release", "version")], collapse = " "), 
[13:24:34.627]                             hostname = base::Sys.info()[["nodename"]])
[13:24:34.627]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:34.627]                             info)
[13:24:34.627]                           info <- base::paste(info, collapse = "; ")
[13:24:34.627]                           if (!has_future) {
[13:24:34.627]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:34.627]                               info)
[13:24:34.627]                           }
[13:24:34.627]                           else {
[13:24:34.627]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:34.627]                               info, version)
[13:24:34.627]                           }
[13:24:34.627]                           base::stop(msg)
[13:24:34.627]                         }
[13:24:34.627]                       })
[13:24:34.627]                     }
[13:24:34.627]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:34.627]                     base::options(mc.cores = 1L)
[13:24:34.627]                   }
[13:24:34.627]                   options(future.plan = NULL)
[13:24:34.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:34.627]                 }
[13:24:34.627]                 ...future.workdir <- getwd()
[13:24:34.627]             }
[13:24:34.627]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:34.627]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:34.627]         }
[13:24:34.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:34.627]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:34.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:34.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:34.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:34.627]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:34.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:34.627]             base::names(...future.oldOptions))
[13:24:34.627]     }
[13:24:34.627]     if (FALSE) {
[13:24:34.627]     }
[13:24:34.627]     else {
[13:24:34.627]         if (TRUE) {
[13:24:34.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:34.627]                 open = "w")
[13:24:34.627]         }
[13:24:34.627]         else {
[13:24:34.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:34.627]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:34.627]         }
[13:24:34.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:34.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:34.627]             base::sink(type = "output", split = FALSE)
[13:24:34.627]             base::close(...future.stdout)
[13:24:34.627]         }, add = TRUE)
[13:24:34.627]     }
[13:24:34.627]     ...future.frame <- base::sys.nframe()
[13:24:34.627]     ...future.conditions <- base::list()
[13:24:34.627]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:34.627]     if (FALSE) {
[13:24:34.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:34.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:34.627]     }
[13:24:34.627]     ...future.result <- base::tryCatch({
[13:24:34.627]         base::withCallingHandlers({
[13:24:34.627]             ...future.value <- base::withVisible(base::local({
[13:24:34.627]                 ...future.makeSendCondition <- base::local({
[13:24:34.627]                   sendCondition <- NULL
[13:24:34.627]                   function(frame = 1L) {
[13:24:34.627]                     if (is.function(sendCondition)) 
[13:24:34.627]                       return(sendCondition)
[13:24:34.627]                     ns <- getNamespace("parallel")
[13:24:34.627]                     if (exists("sendData", mode = "function", 
[13:24:34.627]                       envir = ns)) {
[13:24:34.627]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:34.627]                         envir = ns)
[13:24:34.627]                       envir <- sys.frame(frame)
[13:24:34.627]                       master <- NULL
[13:24:34.627]                       while (!identical(envir, .GlobalEnv) && 
[13:24:34.627]                         !identical(envir, emptyenv())) {
[13:24:34.627]                         if (exists("master", mode = "list", envir = envir, 
[13:24:34.627]                           inherits = FALSE)) {
[13:24:34.627]                           master <- get("master", mode = "list", 
[13:24:34.627]                             envir = envir, inherits = FALSE)
[13:24:34.627]                           if (inherits(master, c("SOCKnode", 
[13:24:34.627]                             "SOCK0node"))) {
[13:24:34.627]                             sendCondition <<- function(cond) {
[13:24:34.627]                               data <- list(type = "VALUE", value = cond, 
[13:24:34.627]                                 success = TRUE)
[13:24:34.627]                               parallel_sendData(master, data)
[13:24:34.627]                             }
[13:24:34.627]                             return(sendCondition)
[13:24:34.627]                           }
[13:24:34.627]                         }
[13:24:34.627]                         frame <- frame + 1L
[13:24:34.627]                         envir <- sys.frame(frame)
[13:24:34.627]                       }
[13:24:34.627]                     }
[13:24:34.627]                     sendCondition <<- function(cond) NULL
[13:24:34.627]                   }
[13:24:34.627]                 })
[13:24:34.627]                 withCallingHandlers({
[13:24:34.627]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:34.627]                 }, immediateCondition = function(cond) {
[13:24:34.627]                   sendCondition <- ...future.makeSendCondition()
[13:24:34.627]                   sendCondition(cond)
[13:24:34.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.627]                   {
[13:24:34.627]                     inherits <- base::inherits
[13:24:34.627]                     invokeRestart <- base::invokeRestart
[13:24:34.627]                     is.null <- base::is.null
[13:24:34.627]                     muffled <- FALSE
[13:24:34.627]                     if (inherits(cond, "message")) {
[13:24:34.627]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:34.627]                       if (muffled) 
[13:24:34.627]                         invokeRestart("muffleMessage")
[13:24:34.627]                     }
[13:24:34.627]                     else if (inherits(cond, "warning")) {
[13:24:34.627]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:34.627]                       if (muffled) 
[13:24:34.627]                         invokeRestart("muffleWarning")
[13:24:34.627]                     }
[13:24:34.627]                     else if (inherits(cond, "condition")) {
[13:24:34.627]                       if (!is.null(pattern)) {
[13:24:34.627]                         computeRestarts <- base::computeRestarts
[13:24:34.627]                         grepl <- base::grepl
[13:24:34.627]                         restarts <- computeRestarts(cond)
[13:24:34.627]                         for (restart in restarts) {
[13:24:34.627]                           name <- restart$name
[13:24:34.627]                           if (is.null(name)) 
[13:24:34.627]                             next
[13:24:34.627]                           if (!grepl(pattern, name)) 
[13:24:34.627]                             next
[13:24:34.627]                           invokeRestart(restart)
[13:24:34.627]                           muffled <- TRUE
[13:24:34.627]                           break
[13:24:34.627]                         }
[13:24:34.627]                       }
[13:24:34.627]                     }
[13:24:34.627]                     invisible(muffled)
[13:24:34.627]                   }
[13:24:34.627]                   muffleCondition(cond)
[13:24:34.627]                 })
[13:24:34.627]             }))
[13:24:34.627]             future::FutureResult(value = ...future.value$value, 
[13:24:34.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.627]                   ...future.rng), globalenv = if (FALSE) 
[13:24:34.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:34.627]                     ...future.globalenv.names))
[13:24:34.627]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:34.627]         }, condition = base::local({
[13:24:34.627]             c <- base::c
[13:24:34.627]             inherits <- base::inherits
[13:24:34.627]             invokeRestart <- base::invokeRestart
[13:24:34.627]             length <- base::length
[13:24:34.627]             list <- base::list
[13:24:34.627]             seq.int <- base::seq.int
[13:24:34.627]             signalCondition <- base::signalCondition
[13:24:34.627]             sys.calls <- base::sys.calls
[13:24:34.627]             `[[` <- base::`[[`
[13:24:34.627]             `+` <- base::`+`
[13:24:34.627]             `<<-` <- base::`<<-`
[13:24:34.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:34.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:34.627]                   3L)]
[13:24:34.627]             }
[13:24:34.627]             function(cond) {
[13:24:34.627]                 is_error <- inherits(cond, "error")
[13:24:34.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:34.627]                   NULL)
[13:24:34.627]                 if (is_error) {
[13:24:34.627]                   sessionInformation <- function() {
[13:24:34.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:34.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:34.627]                       search = base::search(), system = base::Sys.info())
[13:24:34.627]                   }
[13:24:34.627]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:34.627]                     cond$call), session = sessionInformation(), 
[13:24:34.627]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:34.627]                   signalCondition(cond)
[13:24:34.627]                 }
[13:24:34.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:34.627]                 "immediateCondition"))) {
[13:24:34.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:34.627]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:34.627]                   if (TRUE && !signal) {
[13:24:34.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.627]                     {
[13:24:34.627]                       inherits <- base::inherits
[13:24:34.627]                       invokeRestart <- base::invokeRestart
[13:24:34.627]                       is.null <- base::is.null
[13:24:34.627]                       muffled <- FALSE
[13:24:34.627]                       if (inherits(cond, "message")) {
[13:24:34.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.627]                         if (muffled) 
[13:24:34.627]                           invokeRestart("muffleMessage")
[13:24:34.627]                       }
[13:24:34.627]                       else if (inherits(cond, "warning")) {
[13:24:34.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.627]                         if (muffled) 
[13:24:34.627]                           invokeRestart("muffleWarning")
[13:24:34.627]                       }
[13:24:34.627]                       else if (inherits(cond, "condition")) {
[13:24:34.627]                         if (!is.null(pattern)) {
[13:24:34.627]                           computeRestarts <- base::computeRestarts
[13:24:34.627]                           grepl <- base::grepl
[13:24:34.627]                           restarts <- computeRestarts(cond)
[13:24:34.627]                           for (restart in restarts) {
[13:24:34.627]                             name <- restart$name
[13:24:34.627]                             if (is.null(name)) 
[13:24:34.627]                               next
[13:24:34.627]                             if (!grepl(pattern, name)) 
[13:24:34.627]                               next
[13:24:34.627]                             invokeRestart(restart)
[13:24:34.627]                             muffled <- TRUE
[13:24:34.627]                             break
[13:24:34.627]                           }
[13:24:34.627]                         }
[13:24:34.627]                       }
[13:24:34.627]                       invisible(muffled)
[13:24:34.627]                     }
[13:24:34.627]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.627]                   }
[13:24:34.627]                 }
[13:24:34.627]                 else {
[13:24:34.627]                   if (TRUE) {
[13:24:34.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.627]                     {
[13:24:34.627]                       inherits <- base::inherits
[13:24:34.627]                       invokeRestart <- base::invokeRestart
[13:24:34.627]                       is.null <- base::is.null
[13:24:34.627]                       muffled <- FALSE
[13:24:34.627]                       if (inherits(cond, "message")) {
[13:24:34.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.627]                         if (muffled) 
[13:24:34.627]                           invokeRestart("muffleMessage")
[13:24:34.627]                       }
[13:24:34.627]                       else if (inherits(cond, "warning")) {
[13:24:34.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.627]                         if (muffled) 
[13:24:34.627]                           invokeRestart("muffleWarning")
[13:24:34.627]                       }
[13:24:34.627]                       else if (inherits(cond, "condition")) {
[13:24:34.627]                         if (!is.null(pattern)) {
[13:24:34.627]                           computeRestarts <- base::computeRestarts
[13:24:34.627]                           grepl <- base::grepl
[13:24:34.627]                           restarts <- computeRestarts(cond)
[13:24:34.627]                           for (restart in restarts) {
[13:24:34.627]                             name <- restart$name
[13:24:34.627]                             if (is.null(name)) 
[13:24:34.627]                               next
[13:24:34.627]                             if (!grepl(pattern, name)) 
[13:24:34.627]                               next
[13:24:34.627]                             invokeRestart(restart)
[13:24:34.627]                             muffled <- TRUE
[13:24:34.627]                             break
[13:24:34.627]                           }
[13:24:34.627]                         }
[13:24:34.627]                       }
[13:24:34.627]                       invisible(muffled)
[13:24:34.627]                     }
[13:24:34.627]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.627]                   }
[13:24:34.627]                 }
[13:24:34.627]             }
[13:24:34.627]         }))
[13:24:34.627]     }, error = function(ex) {
[13:24:34.627]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:34.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.627]                 ...future.rng), started = ...future.startTime, 
[13:24:34.627]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:34.627]             version = "1.8"), class = "FutureResult")
[13:24:34.627]     }, finally = {
[13:24:34.627]         if (!identical(...future.workdir, getwd())) 
[13:24:34.627]             setwd(...future.workdir)
[13:24:34.627]         {
[13:24:34.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:34.627]                 ...future.oldOptions$nwarnings <- NULL
[13:24:34.627]             }
[13:24:34.627]             base::options(...future.oldOptions)
[13:24:34.627]             if (.Platform$OS.type == "windows") {
[13:24:34.627]                 old_names <- names(...future.oldEnvVars)
[13:24:34.627]                 envs <- base::Sys.getenv()
[13:24:34.627]                 names <- names(envs)
[13:24:34.627]                 common <- intersect(names, old_names)
[13:24:34.627]                 added <- setdiff(names, old_names)
[13:24:34.627]                 removed <- setdiff(old_names, names)
[13:24:34.627]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:34.627]                   envs[common]]
[13:24:34.627]                 NAMES <- toupper(changed)
[13:24:34.627]                 args <- list()
[13:24:34.627]                 for (kk in seq_along(NAMES)) {
[13:24:34.627]                   name <- changed[[kk]]
[13:24:34.627]                   NAME <- NAMES[[kk]]
[13:24:34.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.627]                     next
[13:24:34.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.627]                 }
[13:24:34.627]                 NAMES <- toupper(added)
[13:24:34.627]                 for (kk in seq_along(NAMES)) {
[13:24:34.627]                   name <- added[[kk]]
[13:24:34.627]                   NAME <- NAMES[[kk]]
[13:24:34.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.627]                     next
[13:24:34.627]                   args[[name]] <- ""
[13:24:34.627]                 }
[13:24:34.627]                 NAMES <- toupper(removed)
[13:24:34.627]                 for (kk in seq_along(NAMES)) {
[13:24:34.627]                   name <- removed[[kk]]
[13:24:34.627]                   NAME <- NAMES[[kk]]
[13:24:34.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.627]                     next
[13:24:34.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.627]                 }
[13:24:34.627]                 if (length(args) > 0) 
[13:24:34.627]                   base::do.call(base::Sys.setenv, args = args)
[13:24:34.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:34.627]             }
[13:24:34.627]             else {
[13:24:34.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:34.627]             }
[13:24:34.627]             {
[13:24:34.627]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:34.627]                   0L) {
[13:24:34.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:34.627]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:34.627]                   base::options(opts)
[13:24:34.627]                 }
[13:24:34.627]                 {
[13:24:34.627]                   {
[13:24:34.627]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:34.627]                     NULL
[13:24:34.627]                   }
[13:24:34.627]                   options(future.plan = NULL)
[13:24:34.627]                   if (is.na(NA_character_)) 
[13:24:34.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:34.627]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:34.627]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:34.627]                     envir = parent.frame()) 
[13:24:34.627]                   {
[13:24:34.627]                     if (is.function(workers)) 
[13:24:34.627]                       workers <- workers()
[13:24:34.627]                     workers <- structure(as.integer(workers), 
[13:24:34.627]                       class = class(workers))
[13:24:34.627]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:34.627]                       workers >= 1)
[13:24:34.627]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:34.627]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:34.627]                     }
[13:24:34.627]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:34.627]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:34.627]                       envir = envir)
[13:24:34.627]                     if (!future$lazy) 
[13:24:34.627]                       future <- run(future)
[13:24:34.627]                     invisible(future)
[13:24:34.627]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:34.627]                 }
[13:24:34.627]             }
[13:24:34.627]         }
[13:24:34.627]     })
[13:24:34.627]     if (TRUE) {
[13:24:34.627]         base::sink(type = "output", split = FALSE)
[13:24:34.627]         if (TRUE) {
[13:24:34.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:34.627]         }
[13:24:34.627]         else {
[13:24:34.627]             ...future.result["stdout"] <- base::list(NULL)
[13:24:34.627]         }
[13:24:34.627]         base::close(...future.stdout)
[13:24:34.627]         ...future.stdout <- NULL
[13:24:34.627]     }
[13:24:34.627]     ...future.result$conditions <- ...future.conditions
[13:24:34.627]     ...future.result$finished <- base::Sys.time()
[13:24:34.627]     ...future.result
[13:24:34.627] }
[13:24:34.630] MultisessionFuture started
[13:24:34.631] - Launch lazy future ... done
[13:24:34.631] run() for ‘MultisessionFuture’ ... done
[13:24:34.677] receiveMessageFromWorker() for ClusterFuture ...
[13:24:34.678] - Validating connection of MultisessionFuture
[13:24:34.678] - received message: FutureResult
[13:24:34.678] - Received FutureResult
[13:24:34.679] - Erased future from FutureRegistry
[13:24:34.679] result() for ClusterFuture ...
[13:24:34.679] - result already collected: FutureResult
[13:24:34.679] result() for ClusterFuture ... done
[13:24:34.679] signalConditions() ...
[13:24:34.679]  - include = ‘immediateCondition’
[13:24:34.679]  - exclude = 
[13:24:34.679]  - resignal = FALSE
[13:24:34.679]  - Number of conditions: 1
[13:24:34.679] signalConditions() ... done
[13:24:34.680] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:34.680] A MultisessionFuture was resolved
[13:24:34.680] getGlobalsAndPackages() ...
[13:24:34.680] Searching for globals...
[13:24:34.681] - globals found: [2] ‘list’, ‘stop’
[13:24:34.681] Searching for globals ... DONE
[13:24:34.681] Resolving globals: FALSE
[13:24:34.681] 
[13:24:34.681] 
[13:24:34.681] getGlobalsAndPackages() ... DONE
[13:24:34.682] run() for ‘Future’ ...
[13:24:34.682] - state: ‘created’
[13:24:34.682] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:34.696] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:34.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:34.696]   - Field: ‘node’
[13:24:34.696]   - Field: ‘label’
[13:24:34.696]   - Field: ‘local’
[13:24:34.696]   - Field: ‘owner’
[13:24:34.697]   - Field: ‘envir’
[13:24:34.697]   - Field: ‘workers’
[13:24:34.697]   - Field: ‘packages’
[13:24:34.697]   - Field: ‘gc’
[13:24:34.697]   - Field: ‘conditions’
[13:24:34.697]   - Field: ‘persistent’
[13:24:34.697]   - Field: ‘expr’
[13:24:34.697]   - Field: ‘uuid’
[13:24:34.697]   - Field: ‘seed’
[13:24:34.697]   - Field: ‘version’
[13:24:34.698]   - Field: ‘result’
[13:24:34.698]   - Field: ‘asynchronous’
[13:24:34.698]   - Field: ‘calls’
[13:24:34.698]   - Field: ‘globals’
[13:24:34.698]   - Field: ‘stdout’
[13:24:34.698]   - Field: ‘earlySignal’
[13:24:34.698]   - Field: ‘lazy’
[13:24:34.698]   - Field: ‘state’
[13:24:34.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:34.698] - Launch lazy future ...
[13:24:34.699] Packages needed by the future expression (n = 0): <none>
[13:24:34.699] Packages needed by future strategies (n = 0): <none>
[13:24:34.699] {
[13:24:34.699]     {
[13:24:34.699]         {
[13:24:34.699]             ...future.startTime <- base::Sys.time()
[13:24:34.699]             {
[13:24:34.699]                 {
[13:24:34.699]                   {
[13:24:34.699]                     {
[13:24:34.699]                       base::local({
[13:24:34.699]                         has_future <- base::requireNamespace("future", 
[13:24:34.699]                           quietly = TRUE)
[13:24:34.699]                         if (has_future) {
[13:24:34.699]                           ns <- base::getNamespace("future")
[13:24:34.699]                           version <- ns[[".package"]][["version"]]
[13:24:34.699]                           if (is.null(version)) 
[13:24:34.699]                             version <- utils::packageVersion("future")
[13:24:34.699]                         }
[13:24:34.699]                         else {
[13:24:34.699]                           version <- NULL
[13:24:34.699]                         }
[13:24:34.699]                         if (!has_future || version < "1.8.0") {
[13:24:34.699]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:34.699]                             "", base::R.version$version.string), 
[13:24:34.699]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:34.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:34.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:34.699]                               "release", "version")], collapse = " "), 
[13:24:34.699]                             hostname = base::Sys.info()[["nodename"]])
[13:24:34.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:34.699]                             info)
[13:24:34.699]                           info <- base::paste(info, collapse = "; ")
[13:24:34.699]                           if (!has_future) {
[13:24:34.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:34.699]                               info)
[13:24:34.699]                           }
[13:24:34.699]                           else {
[13:24:34.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:34.699]                               info, version)
[13:24:34.699]                           }
[13:24:34.699]                           base::stop(msg)
[13:24:34.699]                         }
[13:24:34.699]                       })
[13:24:34.699]                     }
[13:24:34.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:34.699]                     base::options(mc.cores = 1L)
[13:24:34.699]                   }
[13:24:34.699]                   options(future.plan = NULL)
[13:24:34.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:34.699]                 }
[13:24:34.699]                 ...future.workdir <- getwd()
[13:24:34.699]             }
[13:24:34.699]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:34.699]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:34.699]         }
[13:24:34.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:34.699]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:34.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:34.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:34.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:34.699]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:34.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:34.699]             base::names(...future.oldOptions))
[13:24:34.699]     }
[13:24:34.699]     if (FALSE) {
[13:24:34.699]     }
[13:24:34.699]     else {
[13:24:34.699]         if (TRUE) {
[13:24:34.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:34.699]                 open = "w")
[13:24:34.699]         }
[13:24:34.699]         else {
[13:24:34.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:34.699]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:34.699]         }
[13:24:34.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:34.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:34.699]             base::sink(type = "output", split = FALSE)
[13:24:34.699]             base::close(...future.stdout)
[13:24:34.699]         }, add = TRUE)
[13:24:34.699]     }
[13:24:34.699]     ...future.frame <- base::sys.nframe()
[13:24:34.699]     ...future.conditions <- base::list()
[13:24:34.699]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:34.699]     if (FALSE) {
[13:24:34.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:34.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:34.699]     }
[13:24:34.699]     ...future.result <- base::tryCatch({
[13:24:34.699]         base::withCallingHandlers({
[13:24:34.699]             ...future.value <- base::withVisible(base::local({
[13:24:34.699]                 ...future.makeSendCondition <- base::local({
[13:24:34.699]                   sendCondition <- NULL
[13:24:34.699]                   function(frame = 1L) {
[13:24:34.699]                     if (is.function(sendCondition)) 
[13:24:34.699]                       return(sendCondition)
[13:24:34.699]                     ns <- getNamespace("parallel")
[13:24:34.699]                     if (exists("sendData", mode = "function", 
[13:24:34.699]                       envir = ns)) {
[13:24:34.699]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:34.699]                         envir = ns)
[13:24:34.699]                       envir <- sys.frame(frame)
[13:24:34.699]                       master <- NULL
[13:24:34.699]                       while (!identical(envir, .GlobalEnv) && 
[13:24:34.699]                         !identical(envir, emptyenv())) {
[13:24:34.699]                         if (exists("master", mode = "list", envir = envir, 
[13:24:34.699]                           inherits = FALSE)) {
[13:24:34.699]                           master <- get("master", mode = "list", 
[13:24:34.699]                             envir = envir, inherits = FALSE)
[13:24:34.699]                           if (inherits(master, c("SOCKnode", 
[13:24:34.699]                             "SOCK0node"))) {
[13:24:34.699]                             sendCondition <<- function(cond) {
[13:24:34.699]                               data <- list(type = "VALUE", value = cond, 
[13:24:34.699]                                 success = TRUE)
[13:24:34.699]                               parallel_sendData(master, data)
[13:24:34.699]                             }
[13:24:34.699]                             return(sendCondition)
[13:24:34.699]                           }
[13:24:34.699]                         }
[13:24:34.699]                         frame <- frame + 1L
[13:24:34.699]                         envir <- sys.frame(frame)
[13:24:34.699]                       }
[13:24:34.699]                     }
[13:24:34.699]                     sendCondition <<- function(cond) NULL
[13:24:34.699]                   }
[13:24:34.699]                 })
[13:24:34.699]                 withCallingHandlers({
[13:24:34.699]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:34.699]                 }, immediateCondition = function(cond) {
[13:24:34.699]                   sendCondition <- ...future.makeSendCondition()
[13:24:34.699]                   sendCondition(cond)
[13:24:34.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.699]                   {
[13:24:34.699]                     inherits <- base::inherits
[13:24:34.699]                     invokeRestart <- base::invokeRestart
[13:24:34.699]                     is.null <- base::is.null
[13:24:34.699]                     muffled <- FALSE
[13:24:34.699]                     if (inherits(cond, "message")) {
[13:24:34.699]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:34.699]                       if (muffled) 
[13:24:34.699]                         invokeRestart("muffleMessage")
[13:24:34.699]                     }
[13:24:34.699]                     else if (inherits(cond, "warning")) {
[13:24:34.699]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:34.699]                       if (muffled) 
[13:24:34.699]                         invokeRestart("muffleWarning")
[13:24:34.699]                     }
[13:24:34.699]                     else if (inherits(cond, "condition")) {
[13:24:34.699]                       if (!is.null(pattern)) {
[13:24:34.699]                         computeRestarts <- base::computeRestarts
[13:24:34.699]                         grepl <- base::grepl
[13:24:34.699]                         restarts <- computeRestarts(cond)
[13:24:34.699]                         for (restart in restarts) {
[13:24:34.699]                           name <- restart$name
[13:24:34.699]                           if (is.null(name)) 
[13:24:34.699]                             next
[13:24:34.699]                           if (!grepl(pattern, name)) 
[13:24:34.699]                             next
[13:24:34.699]                           invokeRestart(restart)
[13:24:34.699]                           muffled <- TRUE
[13:24:34.699]                           break
[13:24:34.699]                         }
[13:24:34.699]                       }
[13:24:34.699]                     }
[13:24:34.699]                     invisible(muffled)
[13:24:34.699]                   }
[13:24:34.699]                   muffleCondition(cond)
[13:24:34.699]                 })
[13:24:34.699]             }))
[13:24:34.699]             future::FutureResult(value = ...future.value$value, 
[13:24:34.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.699]                   ...future.rng), globalenv = if (FALSE) 
[13:24:34.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:34.699]                     ...future.globalenv.names))
[13:24:34.699]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:34.699]         }, condition = base::local({
[13:24:34.699]             c <- base::c
[13:24:34.699]             inherits <- base::inherits
[13:24:34.699]             invokeRestart <- base::invokeRestart
[13:24:34.699]             length <- base::length
[13:24:34.699]             list <- base::list
[13:24:34.699]             seq.int <- base::seq.int
[13:24:34.699]             signalCondition <- base::signalCondition
[13:24:34.699]             sys.calls <- base::sys.calls
[13:24:34.699]             `[[` <- base::`[[`
[13:24:34.699]             `+` <- base::`+`
[13:24:34.699]             `<<-` <- base::`<<-`
[13:24:34.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:34.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:34.699]                   3L)]
[13:24:34.699]             }
[13:24:34.699]             function(cond) {
[13:24:34.699]                 is_error <- inherits(cond, "error")
[13:24:34.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:34.699]                   NULL)
[13:24:34.699]                 if (is_error) {
[13:24:34.699]                   sessionInformation <- function() {
[13:24:34.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:34.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:34.699]                       search = base::search(), system = base::Sys.info())
[13:24:34.699]                   }
[13:24:34.699]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:34.699]                     cond$call), session = sessionInformation(), 
[13:24:34.699]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:34.699]                   signalCondition(cond)
[13:24:34.699]                 }
[13:24:34.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:34.699]                 "immediateCondition"))) {
[13:24:34.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:34.699]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:34.699]                   if (TRUE && !signal) {
[13:24:34.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.699]                     {
[13:24:34.699]                       inherits <- base::inherits
[13:24:34.699]                       invokeRestart <- base::invokeRestart
[13:24:34.699]                       is.null <- base::is.null
[13:24:34.699]                       muffled <- FALSE
[13:24:34.699]                       if (inherits(cond, "message")) {
[13:24:34.699]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.699]                         if (muffled) 
[13:24:34.699]                           invokeRestart("muffleMessage")
[13:24:34.699]                       }
[13:24:34.699]                       else if (inherits(cond, "warning")) {
[13:24:34.699]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.699]                         if (muffled) 
[13:24:34.699]                           invokeRestart("muffleWarning")
[13:24:34.699]                       }
[13:24:34.699]                       else if (inherits(cond, "condition")) {
[13:24:34.699]                         if (!is.null(pattern)) {
[13:24:34.699]                           computeRestarts <- base::computeRestarts
[13:24:34.699]                           grepl <- base::grepl
[13:24:34.699]                           restarts <- computeRestarts(cond)
[13:24:34.699]                           for (restart in restarts) {
[13:24:34.699]                             name <- restart$name
[13:24:34.699]                             if (is.null(name)) 
[13:24:34.699]                               next
[13:24:34.699]                             if (!grepl(pattern, name)) 
[13:24:34.699]                               next
[13:24:34.699]                             invokeRestart(restart)
[13:24:34.699]                             muffled <- TRUE
[13:24:34.699]                             break
[13:24:34.699]                           }
[13:24:34.699]                         }
[13:24:34.699]                       }
[13:24:34.699]                       invisible(muffled)
[13:24:34.699]                     }
[13:24:34.699]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.699]                   }
[13:24:34.699]                 }
[13:24:34.699]                 else {
[13:24:34.699]                   if (TRUE) {
[13:24:34.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.699]                     {
[13:24:34.699]                       inherits <- base::inherits
[13:24:34.699]                       invokeRestart <- base::invokeRestart
[13:24:34.699]                       is.null <- base::is.null
[13:24:34.699]                       muffled <- FALSE
[13:24:34.699]                       if (inherits(cond, "message")) {
[13:24:34.699]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.699]                         if (muffled) 
[13:24:34.699]                           invokeRestart("muffleMessage")
[13:24:34.699]                       }
[13:24:34.699]                       else if (inherits(cond, "warning")) {
[13:24:34.699]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.699]                         if (muffled) 
[13:24:34.699]                           invokeRestart("muffleWarning")
[13:24:34.699]                       }
[13:24:34.699]                       else if (inherits(cond, "condition")) {
[13:24:34.699]                         if (!is.null(pattern)) {
[13:24:34.699]                           computeRestarts <- base::computeRestarts
[13:24:34.699]                           grepl <- base::grepl
[13:24:34.699]                           restarts <- computeRestarts(cond)
[13:24:34.699]                           for (restart in restarts) {
[13:24:34.699]                             name <- restart$name
[13:24:34.699]                             if (is.null(name)) 
[13:24:34.699]                               next
[13:24:34.699]                             if (!grepl(pattern, name)) 
[13:24:34.699]                               next
[13:24:34.699]                             invokeRestart(restart)
[13:24:34.699]                             muffled <- TRUE
[13:24:34.699]                             break
[13:24:34.699]                           }
[13:24:34.699]                         }
[13:24:34.699]                       }
[13:24:34.699]                       invisible(muffled)
[13:24:34.699]                     }
[13:24:34.699]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.699]                   }
[13:24:34.699]                 }
[13:24:34.699]             }
[13:24:34.699]         }))
[13:24:34.699]     }, error = function(ex) {
[13:24:34.699]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:34.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.699]                 ...future.rng), started = ...future.startTime, 
[13:24:34.699]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:34.699]             version = "1.8"), class = "FutureResult")
[13:24:34.699]     }, finally = {
[13:24:34.699]         if (!identical(...future.workdir, getwd())) 
[13:24:34.699]             setwd(...future.workdir)
[13:24:34.699]         {
[13:24:34.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:34.699]                 ...future.oldOptions$nwarnings <- NULL
[13:24:34.699]             }
[13:24:34.699]             base::options(...future.oldOptions)
[13:24:34.699]             if (.Platform$OS.type == "windows") {
[13:24:34.699]                 old_names <- names(...future.oldEnvVars)
[13:24:34.699]                 envs <- base::Sys.getenv()
[13:24:34.699]                 names <- names(envs)
[13:24:34.699]                 common <- intersect(names, old_names)
[13:24:34.699]                 added <- setdiff(names, old_names)
[13:24:34.699]                 removed <- setdiff(old_names, names)
[13:24:34.699]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:34.699]                   envs[common]]
[13:24:34.699]                 NAMES <- toupper(changed)
[13:24:34.699]                 args <- list()
[13:24:34.699]                 for (kk in seq_along(NAMES)) {
[13:24:34.699]                   name <- changed[[kk]]
[13:24:34.699]                   NAME <- NAMES[[kk]]
[13:24:34.699]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.699]                     next
[13:24:34.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.699]                 }
[13:24:34.699]                 NAMES <- toupper(added)
[13:24:34.699]                 for (kk in seq_along(NAMES)) {
[13:24:34.699]                   name <- added[[kk]]
[13:24:34.699]                   NAME <- NAMES[[kk]]
[13:24:34.699]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.699]                     next
[13:24:34.699]                   args[[name]] <- ""
[13:24:34.699]                 }
[13:24:34.699]                 NAMES <- toupper(removed)
[13:24:34.699]                 for (kk in seq_along(NAMES)) {
[13:24:34.699]                   name <- removed[[kk]]
[13:24:34.699]                   NAME <- NAMES[[kk]]
[13:24:34.699]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.699]                     next
[13:24:34.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.699]                 }
[13:24:34.699]                 if (length(args) > 0) 
[13:24:34.699]                   base::do.call(base::Sys.setenv, args = args)
[13:24:34.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:34.699]             }
[13:24:34.699]             else {
[13:24:34.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:34.699]             }
[13:24:34.699]             {
[13:24:34.699]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:34.699]                   0L) {
[13:24:34.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:34.699]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:34.699]                   base::options(opts)
[13:24:34.699]                 }
[13:24:34.699]                 {
[13:24:34.699]                   {
[13:24:34.699]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:34.699]                     NULL
[13:24:34.699]                   }
[13:24:34.699]                   options(future.plan = NULL)
[13:24:34.699]                   if (is.na(NA_character_)) 
[13:24:34.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:34.699]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:34.699]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:34.699]                     envir = parent.frame()) 
[13:24:34.699]                   {
[13:24:34.699]                     if (is.function(workers)) 
[13:24:34.699]                       workers <- workers()
[13:24:34.699]                     workers <- structure(as.integer(workers), 
[13:24:34.699]                       class = class(workers))
[13:24:34.699]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:34.699]                       workers >= 1)
[13:24:34.699]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:34.699]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:34.699]                     }
[13:24:34.699]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:34.699]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:34.699]                       envir = envir)
[13:24:34.699]                     if (!future$lazy) 
[13:24:34.699]                       future <- run(future)
[13:24:34.699]                     invisible(future)
[13:24:34.699]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:34.699]                 }
[13:24:34.699]             }
[13:24:34.699]         }
[13:24:34.699]     })
[13:24:34.699]     if (TRUE) {
[13:24:34.699]         base::sink(type = "output", split = FALSE)
[13:24:34.699]         if (TRUE) {
[13:24:34.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:34.699]         }
[13:24:34.699]         else {
[13:24:34.699]             ...future.result["stdout"] <- base::list(NULL)
[13:24:34.699]         }
[13:24:34.699]         base::close(...future.stdout)
[13:24:34.699]         ...future.stdout <- NULL
[13:24:34.699]     }
[13:24:34.699]     ...future.result$conditions <- ...future.conditions
[13:24:34.699]     ...future.result$finished <- base::Sys.time()
[13:24:34.699]     ...future.result
[13:24:34.699] }
[13:24:34.703] MultisessionFuture started
[13:24:34.703] - Launch lazy future ... done
[13:24:34.703] run() for ‘MultisessionFuture’ ... done
[13:24:34.749] receiveMessageFromWorker() for ClusterFuture ...
[13:24:34.750] - Validating connection of MultisessionFuture
[13:24:34.750] - received message: FutureResult
[13:24:34.750] - Received FutureResult
[13:24:34.750] - Erased future from FutureRegistry
[13:24:34.750] result() for ClusterFuture ...
[13:24:34.751] - result already collected: FutureResult
[13:24:34.751] result() for ClusterFuture ... done
[13:24:34.751] signalConditions() ...
[13:24:34.751]  - include = ‘immediateCondition’
[13:24:34.751]  - exclude = 
[13:24:34.751]  - resignal = FALSE
[13:24:34.751]  - Number of conditions: 1
[13:24:34.751] signalConditions() ... done
[13:24:34.751] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:34.751] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[13:24:34.752] getGlobalsAndPackages() ...
[13:24:34.752] Searching for globals...
[13:24:34.753] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:34.753] Searching for globals ... DONE
[13:24:34.753] Resolving globals: FALSE
[13:24:34.754] 
[13:24:34.754] 
[13:24:34.754] getGlobalsAndPackages() ... DONE
[13:24:34.754] run() for ‘Future’ ...
[13:24:34.754] - state: ‘created’
[13:24:34.754] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:34.768] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:34.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:34.768]   - Field: ‘node’
[13:24:34.768]   - Field: ‘label’
[13:24:34.768]   - Field: ‘local’
[13:24:34.769]   - Field: ‘owner’
[13:24:34.769]   - Field: ‘envir’
[13:24:34.769]   - Field: ‘workers’
[13:24:34.769]   - Field: ‘packages’
[13:24:34.769]   - Field: ‘gc’
[13:24:34.769]   - Field: ‘conditions’
[13:24:34.769]   - Field: ‘persistent’
[13:24:34.769]   - Field: ‘expr’
[13:24:34.769]   - Field: ‘uuid’
[13:24:34.769]   - Field: ‘seed’
[13:24:34.769]   - Field: ‘version’
[13:24:34.770]   - Field: ‘result’
[13:24:34.770]   - Field: ‘asynchronous’
[13:24:34.770]   - Field: ‘calls’
[13:24:34.770]   - Field: ‘globals’
[13:24:34.770]   - Field: ‘stdout’
[13:24:34.770]   - Field: ‘earlySignal’
[13:24:34.770]   - Field: ‘lazy’
[13:24:34.770]   - Field: ‘state’
[13:24:34.770] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:34.770] - Launch lazy future ...
[13:24:34.771] Packages needed by the future expression (n = 0): <none>
[13:24:34.771] Packages needed by future strategies (n = 0): <none>
[13:24:34.771] {
[13:24:34.771]     {
[13:24:34.771]         {
[13:24:34.771]             ...future.startTime <- base::Sys.time()
[13:24:34.771]             {
[13:24:34.771]                 {
[13:24:34.771]                   {
[13:24:34.771]                     {
[13:24:34.771]                       base::local({
[13:24:34.771]                         has_future <- base::requireNamespace("future", 
[13:24:34.771]                           quietly = TRUE)
[13:24:34.771]                         if (has_future) {
[13:24:34.771]                           ns <- base::getNamespace("future")
[13:24:34.771]                           version <- ns[[".package"]][["version"]]
[13:24:34.771]                           if (is.null(version)) 
[13:24:34.771]                             version <- utils::packageVersion("future")
[13:24:34.771]                         }
[13:24:34.771]                         else {
[13:24:34.771]                           version <- NULL
[13:24:34.771]                         }
[13:24:34.771]                         if (!has_future || version < "1.8.0") {
[13:24:34.771]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:34.771]                             "", base::R.version$version.string), 
[13:24:34.771]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:34.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:34.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:34.771]                               "release", "version")], collapse = " "), 
[13:24:34.771]                             hostname = base::Sys.info()[["nodename"]])
[13:24:34.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:34.771]                             info)
[13:24:34.771]                           info <- base::paste(info, collapse = "; ")
[13:24:34.771]                           if (!has_future) {
[13:24:34.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:34.771]                               info)
[13:24:34.771]                           }
[13:24:34.771]                           else {
[13:24:34.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:34.771]                               info, version)
[13:24:34.771]                           }
[13:24:34.771]                           base::stop(msg)
[13:24:34.771]                         }
[13:24:34.771]                       })
[13:24:34.771]                     }
[13:24:34.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:34.771]                     base::options(mc.cores = 1L)
[13:24:34.771]                   }
[13:24:34.771]                   options(future.plan = NULL)
[13:24:34.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:34.771]                 }
[13:24:34.771]                 ...future.workdir <- getwd()
[13:24:34.771]             }
[13:24:34.771]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:34.771]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:34.771]         }
[13:24:34.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:34.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:34.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:34.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:34.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:34.771]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:34.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:34.771]             base::names(...future.oldOptions))
[13:24:34.771]     }
[13:24:34.771]     if (FALSE) {
[13:24:34.771]     }
[13:24:34.771]     else {
[13:24:34.771]         if (TRUE) {
[13:24:34.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:34.771]                 open = "w")
[13:24:34.771]         }
[13:24:34.771]         else {
[13:24:34.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:34.771]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:34.771]         }
[13:24:34.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:34.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:34.771]             base::sink(type = "output", split = FALSE)
[13:24:34.771]             base::close(...future.stdout)
[13:24:34.771]         }, add = TRUE)
[13:24:34.771]     }
[13:24:34.771]     ...future.frame <- base::sys.nframe()
[13:24:34.771]     ...future.conditions <- base::list()
[13:24:34.771]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:34.771]     if (FALSE) {
[13:24:34.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:34.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:34.771]     }
[13:24:34.771]     ...future.result <- base::tryCatch({
[13:24:34.771]         base::withCallingHandlers({
[13:24:34.771]             ...future.value <- base::withVisible(base::local({
[13:24:34.771]                 ...future.makeSendCondition <- base::local({
[13:24:34.771]                   sendCondition <- NULL
[13:24:34.771]                   function(frame = 1L) {
[13:24:34.771]                     if (is.function(sendCondition)) 
[13:24:34.771]                       return(sendCondition)
[13:24:34.771]                     ns <- getNamespace("parallel")
[13:24:34.771]                     if (exists("sendData", mode = "function", 
[13:24:34.771]                       envir = ns)) {
[13:24:34.771]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:34.771]                         envir = ns)
[13:24:34.771]                       envir <- sys.frame(frame)
[13:24:34.771]                       master <- NULL
[13:24:34.771]                       while (!identical(envir, .GlobalEnv) && 
[13:24:34.771]                         !identical(envir, emptyenv())) {
[13:24:34.771]                         if (exists("master", mode = "list", envir = envir, 
[13:24:34.771]                           inherits = FALSE)) {
[13:24:34.771]                           master <- get("master", mode = "list", 
[13:24:34.771]                             envir = envir, inherits = FALSE)
[13:24:34.771]                           if (inherits(master, c("SOCKnode", 
[13:24:34.771]                             "SOCK0node"))) {
[13:24:34.771]                             sendCondition <<- function(cond) {
[13:24:34.771]                               data <- list(type = "VALUE", value = cond, 
[13:24:34.771]                                 success = TRUE)
[13:24:34.771]                               parallel_sendData(master, data)
[13:24:34.771]                             }
[13:24:34.771]                             return(sendCondition)
[13:24:34.771]                           }
[13:24:34.771]                         }
[13:24:34.771]                         frame <- frame + 1L
[13:24:34.771]                         envir <- sys.frame(frame)
[13:24:34.771]                       }
[13:24:34.771]                     }
[13:24:34.771]                     sendCondition <<- function(cond) NULL
[13:24:34.771]                   }
[13:24:34.771]                 })
[13:24:34.771]                 withCallingHandlers({
[13:24:34.771]                   {
[13:24:34.771]                     Sys.sleep(0.5)
[13:24:34.771]                     list(a = 1, b = 42L)
[13:24:34.771]                   }
[13:24:34.771]                 }, immediateCondition = function(cond) {
[13:24:34.771]                   sendCondition <- ...future.makeSendCondition()
[13:24:34.771]                   sendCondition(cond)
[13:24:34.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.771]                   {
[13:24:34.771]                     inherits <- base::inherits
[13:24:34.771]                     invokeRestart <- base::invokeRestart
[13:24:34.771]                     is.null <- base::is.null
[13:24:34.771]                     muffled <- FALSE
[13:24:34.771]                     if (inherits(cond, "message")) {
[13:24:34.771]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:34.771]                       if (muffled) 
[13:24:34.771]                         invokeRestart("muffleMessage")
[13:24:34.771]                     }
[13:24:34.771]                     else if (inherits(cond, "warning")) {
[13:24:34.771]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:34.771]                       if (muffled) 
[13:24:34.771]                         invokeRestart("muffleWarning")
[13:24:34.771]                     }
[13:24:34.771]                     else if (inherits(cond, "condition")) {
[13:24:34.771]                       if (!is.null(pattern)) {
[13:24:34.771]                         computeRestarts <- base::computeRestarts
[13:24:34.771]                         grepl <- base::grepl
[13:24:34.771]                         restarts <- computeRestarts(cond)
[13:24:34.771]                         for (restart in restarts) {
[13:24:34.771]                           name <- restart$name
[13:24:34.771]                           if (is.null(name)) 
[13:24:34.771]                             next
[13:24:34.771]                           if (!grepl(pattern, name)) 
[13:24:34.771]                             next
[13:24:34.771]                           invokeRestart(restart)
[13:24:34.771]                           muffled <- TRUE
[13:24:34.771]                           break
[13:24:34.771]                         }
[13:24:34.771]                       }
[13:24:34.771]                     }
[13:24:34.771]                     invisible(muffled)
[13:24:34.771]                   }
[13:24:34.771]                   muffleCondition(cond)
[13:24:34.771]                 })
[13:24:34.771]             }))
[13:24:34.771]             future::FutureResult(value = ...future.value$value, 
[13:24:34.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.771]                   ...future.rng), globalenv = if (FALSE) 
[13:24:34.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:34.771]                     ...future.globalenv.names))
[13:24:34.771]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:34.771]         }, condition = base::local({
[13:24:34.771]             c <- base::c
[13:24:34.771]             inherits <- base::inherits
[13:24:34.771]             invokeRestart <- base::invokeRestart
[13:24:34.771]             length <- base::length
[13:24:34.771]             list <- base::list
[13:24:34.771]             seq.int <- base::seq.int
[13:24:34.771]             signalCondition <- base::signalCondition
[13:24:34.771]             sys.calls <- base::sys.calls
[13:24:34.771]             `[[` <- base::`[[`
[13:24:34.771]             `+` <- base::`+`
[13:24:34.771]             `<<-` <- base::`<<-`
[13:24:34.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:34.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:34.771]                   3L)]
[13:24:34.771]             }
[13:24:34.771]             function(cond) {
[13:24:34.771]                 is_error <- inherits(cond, "error")
[13:24:34.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:34.771]                   NULL)
[13:24:34.771]                 if (is_error) {
[13:24:34.771]                   sessionInformation <- function() {
[13:24:34.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:34.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:34.771]                       search = base::search(), system = base::Sys.info())
[13:24:34.771]                   }
[13:24:34.771]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:34.771]                     cond$call), session = sessionInformation(), 
[13:24:34.771]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:34.771]                   signalCondition(cond)
[13:24:34.771]                 }
[13:24:34.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:34.771]                 "immediateCondition"))) {
[13:24:34.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:34.771]                   ...future.conditions[[length(...future.conditions) + 
[13:24:34.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:34.771]                   if (TRUE && !signal) {
[13:24:34.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.771]                     {
[13:24:34.771]                       inherits <- base::inherits
[13:24:34.771]                       invokeRestart <- base::invokeRestart
[13:24:34.771]                       is.null <- base::is.null
[13:24:34.771]                       muffled <- FALSE
[13:24:34.771]                       if (inherits(cond, "message")) {
[13:24:34.771]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.771]                         if (muffled) 
[13:24:34.771]                           invokeRestart("muffleMessage")
[13:24:34.771]                       }
[13:24:34.771]                       else if (inherits(cond, "warning")) {
[13:24:34.771]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.771]                         if (muffled) 
[13:24:34.771]                           invokeRestart("muffleWarning")
[13:24:34.771]                       }
[13:24:34.771]                       else if (inherits(cond, "condition")) {
[13:24:34.771]                         if (!is.null(pattern)) {
[13:24:34.771]                           computeRestarts <- base::computeRestarts
[13:24:34.771]                           grepl <- base::grepl
[13:24:34.771]                           restarts <- computeRestarts(cond)
[13:24:34.771]                           for (restart in restarts) {
[13:24:34.771]                             name <- restart$name
[13:24:34.771]                             if (is.null(name)) 
[13:24:34.771]                               next
[13:24:34.771]                             if (!grepl(pattern, name)) 
[13:24:34.771]                               next
[13:24:34.771]                             invokeRestart(restart)
[13:24:34.771]                             muffled <- TRUE
[13:24:34.771]                             break
[13:24:34.771]                           }
[13:24:34.771]                         }
[13:24:34.771]                       }
[13:24:34.771]                       invisible(muffled)
[13:24:34.771]                     }
[13:24:34.771]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.771]                   }
[13:24:34.771]                 }
[13:24:34.771]                 else {
[13:24:34.771]                   if (TRUE) {
[13:24:34.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:34.771]                     {
[13:24:34.771]                       inherits <- base::inherits
[13:24:34.771]                       invokeRestart <- base::invokeRestart
[13:24:34.771]                       is.null <- base::is.null
[13:24:34.771]                       muffled <- FALSE
[13:24:34.771]                       if (inherits(cond, "message")) {
[13:24:34.771]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:34.771]                         if (muffled) 
[13:24:34.771]                           invokeRestart("muffleMessage")
[13:24:34.771]                       }
[13:24:34.771]                       else if (inherits(cond, "warning")) {
[13:24:34.771]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:34.771]                         if (muffled) 
[13:24:34.771]                           invokeRestart("muffleWarning")
[13:24:34.771]                       }
[13:24:34.771]                       else if (inherits(cond, "condition")) {
[13:24:34.771]                         if (!is.null(pattern)) {
[13:24:34.771]                           computeRestarts <- base::computeRestarts
[13:24:34.771]                           grepl <- base::grepl
[13:24:34.771]                           restarts <- computeRestarts(cond)
[13:24:34.771]                           for (restart in restarts) {
[13:24:34.771]                             name <- restart$name
[13:24:34.771]                             if (is.null(name)) 
[13:24:34.771]                               next
[13:24:34.771]                             if (!grepl(pattern, name)) 
[13:24:34.771]                               next
[13:24:34.771]                             invokeRestart(restart)
[13:24:34.771]                             muffled <- TRUE
[13:24:34.771]                             break
[13:24:34.771]                           }
[13:24:34.771]                         }
[13:24:34.771]                       }
[13:24:34.771]                       invisible(muffled)
[13:24:34.771]                     }
[13:24:34.771]                     muffleCondition(cond, pattern = "^muffle")
[13:24:34.771]                   }
[13:24:34.771]                 }
[13:24:34.771]             }
[13:24:34.771]         }))
[13:24:34.771]     }, error = function(ex) {
[13:24:34.771]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:34.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:34.771]                 ...future.rng), started = ...future.startTime, 
[13:24:34.771]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:34.771]             version = "1.8"), class = "FutureResult")
[13:24:34.771]     }, finally = {
[13:24:34.771]         if (!identical(...future.workdir, getwd())) 
[13:24:34.771]             setwd(...future.workdir)
[13:24:34.771]         {
[13:24:34.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:34.771]                 ...future.oldOptions$nwarnings <- NULL
[13:24:34.771]             }
[13:24:34.771]             base::options(...future.oldOptions)
[13:24:34.771]             if (.Platform$OS.type == "windows") {
[13:24:34.771]                 old_names <- names(...future.oldEnvVars)
[13:24:34.771]                 envs <- base::Sys.getenv()
[13:24:34.771]                 names <- names(envs)
[13:24:34.771]                 common <- intersect(names, old_names)
[13:24:34.771]                 added <- setdiff(names, old_names)
[13:24:34.771]                 removed <- setdiff(old_names, names)
[13:24:34.771]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:34.771]                   envs[common]]
[13:24:34.771]                 NAMES <- toupper(changed)
[13:24:34.771]                 args <- list()
[13:24:34.771]                 for (kk in seq_along(NAMES)) {
[13:24:34.771]                   name <- changed[[kk]]
[13:24:34.771]                   NAME <- NAMES[[kk]]
[13:24:34.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.771]                     next
[13:24:34.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.771]                 }
[13:24:34.771]                 NAMES <- toupper(added)
[13:24:34.771]                 for (kk in seq_along(NAMES)) {
[13:24:34.771]                   name <- added[[kk]]
[13:24:34.771]                   NAME <- NAMES[[kk]]
[13:24:34.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.771]                     next
[13:24:34.771]                   args[[name]] <- ""
[13:24:34.771]                 }
[13:24:34.771]                 NAMES <- toupper(removed)
[13:24:34.771]                 for (kk in seq_along(NAMES)) {
[13:24:34.771]                   name <- removed[[kk]]
[13:24:34.771]                   NAME <- NAMES[[kk]]
[13:24:34.771]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:34.771]                     next
[13:24:34.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:34.771]                 }
[13:24:34.771]                 if (length(args) > 0) 
[13:24:34.771]                   base::do.call(base::Sys.setenv, args = args)
[13:24:34.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:34.771]             }
[13:24:34.771]             else {
[13:24:34.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:34.771]             }
[13:24:34.771]             {
[13:24:34.771]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:34.771]                   0L) {
[13:24:34.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:34.771]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:34.771]                   base::options(opts)
[13:24:34.771]                 }
[13:24:34.771]                 {
[13:24:34.771]                   {
[13:24:34.771]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:34.771]                     NULL
[13:24:34.771]                   }
[13:24:34.771]                   options(future.plan = NULL)
[13:24:34.771]                   if (is.na(NA_character_)) 
[13:24:34.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:34.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:34.771]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:34.771]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:34.771]                     envir = parent.frame()) 
[13:24:34.771]                   {
[13:24:34.771]                     if (is.function(workers)) 
[13:24:34.771]                       workers <- workers()
[13:24:34.771]                     workers <- structure(as.integer(workers), 
[13:24:34.771]                       class = class(workers))
[13:24:34.771]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:34.771]                       workers >= 1)
[13:24:34.771]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:34.771]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:34.771]                     }
[13:24:34.771]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:34.771]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:34.771]                       envir = envir)
[13:24:34.771]                     if (!future$lazy) 
[13:24:34.771]                       future <- run(future)
[13:24:34.771]                     invisible(future)
[13:24:34.771]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:34.771]                 }
[13:24:34.771]             }
[13:24:34.771]         }
[13:24:34.771]     })
[13:24:34.771]     if (TRUE) {
[13:24:34.771]         base::sink(type = "output", split = FALSE)
[13:24:34.771]         if (TRUE) {
[13:24:34.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:34.771]         }
[13:24:34.771]         else {
[13:24:34.771]             ...future.result["stdout"] <- base::list(NULL)
[13:24:34.771]         }
[13:24:34.771]         base::close(...future.stdout)
[13:24:34.771]         ...future.stdout <- NULL
[13:24:34.771]     }
[13:24:34.771]     ...future.result$conditions <- ...future.conditions
[13:24:34.771]     ...future.result$finished <- base::Sys.time()
[13:24:34.771]     ...future.result
[13:24:34.771] }
[13:24:34.775] MultisessionFuture started
[13:24:34.775] - Launch lazy future ... done
[13:24:34.775] run() for ‘MultisessionFuture’ ... done
[13:24:35.322] receiveMessageFromWorker() for ClusterFuture ...
[13:24:35.322] - Validating connection of MultisessionFuture
[13:24:35.323] - received message: FutureResult
[13:24:35.323] - Received FutureResult
[13:24:35.323] - Erased future from FutureRegistry
[13:24:35.323] result() for ClusterFuture ...
[13:24:35.323] - result already collected: FutureResult
[13:24:35.323] result() for ClusterFuture ... done
[13:24:35.323] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:35.323] resolve() on list ...
[13:24:35.324]  recursive: 98
[13:24:35.324]  length: 2
[13:24:35.324]  elements: ‘a’, ‘b’
[13:24:35.324]  length: 1 (resolved future 1)
[13:24:35.324]  length: 0 (resolved future 2)
[13:24:35.324] resolve() on list ... DONE
[13:24:35.324] A MultisessionFuture was resolved (and resolved itself)
[13:24:35.324] getGlobalsAndPackages() ...
[13:24:35.324] Searching for globals...
[13:24:35.326] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:35.326] Searching for globals ... DONE
[13:24:35.326] Resolving globals: FALSE
[13:24:35.326] 
[13:24:35.326] 
[13:24:35.326] getGlobalsAndPackages() ... DONE
[13:24:35.327] run() for ‘Future’ ...
[13:24:35.327] - state: ‘created’
[13:24:35.327] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:35.341] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:35.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:35.341]   - Field: ‘node’
[13:24:35.346]   - Field: ‘label’
[13:24:35.346]   - Field: ‘local’
[13:24:35.346]   - Field: ‘owner’
[13:24:35.347]   - Field: ‘envir’
[13:24:35.347]   - Field: ‘workers’
[13:24:35.347]   - Field: ‘packages’
[13:24:35.347]   - Field: ‘gc’
[13:24:35.347]   - Field: ‘conditions’
[13:24:35.347]   - Field: ‘persistent’
[13:24:35.347]   - Field: ‘expr’
[13:24:35.347]   - Field: ‘uuid’
[13:24:35.347]   - Field: ‘seed’
[13:24:35.347]   - Field: ‘version’
[13:24:35.348]   - Field: ‘result’
[13:24:35.348]   - Field: ‘asynchronous’
[13:24:35.348]   - Field: ‘calls’
[13:24:35.348]   - Field: ‘globals’
[13:24:35.348]   - Field: ‘stdout’
[13:24:35.348]   - Field: ‘earlySignal’
[13:24:35.348]   - Field: ‘lazy’
[13:24:35.348]   - Field: ‘state’
[13:24:35.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:35.348] - Launch lazy future ...
[13:24:35.349] Packages needed by the future expression (n = 0): <none>
[13:24:35.349] Packages needed by future strategies (n = 0): <none>
[13:24:35.349] {
[13:24:35.349]     {
[13:24:35.349]         {
[13:24:35.349]             ...future.startTime <- base::Sys.time()
[13:24:35.349]             {
[13:24:35.349]                 {
[13:24:35.349]                   {
[13:24:35.349]                     {
[13:24:35.349]                       base::local({
[13:24:35.349]                         has_future <- base::requireNamespace("future", 
[13:24:35.349]                           quietly = TRUE)
[13:24:35.349]                         if (has_future) {
[13:24:35.349]                           ns <- base::getNamespace("future")
[13:24:35.349]                           version <- ns[[".package"]][["version"]]
[13:24:35.349]                           if (is.null(version)) 
[13:24:35.349]                             version <- utils::packageVersion("future")
[13:24:35.349]                         }
[13:24:35.349]                         else {
[13:24:35.349]                           version <- NULL
[13:24:35.349]                         }
[13:24:35.349]                         if (!has_future || version < "1.8.0") {
[13:24:35.349]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:35.349]                             "", base::R.version$version.string), 
[13:24:35.349]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:35.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:35.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:35.349]                               "release", "version")], collapse = " "), 
[13:24:35.349]                             hostname = base::Sys.info()[["nodename"]])
[13:24:35.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:35.349]                             info)
[13:24:35.349]                           info <- base::paste(info, collapse = "; ")
[13:24:35.349]                           if (!has_future) {
[13:24:35.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:35.349]                               info)
[13:24:35.349]                           }
[13:24:35.349]                           else {
[13:24:35.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:35.349]                               info, version)
[13:24:35.349]                           }
[13:24:35.349]                           base::stop(msg)
[13:24:35.349]                         }
[13:24:35.349]                       })
[13:24:35.349]                     }
[13:24:35.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:35.349]                     base::options(mc.cores = 1L)
[13:24:35.349]                   }
[13:24:35.349]                   options(future.plan = NULL)
[13:24:35.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:35.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:35.349]                 }
[13:24:35.349]                 ...future.workdir <- getwd()
[13:24:35.349]             }
[13:24:35.349]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:35.349]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:35.349]         }
[13:24:35.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:35.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:35.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:35.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:35.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:35.349]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:35.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:35.349]             base::names(...future.oldOptions))
[13:24:35.349]     }
[13:24:35.349]     if (FALSE) {
[13:24:35.349]     }
[13:24:35.349]     else {
[13:24:35.349]         if (TRUE) {
[13:24:35.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:35.349]                 open = "w")
[13:24:35.349]         }
[13:24:35.349]         else {
[13:24:35.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:35.349]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:35.349]         }
[13:24:35.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:35.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:35.349]             base::sink(type = "output", split = FALSE)
[13:24:35.349]             base::close(...future.stdout)
[13:24:35.349]         }, add = TRUE)
[13:24:35.349]     }
[13:24:35.349]     ...future.frame <- base::sys.nframe()
[13:24:35.349]     ...future.conditions <- base::list()
[13:24:35.349]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:35.349]     if (FALSE) {
[13:24:35.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:35.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:35.349]     }
[13:24:35.349]     ...future.result <- base::tryCatch({
[13:24:35.349]         base::withCallingHandlers({
[13:24:35.349]             ...future.value <- base::withVisible(base::local({
[13:24:35.349]                 ...future.makeSendCondition <- base::local({
[13:24:35.349]                   sendCondition <- NULL
[13:24:35.349]                   function(frame = 1L) {
[13:24:35.349]                     if (is.function(sendCondition)) 
[13:24:35.349]                       return(sendCondition)
[13:24:35.349]                     ns <- getNamespace("parallel")
[13:24:35.349]                     if (exists("sendData", mode = "function", 
[13:24:35.349]                       envir = ns)) {
[13:24:35.349]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:35.349]                         envir = ns)
[13:24:35.349]                       envir <- sys.frame(frame)
[13:24:35.349]                       master <- NULL
[13:24:35.349]                       while (!identical(envir, .GlobalEnv) && 
[13:24:35.349]                         !identical(envir, emptyenv())) {
[13:24:35.349]                         if (exists("master", mode = "list", envir = envir, 
[13:24:35.349]                           inherits = FALSE)) {
[13:24:35.349]                           master <- get("master", mode = "list", 
[13:24:35.349]                             envir = envir, inherits = FALSE)
[13:24:35.349]                           if (inherits(master, c("SOCKnode", 
[13:24:35.349]                             "SOCK0node"))) {
[13:24:35.349]                             sendCondition <<- function(cond) {
[13:24:35.349]                               data <- list(type = "VALUE", value = cond, 
[13:24:35.349]                                 success = TRUE)
[13:24:35.349]                               parallel_sendData(master, data)
[13:24:35.349]                             }
[13:24:35.349]                             return(sendCondition)
[13:24:35.349]                           }
[13:24:35.349]                         }
[13:24:35.349]                         frame <- frame + 1L
[13:24:35.349]                         envir <- sys.frame(frame)
[13:24:35.349]                       }
[13:24:35.349]                     }
[13:24:35.349]                     sendCondition <<- function(cond) NULL
[13:24:35.349]                   }
[13:24:35.349]                 })
[13:24:35.349]                 withCallingHandlers({
[13:24:35.349]                   {
[13:24:35.349]                     Sys.sleep(0.5)
[13:24:35.349]                     list(a = 1, b = 42L)
[13:24:35.349]                   }
[13:24:35.349]                 }, immediateCondition = function(cond) {
[13:24:35.349]                   sendCondition <- ...future.makeSendCondition()
[13:24:35.349]                   sendCondition(cond)
[13:24:35.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:35.349]                   {
[13:24:35.349]                     inherits <- base::inherits
[13:24:35.349]                     invokeRestart <- base::invokeRestart
[13:24:35.349]                     is.null <- base::is.null
[13:24:35.349]                     muffled <- FALSE
[13:24:35.349]                     if (inherits(cond, "message")) {
[13:24:35.349]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:35.349]                       if (muffled) 
[13:24:35.349]                         invokeRestart("muffleMessage")
[13:24:35.349]                     }
[13:24:35.349]                     else if (inherits(cond, "warning")) {
[13:24:35.349]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:35.349]                       if (muffled) 
[13:24:35.349]                         invokeRestart("muffleWarning")
[13:24:35.349]                     }
[13:24:35.349]                     else if (inherits(cond, "condition")) {
[13:24:35.349]                       if (!is.null(pattern)) {
[13:24:35.349]                         computeRestarts <- base::computeRestarts
[13:24:35.349]                         grepl <- base::grepl
[13:24:35.349]                         restarts <- computeRestarts(cond)
[13:24:35.349]                         for (restart in restarts) {
[13:24:35.349]                           name <- restart$name
[13:24:35.349]                           if (is.null(name)) 
[13:24:35.349]                             next
[13:24:35.349]                           if (!grepl(pattern, name)) 
[13:24:35.349]                             next
[13:24:35.349]                           invokeRestart(restart)
[13:24:35.349]                           muffled <- TRUE
[13:24:35.349]                           break
[13:24:35.349]                         }
[13:24:35.349]                       }
[13:24:35.349]                     }
[13:24:35.349]                     invisible(muffled)
[13:24:35.349]                   }
[13:24:35.349]                   muffleCondition(cond)
[13:24:35.349]                 })
[13:24:35.349]             }))
[13:24:35.349]             future::FutureResult(value = ...future.value$value, 
[13:24:35.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:35.349]                   ...future.rng), globalenv = if (FALSE) 
[13:24:35.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:35.349]                     ...future.globalenv.names))
[13:24:35.349]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:35.349]         }, condition = base::local({
[13:24:35.349]             c <- base::c
[13:24:35.349]             inherits <- base::inherits
[13:24:35.349]             invokeRestart <- base::invokeRestart
[13:24:35.349]             length <- base::length
[13:24:35.349]             list <- base::list
[13:24:35.349]             seq.int <- base::seq.int
[13:24:35.349]             signalCondition <- base::signalCondition
[13:24:35.349]             sys.calls <- base::sys.calls
[13:24:35.349]             `[[` <- base::`[[`
[13:24:35.349]             `+` <- base::`+`
[13:24:35.349]             `<<-` <- base::`<<-`
[13:24:35.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:35.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:35.349]                   3L)]
[13:24:35.349]             }
[13:24:35.349]             function(cond) {
[13:24:35.349]                 is_error <- inherits(cond, "error")
[13:24:35.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:35.349]                   NULL)
[13:24:35.349]                 if (is_error) {
[13:24:35.349]                   sessionInformation <- function() {
[13:24:35.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:35.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:35.349]                       search = base::search(), system = base::Sys.info())
[13:24:35.349]                   }
[13:24:35.349]                   ...future.conditions[[length(...future.conditions) + 
[13:24:35.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:35.349]                     cond$call), session = sessionInformation(), 
[13:24:35.349]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:35.349]                   signalCondition(cond)
[13:24:35.349]                 }
[13:24:35.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:35.349]                 "immediateCondition"))) {
[13:24:35.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:35.349]                   ...future.conditions[[length(...future.conditions) + 
[13:24:35.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:35.349]                   if (TRUE && !signal) {
[13:24:35.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:35.349]                     {
[13:24:35.349]                       inherits <- base::inherits
[13:24:35.349]                       invokeRestart <- base::invokeRestart
[13:24:35.349]                       is.null <- base::is.null
[13:24:35.349]                       muffled <- FALSE
[13:24:35.349]                       if (inherits(cond, "message")) {
[13:24:35.349]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:35.349]                         if (muffled) 
[13:24:35.349]                           invokeRestart("muffleMessage")
[13:24:35.349]                       }
[13:24:35.349]                       else if (inherits(cond, "warning")) {
[13:24:35.349]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:35.349]                         if (muffled) 
[13:24:35.349]                           invokeRestart("muffleWarning")
[13:24:35.349]                       }
[13:24:35.349]                       else if (inherits(cond, "condition")) {
[13:24:35.349]                         if (!is.null(pattern)) {
[13:24:35.349]                           computeRestarts <- base::computeRestarts
[13:24:35.349]                           grepl <- base::grepl
[13:24:35.349]                           restarts <- computeRestarts(cond)
[13:24:35.349]                           for (restart in restarts) {
[13:24:35.349]                             name <- restart$name
[13:24:35.349]                             if (is.null(name)) 
[13:24:35.349]                               next
[13:24:35.349]                             if (!grepl(pattern, name)) 
[13:24:35.349]                               next
[13:24:35.349]                             invokeRestart(restart)
[13:24:35.349]                             muffled <- TRUE
[13:24:35.349]                             break
[13:24:35.349]                           }
[13:24:35.349]                         }
[13:24:35.349]                       }
[13:24:35.349]                       invisible(muffled)
[13:24:35.349]                     }
[13:24:35.349]                     muffleCondition(cond, pattern = "^muffle")
[13:24:35.349]                   }
[13:24:35.349]                 }
[13:24:35.349]                 else {
[13:24:35.349]                   if (TRUE) {
[13:24:35.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:35.349]                     {
[13:24:35.349]                       inherits <- base::inherits
[13:24:35.349]                       invokeRestart <- base::invokeRestart
[13:24:35.349]                       is.null <- base::is.null
[13:24:35.349]                       muffled <- FALSE
[13:24:35.349]                       if (inherits(cond, "message")) {
[13:24:35.349]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:35.349]                         if (muffled) 
[13:24:35.349]                           invokeRestart("muffleMessage")
[13:24:35.349]                       }
[13:24:35.349]                       else if (inherits(cond, "warning")) {
[13:24:35.349]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:35.349]                         if (muffled) 
[13:24:35.349]                           invokeRestart("muffleWarning")
[13:24:35.349]                       }
[13:24:35.349]                       else if (inherits(cond, "condition")) {
[13:24:35.349]                         if (!is.null(pattern)) {
[13:24:35.349]                           computeRestarts <- base::computeRestarts
[13:24:35.349]                           grepl <- base::grepl
[13:24:35.349]                           restarts <- computeRestarts(cond)
[13:24:35.349]                           for (restart in restarts) {
[13:24:35.349]                             name <- restart$name
[13:24:35.349]                             if (is.null(name)) 
[13:24:35.349]                               next
[13:24:35.349]                             if (!grepl(pattern, name)) 
[13:24:35.349]                               next
[13:24:35.349]                             invokeRestart(restart)
[13:24:35.349]                             muffled <- TRUE
[13:24:35.349]                             break
[13:24:35.349]                           }
[13:24:35.349]                         }
[13:24:35.349]                       }
[13:24:35.349]                       invisible(muffled)
[13:24:35.349]                     }
[13:24:35.349]                     muffleCondition(cond, pattern = "^muffle")
[13:24:35.349]                   }
[13:24:35.349]                 }
[13:24:35.349]             }
[13:24:35.349]         }))
[13:24:35.349]     }, error = function(ex) {
[13:24:35.349]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:35.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:35.349]                 ...future.rng), started = ...future.startTime, 
[13:24:35.349]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:35.349]             version = "1.8"), class = "FutureResult")
[13:24:35.349]     }, finally = {
[13:24:35.349]         if (!identical(...future.workdir, getwd())) 
[13:24:35.349]             setwd(...future.workdir)
[13:24:35.349]         {
[13:24:35.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:35.349]                 ...future.oldOptions$nwarnings <- NULL
[13:24:35.349]             }
[13:24:35.349]             base::options(...future.oldOptions)
[13:24:35.349]             if (.Platform$OS.type == "windows") {
[13:24:35.349]                 old_names <- names(...future.oldEnvVars)
[13:24:35.349]                 envs <- base::Sys.getenv()
[13:24:35.349]                 names <- names(envs)
[13:24:35.349]                 common <- intersect(names, old_names)
[13:24:35.349]                 added <- setdiff(names, old_names)
[13:24:35.349]                 removed <- setdiff(old_names, names)
[13:24:35.349]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:35.349]                   envs[common]]
[13:24:35.349]                 NAMES <- toupper(changed)
[13:24:35.349]                 args <- list()
[13:24:35.349]                 for (kk in seq_along(NAMES)) {
[13:24:35.349]                   name <- changed[[kk]]
[13:24:35.349]                   NAME <- NAMES[[kk]]
[13:24:35.349]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:35.349]                     next
[13:24:35.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:35.349]                 }
[13:24:35.349]                 NAMES <- toupper(added)
[13:24:35.349]                 for (kk in seq_along(NAMES)) {
[13:24:35.349]                   name <- added[[kk]]
[13:24:35.349]                   NAME <- NAMES[[kk]]
[13:24:35.349]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:35.349]                     next
[13:24:35.349]                   args[[name]] <- ""
[13:24:35.349]                 }
[13:24:35.349]                 NAMES <- toupper(removed)
[13:24:35.349]                 for (kk in seq_along(NAMES)) {
[13:24:35.349]                   name <- removed[[kk]]
[13:24:35.349]                   NAME <- NAMES[[kk]]
[13:24:35.349]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:35.349]                     next
[13:24:35.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:35.349]                 }
[13:24:35.349]                 if (length(args) > 0) 
[13:24:35.349]                   base::do.call(base::Sys.setenv, args = args)
[13:24:35.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:35.349]             }
[13:24:35.349]             else {
[13:24:35.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:35.349]             }
[13:24:35.349]             {
[13:24:35.349]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:35.349]                   0L) {
[13:24:35.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:35.349]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:35.349]                   base::options(opts)
[13:24:35.349]                 }
[13:24:35.349]                 {
[13:24:35.349]                   {
[13:24:35.349]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:35.349]                     NULL
[13:24:35.349]                   }
[13:24:35.349]                   options(future.plan = NULL)
[13:24:35.349]                   if (is.na(NA_character_)) 
[13:24:35.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:35.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:35.349]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:35.349]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:35.349]                     envir = parent.frame()) 
[13:24:35.349]                   {
[13:24:35.349]                     if (is.function(workers)) 
[13:24:35.349]                       workers <- workers()
[13:24:35.349]                     workers <- structure(as.integer(workers), 
[13:24:35.349]                       class = class(workers))
[13:24:35.349]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:35.349]                       workers >= 1)
[13:24:35.349]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:35.349]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:35.349]                     }
[13:24:35.349]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:35.349]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:35.349]                       envir = envir)
[13:24:35.349]                     if (!future$lazy) 
[13:24:35.349]                       future <- run(future)
[13:24:35.349]                     invisible(future)
[13:24:35.349]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:35.349]                 }
[13:24:35.349]             }
[13:24:35.349]         }
[13:24:35.349]     })
[13:24:35.349]     if (TRUE) {
[13:24:35.349]         base::sink(type = "output", split = FALSE)
[13:24:35.349]         if (TRUE) {
[13:24:35.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:35.349]         }
[13:24:35.349]         else {
[13:24:35.349]             ...future.result["stdout"] <- base::list(NULL)
[13:24:35.349]         }
[13:24:35.349]         base::close(...future.stdout)
[13:24:35.349]         ...future.stdout <- NULL
[13:24:35.349]     }
[13:24:35.349]     ...future.result$conditions <- ...future.conditions
[13:24:35.349]     ...future.result$finished <- base::Sys.time()
[13:24:35.349]     ...future.result
[13:24:35.349] }
[13:24:35.353] MultisessionFuture started
[13:24:35.353] - Launch lazy future ... done
[13:24:35.353] run() for ‘MultisessionFuture’ ... done
[13:24:35.912] receiveMessageFromWorker() for ClusterFuture ...
[13:24:35.912] - Validating connection of MultisessionFuture
[13:24:35.912] - received message: FutureResult
[13:24:35.912] - Received FutureResult
[13:24:35.913] - Erased future from FutureRegistry
[13:24:35.913] result() for ClusterFuture ...
[13:24:35.913] - result already collected: FutureResult
[13:24:35.913] result() for ClusterFuture ... done
[13:24:35.913] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:35.913] resolve() on list ...
[13:24:35.913]  recursive: 98
[13:24:35.913]  length: 2
[13:24:35.914]  elements: ‘a’, ‘b’
[13:24:35.914]  length: 1 (resolved future 1)
[13:24:35.914]  length: 0 (resolved future 2)
[13:24:35.914] resolve() on list ... DONE
[13:24:35.914] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:24:35.914] getGlobalsAndPackages() ...
[13:24:35.914] Searching for globals...
[13:24:35.915] - globals found: [2] ‘list’, ‘stop’
[13:24:35.915] Searching for globals ... DONE
[13:24:35.915] Resolving globals: FALSE
[13:24:35.915] 
[13:24:35.916] 
[13:24:35.916] getGlobalsAndPackages() ... DONE
[13:24:35.916] run() for ‘Future’ ...
[13:24:35.916] - state: ‘created’
[13:24:35.916] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:35.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:35.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:35.931]   - Field: ‘node’
[13:24:35.931]   - Field: ‘label’
[13:24:35.931]   - Field: ‘local’
[13:24:35.931]   - Field: ‘owner’
[13:24:35.931]   - Field: ‘envir’
[13:24:35.931]   - Field: ‘workers’
[13:24:35.931]   - Field: ‘packages’
[13:24:35.931]   - Field: ‘gc’
[13:24:35.932]   - Field: ‘conditions’
[13:24:35.932]   - Field: ‘persistent’
[13:24:35.932]   - Field: ‘expr’
[13:24:35.932]   - Field: ‘uuid’
[13:24:35.932]   - Field: ‘seed’
[13:24:35.932]   - Field: ‘version’
[13:24:35.932]   - Field: ‘result’
[13:24:35.932]   - Field: ‘asynchronous’
[13:24:35.932]   - Field: ‘calls’
[13:24:35.932]   - Field: ‘globals’
[13:24:35.933]   - Field: ‘stdout’
[13:24:35.933]   - Field: ‘earlySignal’
[13:24:35.933]   - Field: ‘lazy’
[13:24:35.933]   - Field: ‘state’
[13:24:35.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:35.933] - Launch lazy future ...
[13:24:35.933] Packages needed by the future expression (n = 0): <none>
[13:24:35.933] Packages needed by future strategies (n = 0): <none>
[13:24:35.934] {
[13:24:35.934]     {
[13:24:35.934]         {
[13:24:35.934]             ...future.startTime <- base::Sys.time()
[13:24:35.934]             {
[13:24:35.934]                 {
[13:24:35.934]                   {
[13:24:35.934]                     {
[13:24:35.934]                       base::local({
[13:24:35.934]                         has_future <- base::requireNamespace("future", 
[13:24:35.934]                           quietly = TRUE)
[13:24:35.934]                         if (has_future) {
[13:24:35.934]                           ns <- base::getNamespace("future")
[13:24:35.934]                           version <- ns[[".package"]][["version"]]
[13:24:35.934]                           if (is.null(version)) 
[13:24:35.934]                             version <- utils::packageVersion("future")
[13:24:35.934]                         }
[13:24:35.934]                         else {
[13:24:35.934]                           version <- NULL
[13:24:35.934]                         }
[13:24:35.934]                         if (!has_future || version < "1.8.0") {
[13:24:35.934]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:35.934]                             "", base::R.version$version.string), 
[13:24:35.934]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:35.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:35.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:35.934]                               "release", "version")], collapse = " "), 
[13:24:35.934]                             hostname = base::Sys.info()[["nodename"]])
[13:24:35.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:35.934]                             info)
[13:24:35.934]                           info <- base::paste(info, collapse = "; ")
[13:24:35.934]                           if (!has_future) {
[13:24:35.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:35.934]                               info)
[13:24:35.934]                           }
[13:24:35.934]                           else {
[13:24:35.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:35.934]                               info, version)
[13:24:35.934]                           }
[13:24:35.934]                           base::stop(msg)
[13:24:35.934]                         }
[13:24:35.934]                       })
[13:24:35.934]                     }
[13:24:35.934]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:35.934]                     base::options(mc.cores = 1L)
[13:24:35.934]                   }
[13:24:35.934]                   options(future.plan = NULL)
[13:24:35.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:35.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:35.934]                 }
[13:24:35.934]                 ...future.workdir <- getwd()
[13:24:35.934]             }
[13:24:35.934]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:35.934]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:35.934]         }
[13:24:35.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:35.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:35.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:35.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:35.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:35.934]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:35.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:35.934]             base::names(...future.oldOptions))
[13:24:35.934]     }
[13:24:35.934]     if (FALSE) {
[13:24:35.934]     }
[13:24:35.934]     else {
[13:24:35.934]         if (TRUE) {
[13:24:35.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:35.934]                 open = "w")
[13:24:35.934]         }
[13:24:35.934]         else {
[13:24:35.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:35.934]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:35.934]         }
[13:24:35.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:35.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:35.934]             base::sink(type = "output", split = FALSE)
[13:24:35.934]             base::close(...future.stdout)
[13:24:35.934]         }, add = TRUE)
[13:24:35.934]     }
[13:24:35.934]     ...future.frame <- base::sys.nframe()
[13:24:35.934]     ...future.conditions <- base::list()
[13:24:35.934]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:35.934]     if (FALSE) {
[13:24:35.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:35.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:35.934]     }
[13:24:35.934]     ...future.result <- base::tryCatch({
[13:24:35.934]         base::withCallingHandlers({
[13:24:35.934]             ...future.value <- base::withVisible(base::local({
[13:24:35.934]                 ...future.makeSendCondition <- base::local({
[13:24:35.934]                   sendCondition <- NULL
[13:24:35.934]                   function(frame = 1L) {
[13:24:35.934]                     if (is.function(sendCondition)) 
[13:24:35.934]                       return(sendCondition)
[13:24:35.934]                     ns <- getNamespace("parallel")
[13:24:35.934]                     if (exists("sendData", mode = "function", 
[13:24:35.934]                       envir = ns)) {
[13:24:35.934]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:35.934]                         envir = ns)
[13:24:35.934]                       envir <- sys.frame(frame)
[13:24:35.934]                       master <- NULL
[13:24:35.934]                       while (!identical(envir, .GlobalEnv) && 
[13:24:35.934]                         !identical(envir, emptyenv())) {
[13:24:35.934]                         if (exists("master", mode = "list", envir = envir, 
[13:24:35.934]                           inherits = FALSE)) {
[13:24:35.934]                           master <- get("master", mode = "list", 
[13:24:35.934]                             envir = envir, inherits = FALSE)
[13:24:35.934]                           if (inherits(master, c("SOCKnode", 
[13:24:35.934]                             "SOCK0node"))) {
[13:24:35.934]                             sendCondition <<- function(cond) {
[13:24:35.934]                               data <- list(type = "VALUE", value = cond, 
[13:24:35.934]                                 success = TRUE)
[13:24:35.934]                               parallel_sendData(master, data)
[13:24:35.934]                             }
[13:24:35.934]                             return(sendCondition)
[13:24:35.934]                           }
[13:24:35.934]                         }
[13:24:35.934]                         frame <- frame + 1L
[13:24:35.934]                         envir <- sys.frame(frame)
[13:24:35.934]                       }
[13:24:35.934]                     }
[13:24:35.934]                     sendCondition <<- function(cond) NULL
[13:24:35.934]                   }
[13:24:35.934]                 })
[13:24:35.934]                 withCallingHandlers({
[13:24:35.934]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:35.934]                 }, immediateCondition = function(cond) {
[13:24:35.934]                   sendCondition <- ...future.makeSendCondition()
[13:24:35.934]                   sendCondition(cond)
[13:24:35.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:35.934]                   {
[13:24:35.934]                     inherits <- base::inherits
[13:24:35.934]                     invokeRestart <- base::invokeRestart
[13:24:35.934]                     is.null <- base::is.null
[13:24:35.934]                     muffled <- FALSE
[13:24:35.934]                     if (inherits(cond, "message")) {
[13:24:35.934]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:35.934]                       if (muffled) 
[13:24:35.934]                         invokeRestart("muffleMessage")
[13:24:35.934]                     }
[13:24:35.934]                     else if (inherits(cond, "warning")) {
[13:24:35.934]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:35.934]                       if (muffled) 
[13:24:35.934]                         invokeRestart("muffleWarning")
[13:24:35.934]                     }
[13:24:35.934]                     else if (inherits(cond, "condition")) {
[13:24:35.934]                       if (!is.null(pattern)) {
[13:24:35.934]                         computeRestarts <- base::computeRestarts
[13:24:35.934]                         grepl <- base::grepl
[13:24:35.934]                         restarts <- computeRestarts(cond)
[13:24:35.934]                         for (restart in restarts) {
[13:24:35.934]                           name <- restart$name
[13:24:35.934]                           if (is.null(name)) 
[13:24:35.934]                             next
[13:24:35.934]                           if (!grepl(pattern, name)) 
[13:24:35.934]                             next
[13:24:35.934]                           invokeRestart(restart)
[13:24:35.934]                           muffled <- TRUE
[13:24:35.934]                           break
[13:24:35.934]                         }
[13:24:35.934]                       }
[13:24:35.934]                     }
[13:24:35.934]                     invisible(muffled)
[13:24:35.934]                   }
[13:24:35.934]                   muffleCondition(cond)
[13:24:35.934]                 })
[13:24:35.934]             }))
[13:24:35.934]             future::FutureResult(value = ...future.value$value, 
[13:24:35.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:35.934]                   ...future.rng), globalenv = if (FALSE) 
[13:24:35.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:35.934]                     ...future.globalenv.names))
[13:24:35.934]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:35.934]         }, condition = base::local({
[13:24:35.934]             c <- base::c
[13:24:35.934]             inherits <- base::inherits
[13:24:35.934]             invokeRestart <- base::invokeRestart
[13:24:35.934]             length <- base::length
[13:24:35.934]             list <- base::list
[13:24:35.934]             seq.int <- base::seq.int
[13:24:35.934]             signalCondition <- base::signalCondition
[13:24:35.934]             sys.calls <- base::sys.calls
[13:24:35.934]             `[[` <- base::`[[`
[13:24:35.934]             `+` <- base::`+`
[13:24:35.934]             `<<-` <- base::`<<-`
[13:24:35.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:35.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:35.934]                   3L)]
[13:24:35.934]             }
[13:24:35.934]             function(cond) {
[13:24:35.934]                 is_error <- inherits(cond, "error")
[13:24:35.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:35.934]                   NULL)
[13:24:35.934]                 if (is_error) {
[13:24:35.934]                   sessionInformation <- function() {
[13:24:35.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:35.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:35.934]                       search = base::search(), system = base::Sys.info())
[13:24:35.934]                   }
[13:24:35.934]                   ...future.conditions[[length(...future.conditions) + 
[13:24:35.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:35.934]                     cond$call), session = sessionInformation(), 
[13:24:35.934]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:35.934]                   signalCondition(cond)
[13:24:35.934]                 }
[13:24:35.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:35.934]                 "immediateCondition"))) {
[13:24:35.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:35.934]                   ...future.conditions[[length(...future.conditions) + 
[13:24:35.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:35.934]                   if (TRUE && !signal) {
[13:24:35.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:35.934]                     {
[13:24:35.934]                       inherits <- base::inherits
[13:24:35.934]                       invokeRestart <- base::invokeRestart
[13:24:35.934]                       is.null <- base::is.null
[13:24:35.934]                       muffled <- FALSE
[13:24:35.934]                       if (inherits(cond, "message")) {
[13:24:35.934]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:35.934]                         if (muffled) 
[13:24:35.934]                           invokeRestart("muffleMessage")
[13:24:35.934]                       }
[13:24:35.934]                       else if (inherits(cond, "warning")) {
[13:24:35.934]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:35.934]                         if (muffled) 
[13:24:35.934]                           invokeRestart("muffleWarning")
[13:24:35.934]                       }
[13:24:35.934]                       else if (inherits(cond, "condition")) {
[13:24:35.934]                         if (!is.null(pattern)) {
[13:24:35.934]                           computeRestarts <- base::computeRestarts
[13:24:35.934]                           grepl <- base::grepl
[13:24:35.934]                           restarts <- computeRestarts(cond)
[13:24:35.934]                           for (restart in restarts) {
[13:24:35.934]                             name <- restart$name
[13:24:35.934]                             if (is.null(name)) 
[13:24:35.934]                               next
[13:24:35.934]                             if (!grepl(pattern, name)) 
[13:24:35.934]                               next
[13:24:35.934]                             invokeRestart(restart)
[13:24:35.934]                             muffled <- TRUE
[13:24:35.934]                             break
[13:24:35.934]                           }
[13:24:35.934]                         }
[13:24:35.934]                       }
[13:24:35.934]                       invisible(muffled)
[13:24:35.934]                     }
[13:24:35.934]                     muffleCondition(cond, pattern = "^muffle")
[13:24:35.934]                   }
[13:24:35.934]                 }
[13:24:35.934]                 else {
[13:24:35.934]                   if (TRUE) {
[13:24:35.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:35.934]                     {
[13:24:35.934]                       inherits <- base::inherits
[13:24:35.934]                       invokeRestart <- base::invokeRestart
[13:24:35.934]                       is.null <- base::is.null
[13:24:35.934]                       muffled <- FALSE
[13:24:35.934]                       if (inherits(cond, "message")) {
[13:24:35.934]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:35.934]                         if (muffled) 
[13:24:35.934]                           invokeRestart("muffleMessage")
[13:24:35.934]                       }
[13:24:35.934]                       else if (inherits(cond, "warning")) {
[13:24:35.934]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:35.934]                         if (muffled) 
[13:24:35.934]                           invokeRestart("muffleWarning")
[13:24:35.934]                       }
[13:24:35.934]                       else if (inherits(cond, "condition")) {
[13:24:35.934]                         if (!is.null(pattern)) {
[13:24:35.934]                           computeRestarts <- base::computeRestarts
[13:24:35.934]                           grepl <- base::grepl
[13:24:35.934]                           restarts <- computeRestarts(cond)
[13:24:35.934]                           for (restart in restarts) {
[13:24:35.934]                             name <- restart$name
[13:24:35.934]                             if (is.null(name)) 
[13:24:35.934]                               next
[13:24:35.934]                             if (!grepl(pattern, name)) 
[13:24:35.934]                               next
[13:24:35.934]                             invokeRestart(restart)
[13:24:35.934]                             muffled <- TRUE
[13:24:35.934]                             break
[13:24:35.934]                           }
[13:24:35.934]                         }
[13:24:35.934]                       }
[13:24:35.934]                       invisible(muffled)
[13:24:35.934]                     }
[13:24:35.934]                     muffleCondition(cond, pattern = "^muffle")
[13:24:35.934]                   }
[13:24:35.934]                 }
[13:24:35.934]             }
[13:24:35.934]         }))
[13:24:35.934]     }, error = function(ex) {
[13:24:35.934]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:35.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:35.934]                 ...future.rng), started = ...future.startTime, 
[13:24:35.934]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:35.934]             version = "1.8"), class = "FutureResult")
[13:24:35.934]     }, finally = {
[13:24:35.934]         if (!identical(...future.workdir, getwd())) 
[13:24:35.934]             setwd(...future.workdir)
[13:24:35.934]         {
[13:24:35.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:35.934]                 ...future.oldOptions$nwarnings <- NULL
[13:24:35.934]             }
[13:24:35.934]             base::options(...future.oldOptions)
[13:24:35.934]             if (.Platform$OS.type == "windows") {
[13:24:35.934]                 old_names <- names(...future.oldEnvVars)
[13:24:35.934]                 envs <- base::Sys.getenv()
[13:24:35.934]                 names <- names(envs)
[13:24:35.934]                 common <- intersect(names, old_names)
[13:24:35.934]                 added <- setdiff(names, old_names)
[13:24:35.934]                 removed <- setdiff(old_names, names)
[13:24:35.934]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:35.934]                   envs[common]]
[13:24:35.934]                 NAMES <- toupper(changed)
[13:24:35.934]                 args <- list()
[13:24:35.934]                 for (kk in seq_along(NAMES)) {
[13:24:35.934]                   name <- changed[[kk]]
[13:24:35.934]                   NAME <- NAMES[[kk]]
[13:24:35.934]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:35.934]                     next
[13:24:35.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:35.934]                 }
[13:24:35.934]                 NAMES <- toupper(added)
[13:24:35.934]                 for (kk in seq_along(NAMES)) {
[13:24:35.934]                   name <- added[[kk]]
[13:24:35.934]                   NAME <- NAMES[[kk]]
[13:24:35.934]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:35.934]                     next
[13:24:35.934]                   args[[name]] <- ""
[13:24:35.934]                 }
[13:24:35.934]                 NAMES <- toupper(removed)
[13:24:35.934]                 for (kk in seq_along(NAMES)) {
[13:24:35.934]                   name <- removed[[kk]]
[13:24:35.934]                   NAME <- NAMES[[kk]]
[13:24:35.934]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:35.934]                     next
[13:24:35.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:35.934]                 }
[13:24:35.934]                 if (length(args) > 0) 
[13:24:35.934]                   base::do.call(base::Sys.setenv, args = args)
[13:24:35.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:35.934]             }
[13:24:35.934]             else {
[13:24:35.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:35.934]             }
[13:24:35.934]             {
[13:24:35.934]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:35.934]                   0L) {
[13:24:35.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:35.934]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:35.934]                   base::options(opts)
[13:24:35.934]                 }
[13:24:35.934]                 {
[13:24:35.934]                   {
[13:24:35.934]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:35.934]                     NULL
[13:24:35.934]                   }
[13:24:35.934]                   options(future.plan = NULL)
[13:24:35.934]                   if (is.na(NA_character_)) 
[13:24:35.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:35.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:35.934]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:35.934]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:35.934]                     envir = parent.frame()) 
[13:24:35.934]                   {
[13:24:35.934]                     if (is.function(workers)) 
[13:24:35.934]                       workers <- workers()
[13:24:35.934]                     workers <- structure(as.integer(workers), 
[13:24:35.934]                       class = class(workers))
[13:24:35.934]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:35.934]                       workers >= 1)
[13:24:35.934]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:35.934]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:35.934]                     }
[13:24:35.934]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:35.934]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:35.934]                       envir = envir)
[13:24:35.934]                     if (!future$lazy) 
[13:24:35.934]                       future <- run(future)
[13:24:35.934]                     invisible(future)
[13:24:35.934]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:35.934]                 }
[13:24:35.934]             }
[13:24:35.934]         }
[13:24:35.934]     })
[13:24:35.934]     if (TRUE) {
[13:24:35.934]         base::sink(type = "output", split = FALSE)
[13:24:35.934]         if (TRUE) {
[13:24:35.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:35.934]         }
[13:24:35.934]         else {
[13:24:35.934]             ...future.result["stdout"] <- base::list(NULL)
[13:24:35.934]         }
[13:24:35.934]         base::close(...future.stdout)
[13:24:35.934]         ...future.stdout <- NULL
[13:24:35.934]     }
[13:24:35.934]     ...future.result$conditions <- ...future.conditions
[13:24:35.934]     ...future.result$finished <- base::Sys.time()
[13:24:35.934]     ...future.result
[13:24:35.934] }
[13:24:35.937] MultisessionFuture started
[13:24:35.937] - Launch lazy future ... done
[13:24:35.937] run() for ‘MultisessionFuture’ ... done
[13:24:35.985] receiveMessageFromWorker() for ClusterFuture ...
[13:24:35.985] - Validating connection of MultisessionFuture
[13:24:35.986] - received message: FutureResult
[13:24:35.986] - Received FutureResult
[13:24:35.986] - Erased future from FutureRegistry
[13:24:35.986] result() for ClusterFuture ...
[13:24:35.986] - result already collected: FutureResult
[13:24:35.986] result() for ClusterFuture ... done
[13:24:35.986] signalConditions() ...
[13:24:35.986]  - include = ‘immediateCondition’
[13:24:35.986]  - exclude = 
[13:24:35.987]  - resignal = FALSE
[13:24:35.987]  - Number of conditions: 1
[13:24:35.987] signalConditions() ... done
[13:24:35.987] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:35.987] A MultisessionFuture was resolved
[13:24:35.987] getGlobalsAndPackages() ...
[13:24:35.987] Searching for globals...
[13:24:35.988] - globals found: [2] ‘list’, ‘stop’
[13:24:35.988] Searching for globals ... DONE
[13:24:35.988] Resolving globals: FALSE
[13:24:35.988] 
[13:24:35.989] 
[13:24:35.989] getGlobalsAndPackages() ... DONE
[13:24:35.989] run() for ‘Future’ ...
[13:24:35.989] - state: ‘created’
[13:24:35.989] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:36.003] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:36.004] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:36.004]   - Field: ‘node’
[13:24:36.004]   - Field: ‘label’
[13:24:36.004]   - Field: ‘local’
[13:24:36.004]   - Field: ‘owner’
[13:24:36.004]   - Field: ‘envir’
[13:24:36.004]   - Field: ‘workers’
[13:24:36.004]   - Field: ‘packages’
[13:24:36.005]   - Field: ‘gc’
[13:24:36.005]   - Field: ‘conditions’
[13:24:36.005]   - Field: ‘persistent’
[13:24:36.005]   - Field: ‘expr’
[13:24:36.005]   - Field: ‘uuid’
[13:24:36.005]   - Field: ‘seed’
[13:24:36.005]   - Field: ‘version’
[13:24:36.005]   - Field: ‘result’
[13:24:36.005]   - Field: ‘asynchronous’
[13:24:36.005]   - Field: ‘calls’
[13:24:36.005]   - Field: ‘globals’
[13:24:36.006]   - Field: ‘stdout’
[13:24:36.006]   - Field: ‘earlySignal’
[13:24:36.006]   - Field: ‘lazy’
[13:24:36.006]   - Field: ‘state’
[13:24:36.006] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:36.006] - Launch lazy future ...
[13:24:36.006] Packages needed by the future expression (n = 0): <none>
[13:24:36.006] Packages needed by future strategies (n = 0): <none>
[13:24:36.007] {
[13:24:36.007]     {
[13:24:36.007]         {
[13:24:36.007]             ...future.startTime <- base::Sys.time()
[13:24:36.007]             {
[13:24:36.007]                 {
[13:24:36.007]                   {
[13:24:36.007]                     {
[13:24:36.007]                       base::local({
[13:24:36.007]                         has_future <- base::requireNamespace("future", 
[13:24:36.007]                           quietly = TRUE)
[13:24:36.007]                         if (has_future) {
[13:24:36.007]                           ns <- base::getNamespace("future")
[13:24:36.007]                           version <- ns[[".package"]][["version"]]
[13:24:36.007]                           if (is.null(version)) 
[13:24:36.007]                             version <- utils::packageVersion("future")
[13:24:36.007]                         }
[13:24:36.007]                         else {
[13:24:36.007]                           version <- NULL
[13:24:36.007]                         }
[13:24:36.007]                         if (!has_future || version < "1.8.0") {
[13:24:36.007]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:36.007]                             "", base::R.version$version.string), 
[13:24:36.007]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:36.007]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:36.007]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:36.007]                               "release", "version")], collapse = " "), 
[13:24:36.007]                             hostname = base::Sys.info()[["nodename"]])
[13:24:36.007]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:36.007]                             info)
[13:24:36.007]                           info <- base::paste(info, collapse = "; ")
[13:24:36.007]                           if (!has_future) {
[13:24:36.007]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:36.007]                               info)
[13:24:36.007]                           }
[13:24:36.007]                           else {
[13:24:36.007]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:36.007]                               info, version)
[13:24:36.007]                           }
[13:24:36.007]                           base::stop(msg)
[13:24:36.007]                         }
[13:24:36.007]                       })
[13:24:36.007]                     }
[13:24:36.007]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:36.007]                     base::options(mc.cores = 1L)
[13:24:36.007]                   }
[13:24:36.007]                   options(future.plan = NULL)
[13:24:36.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:36.007]                 }
[13:24:36.007]                 ...future.workdir <- getwd()
[13:24:36.007]             }
[13:24:36.007]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:36.007]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:36.007]         }
[13:24:36.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:36.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:36.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:36.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:36.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:36.007]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:36.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:36.007]             base::names(...future.oldOptions))
[13:24:36.007]     }
[13:24:36.007]     if (FALSE) {
[13:24:36.007]     }
[13:24:36.007]     else {
[13:24:36.007]         if (TRUE) {
[13:24:36.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:36.007]                 open = "w")
[13:24:36.007]         }
[13:24:36.007]         else {
[13:24:36.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:36.007]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:36.007]         }
[13:24:36.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:36.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:36.007]             base::sink(type = "output", split = FALSE)
[13:24:36.007]             base::close(...future.stdout)
[13:24:36.007]         }, add = TRUE)
[13:24:36.007]     }
[13:24:36.007]     ...future.frame <- base::sys.nframe()
[13:24:36.007]     ...future.conditions <- base::list()
[13:24:36.007]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:36.007]     if (FALSE) {
[13:24:36.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:36.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:36.007]     }
[13:24:36.007]     ...future.result <- base::tryCatch({
[13:24:36.007]         base::withCallingHandlers({
[13:24:36.007]             ...future.value <- base::withVisible(base::local({
[13:24:36.007]                 ...future.makeSendCondition <- base::local({
[13:24:36.007]                   sendCondition <- NULL
[13:24:36.007]                   function(frame = 1L) {
[13:24:36.007]                     if (is.function(sendCondition)) 
[13:24:36.007]                       return(sendCondition)
[13:24:36.007]                     ns <- getNamespace("parallel")
[13:24:36.007]                     if (exists("sendData", mode = "function", 
[13:24:36.007]                       envir = ns)) {
[13:24:36.007]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:36.007]                         envir = ns)
[13:24:36.007]                       envir <- sys.frame(frame)
[13:24:36.007]                       master <- NULL
[13:24:36.007]                       while (!identical(envir, .GlobalEnv) && 
[13:24:36.007]                         !identical(envir, emptyenv())) {
[13:24:36.007]                         if (exists("master", mode = "list", envir = envir, 
[13:24:36.007]                           inherits = FALSE)) {
[13:24:36.007]                           master <- get("master", mode = "list", 
[13:24:36.007]                             envir = envir, inherits = FALSE)
[13:24:36.007]                           if (inherits(master, c("SOCKnode", 
[13:24:36.007]                             "SOCK0node"))) {
[13:24:36.007]                             sendCondition <<- function(cond) {
[13:24:36.007]                               data <- list(type = "VALUE", value = cond, 
[13:24:36.007]                                 success = TRUE)
[13:24:36.007]                               parallel_sendData(master, data)
[13:24:36.007]                             }
[13:24:36.007]                             return(sendCondition)
[13:24:36.007]                           }
[13:24:36.007]                         }
[13:24:36.007]                         frame <- frame + 1L
[13:24:36.007]                         envir <- sys.frame(frame)
[13:24:36.007]                       }
[13:24:36.007]                     }
[13:24:36.007]                     sendCondition <<- function(cond) NULL
[13:24:36.007]                   }
[13:24:36.007]                 })
[13:24:36.007]                 withCallingHandlers({
[13:24:36.007]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:36.007]                 }, immediateCondition = function(cond) {
[13:24:36.007]                   sendCondition <- ...future.makeSendCondition()
[13:24:36.007]                   sendCondition(cond)
[13:24:36.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.007]                   {
[13:24:36.007]                     inherits <- base::inherits
[13:24:36.007]                     invokeRestart <- base::invokeRestart
[13:24:36.007]                     is.null <- base::is.null
[13:24:36.007]                     muffled <- FALSE
[13:24:36.007]                     if (inherits(cond, "message")) {
[13:24:36.007]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:36.007]                       if (muffled) 
[13:24:36.007]                         invokeRestart("muffleMessage")
[13:24:36.007]                     }
[13:24:36.007]                     else if (inherits(cond, "warning")) {
[13:24:36.007]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:36.007]                       if (muffled) 
[13:24:36.007]                         invokeRestart("muffleWarning")
[13:24:36.007]                     }
[13:24:36.007]                     else if (inherits(cond, "condition")) {
[13:24:36.007]                       if (!is.null(pattern)) {
[13:24:36.007]                         computeRestarts <- base::computeRestarts
[13:24:36.007]                         grepl <- base::grepl
[13:24:36.007]                         restarts <- computeRestarts(cond)
[13:24:36.007]                         for (restart in restarts) {
[13:24:36.007]                           name <- restart$name
[13:24:36.007]                           if (is.null(name)) 
[13:24:36.007]                             next
[13:24:36.007]                           if (!grepl(pattern, name)) 
[13:24:36.007]                             next
[13:24:36.007]                           invokeRestart(restart)
[13:24:36.007]                           muffled <- TRUE
[13:24:36.007]                           break
[13:24:36.007]                         }
[13:24:36.007]                       }
[13:24:36.007]                     }
[13:24:36.007]                     invisible(muffled)
[13:24:36.007]                   }
[13:24:36.007]                   muffleCondition(cond)
[13:24:36.007]                 })
[13:24:36.007]             }))
[13:24:36.007]             future::FutureResult(value = ...future.value$value, 
[13:24:36.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.007]                   ...future.rng), globalenv = if (FALSE) 
[13:24:36.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:36.007]                     ...future.globalenv.names))
[13:24:36.007]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:36.007]         }, condition = base::local({
[13:24:36.007]             c <- base::c
[13:24:36.007]             inherits <- base::inherits
[13:24:36.007]             invokeRestart <- base::invokeRestart
[13:24:36.007]             length <- base::length
[13:24:36.007]             list <- base::list
[13:24:36.007]             seq.int <- base::seq.int
[13:24:36.007]             signalCondition <- base::signalCondition
[13:24:36.007]             sys.calls <- base::sys.calls
[13:24:36.007]             `[[` <- base::`[[`
[13:24:36.007]             `+` <- base::`+`
[13:24:36.007]             `<<-` <- base::`<<-`
[13:24:36.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:36.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:36.007]                   3L)]
[13:24:36.007]             }
[13:24:36.007]             function(cond) {
[13:24:36.007]                 is_error <- inherits(cond, "error")
[13:24:36.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:36.007]                   NULL)
[13:24:36.007]                 if (is_error) {
[13:24:36.007]                   sessionInformation <- function() {
[13:24:36.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:36.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:36.007]                       search = base::search(), system = base::Sys.info())
[13:24:36.007]                   }
[13:24:36.007]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:36.007]                     cond$call), session = sessionInformation(), 
[13:24:36.007]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:36.007]                   signalCondition(cond)
[13:24:36.007]                 }
[13:24:36.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:36.007]                 "immediateCondition"))) {
[13:24:36.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:36.007]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:36.007]                   if (TRUE && !signal) {
[13:24:36.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.007]                     {
[13:24:36.007]                       inherits <- base::inherits
[13:24:36.007]                       invokeRestart <- base::invokeRestart
[13:24:36.007]                       is.null <- base::is.null
[13:24:36.007]                       muffled <- FALSE
[13:24:36.007]                       if (inherits(cond, "message")) {
[13:24:36.007]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.007]                         if (muffled) 
[13:24:36.007]                           invokeRestart("muffleMessage")
[13:24:36.007]                       }
[13:24:36.007]                       else if (inherits(cond, "warning")) {
[13:24:36.007]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.007]                         if (muffled) 
[13:24:36.007]                           invokeRestart("muffleWarning")
[13:24:36.007]                       }
[13:24:36.007]                       else if (inherits(cond, "condition")) {
[13:24:36.007]                         if (!is.null(pattern)) {
[13:24:36.007]                           computeRestarts <- base::computeRestarts
[13:24:36.007]                           grepl <- base::grepl
[13:24:36.007]                           restarts <- computeRestarts(cond)
[13:24:36.007]                           for (restart in restarts) {
[13:24:36.007]                             name <- restart$name
[13:24:36.007]                             if (is.null(name)) 
[13:24:36.007]                               next
[13:24:36.007]                             if (!grepl(pattern, name)) 
[13:24:36.007]                               next
[13:24:36.007]                             invokeRestart(restart)
[13:24:36.007]                             muffled <- TRUE
[13:24:36.007]                             break
[13:24:36.007]                           }
[13:24:36.007]                         }
[13:24:36.007]                       }
[13:24:36.007]                       invisible(muffled)
[13:24:36.007]                     }
[13:24:36.007]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.007]                   }
[13:24:36.007]                 }
[13:24:36.007]                 else {
[13:24:36.007]                   if (TRUE) {
[13:24:36.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.007]                     {
[13:24:36.007]                       inherits <- base::inherits
[13:24:36.007]                       invokeRestart <- base::invokeRestart
[13:24:36.007]                       is.null <- base::is.null
[13:24:36.007]                       muffled <- FALSE
[13:24:36.007]                       if (inherits(cond, "message")) {
[13:24:36.007]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.007]                         if (muffled) 
[13:24:36.007]                           invokeRestart("muffleMessage")
[13:24:36.007]                       }
[13:24:36.007]                       else if (inherits(cond, "warning")) {
[13:24:36.007]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.007]                         if (muffled) 
[13:24:36.007]                           invokeRestart("muffleWarning")
[13:24:36.007]                       }
[13:24:36.007]                       else if (inherits(cond, "condition")) {
[13:24:36.007]                         if (!is.null(pattern)) {
[13:24:36.007]                           computeRestarts <- base::computeRestarts
[13:24:36.007]                           grepl <- base::grepl
[13:24:36.007]                           restarts <- computeRestarts(cond)
[13:24:36.007]                           for (restart in restarts) {
[13:24:36.007]                             name <- restart$name
[13:24:36.007]                             if (is.null(name)) 
[13:24:36.007]                               next
[13:24:36.007]                             if (!grepl(pattern, name)) 
[13:24:36.007]                               next
[13:24:36.007]                             invokeRestart(restart)
[13:24:36.007]                             muffled <- TRUE
[13:24:36.007]                             break
[13:24:36.007]                           }
[13:24:36.007]                         }
[13:24:36.007]                       }
[13:24:36.007]                       invisible(muffled)
[13:24:36.007]                     }
[13:24:36.007]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.007]                   }
[13:24:36.007]                 }
[13:24:36.007]             }
[13:24:36.007]         }))
[13:24:36.007]     }, error = function(ex) {
[13:24:36.007]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:36.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.007]                 ...future.rng), started = ...future.startTime, 
[13:24:36.007]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:36.007]             version = "1.8"), class = "FutureResult")
[13:24:36.007]     }, finally = {
[13:24:36.007]         if (!identical(...future.workdir, getwd())) 
[13:24:36.007]             setwd(...future.workdir)
[13:24:36.007]         {
[13:24:36.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:36.007]                 ...future.oldOptions$nwarnings <- NULL
[13:24:36.007]             }
[13:24:36.007]             base::options(...future.oldOptions)
[13:24:36.007]             if (.Platform$OS.type == "windows") {
[13:24:36.007]                 old_names <- names(...future.oldEnvVars)
[13:24:36.007]                 envs <- base::Sys.getenv()
[13:24:36.007]                 names <- names(envs)
[13:24:36.007]                 common <- intersect(names, old_names)
[13:24:36.007]                 added <- setdiff(names, old_names)
[13:24:36.007]                 removed <- setdiff(old_names, names)
[13:24:36.007]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:36.007]                   envs[common]]
[13:24:36.007]                 NAMES <- toupper(changed)
[13:24:36.007]                 args <- list()
[13:24:36.007]                 for (kk in seq_along(NAMES)) {
[13:24:36.007]                   name <- changed[[kk]]
[13:24:36.007]                   NAME <- NAMES[[kk]]
[13:24:36.007]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.007]                     next
[13:24:36.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.007]                 }
[13:24:36.007]                 NAMES <- toupper(added)
[13:24:36.007]                 for (kk in seq_along(NAMES)) {
[13:24:36.007]                   name <- added[[kk]]
[13:24:36.007]                   NAME <- NAMES[[kk]]
[13:24:36.007]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.007]                     next
[13:24:36.007]                   args[[name]] <- ""
[13:24:36.007]                 }
[13:24:36.007]                 NAMES <- toupper(removed)
[13:24:36.007]                 for (kk in seq_along(NAMES)) {
[13:24:36.007]                   name <- removed[[kk]]
[13:24:36.007]                   NAME <- NAMES[[kk]]
[13:24:36.007]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.007]                     next
[13:24:36.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.007]                 }
[13:24:36.007]                 if (length(args) > 0) 
[13:24:36.007]                   base::do.call(base::Sys.setenv, args = args)
[13:24:36.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:36.007]             }
[13:24:36.007]             else {
[13:24:36.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:36.007]             }
[13:24:36.007]             {
[13:24:36.007]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:36.007]                   0L) {
[13:24:36.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:36.007]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:36.007]                   base::options(opts)
[13:24:36.007]                 }
[13:24:36.007]                 {
[13:24:36.007]                   {
[13:24:36.007]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:36.007]                     NULL
[13:24:36.007]                   }
[13:24:36.007]                   options(future.plan = NULL)
[13:24:36.007]                   if (is.na(NA_character_)) 
[13:24:36.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:36.007]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:36.007]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:36.007]                     envir = parent.frame()) 
[13:24:36.007]                   {
[13:24:36.007]                     if (is.function(workers)) 
[13:24:36.007]                       workers <- workers()
[13:24:36.007]                     workers <- structure(as.integer(workers), 
[13:24:36.007]                       class = class(workers))
[13:24:36.007]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:36.007]                       workers >= 1)
[13:24:36.007]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:36.007]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:36.007]                     }
[13:24:36.007]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:36.007]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:36.007]                       envir = envir)
[13:24:36.007]                     if (!future$lazy) 
[13:24:36.007]                       future <- run(future)
[13:24:36.007]                     invisible(future)
[13:24:36.007]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:36.007]                 }
[13:24:36.007]             }
[13:24:36.007]         }
[13:24:36.007]     })
[13:24:36.007]     if (TRUE) {
[13:24:36.007]         base::sink(type = "output", split = FALSE)
[13:24:36.007]         if (TRUE) {
[13:24:36.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:36.007]         }
[13:24:36.007]         else {
[13:24:36.007]             ...future.result["stdout"] <- base::list(NULL)
[13:24:36.007]         }
[13:24:36.007]         base::close(...future.stdout)
[13:24:36.007]         ...future.stdout <- NULL
[13:24:36.007]     }
[13:24:36.007]     ...future.result$conditions <- ...future.conditions
[13:24:36.007]     ...future.result$finished <- base::Sys.time()
[13:24:36.007]     ...future.result
[13:24:36.007] }
[13:24:36.010] MultisessionFuture started
[13:24:36.010] - Launch lazy future ... done
[13:24:36.010] run() for ‘MultisessionFuture’ ... done
[13:24:36.057] receiveMessageFromWorker() for ClusterFuture ...
[13:24:36.057] - Validating connection of MultisessionFuture
[13:24:36.058] - received message: FutureResult
[13:24:36.058] - Received FutureResult
[13:24:36.058] - Erased future from FutureRegistry
[13:24:36.058] result() for ClusterFuture ...
[13:24:36.058] - result already collected: FutureResult
[13:24:36.059] result() for ClusterFuture ... done
[13:24:36.059] signalConditions() ...
[13:24:36.059]  - include = ‘immediateCondition’
[13:24:36.059]  - exclude = 
[13:24:36.059]  - resignal = FALSE
[13:24:36.059]  - Number of conditions: 1
[13:24:36.059] signalConditions() ... done
[13:24:36.059] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:36.059] A MultisessionFuture was resolved
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[13:24:36.060] getGlobalsAndPackages() ...
[13:24:36.060] Searching for globals...
[13:24:36.061] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:36.061] Searching for globals ... DONE
[13:24:36.061] Resolving globals: FALSE
[13:24:36.062] 
[13:24:36.062] 
[13:24:36.062] getGlobalsAndPackages() ... DONE
[13:24:36.062] run() for ‘Future’ ...
[13:24:36.062] - state: ‘created’
[13:24:36.062] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:36.076] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:36.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:36.076]   - Field: ‘node’
[13:24:36.076]   - Field: ‘label’
[13:24:36.077]   - Field: ‘local’
[13:24:36.077]   - Field: ‘owner’
[13:24:36.077]   - Field: ‘envir’
[13:24:36.077]   - Field: ‘workers’
[13:24:36.077]   - Field: ‘packages’
[13:24:36.077]   - Field: ‘gc’
[13:24:36.077]   - Field: ‘conditions’
[13:24:36.077]   - Field: ‘persistent’
[13:24:36.077]   - Field: ‘expr’
[13:24:36.077]   - Field: ‘uuid’
[13:24:36.077]   - Field: ‘seed’
[13:24:36.078]   - Field: ‘version’
[13:24:36.078]   - Field: ‘result’
[13:24:36.078]   - Field: ‘asynchronous’
[13:24:36.078]   - Field: ‘calls’
[13:24:36.078]   - Field: ‘globals’
[13:24:36.078]   - Field: ‘stdout’
[13:24:36.078]   - Field: ‘earlySignal’
[13:24:36.078]   - Field: ‘lazy’
[13:24:36.078]   - Field: ‘state’
[13:24:36.078] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:36.079] - Launch lazy future ...
[13:24:36.079] Packages needed by the future expression (n = 0): <none>
[13:24:36.079] Packages needed by future strategies (n = 0): <none>
[13:24:36.079] {
[13:24:36.079]     {
[13:24:36.079]         {
[13:24:36.079]             ...future.startTime <- base::Sys.time()
[13:24:36.079]             {
[13:24:36.079]                 {
[13:24:36.079]                   {
[13:24:36.079]                     {
[13:24:36.079]                       base::local({
[13:24:36.079]                         has_future <- base::requireNamespace("future", 
[13:24:36.079]                           quietly = TRUE)
[13:24:36.079]                         if (has_future) {
[13:24:36.079]                           ns <- base::getNamespace("future")
[13:24:36.079]                           version <- ns[[".package"]][["version"]]
[13:24:36.079]                           if (is.null(version)) 
[13:24:36.079]                             version <- utils::packageVersion("future")
[13:24:36.079]                         }
[13:24:36.079]                         else {
[13:24:36.079]                           version <- NULL
[13:24:36.079]                         }
[13:24:36.079]                         if (!has_future || version < "1.8.0") {
[13:24:36.079]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:36.079]                             "", base::R.version$version.string), 
[13:24:36.079]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:36.079]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:36.079]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:36.079]                               "release", "version")], collapse = " "), 
[13:24:36.079]                             hostname = base::Sys.info()[["nodename"]])
[13:24:36.079]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:36.079]                             info)
[13:24:36.079]                           info <- base::paste(info, collapse = "; ")
[13:24:36.079]                           if (!has_future) {
[13:24:36.079]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:36.079]                               info)
[13:24:36.079]                           }
[13:24:36.079]                           else {
[13:24:36.079]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:36.079]                               info, version)
[13:24:36.079]                           }
[13:24:36.079]                           base::stop(msg)
[13:24:36.079]                         }
[13:24:36.079]                       })
[13:24:36.079]                     }
[13:24:36.079]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:36.079]                     base::options(mc.cores = 1L)
[13:24:36.079]                   }
[13:24:36.079]                   options(future.plan = NULL)
[13:24:36.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:36.079]                 }
[13:24:36.079]                 ...future.workdir <- getwd()
[13:24:36.079]             }
[13:24:36.079]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:36.079]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:36.079]         }
[13:24:36.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:36.079]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:36.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:36.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:36.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:36.079]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:36.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:36.079]             base::names(...future.oldOptions))
[13:24:36.079]     }
[13:24:36.079]     if (FALSE) {
[13:24:36.079]     }
[13:24:36.079]     else {
[13:24:36.079]         if (TRUE) {
[13:24:36.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:36.079]                 open = "w")
[13:24:36.079]         }
[13:24:36.079]         else {
[13:24:36.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:36.079]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:36.079]         }
[13:24:36.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:36.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:36.079]             base::sink(type = "output", split = FALSE)
[13:24:36.079]             base::close(...future.stdout)
[13:24:36.079]         }, add = TRUE)
[13:24:36.079]     }
[13:24:36.079]     ...future.frame <- base::sys.nframe()
[13:24:36.079]     ...future.conditions <- base::list()
[13:24:36.079]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:36.079]     if (FALSE) {
[13:24:36.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:36.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:36.079]     }
[13:24:36.079]     ...future.result <- base::tryCatch({
[13:24:36.079]         base::withCallingHandlers({
[13:24:36.079]             ...future.value <- base::withVisible(base::local({
[13:24:36.079]                 ...future.makeSendCondition <- base::local({
[13:24:36.079]                   sendCondition <- NULL
[13:24:36.079]                   function(frame = 1L) {
[13:24:36.079]                     if (is.function(sendCondition)) 
[13:24:36.079]                       return(sendCondition)
[13:24:36.079]                     ns <- getNamespace("parallel")
[13:24:36.079]                     if (exists("sendData", mode = "function", 
[13:24:36.079]                       envir = ns)) {
[13:24:36.079]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:36.079]                         envir = ns)
[13:24:36.079]                       envir <- sys.frame(frame)
[13:24:36.079]                       master <- NULL
[13:24:36.079]                       while (!identical(envir, .GlobalEnv) && 
[13:24:36.079]                         !identical(envir, emptyenv())) {
[13:24:36.079]                         if (exists("master", mode = "list", envir = envir, 
[13:24:36.079]                           inherits = FALSE)) {
[13:24:36.079]                           master <- get("master", mode = "list", 
[13:24:36.079]                             envir = envir, inherits = FALSE)
[13:24:36.079]                           if (inherits(master, c("SOCKnode", 
[13:24:36.079]                             "SOCK0node"))) {
[13:24:36.079]                             sendCondition <<- function(cond) {
[13:24:36.079]                               data <- list(type = "VALUE", value = cond, 
[13:24:36.079]                                 success = TRUE)
[13:24:36.079]                               parallel_sendData(master, data)
[13:24:36.079]                             }
[13:24:36.079]                             return(sendCondition)
[13:24:36.079]                           }
[13:24:36.079]                         }
[13:24:36.079]                         frame <- frame + 1L
[13:24:36.079]                         envir <- sys.frame(frame)
[13:24:36.079]                       }
[13:24:36.079]                     }
[13:24:36.079]                     sendCondition <<- function(cond) NULL
[13:24:36.079]                   }
[13:24:36.079]                 })
[13:24:36.079]                 withCallingHandlers({
[13:24:36.079]                   {
[13:24:36.079]                     Sys.sleep(0.5)
[13:24:36.079]                     list(a = 1, b = 42L)
[13:24:36.079]                   }
[13:24:36.079]                 }, immediateCondition = function(cond) {
[13:24:36.079]                   sendCondition <- ...future.makeSendCondition()
[13:24:36.079]                   sendCondition(cond)
[13:24:36.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.079]                   {
[13:24:36.079]                     inherits <- base::inherits
[13:24:36.079]                     invokeRestart <- base::invokeRestart
[13:24:36.079]                     is.null <- base::is.null
[13:24:36.079]                     muffled <- FALSE
[13:24:36.079]                     if (inherits(cond, "message")) {
[13:24:36.079]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:36.079]                       if (muffled) 
[13:24:36.079]                         invokeRestart("muffleMessage")
[13:24:36.079]                     }
[13:24:36.079]                     else if (inherits(cond, "warning")) {
[13:24:36.079]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:36.079]                       if (muffled) 
[13:24:36.079]                         invokeRestart("muffleWarning")
[13:24:36.079]                     }
[13:24:36.079]                     else if (inherits(cond, "condition")) {
[13:24:36.079]                       if (!is.null(pattern)) {
[13:24:36.079]                         computeRestarts <- base::computeRestarts
[13:24:36.079]                         grepl <- base::grepl
[13:24:36.079]                         restarts <- computeRestarts(cond)
[13:24:36.079]                         for (restart in restarts) {
[13:24:36.079]                           name <- restart$name
[13:24:36.079]                           if (is.null(name)) 
[13:24:36.079]                             next
[13:24:36.079]                           if (!grepl(pattern, name)) 
[13:24:36.079]                             next
[13:24:36.079]                           invokeRestart(restart)
[13:24:36.079]                           muffled <- TRUE
[13:24:36.079]                           break
[13:24:36.079]                         }
[13:24:36.079]                       }
[13:24:36.079]                     }
[13:24:36.079]                     invisible(muffled)
[13:24:36.079]                   }
[13:24:36.079]                   muffleCondition(cond)
[13:24:36.079]                 })
[13:24:36.079]             }))
[13:24:36.079]             future::FutureResult(value = ...future.value$value, 
[13:24:36.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.079]                   ...future.rng), globalenv = if (FALSE) 
[13:24:36.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:36.079]                     ...future.globalenv.names))
[13:24:36.079]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:36.079]         }, condition = base::local({
[13:24:36.079]             c <- base::c
[13:24:36.079]             inherits <- base::inherits
[13:24:36.079]             invokeRestart <- base::invokeRestart
[13:24:36.079]             length <- base::length
[13:24:36.079]             list <- base::list
[13:24:36.079]             seq.int <- base::seq.int
[13:24:36.079]             signalCondition <- base::signalCondition
[13:24:36.079]             sys.calls <- base::sys.calls
[13:24:36.079]             `[[` <- base::`[[`
[13:24:36.079]             `+` <- base::`+`
[13:24:36.079]             `<<-` <- base::`<<-`
[13:24:36.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:36.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:36.079]                   3L)]
[13:24:36.079]             }
[13:24:36.079]             function(cond) {
[13:24:36.079]                 is_error <- inherits(cond, "error")
[13:24:36.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:36.079]                   NULL)
[13:24:36.079]                 if (is_error) {
[13:24:36.079]                   sessionInformation <- function() {
[13:24:36.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:36.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:36.079]                       search = base::search(), system = base::Sys.info())
[13:24:36.079]                   }
[13:24:36.079]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:36.079]                     cond$call), session = sessionInformation(), 
[13:24:36.079]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:36.079]                   signalCondition(cond)
[13:24:36.079]                 }
[13:24:36.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:36.079]                 "immediateCondition"))) {
[13:24:36.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:36.079]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:36.079]                   if (TRUE && !signal) {
[13:24:36.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.079]                     {
[13:24:36.079]                       inherits <- base::inherits
[13:24:36.079]                       invokeRestart <- base::invokeRestart
[13:24:36.079]                       is.null <- base::is.null
[13:24:36.079]                       muffled <- FALSE
[13:24:36.079]                       if (inherits(cond, "message")) {
[13:24:36.079]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.079]                         if (muffled) 
[13:24:36.079]                           invokeRestart("muffleMessage")
[13:24:36.079]                       }
[13:24:36.079]                       else if (inherits(cond, "warning")) {
[13:24:36.079]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.079]                         if (muffled) 
[13:24:36.079]                           invokeRestart("muffleWarning")
[13:24:36.079]                       }
[13:24:36.079]                       else if (inherits(cond, "condition")) {
[13:24:36.079]                         if (!is.null(pattern)) {
[13:24:36.079]                           computeRestarts <- base::computeRestarts
[13:24:36.079]                           grepl <- base::grepl
[13:24:36.079]                           restarts <- computeRestarts(cond)
[13:24:36.079]                           for (restart in restarts) {
[13:24:36.079]                             name <- restart$name
[13:24:36.079]                             if (is.null(name)) 
[13:24:36.079]                               next
[13:24:36.079]                             if (!grepl(pattern, name)) 
[13:24:36.079]                               next
[13:24:36.079]                             invokeRestart(restart)
[13:24:36.079]                             muffled <- TRUE
[13:24:36.079]                             break
[13:24:36.079]                           }
[13:24:36.079]                         }
[13:24:36.079]                       }
[13:24:36.079]                       invisible(muffled)
[13:24:36.079]                     }
[13:24:36.079]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.079]                   }
[13:24:36.079]                 }
[13:24:36.079]                 else {
[13:24:36.079]                   if (TRUE) {
[13:24:36.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.079]                     {
[13:24:36.079]                       inherits <- base::inherits
[13:24:36.079]                       invokeRestart <- base::invokeRestart
[13:24:36.079]                       is.null <- base::is.null
[13:24:36.079]                       muffled <- FALSE
[13:24:36.079]                       if (inherits(cond, "message")) {
[13:24:36.079]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.079]                         if (muffled) 
[13:24:36.079]                           invokeRestart("muffleMessage")
[13:24:36.079]                       }
[13:24:36.079]                       else if (inherits(cond, "warning")) {
[13:24:36.079]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.079]                         if (muffled) 
[13:24:36.079]                           invokeRestart("muffleWarning")
[13:24:36.079]                       }
[13:24:36.079]                       else if (inherits(cond, "condition")) {
[13:24:36.079]                         if (!is.null(pattern)) {
[13:24:36.079]                           computeRestarts <- base::computeRestarts
[13:24:36.079]                           grepl <- base::grepl
[13:24:36.079]                           restarts <- computeRestarts(cond)
[13:24:36.079]                           for (restart in restarts) {
[13:24:36.079]                             name <- restart$name
[13:24:36.079]                             if (is.null(name)) 
[13:24:36.079]                               next
[13:24:36.079]                             if (!grepl(pattern, name)) 
[13:24:36.079]                               next
[13:24:36.079]                             invokeRestart(restart)
[13:24:36.079]                             muffled <- TRUE
[13:24:36.079]                             break
[13:24:36.079]                           }
[13:24:36.079]                         }
[13:24:36.079]                       }
[13:24:36.079]                       invisible(muffled)
[13:24:36.079]                     }
[13:24:36.079]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.079]                   }
[13:24:36.079]                 }
[13:24:36.079]             }
[13:24:36.079]         }))
[13:24:36.079]     }, error = function(ex) {
[13:24:36.079]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:36.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.079]                 ...future.rng), started = ...future.startTime, 
[13:24:36.079]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:36.079]             version = "1.8"), class = "FutureResult")
[13:24:36.079]     }, finally = {
[13:24:36.079]         if (!identical(...future.workdir, getwd())) 
[13:24:36.079]             setwd(...future.workdir)
[13:24:36.079]         {
[13:24:36.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:36.079]                 ...future.oldOptions$nwarnings <- NULL
[13:24:36.079]             }
[13:24:36.079]             base::options(...future.oldOptions)
[13:24:36.079]             if (.Platform$OS.type == "windows") {
[13:24:36.079]                 old_names <- names(...future.oldEnvVars)
[13:24:36.079]                 envs <- base::Sys.getenv()
[13:24:36.079]                 names <- names(envs)
[13:24:36.079]                 common <- intersect(names, old_names)
[13:24:36.079]                 added <- setdiff(names, old_names)
[13:24:36.079]                 removed <- setdiff(old_names, names)
[13:24:36.079]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:36.079]                   envs[common]]
[13:24:36.079]                 NAMES <- toupper(changed)
[13:24:36.079]                 args <- list()
[13:24:36.079]                 for (kk in seq_along(NAMES)) {
[13:24:36.079]                   name <- changed[[kk]]
[13:24:36.079]                   NAME <- NAMES[[kk]]
[13:24:36.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.079]                     next
[13:24:36.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.079]                 }
[13:24:36.079]                 NAMES <- toupper(added)
[13:24:36.079]                 for (kk in seq_along(NAMES)) {
[13:24:36.079]                   name <- added[[kk]]
[13:24:36.079]                   NAME <- NAMES[[kk]]
[13:24:36.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.079]                     next
[13:24:36.079]                   args[[name]] <- ""
[13:24:36.079]                 }
[13:24:36.079]                 NAMES <- toupper(removed)
[13:24:36.079]                 for (kk in seq_along(NAMES)) {
[13:24:36.079]                   name <- removed[[kk]]
[13:24:36.079]                   NAME <- NAMES[[kk]]
[13:24:36.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.079]                     next
[13:24:36.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.079]                 }
[13:24:36.079]                 if (length(args) > 0) 
[13:24:36.079]                   base::do.call(base::Sys.setenv, args = args)
[13:24:36.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:36.079]             }
[13:24:36.079]             else {
[13:24:36.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:36.079]             }
[13:24:36.079]             {
[13:24:36.079]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:36.079]                   0L) {
[13:24:36.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:36.079]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:36.079]                   base::options(opts)
[13:24:36.079]                 }
[13:24:36.079]                 {
[13:24:36.079]                   {
[13:24:36.079]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:36.079]                     NULL
[13:24:36.079]                   }
[13:24:36.079]                   options(future.plan = NULL)
[13:24:36.079]                   if (is.na(NA_character_)) 
[13:24:36.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:36.079]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:36.079]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:36.079]                     envir = parent.frame()) 
[13:24:36.079]                   {
[13:24:36.079]                     if (is.function(workers)) 
[13:24:36.079]                       workers <- workers()
[13:24:36.079]                     workers <- structure(as.integer(workers), 
[13:24:36.079]                       class = class(workers))
[13:24:36.079]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:36.079]                       workers >= 1)
[13:24:36.079]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:36.079]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:36.079]                     }
[13:24:36.079]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:36.079]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:36.079]                       envir = envir)
[13:24:36.079]                     if (!future$lazy) 
[13:24:36.079]                       future <- run(future)
[13:24:36.079]                     invisible(future)
[13:24:36.079]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:36.079]                 }
[13:24:36.079]             }
[13:24:36.079]         }
[13:24:36.079]     })
[13:24:36.079]     if (TRUE) {
[13:24:36.079]         base::sink(type = "output", split = FALSE)
[13:24:36.079]         if (TRUE) {
[13:24:36.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:36.079]         }
[13:24:36.079]         else {
[13:24:36.079]             ...future.result["stdout"] <- base::list(NULL)
[13:24:36.079]         }
[13:24:36.079]         base::close(...future.stdout)
[13:24:36.079]         ...future.stdout <- NULL
[13:24:36.079]     }
[13:24:36.079]     ...future.result$conditions <- ...future.conditions
[13:24:36.079]     ...future.result$finished <- base::Sys.time()
[13:24:36.079]     ...future.result
[13:24:36.079] }
[13:24:36.083] MultisessionFuture started
[13:24:36.083] - Launch lazy future ... done
[13:24:36.083] run() for ‘MultisessionFuture’ ... done
[13:24:36.083] getGlobalsAndPackages() ...
[13:24:36.083] Searching for globals...
[13:24:36.084] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:36.085] Searching for globals ... DONE
[13:24:36.085] Resolving globals: FALSE
[13:24:36.085] 
[13:24:36.085] 
[13:24:36.085] getGlobalsAndPackages() ... DONE
- w/ exception ...
[13:24:36.086] getGlobalsAndPackages() ...
[13:24:36.086] Searching for globals...
[13:24:36.086] - globals found: [2] ‘list’, ‘stop’
[13:24:36.086] Searching for globals ... DONE
[13:24:36.086] Resolving globals: FALSE
[13:24:36.087] 
[13:24:36.087] 
[13:24:36.087] getGlobalsAndPackages() ... DONE
[13:24:36.087] run() for ‘Future’ ...
[13:24:36.087] - state: ‘created’
[13:24:36.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:36.101] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:36.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:36.101]   - Field: ‘node’
[13:24:36.101]   - Field: ‘label’
[13:24:36.102]   - Field: ‘local’
[13:24:36.102]   - Field: ‘owner’
[13:24:36.102]   - Field: ‘envir’
[13:24:36.102]   - Field: ‘workers’
[13:24:36.102]   - Field: ‘packages’
[13:24:36.102]   - Field: ‘gc’
[13:24:36.102]   - Field: ‘conditions’
[13:24:36.102]   - Field: ‘persistent’
[13:24:36.102]   - Field: ‘expr’
[13:24:36.102]   - Field: ‘uuid’
[13:24:36.102]   - Field: ‘seed’
[13:24:36.103]   - Field: ‘version’
[13:24:36.103]   - Field: ‘result’
[13:24:36.103]   - Field: ‘asynchronous’
[13:24:36.103]   - Field: ‘calls’
[13:24:36.103]   - Field: ‘globals’
[13:24:36.103]   - Field: ‘stdout’
[13:24:36.103]   - Field: ‘earlySignal’
[13:24:36.103]   - Field: ‘lazy’
[13:24:36.103]   - Field: ‘state’
[13:24:36.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:36.103] - Launch lazy future ...
[13:24:36.104] Packages needed by the future expression (n = 0): <none>
[13:24:36.104] Packages needed by future strategies (n = 0): <none>
[13:24:36.104] {
[13:24:36.104]     {
[13:24:36.104]         {
[13:24:36.104]             ...future.startTime <- base::Sys.time()
[13:24:36.104]             {
[13:24:36.104]                 {
[13:24:36.104]                   {
[13:24:36.104]                     {
[13:24:36.104]                       base::local({
[13:24:36.104]                         has_future <- base::requireNamespace("future", 
[13:24:36.104]                           quietly = TRUE)
[13:24:36.104]                         if (has_future) {
[13:24:36.104]                           ns <- base::getNamespace("future")
[13:24:36.104]                           version <- ns[[".package"]][["version"]]
[13:24:36.104]                           if (is.null(version)) 
[13:24:36.104]                             version <- utils::packageVersion("future")
[13:24:36.104]                         }
[13:24:36.104]                         else {
[13:24:36.104]                           version <- NULL
[13:24:36.104]                         }
[13:24:36.104]                         if (!has_future || version < "1.8.0") {
[13:24:36.104]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:36.104]                             "", base::R.version$version.string), 
[13:24:36.104]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:36.104]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:36.104]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:36.104]                               "release", "version")], collapse = " "), 
[13:24:36.104]                             hostname = base::Sys.info()[["nodename"]])
[13:24:36.104]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:36.104]                             info)
[13:24:36.104]                           info <- base::paste(info, collapse = "; ")
[13:24:36.104]                           if (!has_future) {
[13:24:36.104]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:36.104]                               info)
[13:24:36.104]                           }
[13:24:36.104]                           else {
[13:24:36.104]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:36.104]                               info, version)
[13:24:36.104]                           }
[13:24:36.104]                           base::stop(msg)
[13:24:36.104]                         }
[13:24:36.104]                       })
[13:24:36.104]                     }
[13:24:36.104]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:36.104]                     base::options(mc.cores = 1L)
[13:24:36.104]                   }
[13:24:36.104]                   options(future.plan = NULL)
[13:24:36.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:36.104]                 }
[13:24:36.104]                 ...future.workdir <- getwd()
[13:24:36.104]             }
[13:24:36.104]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:36.104]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:36.104]         }
[13:24:36.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:36.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:36.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:36.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:36.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:36.104]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:36.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:36.104]             base::names(...future.oldOptions))
[13:24:36.104]     }
[13:24:36.104]     if (FALSE) {
[13:24:36.104]     }
[13:24:36.104]     else {
[13:24:36.104]         if (TRUE) {
[13:24:36.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:36.104]                 open = "w")
[13:24:36.104]         }
[13:24:36.104]         else {
[13:24:36.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:36.104]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:36.104]         }
[13:24:36.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:36.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:36.104]             base::sink(type = "output", split = FALSE)
[13:24:36.104]             base::close(...future.stdout)
[13:24:36.104]         }, add = TRUE)
[13:24:36.104]     }
[13:24:36.104]     ...future.frame <- base::sys.nframe()
[13:24:36.104]     ...future.conditions <- base::list()
[13:24:36.104]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:36.104]     if (FALSE) {
[13:24:36.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:36.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:36.104]     }
[13:24:36.104]     ...future.result <- base::tryCatch({
[13:24:36.104]         base::withCallingHandlers({
[13:24:36.104]             ...future.value <- base::withVisible(base::local({
[13:24:36.104]                 ...future.makeSendCondition <- base::local({
[13:24:36.104]                   sendCondition <- NULL
[13:24:36.104]                   function(frame = 1L) {
[13:24:36.104]                     if (is.function(sendCondition)) 
[13:24:36.104]                       return(sendCondition)
[13:24:36.104]                     ns <- getNamespace("parallel")
[13:24:36.104]                     if (exists("sendData", mode = "function", 
[13:24:36.104]                       envir = ns)) {
[13:24:36.104]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:36.104]                         envir = ns)
[13:24:36.104]                       envir <- sys.frame(frame)
[13:24:36.104]                       master <- NULL
[13:24:36.104]                       while (!identical(envir, .GlobalEnv) && 
[13:24:36.104]                         !identical(envir, emptyenv())) {
[13:24:36.104]                         if (exists("master", mode = "list", envir = envir, 
[13:24:36.104]                           inherits = FALSE)) {
[13:24:36.104]                           master <- get("master", mode = "list", 
[13:24:36.104]                             envir = envir, inherits = FALSE)
[13:24:36.104]                           if (inherits(master, c("SOCKnode", 
[13:24:36.104]                             "SOCK0node"))) {
[13:24:36.104]                             sendCondition <<- function(cond) {
[13:24:36.104]                               data <- list(type = "VALUE", value = cond, 
[13:24:36.104]                                 success = TRUE)
[13:24:36.104]                               parallel_sendData(master, data)
[13:24:36.104]                             }
[13:24:36.104]                             return(sendCondition)
[13:24:36.104]                           }
[13:24:36.104]                         }
[13:24:36.104]                         frame <- frame + 1L
[13:24:36.104]                         envir <- sys.frame(frame)
[13:24:36.104]                       }
[13:24:36.104]                     }
[13:24:36.104]                     sendCondition <<- function(cond) NULL
[13:24:36.104]                   }
[13:24:36.104]                 })
[13:24:36.104]                 withCallingHandlers({
[13:24:36.104]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:36.104]                 }, immediateCondition = function(cond) {
[13:24:36.104]                   sendCondition <- ...future.makeSendCondition()
[13:24:36.104]                   sendCondition(cond)
[13:24:36.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.104]                   {
[13:24:36.104]                     inherits <- base::inherits
[13:24:36.104]                     invokeRestart <- base::invokeRestart
[13:24:36.104]                     is.null <- base::is.null
[13:24:36.104]                     muffled <- FALSE
[13:24:36.104]                     if (inherits(cond, "message")) {
[13:24:36.104]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:36.104]                       if (muffled) 
[13:24:36.104]                         invokeRestart("muffleMessage")
[13:24:36.104]                     }
[13:24:36.104]                     else if (inherits(cond, "warning")) {
[13:24:36.104]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:36.104]                       if (muffled) 
[13:24:36.104]                         invokeRestart("muffleWarning")
[13:24:36.104]                     }
[13:24:36.104]                     else if (inherits(cond, "condition")) {
[13:24:36.104]                       if (!is.null(pattern)) {
[13:24:36.104]                         computeRestarts <- base::computeRestarts
[13:24:36.104]                         grepl <- base::grepl
[13:24:36.104]                         restarts <- computeRestarts(cond)
[13:24:36.104]                         for (restart in restarts) {
[13:24:36.104]                           name <- restart$name
[13:24:36.104]                           if (is.null(name)) 
[13:24:36.104]                             next
[13:24:36.104]                           if (!grepl(pattern, name)) 
[13:24:36.104]                             next
[13:24:36.104]                           invokeRestart(restart)
[13:24:36.104]                           muffled <- TRUE
[13:24:36.104]                           break
[13:24:36.104]                         }
[13:24:36.104]                       }
[13:24:36.104]                     }
[13:24:36.104]                     invisible(muffled)
[13:24:36.104]                   }
[13:24:36.104]                   muffleCondition(cond)
[13:24:36.104]                 })
[13:24:36.104]             }))
[13:24:36.104]             future::FutureResult(value = ...future.value$value, 
[13:24:36.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.104]                   ...future.rng), globalenv = if (FALSE) 
[13:24:36.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:36.104]                     ...future.globalenv.names))
[13:24:36.104]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:36.104]         }, condition = base::local({
[13:24:36.104]             c <- base::c
[13:24:36.104]             inherits <- base::inherits
[13:24:36.104]             invokeRestart <- base::invokeRestart
[13:24:36.104]             length <- base::length
[13:24:36.104]             list <- base::list
[13:24:36.104]             seq.int <- base::seq.int
[13:24:36.104]             signalCondition <- base::signalCondition
[13:24:36.104]             sys.calls <- base::sys.calls
[13:24:36.104]             `[[` <- base::`[[`
[13:24:36.104]             `+` <- base::`+`
[13:24:36.104]             `<<-` <- base::`<<-`
[13:24:36.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:36.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:36.104]                   3L)]
[13:24:36.104]             }
[13:24:36.104]             function(cond) {
[13:24:36.104]                 is_error <- inherits(cond, "error")
[13:24:36.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:36.104]                   NULL)
[13:24:36.104]                 if (is_error) {
[13:24:36.104]                   sessionInformation <- function() {
[13:24:36.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:36.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:36.104]                       search = base::search(), system = base::Sys.info())
[13:24:36.104]                   }
[13:24:36.104]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:36.104]                     cond$call), session = sessionInformation(), 
[13:24:36.104]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:36.104]                   signalCondition(cond)
[13:24:36.104]                 }
[13:24:36.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:36.104]                 "immediateCondition"))) {
[13:24:36.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:36.104]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:36.104]                   if (TRUE && !signal) {
[13:24:36.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.104]                     {
[13:24:36.104]                       inherits <- base::inherits
[13:24:36.104]                       invokeRestart <- base::invokeRestart
[13:24:36.104]                       is.null <- base::is.null
[13:24:36.104]                       muffled <- FALSE
[13:24:36.104]                       if (inherits(cond, "message")) {
[13:24:36.104]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.104]                         if (muffled) 
[13:24:36.104]                           invokeRestart("muffleMessage")
[13:24:36.104]                       }
[13:24:36.104]                       else if (inherits(cond, "warning")) {
[13:24:36.104]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.104]                         if (muffled) 
[13:24:36.104]                           invokeRestart("muffleWarning")
[13:24:36.104]                       }
[13:24:36.104]                       else if (inherits(cond, "condition")) {
[13:24:36.104]                         if (!is.null(pattern)) {
[13:24:36.104]                           computeRestarts <- base::computeRestarts
[13:24:36.104]                           grepl <- base::grepl
[13:24:36.104]                           restarts <- computeRestarts(cond)
[13:24:36.104]                           for (restart in restarts) {
[13:24:36.104]                             name <- restart$name
[13:24:36.104]                             if (is.null(name)) 
[13:24:36.104]                               next
[13:24:36.104]                             if (!grepl(pattern, name)) 
[13:24:36.104]                               next
[13:24:36.104]                             invokeRestart(restart)
[13:24:36.104]                             muffled <- TRUE
[13:24:36.104]                             break
[13:24:36.104]                           }
[13:24:36.104]                         }
[13:24:36.104]                       }
[13:24:36.104]                       invisible(muffled)
[13:24:36.104]                     }
[13:24:36.104]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.104]                   }
[13:24:36.104]                 }
[13:24:36.104]                 else {
[13:24:36.104]                   if (TRUE) {
[13:24:36.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.104]                     {
[13:24:36.104]                       inherits <- base::inherits
[13:24:36.104]                       invokeRestart <- base::invokeRestart
[13:24:36.104]                       is.null <- base::is.null
[13:24:36.104]                       muffled <- FALSE
[13:24:36.104]                       if (inherits(cond, "message")) {
[13:24:36.104]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.104]                         if (muffled) 
[13:24:36.104]                           invokeRestart("muffleMessage")
[13:24:36.104]                       }
[13:24:36.104]                       else if (inherits(cond, "warning")) {
[13:24:36.104]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.104]                         if (muffled) 
[13:24:36.104]                           invokeRestart("muffleWarning")
[13:24:36.104]                       }
[13:24:36.104]                       else if (inherits(cond, "condition")) {
[13:24:36.104]                         if (!is.null(pattern)) {
[13:24:36.104]                           computeRestarts <- base::computeRestarts
[13:24:36.104]                           grepl <- base::grepl
[13:24:36.104]                           restarts <- computeRestarts(cond)
[13:24:36.104]                           for (restart in restarts) {
[13:24:36.104]                             name <- restart$name
[13:24:36.104]                             if (is.null(name)) 
[13:24:36.104]                               next
[13:24:36.104]                             if (!grepl(pattern, name)) 
[13:24:36.104]                               next
[13:24:36.104]                             invokeRestart(restart)
[13:24:36.104]                             muffled <- TRUE
[13:24:36.104]                             break
[13:24:36.104]                           }
[13:24:36.104]                         }
[13:24:36.104]                       }
[13:24:36.104]                       invisible(muffled)
[13:24:36.104]                     }
[13:24:36.104]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.104]                   }
[13:24:36.104]                 }
[13:24:36.104]             }
[13:24:36.104]         }))
[13:24:36.104]     }, error = function(ex) {
[13:24:36.104]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:36.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.104]                 ...future.rng), started = ...future.startTime, 
[13:24:36.104]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:36.104]             version = "1.8"), class = "FutureResult")
[13:24:36.104]     }, finally = {
[13:24:36.104]         if (!identical(...future.workdir, getwd())) 
[13:24:36.104]             setwd(...future.workdir)
[13:24:36.104]         {
[13:24:36.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:36.104]                 ...future.oldOptions$nwarnings <- NULL
[13:24:36.104]             }
[13:24:36.104]             base::options(...future.oldOptions)
[13:24:36.104]             if (.Platform$OS.type == "windows") {
[13:24:36.104]                 old_names <- names(...future.oldEnvVars)
[13:24:36.104]                 envs <- base::Sys.getenv()
[13:24:36.104]                 names <- names(envs)
[13:24:36.104]                 common <- intersect(names, old_names)
[13:24:36.104]                 added <- setdiff(names, old_names)
[13:24:36.104]                 removed <- setdiff(old_names, names)
[13:24:36.104]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:36.104]                   envs[common]]
[13:24:36.104]                 NAMES <- toupper(changed)
[13:24:36.104]                 args <- list()
[13:24:36.104]                 for (kk in seq_along(NAMES)) {
[13:24:36.104]                   name <- changed[[kk]]
[13:24:36.104]                   NAME <- NAMES[[kk]]
[13:24:36.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.104]                     next
[13:24:36.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.104]                 }
[13:24:36.104]                 NAMES <- toupper(added)
[13:24:36.104]                 for (kk in seq_along(NAMES)) {
[13:24:36.104]                   name <- added[[kk]]
[13:24:36.104]                   NAME <- NAMES[[kk]]
[13:24:36.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.104]                     next
[13:24:36.104]                   args[[name]] <- ""
[13:24:36.104]                 }
[13:24:36.104]                 NAMES <- toupper(removed)
[13:24:36.104]                 for (kk in seq_along(NAMES)) {
[13:24:36.104]                   name <- removed[[kk]]
[13:24:36.104]                   NAME <- NAMES[[kk]]
[13:24:36.104]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.104]                     next
[13:24:36.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.104]                 }
[13:24:36.104]                 if (length(args) > 0) 
[13:24:36.104]                   base::do.call(base::Sys.setenv, args = args)
[13:24:36.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:36.104]             }
[13:24:36.104]             else {
[13:24:36.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:36.104]             }
[13:24:36.104]             {
[13:24:36.104]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:36.104]                   0L) {
[13:24:36.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:36.104]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:36.104]                   base::options(opts)
[13:24:36.104]                 }
[13:24:36.104]                 {
[13:24:36.104]                   {
[13:24:36.104]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:36.104]                     NULL
[13:24:36.104]                   }
[13:24:36.104]                   options(future.plan = NULL)
[13:24:36.104]                   if (is.na(NA_character_)) 
[13:24:36.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:36.104]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:36.104]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:36.104]                     envir = parent.frame()) 
[13:24:36.104]                   {
[13:24:36.104]                     if (is.function(workers)) 
[13:24:36.104]                       workers <- workers()
[13:24:36.104]                     workers <- structure(as.integer(workers), 
[13:24:36.104]                       class = class(workers))
[13:24:36.104]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:36.104]                       workers >= 1)
[13:24:36.104]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:36.104]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:36.104]                     }
[13:24:36.104]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:36.104]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:36.104]                       envir = envir)
[13:24:36.104]                     if (!future$lazy) 
[13:24:36.104]                       future <- run(future)
[13:24:36.104]                     invisible(future)
[13:24:36.104]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:36.104]                 }
[13:24:36.104]             }
[13:24:36.104]         }
[13:24:36.104]     })
[13:24:36.104]     if (TRUE) {
[13:24:36.104]         base::sink(type = "output", split = FALSE)
[13:24:36.104]         if (TRUE) {
[13:24:36.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:36.104]         }
[13:24:36.104]         else {
[13:24:36.104]             ...future.result["stdout"] <- base::list(NULL)
[13:24:36.104]         }
[13:24:36.104]         base::close(...future.stdout)
[13:24:36.104]         ...future.stdout <- NULL
[13:24:36.104]     }
[13:24:36.104]     ...future.result$conditions <- ...future.conditions
[13:24:36.104]     ...future.result$finished <- base::Sys.time()
[13:24:36.104]     ...future.result
[13:24:36.104] }
[13:24:36.107] Poll #1 (0): usedNodes() = 2, workers = 2
[13:24:36.117] receiveMessageFromWorker() for ClusterFuture ...
[13:24:36.117] - Validating connection of MultisessionFuture
[13:24:36.118] - received message: FutureResult
[13:24:36.118] - Received FutureResult
[13:24:36.118] - Erased future from FutureRegistry
[13:24:36.118] result() for ClusterFuture ...
[13:24:36.118] - result already collected: FutureResult
[13:24:36.118] result() for ClusterFuture ... done
[13:24:36.118] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:36.118] result() for ClusterFuture ...
[13:24:36.118] - result already collected: FutureResult
[13:24:36.118] result() for ClusterFuture ... done
[13:24:36.119] result() for ClusterFuture ...
[13:24:36.119] - result already collected: FutureResult
[13:24:36.119] result() for ClusterFuture ... done
[13:24:36.120] MultisessionFuture started
[13:24:36.120] - Launch lazy future ... done
[13:24:36.120] run() for ‘MultisessionFuture’ ... done
[13:24:36.120] getGlobalsAndPackages() ...
[13:24:36.120] Searching for globals...
[13:24:36.121] - globals found: [2] ‘list’, ‘stop’
[13:24:36.121] Searching for globals ... DONE
[13:24:36.121] Resolving globals: FALSE
[13:24:36.122] 
[13:24:36.122] 
[13:24:36.122] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[13:24:36.122] getGlobalsAndPackages() ...
[13:24:36.122] Searching for globals...
[13:24:36.123] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:36.123] Searching for globals ... DONE
[13:24:36.123] Resolving globals: FALSE
[13:24:36.124] 
[13:24:36.124] 
[13:24:36.124] getGlobalsAndPackages() ... DONE
[13:24:36.124] run() for ‘Future’ ...
[13:24:36.124] - state: ‘created’
[13:24:36.124] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:36.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:36.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:36.139]   - Field: ‘node’
[13:24:36.139]   - Field: ‘label’
[13:24:36.139]   - Field: ‘local’
[13:24:36.139]   - Field: ‘owner’
[13:24:36.139]   - Field: ‘envir’
[13:24:36.139]   - Field: ‘workers’
[13:24:36.139]   - Field: ‘packages’
[13:24:36.139]   - Field: ‘gc’
[13:24:36.139]   - Field: ‘conditions’
[13:24:36.139]   - Field: ‘persistent’
[13:24:36.140]   - Field: ‘expr’
[13:24:36.140]   - Field: ‘uuid’
[13:24:36.140]   - Field: ‘seed’
[13:24:36.140]   - Field: ‘version’
[13:24:36.140]   - Field: ‘result’
[13:24:36.140]   - Field: ‘asynchronous’
[13:24:36.140]   - Field: ‘calls’
[13:24:36.140]   - Field: ‘globals’
[13:24:36.140]   - Field: ‘stdout’
[13:24:36.140]   - Field: ‘earlySignal’
[13:24:36.141]   - Field: ‘lazy’
[13:24:36.141]   - Field: ‘state’
[13:24:36.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:36.141] - Launch lazy future ...
[13:24:36.141] Packages needed by the future expression (n = 0): <none>
[13:24:36.141] Packages needed by future strategies (n = 0): <none>
[13:24:36.142] {
[13:24:36.142]     {
[13:24:36.142]         {
[13:24:36.142]             ...future.startTime <- base::Sys.time()
[13:24:36.142]             {
[13:24:36.142]                 {
[13:24:36.142]                   {
[13:24:36.142]                     {
[13:24:36.142]                       base::local({
[13:24:36.142]                         has_future <- base::requireNamespace("future", 
[13:24:36.142]                           quietly = TRUE)
[13:24:36.142]                         if (has_future) {
[13:24:36.142]                           ns <- base::getNamespace("future")
[13:24:36.142]                           version <- ns[[".package"]][["version"]]
[13:24:36.142]                           if (is.null(version)) 
[13:24:36.142]                             version <- utils::packageVersion("future")
[13:24:36.142]                         }
[13:24:36.142]                         else {
[13:24:36.142]                           version <- NULL
[13:24:36.142]                         }
[13:24:36.142]                         if (!has_future || version < "1.8.0") {
[13:24:36.142]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:36.142]                             "", base::R.version$version.string), 
[13:24:36.142]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:36.142]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:36.142]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:36.142]                               "release", "version")], collapse = " "), 
[13:24:36.142]                             hostname = base::Sys.info()[["nodename"]])
[13:24:36.142]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:36.142]                             info)
[13:24:36.142]                           info <- base::paste(info, collapse = "; ")
[13:24:36.142]                           if (!has_future) {
[13:24:36.142]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:36.142]                               info)
[13:24:36.142]                           }
[13:24:36.142]                           else {
[13:24:36.142]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:36.142]                               info, version)
[13:24:36.142]                           }
[13:24:36.142]                           base::stop(msg)
[13:24:36.142]                         }
[13:24:36.142]                       })
[13:24:36.142]                     }
[13:24:36.142]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:36.142]                     base::options(mc.cores = 1L)
[13:24:36.142]                   }
[13:24:36.142]                   options(future.plan = NULL)
[13:24:36.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:36.142]                 }
[13:24:36.142]                 ...future.workdir <- getwd()
[13:24:36.142]             }
[13:24:36.142]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:36.142]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:36.142]         }
[13:24:36.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:36.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:36.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:36.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:36.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:36.142]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:36.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:36.142]             base::names(...future.oldOptions))
[13:24:36.142]     }
[13:24:36.142]     if (FALSE) {
[13:24:36.142]     }
[13:24:36.142]     else {
[13:24:36.142]         if (TRUE) {
[13:24:36.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:36.142]                 open = "w")
[13:24:36.142]         }
[13:24:36.142]         else {
[13:24:36.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:36.142]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:36.142]         }
[13:24:36.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:36.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:36.142]             base::sink(type = "output", split = FALSE)
[13:24:36.142]             base::close(...future.stdout)
[13:24:36.142]         }, add = TRUE)
[13:24:36.142]     }
[13:24:36.142]     ...future.frame <- base::sys.nframe()
[13:24:36.142]     ...future.conditions <- base::list()
[13:24:36.142]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:36.142]     if (FALSE) {
[13:24:36.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:36.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:36.142]     }
[13:24:36.142]     ...future.result <- base::tryCatch({
[13:24:36.142]         base::withCallingHandlers({
[13:24:36.142]             ...future.value <- base::withVisible(base::local({
[13:24:36.142]                 ...future.makeSendCondition <- base::local({
[13:24:36.142]                   sendCondition <- NULL
[13:24:36.142]                   function(frame = 1L) {
[13:24:36.142]                     if (is.function(sendCondition)) 
[13:24:36.142]                       return(sendCondition)
[13:24:36.142]                     ns <- getNamespace("parallel")
[13:24:36.142]                     if (exists("sendData", mode = "function", 
[13:24:36.142]                       envir = ns)) {
[13:24:36.142]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:36.142]                         envir = ns)
[13:24:36.142]                       envir <- sys.frame(frame)
[13:24:36.142]                       master <- NULL
[13:24:36.142]                       while (!identical(envir, .GlobalEnv) && 
[13:24:36.142]                         !identical(envir, emptyenv())) {
[13:24:36.142]                         if (exists("master", mode = "list", envir = envir, 
[13:24:36.142]                           inherits = FALSE)) {
[13:24:36.142]                           master <- get("master", mode = "list", 
[13:24:36.142]                             envir = envir, inherits = FALSE)
[13:24:36.142]                           if (inherits(master, c("SOCKnode", 
[13:24:36.142]                             "SOCK0node"))) {
[13:24:36.142]                             sendCondition <<- function(cond) {
[13:24:36.142]                               data <- list(type = "VALUE", value = cond, 
[13:24:36.142]                                 success = TRUE)
[13:24:36.142]                               parallel_sendData(master, data)
[13:24:36.142]                             }
[13:24:36.142]                             return(sendCondition)
[13:24:36.142]                           }
[13:24:36.142]                         }
[13:24:36.142]                         frame <- frame + 1L
[13:24:36.142]                         envir <- sys.frame(frame)
[13:24:36.142]                       }
[13:24:36.142]                     }
[13:24:36.142]                     sendCondition <<- function(cond) NULL
[13:24:36.142]                   }
[13:24:36.142]                 })
[13:24:36.142]                 withCallingHandlers({
[13:24:36.142]                   {
[13:24:36.142]                     Sys.sleep(0.5)
[13:24:36.142]                     list(a = 1, b = 42L)
[13:24:36.142]                   }
[13:24:36.142]                 }, immediateCondition = function(cond) {
[13:24:36.142]                   sendCondition <- ...future.makeSendCondition()
[13:24:36.142]                   sendCondition(cond)
[13:24:36.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.142]                   {
[13:24:36.142]                     inherits <- base::inherits
[13:24:36.142]                     invokeRestart <- base::invokeRestart
[13:24:36.142]                     is.null <- base::is.null
[13:24:36.142]                     muffled <- FALSE
[13:24:36.142]                     if (inherits(cond, "message")) {
[13:24:36.142]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:36.142]                       if (muffled) 
[13:24:36.142]                         invokeRestart("muffleMessage")
[13:24:36.142]                     }
[13:24:36.142]                     else if (inherits(cond, "warning")) {
[13:24:36.142]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:36.142]                       if (muffled) 
[13:24:36.142]                         invokeRestart("muffleWarning")
[13:24:36.142]                     }
[13:24:36.142]                     else if (inherits(cond, "condition")) {
[13:24:36.142]                       if (!is.null(pattern)) {
[13:24:36.142]                         computeRestarts <- base::computeRestarts
[13:24:36.142]                         grepl <- base::grepl
[13:24:36.142]                         restarts <- computeRestarts(cond)
[13:24:36.142]                         for (restart in restarts) {
[13:24:36.142]                           name <- restart$name
[13:24:36.142]                           if (is.null(name)) 
[13:24:36.142]                             next
[13:24:36.142]                           if (!grepl(pattern, name)) 
[13:24:36.142]                             next
[13:24:36.142]                           invokeRestart(restart)
[13:24:36.142]                           muffled <- TRUE
[13:24:36.142]                           break
[13:24:36.142]                         }
[13:24:36.142]                       }
[13:24:36.142]                     }
[13:24:36.142]                     invisible(muffled)
[13:24:36.142]                   }
[13:24:36.142]                   muffleCondition(cond)
[13:24:36.142]                 })
[13:24:36.142]             }))
[13:24:36.142]             future::FutureResult(value = ...future.value$value, 
[13:24:36.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.142]                   ...future.rng), globalenv = if (FALSE) 
[13:24:36.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:36.142]                     ...future.globalenv.names))
[13:24:36.142]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:36.142]         }, condition = base::local({
[13:24:36.142]             c <- base::c
[13:24:36.142]             inherits <- base::inherits
[13:24:36.142]             invokeRestart <- base::invokeRestart
[13:24:36.142]             length <- base::length
[13:24:36.142]             list <- base::list
[13:24:36.142]             seq.int <- base::seq.int
[13:24:36.142]             signalCondition <- base::signalCondition
[13:24:36.142]             sys.calls <- base::sys.calls
[13:24:36.142]             `[[` <- base::`[[`
[13:24:36.142]             `+` <- base::`+`
[13:24:36.142]             `<<-` <- base::`<<-`
[13:24:36.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:36.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:36.142]                   3L)]
[13:24:36.142]             }
[13:24:36.142]             function(cond) {
[13:24:36.142]                 is_error <- inherits(cond, "error")
[13:24:36.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:36.142]                   NULL)
[13:24:36.142]                 if (is_error) {
[13:24:36.142]                   sessionInformation <- function() {
[13:24:36.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:36.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:36.142]                       search = base::search(), system = base::Sys.info())
[13:24:36.142]                   }
[13:24:36.142]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:36.142]                     cond$call), session = sessionInformation(), 
[13:24:36.142]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:36.142]                   signalCondition(cond)
[13:24:36.142]                 }
[13:24:36.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:36.142]                 "immediateCondition"))) {
[13:24:36.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:36.142]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:36.142]                   if (TRUE && !signal) {
[13:24:36.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.142]                     {
[13:24:36.142]                       inherits <- base::inherits
[13:24:36.142]                       invokeRestart <- base::invokeRestart
[13:24:36.142]                       is.null <- base::is.null
[13:24:36.142]                       muffled <- FALSE
[13:24:36.142]                       if (inherits(cond, "message")) {
[13:24:36.142]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.142]                         if (muffled) 
[13:24:36.142]                           invokeRestart("muffleMessage")
[13:24:36.142]                       }
[13:24:36.142]                       else if (inherits(cond, "warning")) {
[13:24:36.142]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.142]                         if (muffled) 
[13:24:36.142]                           invokeRestart("muffleWarning")
[13:24:36.142]                       }
[13:24:36.142]                       else if (inherits(cond, "condition")) {
[13:24:36.142]                         if (!is.null(pattern)) {
[13:24:36.142]                           computeRestarts <- base::computeRestarts
[13:24:36.142]                           grepl <- base::grepl
[13:24:36.142]                           restarts <- computeRestarts(cond)
[13:24:36.142]                           for (restart in restarts) {
[13:24:36.142]                             name <- restart$name
[13:24:36.142]                             if (is.null(name)) 
[13:24:36.142]                               next
[13:24:36.142]                             if (!grepl(pattern, name)) 
[13:24:36.142]                               next
[13:24:36.142]                             invokeRestart(restart)
[13:24:36.142]                             muffled <- TRUE
[13:24:36.142]                             break
[13:24:36.142]                           }
[13:24:36.142]                         }
[13:24:36.142]                       }
[13:24:36.142]                       invisible(muffled)
[13:24:36.142]                     }
[13:24:36.142]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.142]                   }
[13:24:36.142]                 }
[13:24:36.142]                 else {
[13:24:36.142]                   if (TRUE) {
[13:24:36.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.142]                     {
[13:24:36.142]                       inherits <- base::inherits
[13:24:36.142]                       invokeRestart <- base::invokeRestart
[13:24:36.142]                       is.null <- base::is.null
[13:24:36.142]                       muffled <- FALSE
[13:24:36.142]                       if (inherits(cond, "message")) {
[13:24:36.142]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.142]                         if (muffled) 
[13:24:36.142]                           invokeRestart("muffleMessage")
[13:24:36.142]                       }
[13:24:36.142]                       else if (inherits(cond, "warning")) {
[13:24:36.142]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.142]                         if (muffled) 
[13:24:36.142]                           invokeRestart("muffleWarning")
[13:24:36.142]                       }
[13:24:36.142]                       else if (inherits(cond, "condition")) {
[13:24:36.142]                         if (!is.null(pattern)) {
[13:24:36.142]                           computeRestarts <- base::computeRestarts
[13:24:36.142]                           grepl <- base::grepl
[13:24:36.142]                           restarts <- computeRestarts(cond)
[13:24:36.142]                           for (restart in restarts) {
[13:24:36.142]                             name <- restart$name
[13:24:36.142]                             if (is.null(name)) 
[13:24:36.142]                               next
[13:24:36.142]                             if (!grepl(pattern, name)) 
[13:24:36.142]                               next
[13:24:36.142]                             invokeRestart(restart)
[13:24:36.142]                             muffled <- TRUE
[13:24:36.142]                             break
[13:24:36.142]                           }
[13:24:36.142]                         }
[13:24:36.142]                       }
[13:24:36.142]                       invisible(muffled)
[13:24:36.142]                     }
[13:24:36.142]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.142]                   }
[13:24:36.142]                 }
[13:24:36.142]             }
[13:24:36.142]         }))
[13:24:36.142]     }, error = function(ex) {
[13:24:36.142]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:36.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.142]                 ...future.rng), started = ...future.startTime, 
[13:24:36.142]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:36.142]             version = "1.8"), class = "FutureResult")
[13:24:36.142]     }, finally = {
[13:24:36.142]         if (!identical(...future.workdir, getwd())) 
[13:24:36.142]             setwd(...future.workdir)
[13:24:36.142]         {
[13:24:36.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:36.142]                 ...future.oldOptions$nwarnings <- NULL
[13:24:36.142]             }
[13:24:36.142]             base::options(...future.oldOptions)
[13:24:36.142]             if (.Platform$OS.type == "windows") {
[13:24:36.142]                 old_names <- names(...future.oldEnvVars)
[13:24:36.142]                 envs <- base::Sys.getenv()
[13:24:36.142]                 names <- names(envs)
[13:24:36.142]                 common <- intersect(names, old_names)
[13:24:36.142]                 added <- setdiff(names, old_names)
[13:24:36.142]                 removed <- setdiff(old_names, names)
[13:24:36.142]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:36.142]                   envs[common]]
[13:24:36.142]                 NAMES <- toupper(changed)
[13:24:36.142]                 args <- list()
[13:24:36.142]                 for (kk in seq_along(NAMES)) {
[13:24:36.142]                   name <- changed[[kk]]
[13:24:36.142]                   NAME <- NAMES[[kk]]
[13:24:36.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.142]                     next
[13:24:36.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.142]                 }
[13:24:36.142]                 NAMES <- toupper(added)
[13:24:36.142]                 for (kk in seq_along(NAMES)) {
[13:24:36.142]                   name <- added[[kk]]
[13:24:36.142]                   NAME <- NAMES[[kk]]
[13:24:36.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.142]                     next
[13:24:36.142]                   args[[name]] <- ""
[13:24:36.142]                 }
[13:24:36.142]                 NAMES <- toupper(removed)
[13:24:36.142]                 for (kk in seq_along(NAMES)) {
[13:24:36.142]                   name <- removed[[kk]]
[13:24:36.142]                   NAME <- NAMES[[kk]]
[13:24:36.142]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.142]                     next
[13:24:36.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.142]                 }
[13:24:36.142]                 if (length(args) > 0) 
[13:24:36.142]                   base::do.call(base::Sys.setenv, args = args)
[13:24:36.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:36.142]             }
[13:24:36.142]             else {
[13:24:36.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:36.142]             }
[13:24:36.142]             {
[13:24:36.142]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:36.142]                   0L) {
[13:24:36.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:36.142]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:36.142]                   base::options(opts)
[13:24:36.142]                 }
[13:24:36.142]                 {
[13:24:36.142]                   {
[13:24:36.142]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:36.142]                     NULL
[13:24:36.142]                   }
[13:24:36.142]                   options(future.plan = NULL)
[13:24:36.142]                   if (is.na(NA_character_)) 
[13:24:36.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:36.142]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:36.142]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:36.142]                     envir = parent.frame()) 
[13:24:36.142]                   {
[13:24:36.142]                     if (is.function(workers)) 
[13:24:36.142]                       workers <- workers()
[13:24:36.142]                     workers <- structure(as.integer(workers), 
[13:24:36.142]                       class = class(workers))
[13:24:36.142]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:36.142]                       workers >= 1)
[13:24:36.142]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:36.142]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:36.142]                     }
[13:24:36.142]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:36.142]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:36.142]                       envir = envir)
[13:24:36.142]                     if (!future$lazy) 
[13:24:36.142]                       future <- run(future)
[13:24:36.142]                     invisible(future)
[13:24:36.142]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:36.142]                 }
[13:24:36.142]             }
[13:24:36.142]         }
[13:24:36.142]     })
[13:24:36.142]     if (TRUE) {
[13:24:36.142]         base::sink(type = "output", split = FALSE)
[13:24:36.142]         if (TRUE) {
[13:24:36.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:36.142]         }
[13:24:36.142]         else {
[13:24:36.142]             ...future.result["stdout"] <- base::list(NULL)
[13:24:36.142]         }
[13:24:36.142]         base::close(...future.stdout)
[13:24:36.142]         ...future.stdout <- NULL
[13:24:36.142]     }
[13:24:36.142]     ...future.result$conditions <- ...future.conditions
[13:24:36.142]     ...future.result$finished <- base::Sys.time()
[13:24:36.142]     ...future.result
[13:24:36.142] }
[13:24:36.144] Poll #1 (0): usedNodes() = 2, workers = 2
[13:24:36.169] receiveMessageFromWorker() for ClusterFuture ...
[13:24:36.169] - Validating connection of MultisessionFuture
[13:24:36.170] - received message: FutureResult
[13:24:36.170] - Received FutureResult
[13:24:36.170] - Erased future from FutureRegistry
[13:24:36.170] result() for ClusterFuture ...
[13:24:36.170] - result already collected: FutureResult
[13:24:36.170] result() for ClusterFuture ... done
[13:24:36.171] signalConditions() ...
[13:24:36.171]  - include = ‘immediateCondition’
[13:24:36.171]  - exclude = 
[13:24:36.171]  - resignal = FALSE
[13:24:36.171]  - Number of conditions: 1
[13:24:36.171] signalConditions() ... done
[13:24:36.171] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:36.171] result() for ClusterFuture ...
[13:24:36.171] - result already collected: FutureResult
[13:24:36.172] result() for ClusterFuture ... done
[13:24:36.172] result() for ClusterFuture ...
[13:24:36.172] - result already collected: FutureResult
[13:24:36.172] result() for ClusterFuture ... done
[13:24:36.172] signalConditions() ...
[13:24:36.172]  - include = ‘immediateCondition’
[13:24:36.172]  - exclude = 
[13:24:36.172]  - resignal = FALSE
[13:24:36.172]  - Number of conditions: 1
[13:24:36.172] signalConditions() ... done
[13:24:36.174] MultisessionFuture started
[13:24:36.174] - Launch lazy future ... done
[13:24:36.174] run() for ‘MultisessionFuture’ ... done
[13:24:36.722] receiveMessageFromWorker() for ClusterFuture ...
[13:24:36.723] - Validating connection of MultisessionFuture
[13:24:36.723] - received message: FutureResult
[13:24:36.723] - Received FutureResult
[13:24:36.723] - Erased future from FutureRegistry
[13:24:36.724] result() for ClusterFuture ...
[13:24:36.724] - result already collected: FutureResult
[13:24:36.724] result() for ClusterFuture ... done
[13:24:36.724] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:36.724] A MultisessionFuture was resolved
[13:24:36.724] getGlobalsAndPackages() ...
[13:24:36.724] Searching for globals...
[13:24:36.725] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:36.726] Searching for globals ... DONE
[13:24:36.726] Resolving globals: FALSE
[13:24:36.726] 
[13:24:36.726] 
[13:24:36.726] getGlobalsAndPackages() ... DONE
[13:24:36.727] run() for ‘Future’ ...
[13:24:36.727] - state: ‘created’
[13:24:36.727] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:36.741] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:36.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:36.741]   - Field: ‘node’
[13:24:36.741]   - Field: ‘label’
[13:24:36.742]   - Field: ‘local’
[13:24:36.742]   - Field: ‘owner’
[13:24:36.742]   - Field: ‘envir’
[13:24:36.742]   - Field: ‘workers’
[13:24:36.742]   - Field: ‘packages’
[13:24:36.742]   - Field: ‘gc’
[13:24:36.742]   - Field: ‘conditions’
[13:24:36.742]   - Field: ‘persistent’
[13:24:36.742]   - Field: ‘expr’
[13:24:36.742]   - Field: ‘uuid’
[13:24:36.742]   - Field: ‘seed’
[13:24:36.743]   - Field: ‘version’
[13:24:36.743]   - Field: ‘result’
[13:24:36.743]   - Field: ‘asynchronous’
[13:24:36.743]   - Field: ‘calls’
[13:24:36.743]   - Field: ‘globals’
[13:24:36.743]   - Field: ‘stdout’
[13:24:36.743]   - Field: ‘earlySignal’
[13:24:36.743]   - Field: ‘lazy’
[13:24:36.743]   - Field: ‘state’
[13:24:36.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:36.743] - Launch lazy future ...
[13:24:36.744] Packages needed by the future expression (n = 0): <none>
[13:24:36.744] Packages needed by future strategies (n = 0): <none>
[13:24:36.744] {
[13:24:36.744]     {
[13:24:36.744]         {
[13:24:36.744]             ...future.startTime <- base::Sys.time()
[13:24:36.744]             {
[13:24:36.744]                 {
[13:24:36.744]                   {
[13:24:36.744]                     {
[13:24:36.744]                       base::local({
[13:24:36.744]                         has_future <- base::requireNamespace("future", 
[13:24:36.744]                           quietly = TRUE)
[13:24:36.744]                         if (has_future) {
[13:24:36.744]                           ns <- base::getNamespace("future")
[13:24:36.744]                           version <- ns[[".package"]][["version"]]
[13:24:36.744]                           if (is.null(version)) 
[13:24:36.744]                             version <- utils::packageVersion("future")
[13:24:36.744]                         }
[13:24:36.744]                         else {
[13:24:36.744]                           version <- NULL
[13:24:36.744]                         }
[13:24:36.744]                         if (!has_future || version < "1.8.0") {
[13:24:36.744]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:36.744]                             "", base::R.version$version.string), 
[13:24:36.744]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:36.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:36.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:36.744]                               "release", "version")], collapse = " "), 
[13:24:36.744]                             hostname = base::Sys.info()[["nodename"]])
[13:24:36.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:36.744]                             info)
[13:24:36.744]                           info <- base::paste(info, collapse = "; ")
[13:24:36.744]                           if (!has_future) {
[13:24:36.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:36.744]                               info)
[13:24:36.744]                           }
[13:24:36.744]                           else {
[13:24:36.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:36.744]                               info, version)
[13:24:36.744]                           }
[13:24:36.744]                           base::stop(msg)
[13:24:36.744]                         }
[13:24:36.744]                       })
[13:24:36.744]                     }
[13:24:36.744]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:36.744]                     base::options(mc.cores = 1L)
[13:24:36.744]                   }
[13:24:36.744]                   options(future.plan = NULL)
[13:24:36.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:36.744]                 }
[13:24:36.744]                 ...future.workdir <- getwd()
[13:24:36.744]             }
[13:24:36.744]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:36.744]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:36.744]         }
[13:24:36.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:36.744]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:36.744]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:36.744]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:36.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:36.744]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:36.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:36.744]             base::names(...future.oldOptions))
[13:24:36.744]     }
[13:24:36.744]     if (FALSE) {
[13:24:36.744]     }
[13:24:36.744]     else {
[13:24:36.744]         if (TRUE) {
[13:24:36.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:36.744]                 open = "w")
[13:24:36.744]         }
[13:24:36.744]         else {
[13:24:36.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:36.744]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:36.744]         }
[13:24:36.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:36.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:36.744]             base::sink(type = "output", split = FALSE)
[13:24:36.744]             base::close(...future.stdout)
[13:24:36.744]         }, add = TRUE)
[13:24:36.744]     }
[13:24:36.744]     ...future.frame <- base::sys.nframe()
[13:24:36.744]     ...future.conditions <- base::list()
[13:24:36.744]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:36.744]     if (FALSE) {
[13:24:36.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:36.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:36.744]     }
[13:24:36.744]     ...future.result <- base::tryCatch({
[13:24:36.744]         base::withCallingHandlers({
[13:24:36.744]             ...future.value <- base::withVisible(base::local({
[13:24:36.744]                 ...future.makeSendCondition <- base::local({
[13:24:36.744]                   sendCondition <- NULL
[13:24:36.744]                   function(frame = 1L) {
[13:24:36.744]                     if (is.function(sendCondition)) 
[13:24:36.744]                       return(sendCondition)
[13:24:36.744]                     ns <- getNamespace("parallel")
[13:24:36.744]                     if (exists("sendData", mode = "function", 
[13:24:36.744]                       envir = ns)) {
[13:24:36.744]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:36.744]                         envir = ns)
[13:24:36.744]                       envir <- sys.frame(frame)
[13:24:36.744]                       master <- NULL
[13:24:36.744]                       while (!identical(envir, .GlobalEnv) && 
[13:24:36.744]                         !identical(envir, emptyenv())) {
[13:24:36.744]                         if (exists("master", mode = "list", envir = envir, 
[13:24:36.744]                           inherits = FALSE)) {
[13:24:36.744]                           master <- get("master", mode = "list", 
[13:24:36.744]                             envir = envir, inherits = FALSE)
[13:24:36.744]                           if (inherits(master, c("SOCKnode", 
[13:24:36.744]                             "SOCK0node"))) {
[13:24:36.744]                             sendCondition <<- function(cond) {
[13:24:36.744]                               data <- list(type = "VALUE", value = cond, 
[13:24:36.744]                                 success = TRUE)
[13:24:36.744]                               parallel_sendData(master, data)
[13:24:36.744]                             }
[13:24:36.744]                             return(sendCondition)
[13:24:36.744]                           }
[13:24:36.744]                         }
[13:24:36.744]                         frame <- frame + 1L
[13:24:36.744]                         envir <- sys.frame(frame)
[13:24:36.744]                       }
[13:24:36.744]                     }
[13:24:36.744]                     sendCondition <<- function(cond) NULL
[13:24:36.744]                   }
[13:24:36.744]                 })
[13:24:36.744]                 withCallingHandlers({
[13:24:36.744]                   {
[13:24:36.744]                     Sys.sleep(0.5)
[13:24:36.744]                     list(a = 1, b = 42L)
[13:24:36.744]                   }
[13:24:36.744]                 }, immediateCondition = function(cond) {
[13:24:36.744]                   sendCondition <- ...future.makeSendCondition()
[13:24:36.744]                   sendCondition(cond)
[13:24:36.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.744]                   {
[13:24:36.744]                     inherits <- base::inherits
[13:24:36.744]                     invokeRestart <- base::invokeRestart
[13:24:36.744]                     is.null <- base::is.null
[13:24:36.744]                     muffled <- FALSE
[13:24:36.744]                     if (inherits(cond, "message")) {
[13:24:36.744]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:36.744]                       if (muffled) 
[13:24:36.744]                         invokeRestart("muffleMessage")
[13:24:36.744]                     }
[13:24:36.744]                     else if (inherits(cond, "warning")) {
[13:24:36.744]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:36.744]                       if (muffled) 
[13:24:36.744]                         invokeRestart("muffleWarning")
[13:24:36.744]                     }
[13:24:36.744]                     else if (inherits(cond, "condition")) {
[13:24:36.744]                       if (!is.null(pattern)) {
[13:24:36.744]                         computeRestarts <- base::computeRestarts
[13:24:36.744]                         grepl <- base::grepl
[13:24:36.744]                         restarts <- computeRestarts(cond)
[13:24:36.744]                         for (restart in restarts) {
[13:24:36.744]                           name <- restart$name
[13:24:36.744]                           if (is.null(name)) 
[13:24:36.744]                             next
[13:24:36.744]                           if (!grepl(pattern, name)) 
[13:24:36.744]                             next
[13:24:36.744]                           invokeRestart(restart)
[13:24:36.744]                           muffled <- TRUE
[13:24:36.744]                           break
[13:24:36.744]                         }
[13:24:36.744]                       }
[13:24:36.744]                     }
[13:24:36.744]                     invisible(muffled)
[13:24:36.744]                   }
[13:24:36.744]                   muffleCondition(cond)
[13:24:36.744]                 })
[13:24:36.744]             }))
[13:24:36.744]             future::FutureResult(value = ...future.value$value, 
[13:24:36.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.744]                   ...future.rng), globalenv = if (FALSE) 
[13:24:36.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:36.744]                     ...future.globalenv.names))
[13:24:36.744]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:36.744]         }, condition = base::local({
[13:24:36.744]             c <- base::c
[13:24:36.744]             inherits <- base::inherits
[13:24:36.744]             invokeRestart <- base::invokeRestart
[13:24:36.744]             length <- base::length
[13:24:36.744]             list <- base::list
[13:24:36.744]             seq.int <- base::seq.int
[13:24:36.744]             signalCondition <- base::signalCondition
[13:24:36.744]             sys.calls <- base::sys.calls
[13:24:36.744]             `[[` <- base::`[[`
[13:24:36.744]             `+` <- base::`+`
[13:24:36.744]             `<<-` <- base::`<<-`
[13:24:36.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:36.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:36.744]                   3L)]
[13:24:36.744]             }
[13:24:36.744]             function(cond) {
[13:24:36.744]                 is_error <- inherits(cond, "error")
[13:24:36.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:36.744]                   NULL)
[13:24:36.744]                 if (is_error) {
[13:24:36.744]                   sessionInformation <- function() {
[13:24:36.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:36.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:36.744]                       search = base::search(), system = base::Sys.info())
[13:24:36.744]                   }
[13:24:36.744]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:36.744]                     cond$call), session = sessionInformation(), 
[13:24:36.744]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:36.744]                   signalCondition(cond)
[13:24:36.744]                 }
[13:24:36.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:36.744]                 "immediateCondition"))) {
[13:24:36.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:36.744]                   ...future.conditions[[length(...future.conditions) + 
[13:24:36.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:36.744]                   if (TRUE && !signal) {
[13:24:36.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.744]                     {
[13:24:36.744]                       inherits <- base::inherits
[13:24:36.744]                       invokeRestart <- base::invokeRestart
[13:24:36.744]                       is.null <- base::is.null
[13:24:36.744]                       muffled <- FALSE
[13:24:36.744]                       if (inherits(cond, "message")) {
[13:24:36.744]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.744]                         if (muffled) 
[13:24:36.744]                           invokeRestart("muffleMessage")
[13:24:36.744]                       }
[13:24:36.744]                       else if (inherits(cond, "warning")) {
[13:24:36.744]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.744]                         if (muffled) 
[13:24:36.744]                           invokeRestart("muffleWarning")
[13:24:36.744]                       }
[13:24:36.744]                       else if (inherits(cond, "condition")) {
[13:24:36.744]                         if (!is.null(pattern)) {
[13:24:36.744]                           computeRestarts <- base::computeRestarts
[13:24:36.744]                           grepl <- base::grepl
[13:24:36.744]                           restarts <- computeRestarts(cond)
[13:24:36.744]                           for (restart in restarts) {
[13:24:36.744]                             name <- restart$name
[13:24:36.744]                             if (is.null(name)) 
[13:24:36.744]                               next
[13:24:36.744]                             if (!grepl(pattern, name)) 
[13:24:36.744]                               next
[13:24:36.744]                             invokeRestart(restart)
[13:24:36.744]                             muffled <- TRUE
[13:24:36.744]                             break
[13:24:36.744]                           }
[13:24:36.744]                         }
[13:24:36.744]                       }
[13:24:36.744]                       invisible(muffled)
[13:24:36.744]                     }
[13:24:36.744]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.744]                   }
[13:24:36.744]                 }
[13:24:36.744]                 else {
[13:24:36.744]                   if (TRUE) {
[13:24:36.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:36.744]                     {
[13:24:36.744]                       inherits <- base::inherits
[13:24:36.744]                       invokeRestart <- base::invokeRestart
[13:24:36.744]                       is.null <- base::is.null
[13:24:36.744]                       muffled <- FALSE
[13:24:36.744]                       if (inherits(cond, "message")) {
[13:24:36.744]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:36.744]                         if (muffled) 
[13:24:36.744]                           invokeRestart("muffleMessage")
[13:24:36.744]                       }
[13:24:36.744]                       else if (inherits(cond, "warning")) {
[13:24:36.744]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:36.744]                         if (muffled) 
[13:24:36.744]                           invokeRestart("muffleWarning")
[13:24:36.744]                       }
[13:24:36.744]                       else if (inherits(cond, "condition")) {
[13:24:36.744]                         if (!is.null(pattern)) {
[13:24:36.744]                           computeRestarts <- base::computeRestarts
[13:24:36.744]                           grepl <- base::grepl
[13:24:36.744]                           restarts <- computeRestarts(cond)
[13:24:36.744]                           for (restart in restarts) {
[13:24:36.744]                             name <- restart$name
[13:24:36.744]                             if (is.null(name)) 
[13:24:36.744]                               next
[13:24:36.744]                             if (!grepl(pattern, name)) 
[13:24:36.744]                               next
[13:24:36.744]                             invokeRestart(restart)
[13:24:36.744]                             muffled <- TRUE
[13:24:36.744]                             break
[13:24:36.744]                           }
[13:24:36.744]                         }
[13:24:36.744]                       }
[13:24:36.744]                       invisible(muffled)
[13:24:36.744]                     }
[13:24:36.744]                     muffleCondition(cond, pattern = "^muffle")
[13:24:36.744]                   }
[13:24:36.744]                 }
[13:24:36.744]             }
[13:24:36.744]         }))
[13:24:36.744]     }, error = function(ex) {
[13:24:36.744]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:36.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:36.744]                 ...future.rng), started = ...future.startTime, 
[13:24:36.744]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:36.744]             version = "1.8"), class = "FutureResult")
[13:24:36.744]     }, finally = {
[13:24:36.744]         if (!identical(...future.workdir, getwd())) 
[13:24:36.744]             setwd(...future.workdir)
[13:24:36.744]         {
[13:24:36.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:36.744]                 ...future.oldOptions$nwarnings <- NULL
[13:24:36.744]             }
[13:24:36.744]             base::options(...future.oldOptions)
[13:24:36.744]             if (.Platform$OS.type == "windows") {
[13:24:36.744]                 old_names <- names(...future.oldEnvVars)
[13:24:36.744]                 envs <- base::Sys.getenv()
[13:24:36.744]                 names <- names(envs)
[13:24:36.744]                 common <- intersect(names, old_names)
[13:24:36.744]                 added <- setdiff(names, old_names)
[13:24:36.744]                 removed <- setdiff(old_names, names)
[13:24:36.744]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:36.744]                   envs[common]]
[13:24:36.744]                 NAMES <- toupper(changed)
[13:24:36.744]                 args <- list()
[13:24:36.744]                 for (kk in seq_along(NAMES)) {
[13:24:36.744]                   name <- changed[[kk]]
[13:24:36.744]                   NAME <- NAMES[[kk]]
[13:24:36.744]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.744]                     next
[13:24:36.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.744]                 }
[13:24:36.744]                 NAMES <- toupper(added)
[13:24:36.744]                 for (kk in seq_along(NAMES)) {
[13:24:36.744]                   name <- added[[kk]]
[13:24:36.744]                   NAME <- NAMES[[kk]]
[13:24:36.744]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.744]                     next
[13:24:36.744]                   args[[name]] <- ""
[13:24:36.744]                 }
[13:24:36.744]                 NAMES <- toupper(removed)
[13:24:36.744]                 for (kk in seq_along(NAMES)) {
[13:24:36.744]                   name <- removed[[kk]]
[13:24:36.744]                   NAME <- NAMES[[kk]]
[13:24:36.744]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:36.744]                     next
[13:24:36.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:36.744]                 }
[13:24:36.744]                 if (length(args) > 0) 
[13:24:36.744]                   base::do.call(base::Sys.setenv, args = args)
[13:24:36.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:36.744]             }
[13:24:36.744]             else {
[13:24:36.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:36.744]             }
[13:24:36.744]             {
[13:24:36.744]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:36.744]                   0L) {
[13:24:36.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:36.744]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:36.744]                   base::options(opts)
[13:24:36.744]                 }
[13:24:36.744]                 {
[13:24:36.744]                   {
[13:24:36.744]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:36.744]                     NULL
[13:24:36.744]                   }
[13:24:36.744]                   options(future.plan = NULL)
[13:24:36.744]                   if (is.na(NA_character_)) 
[13:24:36.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:36.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:36.744]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:36.744]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:36.744]                     envir = parent.frame()) 
[13:24:36.744]                   {
[13:24:36.744]                     if (is.function(workers)) 
[13:24:36.744]                       workers <- workers()
[13:24:36.744]                     workers <- structure(as.integer(workers), 
[13:24:36.744]                       class = class(workers))
[13:24:36.744]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:36.744]                       workers >= 1)
[13:24:36.744]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:36.744]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:36.744]                     }
[13:24:36.744]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:36.744]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:36.744]                       envir = envir)
[13:24:36.744]                     if (!future$lazy) 
[13:24:36.744]                       future <- run(future)
[13:24:36.744]                     invisible(future)
[13:24:36.744]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:36.744]                 }
[13:24:36.744]             }
[13:24:36.744]         }
[13:24:36.744]     })
[13:24:36.744]     if (TRUE) {
[13:24:36.744]         base::sink(type = "output", split = FALSE)
[13:24:36.744]         if (TRUE) {
[13:24:36.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:36.744]         }
[13:24:36.744]         else {
[13:24:36.744]             ...future.result["stdout"] <- base::list(NULL)
[13:24:36.744]         }
[13:24:36.744]         base::close(...future.stdout)
[13:24:36.744]         ...future.stdout <- NULL
[13:24:36.744]     }
[13:24:36.744]     ...future.result$conditions <- ...future.conditions
[13:24:36.744]     ...future.result$finished <- base::Sys.time()
[13:24:36.744]     ...future.result
[13:24:36.744] }
[13:24:36.748] MultisessionFuture started
[13:24:36.748] - Launch lazy future ... done
[13:24:36.748] run() for ‘MultisessionFuture’ ... done
[13:24:37.294] receiveMessageFromWorker() for ClusterFuture ...
[13:24:37.294] - Validating connection of MultisessionFuture
[13:24:37.294] - received message: FutureResult
[13:24:37.294] - Received FutureResult
[13:24:37.295] - Erased future from FutureRegistry
[13:24:37.295] result() for ClusterFuture ...
[13:24:37.295] - result already collected: FutureResult
[13:24:37.295] result() for ClusterFuture ... done
[13:24:37.295] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:37.295] A MultisessionFuture was resolved
- w/ exception ...
[13:24:37.295] getGlobalsAndPackages() ...
[13:24:37.295] Searching for globals...
[13:24:37.296] - globals found: [2] ‘list’, ‘stop’
[13:24:37.296] Searching for globals ... DONE
[13:24:37.296] Resolving globals: FALSE
[13:24:37.297] 
[13:24:37.297] 
[13:24:37.297] getGlobalsAndPackages() ... DONE
[13:24:37.297] run() for ‘Future’ ...
[13:24:37.297] - state: ‘created’
[13:24:37.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:37.311] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:37.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:37.312]   - Field: ‘node’
[13:24:37.312]   - Field: ‘label’
[13:24:37.312]   - Field: ‘local’
[13:24:37.312]   - Field: ‘owner’
[13:24:37.312]   - Field: ‘envir’
[13:24:37.312]   - Field: ‘workers’
[13:24:37.312]   - Field: ‘packages’
[13:24:37.312]   - Field: ‘gc’
[13:24:37.312]   - Field: ‘conditions’
[13:24:37.312]   - Field: ‘persistent’
[13:24:37.313]   - Field: ‘expr’
[13:24:37.313]   - Field: ‘uuid’
[13:24:37.313]   - Field: ‘seed’
[13:24:37.313]   - Field: ‘version’
[13:24:37.313]   - Field: ‘result’
[13:24:37.313]   - Field: ‘asynchronous’
[13:24:37.313]   - Field: ‘calls’
[13:24:37.313]   - Field: ‘globals’
[13:24:37.313]   - Field: ‘stdout’
[13:24:37.313]   - Field: ‘earlySignal’
[13:24:37.313]   - Field: ‘lazy’
[13:24:37.314]   - Field: ‘state’
[13:24:37.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:37.314] - Launch lazy future ...
[13:24:37.314] Packages needed by the future expression (n = 0): <none>
[13:24:37.314] Packages needed by future strategies (n = 0): <none>
[13:24:37.315] {
[13:24:37.315]     {
[13:24:37.315]         {
[13:24:37.315]             ...future.startTime <- base::Sys.time()
[13:24:37.315]             {
[13:24:37.315]                 {
[13:24:37.315]                   {
[13:24:37.315]                     {
[13:24:37.315]                       base::local({
[13:24:37.315]                         has_future <- base::requireNamespace("future", 
[13:24:37.315]                           quietly = TRUE)
[13:24:37.315]                         if (has_future) {
[13:24:37.315]                           ns <- base::getNamespace("future")
[13:24:37.315]                           version <- ns[[".package"]][["version"]]
[13:24:37.315]                           if (is.null(version)) 
[13:24:37.315]                             version <- utils::packageVersion("future")
[13:24:37.315]                         }
[13:24:37.315]                         else {
[13:24:37.315]                           version <- NULL
[13:24:37.315]                         }
[13:24:37.315]                         if (!has_future || version < "1.8.0") {
[13:24:37.315]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:37.315]                             "", base::R.version$version.string), 
[13:24:37.315]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:37.315]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:37.315]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:37.315]                               "release", "version")], collapse = " "), 
[13:24:37.315]                             hostname = base::Sys.info()[["nodename"]])
[13:24:37.315]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:37.315]                             info)
[13:24:37.315]                           info <- base::paste(info, collapse = "; ")
[13:24:37.315]                           if (!has_future) {
[13:24:37.315]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:37.315]                               info)
[13:24:37.315]                           }
[13:24:37.315]                           else {
[13:24:37.315]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:37.315]                               info, version)
[13:24:37.315]                           }
[13:24:37.315]                           base::stop(msg)
[13:24:37.315]                         }
[13:24:37.315]                       })
[13:24:37.315]                     }
[13:24:37.315]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:37.315]                     base::options(mc.cores = 1L)
[13:24:37.315]                   }
[13:24:37.315]                   options(future.plan = NULL)
[13:24:37.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:37.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:37.315]                 }
[13:24:37.315]                 ...future.workdir <- getwd()
[13:24:37.315]             }
[13:24:37.315]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:37.315]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:37.315]         }
[13:24:37.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:37.315]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:37.315]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:37.315]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:37.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:37.315]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:37.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:37.315]             base::names(...future.oldOptions))
[13:24:37.315]     }
[13:24:37.315]     if (FALSE) {
[13:24:37.315]     }
[13:24:37.315]     else {
[13:24:37.315]         if (TRUE) {
[13:24:37.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:37.315]                 open = "w")
[13:24:37.315]         }
[13:24:37.315]         else {
[13:24:37.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:37.315]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:37.315]         }
[13:24:37.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:37.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:37.315]             base::sink(type = "output", split = FALSE)
[13:24:37.315]             base::close(...future.stdout)
[13:24:37.315]         }, add = TRUE)
[13:24:37.315]     }
[13:24:37.315]     ...future.frame <- base::sys.nframe()
[13:24:37.315]     ...future.conditions <- base::list()
[13:24:37.315]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:37.315]     if (FALSE) {
[13:24:37.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:37.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:37.315]     }
[13:24:37.315]     ...future.result <- base::tryCatch({
[13:24:37.315]         base::withCallingHandlers({
[13:24:37.315]             ...future.value <- base::withVisible(base::local({
[13:24:37.315]                 ...future.makeSendCondition <- base::local({
[13:24:37.315]                   sendCondition <- NULL
[13:24:37.315]                   function(frame = 1L) {
[13:24:37.315]                     if (is.function(sendCondition)) 
[13:24:37.315]                       return(sendCondition)
[13:24:37.315]                     ns <- getNamespace("parallel")
[13:24:37.315]                     if (exists("sendData", mode = "function", 
[13:24:37.315]                       envir = ns)) {
[13:24:37.315]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:37.315]                         envir = ns)
[13:24:37.315]                       envir <- sys.frame(frame)
[13:24:37.315]                       master <- NULL
[13:24:37.315]                       while (!identical(envir, .GlobalEnv) && 
[13:24:37.315]                         !identical(envir, emptyenv())) {
[13:24:37.315]                         if (exists("master", mode = "list", envir = envir, 
[13:24:37.315]                           inherits = FALSE)) {
[13:24:37.315]                           master <- get("master", mode = "list", 
[13:24:37.315]                             envir = envir, inherits = FALSE)
[13:24:37.315]                           if (inherits(master, c("SOCKnode", 
[13:24:37.315]                             "SOCK0node"))) {
[13:24:37.315]                             sendCondition <<- function(cond) {
[13:24:37.315]                               data <- list(type = "VALUE", value = cond, 
[13:24:37.315]                                 success = TRUE)
[13:24:37.315]                               parallel_sendData(master, data)
[13:24:37.315]                             }
[13:24:37.315]                             return(sendCondition)
[13:24:37.315]                           }
[13:24:37.315]                         }
[13:24:37.315]                         frame <- frame + 1L
[13:24:37.315]                         envir <- sys.frame(frame)
[13:24:37.315]                       }
[13:24:37.315]                     }
[13:24:37.315]                     sendCondition <<- function(cond) NULL
[13:24:37.315]                   }
[13:24:37.315]                 })
[13:24:37.315]                 withCallingHandlers({
[13:24:37.315]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:37.315]                 }, immediateCondition = function(cond) {
[13:24:37.315]                   sendCondition <- ...future.makeSendCondition()
[13:24:37.315]                   sendCondition(cond)
[13:24:37.315]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.315]                   {
[13:24:37.315]                     inherits <- base::inherits
[13:24:37.315]                     invokeRestart <- base::invokeRestart
[13:24:37.315]                     is.null <- base::is.null
[13:24:37.315]                     muffled <- FALSE
[13:24:37.315]                     if (inherits(cond, "message")) {
[13:24:37.315]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:37.315]                       if (muffled) 
[13:24:37.315]                         invokeRestart("muffleMessage")
[13:24:37.315]                     }
[13:24:37.315]                     else if (inherits(cond, "warning")) {
[13:24:37.315]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:37.315]                       if (muffled) 
[13:24:37.315]                         invokeRestart("muffleWarning")
[13:24:37.315]                     }
[13:24:37.315]                     else if (inherits(cond, "condition")) {
[13:24:37.315]                       if (!is.null(pattern)) {
[13:24:37.315]                         computeRestarts <- base::computeRestarts
[13:24:37.315]                         grepl <- base::grepl
[13:24:37.315]                         restarts <- computeRestarts(cond)
[13:24:37.315]                         for (restart in restarts) {
[13:24:37.315]                           name <- restart$name
[13:24:37.315]                           if (is.null(name)) 
[13:24:37.315]                             next
[13:24:37.315]                           if (!grepl(pattern, name)) 
[13:24:37.315]                             next
[13:24:37.315]                           invokeRestart(restart)
[13:24:37.315]                           muffled <- TRUE
[13:24:37.315]                           break
[13:24:37.315]                         }
[13:24:37.315]                       }
[13:24:37.315]                     }
[13:24:37.315]                     invisible(muffled)
[13:24:37.315]                   }
[13:24:37.315]                   muffleCondition(cond)
[13:24:37.315]                 })
[13:24:37.315]             }))
[13:24:37.315]             future::FutureResult(value = ...future.value$value, 
[13:24:37.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:37.315]                   ...future.rng), globalenv = if (FALSE) 
[13:24:37.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:37.315]                     ...future.globalenv.names))
[13:24:37.315]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:37.315]         }, condition = base::local({
[13:24:37.315]             c <- base::c
[13:24:37.315]             inherits <- base::inherits
[13:24:37.315]             invokeRestart <- base::invokeRestart
[13:24:37.315]             length <- base::length
[13:24:37.315]             list <- base::list
[13:24:37.315]             seq.int <- base::seq.int
[13:24:37.315]             signalCondition <- base::signalCondition
[13:24:37.315]             sys.calls <- base::sys.calls
[13:24:37.315]             `[[` <- base::`[[`
[13:24:37.315]             `+` <- base::`+`
[13:24:37.315]             `<<-` <- base::`<<-`
[13:24:37.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:37.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:37.315]                   3L)]
[13:24:37.315]             }
[13:24:37.315]             function(cond) {
[13:24:37.315]                 is_error <- inherits(cond, "error")
[13:24:37.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:37.315]                   NULL)
[13:24:37.315]                 if (is_error) {
[13:24:37.315]                   sessionInformation <- function() {
[13:24:37.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:37.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:37.315]                       search = base::search(), system = base::Sys.info())
[13:24:37.315]                   }
[13:24:37.315]                   ...future.conditions[[length(...future.conditions) + 
[13:24:37.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:37.315]                     cond$call), session = sessionInformation(), 
[13:24:37.315]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:37.315]                   signalCondition(cond)
[13:24:37.315]                 }
[13:24:37.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:37.315]                 "immediateCondition"))) {
[13:24:37.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:37.315]                   ...future.conditions[[length(...future.conditions) + 
[13:24:37.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:37.315]                   if (TRUE && !signal) {
[13:24:37.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.315]                     {
[13:24:37.315]                       inherits <- base::inherits
[13:24:37.315]                       invokeRestart <- base::invokeRestart
[13:24:37.315]                       is.null <- base::is.null
[13:24:37.315]                       muffled <- FALSE
[13:24:37.315]                       if (inherits(cond, "message")) {
[13:24:37.315]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:37.315]                         if (muffled) 
[13:24:37.315]                           invokeRestart("muffleMessage")
[13:24:37.315]                       }
[13:24:37.315]                       else if (inherits(cond, "warning")) {
[13:24:37.315]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:37.315]                         if (muffled) 
[13:24:37.315]                           invokeRestart("muffleWarning")
[13:24:37.315]                       }
[13:24:37.315]                       else if (inherits(cond, "condition")) {
[13:24:37.315]                         if (!is.null(pattern)) {
[13:24:37.315]                           computeRestarts <- base::computeRestarts
[13:24:37.315]                           grepl <- base::grepl
[13:24:37.315]                           restarts <- computeRestarts(cond)
[13:24:37.315]                           for (restart in restarts) {
[13:24:37.315]                             name <- restart$name
[13:24:37.315]                             if (is.null(name)) 
[13:24:37.315]                               next
[13:24:37.315]                             if (!grepl(pattern, name)) 
[13:24:37.315]                               next
[13:24:37.315]                             invokeRestart(restart)
[13:24:37.315]                             muffled <- TRUE
[13:24:37.315]                             break
[13:24:37.315]                           }
[13:24:37.315]                         }
[13:24:37.315]                       }
[13:24:37.315]                       invisible(muffled)
[13:24:37.315]                     }
[13:24:37.315]                     muffleCondition(cond, pattern = "^muffle")
[13:24:37.315]                   }
[13:24:37.315]                 }
[13:24:37.315]                 else {
[13:24:37.315]                   if (TRUE) {
[13:24:37.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.315]                     {
[13:24:37.315]                       inherits <- base::inherits
[13:24:37.315]                       invokeRestart <- base::invokeRestart
[13:24:37.315]                       is.null <- base::is.null
[13:24:37.315]                       muffled <- FALSE
[13:24:37.315]                       if (inherits(cond, "message")) {
[13:24:37.315]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:37.315]                         if (muffled) 
[13:24:37.315]                           invokeRestart("muffleMessage")
[13:24:37.315]                       }
[13:24:37.315]                       else if (inherits(cond, "warning")) {
[13:24:37.315]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:37.315]                         if (muffled) 
[13:24:37.315]                           invokeRestart("muffleWarning")
[13:24:37.315]                       }
[13:24:37.315]                       else if (inherits(cond, "condition")) {
[13:24:37.315]                         if (!is.null(pattern)) {
[13:24:37.315]                           computeRestarts <- base::computeRestarts
[13:24:37.315]                           grepl <- base::grepl
[13:24:37.315]                           restarts <- computeRestarts(cond)
[13:24:37.315]                           for (restart in restarts) {
[13:24:37.315]                             name <- restart$name
[13:24:37.315]                             if (is.null(name)) 
[13:24:37.315]                               next
[13:24:37.315]                             if (!grepl(pattern, name)) 
[13:24:37.315]                               next
[13:24:37.315]                             invokeRestart(restart)
[13:24:37.315]                             muffled <- TRUE
[13:24:37.315]                             break
[13:24:37.315]                           }
[13:24:37.315]                         }
[13:24:37.315]                       }
[13:24:37.315]                       invisible(muffled)
[13:24:37.315]                     }
[13:24:37.315]                     muffleCondition(cond, pattern = "^muffle")
[13:24:37.315]                   }
[13:24:37.315]                 }
[13:24:37.315]             }
[13:24:37.315]         }))
[13:24:37.315]     }, error = function(ex) {
[13:24:37.315]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:37.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:37.315]                 ...future.rng), started = ...future.startTime, 
[13:24:37.315]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:37.315]             version = "1.8"), class = "FutureResult")
[13:24:37.315]     }, finally = {
[13:24:37.315]         if (!identical(...future.workdir, getwd())) 
[13:24:37.315]             setwd(...future.workdir)
[13:24:37.315]         {
[13:24:37.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:37.315]                 ...future.oldOptions$nwarnings <- NULL
[13:24:37.315]             }
[13:24:37.315]             base::options(...future.oldOptions)
[13:24:37.315]             if (.Platform$OS.type == "windows") {
[13:24:37.315]                 old_names <- names(...future.oldEnvVars)
[13:24:37.315]                 envs <- base::Sys.getenv()
[13:24:37.315]                 names <- names(envs)
[13:24:37.315]                 common <- intersect(names, old_names)
[13:24:37.315]                 added <- setdiff(names, old_names)
[13:24:37.315]                 removed <- setdiff(old_names, names)
[13:24:37.315]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:37.315]                   envs[common]]
[13:24:37.315]                 NAMES <- toupper(changed)
[13:24:37.315]                 args <- list()
[13:24:37.315]                 for (kk in seq_along(NAMES)) {
[13:24:37.315]                   name <- changed[[kk]]
[13:24:37.315]                   NAME <- NAMES[[kk]]
[13:24:37.315]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.315]                     next
[13:24:37.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:37.315]                 }
[13:24:37.315]                 NAMES <- toupper(added)
[13:24:37.315]                 for (kk in seq_along(NAMES)) {
[13:24:37.315]                   name <- added[[kk]]
[13:24:37.315]                   NAME <- NAMES[[kk]]
[13:24:37.315]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.315]                     next
[13:24:37.315]                   args[[name]] <- ""
[13:24:37.315]                 }
[13:24:37.315]                 NAMES <- toupper(removed)
[13:24:37.315]                 for (kk in seq_along(NAMES)) {
[13:24:37.315]                   name <- removed[[kk]]
[13:24:37.315]                   NAME <- NAMES[[kk]]
[13:24:37.315]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.315]                     next
[13:24:37.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:37.315]                 }
[13:24:37.315]                 if (length(args) > 0) 
[13:24:37.315]                   base::do.call(base::Sys.setenv, args = args)
[13:24:37.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:37.315]             }
[13:24:37.315]             else {
[13:24:37.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:37.315]             }
[13:24:37.315]             {
[13:24:37.315]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:37.315]                   0L) {
[13:24:37.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:37.315]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:37.315]                   base::options(opts)
[13:24:37.315]                 }
[13:24:37.315]                 {
[13:24:37.315]                   {
[13:24:37.315]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:37.315]                     NULL
[13:24:37.315]                   }
[13:24:37.315]                   options(future.plan = NULL)
[13:24:37.315]                   if (is.na(NA_character_)) 
[13:24:37.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:37.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:37.315]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:37.315]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:37.315]                     envir = parent.frame()) 
[13:24:37.315]                   {
[13:24:37.315]                     if (is.function(workers)) 
[13:24:37.315]                       workers <- workers()
[13:24:37.315]                     workers <- structure(as.integer(workers), 
[13:24:37.315]                       class = class(workers))
[13:24:37.315]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:37.315]                       workers >= 1)
[13:24:37.315]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:37.315]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:37.315]                     }
[13:24:37.315]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:37.315]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:37.315]                       envir = envir)
[13:24:37.315]                     if (!future$lazy) 
[13:24:37.315]                       future <- run(future)
[13:24:37.315]                     invisible(future)
[13:24:37.315]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:37.315]                 }
[13:24:37.315]             }
[13:24:37.315]         }
[13:24:37.315]     })
[13:24:37.315]     if (TRUE) {
[13:24:37.315]         base::sink(type = "output", split = FALSE)
[13:24:37.315]         if (TRUE) {
[13:24:37.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:37.315]         }
[13:24:37.315]         else {
[13:24:37.315]             ...future.result["stdout"] <- base::list(NULL)
[13:24:37.315]         }
[13:24:37.315]         base::close(...future.stdout)
[13:24:37.315]         ...future.stdout <- NULL
[13:24:37.315]     }
[13:24:37.315]     ...future.result$conditions <- ...future.conditions
[13:24:37.315]     ...future.result$finished <- base::Sys.time()
[13:24:37.315]     ...future.result
[13:24:37.315] }
[13:24:37.318] MultisessionFuture started
[13:24:37.318] - Launch lazy future ... done
[13:24:37.318] run() for ‘MultisessionFuture’ ... done
[13:24:37.365] receiveMessageFromWorker() for ClusterFuture ...
[13:24:37.365] - Validating connection of MultisessionFuture
[13:24:37.366] - received message: FutureResult
[13:24:37.366] - Received FutureResult
[13:24:37.366] - Erased future from FutureRegistry
[13:24:37.366] result() for ClusterFuture ...
[13:24:37.366] - result already collected: FutureResult
[13:24:37.366] result() for ClusterFuture ... done
[13:24:37.366] signalConditions() ...
[13:24:37.367]  - include = ‘immediateCondition’
[13:24:37.367]  - exclude = 
[13:24:37.367]  - resignal = FALSE
[13:24:37.367]  - Number of conditions: 1
[13:24:37.367] signalConditions() ... done
[13:24:37.367] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:37.367] A MultisessionFuture was resolved
[13:24:37.367] getGlobalsAndPackages() ...
[13:24:37.367] Searching for globals...
[13:24:37.368] - globals found: [2] ‘list’, ‘stop’
[13:24:37.368] Searching for globals ... DONE
[13:24:37.368] Resolving globals: FALSE
[13:24:37.369] 
[13:24:37.369] 
[13:24:37.369] getGlobalsAndPackages() ... DONE
[13:24:37.369] run() for ‘Future’ ...
[13:24:37.369] - state: ‘created’
[13:24:37.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:37.383] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:37.383] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:37.383]   - Field: ‘node’
[13:24:37.383]   - Field: ‘label’
[13:24:37.384]   - Field: ‘local’
[13:24:37.384]   - Field: ‘owner’
[13:24:37.384]   - Field: ‘envir’
[13:24:37.384]   - Field: ‘workers’
[13:24:37.384]   - Field: ‘packages’
[13:24:37.384]   - Field: ‘gc’
[13:24:37.384]   - Field: ‘conditions’
[13:24:37.384]   - Field: ‘persistent’
[13:24:37.384]   - Field: ‘expr’
[13:24:37.384]   - Field: ‘uuid’
[13:24:37.385]   - Field: ‘seed’
[13:24:37.385]   - Field: ‘version’
[13:24:37.385]   - Field: ‘result’
[13:24:37.385]   - Field: ‘asynchronous’
[13:24:37.385]   - Field: ‘calls’
[13:24:37.385]   - Field: ‘globals’
[13:24:37.385]   - Field: ‘stdout’
[13:24:37.385]   - Field: ‘earlySignal’
[13:24:37.385]   - Field: ‘lazy’
[13:24:37.385]   - Field: ‘state’
[13:24:37.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:37.386] - Launch lazy future ...
[13:24:37.386] Packages needed by the future expression (n = 0): <none>
[13:24:37.386] Packages needed by future strategies (n = 0): <none>
[13:24:37.386] {
[13:24:37.386]     {
[13:24:37.386]         {
[13:24:37.386]             ...future.startTime <- base::Sys.time()
[13:24:37.386]             {
[13:24:37.386]                 {
[13:24:37.386]                   {
[13:24:37.386]                     {
[13:24:37.386]                       base::local({
[13:24:37.386]                         has_future <- base::requireNamespace("future", 
[13:24:37.386]                           quietly = TRUE)
[13:24:37.386]                         if (has_future) {
[13:24:37.386]                           ns <- base::getNamespace("future")
[13:24:37.386]                           version <- ns[[".package"]][["version"]]
[13:24:37.386]                           if (is.null(version)) 
[13:24:37.386]                             version <- utils::packageVersion("future")
[13:24:37.386]                         }
[13:24:37.386]                         else {
[13:24:37.386]                           version <- NULL
[13:24:37.386]                         }
[13:24:37.386]                         if (!has_future || version < "1.8.0") {
[13:24:37.386]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:37.386]                             "", base::R.version$version.string), 
[13:24:37.386]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:37.386]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:37.386]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:37.386]                               "release", "version")], collapse = " "), 
[13:24:37.386]                             hostname = base::Sys.info()[["nodename"]])
[13:24:37.386]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:37.386]                             info)
[13:24:37.386]                           info <- base::paste(info, collapse = "; ")
[13:24:37.386]                           if (!has_future) {
[13:24:37.386]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:37.386]                               info)
[13:24:37.386]                           }
[13:24:37.386]                           else {
[13:24:37.386]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:37.386]                               info, version)
[13:24:37.386]                           }
[13:24:37.386]                           base::stop(msg)
[13:24:37.386]                         }
[13:24:37.386]                       })
[13:24:37.386]                     }
[13:24:37.386]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:37.386]                     base::options(mc.cores = 1L)
[13:24:37.386]                   }
[13:24:37.386]                   options(future.plan = NULL)
[13:24:37.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:37.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:37.386]                 }
[13:24:37.386]                 ...future.workdir <- getwd()
[13:24:37.386]             }
[13:24:37.386]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:37.386]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:37.386]         }
[13:24:37.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:37.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:37.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:37.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:37.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:37.386]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:37.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:37.386]             base::names(...future.oldOptions))
[13:24:37.386]     }
[13:24:37.386]     if (FALSE) {
[13:24:37.386]     }
[13:24:37.386]     else {
[13:24:37.386]         if (TRUE) {
[13:24:37.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:37.386]                 open = "w")
[13:24:37.386]         }
[13:24:37.386]         else {
[13:24:37.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:37.386]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:37.386]         }
[13:24:37.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:37.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:37.386]             base::sink(type = "output", split = FALSE)
[13:24:37.386]             base::close(...future.stdout)
[13:24:37.386]         }, add = TRUE)
[13:24:37.386]     }
[13:24:37.386]     ...future.frame <- base::sys.nframe()
[13:24:37.386]     ...future.conditions <- base::list()
[13:24:37.386]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:37.386]     if (FALSE) {
[13:24:37.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:37.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:37.386]     }
[13:24:37.386]     ...future.result <- base::tryCatch({
[13:24:37.386]         base::withCallingHandlers({
[13:24:37.386]             ...future.value <- base::withVisible(base::local({
[13:24:37.386]                 ...future.makeSendCondition <- base::local({
[13:24:37.386]                   sendCondition <- NULL
[13:24:37.386]                   function(frame = 1L) {
[13:24:37.386]                     if (is.function(sendCondition)) 
[13:24:37.386]                       return(sendCondition)
[13:24:37.386]                     ns <- getNamespace("parallel")
[13:24:37.386]                     if (exists("sendData", mode = "function", 
[13:24:37.386]                       envir = ns)) {
[13:24:37.386]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:37.386]                         envir = ns)
[13:24:37.386]                       envir <- sys.frame(frame)
[13:24:37.386]                       master <- NULL
[13:24:37.386]                       while (!identical(envir, .GlobalEnv) && 
[13:24:37.386]                         !identical(envir, emptyenv())) {
[13:24:37.386]                         if (exists("master", mode = "list", envir = envir, 
[13:24:37.386]                           inherits = FALSE)) {
[13:24:37.386]                           master <- get("master", mode = "list", 
[13:24:37.386]                             envir = envir, inherits = FALSE)
[13:24:37.386]                           if (inherits(master, c("SOCKnode", 
[13:24:37.386]                             "SOCK0node"))) {
[13:24:37.386]                             sendCondition <<- function(cond) {
[13:24:37.386]                               data <- list(type = "VALUE", value = cond, 
[13:24:37.386]                                 success = TRUE)
[13:24:37.386]                               parallel_sendData(master, data)
[13:24:37.386]                             }
[13:24:37.386]                             return(sendCondition)
[13:24:37.386]                           }
[13:24:37.386]                         }
[13:24:37.386]                         frame <- frame + 1L
[13:24:37.386]                         envir <- sys.frame(frame)
[13:24:37.386]                       }
[13:24:37.386]                     }
[13:24:37.386]                     sendCondition <<- function(cond) NULL
[13:24:37.386]                   }
[13:24:37.386]                 })
[13:24:37.386]                 withCallingHandlers({
[13:24:37.386]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:37.386]                 }, immediateCondition = function(cond) {
[13:24:37.386]                   sendCondition <- ...future.makeSendCondition()
[13:24:37.386]                   sendCondition(cond)
[13:24:37.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.386]                   {
[13:24:37.386]                     inherits <- base::inherits
[13:24:37.386]                     invokeRestart <- base::invokeRestart
[13:24:37.386]                     is.null <- base::is.null
[13:24:37.386]                     muffled <- FALSE
[13:24:37.386]                     if (inherits(cond, "message")) {
[13:24:37.386]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:37.386]                       if (muffled) 
[13:24:37.386]                         invokeRestart("muffleMessage")
[13:24:37.386]                     }
[13:24:37.386]                     else if (inherits(cond, "warning")) {
[13:24:37.386]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:37.386]                       if (muffled) 
[13:24:37.386]                         invokeRestart("muffleWarning")
[13:24:37.386]                     }
[13:24:37.386]                     else if (inherits(cond, "condition")) {
[13:24:37.386]                       if (!is.null(pattern)) {
[13:24:37.386]                         computeRestarts <- base::computeRestarts
[13:24:37.386]                         grepl <- base::grepl
[13:24:37.386]                         restarts <- computeRestarts(cond)
[13:24:37.386]                         for (restart in restarts) {
[13:24:37.386]                           name <- restart$name
[13:24:37.386]                           if (is.null(name)) 
[13:24:37.386]                             next
[13:24:37.386]                           if (!grepl(pattern, name)) 
[13:24:37.386]                             next
[13:24:37.386]                           invokeRestart(restart)
[13:24:37.386]                           muffled <- TRUE
[13:24:37.386]                           break
[13:24:37.386]                         }
[13:24:37.386]                       }
[13:24:37.386]                     }
[13:24:37.386]                     invisible(muffled)
[13:24:37.386]                   }
[13:24:37.386]                   muffleCondition(cond)
[13:24:37.386]                 })
[13:24:37.386]             }))
[13:24:37.386]             future::FutureResult(value = ...future.value$value, 
[13:24:37.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:37.386]                   ...future.rng), globalenv = if (FALSE) 
[13:24:37.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:37.386]                     ...future.globalenv.names))
[13:24:37.386]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:37.386]         }, condition = base::local({
[13:24:37.386]             c <- base::c
[13:24:37.386]             inherits <- base::inherits
[13:24:37.386]             invokeRestart <- base::invokeRestart
[13:24:37.386]             length <- base::length
[13:24:37.386]             list <- base::list
[13:24:37.386]             seq.int <- base::seq.int
[13:24:37.386]             signalCondition <- base::signalCondition
[13:24:37.386]             sys.calls <- base::sys.calls
[13:24:37.386]             `[[` <- base::`[[`
[13:24:37.386]             `+` <- base::`+`
[13:24:37.386]             `<<-` <- base::`<<-`
[13:24:37.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:37.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:37.386]                   3L)]
[13:24:37.386]             }
[13:24:37.386]             function(cond) {
[13:24:37.386]                 is_error <- inherits(cond, "error")
[13:24:37.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:37.386]                   NULL)
[13:24:37.386]                 if (is_error) {
[13:24:37.386]                   sessionInformation <- function() {
[13:24:37.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:37.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:37.386]                       search = base::search(), system = base::Sys.info())
[13:24:37.386]                   }
[13:24:37.386]                   ...future.conditions[[length(...future.conditions) + 
[13:24:37.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:37.386]                     cond$call), session = sessionInformation(), 
[13:24:37.386]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:37.386]                   signalCondition(cond)
[13:24:37.386]                 }
[13:24:37.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:37.386]                 "immediateCondition"))) {
[13:24:37.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:37.386]                   ...future.conditions[[length(...future.conditions) + 
[13:24:37.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:37.386]                   if (TRUE && !signal) {
[13:24:37.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.386]                     {
[13:24:37.386]                       inherits <- base::inherits
[13:24:37.386]                       invokeRestart <- base::invokeRestart
[13:24:37.386]                       is.null <- base::is.null
[13:24:37.386]                       muffled <- FALSE
[13:24:37.386]                       if (inherits(cond, "message")) {
[13:24:37.386]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:37.386]                         if (muffled) 
[13:24:37.386]                           invokeRestart("muffleMessage")
[13:24:37.386]                       }
[13:24:37.386]                       else if (inherits(cond, "warning")) {
[13:24:37.386]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:37.386]                         if (muffled) 
[13:24:37.386]                           invokeRestart("muffleWarning")
[13:24:37.386]                       }
[13:24:37.386]                       else if (inherits(cond, "condition")) {
[13:24:37.386]                         if (!is.null(pattern)) {
[13:24:37.386]                           computeRestarts <- base::computeRestarts
[13:24:37.386]                           grepl <- base::grepl
[13:24:37.386]                           restarts <- computeRestarts(cond)
[13:24:37.386]                           for (restart in restarts) {
[13:24:37.386]                             name <- restart$name
[13:24:37.386]                             if (is.null(name)) 
[13:24:37.386]                               next
[13:24:37.386]                             if (!grepl(pattern, name)) 
[13:24:37.386]                               next
[13:24:37.386]                             invokeRestart(restart)
[13:24:37.386]                             muffled <- TRUE
[13:24:37.386]                             break
[13:24:37.386]                           }
[13:24:37.386]                         }
[13:24:37.386]                       }
[13:24:37.386]                       invisible(muffled)
[13:24:37.386]                     }
[13:24:37.386]                     muffleCondition(cond, pattern = "^muffle")
[13:24:37.386]                   }
[13:24:37.386]                 }
[13:24:37.386]                 else {
[13:24:37.386]                   if (TRUE) {
[13:24:37.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.386]                     {
[13:24:37.386]                       inherits <- base::inherits
[13:24:37.386]                       invokeRestart <- base::invokeRestart
[13:24:37.386]                       is.null <- base::is.null
[13:24:37.386]                       muffled <- FALSE
[13:24:37.386]                       if (inherits(cond, "message")) {
[13:24:37.386]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:37.386]                         if (muffled) 
[13:24:37.386]                           invokeRestart("muffleMessage")
[13:24:37.386]                       }
[13:24:37.386]                       else if (inherits(cond, "warning")) {
[13:24:37.386]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:37.386]                         if (muffled) 
[13:24:37.386]                           invokeRestart("muffleWarning")
[13:24:37.386]                       }
[13:24:37.386]                       else if (inherits(cond, "condition")) {
[13:24:37.386]                         if (!is.null(pattern)) {
[13:24:37.386]                           computeRestarts <- base::computeRestarts
[13:24:37.386]                           grepl <- base::grepl
[13:24:37.386]                           restarts <- computeRestarts(cond)
[13:24:37.386]                           for (restart in restarts) {
[13:24:37.386]                             name <- restart$name
[13:24:37.386]                             if (is.null(name)) 
[13:24:37.386]                               next
[13:24:37.386]                             if (!grepl(pattern, name)) 
[13:24:37.386]                               next
[13:24:37.386]                             invokeRestart(restart)
[13:24:37.386]                             muffled <- TRUE
[13:24:37.386]                             break
[13:24:37.386]                           }
[13:24:37.386]                         }
[13:24:37.386]                       }
[13:24:37.386]                       invisible(muffled)
[13:24:37.386]                     }
[13:24:37.386]                     muffleCondition(cond, pattern = "^muffle")
[13:24:37.386]                   }
[13:24:37.386]                 }
[13:24:37.386]             }
[13:24:37.386]         }))
[13:24:37.386]     }, error = function(ex) {
[13:24:37.386]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:37.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:37.386]                 ...future.rng), started = ...future.startTime, 
[13:24:37.386]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:37.386]             version = "1.8"), class = "FutureResult")
[13:24:37.386]     }, finally = {
[13:24:37.386]         if (!identical(...future.workdir, getwd())) 
[13:24:37.386]             setwd(...future.workdir)
[13:24:37.386]         {
[13:24:37.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:37.386]                 ...future.oldOptions$nwarnings <- NULL
[13:24:37.386]             }
[13:24:37.386]             base::options(...future.oldOptions)
[13:24:37.386]             if (.Platform$OS.type == "windows") {
[13:24:37.386]                 old_names <- names(...future.oldEnvVars)
[13:24:37.386]                 envs <- base::Sys.getenv()
[13:24:37.386]                 names <- names(envs)
[13:24:37.386]                 common <- intersect(names, old_names)
[13:24:37.386]                 added <- setdiff(names, old_names)
[13:24:37.386]                 removed <- setdiff(old_names, names)
[13:24:37.386]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:37.386]                   envs[common]]
[13:24:37.386]                 NAMES <- toupper(changed)
[13:24:37.386]                 args <- list()
[13:24:37.386]                 for (kk in seq_along(NAMES)) {
[13:24:37.386]                   name <- changed[[kk]]
[13:24:37.386]                   NAME <- NAMES[[kk]]
[13:24:37.386]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.386]                     next
[13:24:37.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:37.386]                 }
[13:24:37.386]                 NAMES <- toupper(added)
[13:24:37.386]                 for (kk in seq_along(NAMES)) {
[13:24:37.386]                   name <- added[[kk]]
[13:24:37.386]                   NAME <- NAMES[[kk]]
[13:24:37.386]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.386]                     next
[13:24:37.386]                   args[[name]] <- ""
[13:24:37.386]                 }
[13:24:37.386]                 NAMES <- toupper(removed)
[13:24:37.386]                 for (kk in seq_along(NAMES)) {
[13:24:37.386]                   name <- removed[[kk]]
[13:24:37.386]                   NAME <- NAMES[[kk]]
[13:24:37.386]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.386]                     next
[13:24:37.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:37.386]                 }
[13:24:37.386]                 if (length(args) > 0) 
[13:24:37.386]                   base::do.call(base::Sys.setenv, args = args)
[13:24:37.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:37.386]             }
[13:24:37.386]             else {
[13:24:37.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:37.386]             }
[13:24:37.386]             {
[13:24:37.386]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:37.386]                   0L) {
[13:24:37.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:37.386]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:37.386]                   base::options(opts)
[13:24:37.386]                 }
[13:24:37.386]                 {
[13:24:37.386]                   {
[13:24:37.386]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:37.386]                     NULL
[13:24:37.386]                   }
[13:24:37.386]                   options(future.plan = NULL)
[13:24:37.386]                   if (is.na(NA_character_)) 
[13:24:37.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:37.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:37.386]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:37.386]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:37.386]                     envir = parent.frame()) 
[13:24:37.386]                   {
[13:24:37.386]                     if (is.function(workers)) 
[13:24:37.386]                       workers <- workers()
[13:24:37.386]                     workers <- structure(as.integer(workers), 
[13:24:37.386]                       class = class(workers))
[13:24:37.386]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:37.386]                       workers >= 1)
[13:24:37.386]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:37.386]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:37.386]                     }
[13:24:37.386]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:37.386]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:37.386]                       envir = envir)
[13:24:37.386]                     if (!future$lazy) 
[13:24:37.386]                       future <- run(future)
[13:24:37.386]                     invisible(future)
[13:24:37.386]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:37.386]                 }
[13:24:37.386]             }
[13:24:37.386]         }
[13:24:37.386]     })
[13:24:37.386]     if (TRUE) {
[13:24:37.386]         base::sink(type = "output", split = FALSE)
[13:24:37.386]         if (TRUE) {
[13:24:37.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:37.386]         }
[13:24:37.386]         else {
[13:24:37.386]             ...future.result["stdout"] <- base::list(NULL)
[13:24:37.386]         }
[13:24:37.386]         base::close(...future.stdout)
[13:24:37.386]         ...future.stdout <- NULL
[13:24:37.386]     }
[13:24:37.386]     ...future.result$conditions <- ...future.conditions
[13:24:37.386]     ...future.result$finished <- base::Sys.time()
[13:24:37.386]     ...future.result
[13:24:37.386] }
[13:24:37.390] MultisessionFuture started
[13:24:37.390] - Launch lazy future ... done
[13:24:37.390] run() for ‘MultisessionFuture’ ... done
[13:24:37.437] receiveMessageFromWorker() for ClusterFuture ...
[13:24:37.438] - Validating connection of MultisessionFuture
[13:24:37.438] - received message: FutureResult
[13:24:37.438] - Received FutureResult
[13:24:37.438] - Erased future from FutureRegistry
[13:24:37.438] result() for ClusterFuture ...
[13:24:37.439] - result already collected: FutureResult
[13:24:37.439] result() for ClusterFuture ... done
[13:24:37.439] signalConditions() ...
[13:24:37.439]  - include = ‘immediateCondition’
[13:24:37.439]  - exclude = 
[13:24:37.439]  - resignal = FALSE
[13:24:37.439]  - Number of conditions: 1
[13:24:37.439] signalConditions() ... done
[13:24:37.439] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:37.439] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[13:24:37.440] getGlobalsAndPackages() ...
[13:24:37.440] Searching for globals...
[13:24:37.441] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:37.441] Searching for globals ... DONE
[13:24:37.441] Resolving globals: FALSE
[13:24:37.442] 
[13:24:37.442] 
[13:24:37.442] getGlobalsAndPackages() ... DONE
[13:24:37.442] run() for ‘Future’ ...
[13:24:37.442] - state: ‘created’
[13:24:37.442] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:37.456] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:37.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:37.456]   - Field: ‘node’
[13:24:37.456]   - Field: ‘label’
[13:24:37.457]   - Field: ‘local’
[13:24:37.457]   - Field: ‘owner’
[13:24:37.457]   - Field: ‘envir’
[13:24:37.457]   - Field: ‘workers’
[13:24:37.457]   - Field: ‘packages’
[13:24:37.457]   - Field: ‘gc’
[13:24:37.457]   - Field: ‘conditions’
[13:24:37.457]   - Field: ‘persistent’
[13:24:37.457]   - Field: ‘expr’
[13:24:37.457]   - Field: ‘uuid’
[13:24:37.457]   - Field: ‘seed’
[13:24:37.458]   - Field: ‘version’
[13:24:37.458]   - Field: ‘result’
[13:24:37.458]   - Field: ‘asynchronous’
[13:24:37.458]   - Field: ‘calls’
[13:24:37.458]   - Field: ‘globals’
[13:24:37.458]   - Field: ‘stdout’
[13:24:37.458]   - Field: ‘earlySignal’
[13:24:37.458]   - Field: ‘lazy’
[13:24:37.458]   - Field: ‘state’
[13:24:37.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:37.458] - Launch lazy future ...
[13:24:37.459] Packages needed by the future expression (n = 0): <none>
[13:24:37.459] Packages needed by future strategies (n = 0): <none>
[13:24:37.459] {
[13:24:37.459]     {
[13:24:37.459]         {
[13:24:37.459]             ...future.startTime <- base::Sys.time()
[13:24:37.459]             {
[13:24:37.459]                 {
[13:24:37.459]                   {
[13:24:37.459]                     {
[13:24:37.459]                       base::local({
[13:24:37.459]                         has_future <- base::requireNamespace("future", 
[13:24:37.459]                           quietly = TRUE)
[13:24:37.459]                         if (has_future) {
[13:24:37.459]                           ns <- base::getNamespace("future")
[13:24:37.459]                           version <- ns[[".package"]][["version"]]
[13:24:37.459]                           if (is.null(version)) 
[13:24:37.459]                             version <- utils::packageVersion("future")
[13:24:37.459]                         }
[13:24:37.459]                         else {
[13:24:37.459]                           version <- NULL
[13:24:37.459]                         }
[13:24:37.459]                         if (!has_future || version < "1.8.0") {
[13:24:37.459]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:37.459]                             "", base::R.version$version.string), 
[13:24:37.459]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:37.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:37.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:37.459]                               "release", "version")], collapse = " "), 
[13:24:37.459]                             hostname = base::Sys.info()[["nodename"]])
[13:24:37.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:37.459]                             info)
[13:24:37.459]                           info <- base::paste(info, collapse = "; ")
[13:24:37.459]                           if (!has_future) {
[13:24:37.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:37.459]                               info)
[13:24:37.459]                           }
[13:24:37.459]                           else {
[13:24:37.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:37.459]                               info, version)
[13:24:37.459]                           }
[13:24:37.459]                           base::stop(msg)
[13:24:37.459]                         }
[13:24:37.459]                       })
[13:24:37.459]                     }
[13:24:37.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:37.459]                     base::options(mc.cores = 1L)
[13:24:37.459]                   }
[13:24:37.459]                   options(future.plan = NULL)
[13:24:37.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:37.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:37.459]                 }
[13:24:37.459]                 ...future.workdir <- getwd()
[13:24:37.459]             }
[13:24:37.459]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:37.459]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:37.459]         }
[13:24:37.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:37.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:37.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:37.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:37.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:37.459]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:37.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:37.459]             base::names(...future.oldOptions))
[13:24:37.459]     }
[13:24:37.459]     if (FALSE) {
[13:24:37.459]     }
[13:24:37.459]     else {
[13:24:37.459]         if (TRUE) {
[13:24:37.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:37.459]                 open = "w")
[13:24:37.459]         }
[13:24:37.459]         else {
[13:24:37.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:37.459]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:37.459]         }
[13:24:37.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:37.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:37.459]             base::sink(type = "output", split = FALSE)
[13:24:37.459]             base::close(...future.stdout)
[13:24:37.459]         }, add = TRUE)
[13:24:37.459]     }
[13:24:37.459]     ...future.frame <- base::sys.nframe()
[13:24:37.459]     ...future.conditions <- base::list()
[13:24:37.459]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:37.459]     if (FALSE) {
[13:24:37.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:37.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:37.459]     }
[13:24:37.459]     ...future.result <- base::tryCatch({
[13:24:37.459]         base::withCallingHandlers({
[13:24:37.459]             ...future.value <- base::withVisible(base::local({
[13:24:37.459]                 ...future.makeSendCondition <- base::local({
[13:24:37.459]                   sendCondition <- NULL
[13:24:37.459]                   function(frame = 1L) {
[13:24:37.459]                     if (is.function(sendCondition)) 
[13:24:37.459]                       return(sendCondition)
[13:24:37.459]                     ns <- getNamespace("parallel")
[13:24:37.459]                     if (exists("sendData", mode = "function", 
[13:24:37.459]                       envir = ns)) {
[13:24:37.459]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:37.459]                         envir = ns)
[13:24:37.459]                       envir <- sys.frame(frame)
[13:24:37.459]                       master <- NULL
[13:24:37.459]                       while (!identical(envir, .GlobalEnv) && 
[13:24:37.459]                         !identical(envir, emptyenv())) {
[13:24:37.459]                         if (exists("master", mode = "list", envir = envir, 
[13:24:37.459]                           inherits = FALSE)) {
[13:24:37.459]                           master <- get("master", mode = "list", 
[13:24:37.459]                             envir = envir, inherits = FALSE)
[13:24:37.459]                           if (inherits(master, c("SOCKnode", 
[13:24:37.459]                             "SOCK0node"))) {
[13:24:37.459]                             sendCondition <<- function(cond) {
[13:24:37.459]                               data <- list(type = "VALUE", value = cond, 
[13:24:37.459]                                 success = TRUE)
[13:24:37.459]                               parallel_sendData(master, data)
[13:24:37.459]                             }
[13:24:37.459]                             return(sendCondition)
[13:24:37.459]                           }
[13:24:37.459]                         }
[13:24:37.459]                         frame <- frame + 1L
[13:24:37.459]                         envir <- sys.frame(frame)
[13:24:37.459]                       }
[13:24:37.459]                     }
[13:24:37.459]                     sendCondition <<- function(cond) NULL
[13:24:37.459]                   }
[13:24:37.459]                 })
[13:24:37.459]                 withCallingHandlers({
[13:24:37.459]                   {
[13:24:37.459]                     Sys.sleep(0.5)
[13:24:37.459]                     list(a = 1, b = 42L)
[13:24:37.459]                   }
[13:24:37.459]                 }, immediateCondition = function(cond) {
[13:24:37.459]                   sendCondition <- ...future.makeSendCondition()
[13:24:37.459]                   sendCondition(cond)
[13:24:37.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.459]                   {
[13:24:37.459]                     inherits <- base::inherits
[13:24:37.459]                     invokeRestart <- base::invokeRestart
[13:24:37.459]                     is.null <- base::is.null
[13:24:37.459]                     muffled <- FALSE
[13:24:37.459]                     if (inherits(cond, "message")) {
[13:24:37.459]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:37.459]                       if (muffled) 
[13:24:37.459]                         invokeRestart("muffleMessage")
[13:24:37.459]                     }
[13:24:37.459]                     else if (inherits(cond, "warning")) {
[13:24:37.459]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:37.459]                       if (muffled) 
[13:24:37.459]                         invokeRestart("muffleWarning")
[13:24:37.459]                     }
[13:24:37.459]                     else if (inherits(cond, "condition")) {
[13:24:37.459]                       if (!is.null(pattern)) {
[13:24:37.459]                         computeRestarts <- base::computeRestarts
[13:24:37.459]                         grepl <- base::grepl
[13:24:37.459]                         restarts <- computeRestarts(cond)
[13:24:37.459]                         for (restart in restarts) {
[13:24:37.459]                           name <- restart$name
[13:24:37.459]                           if (is.null(name)) 
[13:24:37.459]                             next
[13:24:37.459]                           if (!grepl(pattern, name)) 
[13:24:37.459]                             next
[13:24:37.459]                           invokeRestart(restart)
[13:24:37.459]                           muffled <- TRUE
[13:24:37.459]                           break
[13:24:37.459]                         }
[13:24:37.459]                       }
[13:24:37.459]                     }
[13:24:37.459]                     invisible(muffled)
[13:24:37.459]                   }
[13:24:37.459]                   muffleCondition(cond)
[13:24:37.459]                 })
[13:24:37.459]             }))
[13:24:37.459]             future::FutureResult(value = ...future.value$value, 
[13:24:37.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:37.459]                   ...future.rng), globalenv = if (FALSE) 
[13:24:37.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:37.459]                     ...future.globalenv.names))
[13:24:37.459]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:37.459]         }, condition = base::local({
[13:24:37.459]             c <- base::c
[13:24:37.459]             inherits <- base::inherits
[13:24:37.459]             invokeRestart <- base::invokeRestart
[13:24:37.459]             length <- base::length
[13:24:37.459]             list <- base::list
[13:24:37.459]             seq.int <- base::seq.int
[13:24:37.459]             signalCondition <- base::signalCondition
[13:24:37.459]             sys.calls <- base::sys.calls
[13:24:37.459]             `[[` <- base::`[[`
[13:24:37.459]             `+` <- base::`+`
[13:24:37.459]             `<<-` <- base::`<<-`
[13:24:37.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:37.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:37.459]                   3L)]
[13:24:37.459]             }
[13:24:37.459]             function(cond) {
[13:24:37.459]                 is_error <- inherits(cond, "error")
[13:24:37.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:37.459]                   NULL)
[13:24:37.459]                 if (is_error) {
[13:24:37.459]                   sessionInformation <- function() {
[13:24:37.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:37.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:37.459]                       search = base::search(), system = base::Sys.info())
[13:24:37.459]                   }
[13:24:37.459]                   ...future.conditions[[length(...future.conditions) + 
[13:24:37.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:37.459]                     cond$call), session = sessionInformation(), 
[13:24:37.459]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:37.459]                   signalCondition(cond)
[13:24:37.459]                 }
[13:24:37.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:37.459]                 "immediateCondition"))) {
[13:24:37.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:37.459]                   ...future.conditions[[length(...future.conditions) + 
[13:24:37.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:37.459]                   if (TRUE && !signal) {
[13:24:37.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.459]                     {
[13:24:37.459]                       inherits <- base::inherits
[13:24:37.459]                       invokeRestart <- base::invokeRestart
[13:24:37.459]                       is.null <- base::is.null
[13:24:37.459]                       muffled <- FALSE
[13:24:37.459]                       if (inherits(cond, "message")) {
[13:24:37.459]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:37.459]                         if (muffled) 
[13:24:37.459]                           invokeRestart("muffleMessage")
[13:24:37.459]                       }
[13:24:37.459]                       else if (inherits(cond, "warning")) {
[13:24:37.459]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:37.459]                         if (muffled) 
[13:24:37.459]                           invokeRestart("muffleWarning")
[13:24:37.459]                       }
[13:24:37.459]                       else if (inherits(cond, "condition")) {
[13:24:37.459]                         if (!is.null(pattern)) {
[13:24:37.459]                           computeRestarts <- base::computeRestarts
[13:24:37.459]                           grepl <- base::grepl
[13:24:37.459]                           restarts <- computeRestarts(cond)
[13:24:37.459]                           for (restart in restarts) {
[13:24:37.459]                             name <- restart$name
[13:24:37.459]                             if (is.null(name)) 
[13:24:37.459]                               next
[13:24:37.459]                             if (!grepl(pattern, name)) 
[13:24:37.459]                               next
[13:24:37.459]                             invokeRestart(restart)
[13:24:37.459]                             muffled <- TRUE
[13:24:37.459]                             break
[13:24:37.459]                           }
[13:24:37.459]                         }
[13:24:37.459]                       }
[13:24:37.459]                       invisible(muffled)
[13:24:37.459]                     }
[13:24:37.459]                     muffleCondition(cond, pattern = "^muffle")
[13:24:37.459]                   }
[13:24:37.459]                 }
[13:24:37.459]                 else {
[13:24:37.459]                   if (TRUE) {
[13:24:37.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:37.459]                     {
[13:24:37.459]                       inherits <- base::inherits
[13:24:37.459]                       invokeRestart <- base::invokeRestart
[13:24:37.459]                       is.null <- base::is.null
[13:24:37.459]                       muffled <- FALSE
[13:24:37.459]                       if (inherits(cond, "message")) {
[13:24:37.459]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:37.459]                         if (muffled) 
[13:24:37.459]                           invokeRestart("muffleMessage")
[13:24:37.459]                       }
[13:24:37.459]                       else if (inherits(cond, "warning")) {
[13:24:37.459]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:37.459]                         if (muffled) 
[13:24:37.459]                           invokeRestart("muffleWarning")
[13:24:37.459]                       }
[13:24:37.459]                       else if (inherits(cond, "condition")) {
[13:24:37.459]                         if (!is.null(pattern)) {
[13:24:37.459]                           computeRestarts <- base::computeRestarts
[13:24:37.459]                           grepl <- base::grepl
[13:24:37.459]                           restarts <- computeRestarts(cond)
[13:24:37.459]                           for (restart in restarts) {
[13:24:37.459]                             name <- restart$name
[13:24:37.459]                             if (is.null(name)) 
[13:24:37.459]                               next
[13:24:37.459]                             if (!grepl(pattern, name)) 
[13:24:37.459]                               next
[13:24:37.459]                             invokeRestart(restart)
[13:24:37.459]                             muffled <- TRUE
[13:24:37.459]                             break
[13:24:37.459]                           }
[13:24:37.459]                         }
[13:24:37.459]                       }
[13:24:37.459]                       invisible(muffled)
[13:24:37.459]                     }
[13:24:37.459]                     muffleCondition(cond, pattern = "^muffle")
[13:24:37.459]                   }
[13:24:37.459]                 }
[13:24:37.459]             }
[13:24:37.459]         }))
[13:24:37.459]     }, error = function(ex) {
[13:24:37.459]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:37.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:37.459]                 ...future.rng), started = ...future.startTime, 
[13:24:37.459]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:37.459]             version = "1.8"), class = "FutureResult")
[13:24:37.459]     }, finally = {
[13:24:37.459]         if (!identical(...future.workdir, getwd())) 
[13:24:37.459]             setwd(...future.workdir)
[13:24:37.459]         {
[13:24:37.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:37.459]                 ...future.oldOptions$nwarnings <- NULL
[13:24:37.459]             }
[13:24:37.459]             base::options(...future.oldOptions)
[13:24:37.459]             if (.Platform$OS.type == "windows") {
[13:24:37.459]                 old_names <- names(...future.oldEnvVars)
[13:24:37.459]                 envs <- base::Sys.getenv()
[13:24:37.459]                 names <- names(envs)
[13:24:37.459]                 common <- intersect(names, old_names)
[13:24:37.459]                 added <- setdiff(names, old_names)
[13:24:37.459]                 removed <- setdiff(old_names, names)
[13:24:37.459]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:37.459]                   envs[common]]
[13:24:37.459]                 NAMES <- toupper(changed)
[13:24:37.459]                 args <- list()
[13:24:37.459]                 for (kk in seq_along(NAMES)) {
[13:24:37.459]                   name <- changed[[kk]]
[13:24:37.459]                   NAME <- NAMES[[kk]]
[13:24:37.459]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.459]                     next
[13:24:37.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:37.459]                 }
[13:24:37.459]                 NAMES <- toupper(added)
[13:24:37.459]                 for (kk in seq_along(NAMES)) {
[13:24:37.459]                   name <- added[[kk]]
[13:24:37.459]                   NAME <- NAMES[[kk]]
[13:24:37.459]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.459]                     next
[13:24:37.459]                   args[[name]] <- ""
[13:24:37.459]                 }
[13:24:37.459]                 NAMES <- toupper(removed)
[13:24:37.459]                 for (kk in seq_along(NAMES)) {
[13:24:37.459]                   name <- removed[[kk]]
[13:24:37.459]                   NAME <- NAMES[[kk]]
[13:24:37.459]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:37.459]                     next
[13:24:37.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:37.459]                 }
[13:24:37.459]                 if (length(args) > 0) 
[13:24:37.459]                   base::do.call(base::Sys.setenv, args = args)
[13:24:37.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:37.459]             }
[13:24:37.459]             else {
[13:24:37.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:37.459]             }
[13:24:37.459]             {
[13:24:37.459]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:37.459]                   0L) {
[13:24:37.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:37.459]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:37.459]                   base::options(opts)
[13:24:37.459]                 }
[13:24:37.459]                 {
[13:24:37.459]                   {
[13:24:37.459]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:37.459]                     NULL
[13:24:37.459]                   }
[13:24:37.459]                   options(future.plan = NULL)
[13:24:37.459]                   if (is.na(NA_character_)) 
[13:24:37.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:37.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:37.459]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:37.459]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:37.459]                     envir = parent.frame()) 
[13:24:37.459]                   {
[13:24:37.459]                     if (is.function(workers)) 
[13:24:37.459]                       workers <- workers()
[13:24:37.459]                     workers <- structure(as.integer(workers), 
[13:24:37.459]                       class = class(workers))
[13:24:37.459]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:37.459]                       workers >= 1)
[13:24:37.459]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:37.459]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:37.459]                     }
[13:24:37.459]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:37.459]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:37.459]                       envir = envir)
[13:24:37.459]                     if (!future$lazy) 
[13:24:37.459]                       future <- run(future)
[13:24:37.459]                     invisible(future)
[13:24:37.459]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:37.459]                 }
[13:24:37.459]             }
[13:24:37.459]         }
[13:24:37.459]     })
[13:24:37.459]     if (TRUE) {
[13:24:37.459]         base::sink(type = "output", split = FALSE)
[13:24:37.459]         if (TRUE) {
[13:24:37.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:37.459]         }
[13:24:37.459]         else {
[13:24:37.459]             ...future.result["stdout"] <- base::list(NULL)
[13:24:37.459]         }
[13:24:37.459]         base::close(...future.stdout)
[13:24:37.459]         ...future.stdout <- NULL
[13:24:37.459]     }
[13:24:37.459]     ...future.result$conditions <- ...future.conditions
[13:24:37.459]     ...future.result$finished <- base::Sys.time()
[13:24:37.459]     ...future.result
[13:24:37.459] }
[13:24:37.463] MultisessionFuture started
[13:24:37.463] - Launch lazy future ... done
[13:24:37.463] run() for ‘MultisessionFuture’ ... done
[13:24:38.010] receiveMessageFromWorker() for ClusterFuture ...
[13:24:38.011] - Validating connection of MultisessionFuture
[13:24:38.011] - received message: FutureResult
[13:24:38.011] - Received FutureResult
[13:24:38.011] - Erased future from FutureRegistry
[13:24:38.011] result() for ClusterFuture ...
[13:24:38.011] - result already collected: FutureResult
[13:24:38.011] result() for ClusterFuture ... done
[13:24:38.012] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:38.012] resolve() on list ...
[13:24:38.012]  recursive: 0
[13:24:38.012]  length: 2
[13:24:38.012]  elements: ‘a’, ‘b’
[13:24:38.012]  length: 1 (resolved future 1)
[13:24:38.015]  length: 0 (resolved future 2)
[13:24:38.015] resolve() on list ... DONE
[13:24:38.015] A MultisessionFuture was resolved (and resolved itself)
[13:24:38.015] getGlobalsAndPackages() ...
[13:24:38.015] Searching for globals...
[13:24:38.017] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:38.017] Searching for globals ... DONE
[13:24:38.017] Resolving globals: FALSE
[13:24:38.017] 
[13:24:38.017] 
[13:24:38.018] getGlobalsAndPackages() ... DONE
[13:24:38.018] run() for ‘Future’ ...
[13:24:38.018] - state: ‘created’
[13:24:38.018] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:38.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:38.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:38.032]   - Field: ‘node’
[13:24:38.032]   - Field: ‘label’
[13:24:38.032]   - Field: ‘local’
[13:24:38.033]   - Field: ‘owner’
[13:24:38.033]   - Field: ‘envir’
[13:24:38.033]   - Field: ‘workers’
[13:24:38.033]   - Field: ‘packages’
[13:24:38.033]   - Field: ‘gc’
[13:24:38.033]   - Field: ‘conditions’
[13:24:38.033]   - Field: ‘persistent’
[13:24:38.033]   - Field: ‘expr’
[13:24:38.033]   - Field: ‘uuid’
[13:24:38.033]   - Field: ‘seed’
[13:24:38.033]   - Field: ‘version’
[13:24:38.034]   - Field: ‘result’
[13:24:38.034]   - Field: ‘asynchronous’
[13:24:38.034]   - Field: ‘calls’
[13:24:38.034]   - Field: ‘globals’
[13:24:38.034]   - Field: ‘stdout’
[13:24:38.034]   - Field: ‘earlySignal’
[13:24:38.034]   - Field: ‘lazy’
[13:24:38.034]   - Field: ‘state’
[13:24:38.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:38.034] - Launch lazy future ...
[13:24:38.035] Packages needed by the future expression (n = 0): <none>
[13:24:38.035] Packages needed by future strategies (n = 0): <none>
[13:24:38.035] {
[13:24:38.035]     {
[13:24:38.035]         {
[13:24:38.035]             ...future.startTime <- base::Sys.time()
[13:24:38.035]             {
[13:24:38.035]                 {
[13:24:38.035]                   {
[13:24:38.035]                     {
[13:24:38.035]                       base::local({
[13:24:38.035]                         has_future <- base::requireNamespace("future", 
[13:24:38.035]                           quietly = TRUE)
[13:24:38.035]                         if (has_future) {
[13:24:38.035]                           ns <- base::getNamespace("future")
[13:24:38.035]                           version <- ns[[".package"]][["version"]]
[13:24:38.035]                           if (is.null(version)) 
[13:24:38.035]                             version <- utils::packageVersion("future")
[13:24:38.035]                         }
[13:24:38.035]                         else {
[13:24:38.035]                           version <- NULL
[13:24:38.035]                         }
[13:24:38.035]                         if (!has_future || version < "1.8.0") {
[13:24:38.035]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:38.035]                             "", base::R.version$version.string), 
[13:24:38.035]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:38.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:38.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:38.035]                               "release", "version")], collapse = " "), 
[13:24:38.035]                             hostname = base::Sys.info()[["nodename"]])
[13:24:38.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:38.035]                             info)
[13:24:38.035]                           info <- base::paste(info, collapse = "; ")
[13:24:38.035]                           if (!has_future) {
[13:24:38.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:38.035]                               info)
[13:24:38.035]                           }
[13:24:38.035]                           else {
[13:24:38.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:38.035]                               info, version)
[13:24:38.035]                           }
[13:24:38.035]                           base::stop(msg)
[13:24:38.035]                         }
[13:24:38.035]                       })
[13:24:38.035]                     }
[13:24:38.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:38.035]                     base::options(mc.cores = 1L)
[13:24:38.035]                   }
[13:24:38.035]                   options(future.plan = NULL)
[13:24:38.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:38.035]                 }
[13:24:38.035]                 ...future.workdir <- getwd()
[13:24:38.035]             }
[13:24:38.035]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:38.035]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:38.035]         }
[13:24:38.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:38.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:38.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:38.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:38.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:38.035]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:38.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:38.035]             base::names(...future.oldOptions))
[13:24:38.035]     }
[13:24:38.035]     if (FALSE) {
[13:24:38.035]     }
[13:24:38.035]     else {
[13:24:38.035]         if (TRUE) {
[13:24:38.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:38.035]                 open = "w")
[13:24:38.035]         }
[13:24:38.035]         else {
[13:24:38.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:38.035]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:38.035]         }
[13:24:38.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:38.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:38.035]             base::sink(type = "output", split = FALSE)
[13:24:38.035]             base::close(...future.stdout)
[13:24:38.035]         }, add = TRUE)
[13:24:38.035]     }
[13:24:38.035]     ...future.frame <- base::sys.nframe()
[13:24:38.035]     ...future.conditions <- base::list()
[13:24:38.035]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:38.035]     if (FALSE) {
[13:24:38.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:38.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:38.035]     }
[13:24:38.035]     ...future.result <- base::tryCatch({
[13:24:38.035]         base::withCallingHandlers({
[13:24:38.035]             ...future.value <- base::withVisible(base::local({
[13:24:38.035]                 ...future.makeSendCondition <- base::local({
[13:24:38.035]                   sendCondition <- NULL
[13:24:38.035]                   function(frame = 1L) {
[13:24:38.035]                     if (is.function(sendCondition)) 
[13:24:38.035]                       return(sendCondition)
[13:24:38.035]                     ns <- getNamespace("parallel")
[13:24:38.035]                     if (exists("sendData", mode = "function", 
[13:24:38.035]                       envir = ns)) {
[13:24:38.035]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:38.035]                         envir = ns)
[13:24:38.035]                       envir <- sys.frame(frame)
[13:24:38.035]                       master <- NULL
[13:24:38.035]                       while (!identical(envir, .GlobalEnv) && 
[13:24:38.035]                         !identical(envir, emptyenv())) {
[13:24:38.035]                         if (exists("master", mode = "list", envir = envir, 
[13:24:38.035]                           inherits = FALSE)) {
[13:24:38.035]                           master <- get("master", mode = "list", 
[13:24:38.035]                             envir = envir, inherits = FALSE)
[13:24:38.035]                           if (inherits(master, c("SOCKnode", 
[13:24:38.035]                             "SOCK0node"))) {
[13:24:38.035]                             sendCondition <<- function(cond) {
[13:24:38.035]                               data <- list(type = "VALUE", value = cond, 
[13:24:38.035]                                 success = TRUE)
[13:24:38.035]                               parallel_sendData(master, data)
[13:24:38.035]                             }
[13:24:38.035]                             return(sendCondition)
[13:24:38.035]                           }
[13:24:38.035]                         }
[13:24:38.035]                         frame <- frame + 1L
[13:24:38.035]                         envir <- sys.frame(frame)
[13:24:38.035]                       }
[13:24:38.035]                     }
[13:24:38.035]                     sendCondition <<- function(cond) NULL
[13:24:38.035]                   }
[13:24:38.035]                 })
[13:24:38.035]                 withCallingHandlers({
[13:24:38.035]                   {
[13:24:38.035]                     Sys.sleep(0.5)
[13:24:38.035]                     list(a = 1, b = 42L)
[13:24:38.035]                   }
[13:24:38.035]                 }, immediateCondition = function(cond) {
[13:24:38.035]                   sendCondition <- ...future.makeSendCondition()
[13:24:38.035]                   sendCondition(cond)
[13:24:38.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.035]                   {
[13:24:38.035]                     inherits <- base::inherits
[13:24:38.035]                     invokeRestart <- base::invokeRestart
[13:24:38.035]                     is.null <- base::is.null
[13:24:38.035]                     muffled <- FALSE
[13:24:38.035]                     if (inherits(cond, "message")) {
[13:24:38.035]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:38.035]                       if (muffled) 
[13:24:38.035]                         invokeRestart("muffleMessage")
[13:24:38.035]                     }
[13:24:38.035]                     else if (inherits(cond, "warning")) {
[13:24:38.035]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:38.035]                       if (muffled) 
[13:24:38.035]                         invokeRestart("muffleWarning")
[13:24:38.035]                     }
[13:24:38.035]                     else if (inherits(cond, "condition")) {
[13:24:38.035]                       if (!is.null(pattern)) {
[13:24:38.035]                         computeRestarts <- base::computeRestarts
[13:24:38.035]                         grepl <- base::grepl
[13:24:38.035]                         restarts <- computeRestarts(cond)
[13:24:38.035]                         for (restart in restarts) {
[13:24:38.035]                           name <- restart$name
[13:24:38.035]                           if (is.null(name)) 
[13:24:38.035]                             next
[13:24:38.035]                           if (!grepl(pattern, name)) 
[13:24:38.035]                             next
[13:24:38.035]                           invokeRestart(restart)
[13:24:38.035]                           muffled <- TRUE
[13:24:38.035]                           break
[13:24:38.035]                         }
[13:24:38.035]                       }
[13:24:38.035]                     }
[13:24:38.035]                     invisible(muffled)
[13:24:38.035]                   }
[13:24:38.035]                   muffleCondition(cond)
[13:24:38.035]                 })
[13:24:38.035]             }))
[13:24:38.035]             future::FutureResult(value = ...future.value$value, 
[13:24:38.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.035]                   ...future.rng), globalenv = if (FALSE) 
[13:24:38.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:38.035]                     ...future.globalenv.names))
[13:24:38.035]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:38.035]         }, condition = base::local({
[13:24:38.035]             c <- base::c
[13:24:38.035]             inherits <- base::inherits
[13:24:38.035]             invokeRestart <- base::invokeRestart
[13:24:38.035]             length <- base::length
[13:24:38.035]             list <- base::list
[13:24:38.035]             seq.int <- base::seq.int
[13:24:38.035]             signalCondition <- base::signalCondition
[13:24:38.035]             sys.calls <- base::sys.calls
[13:24:38.035]             `[[` <- base::`[[`
[13:24:38.035]             `+` <- base::`+`
[13:24:38.035]             `<<-` <- base::`<<-`
[13:24:38.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:38.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:38.035]                   3L)]
[13:24:38.035]             }
[13:24:38.035]             function(cond) {
[13:24:38.035]                 is_error <- inherits(cond, "error")
[13:24:38.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:38.035]                   NULL)
[13:24:38.035]                 if (is_error) {
[13:24:38.035]                   sessionInformation <- function() {
[13:24:38.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:38.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:38.035]                       search = base::search(), system = base::Sys.info())
[13:24:38.035]                   }
[13:24:38.035]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:38.035]                     cond$call), session = sessionInformation(), 
[13:24:38.035]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:38.035]                   signalCondition(cond)
[13:24:38.035]                 }
[13:24:38.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:38.035]                 "immediateCondition"))) {
[13:24:38.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:38.035]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:38.035]                   if (TRUE && !signal) {
[13:24:38.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.035]                     {
[13:24:38.035]                       inherits <- base::inherits
[13:24:38.035]                       invokeRestart <- base::invokeRestart
[13:24:38.035]                       is.null <- base::is.null
[13:24:38.035]                       muffled <- FALSE
[13:24:38.035]                       if (inherits(cond, "message")) {
[13:24:38.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.035]                         if (muffled) 
[13:24:38.035]                           invokeRestart("muffleMessage")
[13:24:38.035]                       }
[13:24:38.035]                       else if (inherits(cond, "warning")) {
[13:24:38.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.035]                         if (muffled) 
[13:24:38.035]                           invokeRestart("muffleWarning")
[13:24:38.035]                       }
[13:24:38.035]                       else if (inherits(cond, "condition")) {
[13:24:38.035]                         if (!is.null(pattern)) {
[13:24:38.035]                           computeRestarts <- base::computeRestarts
[13:24:38.035]                           grepl <- base::grepl
[13:24:38.035]                           restarts <- computeRestarts(cond)
[13:24:38.035]                           for (restart in restarts) {
[13:24:38.035]                             name <- restart$name
[13:24:38.035]                             if (is.null(name)) 
[13:24:38.035]                               next
[13:24:38.035]                             if (!grepl(pattern, name)) 
[13:24:38.035]                               next
[13:24:38.035]                             invokeRestart(restart)
[13:24:38.035]                             muffled <- TRUE
[13:24:38.035]                             break
[13:24:38.035]                           }
[13:24:38.035]                         }
[13:24:38.035]                       }
[13:24:38.035]                       invisible(muffled)
[13:24:38.035]                     }
[13:24:38.035]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.035]                   }
[13:24:38.035]                 }
[13:24:38.035]                 else {
[13:24:38.035]                   if (TRUE) {
[13:24:38.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.035]                     {
[13:24:38.035]                       inherits <- base::inherits
[13:24:38.035]                       invokeRestart <- base::invokeRestart
[13:24:38.035]                       is.null <- base::is.null
[13:24:38.035]                       muffled <- FALSE
[13:24:38.035]                       if (inherits(cond, "message")) {
[13:24:38.035]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.035]                         if (muffled) 
[13:24:38.035]                           invokeRestart("muffleMessage")
[13:24:38.035]                       }
[13:24:38.035]                       else if (inherits(cond, "warning")) {
[13:24:38.035]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.035]                         if (muffled) 
[13:24:38.035]                           invokeRestart("muffleWarning")
[13:24:38.035]                       }
[13:24:38.035]                       else if (inherits(cond, "condition")) {
[13:24:38.035]                         if (!is.null(pattern)) {
[13:24:38.035]                           computeRestarts <- base::computeRestarts
[13:24:38.035]                           grepl <- base::grepl
[13:24:38.035]                           restarts <- computeRestarts(cond)
[13:24:38.035]                           for (restart in restarts) {
[13:24:38.035]                             name <- restart$name
[13:24:38.035]                             if (is.null(name)) 
[13:24:38.035]                               next
[13:24:38.035]                             if (!grepl(pattern, name)) 
[13:24:38.035]                               next
[13:24:38.035]                             invokeRestart(restart)
[13:24:38.035]                             muffled <- TRUE
[13:24:38.035]                             break
[13:24:38.035]                           }
[13:24:38.035]                         }
[13:24:38.035]                       }
[13:24:38.035]                       invisible(muffled)
[13:24:38.035]                     }
[13:24:38.035]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.035]                   }
[13:24:38.035]                 }
[13:24:38.035]             }
[13:24:38.035]         }))
[13:24:38.035]     }, error = function(ex) {
[13:24:38.035]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:38.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.035]                 ...future.rng), started = ...future.startTime, 
[13:24:38.035]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:38.035]             version = "1.8"), class = "FutureResult")
[13:24:38.035]     }, finally = {
[13:24:38.035]         if (!identical(...future.workdir, getwd())) 
[13:24:38.035]             setwd(...future.workdir)
[13:24:38.035]         {
[13:24:38.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:38.035]                 ...future.oldOptions$nwarnings <- NULL
[13:24:38.035]             }
[13:24:38.035]             base::options(...future.oldOptions)
[13:24:38.035]             if (.Platform$OS.type == "windows") {
[13:24:38.035]                 old_names <- names(...future.oldEnvVars)
[13:24:38.035]                 envs <- base::Sys.getenv()
[13:24:38.035]                 names <- names(envs)
[13:24:38.035]                 common <- intersect(names, old_names)
[13:24:38.035]                 added <- setdiff(names, old_names)
[13:24:38.035]                 removed <- setdiff(old_names, names)
[13:24:38.035]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:38.035]                   envs[common]]
[13:24:38.035]                 NAMES <- toupper(changed)
[13:24:38.035]                 args <- list()
[13:24:38.035]                 for (kk in seq_along(NAMES)) {
[13:24:38.035]                   name <- changed[[kk]]
[13:24:38.035]                   NAME <- NAMES[[kk]]
[13:24:38.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.035]                     next
[13:24:38.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.035]                 }
[13:24:38.035]                 NAMES <- toupper(added)
[13:24:38.035]                 for (kk in seq_along(NAMES)) {
[13:24:38.035]                   name <- added[[kk]]
[13:24:38.035]                   NAME <- NAMES[[kk]]
[13:24:38.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.035]                     next
[13:24:38.035]                   args[[name]] <- ""
[13:24:38.035]                 }
[13:24:38.035]                 NAMES <- toupper(removed)
[13:24:38.035]                 for (kk in seq_along(NAMES)) {
[13:24:38.035]                   name <- removed[[kk]]
[13:24:38.035]                   NAME <- NAMES[[kk]]
[13:24:38.035]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.035]                     next
[13:24:38.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.035]                 }
[13:24:38.035]                 if (length(args) > 0) 
[13:24:38.035]                   base::do.call(base::Sys.setenv, args = args)
[13:24:38.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:38.035]             }
[13:24:38.035]             else {
[13:24:38.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:38.035]             }
[13:24:38.035]             {
[13:24:38.035]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:38.035]                   0L) {
[13:24:38.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:38.035]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:38.035]                   base::options(opts)
[13:24:38.035]                 }
[13:24:38.035]                 {
[13:24:38.035]                   {
[13:24:38.035]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:38.035]                     NULL
[13:24:38.035]                   }
[13:24:38.035]                   options(future.plan = NULL)
[13:24:38.035]                   if (is.na(NA_character_)) 
[13:24:38.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:38.035]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:38.035]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:38.035]                     envir = parent.frame()) 
[13:24:38.035]                   {
[13:24:38.035]                     if (is.function(workers)) 
[13:24:38.035]                       workers <- workers()
[13:24:38.035]                     workers <- structure(as.integer(workers), 
[13:24:38.035]                       class = class(workers))
[13:24:38.035]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:38.035]                       workers >= 1)
[13:24:38.035]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:38.035]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:38.035]                     }
[13:24:38.035]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:38.035]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:38.035]                       envir = envir)
[13:24:38.035]                     if (!future$lazy) 
[13:24:38.035]                       future <- run(future)
[13:24:38.035]                     invisible(future)
[13:24:38.035]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:38.035]                 }
[13:24:38.035]             }
[13:24:38.035]         }
[13:24:38.035]     })
[13:24:38.035]     if (TRUE) {
[13:24:38.035]         base::sink(type = "output", split = FALSE)
[13:24:38.035]         if (TRUE) {
[13:24:38.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:38.035]         }
[13:24:38.035]         else {
[13:24:38.035]             ...future.result["stdout"] <- base::list(NULL)
[13:24:38.035]         }
[13:24:38.035]         base::close(...future.stdout)
[13:24:38.035]         ...future.stdout <- NULL
[13:24:38.035]     }
[13:24:38.035]     ...future.result$conditions <- ...future.conditions
[13:24:38.035]     ...future.result$finished <- base::Sys.time()
[13:24:38.035]     ...future.result
[13:24:38.035] }
[13:24:38.038] MultisessionFuture started
[13:24:38.038] - Launch lazy future ... done
[13:24:38.039] run() for ‘MultisessionFuture’ ... done
[13:24:38.588] receiveMessageFromWorker() for ClusterFuture ...
[13:24:38.588] - Validating connection of MultisessionFuture
[13:24:38.588] - received message: FutureResult
[13:24:38.588] - Received FutureResult
[13:24:38.588] - Erased future from FutureRegistry
[13:24:38.589] result() for ClusterFuture ...
[13:24:38.589] - result already collected: FutureResult
[13:24:38.589] result() for ClusterFuture ... done
[13:24:38.589] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:38.589] resolve() on list ...
[13:24:38.589]  recursive: 0
[13:24:38.589]  length: 2
[13:24:38.589]  elements: ‘a’, ‘b’
[13:24:38.589]  length: 1 (resolved future 1)
[13:24:38.590]  length: 0 (resolved future 2)
[13:24:38.590] resolve() on list ... DONE
[13:24:38.590] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:24:38.590] getGlobalsAndPackages() ...
[13:24:38.590] Searching for globals...
[13:24:38.591] - globals found: [2] ‘list’, ‘stop’
[13:24:38.591] Searching for globals ... DONE
[13:24:38.591] Resolving globals: FALSE
[13:24:38.591] 
[13:24:38.591] 
[13:24:38.591] getGlobalsAndPackages() ... DONE
[13:24:38.592] run() for ‘Future’ ...
[13:24:38.592] - state: ‘created’
[13:24:38.592] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:38.607] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:38.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:38.607]   - Field: ‘node’
[13:24:38.608]   - Field: ‘label’
[13:24:38.608]   - Field: ‘local’
[13:24:38.608]   - Field: ‘owner’
[13:24:38.608]   - Field: ‘envir’
[13:24:38.608]   - Field: ‘workers’
[13:24:38.608]   - Field: ‘packages’
[13:24:38.608]   - Field: ‘gc’
[13:24:38.608]   - Field: ‘conditions’
[13:24:38.608]   - Field: ‘persistent’
[13:24:38.609]   - Field: ‘expr’
[13:24:38.609]   - Field: ‘uuid’
[13:24:38.609]   - Field: ‘seed’
[13:24:38.609]   - Field: ‘version’
[13:24:38.609]   - Field: ‘result’
[13:24:38.609]   - Field: ‘asynchronous’
[13:24:38.609]   - Field: ‘calls’
[13:24:38.609]   - Field: ‘globals’
[13:24:38.609]   - Field: ‘stdout’
[13:24:38.609]   - Field: ‘earlySignal’
[13:24:38.609]   - Field: ‘lazy’
[13:24:38.610]   - Field: ‘state’
[13:24:38.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:38.610] - Launch lazy future ...
[13:24:38.610] Packages needed by the future expression (n = 0): <none>
[13:24:38.610] Packages needed by future strategies (n = 0): <none>
[13:24:38.611] {
[13:24:38.611]     {
[13:24:38.611]         {
[13:24:38.611]             ...future.startTime <- base::Sys.time()
[13:24:38.611]             {
[13:24:38.611]                 {
[13:24:38.611]                   {
[13:24:38.611]                     {
[13:24:38.611]                       base::local({
[13:24:38.611]                         has_future <- base::requireNamespace("future", 
[13:24:38.611]                           quietly = TRUE)
[13:24:38.611]                         if (has_future) {
[13:24:38.611]                           ns <- base::getNamespace("future")
[13:24:38.611]                           version <- ns[[".package"]][["version"]]
[13:24:38.611]                           if (is.null(version)) 
[13:24:38.611]                             version <- utils::packageVersion("future")
[13:24:38.611]                         }
[13:24:38.611]                         else {
[13:24:38.611]                           version <- NULL
[13:24:38.611]                         }
[13:24:38.611]                         if (!has_future || version < "1.8.0") {
[13:24:38.611]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:38.611]                             "", base::R.version$version.string), 
[13:24:38.611]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:38.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:38.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:38.611]                               "release", "version")], collapse = " "), 
[13:24:38.611]                             hostname = base::Sys.info()[["nodename"]])
[13:24:38.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:38.611]                             info)
[13:24:38.611]                           info <- base::paste(info, collapse = "; ")
[13:24:38.611]                           if (!has_future) {
[13:24:38.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:38.611]                               info)
[13:24:38.611]                           }
[13:24:38.611]                           else {
[13:24:38.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:38.611]                               info, version)
[13:24:38.611]                           }
[13:24:38.611]                           base::stop(msg)
[13:24:38.611]                         }
[13:24:38.611]                       })
[13:24:38.611]                     }
[13:24:38.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:38.611]                     base::options(mc.cores = 1L)
[13:24:38.611]                   }
[13:24:38.611]                   options(future.plan = NULL)
[13:24:38.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:38.611]                 }
[13:24:38.611]                 ...future.workdir <- getwd()
[13:24:38.611]             }
[13:24:38.611]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:38.611]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:38.611]         }
[13:24:38.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:38.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:38.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:38.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:38.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:38.611]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:38.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:38.611]             base::names(...future.oldOptions))
[13:24:38.611]     }
[13:24:38.611]     if (FALSE) {
[13:24:38.611]     }
[13:24:38.611]     else {
[13:24:38.611]         if (TRUE) {
[13:24:38.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:38.611]                 open = "w")
[13:24:38.611]         }
[13:24:38.611]         else {
[13:24:38.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:38.611]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:38.611]         }
[13:24:38.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:38.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:38.611]             base::sink(type = "output", split = FALSE)
[13:24:38.611]             base::close(...future.stdout)
[13:24:38.611]         }, add = TRUE)
[13:24:38.611]     }
[13:24:38.611]     ...future.frame <- base::sys.nframe()
[13:24:38.611]     ...future.conditions <- base::list()
[13:24:38.611]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:38.611]     if (FALSE) {
[13:24:38.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:38.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:38.611]     }
[13:24:38.611]     ...future.result <- base::tryCatch({
[13:24:38.611]         base::withCallingHandlers({
[13:24:38.611]             ...future.value <- base::withVisible(base::local({
[13:24:38.611]                 ...future.makeSendCondition <- base::local({
[13:24:38.611]                   sendCondition <- NULL
[13:24:38.611]                   function(frame = 1L) {
[13:24:38.611]                     if (is.function(sendCondition)) 
[13:24:38.611]                       return(sendCondition)
[13:24:38.611]                     ns <- getNamespace("parallel")
[13:24:38.611]                     if (exists("sendData", mode = "function", 
[13:24:38.611]                       envir = ns)) {
[13:24:38.611]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:38.611]                         envir = ns)
[13:24:38.611]                       envir <- sys.frame(frame)
[13:24:38.611]                       master <- NULL
[13:24:38.611]                       while (!identical(envir, .GlobalEnv) && 
[13:24:38.611]                         !identical(envir, emptyenv())) {
[13:24:38.611]                         if (exists("master", mode = "list", envir = envir, 
[13:24:38.611]                           inherits = FALSE)) {
[13:24:38.611]                           master <- get("master", mode = "list", 
[13:24:38.611]                             envir = envir, inherits = FALSE)
[13:24:38.611]                           if (inherits(master, c("SOCKnode", 
[13:24:38.611]                             "SOCK0node"))) {
[13:24:38.611]                             sendCondition <<- function(cond) {
[13:24:38.611]                               data <- list(type = "VALUE", value = cond, 
[13:24:38.611]                                 success = TRUE)
[13:24:38.611]                               parallel_sendData(master, data)
[13:24:38.611]                             }
[13:24:38.611]                             return(sendCondition)
[13:24:38.611]                           }
[13:24:38.611]                         }
[13:24:38.611]                         frame <- frame + 1L
[13:24:38.611]                         envir <- sys.frame(frame)
[13:24:38.611]                       }
[13:24:38.611]                     }
[13:24:38.611]                     sendCondition <<- function(cond) NULL
[13:24:38.611]                   }
[13:24:38.611]                 })
[13:24:38.611]                 withCallingHandlers({
[13:24:38.611]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:38.611]                 }, immediateCondition = function(cond) {
[13:24:38.611]                   sendCondition <- ...future.makeSendCondition()
[13:24:38.611]                   sendCondition(cond)
[13:24:38.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.611]                   {
[13:24:38.611]                     inherits <- base::inherits
[13:24:38.611]                     invokeRestart <- base::invokeRestart
[13:24:38.611]                     is.null <- base::is.null
[13:24:38.611]                     muffled <- FALSE
[13:24:38.611]                     if (inherits(cond, "message")) {
[13:24:38.611]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:38.611]                       if (muffled) 
[13:24:38.611]                         invokeRestart("muffleMessage")
[13:24:38.611]                     }
[13:24:38.611]                     else if (inherits(cond, "warning")) {
[13:24:38.611]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:38.611]                       if (muffled) 
[13:24:38.611]                         invokeRestart("muffleWarning")
[13:24:38.611]                     }
[13:24:38.611]                     else if (inherits(cond, "condition")) {
[13:24:38.611]                       if (!is.null(pattern)) {
[13:24:38.611]                         computeRestarts <- base::computeRestarts
[13:24:38.611]                         grepl <- base::grepl
[13:24:38.611]                         restarts <- computeRestarts(cond)
[13:24:38.611]                         for (restart in restarts) {
[13:24:38.611]                           name <- restart$name
[13:24:38.611]                           if (is.null(name)) 
[13:24:38.611]                             next
[13:24:38.611]                           if (!grepl(pattern, name)) 
[13:24:38.611]                             next
[13:24:38.611]                           invokeRestart(restart)
[13:24:38.611]                           muffled <- TRUE
[13:24:38.611]                           break
[13:24:38.611]                         }
[13:24:38.611]                       }
[13:24:38.611]                     }
[13:24:38.611]                     invisible(muffled)
[13:24:38.611]                   }
[13:24:38.611]                   muffleCondition(cond)
[13:24:38.611]                 })
[13:24:38.611]             }))
[13:24:38.611]             future::FutureResult(value = ...future.value$value, 
[13:24:38.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.611]                   ...future.rng), globalenv = if (FALSE) 
[13:24:38.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:38.611]                     ...future.globalenv.names))
[13:24:38.611]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:38.611]         }, condition = base::local({
[13:24:38.611]             c <- base::c
[13:24:38.611]             inherits <- base::inherits
[13:24:38.611]             invokeRestart <- base::invokeRestart
[13:24:38.611]             length <- base::length
[13:24:38.611]             list <- base::list
[13:24:38.611]             seq.int <- base::seq.int
[13:24:38.611]             signalCondition <- base::signalCondition
[13:24:38.611]             sys.calls <- base::sys.calls
[13:24:38.611]             `[[` <- base::`[[`
[13:24:38.611]             `+` <- base::`+`
[13:24:38.611]             `<<-` <- base::`<<-`
[13:24:38.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:38.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:38.611]                   3L)]
[13:24:38.611]             }
[13:24:38.611]             function(cond) {
[13:24:38.611]                 is_error <- inherits(cond, "error")
[13:24:38.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:38.611]                   NULL)
[13:24:38.611]                 if (is_error) {
[13:24:38.611]                   sessionInformation <- function() {
[13:24:38.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:38.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:38.611]                       search = base::search(), system = base::Sys.info())
[13:24:38.611]                   }
[13:24:38.611]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:38.611]                     cond$call), session = sessionInformation(), 
[13:24:38.611]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:38.611]                   signalCondition(cond)
[13:24:38.611]                 }
[13:24:38.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:38.611]                 "immediateCondition"))) {
[13:24:38.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:38.611]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:38.611]                   if (TRUE && !signal) {
[13:24:38.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.611]                     {
[13:24:38.611]                       inherits <- base::inherits
[13:24:38.611]                       invokeRestart <- base::invokeRestart
[13:24:38.611]                       is.null <- base::is.null
[13:24:38.611]                       muffled <- FALSE
[13:24:38.611]                       if (inherits(cond, "message")) {
[13:24:38.611]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.611]                         if (muffled) 
[13:24:38.611]                           invokeRestart("muffleMessage")
[13:24:38.611]                       }
[13:24:38.611]                       else if (inherits(cond, "warning")) {
[13:24:38.611]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.611]                         if (muffled) 
[13:24:38.611]                           invokeRestart("muffleWarning")
[13:24:38.611]                       }
[13:24:38.611]                       else if (inherits(cond, "condition")) {
[13:24:38.611]                         if (!is.null(pattern)) {
[13:24:38.611]                           computeRestarts <- base::computeRestarts
[13:24:38.611]                           grepl <- base::grepl
[13:24:38.611]                           restarts <- computeRestarts(cond)
[13:24:38.611]                           for (restart in restarts) {
[13:24:38.611]                             name <- restart$name
[13:24:38.611]                             if (is.null(name)) 
[13:24:38.611]                               next
[13:24:38.611]                             if (!grepl(pattern, name)) 
[13:24:38.611]                               next
[13:24:38.611]                             invokeRestart(restart)
[13:24:38.611]                             muffled <- TRUE
[13:24:38.611]                             break
[13:24:38.611]                           }
[13:24:38.611]                         }
[13:24:38.611]                       }
[13:24:38.611]                       invisible(muffled)
[13:24:38.611]                     }
[13:24:38.611]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.611]                   }
[13:24:38.611]                 }
[13:24:38.611]                 else {
[13:24:38.611]                   if (TRUE) {
[13:24:38.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.611]                     {
[13:24:38.611]                       inherits <- base::inherits
[13:24:38.611]                       invokeRestart <- base::invokeRestart
[13:24:38.611]                       is.null <- base::is.null
[13:24:38.611]                       muffled <- FALSE
[13:24:38.611]                       if (inherits(cond, "message")) {
[13:24:38.611]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.611]                         if (muffled) 
[13:24:38.611]                           invokeRestart("muffleMessage")
[13:24:38.611]                       }
[13:24:38.611]                       else if (inherits(cond, "warning")) {
[13:24:38.611]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.611]                         if (muffled) 
[13:24:38.611]                           invokeRestart("muffleWarning")
[13:24:38.611]                       }
[13:24:38.611]                       else if (inherits(cond, "condition")) {
[13:24:38.611]                         if (!is.null(pattern)) {
[13:24:38.611]                           computeRestarts <- base::computeRestarts
[13:24:38.611]                           grepl <- base::grepl
[13:24:38.611]                           restarts <- computeRestarts(cond)
[13:24:38.611]                           for (restart in restarts) {
[13:24:38.611]                             name <- restart$name
[13:24:38.611]                             if (is.null(name)) 
[13:24:38.611]                               next
[13:24:38.611]                             if (!grepl(pattern, name)) 
[13:24:38.611]                               next
[13:24:38.611]                             invokeRestart(restart)
[13:24:38.611]                             muffled <- TRUE
[13:24:38.611]                             break
[13:24:38.611]                           }
[13:24:38.611]                         }
[13:24:38.611]                       }
[13:24:38.611]                       invisible(muffled)
[13:24:38.611]                     }
[13:24:38.611]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.611]                   }
[13:24:38.611]                 }
[13:24:38.611]             }
[13:24:38.611]         }))
[13:24:38.611]     }, error = function(ex) {
[13:24:38.611]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:38.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.611]                 ...future.rng), started = ...future.startTime, 
[13:24:38.611]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:38.611]             version = "1.8"), class = "FutureResult")
[13:24:38.611]     }, finally = {
[13:24:38.611]         if (!identical(...future.workdir, getwd())) 
[13:24:38.611]             setwd(...future.workdir)
[13:24:38.611]         {
[13:24:38.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:38.611]                 ...future.oldOptions$nwarnings <- NULL
[13:24:38.611]             }
[13:24:38.611]             base::options(...future.oldOptions)
[13:24:38.611]             if (.Platform$OS.type == "windows") {
[13:24:38.611]                 old_names <- names(...future.oldEnvVars)
[13:24:38.611]                 envs <- base::Sys.getenv()
[13:24:38.611]                 names <- names(envs)
[13:24:38.611]                 common <- intersect(names, old_names)
[13:24:38.611]                 added <- setdiff(names, old_names)
[13:24:38.611]                 removed <- setdiff(old_names, names)
[13:24:38.611]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:38.611]                   envs[common]]
[13:24:38.611]                 NAMES <- toupper(changed)
[13:24:38.611]                 args <- list()
[13:24:38.611]                 for (kk in seq_along(NAMES)) {
[13:24:38.611]                   name <- changed[[kk]]
[13:24:38.611]                   NAME <- NAMES[[kk]]
[13:24:38.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.611]                     next
[13:24:38.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.611]                 }
[13:24:38.611]                 NAMES <- toupper(added)
[13:24:38.611]                 for (kk in seq_along(NAMES)) {
[13:24:38.611]                   name <- added[[kk]]
[13:24:38.611]                   NAME <- NAMES[[kk]]
[13:24:38.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.611]                     next
[13:24:38.611]                   args[[name]] <- ""
[13:24:38.611]                 }
[13:24:38.611]                 NAMES <- toupper(removed)
[13:24:38.611]                 for (kk in seq_along(NAMES)) {
[13:24:38.611]                   name <- removed[[kk]]
[13:24:38.611]                   NAME <- NAMES[[kk]]
[13:24:38.611]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.611]                     next
[13:24:38.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.611]                 }
[13:24:38.611]                 if (length(args) > 0) 
[13:24:38.611]                   base::do.call(base::Sys.setenv, args = args)
[13:24:38.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:38.611]             }
[13:24:38.611]             else {
[13:24:38.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:38.611]             }
[13:24:38.611]             {
[13:24:38.611]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:38.611]                   0L) {
[13:24:38.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:38.611]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:38.611]                   base::options(opts)
[13:24:38.611]                 }
[13:24:38.611]                 {
[13:24:38.611]                   {
[13:24:38.611]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:38.611]                     NULL
[13:24:38.611]                   }
[13:24:38.611]                   options(future.plan = NULL)
[13:24:38.611]                   if (is.na(NA_character_)) 
[13:24:38.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:38.611]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:38.611]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:38.611]                     envir = parent.frame()) 
[13:24:38.611]                   {
[13:24:38.611]                     if (is.function(workers)) 
[13:24:38.611]                       workers <- workers()
[13:24:38.611]                     workers <- structure(as.integer(workers), 
[13:24:38.611]                       class = class(workers))
[13:24:38.611]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:38.611]                       workers >= 1)
[13:24:38.611]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:38.611]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:38.611]                     }
[13:24:38.611]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:38.611]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:38.611]                       envir = envir)
[13:24:38.611]                     if (!future$lazy) 
[13:24:38.611]                       future <- run(future)
[13:24:38.611]                     invisible(future)
[13:24:38.611]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:38.611]                 }
[13:24:38.611]             }
[13:24:38.611]         }
[13:24:38.611]     })
[13:24:38.611]     if (TRUE) {
[13:24:38.611]         base::sink(type = "output", split = FALSE)
[13:24:38.611]         if (TRUE) {
[13:24:38.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:38.611]         }
[13:24:38.611]         else {
[13:24:38.611]             ...future.result["stdout"] <- base::list(NULL)
[13:24:38.611]         }
[13:24:38.611]         base::close(...future.stdout)
[13:24:38.611]         ...future.stdout <- NULL
[13:24:38.611]     }
[13:24:38.611]     ...future.result$conditions <- ...future.conditions
[13:24:38.611]     ...future.result$finished <- base::Sys.time()
[13:24:38.611]     ...future.result
[13:24:38.611] }
[13:24:38.614] MultisessionFuture started
[13:24:38.614] - Launch lazy future ... done
[13:24:38.614] run() for ‘MultisessionFuture’ ... done
[13:24:38.661] receiveMessageFromWorker() for ClusterFuture ...
[13:24:38.661] - Validating connection of MultisessionFuture
[13:24:38.662] - received message: FutureResult
[13:24:38.662] - Received FutureResult
[13:24:38.662] - Erased future from FutureRegistry
[13:24:38.662] result() for ClusterFuture ...
[13:24:38.662] - result already collected: FutureResult
[13:24:38.663] result() for ClusterFuture ... done
[13:24:38.663] signalConditions() ...
[13:24:38.663]  - include = ‘immediateCondition’
[13:24:38.663]  - exclude = 
[13:24:38.663]  - resignal = FALSE
[13:24:38.663]  - Number of conditions: 1
[13:24:38.663] signalConditions() ... done
[13:24:38.663] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:38.663] A MultisessionFuture was resolved
[13:24:38.663] getGlobalsAndPackages() ...
[13:24:38.664] Searching for globals...
[13:24:38.664] - globals found: [2] ‘list’, ‘stop’
[13:24:38.664] Searching for globals ... DONE
[13:24:38.665] Resolving globals: FALSE
[13:24:38.665] 
[13:24:38.665] 
[13:24:38.665] getGlobalsAndPackages() ... DONE
[13:24:38.665] run() for ‘Future’ ...
[13:24:38.665] - state: ‘created’
[13:24:38.666] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:38.680] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:38.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:38.680]   - Field: ‘node’
[13:24:38.680]   - Field: ‘label’
[13:24:38.680]   - Field: ‘local’
[13:24:38.680]   - Field: ‘owner’
[13:24:38.680]   - Field: ‘envir’
[13:24:38.681]   - Field: ‘workers’
[13:24:38.681]   - Field: ‘packages’
[13:24:38.681]   - Field: ‘gc’
[13:24:38.681]   - Field: ‘conditions’
[13:24:38.681]   - Field: ‘persistent’
[13:24:38.681]   - Field: ‘expr’
[13:24:38.681]   - Field: ‘uuid’
[13:24:38.681]   - Field: ‘seed’
[13:24:38.681]   - Field: ‘version’
[13:24:38.681]   - Field: ‘result’
[13:24:38.682]   - Field: ‘asynchronous’
[13:24:38.682]   - Field: ‘calls’
[13:24:38.682]   - Field: ‘globals’
[13:24:38.682]   - Field: ‘stdout’
[13:24:38.682]   - Field: ‘earlySignal’
[13:24:38.682]   - Field: ‘lazy’
[13:24:38.682]   - Field: ‘state’
[13:24:38.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:38.682] - Launch lazy future ...
[13:24:38.683] Packages needed by the future expression (n = 0): <none>
[13:24:38.683] Packages needed by future strategies (n = 0): <none>
[13:24:38.683] {
[13:24:38.683]     {
[13:24:38.683]         {
[13:24:38.683]             ...future.startTime <- base::Sys.time()
[13:24:38.683]             {
[13:24:38.683]                 {
[13:24:38.683]                   {
[13:24:38.683]                     {
[13:24:38.683]                       base::local({
[13:24:38.683]                         has_future <- base::requireNamespace("future", 
[13:24:38.683]                           quietly = TRUE)
[13:24:38.683]                         if (has_future) {
[13:24:38.683]                           ns <- base::getNamespace("future")
[13:24:38.683]                           version <- ns[[".package"]][["version"]]
[13:24:38.683]                           if (is.null(version)) 
[13:24:38.683]                             version <- utils::packageVersion("future")
[13:24:38.683]                         }
[13:24:38.683]                         else {
[13:24:38.683]                           version <- NULL
[13:24:38.683]                         }
[13:24:38.683]                         if (!has_future || version < "1.8.0") {
[13:24:38.683]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:38.683]                             "", base::R.version$version.string), 
[13:24:38.683]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:38.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:38.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:38.683]                               "release", "version")], collapse = " "), 
[13:24:38.683]                             hostname = base::Sys.info()[["nodename"]])
[13:24:38.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:38.683]                             info)
[13:24:38.683]                           info <- base::paste(info, collapse = "; ")
[13:24:38.683]                           if (!has_future) {
[13:24:38.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:38.683]                               info)
[13:24:38.683]                           }
[13:24:38.683]                           else {
[13:24:38.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:38.683]                               info, version)
[13:24:38.683]                           }
[13:24:38.683]                           base::stop(msg)
[13:24:38.683]                         }
[13:24:38.683]                       })
[13:24:38.683]                     }
[13:24:38.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:38.683]                     base::options(mc.cores = 1L)
[13:24:38.683]                   }
[13:24:38.683]                   options(future.plan = NULL)
[13:24:38.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:38.683]                 }
[13:24:38.683]                 ...future.workdir <- getwd()
[13:24:38.683]             }
[13:24:38.683]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:38.683]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:38.683]         }
[13:24:38.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:38.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:38.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:38.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:38.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:38.683]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:38.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:38.683]             base::names(...future.oldOptions))
[13:24:38.683]     }
[13:24:38.683]     if (FALSE) {
[13:24:38.683]     }
[13:24:38.683]     else {
[13:24:38.683]         if (TRUE) {
[13:24:38.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:38.683]                 open = "w")
[13:24:38.683]         }
[13:24:38.683]         else {
[13:24:38.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:38.683]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:38.683]         }
[13:24:38.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:38.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:38.683]             base::sink(type = "output", split = FALSE)
[13:24:38.683]             base::close(...future.stdout)
[13:24:38.683]         }, add = TRUE)
[13:24:38.683]     }
[13:24:38.683]     ...future.frame <- base::sys.nframe()
[13:24:38.683]     ...future.conditions <- base::list()
[13:24:38.683]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:38.683]     if (FALSE) {
[13:24:38.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:38.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:38.683]     }
[13:24:38.683]     ...future.result <- base::tryCatch({
[13:24:38.683]         base::withCallingHandlers({
[13:24:38.683]             ...future.value <- base::withVisible(base::local({
[13:24:38.683]                 ...future.makeSendCondition <- base::local({
[13:24:38.683]                   sendCondition <- NULL
[13:24:38.683]                   function(frame = 1L) {
[13:24:38.683]                     if (is.function(sendCondition)) 
[13:24:38.683]                       return(sendCondition)
[13:24:38.683]                     ns <- getNamespace("parallel")
[13:24:38.683]                     if (exists("sendData", mode = "function", 
[13:24:38.683]                       envir = ns)) {
[13:24:38.683]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:38.683]                         envir = ns)
[13:24:38.683]                       envir <- sys.frame(frame)
[13:24:38.683]                       master <- NULL
[13:24:38.683]                       while (!identical(envir, .GlobalEnv) && 
[13:24:38.683]                         !identical(envir, emptyenv())) {
[13:24:38.683]                         if (exists("master", mode = "list", envir = envir, 
[13:24:38.683]                           inherits = FALSE)) {
[13:24:38.683]                           master <- get("master", mode = "list", 
[13:24:38.683]                             envir = envir, inherits = FALSE)
[13:24:38.683]                           if (inherits(master, c("SOCKnode", 
[13:24:38.683]                             "SOCK0node"))) {
[13:24:38.683]                             sendCondition <<- function(cond) {
[13:24:38.683]                               data <- list(type = "VALUE", value = cond, 
[13:24:38.683]                                 success = TRUE)
[13:24:38.683]                               parallel_sendData(master, data)
[13:24:38.683]                             }
[13:24:38.683]                             return(sendCondition)
[13:24:38.683]                           }
[13:24:38.683]                         }
[13:24:38.683]                         frame <- frame + 1L
[13:24:38.683]                         envir <- sys.frame(frame)
[13:24:38.683]                       }
[13:24:38.683]                     }
[13:24:38.683]                     sendCondition <<- function(cond) NULL
[13:24:38.683]                   }
[13:24:38.683]                 })
[13:24:38.683]                 withCallingHandlers({
[13:24:38.683]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:38.683]                 }, immediateCondition = function(cond) {
[13:24:38.683]                   sendCondition <- ...future.makeSendCondition()
[13:24:38.683]                   sendCondition(cond)
[13:24:38.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.683]                   {
[13:24:38.683]                     inherits <- base::inherits
[13:24:38.683]                     invokeRestart <- base::invokeRestart
[13:24:38.683]                     is.null <- base::is.null
[13:24:38.683]                     muffled <- FALSE
[13:24:38.683]                     if (inherits(cond, "message")) {
[13:24:38.683]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:38.683]                       if (muffled) 
[13:24:38.683]                         invokeRestart("muffleMessage")
[13:24:38.683]                     }
[13:24:38.683]                     else if (inherits(cond, "warning")) {
[13:24:38.683]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:38.683]                       if (muffled) 
[13:24:38.683]                         invokeRestart("muffleWarning")
[13:24:38.683]                     }
[13:24:38.683]                     else if (inherits(cond, "condition")) {
[13:24:38.683]                       if (!is.null(pattern)) {
[13:24:38.683]                         computeRestarts <- base::computeRestarts
[13:24:38.683]                         grepl <- base::grepl
[13:24:38.683]                         restarts <- computeRestarts(cond)
[13:24:38.683]                         for (restart in restarts) {
[13:24:38.683]                           name <- restart$name
[13:24:38.683]                           if (is.null(name)) 
[13:24:38.683]                             next
[13:24:38.683]                           if (!grepl(pattern, name)) 
[13:24:38.683]                             next
[13:24:38.683]                           invokeRestart(restart)
[13:24:38.683]                           muffled <- TRUE
[13:24:38.683]                           break
[13:24:38.683]                         }
[13:24:38.683]                       }
[13:24:38.683]                     }
[13:24:38.683]                     invisible(muffled)
[13:24:38.683]                   }
[13:24:38.683]                   muffleCondition(cond)
[13:24:38.683]                 })
[13:24:38.683]             }))
[13:24:38.683]             future::FutureResult(value = ...future.value$value, 
[13:24:38.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.683]                   ...future.rng), globalenv = if (FALSE) 
[13:24:38.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:38.683]                     ...future.globalenv.names))
[13:24:38.683]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:38.683]         }, condition = base::local({
[13:24:38.683]             c <- base::c
[13:24:38.683]             inherits <- base::inherits
[13:24:38.683]             invokeRestart <- base::invokeRestart
[13:24:38.683]             length <- base::length
[13:24:38.683]             list <- base::list
[13:24:38.683]             seq.int <- base::seq.int
[13:24:38.683]             signalCondition <- base::signalCondition
[13:24:38.683]             sys.calls <- base::sys.calls
[13:24:38.683]             `[[` <- base::`[[`
[13:24:38.683]             `+` <- base::`+`
[13:24:38.683]             `<<-` <- base::`<<-`
[13:24:38.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:38.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:38.683]                   3L)]
[13:24:38.683]             }
[13:24:38.683]             function(cond) {
[13:24:38.683]                 is_error <- inherits(cond, "error")
[13:24:38.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:38.683]                   NULL)
[13:24:38.683]                 if (is_error) {
[13:24:38.683]                   sessionInformation <- function() {
[13:24:38.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:38.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:38.683]                       search = base::search(), system = base::Sys.info())
[13:24:38.683]                   }
[13:24:38.683]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:38.683]                     cond$call), session = sessionInformation(), 
[13:24:38.683]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:38.683]                   signalCondition(cond)
[13:24:38.683]                 }
[13:24:38.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:38.683]                 "immediateCondition"))) {
[13:24:38.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:38.683]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:38.683]                   if (TRUE && !signal) {
[13:24:38.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.683]                     {
[13:24:38.683]                       inherits <- base::inherits
[13:24:38.683]                       invokeRestart <- base::invokeRestart
[13:24:38.683]                       is.null <- base::is.null
[13:24:38.683]                       muffled <- FALSE
[13:24:38.683]                       if (inherits(cond, "message")) {
[13:24:38.683]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.683]                         if (muffled) 
[13:24:38.683]                           invokeRestart("muffleMessage")
[13:24:38.683]                       }
[13:24:38.683]                       else if (inherits(cond, "warning")) {
[13:24:38.683]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.683]                         if (muffled) 
[13:24:38.683]                           invokeRestart("muffleWarning")
[13:24:38.683]                       }
[13:24:38.683]                       else if (inherits(cond, "condition")) {
[13:24:38.683]                         if (!is.null(pattern)) {
[13:24:38.683]                           computeRestarts <- base::computeRestarts
[13:24:38.683]                           grepl <- base::grepl
[13:24:38.683]                           restarts <- computeRestarts(cond)
[13:24:38.683]                           for (restart in restarts) {
[13:24:38.683]                             name <- restart$name
[13:24:38.683]                             if (is.null(name)) 
[13:24:38.683]                               next
[13:24:38.683]                             if (!grepl(pattern, name)) 
[13:24:38.683]                               next
[13:24:38.683]                             invokeRestart(restart)
[13:24:38.683]                             muffled <- TRUE
[13:24:38.683]                             break
[13:24:38.683]                           }
[13:24:38.683]                         }
[13:24:38.683]                       }
[13:24:38.683]                       invisible(muffled)
[13:24:38.683]                     }
[13:24:38.683]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.683]                   }
[13:24:38.683]                 }
[13:24:38.683]                 else {
[13:24:38.683]                   if (TRUE) {
[13:24:38.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.683]                     {
[13:24:38.683]                       inherits <- base::inherits
[13:24:38.683]                       invokeRestart <- base::invokeRestart
[13:24:38.683]                       is.null <- base::is.null
[13:24:38.683]                       muffled <- FALSE
[13:24:38.683]                       if (inherits(cond, "message")) {
[13:24:38.683]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.683]                         if (muffled) 
[13:24:38.683]                           invokeRestart("muffleMessage")
[13:24:38.683]                       }
[13:24:38.683]                       else if (inherits(cond, "warning")) {
[13:24:38.683]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.683]                         if (muffled) 
[13:24:38.683]                           invokeRestart("muffleWarning")
[13:24:38.683]                       }
[13:24:38.683]                       else if (inherits(cond, "condition")) {
[13:24:38.683]                         if (!is.null(pattern)) {
[13:24:38.683]                           computeRestarts <- base::computeRestarts
[13:24:38.683]                           grepl <- base::grepl
[13:24:38.683]                           restarts <- computeRestarts(cond)
[13:24:38.683]                           for (restart in restarts) {
[13:24:38.683]                             name <- restart$name
[13:24:38.683]                             if (is.null(name)) 
[13:24:38.683]                               next
[13:24:38.683]                             if (!grepl(pattern, name)) 
[13:24:38.683]                               next
[13:24:38.683]                             invokeRestart(restart)
[13:24:38.683]                             muffled <- TRUE
[13:24:38.683]                             break
[13:24:38.683]                           }
[13:24:38.683]                         }
[13:24:38.683]                       }
[13:24:38.683]                       invisible(muffled)
[13:24:38.683]                     }
[13:24:38.683]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.683]                   }
[13:24:38.683]                 }
[13:24:38.683]             }
[13:24:38.683]         }))
[13:24:38.683]     }, error = function(ex) {
[13:24:38.683]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:38.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.683]                 ...future.rng), started = ...future.startTime, 
[13:24:38.683]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:38.683]             version = "1.8"), class = "FutureResult")
[13:24:38.683]     }, finally = {
[13:24:38.683]         if (!identical(...future.workdir, getwd())) 
[13:24:38.683]             setwd(...future.workdir)
[13:24:38.683]         {
[13:24:38.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:38.683]                 ...future.oldOptions$nwarnings <- NULL
[13:24:38.683]             }
[13:24:38.683]             base::options(...future.oldOptions)
[13:24:38.683]             if (.Platform$OS.type == "windows") {
[13:24:38.683]                 old_names <- names(...future.oldEnvVars)
[13:24:38.683]                 envs <- base::Sys.getenv()
[13:24:38.683]                 names <- names(envs)
[13:24:38.683]                 common <- intersect(names, old_names)
[13:24:38.683]                 added <- setdiff(names, old_names)
[13:24:38.683]                 removed <- setdiff(old_names, names)
[13:24:38.683]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:38.683]                   envs[common]]
[13:24:38.683]                 NAMES <- toupper(changed)
[13:24:38.683]                 args <- list()
[13:24:38.683]                 for (kk in seq_along(NAMES)) {
[13:24:38.683]                   name <- changed[[kk]]
[13:24:38.683]                   NAME <- NAMES[[kk]]
[13:24:38.683]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.683]                     next
[13:24:38.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.683]                 }
[13:24:38.683]                 NAMES <- toupper(added)
[13:24:38.683]                 for (kk in seq_along(NAMES)) {
[13:24:38.683]                   name <- added[[kk]]
[13:24:38.683]                   NAME <- NAMES[[kk]]
[13:24:38.683]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.683]                     next
[13:24:38.683]                   args[[name]] <- ""
[13:24:38.683]                 }
[13:24:38.683]                 NAMES <- toupper(removed)
[13:24:38.683]                 for (kk in seq_along(NAMES)) {
[13:24:38.683]                   name <- removed[[kk]]
[13:24:38.683]                   NAME <- NAMES[[kk]]
[13:24:38.683]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.683]                     next
[13:24:38.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.683]                 }
[13:24:38.683]                 if (length(args) > 0) 
[13:24:38.683]                   base::do.call(base::Sys.setenv, args = args)
[13:24:38.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:38.683]             }
[13:24:38.683]             else {
[13:24:38.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:38.683]             }
[13:24:38.683]             {
[13:24:38.683]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:38.683]                   0L) {
[13:24:38.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:38.683]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:38.683]                   base::options(opts)
[13:24:38.683]                 }
[13:24:38.683]                 {
[13:24:38.683]                   {
[13:24:38.683]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:38.683]                     NULL
[13:24:38.683]                   }
[13:24:38.683]                   options(future.plan = NULL)
[13:24:38.683]                   if (is.na(NA_character_)) 
[13:24:38.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:38.683]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:38.683]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:38.683]                     envir = parent.frame()) 
[13:24:38.683]                   {
[13:24:38.683]                     if (is.function(workers)) 
[13:24:38.683]                       workers <- workers()
[13:24:38.683]                     workers <- structure(as.integer(workers), 
[13:24:38.683]                       class = class(workers))
[13:24:38.683]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:38.683]                       workers >= 1)
[13:24:38.683]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:38.683]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:38.683]                     }
[13:24:38.683]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:38.683]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:38.683]                       envir = envir)
[13:24:38.683]                     if (!future$lazy) 
[13:24:38.683]                       future <- run(future)
[13:24:38.683]                     invisible(future)
[13:24:38.683]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:38.683]                 }
[13:24:38.683]             }
[13:24:38.683]         }
[13:24:38.683]     })
[13:24:38.683]     if (TRUE) {
[13:24:38.683]         base::sink(type = "output", split = FALSE)
[13:24:38.683]         if (TRUE) {
[13:24:38.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:38.683]         }
[13:24:38.683]         else {
[13:24:38.683]             ...future.result["stdout"] <- base::list(NULL)
[13:24:38.683]         }
[13:24:38.683]         base::close(...future.stdout)
[13:24:38.683]         ...future.stdout <- NULL
[13:24:38.683]     }
[13:24:38.683]     ...future.result$conditions <- ...future.conditions
[13:24:38.683]     ...future.result$finished <- base::Sys.time()
[13:24:38.683]     ...future.result
[13:24:38.683] }
[13:24:38.687] MultisessionFuture started
[13:24:38.687] - Launch lazy future ... done
[13:24:38.687] run() for ‘MultisessionFuture’ ... done
[13:24:38.733] receiveMessageFromWorker() for ClusterFuture ...
[13:24:38.734] - Validating connection of MultisessionFuture
[13:24:38.734] - received message: FutureResult
[13:24:38.734] - Received FutureResult
[13:24:38.735] - Erased future from FutureRegistry
[13:24:38.735] result() for ClusterFuture ...
[13:24:38.735] - result already collected: FutureResult
[13:24:38.735] result() for ClusterFuture ... done
[13:24:38.735] signalConditions() ...
[13:24:38.735]  - include = ‘immediateCondition’
[13:24:38.735]  - exclude = 
[13:24:38.735]  - resignal = FALSE
[13:24:38.735]  - Number of conditions: 1
[13:24:38.736] signalConditions() ... done
[13:24:38.736] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:38.736] A MultisessionFuture was resolved
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[13:24:38.736] getGlobalsAndPackages() ...
[13:24:38.736] Searching for globals...
[13:24:38.737] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:38.737] Searching for globals ... DONE
[13:24:38.738] Resolving globals: FALSE
[13:24:38.738] 
[13:24:38.738] 
[13:24:38.738] getGlobalsAndPackages() ... DONE
[13:24:38.738] run() for ‘Future’ ...
[13:24:38.738] - state: ‘created’
[13:24:38.739] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:38.753] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:38.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:38.753]   - Field: ‘node’
[13:24:38.753]   - Field: ‘label’
[13:24:38.753]   - Field: ‘local’
[13:24:38.754]   - Field: ‘owner’
[13:24:38.754]   - Field: ‘envir’
[13:24:38.754]   - Field: ‘workers’
[13:24:38.754]   - Field: ‘packages’
[13:24:38.754]   - Field: ‘gc’
[13:24:38.754]   - Field: ‘conditions’
[13:24:38.754]   - Field: ‘persistent’
[13:24:38.754]   - Field: ‘expr’
[13:24:38.754]   - Field: ‘uuid’
[13:24:38.754]   - Field: ‘seed’
[13:24:38.754]   - Field: ‘version’
[13:24:38.755]   - Field: ‘result’
[13:24:38.755]   - Field: ‘asynchronous’
[13:24:38.755]   - Field: ‘calls’
[13:24:38.755]   - Field: ‘globals’
[13:24:38.755]   - Field: ‘stdout’
[13:24:38.755]   - Field: ‘earlySignal’
[13:24:38.755]   - Field: ‘lazy’
[13:24:38.755]   - Field: ‘state’
[13:24:38.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:38.755] - Launch lazy future ...
[13:24:38.756] Packages needed by the future expression (n = 0): <none>
[13:24:38.756] Packages needed by future strategies (n = 0): <none>
[13:24:38.756] {
[13:24:38.756]     {
[13:24:38.756]         {
[13:24:38.756]             ...future.startTime <- base::Sys.time()
[13:24:38.756]             {
[13:24:38.756]                 {
[13:24:38.756]                   {
[13:24:38.756]                     {
[13:24:38.756]                       base::local({
[13:24:38.756]                         has_future <- base::requireNamespace("future", 
[13:24:38.756]                           quietly = TRUE)
[13:24:38.756]                         if (has_future) {
[13:24:38.756]                           ns <- base::getNamespace("future")
[13:24:38.756]                           version <- ns[[".package"]][["version"]]
[13:24:38.756]                           if (is.null(version)) 
[13:24:38.756]                             version <- utils::packageVersion("future")
[13:24:38.756]                         }
[13:24:38.756]                         else {
[13:24:38.756]                           version <- NULL
[13:24:38.756]                         }
[13:24:38.756]                         if (!has_future || version < "1.8.0") {
[13:24:38.756]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:38.756]                             "", base::R.version$version.string), 
[13:24:38.756]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:38.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:38.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:38.756]                               "release", "version")], collapse = " "), 
[13:24:38.756]                             hostname = base::Sys.info()[["nodename"]])
[13:24:38.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:38.756]                             info)
[13:24:38.756]                           info <- base::paste(info, collapse = "; ")
[13:24:38.756]                           if (!has_future) {
[13:24:38.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:38.756]                               info)
[13:24:38.756]                           }
[13:24:38.756]                           else {
[13:24:38.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:38.756]                               info, version)
[13:24:38.756]                           }
[13:24:38.756]                           base::stop(msg)
[13:24:38.756]                         }
[13:24:38.756]                       })
[13:24:38.756]                     }
[13:24:38.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:38.756]                     base::options(mc.cores = 1L)
[13:24:38.756]                   }
[13:24:38.756]                   options(future.plan = NULL)
[13:24:38.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:38.756]                 }
[13:24:38.756]                 ...future.workdir <- getwd()
[13:24:38.756]             }
[13:24:38.756]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:38.756]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:38.756]         }
[13:24:38.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:38.756]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:38.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:38.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:38.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:38.756]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:38.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:38.756]             base::names(...future.oldOptions))
[13:24:38.756]     }
[13:24:38.756]     if (FALSE) {
[13:24:38.756]     }
[13:24:38.756]     else {
[13:24:38.756]         if (TRUE) {
[13:24:38.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:38.756]                 open = "w")
[13:24:38.756]         }
[13:24:38.756]         else {
[13:24:38.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:38.756]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:38.756]         }
[13:24:38.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:38.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:38.756]             base::sink(type = "output", split = FALSE)
[13:24:38.756]             base::close(...future.stdout)
[13:24:38.756]         }, add = TRUE)
[13:24:38.756]     }
[13:24:38.756]     ...future.frame <- base::sys.nframe()
[13:24:38.756]     ...future.conditions <- base::list()
[13:24:38.756]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:38.756]     if (FALSE) {
[13:24:38.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:38.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:38.756]     }
[13:24:38.756]     ...future.result <- base::tryCatch({
[13:24:38.756]         base::withCallingHandlers({
[13:24:38.756]             ...future.value <- base::withVisible(base::local({
[13:24:38.756]                 ...future.makeSendCondition <- base::local({
[13:24:38.756]                   sendCondition <- NULL
[13:24:38.756]                   function(frame = 1L) {
[13:24:38.756]                     if (is.function(sendCondition)) 
[13:24:38.756]                       return(sendCondition)
[13:24:38.756]                     ns <- getNamespace("parallel")
[13:24:38.756]                     if (exists("sendData", mode = "function", 
[13:24:38.756]                       envir = ns)) {
[13:24:38.756]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:38.756]                         envir = ns)
[13:24:38.756]                       envir <- sys.frame(frame)
[13:24:38.756]                       master <- NULL
[13:24:38.756]                       while (!identical(envir, .GlobalEnv) && 
[13:24:38.756]                         !identical(envir, emptyenv())) {
[13:24:38.756]                         if (exists("master", mode = "list", envir = envir, 
[13:24:38.756]                           inherits = FALSE)) {
[13:24:38.756]                           master <- get("master", mode = "list", 
[13:24:38.756]                             envir = envir, inherits = FALSE)
[13:24:38.756]                           if (inherits(master, c("SOCKnode", 
[13:24:38.756]                             "SOCK0node"))) {
[13:24:38.756]                             sendCondition <<- function(cond) {
[13:24:38.756]                               data <- list(type = "VALUE", value = cond, 
[13:24:38.756]                                 success = TRUE)
[13:24:38.756]                               parallel_sendData(master, data)
[13:24:38.756]                             }
[13:24:38.756]                             return(sendCondition)
[13:24:38.756]                           }
[13:24:38.756]                         }
[13:24:38.756]                         frame <- frame + 1L
[13:24:38.756]                         envir <- sys.frame(frame)
[13:24:38.756]                       }
[13:24:38.756]                     }
[13:24:38.756]                     sendCondition <<- function(cond) NULL
[13:24:38.756]                   }
[13:24:38.756]                 })
[13:24:38.756]                 withCallingHandlers({
[13:24:38.756]                   {
[13:24:38.756]                     Sys.sleep(0.5)
[13:24:38.756]                     list(a = 1, b = 42L)
[13:24:38.756]                   }
[13:24:38.756]                 }, immediateCondition = function(cond) {
[13:24:38.756]                   sendCondition <- ...future.makeSendCondition()
[13:24:38.756]                   sendCondition(cond)
[13:24:38.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.756]                   {
[13:24:38.756]                     inherits <- base::inherits
[13:24:38.756]                     invokeRestart <- base::invokeRestart
[13:24:38.756]                     is.null <- base::is.null
[13:24:38.756]                     muffled <- FALSE
[13:24:38.756]                     if (inherits(cond, "message")) {
[13:24:38.756]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:38.756]                       if (muffled) 
[13:24:38.756]                         invokeRestart("muffleMessage")
[13:24:38.756]                     }
[13:24:38.756]                     else if (inherits(cond, "warning")) {
[13:24:38.756]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:38.756]                       if (muffled) 
[13:24:38.756]                         invokeRestart("muffleWarning")
[13:24:38.756]                     }
[13:24:38.756]                     else if (inherits(cond, "condition")) {
[13:24:38.756]                       if (!is.null(pattern)) {
[13:24:38.756]                         computeRestarts <- base::computeRestarts
[13:24:38.756]                         grepl <- base::grepl
[13:24:38.756]                         restarts <- computeRestarts(cond)
[13:24:38.756]                         for (restart in restarts) {
[13:24:38.756]                           name <- restart$name
[13:24:38.756]                           if (is.null(name)) 
[13:24:38.756]                             next
[13:24:38.756]                           if (!grepl(pattern, name)) 
[13:24:38.756]                             next
[13:24:38.756]                           invokeRestart(restart)
[13:24:38.756]                           muffled <- TRUE
[13:24:38.756]                           break
[13:24:38.756]                         }
[13:24:38.756]                       }
[13:24:38.756]                     }
[13:24:38.756]                     invisible(muffled)
[13:24:38.756]                   }
[13:24:38.756]                   muffleCondition(cond)
[13:24:38.756]                 })
[13:24:38.756]             }))
[13:24:38.756]             future::FutureResult(value = ...future.value$value, 
[13:24:38.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.756]                   ...future.rng), globalenv = if (FALSE) 
[13:24:38.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:38.756]                     ...future.globalenv.names))
[13:24:38.756]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:38.756]         }, condition = base::local({
[13:24:38.756]             c <- base::c
[13:24:38.756]             inherits <- base::inherits
[13:24:38.756]             invokeRestart <- base::invokeRestart
[13:24:38.756]             length <- base::length
[13:24:38.756]             list <- base::list
[13:24:38.756]             seq.int <- base::seq.int
[13:24:38.756]             signalCondition <- base::signalCondition
[13:24:38.756]             sys.calls <- base::sys.calls
[13:24:38.756]             `[[` <- base::`[[`
[13:24:38.756]             `+` <- base::`+`
[13:24:38.756]             `<<-` <- base::`<<-`
[13:24:38.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:38.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:38.756]                   3L)]
[13:24:38.756]             }
[13:24:38.756]             function(cond) {
[13:24:38.756]                 is_error <- inherits(cond, "error")
[13:24:38.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:38.756]                   NULL)
[13:24:38.756]                 if (is_error) {
[13:24:38.756]                   sessionInformation <- function() {
[13:24:38.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:38.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:38.756]                       search = base::search(), system = base::Sys.info())
[13:24:38.756]                   }
[13:24:38.756]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:38.756]                     cond$call), session = sessionInformation(), 
[13:24:38.756]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:38.756]                   signalCondition(cond)
[13:24:38.756]                 }
[13:24:38.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:38.756]                 "immediateCondition"))) {
[13:24:38.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:38.756]                   ...future.conditions[[length(...future.conditions) + 
[13:24:38.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:38.756]                   if (TRUE && !signal) {
[13:24:38.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.756]                     {
[13:24:38.756]                       inherits <- base::inherits
[13:24:38.756]                       invokeRestart <- base::invokeRestart
[13:24:38.756]                       is.null <- base::is.null
[13:24:38.756]                       muffled <- FALSE
[13:24:38.756]                       if (inherits(cond, "message")) {
[13:24:38.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.756]                         if (muffled) 
[13:24:38.756]                           invokeRestart("muffleMessage")
[13:24:38.756]                       }
[13:24:38.756]                       else if (inherits(cond, "warning")) {
[13:24:38.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.756]                         if (muffled) 
[13:24:38.756]                           invokeRestart("muffleWarning")
[13:24:38.756]                       }
[13:24:38.756]                       else if (inherits(cond, "condition")) {
[13:24:38.756]                         if (!is.null(pattern)) {
[13:24:38.756]                           computeRestarts <- base::computeRestarts
[13:24:38.756]                           grepl <- base::grepl
[13:24:38.756]                           restarts <- computeRestarts(cond)
[13:24:38.756]                           for (restart in restarts) {
[13:24:38.756]                             name <- restart$name
[13:24:38.756]                             if (is.null(name)) 
[13:24:38.756]                               next
[13:24:38.756]                             if (!grepl(pattern, name)) 
[13:24:38.756]                               next
[13:24:38.756]                             invokeRestart(restart)
[13:24:38.756]                             muffled <- TRUE
[13:24:38.756]                             break
[13:24:38.756]                           }
[13:24:38.756]                         }
[13:24:38.756]                       }
[13:24:38.756]                       invisible(muffled)
[13:24:38.756]                     }
[13:24:38.756]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.756]                   }
[13:24:38.756]                 }
[13:24:38.756]                 else {
[13:24:38.756]                   if (TRUE) {
[13:24:38.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:38.756]                     {
[13:24:38.756]                       inherits <- base::inherits
[13:24:38.756]                       invokeRestart <- base::invokeRestart
[13:24:38.756]                       is.null <- base::is.null
[13:24:38.756]                       muffled <- FALSE
[13:24:38.756]                       if (inherits(cond, "message")) {
[13:24:38.756]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:38.756]                         if (muffled) 
[13:24:38.756]                           invokeRestart("muffleMessage")
[13:24:38.756]                       }
[13:24:38.756]                       else if (inherits(cond, "warning")) {
[13:24:38.756]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:38.756]                         if (muffled) 
[13:24:38.756]                           invokeRestart("muffleWarning")
[13:24:38.756]                       }
[13:24:38.756]                       else if (inherits(cond, "condition")) {
[13:24:38.756]                         if (!is.null(pattern)) {
[13:24:38.756]                           computeRestarts <- base::computeRestarts
[13:24:38.756]                           grepl <- base::grepl
[13:24:38.756]                           restarts <- computeRestarts(cond)
[13:24:38.756]                           for (restart in restarts) {
[13:24:38.756]                             name <- restart$name
[13:24:38.756]                             if (is.null(name)) 
[13:24:38.756]                               next
[13:24:38.756]                             if (!grepl(pattern, name)) 
[13:24:38.756]                               next
[13:24:38.756]                             invokeRestart(restart)
[13:24:38.756]                             muffled <- TRUE
[13:24:38.756]                             break
[13:24:38.756]                           }
[13:24:38.756]                         }
[13:24:38.756]                       }
[13:24:38.756]                       invisible(muffled)
[13:24:38.756]                     }
[13:24:38.756]                     muffleCondition(cond, pattern = "^muffle")
[13:24:38.756]                   }
[13:24:38.756]                 }
[13:24:38.756]             }
[13:24:38.756]         }))
[13:24:38.756]     }, error = function(ex) {
[13:24:38.756]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:38.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:38.756]                 ...future.rng), started = ...future.startTime, 
[13:24:38.756]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:38.756]             version = "1.8"), class = "FutureResult")
[13:24:38.756]     }, finally = {
[13:24:38.756]         if (!identical(...future.workdir, getwd())) 
[13:24:38.756]             setwd(...future.workdir)
[13:24:38.756]         {
[13:24:38.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:38.756]                 ...future.oldOptions$nwarnings <- NULL
[13:24:38.756]             }
[13:24:38.756]             base::options(...future.oldOptions)
[13:24:38.756]             if (.Platform$OS.type == "windows") {
[13:24:38.756]                 old_names <- names(...future.oldEnvVars)
[13:24:38.756]                 envs <- base::Sys.getenv()
[13:24:38.756]                 names <- names(envs)
[13:24:38.756]                 common <- intersect(names, old_names)
[13:24:38.756]                 added <- setdiff(names, old_names)
[13:24:38.756]                 removed <- setdiff(old_names, names)
[13:24:38.756]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:38.756]                   envs[common]]
[13:24:38.756]                 NAMES <- toupper(changed)
[13:24:38.756]                 args <- list()
[13:24:38.756]                 for (kk in seq_along(NAMES)) {
[13:24:38.756]                   name <- changed[[kk]]
[13:24:38.756]                   NAME <- NAMES[[kk]]
[13:24:38.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.756]                     next
[13:24:38.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.756]                 }
[13:24:38.756]                 NAMES <- toupper(added)
[13:24:38.756]                 for (kk in seq_along(NAMES)) {
[13:24:38.756]                   name <- added[[kk]]
[13:24:38.756]                   NAME <- NAMES[[kk]]
[13:24:38.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.756]                     next
[13:24:38.756]                   args[[name]] <- ""
[13:24:38.756]                 }
[13:24:38.756]                 NAMES <- toupper(removed)
[13:24:38.756]                 for (kk in seq_along(NAMES)) {
[13:24:38.756]                   name <- removed[[kk]]
[13:24:38.756]                   NAME <- NAMES[[kk]]
[13:24:38.756]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:38.756]                     next
[13:24:38.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:38.756]                 }
[13:24:38.756]                 if (length(args) > 0) 
[13:24:38.756]                   base::do.call(base::Sys.setenv, args = args)
[13:24:38.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:38.756]             }
[13:24:38.756]             else {
[13:24:38.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:38.756]             }
[13:24:38.756]             {
[13:24:38.756]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:38.756]                   0L) {
[13:24:38.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:38.756]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:38.756]                   base::options(opts)
[13:24:38.756]                 }
[13:24:38.756]                 {
[13:24:38.756]                   {
[13:24:38.756]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:38.756]                     NULL
[13:24:38.756]                   }
[13:24:38.756]                   options(future.plan = NULL)
[13:24:38.756]                   if (is.na(NA_character_)) 
[13:24:38.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:38.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:38.756]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:38.756]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:38.756]                     envir = parent.frame()) 
[13:24:38.756]                   {
[13:24:38.756]                     if (is.function(workers)) 
[13:24:38.756]                       workers <- workers()
[13:24:38.756]                     workers <- structure(as.integer(workers), 
[13:24:38.756]                       class = class(workers))
[13:24:38.756]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:38.756]                       workers >= 1)
[13:24:38.756]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:38.756]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:38.756]                     }
[13:24:38.756]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:38.756]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:38.756]                       envir = envir)
[13:24:38.756]                     if (!future$lazy) 
[13:24:38.756]                       future <- run(future)
[13:24:38.756]                     invisible(future)
[13:24:38.756]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:38.756]                 }
[13:24:38.756]             }
[13:24:38.756]         }
[13:24:38.756]     })
[13:24:38.756]     if (TRUE) {
[13:24:38.756]         base::sink(type = "output", split = FALSE)
[13:24:38.756]         if (TRUE) {
[13:24:38.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:38.756]         }
[13:24:38.756]         else {
[13:24:38.756]             ...future.result["stdout"] <- base::list(NULL)
[13:24:38.756]         }
[13:24:38.756]         base::close(...future.stdout)
[13:24:38.756]         ...future.stdout <- NULL
[13:24:38.756]     }
[13:24:38.756]     ...future.result$conditions <- ...future.conditions
[13:24:38.756]     ...future.result$finished <- base::Sys.time()
[13:24:38.756]     ...future.result
[13:24:38.756] }
[13:24:38.760] MultisessionFuture started
[13:24:38.760] - Launch lazy future ... done
[13:24:38.760] run() for ‘MultisessionFuture’ ... done
[13:24:39.320] receiveMessageFromWorker() for ClusterFuture ...
[13:24:39.320] - Validating connection of MultisessionFuture
[13:24:39.320] - received message: FutureResult
[13:24:39.320] - Received FutureResult
[13:24:39.321] - Erased future from FutureRegistry
[13:24:39.321] result() for ClusterFuture ...
[13:24:39.321] - result already collected: FutureResult
[13:24:39.321] result() for ClusterFuture ... done
[13:24:39.321] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:39.321] resolve() on list ...
[13:24:39.321]  recursive: 1
[13:24:39.322]  length: 2
[13:24:39.322]  elements: ‘a’, ‘b’
[13:24:39.322]  length: 1 (resolved future 1)
[13:24:39.322]  length: 0 (resolved future 2)
[13:24:39.322] resolve() on list ... DONE
[13:24:39.322] A MultisessionFuture was resolved (and resolved itself)
[13:24:39.322] getGlobalsAndPackages() ...
[13:24:39.323] Searching for globals...
[13:24:39.324] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:39.324] Searching for globals ... DONE
[13:24:39.325] Resolving globals: FALSE
[13:24:39.325] 
[13:24:39.325] 
[13:24:39.325] getGlobalsAndPackages() ... DONE
[13:24:39.326] run() for ‘Future’ ...
[13:24:39.326] - state: ‘created’
[13:24:39.326] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:39.340] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:39.340] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:39.340]   - Field: ‘node’
[13:24:39.341]   - Field: ‘label’
[13:24:39.341]   - Field: ‘local’
[13:24:39.341]   - Field: ‘owner’
[13:24:39.341]   - Field: ‘envir’
[13:24:39.341]   - Field: ‘workers’
[13:24:39.341]   - Field: ‘packages’
[13:24:39.341]   - Field: ‘gc’
[13:24:39.341]   - Field: ‘conditions’
[13:24:39.342]   - Field: ‘persistent’
[13:24:39.342]   - Field: ‘expr’
[13:24:39.342]   - Field: ‘uuid’
[13:24:39.342]   - Field: ‘seed’
[13:24:39.342]   - Field: ‘version’
[13:24:39.342]   - Field: ‘result’
[13:24:39.342]   - Field: ‘asynchronous’
[13:24:39.342]   - Field: ‘calls’
[13:24:39.342]   - Field: ‘globals’
[13:24:39.342]   - Field: ‘stdout’
[13:24:39.343]   - Field: ‘earlySignal’
[13:24:39.343]   - Field: ‘lazy’
[13:24:39.343]   - Field: ‘state’
[13:24:39.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:39.343] - Launch lazy future ...
[13:24:39.343] Packages needed by the future expression (n = 0): <none>
[13:24:39.343] Packages needed by future strategies (n = 0): <none>
[13:24:39.344] {
[13:24:39.344]     {
[13:24:39.344]         {
[13:24:39.344]             ...future.startTime <- base::Sys.time()
[13:24:39.344]             {
[13:24:39.344]                 {
[13:24:39.344]                   {
[13:24:39.344]                     {
[13:24:39.344]                       base::local({
[13:24:39.344]                         has_future <- base::requireNamespace("future", 
[13:24:39.344]                           quietly = TRUE)
[13:24:39.344]                         if (has_future) {
[13:24:39.344]                           ns <- base::getNamespace("future")
[13:24:39.344]                           version <- ns[[".package"]][["version"]]
[13:24:39.344]                           if (is.null(version)) 
[13:24:39.344]                             version <- utils::packageVersion("future")
[13:24:39.344]                         }
[13:24:39.344]                         else {
[13:24:39.344]                           version <- NULL
[13:24:39.344]                         }
[13:24:39.344]                         if (!has_future || version < "1.8.0") {
[13:24:39.344]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:39.344]                             "", base::R.version$version.string), 
[13:24:39.344]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:39.344]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:39.344]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:39.344]                               "release", "version")], collapse = " "), 
[13:24:39.344]                             hostname = base::Sys.info()[["nodename"]])
[13:24:39.344]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:39.344]                             info)
[13:24:39.344]                           info <- base::paste(info, collapse = "; ")
[13:24:39.344]                           if (!has_future) {
[13:24:39.344]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:39.344]                               info)
[13:24:39.344]                           }
[13:24:39.344]                           else {
[13:24:39.344]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:39.344]                               info, version)
[13:24:39.344]                           }
[13:24:39.344]                           base::stop(msg)
[13:24:39.344]                         }
[13:24:39.344]                       })
[13:24:39.344]                     }
[13:24:39.344]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:39.344]                     base::options(mc.cores = 1L)
[13:24:39.344]                   }
[13:24:39.344]                   options(future.plan = NULL)
[13:24:39.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:39.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:39.344]                 }
[13:24:39.344]                 ...future.workdir <- getwd()
[13:24:39.344]             }
[13:24:39.344]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:39.344]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:39.344]         }
[13:24:39.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:39.344]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:39.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:39.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:39.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:39.344]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:39.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:39.344]             base::names(...future.oldOptions))
[13:24:39.344]     }
[13:24:39.344]     if (FALSE) {
[13:24:39.344]     }
[13:24:39.344]     else {
[13:24:39.344]         if (TRUE) {
[13:24:39.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:39.344]                 open = "w")
[13:24:39.344]         }
[13:24:39.344]         else {
[13:24:39.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:39.344]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:39.344]         }
[13:24:39.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:39.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:39.344]             base::sink(type = "output", split = FALSE)
[13:24:39.344]             base::close(...future.stdout)
[13:24:39.344]         }, add = TRUE)
[13:24:39.344]     }
[13:24:39.344]     ...future.frame <- base::sys.nframe()
[13:24:39.344]     ...future.conditions <- base::list()
[13:24:39.344]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:39.344]     if (FALSE) {
[13:24:39.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:39.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:39.344]     }
[13:24:39.344]     ...future.result <- base::tryCatch({
[13:24:39.344]         base::withCallingHandlers({
[13:24:39.344]             ...future.value <- base::withVisible(base::local({
[13:24:39.344]                 ...future.makeSendCondition <- base::local({
[13:24:39.344]                   sendCondition <- NULL
[13:24:39.344]                   function(frame = 1L) {
[13:24:39.344]                     if (is.function(sendCondition)) 
[13:24:39.344]                       return(sendCondition)
[13:24:39.344]                     ns <- getNamespace("parallel")
[13:24:39.344]                     if (exists("sendData", mode = "function", 
[13:24:39.344]                       envir = ns)) {
[13:24:39.344]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:39.344]                         envir = ns)
[13:24:39.344]                       envir <- sys.frame(frame)
[13:24:39.344]                       master <- NULL
[13:24:39.344]                       while (!identical(envir, .GlobalEnv) && 
[13:24:39.344]                         !identical(envir, emptyenv())) {
[13:24:39.344]                         if (exists("master", mode = "list", envir = envir, 
[13:24:39.344]                           inherits = FALSE)) {
[13:24:39.344]                           master <- get("master", mode = "list", 
[13:24:39.344]                             envir = envir, inherits = FALSE)
[13:24:39.344]                           if (inherits(master, c("SOCKnode", 
[13:24:39.344]                             "SOCK0node"))) {
[13:24:39.344]                             sendCondition <<- function(cond) {
[13:24:39.344]                               data <- list(type = "VALUE", value = cond, 
[13:24:39.344]                                 success = TRUE)
[13:24:39.344]                               parallel_sendData(master, data)
[13:24:39.344]                             }
[13:24:39.344]                             return(sendCondition)
[13:24:39.344]                           }
[13:24:39.344]                         }
[13:24:39.344]                         frame <- frame + 1L
[13:24:39.344]                         envir <- sys.frame(frame)
[13:24:39.344]                       }
[13:24:39.344]                     }
[13:24:39.344]                     sendCondition <<- function(cond) NULL
[13:24:39.344]                   }
[13:24:39.344]                 })
[13:24:39.344]                 withCallingHandlers({
[13:24:39.344]                   {
[13:24:39.344]                     Sys.sleep(0.5)
[13:24:39.344]                     list(a = 1, b = 42L)
[13:24:39.344]                   }
[13:24:39.344]                 }, immediateCondition = function(cond) {
[13:24:39.344]                   sendCondition <- ...future.makeSendCondition()
[13:24:39.344]                   sendCondition(cond)
[13:24:39.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.344]                   {
[13:24:39.344]                     inherits <- base::inherits
[13:24:39.344]                     invokeRestart <- base::invokeRestart
[13:24:39.344]                     is.null <- base::is.null
[13:24:39.344]                     muffled <- FALSE
[13:24:39.344]                     if (inherits(cond, "message")) {
[13:24:39.344]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:39.344]                       if (muffled) 
[13:24:39.344]                         invokeRestart("muffleMessage")
[13:24:39.344]                     }
[13:24:39.344]                     else if (inherits(cond, "warning")) {
[13:24:39.344]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:39.344]                       if (muffled) 
[13:24:39.344]                         invokeRestart("muffleWarning")
[13:24:39.344]                     }
[13:24:39.344]                     else if (inherits(cond, "condition")) {
[13:24:39.344]                       if (!is.null(pattern)) {
[13:24:39.344]                         computeRestarts <- base::computeRestarts
[13:24:39.344]                         grepl <- base::grepl
[13:24:39.344]                         restarts <- computeRestarts(cond)
[13:24:39.344]                         for (restart in restarts) {
[13:24:39.344]                           name <- restart$name
[13:24:39.344]                           if (is.null(name)) 
[13:24:39.344]                             next
[13:24:39.344]                           if (!grepl(pattern, name)) 
[13:24:39.344]                             next
[13:24:39.344]                           invokeRestart(restart)
[13:24:39.344]                           muffled <- TRUE
[13:24:39.344]                           break
[13:24:39.344]                         }
[13:24:39.344]                       }
[13:24:39.344]                     }
[13:24:39.344]                     invisible(muffled)
[13:24:39.344]                   }
[13:24:39.344]                   muffleCondition(cond)
[13:24:39.344]                 })
[13:24:39.344]             }))
[13:24:39.344]             future::FutureResult(value = ...future.value$value, 
[13:24:39.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:39.344]                   ...future.rng), globalenv = if (FALSE) 
[13:24:39.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:39.344]                     ...future.globalenv.names))
[13:24:39.344]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:39.344]         }, condition = base::local({
[13:24:39.344]             c <- base::c
[13:24:39.344]             inherits <- base::inherits
[13:24:39.344]             invokeRestart <- base::invokeRestart
[13:24:39.344]             length <- base::length
[13:24:39.344]             list <- base::list
[13:24:39.344]             seq.int <- base::seq.int
[13:24:39.344]             signalCondition <- base::signalCondition
[13:24:39.344]             sys.calls <- base::sys.calls
[13:24:39.344]             `[[` <- base::`[[`
[13:24:39.344]             `+` <- base::`+`
[13:24:39.344]             `<<-` <- base::`<<-`
[13:24:39.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:39.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:39.344]                   3L)]
[13:24:39.344]             }
[13:24:39.344]             function(cond) {
[13:24:39.344]                 is_error <- inherits(cond, "error")
[13:24:39.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:39.344]                   NULL)
[13:24:39.344]                 if (is_error) {
[13:24:39.344]                   sessionInformation <- function() {
[13:24:39.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:39.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:39.344]                       search = base::search(), system = base::Sys.info())
[13:24:39.344]                   }
[13:24:39.344]                   ...future.conditions[[length(...future.conditions) + 
[13:24:39.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:39.344]                     cond$call), session = sessionInformation(), 
[13:24:39.344]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:39.344]                   signalCondition(cond)
[13:24:39.344]                 }
[13:24:39.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:39.344]                 "immediateCondition"))) {
[13:24:39.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:39.344]                   ...future.conditions[[length(...future.conditions) + 
[13:24:39.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:39.344]                   if (TRUE && !signal) {
[13:24:39.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.344]                     {
[13:24:39.344]                       inherits <- base::inherits
[13:24:39.344]                       invokeRestart <- base::invokeRestart
[13:24:39.344]                       is.null <- base::is.null
[13:24:39.344]                       muffled <- FALSE
[13:24:39.344]                       if (inherits(cond, "message")) {
[13:24:39.344]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:39.344]                         if (muffled) 
[13:24:39.344]                           invokeRestart("muffleMessage")
[13:24:39.344]                       }
[13:24:39.344]                       else if (inherits(cond, "warning")) {
[13:24:39.344]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:39.344]                         if (muffled) 
[13:24:39.344]                           invokeRestart("muffleWarning")
[13:24:39.344]                       }
[13:24:39.344]                       else if (inherits(cond, "condition")) {
[13:24:39.344]                         if (!is.null(pattern)) {
[13:24:39.344]                           computeRestarts <- base::computeRestarts
[13:24:39.344]                           grepl <- base::grepl
[13:24:39.344]                           restarts <- computeRestarts(cond)
[13:24:39.344]                           for (restart in restarts) {
[13:24:39.344]                             name <- restart$name
[13:24:39.344]                             if (is.null(name)) 
[13:24:39.344]                               next
[13:24:39.344]                             if (!grepl(pattern, name)) 
[13:24:39.344]                               next
[13:24:39.344]                             invokeRestart(restart)
[13:24:39.344]                             muffled <- TRUE
[13:24:39.344]                             break
[13:24:39.344]                           }
[13:24:39.344]                         }
[13:24:39.344]                       }
[13:24:39.344]                       invisible(muffled)
[13:24:39.344]                     }
[13:24:39.344]                     muffleCondition(cond, pattern = "^muffle")
[13:24:39.344]                   }
[13:24:39.344]                 }
[13:24:39.344]                 else {
[13:24:39.344]                   if (TRUE) {
[13:24:39.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.344]                     {
[13:24:39.344]                       inherits <- base::inherits
[13:24:39.344]                       invokeRestart <- base::invokeRestart
[13:24:39.344]                       is.null <- base::is.null
[13:24:39.344]                       muffled <- FALSE
[13:24:39.344]                       if (inherits(cond, "message")) {
[13:24:39.344]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:39.344]                         if (muffled) 
[13:24:39.344]                           invokeRestart("muffleMessage")
[13:24:39.344]                       }
[13:24:39.344]                       else if (inherits(cond, "warning")) {
[13:24:39.344]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:39.344]                         if (muffled) 
[13:24:39.344]                           invokeRestart("muffleWarning")
[13:24:39.344]                       }
[13:24:39.344]                       else if (inherits(cond, "condition")) {
[13:24:39.344]                         if (!is.null(pattern)) {
[13:24:39.344]                           computeRestarts <- base::computeRestarts
[13:24:39.344]                           grepl <- base::grepl
[13:24:39.344]                           restarts <- computeRestarts(cond)
[13:24:39.344]                           for (restart in restarts) {
[13:24:39.344]                             name <- restart$name
[13:24:39.344]                             if (is.null(name)) 
[13:24:39.344]                               next
[13:24:39.344]                             if (!grepl(pattern, name)) 
[13:24:39.344]                               next
[13:24:39.344]                             invokeRestart(restart)
[13:24:39.344]                             muffled <- TRUE
[13:24:39.344]                             break
[13:24:39.344]                           }
[13:24:39.344]                         }
[13:24:39.344]                       }
[13:24:39.344]                       invisible(muffled)
[13:24:39.344]                     }
[13:24:39.344]                     muffleCondition(cond, pattern = "^muffle")
[13:24:39.344]                   }
[13:24:39.344]                 }
[13:24:39.344]             }
[13:24:39.344]         }))
[13:24:39.344]     }, error = function(ex) {
[13:24:39.344]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:39.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:39.344]                 ...future.rng), started = ...future.startTime, 
[13:24:39.344]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:39.344]             version = "1.8"), class = "FutureResult")
[13:24:39.344]     }, finally = {
[13:24:39.344]         if (!identical(...future.workdir, getwd())) 
[13:24:39.344]             setwd(...future.workdir)
[13:24:39.344]         {
[13:24:39.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:39.344]                 ...future.oldOptions$nwarnings <- NULL
[13:24:39.344]             }
[13:24:39.344]             base::options(...future.oldOptions)
[13:24:39.344]             if (.Platform$OS.type == "windows") {
[13:24:39.344]                 old_names <- names(...future.oldEnvVars)
[13:24:39.344]                 envs <- base::Sys.getenv()
[13:24:39.344]                 names <- names(envs)
[13:24:39.344]                 common <- intersect(names, old_names)
[13:24:39.344]                 added <- setdiff(names, old_names)
[13:24:39.344]                 removed <- setdiff(old_names, names)
[13:24:39.344]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:39.344]                   envs[common]]
[13:24:39.344]                 NAMES <- toupper(changed)
[13:24:39.344]                 args <- list()
[13:24:39.344]                 for (kk in seq_along(NAMES)) {
[13:24:39.344]                   name <- changed[[kk]]
[13:24:39.344]                   NAME <- NAMES[[kk]]
[13:24:39.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.344]                     next
[13:24:39.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:39.344]                 }
[13:24:39.344]                 NAMES <- toupper(added)
[13:24:39.344]                 for (kk in seq_along(NAMES)) {
[13:24:39.344]                   name <- added[[kk]]
[13:24:39.344]                   NAME <- NAMES[[kk]]
[13:24:39.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.344]                     next
[13:24:39.344]                   args[[name]] <- ""
[13:24:39.344]                 }
[13:24:39.344]                 NAMES <- toupper(removed)
[13:24:39.344]                 for (kk in seq_along(NAMES)) {
[13:24:39.344]                   name <- removed[[kk]]
[13:24:39.344]                   NAME <- NAMES[[kk]]
[13:24:39.344]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.344]                     next
[13:24:39.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:39.344]                 }
[13:24:39.344]                 if (length(args) > 0) 
[13:24:39.344]                   base::do.call(base::Sys.setenv, args = args)
[13:24:39.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:39.344]             }
[13:24:39.344]             else {
[13:24:39.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:39.344]             }
[13:24:39.344]             {
[13:24:39.344]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:39.344]                   0L) {
[13:24:39.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:39.344]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:39.344]                   base::options(opts)
[13:24:39.344]                 }
[13:24:39.344]                 {
[13:24:39.344]                   {
[13:24:39.344]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:39.344]                     NULL
[13:24:39.344]                   }
[13:24:39.344]                   options(future.plan = NULL)
[13:24:39.344]                   if (is.na(NA_character_)) 
[13:24:39.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:39.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:39.344]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:39.344]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:39.344]                     envir = parent.frame()) 
[13:24:39.344]                   {
[13:24:39.344]                     if (is.function(workers)) 
[13:24:39.344]                       workers <- workers()
[13:24:39.344]                     workers <- structure(as.integer(workers), 
[13:24:39.344]                       class = class(workers))
[13:24:39.344]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:39.344]                       workers >= 1)
[13:24:39.344]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:39.344]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:39.344]                     }
[13:24:39.344]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:39.344]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:39.344]                       envir = envir)
[13:24:39.344]                     if (!future$lazy) 
[13:24:39.344]                       future <- run(future)
[13:24:39.344]                     invisible(future)
[13:24:39.344]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:39.344]                 }
[13:24:39.344]             }
[13:24:39.344]         }
[13:24:39.344]     })
[13:24:39.344]     if (TRUE) {
[13:24:39.344]         base::sink(type = "output", split = FALSE)
[13:24:39.344]         if (TRUE) {
[13:24:39.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:39.344]         }
[13:24:39.344]         else {
[13:24:39.344]             ...future.result["stdout"] <- base::list(NULL)
[13:24:39.344]         }
[13:24:39.344]         base::close(...future.stdout)
[13:24:39.344]         ...future.stdout <- NULL
[13:24:39.344]     }
[13:24:39.344]     ...future.result$conditions <- ...future.conditions
[13:24:39.344]     ...future.result$finished <- base::Sys.time()
[13:24:39.344]     ...future.result
[13:24:39.344] }
[13:24:39.347] MultisessionFuture started
[13:24:39.350] - Launch lazy future ... done
[13:24:39.350] run() for ‘MultisessionFuture’ ... done
[13:24:39.894] receiveMessageFromWorker() for ClusterFuture ...
[13:24:39.894] - Validating connection of MultisessionFuture
[13:24:39.894] - received message: FutureResult
[13:24:39.895] - Received FutureResult
[13:24:39.895] - Erased future from FutureRegistry
[13:24:39.895] result() for ClusterFuture ...
[13:24:39.895] - result already collected: FutureResult
[13:24:39.895] result() for ClusterFuture ... done
[13:24:39.895] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:39.895] resolve() on list ...
[13:24:39.895]  recursive: 1
[13:24:39.896]  length: 2
[13:24:39.896]  elements: ‘a’, ‘b’
[13:24:39.896]  length: 1 (resolved future 1)
[13:24:39.896]  length: 0 (resolved future 2)
[13:24:39.896] resolve() on list ... DONE
[13:24:39.896] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:24:39.896] getGlobalsAndPackages() ...
[13:24:39.896] Searching for globals...
[13:24:39.897] - globals found: [2] ‘list’, ‘stop’
[13:24:39.897] Searching for globals ... DONE
[13:24:39.897] Resolving globals: FALSE
[13:24:39.898] 
[13:24:39.898] 
[13:24:39.898] getGlobalsAndPackages() ... DONE
[13:24:39.898] run() for ‘Future’ ...
[13:24:39.898] - state: ‘created’
[13:24:39.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:39.913] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:39.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:39.913]   - Field: ‘node’
[13:24:39.913]   - Field: ‘label’
[13:24:39.913]   - Field: ‘local’
[13:24:39.913]   - Field: ‘owner’
[13:24:39.914]   - Field: ‘envir’
[13:24:39.914]   - Field: ‘workers’
[13:24:39.914]   - Field: ‘packages’
[13:24:39.914]   - Field: ‘gc’
[13:24:39.914]   - Field: ‘conditions’
[13:24:39.914]   - Field: ‘persistent’
[13:24:39.914]   - Field: ‘expr’
[13:24:39.914]   - Field: ‘uuid’
[13:24:39.914]   - Field: ‘seed’
[13:24:39.914]   - Field: ‘version’
[13:24:39.915]   - Field: ‘result’
[13:24:39.915]   - Field: ‘asynchronous’
[13:24:39.915]   - Field: ‘calls’
[13:24:39.915]   - Field: ‘globals’
[13:24:39.915]   - Field: ‘stdout’
[13:24:39.915]   - Field: ‘earlySignal’
[13:24:39.915]   - Field: ‘lazy’
[13:24:39.915]   - Field: ‘state’
[13:24:39.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:39.915] - Launch lazy future ...
[13:24:39.916] Packages needed by the future expression (n = 0): <none>
[13:24:39.916] Packages needed by future strategies (n = 0): <none>
[13:24:39.916] {
[13:24:39.916]     {
[13:24:39.916]         {
[13:24:39.916]             ...future.startTime <- base::Sys.time()
[13:24:39.916]             {
[13:24:39.916]                 {
[13:24:39.916]                   {
[13:24:39.916]                     {
[13:24:39.916]                       base::local({
[13:24:39.916]                         has_future <- base::requireNamespace("future", 
[13:24:39.916]                           quietly = TRUE)
[13:24:39.916]                         if (has_future) {
[13:24:39.916]                           ns <- base::getNamespace("future")
[13:24:39.916]                           version <- ns[[".package"]][["version"]]
[13:24:39.916]                           if (is.null(version)) 
[13:24:39.916]                             version <- utils::packageVersion("future")
[13:24:39.916]                         }
[13:24:39.916]                         else {
[13:24:39.916]                           version <- NULL
[13:24:39.916]                         }
[13:24:39.916]                         if (!has_future || version < "1.8.0") {
[13:24:39.916]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:39.916]                             "", base::R.version$version.string), 
[13:24:39.916]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:39.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:39.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:39.916]                               "release", "version")], collapse = " "), 
[13:24:39.916]                             hostname = base::Sys.info()[["nodename"]])
[13:24:39.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:39.916]                             info)
[13:24:39.916]                           info <- base::paste(info, collapse = "; ")
[13:24:39.916]                           if (!has_future) {
[13:24:39.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:39.916]                               info)
[13:24:39.916]                           }
[13:24:39.916]                           else {
[13:24:39.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:39.916]                               info, version)
[13:24:39.916]                           }
[13:24:39.916]                           base::stop(msg)
[13:24:39.916]                         }
[13:24:39.916]                       })
[13:24:39.916]                     }
[13:24:39.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:39.916]                     base::options(mc.cores = 1L)
[13:24:39.916]                   }
[13:24:39.916]                   options(future.plan = NULL)
[13:24:39.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:39.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:39.916]                 }
[13:24:39.916]                 ...future.workdir <- getwd()
[13:24:39.916]             }
[13:24:39.916]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:39.916]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:39.916]         }
[13:24:39.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:39.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:39.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:39.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:39.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:39.916]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:39.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:39.916]             base::names(...future.oldOptions))
[13:24:39.916]     }
[13:24:39.916]     if (FALSE) {
[13:24:39.916]     }
[13:24:39.916]     else {
[13:24:39.916]         if (TRUE) {
[13:24:39.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:39.916]                 open = "w")
[13:24:39.916]         }
[13:24:39.916]         else {
[13:24:39.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:39.916]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:39.916]         }
[13:24:39.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:39.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:39.916]             base::sink(type = "output", split = FALSE)
[13:24:39.916]             base::close(...future.stdout)
[13:24:39.916]         }, add = TRUE)
[13:24:39.916]     }
[13:24:39.916]     ...future.frame <- base::sys.nframe()
[13:24:39.916]     ...future.conditions <- base::list()
[13:24:39.916]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:39.916]     if (FALSE) {
[13:24:39.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:39.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:39.916]     }
[13:24:39.916]     ...future.result <- base::tryCatch({
[13:24:39.916]         base::withCallingHandlers({
[13:24:39.916]             ...future.value <- base::withVisible(base::local({
[13:24:39.916]                 ...future.makeSendCondition <- base::local({
[13:24:39.916]                   sendCondition <- NULL
[13:24:39.916]                   function(frame = 1L) {
[13:24:39.916]                     if (is.function(sendCondition)) 
[13:24:39.916]                       return(sendCondition)
[13:24:39.916]                     ns <- getNamespace("parallel")
[13:24:39.916]                     if (exists("sendData", mode = "function", 
[13:24:39.916]                       envir = ns)) {
[13:24:39.916]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:39.916]                         envir = ns)
[13:24:39.916]                       envir <- sys.frame(frame)
[13:24:39.916]                       master <- NULL
[13:24:39.916]                       while (!identical(envir, .GlobalEnv) && 
[13:24:39.916]                         !identical(envir, emptyenv())) {
[13:24:39.916]                         if (exists("master", mode = "list", envir = envir, 
[13:24:39.916]                           inherits = FALSE)) {
[13:24:39.916]                           master <- get("master", mode = "list", 
[13:24:39.916]                             envir = envir, inherits = FALSE)
[13:24:39.916]                           if (inherits(master, c("SOCKnode", 
[13:24:39.916]                             "SOCK0node"))) {
[13:24:39.916]                             sendCondition <<- function(cond) {
[13:24:39.916]                               data <- list(type = "VALUE", value = cond, 
[13:24:39.916]                                 success = TRUE)
[13:24:39.916]                               parallel_sendData(master, data)
[13:24:39.916]                             }
[13:24:39.916]                             return(sendCondition)
[13:24:39.916]                           }
[13:24:39.916]                         }
[13:24:39.916]                         frame <- frame + 1L
[13:24:39.916]                         envir <- sys.frame(frame)
[13:24:39.916]                       }
[13:24:39.916]                     }
[13:24:39.916]                     sendCondition <<- function(cond) NULL
[13:24:39.916]                   }
[13:24:39.916]                 })
[13:24:39.916]                 withCallingHandlers({
[13:24:39.916]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:39.916]                 }, immediateCondition = function(cond) {
[13:24:39.916]                   sendCondition <- ...future.makeSendCondition()
[13:24:39.916]                   sendCondition(cond)
[13:24:39.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.916]                   {
[13:24:39.916]                     inherits <- base::inherits
[13:24:39.916]                     invokeRestart <- base::invokeRestart
[13:24:39.916]                     is.null <- base::is.null
[13:24:39.916]                     muffled <- FALSE
[13:24:39.916]                     if (inherits(cond, "message")) {
[13:24:39.916]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:39.916]                       if (muffled) 
[13:24:39.916]                         invokeRestart("muffleMessage")
[13:24:39.916]                     }
[13:24:39.916]                     else if (inherits(cond, "warning")) {
[13:24:39.916]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:39.916]                       if (muffled) 
[13:24:39.916]                         invokeRestart("muffleWarning")
[13:24:39.916]                     }
[13:24:39.916]                     else if (inherits(cond, "condition")) {
[13:24:39.916]                       if (!is.null(pattern)) {
[13:24:39.916]                         computeRestarts <- base::computeRestarts
[13:24:39.916]                         grepl <- base::grepl
[13:24:39.916]                         restarts <- computeRestarts(cond)
[13:24:39.916]                         for (restart in restarts) {
[13:24:39.916]                           name <- restart$name
[13:24:39.916]                           if (is.null(name)) 
[13:24:39.916]                             next
[13:24:39.916]                           if (!grepl(pattern, name)) 
[13:24:39.916]                             next
[13:24:39.916]                           invokeRestart(restart)
[13:24:39.916]                           muffled <- TRUE
[13:24:39.916]                           break
[13:24:39.916]                         }
[13:24:39.916]                       }
[13:24:39.916]                     }
[13:24:39.916]                     invisible(muffled)
[13:24:39.916]                   }
[13:24:39.916]                   muffleCondition(cond)
[13:24:39.916]                 })
[13:24:39.916]             }))
[13:24:39.916]             future::FutureResult(value = ...future.value$value, 
[13:24:39.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:39.916]                   ...future.rng), globalenv = if (FALSE) 
[13:24:39.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:39.916]                     ...future.globalenv.names))
[13:24:39.916]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:39.916]         }, condition = base::local({
[13:24:39.916]             c <- base::c
[13:24:39.916]             inherits <- base::inherits
[13:24:39.916]             invokeRestart <- base::invokeRestart
[13:24:39.916]             length <- base::length
[13:24:39.916]             list <- base::list
[13:24:39.916]             seq.int <- base::seq.int
[13:24:39.916]             signalCondition <- base::signalCondition
[13:24:39.916]             sys.calls <- base::sys.calls
[13:24:39.916]             `[[` <- base::`[[`
[13:24:39.916]             `+` <- base::`+`
[13:24:39.916]             `<<-` <- base::`<<-`
[13:24:39.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:39.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:39.916]                   3L)]
[13:24:39.916]             }
[13:24:39.916]             function(cond) {
[13:24:39.916]                 is_error <- inherits(cond, "error")
[13:24:39.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:39.916]                   NULL)
[13:24:39.916]                 if (is_error) {
[13:24:39.916]                   sessionInformation <- function() {
[13:24:39.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:39.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:39.916]                       search = base::search(), system = base::Sys.info())
[13:24:39.916]                   }
[13:24:39.916]                   ...future.conditions[[length(...future.conditions) + 
[13:24:39.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:39.916]                     cond$call), session = sessionInformation(), 
[13:24:39.916]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:39.916]                   signalCondition(cond)
[13:24:39.916]                 }
[13:24:39.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:39.916]                 "immediateCondition"))) {
[13:24:39.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:39.916]                   ...future.conditions[[length(...future.conditions) + 
[13:24:39.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:39.916]                   if (TRUE && !signal) {
[13:24:39.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.916]                     {
[13:24:39.916]                       inherits <- base::inherits
[13:24:39.916]                       invokeRestart <- base::invokeRestart
[13:24:39.916]                       is.null <- base::is.null
[13:24:39.916]                       muffled <- FALSE
[13:24:39.916]                       if (inherits(cond, "message")) {
[13:24:39.916]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:39.916]                         if (muffled) 
[13:24:39.916]                           invokeRestart("muffleMessage")
[13:24:39.916]                       }
[13:24:39.916]                       else if (inherits(cond, "warning")) {
[13:24:39.916]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:39.916]                         if (muffled) 
[13:24:39.916]                           invokeRestart("muffleWarning")
[13:24:39.916]                       }
[13:24:39.916]                       else if (inherits(cond, "condition")) {
[13:24:39.916]                         if (!is.null(pattern)) {
[13:24:39.916]                           computeRestarts <- base::computeRestarts
[13:24:39.916]                           grepl <- base::grepl
[13:24:39.916]                           restarts <- computeRestarts(cond)
[13:24:39.916]                           for (restart in restarts) {
[13:24:39.916]                             name <- restart$name
[13:24:39.916]                             if (is.null(name)) 
[13:24:39.916]                               next
[13:24:39.916]                             if (!grepl(pattern, name)) 
[13:24:39.916]                               next
[13:24:39.916]                             invokeRestart(restart)
[13:24:39.916]                             muffled <- TRUE
[13:24:39.916]                             break
[13:24:39.916]                           }
[13:24:39.916]                         }
[13:24:39.916]                       }
[13:24:39.916]                       invisible(muffled)
[13:24:39.916]                     }
[13:24:39.916]                     muffleCondition(cond, pattern = "^muffle")
[13:24:39.916]                   }
[13:24:39.916]                 }
[13:24:39.916]                 else {
[13:24:39.916]                   if (TRUE) {
[13:24:39.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.916]                     {
[13:24:39.916]                       inherits <- base::inherits
[13:24:39.916]                       invokeRestart <- base::invokeRestart
[13:24:39.916]                       is.null <- base::is.null
[13:24:39.916]                       muffled <- FALSE
[13:24:39.916]                       if (inherits(cond, "message")) {
[13:24:39.916]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:39.916]                         if (muffled) 
[13:24:39.916]                           invokeRestart("muffleMessage")
[13:24:39.916]                       }
[13:24:39.916]                       else if (inherits(cond, "warning")) {
[13:24:39.916]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:39.916]                         if (muffled) 
[13:24:39.916]                           invokeRestart("muffleWarning")
[13:24:39.916]                       }
[13:24:39.916]                       else if (inherits(cond, "condition")) {
[13:24:39.916]                         if (!is.null(pattern)) {
[13:24:39.916]                           computeRestarts <- base::computeRestarts
[13:24:39.916]                           grepl <- base::grepl
[13:24:39.916]                           restarts <- computeRestarts(cond)
[13:24:39.916]                           for (restart in restarts) {
[13:24:39.916]                             name <- restart$name
[13:24:39.916]                             if (is.null(name)) 
[13:24:39.916]                               next
[13:24:39.916]                             if (!grepl(pattern, name)) 
[13:24:39.916]                               next
[13:24:39.916]                             invokeRestart(restart)
[13:24:39.916]                             muffled <- TRUE
[13:24:39.916]                             break
[13:24:39.916]                           }
[13:24:39.916]                         }
[13:24:39.916]                       }
[13:24:39.916]                       invisible(muffled)
[13:24:39.916]                     }
[13:24:39.916]                     muffleCondition(cond, pattern = "^muffle")
[13:24:39.916]                   }
[13:24:39.916]                 }
[13:24:39.916]             }
[13:24:39.916]         }))
[13:24:39.916]     }, error = function(ex) {
[13:24:39.916]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:39.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:39.916]                 ...future.rng), started = ...future.startTime, 
[13:24:39.916]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:39.916]             version = "1.8"), class = "FutureResult")
[13:24:39.916]     }, finally = {
[13:24:39.916]         if (!identical(...future.workdir, getwd())) 
[13:24:39.916]             setwd(...future.workdir)
[13:24:39.916]         {
[13:24:39.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:39.916]                 ...future.oldOptions$nwarnings <- NULL
[13:24:39.916]             }
[13:24:39.916]             base::options(...future.oldOptions)
[13:24:39.916]             if (.Platform$OS.type == "windows") {
[13:24:39.916]                 old_names <- names(...future.oldEnvVars)
[13:24:39.916]                 envs <- base::Sys.getenv()
[13:24:39.916]                 names <- names(envs)
[13:24:39.916]                 common <- intersect(names, old_names)
[13:24:39.916]                 added <- setdiff(names, old_names)
[13:24:39.916]                 removed <- setdiff(old_names, names)
[13:24:39.916]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:39.916]                   envs[common]]
[13:24:39.916]                 NAMES <- toupper(changed)
[13:24:39.916]                 args <- list()
[13:24:39.916]                 for (kk in seq_along(NAMES)) {
[13:24:39.916]                   name <- changed[[kk]]
[13:24:39.916]                   NAME <- NAMES[[kk]]
[13:24:39.916]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.916]                     next
[13:24:39.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:39.916]                 }
[13:24:39.916]                 NAMES <- toupper(added)
[13:24:39.916]                 for (kk in seq_along(NAMES)) {
[13:24:39.916]                   name <- added[[kk]]
[13:24:39.916]                   NAME <- NAMES[[kk]]
[13:24:39.916]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.916]                     next
[13:24:39.916]                   args[[name]] <- ""
[13:24:39.916]                 }
[13:24:39.916]                 NAMES <- toupper(removed)
[13:24:39.916]                 for (kk in seq_along(NAMES)) {
[13:24:39.916]                   name <- removed[[kk]]
[13:24:39.916]                   NAME <- NAMES[[kk]]
[13:24:39.916]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.916]                     next
[13:24:39.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:39.916]                 }
[13:24:39.916]                 if (length(args) > 0) 
[13:24:39.916]                   base::do.call(base::Sys.setenv, args = args)
[13:24:39.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:39.916]             }
[13:24:39.916]             else {
[13:24:39.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:39.916]             }
[13:24:39.916]             {
[13:24:39.916]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:39.916]                   0L) {
[13:24:39.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:39.916]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:39.916]                   base::options(opts)
[13:24:39.916]                 }
[13:24:39.916]                 {
[13:24:39.916]                   {
[13:24:39.916]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:39.916]                     NULL
[13:24:39.916]                   }
[13:24:39.916]                   options(future.plan = NULL)
[13:24:39.916]                   if (is.na(NA_character_)) 
[13:24:39.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:39.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:39.916]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:39.916]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:39.916]                     envir = parent.frame()) 
[13:24:39.916]                   {
[13:24:39.916]                     if (is.function(workers)) 
[13:24:39.916]                       workers <- workers()
[13:24:39.916]                     workers <- structure(as.integer(workers), 
[13:24:39.916]                       class = class(workers))
[13:24:39.916]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:39.916]                       workers >= 1)
[13:24:39.916]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:39.916]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:39.916]                     }
[13:24:39.916]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:39.916]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:39.916]                       envir = envir)
[13:24:39.916]                     if (!future$lazy) 
[13:24:39.916]                       future <- run(future)
[13:24:39.916]                     invisible(future)
[13:24:39.916]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:39.916]                 }
[13:24:39.916]             }
[13:24:39.916]         }
[13:24:39.916]     })
[13:24:39.916]     if (TRUE) {
[13:24:39.916]         base::sink(type = "output", split = FALSE)
[13:24:39.916]         if (TRUE) {
[13:24:39.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:39.916]         }
[13:24:39.916]         else {
[13:24:39.916]             ...future.result["stdout"] <- base::list(NULL)
[13:24:39.916]         }
[13:24:39.916]         base::close(...future.stdout)
[13:24:39.916]         ...future.stdout <- NULL
[13:24:39.916]     }
[13:24:39.916]     ...future.result$conditions <- ...future.conditions
[13:24:39.916]     ...future.result$finished <- base::Sys.time()
[13:24:39.916]     ...future.result
[13:24:39.916] }
[13:24:39.920] MultisessionFuture started
[13:24:39.920] - Launch lazy future ... done
[13:24:39.920] run() for ‘MultisessionFuture’ ... done
[13:24:39.965] receiveMessageFromWorker() for ClusterFuture ...
[13:24:39.965] - Validating connection of MultisessionFuture
[13:24:39.966] - received message: FutureResult
[13:24:39.966] - Received FutureResult
[13:24:39.966] - Erased future from FutureRegistry
[13:24:39.966] result() for ClusterFuture ...
[13:24:39.966] - result already collected: FutureResult
[13:24:39.966] result() for ClusterFuture ... done
[13:24:39.966] signalConditions() ...
[13:24:39.966]  - include = ‘immediateCondition’
[13:24:39.966]  - exclude = 
[13:24:39.967]  - resignal = FALSE
[13:24:39.967]  - Number of conditions: 1
[13:24:39.967] signalConditions() ... done
[13:24:39.967] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:39.967] A MultisessionFuture was resolved
[13:24:39.967] getGlobalsAndPackages() ...
[13:24:39.967] Searching for globals...
[13:24:39.968] - globals found: [2] ‘list’, ‘stop’
[13:24:39.968] Searching for globals ... DONE
[13:24:39.968] Resolving globals: FALSE
[13:24:39.968] 
[13:24:39.968] 
[13:24:39.969] getGlobalsAndPackages() ... DONE
[13:24:39.969] run() for ‘Future’ ...
[13:24:39.969] - state: ‘created’
[13:24:39.969] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:39.984] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:39.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:39.985]   - Field: ‘node’
[13:24:39.985]   - Field: ‘label’
[13:24:39.985]   - Field: ‘local’
[13:24:39.985]   - Field: ‘owner’
[13:24:39.985]   - Field: ‘envir’
[13:24:39.985]   - Field: ‘workers’
[13:24:39.985]   - Field: ‘packages’
[13:24:39.985]   - Field: ‘gc’
[13:24:39.985]   - Field: ‘conditions’
[13:24:39.985]   - Field: ‘persistent’
[13:24:39.986]   - Field: ‘expr’
[13:24:39.986]   - Field: ‘uuid’
[13:24:39.986]   - Field: ‘seed’
[13:24:39.986]   - Field: ‘version’
[13:24:39.986]   - Field: ‘result’
[13:24:39.986]   - Field: ‘asynchronous’
[13:24:39.986]   - Field: ‘calls’
[13:24:39.986]   - Field: ‘globals’
[13:24:39.986]   - Field: ‘stdout’
[13:24:39.986]   - Field: ‘earlySignal’
[13:24:39.986]   - Field: ‘lazy’
[13:24:39.987]   - Field: ‘state’
[13:24:39.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:39.987] - Launch lazy future ...
[13:24:39.987] Packages needed by the future expression (n = 0): <none>
[13:24:39.987] Packages needed by future strategies (n = 0): <none>
[13:24:39.988] {
[13:24:39.988]     {
[13:24:39.988]         {
[13:24:39.988]             ...future.startTime <- base::Sys.time()
[13:24:39.988]             {
[13:24:39.988]                 {
[13:24:39.988]                   {
[13:24:39.988]                     {
[13:24:39.988]                       base::local({
[13:24:39.988]                         has_future <- base::requireNamespace("future", 
[13:24:39.988]                           quietly = TRUE)
[13:24:39.988]                         if (has_future) {
[13:24:39.988]                           ns <- base::getNamespace("future")
[13:24:39.988]                           version <- ns[[".package"]][["version"]]
[13:24:39.988]                           if (is.null(version)) 
[13:24:39.988]                             version <- utils::packageVersion("future")
[13:24:39.988]                         }
[13:24:39.988]                         else {
[13:24:39.988]                           version <- NULL
[13:24:39.988]                         }
[13:24:39.988]                         if (!has_future || version < "1.8.0") {
[13:24:39.988]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:39.988]                             "", base::R.version$version.string), 
[13:24:39.988]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:39.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:39.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:39.988]                               "release", "version")], collapse = " "), 
[13:24:39.988]                             hostname = base::Sys.info()[["nodename"]])
[13:24:39.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:39.988]                             info)
[13:24:39.988]                           info <- base::paste(info, collapse = "; ")
[13:24:39.988]                           if (!has_future) {
[13:24:39.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:39.988]                               info)
[13:24:39.988]                           }
[13:24:39.988]                           else {
[13:24:39.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:39.988]                               info, version)
[13:24:39.988]                           }
[13:24:39.988]                           base::stop(msg)
[13:24:39.988]                         }
[13:24:39.988]                       })
[13:24:39.988]                     }
[13:24:39.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:39.988]                     base::options(mc.cores = 1L)
[13:24:39.988]                   }
[13:24:39.988]                   options(future.plan = NULL)
[13:24:39.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:39.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:39.988]                 }
[13:24:39.988]                 ...future.workdir <- getwd()
[13:24:39.988]             }
[13:24:39.988]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:39.988]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:39.988]         }
[13:24:39.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:39.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:39.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:39.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:39.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:39.988]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:39.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:39.988]             base::names(...future.oldOptions))
[13:24:39.988]     }
[13:24:39.988]     if (FALSE) {
[13:24:39.988]     }
[13:24:39.988]     else {
[13:24:39.988]         if (TRUE) {
[13:24:39.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:39.988]                 open = "w")
[13:24:39.988]         }
[13:24:39.988]         else {
[13:24:39.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:39.988]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:39.988]         }
[13:24:39.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:39.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:39.988]             base::sink(type = "output", split = FALSE)
[13:24:39.988]             base::close(...future.stdout)
[13:24:39.988]         }, add = TRUE)
[13:24:39.988]     }
[13:24:39.988]     ...future.frame <- base::sys.nframe()
[13:24:39.988]     ...future.conditions <- base::list()
[13:24:39.988]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:39.988]     if (FALSE) {
[13:24:39.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:39.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:39.988]     }
[13:24:39.988]     ...future.result <- base::tryCatch({
[13:24:39.988]         base::withCallingHandlers({
[13:24:39.988]             ...future.value <- base::withVisible(base::local({
[13:24:39.988]                 ...future.makeSendCondition <- base::local({
[13:24:39.988]                   sendCondition <- NULL
[13:24:39.988]                   function(frame = 1L) {
[13:24:39.988]                     if (is.function(sendCondition)) 
[13:24:39.988]                       return(sendCondition)
[13:24:39.988]                     ns <- getNamespace("parallel")
[13:24:39.988]                     if (exists("sendData", mode = "function", 
[13:24:39.988]                       envir = ns)) {
[13:24:39.988]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:39.988]                         envir = ns)
[13:24:39.988]                       envir <- sys.frame(frame)
[13:24:39.988]                       master <- NULL
[13:24:39.988]                       while (!identical(envir, .GlobalEnv) && 
[13:24:39.988]                         !identical(envir, emptyenv())) {
[13:24:39.988]                         if (exists("master", mode = "list", envir = envir, 
[13:24:39.988]                           inherits = FALSE)) {
[13:24:39.988]                           master <- get("master", mode = "list", 
[13:24:39.988]                             envir = envir, inherits = FALSE)
[13:24:39.988]                           if (inherits(master, c("SOCKnode", 
[13:24:39.988]                             "SOCK0node"))) {
[13:24:39.988]                             sendCondition <<- function(cond) {
[13:24:39.988]                               data <- list(type = "VALUE", value = cond, 
[13:24:39.988]                                 success = TRUE)
[13:24:39.988]                               parallel_sendData(master, data)
[13:24:39.988]                             }
[13:24:39.988]                             return(sendCondition)
[13:24:39.988]                           }
[13:24:39.988]                         }
[13:24:39.988]                         frame <- frame + 1L
[13:24:39.988]                         envir <- sys.frame(frame)
[13:24:39.988]                       }
[13:24:39.988]                     }
[13:24:39.988]                     sendCondition <<- function(cond) NULL
[13:24:39.988]                   }
[13:24:39.988]                 })
[13:24:39.988]                 withCallingHandlers({
[13:24:39.988]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:39.988]                 }, immediateCondition = function(cond) {
[13:24:39.988]                   sendCondition <- ...future.makeSendCondition()
[13:24:39.988]                   sendCondition(cond)
[13:24:39.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.988]                   {
[13:24:39.988]                     inherits <- base::inherits
[13:24:39.988]                     invokeRestart <- base::invokeRestart
[13:24:39.988]                     is.null <- base::is.null
[13:24:39.988]                     muffled <- FALSE
[13:24:39.988]                     if (inherits(cond, "message")) {
[13:24:39.988]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:39.988]                       if (muffled) 
[13:24:39.988]                         invokeRestart("muffleMessage")
[13:24:39.988]                     }
[13:24:39.988]                     else if (inherits(cond, "warning")) {
[13:24:39.988]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:39.988]                       if (muffled) 
[13:24:39.988]                         invokeRestart("muffleWarning")
[13:24:39.988]                     }
[13:24:39.988]                     else if (inherits(cond, "condition")) {
[13:24:39.988]                       if (!is.null(pattern)) {
[13:24:39.988]                         computeRestarts <- base::computeRestarts
[13:24:39.988]                         grepl <- base::grepl
[13:24:39.988]                         restarts <- computeRestarts(cond)
[13:24:39.988]                         for (restart in restarts) {
[13:24:39.988]                           name <- restart$name
[13:24:39.988]                           if (is.null(name)) 
[13:24:39.988]                             next
[13:24:39.988]                           if (!grepl(pattern, name)) 
[13:24:39.988]                             next
[13:24:39.988]                           invokeRestart(restart)
[13:24:39.988]                           muffled <- TRUE
[13:24:39.988]                           break
[13:24:39.988]                         }
[13:24:39.988]                       }
[13:24:39.988]                     }
[13:24:39.988]                     invisible(muffled)
[13:24:39.988]                   }
[13:24:39.988]                   muffleCondition(cond)
[13:24:39.988]                 })
[13:24:39.988]             }))
[13:24:39.988]             future::FutureResult(value = ...future.value$value, 
[13:24:39.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:39.988]                   ...future.rng), globalenv = if (FALSE) 
[13:24:39.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:39.988]                     ...future.globalenv.names))
[13:24:39.988]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:39.988]         }, condition = base::local({
[13:24:39.988]             c <- base::c
[13:24:39.988]             inherits <- base::inherits
[13:24:39.988]             invokeRestart <- base::invokeRestart
[13:24:39.988]             length <- base::length
[13:24:39.988]             list <- base::list
[13:24:39.988]             seq.int <- base::seq.int
[13:24:39.988]             signalCondition <- base::signalCondition
[13:24:39.988]             sys.calls <- base::sys.calls
[13:24:39.988]             `[[` <- base::`[[`
[13:24:39.988]             `+` <- base::`+`
[13:24:39.988]             `<<-` <- base::`<<-`
[13:24:39.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:39.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:39.988]                   3L)]
[13:24:39.988]             }
[13:24:39.988]             function(cond) {
[13:24:39.988]                 is_error <- inherits(cond, "error")
[13:24:39.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:39.988]                   NULL)
[13:24:39.988]                 if (is_error) {
[13:24:39.988]                   sessionInformation <- function() {
[13:24:39.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:39.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:39.988]                       search = base::search(), system = base::Sys.info())
[13:24:39.988]                   }
[13:24:39.988]                   ...future.conditions[[length(...future.conditions) + 
[13:24:39.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:39.988]                     cond$call), session = sessionInformation(), 
[13:24:39.988]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:39.988]                   signalCondition(cond)
[13:24:39.988]                 }
[13:24:39.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:39.988]                 "immediateCondition"))) {
[13:24:39.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:39.988]                   ...future.conditions[[length(...future.conditions) + 
[13:24:39.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:39.988]                   if (TRUE && !signal) {
[13:24:39.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.988]                     {
[13:24:39.988]                       inherits <- base::inherits
[13:24:39.988]                       invokeRestart <- base::invokeRestart
[13:24:39.988]                       is.null <- base::is.null
[13:24:39.988]                       muffled <- FALSE
[13:24:39.988]                       if (inherits(cond, "message")) {
[13:24:39.988]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:39.988]                         if (muffled) 
[13:24:39.988]                           invokeRestart("muffleMessage")
[13:24:39.988]                       }
[13:24:39.988]                       else if (inherits(cond, "warning")) {
[13:24:39.988]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:39.988]                         if (muffled) 
[13:24:39.988]                           invokeRestart("muffleWarning")
[13:24:39.988]                       }
[13:24:39.988]                       else if (inherits(cond, "condition")) {
[13:24:39.988]                         if (!is.null(pattern)) {
[13:24:39.988]                           computeRestarts <- base::computeRestarts
[13:24:39.988]                           grepl <- base::grepl
[13:24:39.988]                           restarts <- computeRestarts(cond)
[13:24:39.988]                           for (restart in restarts) {
[13:24:39.988]                             name <- restart$name
[13:24:39.988]                             if (is.null(name)) 
[13:24:39.988]                               next
[13:24:39.988]                             if (!grepl(pattern, name)) 
[13:24:39.988]                               next
[13:24:39.988]                             invokeRestart(restart)
[13:24:39.988]                             muffled <- TRUE
[13:24:39.988]                             break
[13:24:39.988]                           }
[13:24:39.988]                         }
[13:24:39.988]                       }
[13:24:39.988]                       invisible(muffled)
[13:24:39.988]                     }
[13:24:39.988]                     muffleCondition(cond, pattern = "^muffle")
[13:24:39.988]                   }
[13:24:39.988]                 }
[13:24:39.988]                 else {
[13:24:39.988]                   if (TRUE) {
[13:24:39.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:39.988]                     {
[13:24:39.988]                       inherits <- base::inherits
[13:24:39.988]                       invokeRestart <- base::invokeRestart
[13:24:39.988]                       is.null <- base::is.null
[13:24:39.988]                       muffled <- FALSE
[13:24:39.988]                       if (inherits(cond, "message")) {
[13:24:39.988]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:39.988]                         if (muffled) 
[13:24:39.988]                           invokeRestart("muffleMessage")
[13:24:39.988]                       }
[13:24:39.988]                       else if (inherits(cond, "warning")) {
[13:24:39.988]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:39.988]                         if (muffled) 
[13:24:39.988]                           invokeRestart("muffleWarning")
[13:24:39.988]                       }
[13:24:39.988]                       else if (inherits(cond, "condition")) {
[13:24:39.988]                         if (!is.null(pattern)) {
[13:24:39.988]                           computeRestarts <- base::computeRestarts
[13:24:39.988]                           grepl <- base::grepl
[13:24:39.988]                           restarts <- computeRestarts(cond)
[13:24:39.988]                           for (restart in restarts) {
[13:24:39.988]                             name <- restart$name
[13:24:39.988]                             if (is.null(name)) 
[13:24:39.988]                               next
[13:24:39.988]                             if (!grepl(pattern, name)) 
[13:24:39.988]                               next
[13:24:39.988]                             invokeRestart(restart)
[13:24:39.988]                             muffled <- TRUE
[13:24:39.988]                             break
[13:24:39.988]                           }
[13:24:39.988]                         }
[13:24:39.988]                       }
[13:24:39.988]                       invisible(muffled)
[13:24:39.988]                     }
[13:24:39.988]                     muffleCondition(cond, pattern = "^muffle")
[13:24:39.988]                   }
[13:24:39.988]                 }
[13:24:39.988]             }
[13:24:39.988]         }))
[13:24:39.988]     }, error = function(ex) {
[13:24:39.988]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:39.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:39.988]                 ...future.rng), started = ...future.startTime, 
[13:24:39.988]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:39.988]             version = "1.8"), class = "FutureResult")
[13:24:39.988]     }, finally = {
[13:24:39.988]         if (!identical(...future.workdir, getwd())) 
[13:24:39.988]             setwd(...future.workdir)
[13:24:39.988]         {
[13:24:39.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:39.988]                 ...future.oldOptions$nwarnings <- NULL
[13:24:39.988]             }
[13:24:39.988]             base::options(...future.oldOptions)
[13:24:39.988]             if (.Platform$OS.type == "windows") {
[13:24:39.988]                 old_names <- names(...future.oldEnvVars)
[13:24:39.988]                 envs <- base::Sys.getenv()
[13:24:39.988]                 names <- names(envs)
[13:24:39.988]                 common <- intersect(names, old_names)
[13:24:39.988]                 added <- setdiff(names, old_names)
[13:24:39.988]                 removed <- setdiff(old_names, names)
[13:24:39.988]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:39.988]                   envs[common]]
[13:24:39.988]                 NAMES <- toupper(changed)
[13:24:39.988]                 args <- list()
[13:24:39.988]                 for (kk in seq_along(NAMES)) {
[13:24:39.988]                   name <- changed[[kk]]
[13:24:39.988]                   NAME <- NAMES[[kk]]
[13:24:39.988]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.988]                     next
[13:24:39.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:39.988]                 }
[13:24:39.988]                 NAMES <- toupper(added)
[13:24:39.988]                 for (kk in seq_along(NAMES)) {
[13:24:39.988]                   name <- added[[kk]]
[13:24:39.988]                   NAME <- NAMES[[kk]]
[13:24:39.988]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.988]                     next
[13:24:39.988]                   args[[name]] <- ""
[13:24:39.988]                 }
[13:24:39.988]                 NAMES <- toupper(removed)
[13:24:39.988]                 for (kk in seq_along(NAMES)) {
[13:24:39.988]                   name <- removed[[kk]]
[13:24:39.988]                   NAME <- NAMES[[kk]]
[13:24:39.988]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:39.988]                     next
[13:24:39.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:39.988]                 }
[13:24:39.988]                 if (length(args) > 0) 
[13:24:39.988]                   base::do.call(base::Sys.setenv, args = args)
[13:24:39.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:39.988]             }
[13:24:39.988]             else {
[13:24:39.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:39.988]             }
[13:24:39.988]             {
[13:24:39.988]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:39.988]                   0L) {
[13:24:39.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:39.988]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:39.988]                   base::options(opts)
[13:24:39.988]                 }
[13:24:39.988]                 {
[13:24:39.988]                   {
[13:24:39.988]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:39.988]                     NULL
[13:24:39.988]                   }
[13:24:39.988]                   options(future.plan = NULL)
[13:24:39.988]                   if (is.na(NA_character_)) 
[13:24:39.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:39.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:39.988]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:39.988]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:39.988]                     envir = parent.frame()) 
[13:24:39.988]                   {
[13:24:39.988]                     if (is.function(workers)) 
[13:24:39.988]                       workers <- workers()
[13:24:39.988]                     workers <- structure(as.integer(workers), 
[13:24:39.988]                       class = class(workers))
[13:24:39.988]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:39.988]                       workers >= 1)
[13:24:39.988]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:39.988]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:39.988]                     }
[13:24:39.988]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:39.988]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:39.988]                       envir = envir)
[13:24:39.988]                     if (!future$lazy) 
[13:24:39.988]                       future <- run(future)
[13:24:39.988]                     invisible(future)
[13:24:39.988]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:39.988]                 }
[13:24:39.988]             }
[13:24:39.988]         }
[13:24:39.988]     })
[13:24:39.988]     if (TRUE) {
[13:24:39.988]         base::sink(type = "output", split = FALSE)
[13:24:39.988]         if (TRUE) {
[13:24:39.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:39.988]         }
[13:24:39.988]         else {
[13:24:39.988]             ...future.result["stdout"] <- base::list(NULL)
[13:24:39.988]         }
[13:24:39.988]         base::close(...future.stdout)
[13:24:39.988]         ...future.stdout <- NULL
[13:24:39.988]     }
[13:24:39.988]     ...future.result$conditions <- ...future.conditions
[13:24:39.988]     ...future.result$finished <- base::Sys.time()
[13:24:39.988]     ...future.result
[13:24:39.988] }
[13:24:39.991] MultisessionFuture started
[13:24:39.991] - Launch lazy future ... done
[13:24:39.991] run() for ‘MultisessionFuture’ ... done
[13:24:40.037] receiveMessageFromWorker() for ClusterFuture ...
[13:24:40.037] - Validating connection of MultisessionFuture
[13:24:40.038] - received message: FutureResult
[13:24:40.038] - Received FutureResult
[13:24:40.038] - Erased future from FutureRegistry
[13:24:40.038] result() for ClusterFuture ...
[13:24:40.038] - result already collected: FutureResult
[13:24:40.038] result() for ClusterFuture ... done
[13:24:40.039] signalConditions() ...
[13:24:40.039]  - include = ‘immediateCondition’
[13:24:40.039]  - exclude = 
[13:24:40.039]  - resignal = FALSE
[13:24:40.039]  - Number of conditions: 1
[13:24:40.039] signalConditions() ... done
[13:24:40.039] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:40.039] A MultisessionFuture was resolved
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[13:24:40.039] getGlobalsAndPackages() ...
[13:24:40.040] Searching for globals...
[13:24:40.041] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:40.041] Searching for globals ... DONE
[13:24:40.041] Resolving globals: FALSE
[13:24:40.041] 
[13:24:40.041] 
[13:24:40.042] getGlobalsAndPackages() ... DONE
[13:24:40.042] run() for ‘Future’ ...
[13:24:40.042] - state: ‘created’
[13:24:40.042] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:40.056] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:40.056] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:40.056]   - Field: ‘node’
[13:24:40.056]   - Field: ‘label’
[13:24:40.057]   - Field: ‘local’
[13:24:40.057]   - Field: ‘owner’
[13:24:40.057]   - Field: ‘envir’
[13:24:40.057]   - Field: ‘workers’
[13:24:40.057]   - Field: ‘packages’
[13:24:40.057]   - Field: ‘gc’
[13:24:40.057]   - Field: ‘conditions’
[13:24:40.057]   - Field: ‘persistent’
[13:24:40.057]   - Field: ‘expr’
[13:24:40.057]   - Field: ‘uuid’
[13:24:40.057]   - Field: ‘seed’
[13:24:40.058]   - Field: ‘version’
[13:24:40.058]   - Field: ‘result’
[13:24:40.058]   - Field: ‘asynchronous’
[13:24:40.058]   - Field: ‘calls’
[13:24:40.058]   - Field: ‘globals’
[13:24:40.058]   - Field: ‘stdout’
[13:24:40.058]   - Field: ‘earlySignal’
[13:24:40.058]   - Field: ‘lazy’
[13:24:40.058]   - Field: ‘state’
[13:24:40.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:40.058] - Launch lazy future ...
[13:24:40.059] Packages needed by the future expression (n = 0): <none>
[13:24:40.059] Packages needed by future strategies (n = 0): <none>
[13:24:40.059] {
[13:24:40.059]     {
[13:24:40.059]         {
[13:24:40.059]             ...future.startTime <- base::Sys.time()
[13:24:40.059]             {
[13:24:40.059]                 {
[13:24:40.059]                   {
[13:24:40.059]                     {
[13:24:40.059]                       base::local({
[13:24:40.059]                         has_future <- base::requireNamespace("future", 
[13:24:40.059]                           quietly = TRUE)
[13:24:40.059]                         if (has_future) {
[13:24:40.059]                           ns <- base::getNamespace("future")
[13:24:40.059]                           version <- ns[[".package"]][["version"]]
[13:24:40.059]                           if (is.null(version)) 
[13:24:40.059]                             version <- utils::packageVersion("future")
[13:24:40.059]                         }
[13:24:40.059]                         else {
[13:24:40.059]                           version <- NULL
[13:24:40.059]                         }
[13:24:40.059]                         if (!has_future || version < "1.8.0") {
[13:24:40.059]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:40.059]                             "", base::R.version$version.string), 
[13:24:40.059]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:40.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:40.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:40.059]                               "release", "version")], collapse = " "), 
[13:24:40.059]                             hostname = base::Sys.info()[["nodename"]])
[13:24:40.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:40.059]                             info)
[13:24:40.059]                           info <- base::paste(info, collapse = "; ")
[13:24:40.059]                           if (!has_future) {
[13:24:40.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:40.059]                               info)
[13:24:40.059]                           }
[13:24:40.059]                           else {
[13:24:40.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:40.059]                               info, version)
[13:24:40.059]                           }
[13:24:40.059]                           base::stop(msg)
[13:24:40.059]                         }
[13:24:40.059]                       })
[13:24:40.059]                     }
[13:24:40.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:40.059]                     base::options(mc.cores = 1L)
[13:24:40.059]                   }
[13:24:40.059]                   options(future.plan = NULL)
[13:24:40.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:40.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:40.059]                 }
[13:24:40.059]                 ...future.workdir <- getwd()
[13:24:40.059]             }
[13:24:40.059]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:40.059]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:40.059]         }
[13:24:40.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:40.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:40.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:40.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:40.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:40.059]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:40.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:40.059]             base::names(...future.oldOptions))
[13:24:40.059]     }
[13:24:40.059]     if (FALSE) {
[13:24:40.059]     }
[13:24:40.059]     else {
[13:24:40.059]         if (TRUE) {
[13:24:40.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:40.059]                 open = "w")
[13:24:40.059]         }
[13:24:40.059]         else {
[13:24:40.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:40.059]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:40.059]         }
[13:24:40.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:40.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:40.059]             base::sink(type = "output", split = FALSE)
[13:24:40.059]             base::close(...future.stdout)
[13:24:40.059]         }, add = TRUE)
[13:24:40.059]     }
[13:24:40.059]     ...future.frame <- base::sys.nframe()
[13:24:40.059]     ...future.conditions <- base::list()
[13:24:40.059]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:40.059]     if (FALSE) {
[13:24:40.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:40.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:40.059]     }
[13:24:40.059]     ...future.result <- base::tryCatch({
[13:24:40.059]         base::withCallingHandlers({
[13:24:40.059]             ...future.value <- base::withVisible(base::local({
[13:24:40.059]                 ...future.makeSendCondition <- base::local({
[13:24:40.059]                   sendCondition <- NULL
[13:24:40.059]                   function(frame = 1L) {
[13:24:40.059]                     if (is.function(sendCondition)) 
[13:24:40.059]                       return(sendCondition)
[13:24:40.059]                     ns <- getNamespace("parallel")
[13:24:40.059]                     if (exists("sendData", mode = "function", 
[13:24:40.059]                       envir = ns)) {
[13:24:40.059]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:40.059]                         envir = ns)
[13:24:40.059]                       envir <- sys.frame(frame)
[13:24:40.059]                       master <- NULL
[13:24:40.059]                       while (!identical(envir, .GlobalEnv) && 
[13:24:40.059]                         !identical(envir, emptyenv())) {
[13:24:40.059]                         if (exists("master", mode = "list", envir = envir, 
[13:24:40.059]                           inherits = FALSE)) {
[13:24:40.059]                           master <- get("master", mode = "list", 
[13:24:40.059]                             envir = envir, inherits = FALSE)
[13:24:40.059]                           if (inherits(master, c("SOCKnode", 
[13:24:40.059]                             "SOCK0node"))) {
[13:24:40.059]                             sendCondition <<- function(cond) {
[13:24:40.059]                               data <- list(type = "VALUE", value = cond, 
[13:24:40.059]                                 success = TRUE)
[13:24:40.059]                               parallel_sendData(master, data)
[13:24:40.059]                             }
[13:24:40.059]                             return(sendCondition)
[13:24:40.059]                           }
[13:24:40.059]                         }
[13:24:40.059]                         frame <- frame + 1L
[13:24:40.059]                         envir <- sys.frame(frame)
[13:24:40.059]                       }
[13:24:40.059]                     }
[13:24:40.059]                     sendCondition <<- function(cond) NULL
[13:24:40.059]                   }
[13:24:40.059]                 })
[13:24:40.059]                 withCallingHandlers({
[13:24:40.059]                   {
[13:24:40.059]                     Sys.sleep(0.5)
[13:24:40.059]                     list(a = 1, b = 42L)
[13:24:40.059]                   }
[13:24:40.059]                 }, immediateCondition = function(cond) {
[13:24:40.059]                   sendCondition <- ...future.makeSendCondition()
[13:24:40.059]                   sendCondition(cond)
[13:24:40.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:40.059]                   {
[13:24:40.059]                     inherits <- base::inherits
[13:24:40.059]                     invokeRestart <- base::invokeRestart
[13:24:40.059]                     is.null <- base::is.null
[13:24:40.059]                     muffled <- FALSE
[13:24:40.059]                     if (inherits(cond, "message")) {
[13:24:40.059]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:40.059]                       if (muffled) 
[13:24:40.059]                         invokeRestart("muffleMessage")
[13:24:40.059]                     }
[13:24:40.059]                     else if (inherits(cond, "warning")) {
[13:24:40.059]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:40.059]                       if (muffled) 
[13:24:40.059]                         invokeRestart("muffleWarning")
[13:24:40.059]                     }
[13:24:40.059]                     else if (inherits(cond, "condition")) {
[13:24:40.059]                       if (!is.null(pattern)) {
[13:24:40.059]                         computeRestarts <- base::computeRestarts
[13:24:40.059]                         grepl <- base::grepl
[13:24:40.059]                         restarts <- computeRestarts(cond)
[13:24:40.059]                         for (restart in restarts) {
[13:24:40.059]                           name <- restart$name
[13:24:40.059]                           if (is.null(name)) 
[13:24:40.059]                             next
[13:24:40.059]                           if (!grepl(pattern, name)) 
[13:24:40.059]                             next
[13:24:40.059]                           invokeRestart(restart)
[13:24:40.059]                           muffled <- TRUE
[13:24:40.059]                           break
[13:24:40.059]                         }
[13:24:40.059]                       }
[13:24:40.059]                     }
[13:24:40.059]                     invisible(muffled)
[13:24:40.059]                   }
[13:24:40.059]                   muffleCondition(cond)
[13:24:40.059]                 })
[13:24:40.059]             }))
[13:24:40.059]             future::FutureResult(value = ...future.value$value, 
[13:24:40.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:40.059]                   ...future.rng), globalenv = if (FALSE) 
[13:24:40.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:40.059]                     ...future.globalenv.names))
[13:24:40.059]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:40.059]         }, condition = base::local({
[13:24:40.059]             c <- base::c
[13:24:40.059]             inherits <- base::inherits
[13:24:40.059]             invokeRestart <- base::invokeRestart
[13:24:40.059]             length <- base::length
[13:24:40.059]             list <- base::list
[13:24:40.059]             seq.int <- base::seq.int
[13:24:40.059]             signalCondition <- base::signalCondition
[13:24:40.059]             sys.calls <- base::sys.calls
[13:24:40.059]             `[[` <- base::`[[`
[13:24:40.059]             `+` <- base::`+`
[13:24:40.059]             `<<-` <- base::`<<-`
[13:24:40.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:40.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:40.059]                   3L)]
[13:24:40.059]             }
[13:24:40.059]             function(cond) {
[13:24:40.059]                 is_error <- inherits(cond, "error")
[13:24:40.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:40.059]                   NULL)
[13:24:40.059]                 if (is_error) {
[13:24:40.059]                   sessionInformation <- function() {
[13:24:40.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:40.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:40.059]                       search = base::search(), system = base::Sys.info())
[13:24:40.059]                   }
[13:24:40.059]                   ...future.conditions[[length(...future.conditions) + 
[13:24:40.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:40.059]                     cond$call), session = sessionInformation(), 
[13:24:40.059]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:40.059]                   signalCondition(cond)
[13:24:40.059]                 }
[13:24:40.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:40.059]                 "immediateCondition"))) {
[13:24:40.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:40.059]                   ...future.conditions[[length(...future.conditions) + 
[13:24:40.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:40.059]                   if (TRUE && !signal) {
[13:24:40.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:40.059]                     {
[13:24:40.059]                       inherits <- base::inherits
[13:24:40.059]                       invokeRestart <- base::invokeRestart
[13:24:40.059]                       is.null <- base::is.null
[13:24:40.059]                       muffled <- FALSE
[13:24:40.059]                       if (inherits(cond, "message")) {
[13:24:40.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:40.059]                         if (muffled) 
[13:24:40.059]                           invokeRestart("muffleMessage")
[13:24:40.059]                       }
[13:24:40.059]                       else if (inherits(cond, "warning")) {
[13:24:40.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:40.059]                         if (muffled) 
[13:24:40.059]                           invokeRestart("muffleWarning")
[13:24:40.059]                       }
[13:24:40.059]                       else if (inherits(cond, "condition")) {
[13:24:40.059]                         if (!is.null(pattern)) {
[13:24:40.059]                           computeRestarts <- base::computeRestarts
[13:24:40.059]                           grepl <- base::grepl
[13:24:40.059]                           restarts <- computeRestarts(cond)
[13:24:40.059]                           for (restart in restarts) {
[13:24:40.059]                             name <- restart$name
[13:24:40.059]                             if (is.null(name)) 
[13:24:40.059]                               next
[13:24:40.059]                             if (!grepl(pattern, name)) 
[13:24:40.059]                               next
[13:24:40.059]                             invokeRestart(restart)
[13:24:40.059]                             muffled <- TRUE
[13:24:40.059]                             break
[13:24:40.059]                           }
[13:24:40.059]                         }
[13:24:40.059]                       }
[13:24:40.059]                       invisible(muffled)
[13:24:40.059]                     }
[13:24:40.059]                     muffleCondition(cond, pattern = "^muffle")
[13:24:40.059]                   }
[13:24:40.059]                 }
[13:24:40.059]                 else {
[13:24:40.059]                   if (TRUE) {
[13:24:40.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:40.059]                     {
[13:24:40.059]                       inherits <- base::inherits
[13:24:40.059]                       invokeRestart <- base::invokeRestart
[13:24:40.059]                       is.null <- base::is.null
[13:24:40.059]                       muffled <- FALSE
[13:24:40.059]                       if (inherits(cond, "message")) {
[13:24:40.059]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:40.059]                         if (muffled) 
[13:24:40.059]                           invokeRestart("muffleMessage")
[13:24:40.059]                       }
[13:24:40.059]                       else if (inherits(cond, "warning")) {
[13:24:40.059]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:40.059]                         if (muffled) 
[13:24:40.059]                           invokeRestart("muffleWarning")
[13:24:40.059]                       }
[13:24:40.059]                       else if (inherits(cond, "condition")) {
[13:24:40.059]                         if (!is.null(pattern)) {
[13:24:40.059]                           computeRestarts <- base::computeRestarts
[13:24:40.059]                           grepl <- base::grepl
[13:24:40.059]                           restarts <- computeRestarts(cond)
[13:24:40.059]                           for (restart in restarts) {
[13:24:40.059]                             name <- restart$name
[13:24:40.059]                             if (is.null(name)) 
[13:24:40.059]                               next
[13:24:40.059]                             if (!grepl(pattern, name)) 
[13:24:40.059]                               next
[13:24:40.059]                             invokeRestart(restart)
[13:24:40.059]                             muffled <- TRUE
[13:24:40.059]                             break
[13:24:40.059]                           }
[13:24:40.059]                         }
[13:24:40.059]                       }
[13:24:40.059]                       invisible(muffled)
[13:24:40.059]                     }
[13:24:40.059]                     muffleCondition(cond, pattern = "^muffle")
[13:24:40.059]                   }
[13:24:40.059]                 }
[13:24:40.059]             }
[13:24:40.059]         }))
[13:24:40.059]     }, error = function(ex) {
[13:24:40.059]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:40.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:40.059]                 ...future.rng), started = ...future.startTime, 
[13:24:40.059]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:40.059]             version = "1.8"), class = "FutureResult")
[13:24:40.059]     }, finally = {
[13:24:40.059]         if (!identical(...future.workdir, getwd())) 
[13:24:40.059]             setwd(...future.workdir)
[13:24:40.059]         {
[13:24:40.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:40.059]                 ...future.oldOptions$nwarnings <- NULL
[13:24:40.059]             }
[13:24:40.059]             base::options(...future.oldOptions)
[13:24:40.059]             if (.Platform$OS.type == "windows") {
[13:24:40.059]                 old_names <- names(...future.oldEnvVars)
[13:24:40.059]                 envs <- base::Sys.getenv()
[13:24:40.059]                 names <- names(envs)
[13:24:40.059]                 common <- intersect(names, old_names)
[13:24:40.059]                 added <- setdiff(names, old_names)
[13:24:40.059]                 removed <- setdiff(old_names, names)
[13:24:40.059]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:40.059]                   envs[common]]
[13:24:40.059]                 NAMES <- toupper(changed)
[13:24:40.059]                 args <- list()
[13:24:40.059]                 for (kk in seq_along(NAMES)) {
[13:24:40.059]                   name <- changed[[kk]]
[13:24:40.059]                   NAME <- NAMES[[kk]]
[13:24:40.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:40.059]                     next
[13:24:40.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:40.059]                 }
[13:24:40.059]                 NAMES <- toupper(added)
[13:24:40.059]                 for (kk in seq_along(NAMES)) {
[13:24:40.059]                   name <- added[[kk]]
[13:24:40.059]                   NAME <- NAMES[[kk]]
[13:24:40.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:40.059]                     next
[13:24:40.059]                   args[[name]] <- ""
[13:24:40.059]                 }
[13:24:40.059]                 NAMES <- toupper(removed)
[13:24:40.059]                 for (kk in seq_along(NAMES)) {
[13:24:40.059]                   name <- removed[[kk]]
[13:24:40.059]                   NAME <- NAMES[[kk]]
[13:24:40.059]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:40.059]                     next
[13:24:40.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:40.059]                 }
[13:24:40.059]                 if (length(args) > 0) 
[13:24:40.059]                   base::do.call(base::Sys.setenv, args = args)
[13:24:40.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:40.059]             }
[13:24:40.059]             else {
[13:24:40.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:40.059]             }
[13:24:40.059]             {
[13:24:40.059]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:40.059]                   0L) {
[13:24:40.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:40.059]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:40.059]                   base::options(opts)
[13:24:40.059]                 }
[13:24:40.059]                 {
[13:24:40.059]                   {
[13:24:40.059]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:40.059]                     NULL
[13:24:40.059]                   }
[13:24:40.059]                   options(future.plan = NULL)
[13:24:40.059]                   if (is.na(NA_character_)) 
[13:24:40.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:40.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:40.059]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:40.059]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:40.059]                     envir = parent.frame()) 
[13:24:40.059]                   {
[13:24:40.059]                     if (is.function(workers)) 
[13:24:40.059]                       workers <- workers()
[13:24:40.059]                     workers <- structure(as.integer(workers), 
[13:24:40.059]                       class = class(workers))
[13:24:40.059]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:40.059]                       workers >= 1)
[13:24:40.059]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:40.059]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:40.059]                     }
[13:24:40.059]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:40.059]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:40.059]                       envir = envir)
[13:24:40.059]                     if (!future$lazy) 
[13:24:40.059]                       future <- run(future)
[13:24:40.059]                     invisible(future)
[13:24:40.059]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:40.059]                 }
[13:24:40.059]             }
[13:24:40.059]         }
[13:24:40.059]     })
[13:24:40.059]     if (TRUE) {
[13:24:40.059]         base::sink(type = "output", split = FALSE)
[13:24:40.059]         if (TRUE) {
[13:24:40.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:40.059]         }
[13:24:40.059]         else {
[13:24:40.059]             ...future.result["stdout"] <- base::list(NULL)
[13:24:40.059]         }
[13:24:40.059]         base::close(...future.stdout)
[13:24:40.059]         ...future.stdout <- NULL
[13:24:40.059]     }
[13:24:40.059]     ...future.result$conditions <- ...future.conditions
[13:24:40.059]     ...future.result$finished <- base::Sys.time()
[13:24:40.059]     ...future.result
[13:24:40.059] }
[13:24:40.063] MultisessionFuture started
[13:24:40.063] - Launch lazy future ... done
[13:24:40.063] run() for ‘MultisessionFuture’ ... done
[13:24:40.621] receiveMessageFromWorker() for ClusterFuture ...
[13:24:40.621] - Validating connection of MultisessionFuture
[13:24:40.622] - received message: FutureResult
[13:24:40.622] - Received FutureResult
[13:24:40.622] - Erased future from FutureRegistry
[13:24:40.622] result() for ClusterFuture ...
[13:24:40.622] - result already collected: FutureResult
[13:24:40.622] result() for ClusterFuture ... done
[13:24:40.622] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:40.622] resolve() on list ...
[13:24:40.623]  recursive: Inf
[13:24:40.623]  length: 2
[13:24:40.623]  elements: ‘a’, ‘b’
[13:24:40.623]  length: 1 (resolved future 1)
[13:24:40.623]  length: 0 (resolved future 2)
[13:24:40.623] resolve() on list ... DONE
[13:24:40.623] A MultisessionFuture was resolved (and resolved itself)
[13:24:40.623] getGlobalsAndPackages() ...
[13:24:40.623] Searching for globals...
[13:24:40.625] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[13:24:40.625] Searching for globals ... DONE
[13:24:40.625] Resolving globals: FALSE
[13:24:40.625] 
[13:24:40.625] 
[13:24:40.625] getGlobalsAndPackages() ... DONE
[13:24:40.626] run() for ‘Future’ ...
[13:24:40.626] - state: ‘created’
[13:24:40.626] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:40.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:40.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:40.640]   - Field: ‘node’
[13:24:40.640]   - Field: ‘label’
[13:24:40.640]   - Field: ‘local’
[13:24:40.640]   - Field: ‘owner’
[13:24:40.641]   - Field: ‘envir’
[13:24:40.641]   - Field: ‘workers’
[13:24:40.641]   - Field: ‘packages’
[13:24:40.641]   - Field: ‘gc’
[13:24:40.641]   - Field: ‘conditions’
[13:24:40.641]   - Field: ‘persistent’
[13:24:40.641]   - Field: ‘expr’
[13:24:40.641]   - Field: ‘uuid’
[13:24:40.641]   - Field: ‘seed’
[13:24:40.641]   - Field: ‘version’
[13:24:40.641]   - Field: ‘result’
[13:24:40.641]   - Field: ‘asynchronous’
[13:24:40.642]   - Field: ‘calls’
[13:24:40.642]   - Field: ‘globals’
[13:24:40.642]   - Field: ‘stdout’
[13:24:40.642]   - Field: ‘earlySignal’
[13:24:40.642]   - Field: ‘lazy’
[13:24:40.642]   - Field: ‘state’
[13:24:40.642] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:40.642] - Launch lazy future ...
[13:24:40.643] Packages needed by the future expression (n = 0): <none>
[13:24:40.643] Packages needed by future strategies (n = 0): <none>
[13:24:40.643] {
[13:24:40.643]     {
[13:24:40.643]         {
[13:24:40.643]             ...future.startTime <- base::Sys.time()
[13:24:40.643]             {
[13:24:40.643]                 {
[13:24:40.643]                   {
[13:24:40.643]                     {
[13:24:40.643]                       base::local({
[13:24:40.643]                         has_future <- base::requireNamespace("future", 
[13:24:40.643]                           quietly = TRUE)
[13:24:40.643]                         if (has_future) {
[13:24:40.643]                           ns <- base::getNamespace("future")
[13:24:40.643]                           version <- ns[[".package"]][["version"]]
[13:24:40.643]                           if (is.null(version)) 
[13:24:40.643]                             version <- utils::packageVersion("future")
[13:24:40.643]                         }
[13:24:40.643]                         else {
[13:24:40.643]                           version <- NULL
[13:24:40.643]                         }
[13:24:40.643]                         if (!has_future || version < "1.8.0") {
[13:24:40.643]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:40.643]                             "", base::R.version$version.string), 
[13:24:40.643]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:40.643]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:40.643]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:40.643]                               "release", "version")], collapse = " "), 
[13:24:40.643]                             hostname = base::Sys.info()[["nodename"]])
[13:24:40.643]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:40.643]                             info)
[13:24:40.643]                           info <- base::paste(info, collapse = "; ")
[13:24:40.643]                           if (!has_future) {
[13:24:40.643]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:40.643]                               info)
[13:24:40.643]                           }
[13:24:40.643]                           else {
[13:24:40.643]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:40.643]                               info, version)
[13:24:40.643]                           }
[13:24:40.643]                           base::stop(msg)
[13:24:40.643]                         }
[13:24:40.643]                       })
[13:24:40.643]                     }
[13:24:40.643]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:40.643]                     base::options(mc.cores = 1L)
[13:24:40.643]                   }
[13:24:40.643]                   options(future.plan = NULL)
[13:24:40.643]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:40.643]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:40.643]                 }
[13:24:40.643]                 ...future.workdir <- getwd()
[13:24:40.643]             }
[13:24:40.643]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:40.643]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:40.643]         }
[13:24:40.643]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:40.643]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:40.643]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:40.643]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:40.643]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:40.643]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:40.643]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:40.643]             base::names(...future.oldOptions))
[13:24:40.643]     }
[13:24:40.643]     if (FALSE) {
[13:24:40.643]     }
[13:24:40.643]     else {
[13:24:40.643]         if (TRUE) {
[13:24:40.643]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:40.643]                 open = "w")
[13:24:40.643]         }
[13:24:40.643]         else {
[13:24:40.643]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:40.643]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:40.643]         }
[13:24:40.643]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:40.643]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:40.643]             base::sink(type = "output", split = FALSE)
[13:24:40.643]             base::close(...future.stdout)
[13:24:40.643]         }, add = TRUE)
[13:24:40.643]     }
[13:24:40.643]     ...future.frame <- base::sys.nframe()
[13:24:40.643]     ...future.conditions <- base::list()
[13:24:40.643]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:40.643]     if (FALSE) {
[13:24:40.643]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:40.643]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:40.643]     }
[13:24:40.643]     ...future.result <- base::tryCatch({
[13:24:40.643]         base::withCallingHandlers({
[13:24:40.643]             ...future.value <- base::withVisible(base::local({
[13:24:40.643]                 ...future.makeSendCondition <- base::local({
[13:24:40.643]                   sendCondition <- NULL
[13:24:40.643]                   function(frame = 1L) {
[13:24:40.643]                     if (is.function(sendCondition)) 
[13:24:40.643]                       return(sendCondition)
[13:24:40.643]                     ns <- getNamespace("parallel")
[13:24:40.643]                     if (exists("sendData", mode = "function", 
[13:24:40.643]                       envir = ns)) {
[13:24:40.643]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:40.643]                         envir = ns)
[13:24:40.643]                       envir <- sys.frame(frame)
[13:24:40.643]                       master <- NULL
[13:24:40.643]                       while (!identical(envir, .GlobalEnv) && 
[13:24:40.643]                         !identical(envir, emptyenv())) {
[13:24:40.643]                         if (exists("master", mode = "list", envir = envir, 
[13:24:40.643]                           inherits = FALSE)) {
[13:24:40.643]                           master <- get("master", mode = "list", 
[13:24:40.643]                             envir = envir, inherits = FALSE)
[13:24:40.643]                           if (inherits(master, c("SOCKnode", 
[13:24:40.643]                             "SOCK0node"))) {
[13:24:40.643]                             sendCondition <<- function(cond) {
[13:24:40.643]                               data <- list(type = "VALUE", value = cond, 
[13:24:40.643]                                 success = TRUE)
[13:24:40.643]                               parallel_sendData(master, data)
[13:24:40.643]                             }
[13:24:40.643]                             return(sendCondition)
[13:24:40.643]                           }
[13:24:40.643]                         }
[13:24:40.643]                         frame <- frame + 1L
[13:24:40.643]                         envir <- sys.frame(frame)
[13:24:40.643]                       }
[13:24:40.643]                     }
[13:24:40.643]                     sendCondition <<- function(cond) NULL
[13:24:40.643]                   }
[13:24:40.643]                 })
[13:24:40.643]                 withCallingHandlers({
[13:24:40.643]                   {
[13:24:40.643]                     Sys.sleep(0.5)
[13:24:40.643]                     list(a = 1, b = 42L)
[13:24:40.643]                   }
[13:24:40.643]                 }, immediateCondition = function(cond) {
[13:24:40.643]                   sendCondition <- ...future.makeSendCondition()
[13:24:40.643]                   sendCondition(cond)
[13:24:40.643]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:40.643]                   {
[13:24:40.643]                     inherits <- base::inherits
[13:24:40.643]                     invokeRestart <- base::invokeRestart
[13:24:40.643]                     is.null <- base::is.null
[13:24:40.643]                     muffled <- FALSE
[13:24:40.643]                     if (inherits(cond, "message")) {
[13:24:40.643]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:40.643]                       if (muffled) 
[13:24:40.643]                         invokeRestart("muffleMessage")
[13:24:40.643]                     }
[13:24:40.643]                     else if (inherits(cond, "warning")) {
[13:24:40.643]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:40.643]                       if (muffled) 
[13:24:40.643]                         invokeRestart("muffleWarning")
[13:24:40.643]                     }
[13:24:40.643]                     else if (inherits(cond, "condition")) {
[13:24:40.643]                       if (!is.null(pattern)) {
[13:24:40.643]                         computeRestarts <- base::computeRestarts
[13:24:40.643]                         grepl <- base::grepl
[13:24:40.643]                         restarts <- computeRestarts(cond)
[13:24:40.643]                         for (restart in restarts) {
[13:24:40.643]                           name <- restart$name
[13:24:40.643]                           if (is.null(name)) 
[13:24:40.643]                             next
[13:24:40.643]                           if (!grepl(pattern, name)) 
[13:24:40.643]                             next
[13:24:40.643]                           invokeRestart(restart)
[13:24:40.643]                           muffled <- TRUE
[13:24:40.643]                           break
[13:24:40.643]                         }
[13:24:40.643]                       }
[13:24:40.643]                     }
[13:24:40.643]                     invisible(muffled)
[13:24:40.643]                   }
[13:24:40.643]                   muffleCondition(cond)
[13:24:40.643]                 })
[13:24:40.643]             }))
[13:24:40.643]             future::FutureResult(value = ...future.value$value, 
[13:24:40.643]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:40.643]                   ...future.rng), globalenv = if (FALSE) 
[13:24:40.643]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:40.643]                     ...future.globalenv.names))
[13:24:40.643]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:40.643]         }, condition = base::local({
[13:24:40.643]             c <- base::c
[13:24:40.643]             inherits <- base::inherits
[13:24:40.643]             invokeRestart <- base::invokeRestart
[13:24:40.643]             length <- base::length
[13:24:40.643]             list <- base::list
[13:24:40.643]             seq.int <- base::seq.int
[13:24:40.643]             signalCondition <- base::signalCondition
[13:24:40.643]             sys.calls <- base::sys.calls
[13:24:40.643]             `[[` <- base::`[[`
[13:24:40.643]             `+` <- base::`+`
[13:24:40.643]             `<<-` <- base::`<<-`
[13:24:40.643]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:40.643]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:40.643]                   3L)]
[13:24:40.643]             }
[13:24:40.643]             function(cond) {
[13:24:40.643]                 is_error <- inherits(cond, "error")
[13:24:40.643]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:40.643]                   NULL)
[13:24:40.643]                 if (is_error) {
[13:24:40.643]                   sessionInformation <- function() {
[13:24:40.643]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:40.643]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:40.643]                       search = base::search(), system = base::Sys.info())
[13:24:40.643]                   }
[13:24:40.643]                   ...future.conditions[[length(...future.conditions) + 
[13:24:40.643]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:40.643]                     cond$call), session = sessionInformation(), 
[13:24:40.643]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:40.643]                   signalCondition(cond)
[13:24:40.643]                 }
[13:24:40.643]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:40.643]                 "immediateCondition"))) {
[13:24:40.643]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:40.643]                   ...future.conditions[[length(...future.conditions) + 
[13:24:40.643]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:40.643]                   if (TRUE && !signal) {
[13:24:40.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:40.643]                     {
[13:24:40.643]                       inherits <- base::inherits
[13:24:40.643]                       invokeRestart <- base::invokeRestart
[13:24:40.643]                       is.null <- base::is.null
[13:24:40.643]                       muffled <- FALSE
[13:24:40.643]                       if (inherits(cond, "message")) {
[13:24:40.643]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:40.643]                         if (muffled) 
[13:24:40.643]                           invokeRestart("muffleMessage")
[13:24:40.643]                       }
[13:24:40.643]                       else if (inherits(cond, "warning")) {
[13:24:40.643]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:40.643]                         if (muffled) 
[13:24:40.643]                           invokeRestart("muffleWarning")
[13:24:40.643]                       }
[13:24:40.643]                       else if (inherits(cond, "condition")) {
[13:24:40.643]                         if (!is.null(pattern)) {
[13:24:40.643]                           computeRestarts <- base::computeRestarts
[13:24:40.643]                           grepl <- base::grepl
[13:24:40.643]                           restarts <- computeRestarts(cond)
[13:24:40.643]                           for (restart in restarts) {
[13:24:40.643]                             name <- restart$name
[13:24:40.643]                             if (is.null(name)) 
[13:24:40.643]                               next
[13:24:40.643]                             if (!grepl(pattern, name)) 
[13:24:40.643]                               next
[13:24:40.643]                             invokeRestart(restart)
[13:24:40.643]                             muffled <- TRUE
[13:24:40.643]                             break
[13:24:40.643]                           }
[13:24:40.643]                         }
[13:24:40.643]                       }
[13:24:40.643]                       invisible(muffled)
[13:24:40.643]                     }
[13:24:40.643]                     muffleCondition(cond, pattern = "^muffle")
[13:24:40.643]                   }
[13:24:40.643]                 }
[13:24:40.643]                 else {
[13:24:40.643]                   if (TRUE) {
[13:24:40.643]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:40.643]                     {
[13:24:40.643]                       inherits <- base::inherits
[13:24:40.643]                       invokeRestart <- base::invokeRestart
[13:24:40.643]                       is.null <- base::is.null
[13:24:40.643]                       muffled <- FALSE
[13:24:40.643]                       if (inherits(cond, "message")) {
[13:24:40.643]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:40.643]                         if (muffled) 
[13:24:40.643]                           invokeRestart("muffleMessage")
[13:24:40.643]                       }
[13:24:40.643]                       else if (inherits(cond, "warning")) {
[13:24:40.643]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:40.643]                         if (muffled) 
[13:24:40.643]                           invokeRestart("muffleWarning")
[13:24:40.643]                       }
[13:24:40.643]                       else if (inherits(cond, "condition")) {
[13:24:40.643]                         if (!is.null(pattern)) {
[13:24:40.643]                           computeRestarts <- base::computeRestarts
[13:24:40.643]                           grepl <- base::grepl
[13:24:40.643]                           restarts <- computeRestarts(cond)
[13:24:40.643]                           for (restart in restarts) {
[13:24:40.643]                             name <- restart$name
[13:24:40.643]                             if (is.null(name)) 
[13:24:40.643]                               next
[13:24:40.643]                             if (!grepl(pattern, name)) 
[13:24:40.643]                               next
[13:24:40.643]                             invokeRestart(restart)
[13:24:40.643]                             muffled <- TRUE
[13:24:40.643]                             break
[13:24:40.643]                           }
[13:24:40.643]                         }
[13:24:40.643]                       }
[13:24:40.643]                       invisible(muffled)
[13:24:40.643]                     }
[13:24:40.643]                     muffleCondition(cond, pattern = "^muffle")
[13:24:40.643]                   }
[13:24:40.643]                 }
[13:24:40.643]             }
[13:24:40.643]         }))
[13:24:40.643]     }, error = function(ex) {
[13:24:40.643]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:40.643]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:40.643]                 ...future.rng), started = ...future.startTime, 
[13:24:40.643]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:40.643]             version = "1.8"), class = "FutureResult")
[13:24:40.643]     }, finally = {
[13:24:40.643]         if (!identical(...future.workdir, getwd())) 
[13:24:40.643]             setwd(...future.workdir)
[13:24:40.643]         {
[13:24:40.643]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:40.643]                 ...future.oldOptions$nwarnings <- NULL
[13:24:40.643]             }
[13:24:40.643]             base::options(...future.oldOptions)
[13:24:40.643]             if (.Platform$OS.type == "windows") {
[13:24:40.643]                 old_names <- names(...future.oldEnvVars)
[13:24:40.643]                 envs <- base::Sys.getenv()
[13:24:40.643]                 names <- names(envs)
[13:24:40.643]                 common <- intersect(names, old_names)
[13:24:40.643]                 added <- setdiff(names, old_names)
[13:24:40.643]                 removed <- setdiff(old_names, names)
[13:24:40.643]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:40.643]                   envs[common]]
[13:24:40.643]                 NAMES <- toupper(changed)
[13:24:40.643]                 args <- list()
[13:24:40.643]                 for (kk in seq_along(NAMES)) {
[13:24:40.643]                   name <- changed[[kk]]
[13:24:40.643]                   NAME <- NAMES[[kk]]
[13:24:40.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:40.643]                     next
[13:24:40.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:40.643]                 }
[13:24:40.643]                 NAMES <- toupper(added)
[13:24:40.643]                 for (kk in seq_along(NAMES)) {
[13:24:40.643]                   name <- added[[kk]]
[13:24:40.643]                   NAME <- NAMES[[kk]]
[13:24:40.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:40.643]                     next
[13:24:40.643]                   args[[name]] <- ""
[13:24:40.643]                 }
[13:24:40.643]                 NAMES <- toupper(removed)
[13:24:40.643]                 for (kk in seq_along(NAMES)) {
[13:24:40.643]                   name <- removed[[kk]]
[13:24:40.643]                   NAME <- NAMES[[kk]]
[13:24:40.643]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:40.643]                     next
[13:24:40.643]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:40.643]                 }
[13:24:40.643]                 if (length(args) > 0) 
[13:24:40.643]                   base::do.call(base::Sys.setenv, args = args)
[13:24:40.643]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:40.643]             }
[13:24:40.643]             else {
[13:24:40.643]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:40.643]             }
[13:24:40.643]             {
[13:24:40.643]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:40.643]                   0L) {
[13:24:40.643]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:40.643]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:40.643]                   base::options(opts)
[13:24:40.643]                 }
[13:24:40.643]                 {
[13:24:40.643]                   {
[13:24:40.643]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:40.643]                     NULL
[13:24:40.643]                   }
[13:24:40.643]                   options(future.plan = NULL)
[13:24:40.643]                   if (is.na(NA_character_)) 
[13:24:40.643]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:40.643]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:40.643]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:40.643]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:40.643]                     envir = parent.frame()) 
[13:24:40.643]                   {
[13:24:40.643]                     if (is.function(workers)) 
[13:24:40.643]                       workers <- workers()
[13:24:40.643]                     workers <- structure(as.integer(workers), 
[13:24:40.643]                       class = class(workers))
[13:24:40.643]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:40.643]                       workers >= 1)
[13:24:40.643]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:40.643]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:40.643]                     }
[13:24:40.643]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:40.643]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:40.643]                       envir = envir)
[13:24:40.643]                     if (!future$lazy) 
[13:24:40.643]                       future <- run(future)
[13:24:40.643]                     invisible(future)
[13:24:40.643]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:40.643]                 }
[13:24:40.643]             }
[13:24:40.643]         }
[13:24:40.643]     })
[13:24:40.643]     if (TRUE) {
[13:24:40.643]         base::sink(type = "output", split = FALSE)
[13:24:40.643]         if (TRUE) {
[13:24:40.643]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:40.643]         }
[13:24:40.643]         else {
[13:24:40.643]             ...future.result["stdout"] <- base::list(NULL)
[13:24:40.643]         }
[13:24:40.643]         base::close(...future.stdout)
[13:24:40.643]         ...future.stdout <- NULL
[13:24:40.643]     }
[13:24:40.643]     ...future.result$conditions <- ...future.conditions
[13:24:40.643]     ...future.result$finished <- base::Sys.time()
[13:24:40.643]     ...future.result
[13:24:40.643] }
[13:24:40.646] MultisessionFuture started
[13:24:40.647] - Launch lazy future ... done
[13:24:40.647] run() for ‘MultisessionFuture’ ... done
[13:24:41.194] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.194] - Validating connection of MultisessionFuture
[13:24:41.194] - received message: FutureResult
[13:24:41.194] - Received FutureResult
[13:24:41.195] - Erased future from FutureRegistry
[13:24:41.195] result() for ClusterFuture ...
[13:24:41.195] - result already collected: FutureResult
[13:24:41.195] result() for ClusterFuture ... done
[13:24:41.195] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.195] resolve() on list ...
[13:24:41.195]  recursive: Inf
[13:24:41.195]  length: 2
[13:24:41.195]  elements: ‘a’, ‘b’
[13:24:41.195]  length: 1 (resolved future 1)
[13:24:41.196]  length: 0 (resolved future 2)
[13:24:41.196] resolve() on list ... DONE
[13:24:41.196] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[13:24:41.196] getGlobalsAndPackages() ...
[13:24:41.196] Searching for globals...
[13:24:41.199] - globals found: [2] ‘list’, ‘stop’
[13:24:41.200] Searching for globals ... DONE
[13:24:41.200] Resolving globals: FALSE
[13:24:41.200] 
[13:24:41.200] 
[13:24:41.200] getGlobalsAndPackages() ... DONE
[13:24:41.201] run() for ‘Future’ ...
[13:24:41.201] - state: ‘created’
[13:24:41.201] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.215] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.215]   - Field: ‘node’
[13:24:41.215]   - Field: ‘label’
[13:24:41.215]   - Field: ‘local’
[13:24:41.215]   - Field: ‘owner’
[13:24:41.215]   - Field: ‘envir’
[13:24:41.216]   - Field: ‘workers’
[13:24:41.216]   - Field: ‘packages’
[13:24:41.216]   - Field: ‘gc’
[13:24:41.216]   - Field: ‘conditions’
[13:24:41.216]   - Field: ‘persistent’
[13:24:41.216]   - Field: ‘expr’
[13:24:41.216]   - Field: ‘uuid’
[13:24:41.216]   - Field: ‘seed’
[13:24:41.216]   - Field: ‘version’
[13:24:41.216]   - Field: ‘result’
[13:24:41.216]   - Field: ‘asynchronous’
[13:24:41.217]   - Field: ‘calls’
[13:24:41.217]   - Field: ‘globals’
[13:24:41.217]   - Field: ‘stdout’
[13:24:41.217]   - Field: ‘earlySignal’
[13:24:41.217]   - Field: ‘lazy’
[13:24:41.217]   - Field: ‘state’
[13:24:41.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.217] - Launch lazy future ...
[13:24:41.217] Packages needed by the future expression (n = 0): <none>
[13:24:41.218] Packages needed by future strategies (n = 0): <none>
[13:24:41.218] {
[13:24:41.218]     {
[13:24:41.218]         {
[13:24:41.218]             ...future.startTime <- base::Sys.time()
[13:24:41.218]             {
[13:24:41.218]                 {
[13:24:41.218]                   {
[13:24:41.218]                     {
[13:24:41.218]                       base::local({
[13:24:41.218]                         has_future <- base::requireNamespace("future", 
[13:24:41.218]                           quietly = TRUE)
[13:24:41.218]                         if (has_future) {
[13:24:41.218]                           ns <- base::getNamespace("future")
[13:24:41.218]                           version <- ns[[".package"]][["version"]]
[13:24:41.218]                           if (is.null(version)) 
[13:24:41.218]                             version <- utils::packageVersion("future")
[13:24:41.218]                         }
[13:24:41.218]                         else {
[13:24:41.218]                           version <- NULL
[13:24:41.218]                         }
[13:24:41.218]                         if (!has_future || version < "1.8.0") {
[13:24:41.218]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.218]                             "", base::R.version$version.string), 
[13:24:41.218]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.218]                               "release", "version")], collapse = " "), 
[13:24:41.218]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.218]                             info)
[13:24:41.218]                           info <- base::paste(info, collapse = "; ")
[13:24:41.218]                           if (!has_future) {
[13:24:41.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.218]                               info)
[13:24:41.218]                           }
[13:24:41.218]                           else {
[13:24:41.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.218]                               info, version)
[13:24:41.218]                           }
[13:24:41.218]                           base::stop(msg)
[13:24:41.218]                         }
[13:24:41.218]                       })
[13:24:41.218]                     }
[13:24:41.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.218]                     base::options(mc.cores = 1L)
[13:24:41.218]                   }
[13:24:41.218]                   options(future.plan = NULL)
[13:24:41.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.218]                 }
[13:24:41.218]                 ...future.workdir <- getwd()
[13:24:41.218]             }
[13:24:41.218]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.218]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.218]         }
[13:24:41.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.218]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.218]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.218]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.218]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.218]             base::names(...future.oldOptions))
[13:24:41.218]     }
[13:24:41.218]     if (FALSE) {
[13:24:41.218]     }
[13:24:41.218]     else {
[13:24:41.218]         if (TRUE) {
[13:24:41.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.218]                 open = "w")
[13:24:41.218]         }
[13:24:41.218]         else {
[13:24:41.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.218]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.218]         }
[13:24:41.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.218]             base::sink(type = "output", split = FALSE)
[13:24:41.218]             base::close(...future.stdout)
[13:24:41.218]         }, add = TRUE)
[13:24:41.218]     }
[13:24:41.218]     ...future.frame <- base::sys.nframe()
[13:24:41.218]     ...future.conditions <- base::list()
[13:24:41.218]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.218]     if (FALSE) {
[13:24:41.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.218]     }
[13:24:41.218]     ...future.result <- base::tryCatch({
[13:24:41.218]         base::withCallingHandlers({
[13:24:41.218]             ...future.value <- base::withVisible(base::local({
[13:24:41.218]                 ...future.makeSendCondition <- base::local({
[13:24:41.218]                   sendCondition <- NULL
[13:24:41.218]                   function(frame = 1L) {
[13:24:41.218]                     if (is.function(sendCondition)) 
[13:24:41.218]                       return(sendCondition)
[13:24:41.218]                     ns <- getNamespace("parallel")
[13:24:41.218]                     if (exists("sendData", mode = "function", 
[13:24:41.218]                       envir = ns)) {
[13:24:41.218]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.218]                         envir = ns)
[13:24:41.218]                       envir <- sys.frame(frame)
[13:24:41.218]                       master <- NULL
[13:24:41.218]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.218]                         !identical(envir, emptyenv())) {
[13:24:41.218]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.218]                           inherits = FALSE)) {
[13:24:41.218]                           master <- get("master", mode = "list", 
[13:24:41.218]                             envir = envir, inherits = FALSE)
[13:24:41.218]                           if (inherits(master, c("SOCKnode", 
[13:24:41.218]                             "SOCK0node"))) {
[13:24:41.218]                             sendCondition <<- function(cond) {
[13:24:41.218]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.218]                                 success = TRUE)
[13:24:41.218]                               parallel_sendData(master, data)
[13:24:41.218]                             }
[13:24:41.218]                             return(sendCondition)
[13:24:41.218]                           }
[13:24:41.218]                         }
[13:24:41.218]                         frame <- frame + 1L
[13:24:41.218]                         envir <- sys.frame(frame)
[13:24:41.218]                       }
[13:24:41.218]                     }
[13:24:41.218]                     sendCondition <<- function(cond) NULL
[13:24:41.218]                   }
[13:24:41.218]                 })
[13:24:41.218]                 withCallingHandlers({
[13:24:41.218]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:41.218]                 }, immediateCondition = function(cond) {
[13:24:41.218]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.218]                   sendCondition(cond)
[13:24:41.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.218]                   {
[13:24:41.218]                     inherits <- base::inherits
[13:24:41.218]                     invokeRestart <- base::invokeRestart
[13:24:41.218]                     is.null <- base::is.null
[13:24:41.218]                     muffled <- FALSE
[13:24:41.218]                     if (inherits(cond, "message")) {
[13:24:41.218]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.218]                       if (muffled) 
[13:24:41.218]                         invokeRestart("muffleMessage")
[13:24:41.218]                     }
[13:24:41.218]                     else if (inherits(cond, "warning")) {
[13:24:41.218]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.218]                       if (muffled) 
[13:24:41.218]                         invokeRestart("muffleWarning")
[13:24:41.218]                     }
[13:24:41.218]                     else if (inherits(cond, "condition")) {
[13:24:41.218]                       if (!is.null(pattern)) {
[13:24:41.218]                         computeRestarts <- base::computeRestarts
[13:24:41.218]                         grepl <- base::grepl
[13:24:41.218]                         restarts <- computeRestarts(cond)
[13:24:41.218]                         for (restart in restarts) {
[13:24:41.218]                           name <- restart$name
[13:24:41.218]                           if (is.null(name)) 
[13:24:41.218]                             next
[13:24:41.218]                           if (!grepl(pattern, name)) 
[13:24:41.218]                             next
[13:24:41.218]                           invokeRestart(restart)
[13:24:41.218]                           muffled <- TRUE
[13:24:41.218]                           break
[13:24:41.218]                         }
[13:24:41.218]                       }
[13:24:41.218]                     }
[13:24:41.218]                     invisible(muffled)
[13:24:41.218]                   }
[13:24:41.218]                   muffleCondition(cond)
[13:24:41.218]                 })
[13:24:41.218]             }))
[13:24:41.218]             future::FutureResult(value = ...future.value$value, 
[13:24:41.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.218]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.218]                     ...future.globalenv.names))
[13:24:41.218]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.218]         }, condition = base::local({
[13:24:41.218]             c <- base::c
[13:24:41.218]             inherits <- base::inherits
[13:24:41.218]             invokeRestart <- base::invokeRestart
[13:24:41.218]             length <- base::length
[13:24:41.218]             list <- base::list
[13:24:41.218]             seq.int <- base::seq.int
[13:24:41.218]             signalCondition <- base::signalCondition
[13:24:41.218]             sys.calls <- base::sys.calls
[13:24:41.218]             `[[` <- base::`[[`
[13:24:41.218]             `+` <- base::`+`
[13:24:41.218]             `<<-` <- base::`<<-`
[13:24:41.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.218]                   3L)]
[13:24:41.218]             }
[13:24:41.218]             function(cond) {
[13:24:41.218]                 is_error <- inherits(cond, "error")
[13:24:41.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.218]                   NULL)
[13:24:41.218]                 if (is_error) {
[13:24:41.218]                   sessionInformation <- function() {
[13:24:41.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.218]                       search = base::search(), system = base::Sys.info())
[13:24:41.218]                   }
[13:24:41.218]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.218]                     cond$call), session = sessionInformation(), 
[13:24:41.218]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.218]                   signalCondition(cond)
[13:24:41.218]                 }
[13:24:41.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.218]                 "immediateCondition"))) {
[13:24:41.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.218]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.218]                   if (TRUE && !signal) {
[13:24:41.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.218]                     {
[13:24:41.218]                       inherits <- base::inherits
[13:24:41.218]                       invokeRestart <- base::invokeRestart
[13:24:41.218]                       is.null <- base::is.null
[13:24:41.218]                       muffled <- FALSE
[13:24:41.218]                       if (inherits(cond, "message")) {
[13:24:41.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.218]                         if (muffled) 
[13:24:41.218]                           invokeRestart("muffleMessage")
[13:24:41.218]                       }
[13:24:41.218]                       else if (inherits(cond, "warning")) {
[13:24:41.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.218]                         if (muffled) 
[13:24:41.218]                           invokeRestart("muffleWarning")
[13:24:41.218]                       }
[13:24:41.218]                       else if (inherits(cond, "condition")) {
[13:24:41.218]                         if (!is.null(pattern)) {
[13:24:41.218]                           computeRestarts <- base::computeRestarts
[13:24:41.218]                           grepl <- base::grepl
[13:24:41.218]                           restarts <- computeRestarts(cond)
[13:24:41.218]                           for (restart in restarts) {
[13:24:41.218]                             name <- restart$name
[13:24:41.218]                             if (is.null(name)) 
[13:24:41.218]                               next
[13:24:41.218]                             if (!grepl(pattern, name)) 
[13:24:41.218]                               next
[13:24:41.218]                             invokeRestart(restart)
[13:24:41.218]                             muffled <- TRUE
[13:24:41.218]                             break
[13:24:41.218]                           }
[13:24:41.218]                         }
[13:24:41.218]                       }
[13:24:41.218]                       invisible(muffled)
[13:24:41.218]                     }
[13:24:41.218]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.218]                   }
[13:24:41.218]                 }
[13:24:41.218]                 else {
[13:24:41.218]                   if (TRUE) {
[13:24:41.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.218]                     {
[13:24:41.218]                       inherits <- base::inherits
[13:24:41.218]                       invokeRestart <- base::invokeRestart
[13:24:41.218]                       is.null <- base::is.null
[13:24:41.218]                       muffled <- FALSE
[13:24:41.218]                       if (inherits(cond, "message")) {
[13:24:41.218]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.218]                         if (muffled) 
[13:24:41.218]                           invokeRestart("muffleMessage")
[13:24:41.218]                       }
[13:24:41.218]                       else if (inherits(cond, "warning")) {
[13:24:41.218]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.218]                         if (muffled) 
[13:24:41.218]                           invokeRestart("muffleWarning")
[13:24:41.218]                       }
[13:24:41.218]                       else if (inherits(cond, "condition")) {
[13:24:41.218]                         if (!is.null(pattern)) {
[13:24:41.218]                           computeRestarts <- base::computeRestarts
[13:24:41.218]                           grepl <- base::grepl
[13:24:41.218]                           restarts <- computeRestarts(cond)
[13:24:41.218]                           for (restart in restarts) {
[13:24:41.218]                             name <- restart$name
[13:24:41.218]                             if (is.null(name)) 
[13:24:41.218]                               next
[13:24:41.218]                             if (!grepl(pattern, name)) 
[13:24:41.218]                               next
[13:24:41.218]                             invokeRestart(restart)
[13:24:41.218]                             muffled <- TRUE
[13:24:41.218]                             break
[13:24:41.218]                           }
[13:24:41.218]                         }
[13:24:41.218]                       }
[13:24:41.218]                       invisible(muffled)
[13:24:41.218]                     }
[13:24:41.218]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.218]                   }
[13:24:41.218]                 }
[13:24:41.218]             }
[13:24:41.218]         }))
[13:24:41.218]     }, error = function(ex) {
[13:24:41.218]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.218]                 ...future.rng), started = ...future.startTime, 
[13:24:41.218]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.218]             version = "1.8"), class = "FutureResult")
[13:24:41.218]     }, finally = {
[13:24:41.218]         if (!identical(...future.workdir, getwd())) 
[13:24:41.218]             setwd(...future.workdir)
[13:24:41.218]         {
[13:24:41.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.218]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.218]             }
[13:24:41.218]             base::options(...future.oldOptions)
[13:24:41.218]             if (.Platform$OS.type == "windows") {
[13:24:41.218]                 old_names <- names(...future.oldEnvVars)
[13:24:41.218]                 envs <- base::Sys.getenv()
[13:24:41.218]                 names <- names(envs)
[13:24:41.218]                 common <- intersect(names, old_names)
[13:24:41.218]                 added <- setdiff(names, old_names)
[13:24:41.218]                 removed <- setdiff(old_names, names)
[13:24:41.218]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.218]                   envs[common]]
[13:24:41.218]                 NAMES <- toupper(changed)
[13:24:41.218]                 args <- list()
[13:24:41.218]                 for (kk in seq_along(NAMES)) {
[13:24:41.218]                   name <- changed[[kk]]
[13:24:41.218]                   NAME <- NAMES[[kk]]
[13:24:41.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.218]                     next
[13:24:41.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.218]                 }
[13:24:41.218]                 NAMES <- toupper(added)
[13:24:41.218]                 for (kk in seq_along(NAMES)) {
[13:24:41.218]                   name <- added[[kk]]
[13:24:41.218]                   NAME <- NAMES[[kk]]
[13:24:41.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.218]                     next
[13:24:41.218]                   args[[name]] <- ""
[13:24:41.218]                 }
[13:24:41.218]                 NAMES <- toupper(removed)
[13:24:41.218]                 for (kk in seq_along(NAMES)) {
[13:24:41.218]                   name <- removed[[kk]]
[13:24:41.218]                   NAME <- NAMES[[kk]]
[13:24:41.218]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.218]                     next
[13:24:41.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.218]                 }
[13:24:41.218]                 if (length(args) > 0) 
[13:24:41.218]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.218]             }
[13:24:41.218]             else {
[13:24:41.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.218]             }
[13:24:41.218]             {
[13:24:41.218]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.218]                   0L) {
[13:24:41.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.218]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.218]                   base::options(opts)
[13:24:41.218]                 }
[13:24:41.218]                 {
[13:24:41.218]                   {
[13:24:41.218]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.218]                     NULL
[13:24:41.218]                   }
[13:24:41.218]                   options(future.plan = NULL)
[13:24:41.218]                   if (is.na(NA_character_)) 
[13:24:41.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.218]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.218]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.218]                     envir = parent.frame()) 
[13:24:41.218]                   {
[13:24:41.218]                     if (is.function(workers)) 
[13:24:41.218]                       workers <- workers()
[13:24:41.218]                     workers <- structure(as.integer(workers), 
[13:24:41.218]                       class = class(workers))
[13:24:41.218]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.218]                       workers >= 1)
[13:24:41.218]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.218]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.218]                     }
[13:24:41.218]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.218]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.218]                       envir = envir)
[13:24:41.218]                     if (!future$lazy) 
[13:24:41.218]                       future <- run(future)
[13:24:41.218]                     invisible(future)
[13:24:41.218]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.218]                 }
[13:24:41.218]             }
[13:24:41.218]         }
[13:24:41.218]     })
[13:24:41.218]     if (TRUE) {
[13:24:41.218]         base::sink(type = "output", split = FALSE)
[13:24:41.218]         if (TRUE) {
[13:24:41.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.218]         }
[13:24:41.218]         else {
[13:24:41.218]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.218]         }
[13:24:41.218]         base::close(...future.stdout)
[13:24:41.218]         ...future.stdout <- NULL
[13:24:41.218]     }
[13:24:41.218]     ...future.result$conditions <- ...future.conditions
[13:24:41.218]     ...future.result$finished <- base::Sys.time()
[13:24:41.218]     ...future.result
[13:24:41.218] }
[13:24:41.221] MultisessionFuture started
[13:24:41.221] - Launch lazy future ... done
[13:24:41.221] run() for ‘MultisessionFuture’ ... done
[13:24:41.269] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.269] - Validating connection of MultisessionFuture
[13:24:41.270] - received message: FutureResult
[13:24:41.270] - Received FutureResult
[13:24:41.270] - Erased future from FutureRegistry
[13:24:41.270] result() for ClusterFuture ...
[13:24:41.270] - result already collected: FutureResult
[13:24:41.270] result() for ClusterFuture ... done
[13:24:41.270] signalConditions() ...
[13:24:41.270]  - include = ‘immediateCondition’
[13:24:41.270]  - exclude = 
[13:24:41.270]  - resignal = FALSE
[13:24:41.271]  - Number of conditions: 1
[13:24:41.271] signalConditions() ... done
[13:24:41.271] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.271] A MultisessionFuture was resolved
[13:24:41.271] getGlobalsAndPackages() ...
[13:24:41.271] Searching for globals...
[13:24:41.272] - globals found: [2] ‘list’, ‘stop’
[13:24:41.272] Searching for globals ... DONE
[13:24:41.272] Resolving globals: FALSE
[13:24:41.272] 
[13:24:41.272] 
[13:24:41.272] getGlobalsAndPackages() ... DONE
[13:24:41.273] run() for ‘Future’ ...
[13:24:41.273] - state: ‘created’
[13:24:41.273] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.286] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.287]   - Field: ‘node’
[13:24:41.287]   - Field: ‘label’
[13:24:41.287]   - Field: ‘local’
[13:24:41.287]   - Field: ‘owner’
[13:24:41.287]   - Field: ‘envir’
[13:24:41.287]   - Field: ‘workers’
[13:24:41.287]   - Field: ‘packages’
[13:24:41.287]   - Field: ‘gc’
[13:24:41.288]   - Field: ‘conditions’
[13:24:41.288]   - Field: ‘persistent’
[13:24:41.288]   - Field: ‘expr’
[13:24:41.288]   - Field: ‘uuid’
[13:24:41.288]   - Field: ‘seed’
[13:24:41.288]   - Field: ‘version’
[13:24:41.288]   - Field: ‘result’
[13:24:41.288]   - Field: ‘asynchronous’
[13:24:41.288]   - Field: ‘calls’
[13:24:41.288]   - Field: ‘globals’
[13:24:41.289]   - Field: ‘stdout’
[13:24:41.289]   - Field: ‘earlySignal’
[13:24:41.289]   - Field: ‘lazy’
[13:24:41.289]   - Field: ‘state’
[13:24:41.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.289] - Launch lazy future ...
[13:24:41.289] Packages needed by the future expression (n = 0): <none>
[13:24:41.289] Packages needed by future strategies (n = 0): <none>
[13:24:41.290] {
[13:24:41.290]     {
[13:24:41.290]         {
[13:24:41.290]             ...future.startTime <- base::Sys.time()
[13:24:41.290]             {
[13:24:41.290]                 {
[13:24:41.290]                   {
[13:24:41.290]                     {
[13:24:41.290]                       base::local({
[13:24:41.290]                         has_future <- base::requireNamespace("future", 
[13:24:41.290]                           quietly = TRUE)
[13:24:41.290]                         if (has_future) {
[13:24:41.290]                           ns <- base::getNamespace("future")
[13:24:41.290]                           version <- ns[[".package"]][["version"]]
[13:24:41.290]                           if (is.null(version)) 
[13:24:41.290]                             version <- utils::packageVersion("future")
[13:24:41.290]                         }
[13:24:41.290]                         else {
[13:24:41.290]                           version <- NULL
[13:24:41.290]                         }
[13:24:41.290]                         if (!has_future || version < "1.8.0") {
[13:24:41.290]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.290]                             "", base::R.version$version.string), 
[13:24:41.290]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.290]                               "release", "version")], collapse = " "), 
[13:24:41.290]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.290]                             info)
[13:24:41.290]                           info <- base::paste(info, collapse = "; ")
[13:24:41.290]                           if (!has_future) {
[13:24:41.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.290]                               info)
[13:24:41.290]                           }
[13:24:41.290]                           else {
[13:24:41.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.290]                               info, version)
[13:24:41.290]                           }
[13:24:41.290]                           base::stop(msg)
[13:24:41.290]                         }
[13:24:41.290]                       })
[13:24:41.290]                     }
[13:24:41.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.290]                     base::options(mc.cores = 1L)
[13:24:41.290]                   }
[13:24:41.290]                   options(future.plan = NULL)
[13:24:41.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.290]                 }
[13:24:41.290]                 ...future.workdir <- getwd()
[13:24:41.290]             }
[13:24:41.290]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.290]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.290]         }
[13:24:41.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.290]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.290]             base::names(...future.oldOptions))
[13:24:41.290]     }
[13:24:41.290]     if (FALSE) {
[13:24:41.290]     }
[13:24:41.290]     else {
[13:24:41.290]         if (TRUE) {
[13:24:41.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.290]                 open = "w")
[13:24:41.290]         }
[13:24:41.290]         else {
[13:24:41.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.290]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.290]         }
[13:24:41.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.290]             base::sink(type = "output", split = FALSE)
[13:24:41.290]             base::close(...future.stdout)
[13:24:41.290]         }, add = TRUE)
[13:24:41.290]     }
[13:24:41.290]     ...future.frame <- base::sys.nframe()
[13:24:41.290]     ...future.conditions <- base::list()
[13:24:41.290]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.290]     if (FALSE) {
[13:24:41.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.290]     }
[13:24:41.290]     ...future.result <- base::tryCatch({
[13:24:41.290]         base::withCallingHandlers({
[13:24:41.290]             ...future.value <- base::withVisible(base::local({
[13:24:41.290]                 ...future.makeSendCondition <- base::local({
[13:24:41.290]                   sendCondition <- NULL
[13:24:41.290]                   function(frame = 1L) {
[13:24:41.290]                     if (is.function(sendCondition)) 
[13:24:41.290]                       return(sendCondition)
[13:24:41.290]                     ns <- getNamespace("parallel")
[13:24:41.290]                     if (exists("sendData", mode = "function", 
[13:24:41.290]                       envir = ns)) {
[13:24:41.290]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.290]                         envir = ns)
[13:24:41.290]                       envir <- sys.frame(frame)
[13:24:41.290]                       master <- NULL
[13:24:41.290]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.290]                         !identical(envir, emptyenv())) {
[13:24:41.290]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.290]                           inherits = FALSE)) {
[13:24:41.290]                           master <- get("master", mode = "list", 
[13:24:41.290]                             envir = envir, inherits = FALSE)
[13:24:41.290]                           if (inherits(master, c("SOCKnode", 
[13:24:41.290]                             "SOCK0node"))) {
[13:24:41.290]                             sendCondition <<- function(cond) {
[13:24:41.290]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.290]                                 success = TRUE)
[13:24:41.290]                               parallel_sendData(master, data)
[13:24:41.290]                             }
[13:24:41.290]                             return(sendCondition)
[13:24:41.290]                           }
[13:24:41.290]                         }
[13:24:41.290]                         frame <- frame + 1L
[13:24:41.290]                         envir <- sys.frame(frame)
[13:24:41.290]                       }
[13:24:41.290]                     }
[13:24:41.290]                     sendCondition <<- function(cond) NULL
[13:24:41.290]                   }
[13:24:41.290]                 })
[13:24:41.290]                 withCallingHandlers({
[13:24:41.290]                   list(a = 1, b = 42L, c = stop("Nah!"))
[13:24:41.290]                 }, immediateCondition = function(cond) {
[13:24:41.290]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.290]                   sendCondition(cond)
[13:24:41.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.290]                   {
[13:24:41.290]                     inherits <- base::inherits
[13:24:41.290]                     invokeRestart <- base::invokeRestart
[13:24:41.290]                     is.null <- base::is.null
[13:24:41.290]                     muffled <- FALSE
[13:24:41.290]                     if (inherits(cond, "message")) {
[13:24:41.290]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.290]                       if (muffled) 
[13:24:41.290]                         invokeRestart("muffleMessage")
[13:24:41.290]                     }
[13:24:41.290]                     else if (inherits(cond, "warning")) {
[13:24:41.290]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.290]                       if (muffled) 
[13:24:41.290]                         invokeRestart("muffleWarning")
[13:24:41.290]                     }
[13:24:41.290]                     else if (inherits(cond, "condition")) {
[13:24:41.290]                       if (!is.null(pattern)) {
[13:24:41.290]                         computeRestarts <- base::computeRestarts
[13:24:41.290]                         grepl <- base::grepl
[13:24:41.290]                         restarts <- computeRestarts(cond)
[13:24:41.290]                         for (restart in restarts) {
[13:24:41.290]                           name <- restart$name
[13:24:41.290]                           if (is.null(name)) 
[13:24:41.290]                             next
[13:24:41.290]                           if (!grepl(pattern, name)) 
[13:24:41.290]                             next
[13:24:41.290]                           invokeRestart(restart)
[13:24:41.290]                           muffled <- TRUE
[13:24:41.290]                           break
[13:24:41.290]                         }
[13:24:41.290]                       }
[13:24:41.290]                     }
[13:24:41.290]                     invisible(muffled)
[13:24:41.290]                   }
[13:24:41.290]                   muffleCondition(cond)
[13:24:41.290]                 })
[13:24:41.290]             }))
[13:24:41.290]             future::FutureResult(value = ...future.value$value, 
[13:24:41.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.290]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.290]                     ...future.globalenv.names))
[13:24:41.290]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.290]         }, condition = base::local({
[13:24:41.290]             c <- base::c
[13:24:41.290]             inherits <- base::inherits
[13:24:41.290]             invokeRestart <- base::invokeRestart
[13:24:41.290]             length <- base::length
[13:24:41.290]             list <- base::list
[13:24:41.290]             seq.int <- base::seq.int
[13:24:41.290]             signalCondition <- base::signalCondition
[13:24:41.290]             sys.calls <- base::sys.calls
[13:24:41.290]             `[[` <- base::`[[`
[13:24:41.290]             `+` <- base::`+`
[13:24:41.290]             `<<-` <- base::`<<-`
[13:24:41.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.290]                   3L)]
[13:24:41.290]             }
[13:24:41.290]             function(cond) {
[13:24:41.290]                 is_error <- inherits(cond, "error")
[13:24:41.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.290]                   NULL)
[13:24:41.290]                 if (is_error) {
[13:24:41.290]                   sessionInformation <- function() {
[13:24:41.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.290]                       search = base::search(), system = base::Sys.info())
[13:24:41.290]                   }
[13:24:41.290]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.290]                     cond$call), session = sessionInformation(), 
[13:24:41.290]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.290]                   signalCondition(cond)
[13:24:41.290]                 }
[13:24:41.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.290]                 "immediateCondition"))) {
[13:24:41.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.290]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.290]                   if (TRUE && !signal) {
[13:24:41.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.290]                     {
[13:24:41.290]                       inherits <- base::inherits
[13:24:41.290]                       invokeRestart <- base::invokeRestart
[13:24:41.290]                       is.null <- base::is.null
[13:24:41.290]                       muffled <- FALSE
[13:24:41.290]                       if (inherits(cond, "message")) {
[13:24:41.290]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.290]                         if (muffled) 
[13:24:41.290]                           invokeRestart("muffleMessage")
[13:24:41.290]                       }
[13:24:41.290]                       else if (inherits(cond, "warning")) {
[13:24:41.290]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.290]                         if (muffled) 
[13:24:41.290]                           invokeRestart("muffleWarning")
[13:24:41.290]                       }
[13:24:41.290]                       else if (inherits(cond, "condition")) {
[13:24:41.290]                         if (!is.null(pattern)) {
[13:24:41.290]                           computeRestarts <- base::computeRestarts
[13:24:41.290]                           grepl <- base::grepl
[13:24:41.290]                           restarts <- computeRestarts(cond)
[13:24:41.290]                           for (restart in restarts) {
[13:24:41.290]                             name <- restart$name
[13:24:41.290]                             if (is.null(name)) 
[13:24:41.290]                               next
[13:24:41.290]                             if (!grepl(pattern, name)) 
[13:24:41.290]                               next
[13:24:41.290]                             invokeRestart(restart)
[13:24:41.290]                             muffled <- TRUE
[13:24:41.290]                             break
[13:24:41.290]                           }
[13:24:41.290]                         }
[13:24:41.290]                       }
[13:24:41.290]                       invisible(muffled)
[13:24:41.290]                     }
[13:24:41.290]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.290]                   }
[13:24:41.290]                 }
[13:24:41.290]                 else {
[13:24:41.290]                   if (TRUE) {
[13:24:41.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.290]                     {
[13:24:41.290]                       inherits <- base::inherits
[13:24:41.290]                       invokeRestart <- base::invokeRestart
[13:24:41.290]                       is.null <- base::is.null
[13:24:41.290]                       muffled <- FALSE
[13:24:41.290]                       if (inherits(cond, "message")) {
[13:24:41.290]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.290]                         if (muffled) 
[13:24:41.290]                           invokeRestart("muffleMessage")
[13:24:41.290]                       }
[13:24:41.290]                       else if (inherits(cond, "warning")) {
[13:24:41.290]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.290]                         if (muffled) 
[13:24:41.290]                           invokeRestart("muffleWarning")
[13:24:41.290]                       }
[13:24:41.290]                       else if (inherits(cond, "condition")) {
[13:24:41.290]                         if (!is.null(pattern)) {
[13:24:41.290]                           computeRestarts <- base::computeRestarts
[13:24:41.290]                           grepl <- base::grepl
[13:24:41.290]                           restarts <- computeRestarts(cond)
[13:24:41.290]                           for (restart in restarts) {
[13:24:41.290]                             name <- restart$name
[13:24:41.290]                             if (is.null(name)) 
[13:24:41.290]                               next
[13:24:41.290]                             if (!grepl(pattern, name)) 
[13:24:41.290]                               next
[13:24:41.290]                             invokeRestart(restart)
[13:24:41.290]                             muffled <- TRUE
[13:24:41.290]                             break
[13:24:41.290]                           }
[13:24:41.290]                         }
[13:24:41.290]                       }
[13:24:41.290]                       invisible(muffled)
[13:24:41.290]                     }
[13:24:41.290]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.290]                   }
[13:24:41.290]                 }
[13:24:41.290]             }
[13:24:41.290]         }))
[13:24:41.290]     }, error = function(ex) {
[13:24:41.290]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.290]                 ...future.rng), started = ...future.startTime, 
[13:24:41.290]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.290]             version = "1.8"), class = "FutureResult")
[13:24:41.290]     }, finally = {
[13:24:41.290]         if (!identical(...future.workdir, getwd())) 
[13:24:41.290]             setwd(...future.workdir)
[13:24:41.290]         {
[13:24:41.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.290]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.290]             }
[13:24:41.290]             base::options(...future.oldOptions)
[13:24:41.290]             if (.Platform$OS.type == "windows") {
[13:24:41.290]                 old_names <- names(...future.oldEnvVars)
[13:24:41.290]                 envs <- base::Sys.getenv()
[13:24:41.290]                 names <- names(envs)
[13:24:41.290]                 common <- intersect(names, old_names)
[13:24:41.290]                 added <- setdiff(names, old_names)
[13:24:41.290]                 removed <- setdiff(old_names, names)
[13:24:41.290]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.290]                   envs[common]]
[13:24:41.290]                 NAMES <- toupper(changed)
[13:24:41.290]                 args <- list()
[13:24:41.290]                 for (kk in seq_along(NAMES)) {
[13:24:41.290]                   name <- changed[[kk]]
[13:24:41.290]                   NAME <- NAMES[[kk]]
[13:24:41.290]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.290]                     next
[13:24:41.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.290]                 }
[13:24:41.290]                 NAMES <- toupper(added)
[13:24:41.290]                 for (kk in seq_along(NAMES)) {
[13:24:41.290]                   name <- added[[kk]]
[13:24:41.290]                   NAME <- NAMES[[kk]]
[13:24:41.290]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.290]                     next
[13:24:41.290]                   args[[name]] <- ""
[13:24:41.290]                 }
[13:24:41.290]                 NAMES <- toupper(removed)
[13:24:41.290]                 for (kk in seq_along(NAMES)) {
[13:24:41.290]                   name <- removed[[kk]]
[13:24:41.290]                   NAME <- NAMES[[kk]]
[13:24:41.290]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.290]                     next
[13:24:41.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.290]                 }
[13:24:41.290]                 if (length(args) > 0) 
[13:24:41.290]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.290]             }
[13:24:41.290]             else {
[13:24:41.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.290]             }
[13:24:41.290]             {
[13:24:41.290]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.290]                   0L) {
[13:24:41.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.290]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.290]                   base::options(opts)
[13:24:41.290]                 }
[13:24:41.290]                 {
[13:24:41.290]                   {
[13:24:41.290]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.290]                     NULL
[13:24:41.290]                   }
[13:24:41.290]                   options(future.plan = NULL)
[13:24:41.290]                   if (is.na(NA_character_)) 
[13:24:41.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.290]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.290]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.290]                     envir = parent.frame()) 
[13:24:41.290]                   {
[13:24:41.290]                     if (is.function(workers)) 
[13:24:41.290]                       workers <- workers()
[13:24:41.290]                     workers <- structure(as.integer(workers), 
[13:24:41.290]                       class = class(workers))
[13:24:41.290]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.290]                       workers >= 1)
[13:24:41.290]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.290]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.290]                     }
[13:24:41.290]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.290]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.290]                       envir = envir)
[13:24:41.290]                     if (!future$lazy) 
[13:24:41.290]                       future <- run(future)
[13:24:41.290]                     invisible(future)
[13:24:41.290]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.290]                 }
[13:24:41.290]             }
[13:24:41.290]         }
[13:24:41.290]     })
[13:24:41.290]     if (TRUE) {
[13:24:41.290]         base::sink(type = "output", split = FALSE)
[13:24:41.290]         if (TRUE) {
[13:24:41.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.290]         }
[13:24:41.290]         else {
[13:24:41.290]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.290]         }
[13:24:41.290]         base::close(...future.stdout)
[13:24:41.290]         ...future.stdout <- NULL
[13:24:41.290]     }
[13:24:41.290]     ...future.result$conditions <- ...future.conditions
[13:24:41.290]     ...future.result$finished <- base::Sys.time()
[13:24:41.290]     ...future.result
[13:24:41.290] }
[13:24:41.293] MultisessionFuture started
[13:24:41.293] - Launch lazy future ... done
[13:24:41.293] run() for ‘MultisessionFuture’ ... done
[13:24:41.342] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.342] - Validating connection of MultisessionFuture
[13:24:41.342] - received message: FutureResult
[13:24:41.343] - Received FutureResult
[13:24:41.343] - Erased future from FutureRegistry
[13:24:41.343] result() for ClusterFuture ...
[13:24:41.343] - result already collected: FutureResult
[13:24:41.343] result() for ClusterFuture ... done
[13:24:41.343] signalConditions() ...
[13:24:41.343]  - include = ‘immediateCondition’
[13:24:41.343]  - exclude = 
[13:24:41.343]  - resignal = FALSE
[13:24:41.343]  - Number of conditions: 1
[13:24:41.343] signalConditions() ... done
[13:24:41.344] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.344] A MultisessionFuture was resolved
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[13:24:41.344] resolve() on list ...
[13:24:41.344]  recursive: 0
[13:24:41.344]  length: 2
[13:24:41.344]  elements: ‘a’, ‘b’
[13:24:41.344]  length: 1 (resolved future 1)
[13:24:41.345]  length: 0 (resolved future 2)
[13:24:41.345] resolve() on list ... DONE
[13:24:41.345] getGlobalsAndPackages() ...
[13:24:41.345] Searching for globals...
[13:24:41.345] 
[13:24:41.345] Searching for globals ... DONE
[13:24:41.345] - globals: [0] <none>
[13:24:41.345] getGlobalsAndPackages() ... DONE
[13:24:41.346] run() for ‘Future’ ...
[13:24:41.346] - state: ‘created’
[13:24:41.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.362] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.362] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.362]   - Field: ‘node’
[13:24:41.363]   - Field: ‘label’
[13:24:41.363]   - Field: ‘local’
[13:24:41.363]   - Field: ‘owner’
[13:24:41.363]   - Field: ‘envir’
[13:24:41.363]   - Field: ‘workers’
[13:24:41.363]   - Field: ‘packages’
[13:24:41.363]   - Field: ‘gc’
[13:24:41.363]   - Field: ‘conditions’
[13:24:41.363]   - Field: ‘persistent’
[13:24:41.363]   - Field: ‘expr’
[13:24:41.363]   - Field: ‘uuid’
[13:24:41.364]   - Field: ‘seed’
[13:24:41.364]   - Field: ‘version’
[13:24:41.364]   - Field: ‘result’
[13:24:41.364]   - Field: ‘asynchronous’
[13:24:41.364]   - Field: ‘calls’
[13:24:41.364]   - Field: ‘globals’
[13:24:41.364]   - Field: ‘stdout’
[13:24:41.364]   - Field: ‘earlySignal’
[13:24:41.364]   - Field: ‘lazy’
[13:24:41.364]   - Field: ‘state’
[13:24:41.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.365] - Launch lazy future ...
[13:24:41.365] Packages needed by the future expression (n = 0): <none>
[13:24:41.365] Packages needed by future strategies (n = 0): <none>
[13:24:41.366] {
[13:24:41.366]     {
[13:24:41.366]         {
[13:24:41.366]             ...future.startTime <- base::Sys.time()
[13:24:41.366]             {
[13:24:41.366]                 {
[13:24:41.366]                   {
[13:24:41.366]                     {
[13:24:41.366]                       base::local({
[13:24:41.366]                         has_future <- base::requireNamespace("future", 
[13:24:41.366]                           quietly = TRUE)
[13:24:41.366]                         if (has_future) {
[13:24:41.366]                           ns <- base::getNamespace("future")
[13:24:41.366]                           version <- ns[[".package"]][["version"]]
[13:24:41.366]                           if (is.null(version)) 
[13:24:41.366]                             version <- utils::packageVersion("future")
[13:24:41.366]                         }
[13:24:41.366]                         else {
[13:24:41.366]                           version <- NULL
[13:24:41.366]                         }
[13:24:41.366]                         if (!has_future || version < "1.8.0") {
[13:24:41.366]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.366]                             "", base::R.version$version.string), 
[13:24:41.366]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.366]                               "release", "version")], collapse = " "), 
[13:24:41.366]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.366]                             info)
[13:24:41.366]                           info <- base::paste(info, collapse = "; ")
[13:24:41.366]                           if (!has_future) {
[13:24:41.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.366]                               info)
[13:24:41.366]                           }
[13:24:41.366]                           else {
[13:24:41.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.366]                               info, version)
[13:24:41.366]                           }
[13:24:41.366]                           base::stop(msg)
[13:24:41.366]                         }
[13:24:41.366]                       })
[13:24:41.366]                     }
[13:24:41.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.366]                     base::options(mc.cores = 1L)
[13:24:41.366]                   }
[13:24:41.366]                   options(future.plan = NULL)
[13:24:41.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.366]                 }
[13:24:41.366]                 ...future.workdir <- getwd()
[13:24:41.366]             }
[13:24:41.366]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.366]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.366]         }
[13:24:41.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.366]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.366]             base::names(...future.oldOptions))
[13:24:41.366]     }
[13:24:41.366]     if (FALSE) {
[13:24:41.366]     }
[13:24:41.366]     else {
[13:24:41.366]         if (TRUE) {
[13:24:41.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.366]                 open = "w")
[13:24:41.366]         }
[13:24:41.366]         else {
[13:24:41.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.366]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.366]         }
[13:24:41.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.366]             base::sink(type = "output", split = FALSE)
[13:24:41.366]             base::close(...future.stdout)
[13:24:41.366]         }, add = TRUE)
[13:24:41.366]     }
[13:24:41.366]     ...future.frame <- base::sys.nframe()
[13:24:41.366]     ...future.conditions <- base::list()
[13:24:41.366]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.366]     if (FALSE) {
[13:24:41.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.366]     }
[13:24:41.366]     ...future.result <- base::tryCatch({
[13:24:41.366]         base::withCallingHandlers({
[13:24:41.366]             ...future.value <- base::withVisible(base::local({
[13:24:41.366]                 ...future.makeSendCondition <- base::local({
[13:24:41.366]                   sendCondition <- NULL
[13:24:41.366]                   function(frame = 1L) {
[13:24:41.366]                     if (is.function(sendCondition)) 
[13:24:41.366]                       return(sendCondition)
[13:24:41.366]                     ns <- getNamespace("parallel")
[13:24:41.366]                     if (exists("sendData", mode = "function", 
[13:24:41.366]                       envir = ns)) {
[13:24:41.366]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.366]                         envir = ns)
[13:24:41.366]                       envir <- sys.frame(frame)
[13:24:41.366]                       master <- NULL
[13:24:41.366]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.366]                         !identical(envir, emptyenv())) {
[13:24:41.366]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.366]                           inherits = FALSE)) {
[13:24:41.366]                           master <- get("master", mode = "list", 
[13:24:41.366]                             envir = envir, inherits = FALSE)
[13:24:41.366]                           if (inherits(master, c("SOCKnode", 
[13:24:41.366]                             "SOCK0node"))) {
[13:24:41.366]                             sendCondition <<- function(cond) {
[13:24:41.366]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.366]                                 success = TRUE)
[13:24:41.366]                               parallel_sendData(master, data)
[13:24:41.366]                             }
[13:24:41.366]                             return(sendCondition)
[13:24:41.366]                           }
[13:24:41.366]                         }
[13:24:41.366]                         frame <- frame + 1L
[13:24:41.366]                         envir <- sys.frame(frame)
[13:24:41.366]                       }
[13:24:41.366]                     }
[13:24:41.366]                     sendCondition <<- function(cond) NULL
[13:24:41.366]                   }
[13:24:41.366]                 })
[13:24:41.366]                 withCallingHandlers({
[13:24:41.366]                   1
[13:24:41.366]                 }, immediateCondition = function(cond) {
[13:24:41.366]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.366]                   sendCondition(cond)
[13:24:41.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.366]                   {
[13:24:41.366]                     inherits <- base::inherits
[13:24:41.366]                     invokeRestart <- base::invokeRestart
[13:24:41.366]                     is.null <- base::is.null
[13:24:41.366]                     muffled <- FALSE
[13:24:41.366]                     if (inherits(cond, "message")) {
[13:24:41.366]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.366]                       if (muffled) 
[13:24:41.366]                         invokeRestart("muffleMessage")
[13:24:41.366]                     }
[13:24:41.366]                     else if (inherits(cond, "warning")) {
[13:24:41.366]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.366]                       if (muffled) 
[13:24:41.366]                         invokeRestart("muffleWarning")
[13:24:41.366]                     }
[13:24:41.366]                     else if (inherits(cond, "condition")) {
[13:24:41.366]                       if (!is.null(pattern)) {
[13:24:41.366]                         computeRestarts <- base::computeRestarts
[13:24:41.366]                         grepl <- base::grepl
[13:24:41.366]                         restarts <- computeRestarts(cond)
[13:24:41.366]                         for (restart in restarts) {
[13:24:41.366]                           name <- restart$name
[13:24:41.366]                           if (is.null(name)) 
[13:24:41.366]                             next
[13:24:41.366]                           if (!grepl(pattern, name)) 
[13:24:41.366]                             next
[13:24:41.366]                           invokeRestart(restart)
[13:24:41.366]                           muffled <- TRUE
[13:24:41.366]                           break
[13:24:41.366]                         }
[13:24:41.366]                       }
[13:24:41.366]                     }
[13:24:41.366]                     invisible(muffled)
[13:24:41.366]                   }
[13:24:41.366]                   muffleCondition(cond)
[13:24:41.366]                 })
[13:24:41.366]             }))
[13:24:41.366]             future::FutureResult(value = ...future.value$value, 
[13:24:41.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.366]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.366]                     ...future.globalenv.names))
[13:24:41.366]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.366]         }, condition = base::local({
[13:24:41.366]             c <- base::c
[13:24:41.366]             inherits <- base::inherits
[13:24:41.366]             invokeRestart <- base::invokeRestart
[13:24:41.366]             length <- base::length
[13:24:41.366]             list <- base::list
[13:24:41.366]             seq.int <- base::seq.int
[13:24:41.366]             signalCondition <- base::signalCondition
[13:24:41.366]             sys.calls <- base::sys.calls
[13:24:41.366]             `[[` <- base::`[[`
[13:24:41.366]             `+` <- base::`+`
[13:24:41.366]             `<<-` <- base::`<<-`
[13:24:41.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.366]                   3L)]
[13:24:41.366]             }
[13:24:41.366]             function(cond) {
[13:24:41.366]                 is_error <- inherits(cond, "error")
[13:24:41.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.366]                   NULL)
[13:24:41.366]                 if (is_error) {
[13:24:41.366]                   sessionInformation <- function() {
[13:24:41.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.366]                       search = base::search(), system = base::Sys.info())
[13:24:41.366]                   }
[13:24:41.366]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.366]                     cond$call), session = sessionInformation(), 
[13:24:41.366]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.366]                   signalCondition(cond)
[13:24:41.366]                 }
[13:24:41.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.366]                 "immediateCondition"))) {
[13:24:41.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.366]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.366]                   if (TRUE && !signal) {
[13:24:41.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.366]                     {
[13:24:41.366]                       inherits <- base::inherits
[13:24:41.366]                       invokeRestart <- base::invokeRestart
[13:24:41.366]                       is.null <- base::is.null
[13:24:41.366]                       muffled <- FALSE
[13:24:41.366]                       if (inherits(cond, "message")) {
[13:24:41.366]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.366]                         if (muffled) 
[13:24:41.366]                           invokeRestart("muffleMessage")
[13:24:41.366]                       }
[13:24:41.366]                       else if (inherits(cond, "warning")) {
[13:24:41.366]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.366]                         if (muffled) 
[13:24:41.366]                           invokeRestart("muffleWarning")
[13:24:41.366]                       }
[13:24:41.366]                       else if (inherits(cond, "condition")) {
[13:24:41.366]                         if (!is.null(pattern)) {
[13:24:41.366]                           computeRestarts <- base::computeRestarts
[13:24:41.366]                           grepl <- base::grepl
[13:24:41.366]                           restarts <- computeRestarts(cond)
[13:24:41.366]                           for (restart in restarts) {
[13:24:41.366]                             name <- restart$name
[13:24:41.366]                             if (is.null(name)) 
[13:24:41.366]                               next
[13:24:41.366]                             if (!grepl(pattern, name)) 
[13:24:41.366]                               next
[13:24:41.366]                             invokeRestart(restart)
[13:24:41.366]                             muffled <- TRUE
[13:24:41.366]                             break
[13:24:41.366]                           }
[13:24:41.366]                         }
[13:24:41.366]                       }
[13:24:41.366]                       invisible(muffled)
[13:24:41.366]                     }
[13:24:41.366]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.366]                   }
[13:24:41.366]                 }
[13:24:41.366]                 else {
[13:24:41.366]                   if (TRUE) {
[13:24:41.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.366]                     {
[13:24:41.366]                       inherits <- base::inherits
[13:24:41.366]                       invokeRestart <- base::invokeRestart
[13:24:41.366]                       is.null <- base::is.null
[13:24:41.366]                       muffled <- FALSE
[13:24:41.366]                       if (inherits(cond, "message")) {
[13:24:41.366]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.366]                         if (muffled) 
[13:24:41.366]                           invokeRestart("muffleMessage")
[13:24:41.366]                       }
[13:24:41.366]                       else if (inherits(cond, "warning")) {
[13:24:41.366]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.366]                         if (muffled) 
[13:24:41.366]                           invokeRestart("muffleWarning")
[13:24:41.366]                       }
[13:24:41.366]                       else if (inherits(cond, "condition")) {
[13:24:41.366]                         if (!is.null(pattern)) {
[13:24:41.366]                           computeRestarts <- base::computeRestarts
[13:24:41.366]                           grepl <- base::grepl
[13:24:41.366]                           restarts <- computeRestarts(cond)
[13:24:41.366]                           for (restart in restarts) {
[13:24:41.366]                             name <- restart$name
[13:24:41.366]                             if (is.null(name)) 
[13:24:41.366]                               next
[13:24:41.366]                             if (!grepl(pattern, name)) 
[13:24:41.366]                               next
[13:24:41.366]                             invokeRestart(restart)
[13:24:41.366]                             muffled <- TRUE
[13:24:41.366]                             break
[13:24:41.366]                           }
[13:24:41.366]                         }
[13:24:41.366]                       }
[13:24:41.366]                       invisible(muffled)
[13:24:41.366]                     }
[13:24:41.366]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.366]                   }
[13:24:41.366]                 }
[13:24:41.366]             }
[13:24:41.366]         }))
[13:24:41.366]     }, error = function(ex) {
[13:24:41.366]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.366]                 ...future.rng), started = ...future.startTime, 
[13:24:41.366]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.366]             version = "1.8"), class = "FutureResult")
[13:24:41.366]     }, finally = {
[13:24:41.366]         if (!identical(...future.workdir, getwd())) 
[13:24:41.366]             setwd(...future.workdir)
[13:24:41.366]         {
[13:24:41.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.366]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.366]             }
[13:24:41.366]             base::options(...future.oldOptions)
[13:24:41.366]             if (.Platform$OS.type == "windows") {
[13:24:41.366]                 old_names <- names(...future.oldEnvVars)
[13:24:41.366]                 envs <- base::Sys.getenv()
[13:24:41.366]                 names <- names(envs)
[13:24:41.366]                 common <- intersect(names, old_names)
[13:24:41.366]                 added <- setdiff(names, old_names)
[13:24:41.366]                 removed <- setdiff(old_names, names)
[13:24:41.366]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.366]                   envs[common]]
[13:24:41.366]                 NAMES <- toupper(changed)
[13:24:41.366]                 args <- list()
[13:24:41.366]                 for (kk in seq_along(NAMES)) {
[13:24:41.366]                   name <- changed[[kk]]
[13:24:41.366]                   NAME <- NAMES[[kk]]
[13:24:41.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.366]                     next
[13:24:41.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.366]                 }
[13:24:41.366]                 NAMES <- toupper(added)
[13:24:41.366]                 for (kk in seq_along(NAMES)) {
[13:24:41.366]                   name <- added[[kk]]
[13:24:41.366]                   NAME <- NAMES[[kk]]
[13:24:41.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.366]                     next
[13:24:41.366]                   args[[name]] <- ""
[13:24:41.366]                 }
[13:24:41.366]                 NAMES <- toupper(removed)
[13:24:41.366]                 for (kk in seq_along(NAMES)) {
[13:24:41.366]                   name <- removed[[kk]]
[13:24:41.366]                   NAME <- NAMES[[kk]]
[13:24:41.366]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.366]                     next
[13:24:41.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.366]                 }
[13:24:41.366]                 if (length(args) > 0) 
[13:24:41.366]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.366]             }
[13:24:41.366]             else {
[13:24:41.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.366]             }
[13:24:41.366]             {
[13:24:41.366]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.366]                   0L) {
[13:24:41.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.366]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.366]                   base::options(opts)
[13:24:41.366]                 }
[13:24:41.366]                 {
[13:24:41.366]                   {
[13:24:41.366]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.366]                     NULL
[13:24:41.366]                   }
[13:24:41.366]                   options(future.plan = NULL)
[13:24:41.366]                   if (is.na(NA_character_)) 
[13:24:41.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.366]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.366]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.366]                     envir = parent.frame()) 
[13:24:41.366]                   {
[13:24:41.366]                     if (is.function(workers)) 
[13:24:41.366]                       workers <- workers()
[13:24:41.366]                     workers <- structure(as.integer(workers), 
[13:24:41.366]                       class = class(workers))
[13:24:41.366]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.366]                       workers >= 1)
[13:24:41.366]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.366]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.366]                     }
[13:24:41.366]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.366]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.366]                       envir = envir)
[13:24:41.366]                     if (!future$lazy) 
[13:24:41.366]                       future <- run(future)
[13:24:41.366]                     invisible(future)
[13:24:41.366]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.366]                 }
[13:24:41.366]             }
[13:24:41.366]         }
[13:24:41.366]     })
[13:24:41.366]     if (TRUE) {
[13:24:41.366]         base::sink(type = "output", split = FALSE)
[13:24:41.366]         if (TRUE) {
[13:24:41.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.366]         }
[13:24:41.366]         else {
[13:24:41.366]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.366]         }
[13:24:41.366]         base::close(...future.stdout)
[13:24:41.366]         ...future.stdout <- NULL
[13:24:41.366]     }
[13:24:41.366]     ...future.result$conditions <- ...future.conditions
[13:24:41.366]     ...future.result$finished <- base::Sys.time()
[13:24:41.366]     ...future.result
[13:24:41.366] }
[13:24:41.369] MultisessionFuture started
[13:24:41.369] - Launch lazy future ... done
[13:24:41.369] run() for ‘MultisessionFuture’ ... done
[13:24:41.369] getGlobalsAndPackages() ...
[13:24:41.369] Searching for globals...
[13:24:41.370] 
[13:24:41.370] Searching for globals ... DONE
[13:24:41.370] - globals: [0] <none>
[13:24:41.370] getGlobalsAndPackages() ... DONE
[13:24:41.370] run() for ‘Future’ ...
[13:24:41.370] - state: ‘created’
[13:24:41.371] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.384] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.385]   - Field: ‘node’
[13:24:41.385]   - Field: ‘label’
[13:24:41.385]   - Field: ‘local’
[13:24:41.385]   - Field: ‘owner’
[13:24:41.385]   - Field: ‘envir’
[13:24:41.385]   - Field: ‘workers’
[13:24:41.385]   - Field: ‘packages’
[13:24:41.385]   - Field: ‘gc’
[13:24:41.386]   - Field: ‘conditions’
[13:24:41.386]   - Field: ‘persistent’
[13:24:41.386]   - Field: ‘expr’
[13:24:41.386]   - Field: ‘uuid’
[13:24:41.386]   - Field: ‘seed’
[13:24:41.386]   - Field: ‘version’
[13:24:41.386]   - Field: ‘result’
[13:24:41.386]   - Field: ‘asynchronous’
[13:24:41.386]   - Field: ‘calls’
[13:24:41.386]   - Field: ‘globals’
[13:24:41.386]   - Field: ‘stdout’
[13:24:41.387]   - Field: ‘earlySignal’
[13:24:41.387]   - Field: ‘lazy’
[13:24:41.387]   - Field: ‘state’
[13:24:41.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.387] - Launch lazy future ...
[13:24:41.387] Packages needed by the future expression (n = 0): <none>
[13:24:41.387] Packages needed by future strategies (n = 0): <none>
[13:24:41.388] {
[13:24:41.388]     {
[13:24:41.388]         {
[13:24:41.388]             ...future.startTime <- base::Sys.time()
[13:24:41.388]             {
[13:24:41.388]                 {
[13:24:41.388]                   {
[13:24:41.388]                     {
[13:24:41.388]                       base::local({
[13:24:41.388]                         has_future <- base::requireNamespace("future", 
[13:24:41.388]                           quietly = TRUE)
[13:24:41.388]                         if (has_future) {
[13:24:41.388]                           ns <- base::getNamespace("future")
[13:24:41.388]                           version <- ns[[".package"]][["version"]]
[13:24:41.388]                           if (is.null(version)) 
[13:24:41.388]                             version <- utils::packageVersion("future")
[13:24:41.388]                         }
[13:24:41.388]                         else {
[13:24:41.388]                           version <- NULL
[13:24:41.388]                         }
[13:24:41.388]                         if (!has_future || version < "1.8.0") {
[13:24:41.388]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.388]                             "", base::R.version$version.string), 
[13:24:41.388]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.388]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.388]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.388]                               "release", "version")], collapse = " "), 
[13:24:41.388]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.388]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.388]                             info)
[13:24:41.388]                           info <- base::paste(info, collapse = "; ")
[13:24:41.388]                           if (!has_future) {
[13:24:41.388]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.388]                               info)
[13:24:41.388]                           }
[13:24:41.388]                           else {
[13:24:41.388]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.388]                               info, version)
[13:24:41.388]                           }
[13:24:41.388]                           base::stop(msg)
[13:24:41.388]                         }
[13:24:41.388]                       })
[13:24:41.388]                     }
[13:24:41.388]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.388]                     base::options(mc.cores = 1L)
[13:24:41.388]                   }
[13:24:41.388]                   options(future.plan = NULL)
[13:24:41.388]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.388]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.388]                 }
[13:24:41.388]                 ...future.workdir <- getwd()
[13:24:41.388]             }
[13:24:41.388]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.388]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.388]         }
[13:24:41.388]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.388]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.388]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.388]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.388]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.388]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.388]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.388]             base::names(...future.oldOptions))
[13:24:41.388]     }
[13:24:41.388]     if (FALSE) {
[13:24:41.388]     }
[13:24:41.388]     else {
[13:24:41.388]         if (TRUE) {
[13:24:41.388]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.388]                 open = "w")
[13:24:41.388]         }
[13:24:41.388]         else {
[13:24:41.388]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.388]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.388]         }
[13:24:41.388]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.388]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.388]             base::sink(type = "output", split = FALSE)
[13:24:41.388]             base::close(...future.stdout)
[13:24:41.388]         }, add = TRUE)
[13:24:41.388]     }
[13:24:41.388]     ...future.frame <- base::sys.nframe()
[13:24:41.388]     ...future.conditions <- base::list()
[13:24:41.388]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.388]     if (FALSE) {
[13:24:41.388]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.388]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.388]     }
[13:24:41.388]     ...future.result <- base::tryCatch({
[13:24:41.388]         base::withCallingHandlers({
[13:24:41.388]             ...future.value <- base::withVisible(base::local({
[13:24:41.388]                 ...future.makeSendCondition <- base::local({
[13:24:41.388]                   sendCondition <- NULL
[13:24:41.388]                   function(frame = 1L) {
[13:24:41.388]                     if (is.function(sendCondition)) 
[13:24:41.388]                       return(sendCondition)
[13:24:41.388]                     ns <- getNamespace("parallel")
[13:24:41.388]                     if (exists("sendData", mode = "function", 
[13:24:41.388]                       envir = ns)) {
[13:24:41.388]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.388]                         envir = ns)
[13:24:41.388]                       envir <- sys.frame(frame)
[13:24:41.388]                       master <- NULL
[13:24:41.388]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.388]                         !identical(envir, emptyenv())) {
[13:24:41.388]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.388]                           inherits = FALSE)) {
[13:24:41.388]                           master <- get("master", mode = "list", 
[13:24:41.388]                             envir = envir, inherits = FALSE)
[13:24:41.388]                           if (inherits(master, c("SOCKnode", 
[13:24:41.388]                             "SOCK0node"))) {
[13:24:41.388]                             sendCondition <<- function(cond) {
[13:24:41.388]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.388]                                 success = TRUE)
[13:24:41.388]                               parallel_sendData(master, data)
[13:24:41.388]                             }
[13:24:41.388]                             return(sendCondition)
[13:24:41.388]                           }
[13:24:41.388]                         }
[13:24:41.388]                         frame <- frame + 1L
[13:24:41.388]                         envir <- sys.frame(frame)
[13:24:41.388]                       }
[13:24:41.388]                     }
[13:24:41.388]                     sendCondition <<- function(cond) NULL
[13:24:41.388]                   }
[13:24:41.388]                 })
[13:24:41.388]                 withCallingHandlers({
[13:24:41.388]                   2
[13:24:41.388]                 }, immediateCondition = function(cond) {
[13:24:41.388]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.388]                   sendCondition(cond)
[13:24:41.388]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.388]                   {
[13:24:41.388]                     inherits <- base::inherits
[13:24:41.388]                     invokeRestart <- base::invokeRestart
[13:24:41.388]                     is.null <- base::is.null
[13:24:41.388]                     muffled <- FALSE
[13:24:41.388]                     if (inherits(cond, "message")) {
[13:24:41.388]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.388]                       if (muffled) 
[13:24:41.388]                         invokeRestart("muffleMessage")
[13:24:41.388]                     }
[13:24:41.388]                     else if (inherits(cond, "warning")) {
[13:24:41.388]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.388]                       if (muffled) 
[13:24:41.388]                         invokeRestart("muffleWarning")
[13:24:41.388]                     }
[13:24:41.388]                     else if (inherits(cond, "condition")) {
[13:24:41.388]                       if (!is.null(pattern)) {
[13:24:41.388]                         computeRestarts <- base::computeRestarts
[13:24:41.388]                         grepl <- base::grepl
[13:24:41.388]                         restarts <- computeRestarts(cond)
[13:24:41.388]                         for (restart in restarts) {
[13:24:41.388]                           name <- restart$name
[13:24:41.388]                           if (is.null(name)) 
[13:24:41.388]                             next
[13:24:41.388]                           if (!grepl(pattern, name)) 
[13:24:41.388]                             next
[13:24:41.388]                           invokeRestart(restart)
[13:24:41.388]                           muffled <- TRUE
[13:24:41.388]                           break
[13:24:41.388]                         }
[13:24:41.388]                       }
[13:24:41.388]                     }
[13:24:41.388]                     invisible(muffled)
[13:24:41.388]                   }
[13:24:41.388]                   muffleCondition(cond)
[13:24:41.388]                 })
[13:24:41.388]             }))
[13:24:41.388]             future::FutureResult(value = ...future.value$value, 
[13:24:41.388]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.388]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.388]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.388]                     ...future.globalenv.names))
[13:24:41.388]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.388]         }, condition = base::local({
[13:24:41.388]             c <- base::c
[13:24:41.388]             inherits <- base::inherits
[13:24:41.388]             invokeRestart <- base::invokeRestart
[13:24:41.388]             length <- base::length
[13:24:41.388]             list <- base::list
[13:24:41.388]             seq.int <- base::seq.int
[13:24:41.388]             signalCondition <- base::signalCondition
[13:24:41.388]             sys.calls <- base::sys.calls
[13:24:41.388]             `[[` <- base::`[[`
[13:24:41.388]             `+` <- base::`+`
[13:24:41.388]             `<<-` <- base::`<<-`
[13:24:41.388]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.388]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.388]                   3L)]
[13:24:41.388]             }
[13:24:41.388]             function(cond) {
[13:24:41.388]                 is_error <- inherits(cond, "error")
[13:24:41.388]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.388]                   NULL)
[13:24:41.388]                 if (is_error) {
[13:24:41.388]                   sessionInformation <- function() {
[13:24:41.388]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.388]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.388]                       search = base::search(), system = base::Sys.info())
[13:24:41.388]                   }
[13:24:41.388]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.388]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.388]                     cond$call), session = sessionInformation(), 
[13:24:41.388]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.388]                   signalCondition(cond)
[13:24:41.388]                 }
[13:24:41.388]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.388]                 "immediateCondition"))) {
[13:24:41.388]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.388]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.388]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.388]                   if (TRUE && !signal) {
[13:24:41.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.388]                     {
[13:24:41.388]                       inherits <- base::inherits
[13:24:41.388]                       invokeRestart <- base::invokeRestart
[13:24:41.388]                       is.null <- base::is.null
[13:24:41.388]                       muffled <- FALSE
[13:24:41.388]                       if (inherits(cond, "message")) {
[13:24:41.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.388]                         if (muffled) 
[13:24:41.388]                           invokeRestart("muffleMessage")
[13:24:41.388]                       }
[13:24:41.388]                       else if (inherits(cond, "warning")) {
[13:24:41.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.388]                         if (muffled) 
[13:24:41.388]                           invokeRestart("muffleWarning")
[13:24:41.388]                       }
[13:24:41.388]                       else if (inherits(cond, "condition")) {
[13:24:41.388]                         if (!is.null(pattern)) {
[13:24:41.388]                           computeRestarts <- base::computeRestarts
[13:24:41.388]                           grepl <- base::grepl
[13:24:41.388]                           restarts <- computeRestarts(cond)
[13:24:41.388]                           for (restart in restarts) {
[13:24:41.388]                             name <- restart$name
[13:24:41.388]                             if (is.null(name)) 
[13:24:41.388]                               next
[13:24:41.388]                             if (!grepl(pattern, name)) 
[13:24:41.388]                               next
[13:24:41.388]                             invokeRestart(restart)
[13:24:41.388]                             muffled <- TRUE
[13:24:41.388]                             break
[13:24:41.388]                           }
[13:24:41.388]                         }
[13:24:41.388]                       }
[13:24:41.388]                       invisible(muffled)
[13:24:41.388]                     }
[13:24:41.388]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.388]                   }
[13:24:41.388]                 }
[13:24:41.388]                 else {
[13:24:41.388]                   if (TRUE) {
[13:24:41.388]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.388]                     {
[13:24:41.388]                       inherits <- base::inherits
[13:24:41.388]                       invokeRestart <- base::invokeRestart
[13:24:41.388]                       is.null <- base::is.null
[13:24:41.388]                       muffled <- FALSE
[13:24:41.388]                       if (inherits(cond, "message")) {
[13:24:41.388]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.388]                         if (muffled) 
[13:24:41.388]                           invokeRestart("muffleMessage")
[13:24:41.388]                       }
[13:24:41.388]                       else if (inherits(cond, "warning")) {
[13:24:41.388]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.388]                         if (muffled) 
[13:24:41.388]                           invokeRestart("muffleWarning")
[13:24:41.388]                       }
[13:24:41.388]                       else if (inherits(cond, "condition")) {
[13:24:41.388]                         if (!is.null(pattern)) {
[13:24:41.388]                           computeRestarts <- base::computeRestarts
[13:24:41.388]                           grepl <- base::grepl
[13:24:41.388]                           restarts <- computeRestarts(cond)
[13:24:41.388]                           for (restart in restarts) {
[13:24:41.388]                             name <- restart$name
[13:24:41.388]                             if (is.null(name)) 
[13:24:41.388]                               next
[13:24:41.388]                             if (!grepl(pattern, name)) 
[13:24:41.388]                               next
[13:24:41.388]                             invokeRestart(restart)
[13:24:41.388]                             muffled <- TRUE
[13:24:41.388]                             break
[13:24:41.388]                           }
[13:24:41.388]                         }
[13:24:41.388]                       }
[13:24:41.388]                       invisible(muffled)
[13:24:41.388]                     }
[13:24:41.388]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.388]                   }
[13:24:41.388]                 }
[13:24:41.388]             }
[13:24:41.388]         }))
[13:24:41.388]     }, error = function(ex) {
[13:24:41.388]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.388]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.388]                 ...future.rng), started = ...future.startTime, 
[13:24:41.388]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.388]             version = "1.8"), class = "FutureResult")
[13:24:41.388]     }, finally = {
[13:24:41.388]         if (!identical(...future.workdir, getwd())) 
[13:24:41.388]             setwd(...future.workdir)
[13:24:41.388]         {
[13:24:41.388]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.388]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.388]             }
[13:24:41.388]             base::options(...future.oldOptions)
[13:24:41.388]             if (.Platform$OS.type == "windows") {
[13:24:41.388]                 old_names <- names(...future.oldEnvVars)
[13:24:41.388]                 envs <- base::Sys.getenv()
[13:24:41.388]                 names <- names(envs)
[13:24:41.388]                 common <- intersect(names, old_names)
[13:24:41.388]                 added <- setdiff(names, old_names)
[13:24:41.388]                 removed <- setdiff(old_names, names)
[13:24:41.388]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.388]                   envs[common]]
[13:24:41.388]                 NAMES <- toupper(changed)
[13:24:41.388]                 args <- list()
[13:24:41.388]                 for (kk in seq_along(NAMES)) {
[13:24:41.388]                   name <- changed[[kk]]
[13:24:41.388]                   NAME <- NAMES[[kk]]
[13:24:41.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.388]                     next
[13:24:41.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.388]                 }
[13:24:41.388]                 NAMES <- toupper(added)
[13:24:41.388]                 for (kk in seq_along(NAMES)) {
[13:24:41.388]                   name <- added[[kk]]
[13:24:41.388]                   NAME <- NAMES[[kk]]
[13:24:41.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.388]                     next
[13:24:41.388]                   args[[name]] <- ""
[13:24:41.388]                 }
[13:24:41.388]                 NAMES <- toupper(removed)
[13:24:41.388]                 for (kk in seq_along(NAMES)) {
[13:24:41.388]                   name <- removed[[kk]]
[13:24:41.388]                   NAME <- NAMES[[kk]]
[13:24:41.388]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.388]                     next
[13:24:41.388]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.388]                 }
[13:24:41.388]                 if (length(args) > 0) 
[13:24:41.388]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.388]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.388]             }
[13:24:41.388]             else {
[13:24:41.388]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.388]             }
[13:24:41.388]             {
[13:24:41.388]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.388]                   0L) {
[13:24:41.388]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.388]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.388]                   base::options(opts)
[13:24:41.388]                 }
[13:24:41.388]                 {
[13:24:41.388]                   {
[13:24:41.388]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.388]                     NULL
[13:24:41.388]                   }
[13:24:41.388]                   options(future.plan = NULL)
[13:24:41.388]                   if (is.na(NA_character_)) 
[13:24:41.388]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.388]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.388]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.388]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.388]                     envir = parent.frame()) 
[13:24:41.388]                   {
[13:24:41.388]                     if (is.function(workers)) 
[13:24:41.388]                       workers <- workers()
[13:24:41.388]                     workers <- structure(as.integer(workers), 
[13:24:41.388]                       class = class(workers))
[13:24:41.388]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.388]                       workers >= 1)
[13:24:41.388]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.388]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.388]                     }
[13:24:41.388]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.388]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.388]                       envir = envir)
[13:24:41.388]                     if (!future$lazy) 
[13:24:41.388]                       future <- run(future)
[13:24:41.388]                     invisible(future)
[13:24:41.388]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.388]                 }
[13:24:41.388]             }
[13:24:41.388]         }
[13:24:41.388]     })
[13:24:41.388]     if (TRUE) {
[13:24:41.388]         base::sink(type = "output", split = FALSE)
[13:24:41.388]         if (TRUE) {
[13:24:41.388]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.388]         }
[13:24:41.388]         else {
[13:24:41.388]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.388]         }
[13:24:41.388]         base::close(...future.stdout)
[13:24:41.388]         ...future.stdout <- NULL
[13:24:41.388]     }
[13:24:41.388]     ...future.result$conditions <- ...future.conditions
[13:24:41.388]     ...future.result$finished <- base::Sys.time()
[13:24:41.388]     ...future.result
[13:24:41.388] }
[13:24:41.390] Poll #1 (0): usedNodes() = 2, workers = 2
[13:24:41.401] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.401] - Validating connection of MultisessionFuture
[13:24:41.401] - received message: FutureResult
[13:24:41.401] - Received FutureResult
[13:24:41.402] - Erased future from FutureRegistry
[13:24:41.402] result() for ClusterFuture ...
[13:24:41.402] - result already collected: FutureResult
[13:24:41.402] result() for ClusterFuture ... done
[13:24:41.402] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.402] result() for ClusterFuture ...
[13:24:41.402] - result already collected: FutureResult
[13:24:41.402] result() for ClusterFuture ... done
[13:24:41.402] result() for ClusterFuture ...
[13:24:41.402] - result already collected: FutureResult
[13:24:41.403] result() for ClusterFuture ... done
[13:24:41.404] MultisessionFuture started
[13:24:41.404] - Launch lazy future ... done
[13:24:41.404] run() for ‘MultisessionFuture’ ... done
[13:24:41.404] resolve() on list ...
[13:24:41.404]  recursive: 0
[13:24:41.404]  length: 3
[13:24:41.404]  elements: ‘a’, ‘b’, ‘’
[13:24:41.426]  length: 2 (resolved future 3)
[13:24:41.436] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.436] - Validating connection of MultisessionFuture
[13:24:41.437] - received message: FutureResult
[13:24:41.437] - Received FutureResult
[13:24:41.437] - Erased future from FutureRegistry
[13:24:41.437] result() for ClusterFuture ...
[13:24:41.437] - result already collected: FutureResult
[13:24:41.437] result() for ClusterFuture ... done
[13:24:41.437] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.437] Future #1
[13:24:41.437]  length: 1 (resolved future 1)
[13:24:41.458] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.459] - Validating connection of MultisessionFuture
[13:24:41.459] - received message: FutureResult
[13:24:41.459] - Received FutureResult
[13:24:41.459] - Erased future from FutureRegistry
[13:24:41.459] result() for ClusterFuture ...
[13:24:41.459] - result already collected: FutureResult
[13:24:41.459] result() for ClusterFuture ... done
[13:24:41.459] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.460] Future #2
[13:24:41.460]  length: 0 (resolved future 2)
[13:24:41.460] resolve() on list ... DONE
[13:24:41.460] getGlobalsAndPackages() ...
[13:24:41.460] Searching for globals...
[13:24:41.460] 
[13:24:41.460] Searching for globals ... DONE
[13:24:41.461] - globals: [0] <none>
[13:24:41.461] getGlobalsAndPackages() ... DONE
[13:24:41.461] getGlobalsAndPackages() ...
[13:24:41.461] Searching for globals...
[13:24:41.461] 
[13:24:41.461] Searching for globals ... DONE
[13:24:41.461] - globals: [0] <none>
[13:24:41.462] getGlobalsAndPackages() ... DONE
[13:24:41.462] run() for ‘Future’ ...
[13:24:41.462] - state: ‘created’
[13:24:41.462] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.476]   - Field: ‘node’
[13:24:41.476]   - Field: ‘label’
[13:24:41.476]   - Field: ‘local’
[13:24:41.477]   - Field: ‘owner’
[13:24:41.477]   - Field: ‘envir’
[13:24:41.477]   - Field: ‘workers’
[13:24:41.477]   - Field: ‘packages’
[13:24:41.477]   - Field: ‘gc’
[13:24:41.477]   - Field: ‘conditions’
[13:24:41.477]   - Field: ‘persistent’
[13:24:41.477]   - Field: ‘expr’
[13:24:41.478]   - Field: ‘uuid’
[13:24:41.478]   - Field: ‘seed’
[13:24:41.478]   - Field: ‘version’
[13:24:41.478]   - Field: ‘result’
[13:24:41.478]   - Field: ‘asynchronous’
[13:24:41.478]   - Field: ‘calls’
[13:24:41.478]   - Field: ‘globals’
[13:24:41.478]   - Field: ‘stdout’
[13:24:41.478]   - Field: ‘earlySignal’
[13:24:41.479]   - Field: ‘lazy’
[13:24:41.479]   - Field: ‘state’
[13:24:41.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.479] - Launch lazy future ...
[13:24:41.479] Packages needed by the future expression (n = 0): <none>
[13:24:41.479] Packages needed by future strategies (n = 0): <none>
[13:24:41.480] {
[13:24:41.480]     {
[13:24:41.480]         {
[13:24:41.480]             ...future.startTime <- base::Sys.time()
[13:24:41.480]             {
[13:24:41.480]                 {
[13:24:41.480]                   {
[13:24:41.480]                     {
[13:24:41.480]                       base::local({
[13:24:41.480]                         has_future <- base::requireNamespace("future", 
[13:24:41.480]                           quietly = TRUE)
[13:24:41.480]                         if (has_future) {
[13:24:41.480]                           ns <- base::getNamespace("future")
[13:24:41.480]                           version <- ns[[".package"]][["version"]]
[13:24:41.480]                           if (is.null(version)) 
[13:24:41.480]                             version <- utils::packageVersion("future")
[13:24:41.480]                         }
[13:24:41.480]                         else {
[13:24:41.480]                           version <- NULL
[13:24:41.480]                         }
[13:24:41.480]                         if (!has_future || version < "1.8.0") {
[13:24:41.480]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.480]                             "", base::R.version$version.string), 
[13:24:41.480]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.480]                               "release", "version")], collapse = " "), 
[13:24:41.480]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.480]                             info)
[13:24:41.480]                           info <- base::paste(info, collapse = "; ")
[13:24:41.480]                           if (!has_future) {
[13:24:41.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.480]                               info)
[13:24:41.480]                           }
[13:24:41.480]                           else {
[13:24:41.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.480]                               info, version)
[13:24:41.480]                           }
[13:24:41.480]                           base::stop(msg)
[13:24:41.480]                         }
[13:24:41.480]                       })
[13:24:41.480]                     }
[13:24:41.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.480]                     base::options(mc.cores = 1L)
[13:24:41.480]                   }
[13:24:41.480]                   options(future.plan = NULL)
[13:24:41.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.480]                 }
[13:24:41.480]                 ...future.workdir <- getwd()
[13:24:41.480]             }
[13:24:41.480]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.480]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.480]         }
[13:24:41.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.480]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.480]             base::names(...future.oldOptions))
[13:24:41.480]     }
[13:24:41.480]     if (FALSE) {
[13:24:41.480]     }
[13:24:41.480]     else {
[13:24:41.480]         if (TRUE) {
[13:24:41.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.480]                 open = "w")
[13:24:41.480]         }
[13:24:41.480]         else {
[13:24:41.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.480]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.480]         }
[13:24:41.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.480]             base::sink(type = "output", split = FALSE)
[13:24:41.480]             base::close(...future.stdout)
[13:24:41.480]         }, add = TRUE)
[13:24:41.480]     }
[13:24:41.480]     ...future.frame <- base::sys.nframe()
[13:24:41.480]     ...future.conditions <- base::list()
[13:24:41.480]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.480]     if (FALSE) {
[13:24:41.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.480]     }
[13:24:41.480]     ...future.result <- base::tryCatch({
[13:24:41.480]         base::withCallingHandlers({
[13:24:41.480]             ...future.value <- base::withVisible(base::local({
[13:24:41.480]                 ...future.makeSendCondition <- base::local({
[13:24:41.480]                   sendCondition <- NULL
[13:24:41.480]                   function(frame = 1L) {
[13:24:41.480]                     if (is.function(sendCondition)) 
[13:24:41.480]                       return(sendCondition)
[13:24:41.480]                     ns <- getNamespace("parallel")
[13:24:41.480]                     if (exists("sendData", mode = "function", 
[13:24:41.480]                       envir = ns)) {
[13:24:41.480]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.480]                         envir = ns)
[13:24:41.480]                       envir <- sys.frame(frame)
[13:24:41.480]                       master <- NULL
[13:24:41.480]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.480]                         !identical(envir, emptyenv())) {
[13:24:41.480]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.480]                           inherits = FALSE)) {
[13:24:41.480]                           master <- get("master", mode = "list", 
[13:24:41.480]                             envir = envir, inherits = FALSE)
[13:24:41.480]                           if (inherits(master, c("SOCKnode", 
[13:24:41.480]                             "SOCK0node"))) {
[13:24:41.480]                             sendCondition <<- function(cond) {
[13:24:41.480]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.480]                                 success = TRUE)
[13:24:41.480]                               parallel_sendData(master, data)
[13:24:41.480]                             }
[13:24:41.480]                             return(sendCondition)
[13:24:41.480]                           }
[13:24:41.480]                         }
[13:24:41.480]                         frame <- frame + 1L
[13:24:41.480]                         envir <- sys.frame(frame)
[13:24:41.480]                       }
[13:24:41.480]                     }
[13:24:41.480]                     sendCondition <<- function(cond) NULL
[13:24:41.480]                   }
[13:24:41.480]                 })
[13:24:41.480]                 withCallingHandlers({
[13:24:41.480]                   2
[13:24:41.480]                 }, immediateCondition = function(cond) {
[13:24:41.480]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.480]                   sendCondition(cond)
[13:24:41.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.480]                   {
[13:24:41.480]                     inherits <- base::inherits
[13:24:41.480]                     invokeRestart <- base::invokeRestart
[13:24:41.480]                     is.null <- base::is.null
[13:24:41.480]                     muffled <- FALSE
[13:24:41.480]                     if (inherits(cond, "message")) {
[13:24:41.480]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.480]                       if (muffled) 
[13:24:41.480]                         invokeRestart("muffleMessage")
[13:24:41.480]                     }
[13:24:41.480]                     else if (inherits(cond, "warning")) {
[13:24:41.480]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.480]                       if (muffled) 
[13:24:41.480]                         invokeRestart("muffleWarning")
[13:24:41.480]                     }
[13:24:41.480]                     else if (inherits(cond, "condition")) {
[13:24:41.480]                       if (!is.null(pattern)) {
[13:24:41.480]                         computeRestarts <- base::computeRestarts
[13:24:41.480]                         grepl <- base::grepl
[13:24:41.480]                         restarts <- computeRestarts(cond)
[13:24:41.480]                         for (restart in restarts) {
[13:24:41.480]                           name <- restart$name
[13:24:41.480]                           if (is.null(name)) 
[13:24:41.480]                             next
[13:24:41.480]                           if (!grepl(pattern, name)) 
[13:24:41.480]                             next
[13:24:41.480]                           invokeRestart(restart)
[13:24:41.480]                           muffled <- TRUE
[13:24:41.480]                           break
[13:24:41.480]                         }
[13:24:41.480]                       }
[13:24:41.480]                     }
[13:24:41.480]                     invisible(muffled)
[13:24:41.480]                   }
[13:24:41.480]                   muffleCondition(cond)
[13:24:41.480]                 })
[13:24:41.480]             }))
[13:24:41.480]             future::FutureResult(value = ...future.value$value, 
[13:24:41.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.480]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.480]                     ...future.globalenv.names))
[13:24:41.480]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.480]         }, condition = base::local({
[13:24:41.480]             c <- base::c
[13:24:41.480]             inherits <- base::inherits
[13:24:41.480]             invokeRestart <- base::invokeRestart
[13:24:41.480]             length <- base::length
[13:24:41.480]             list <- base::list
[13:24:41.480]             seq.int <- base::seq.int
[13:24:41.480]             signalCondition <- base::signalCondition
[13:24:41.480]             sys.calls <- base::sys.calls
[13:24:41.480]             `[[` <- base::`[[`
[13:24:41.480]             `+` <- base::`+`
[13:24:41.480]             `<<-` <- base::`<<-`
[13:24:41.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.480]                   3L)]
[13:24:41.480]             }
[13:24:41.480]             function(cond) {
[13:24:41.480]                 is_error <- inherits(cond, "error")
[13:24:41.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.480]                   NULL)
[13:24:41.480]                 if (is_error) {
[13:24:41.480]                   sessionInformation <- function() {
[13:24:41.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.480]                       search = base::search(), system = base::Sys.info())
[13:24:41.480]                   }
[13:24:41.480]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.480]                     cond$call), session = sessionInformation(), 
[13:24:41.480]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.480]                   signalCondition(cond)
[13:24:41.480]                 }
[13:24:41.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.480]                 "immediateCondition"))) {
[13:24:41.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.480]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.480]                   if (TRUE && !signal) {
[13:24:41.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.480]                     {
[13:24:41.480]                       inherits <- base::inherits
[13:24:41.480]                       invokeRestart <- base::invokeRestart
[13:24:41.480]                       is.null <- base::is.null
[13:24:41.480]                       muffled <- FALSE
[13:24:41.480]                       if (inherits(cond, "message")) {
[13:24:41.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.480]                         if (muffled) 
[13:24:41.480]                           invokeRestart("muffleMessage")
[13:24:41.480]                       }
[13:24:41.480]                       else if (inherits(cond, "warning")) {
[13:24:41.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.480]                         if (muffled) 
[13:24:41.480]                           invokeRestart("muffleWarning")
[13:24:41.480]                       }
[13:24:41.480]                       else if (inherits(cond, "condition")) {
[13:24:41.480]                         if (!is.null(pattern)) {
[13:24:41.480]                           computeRestarts <- base::computeRestarts
[13:24:41.480]                           grepl <- base::grepl
[13:24:41.480]                           restarts <- computeRestarts(cond)
[13:24:41.480]                           for (restart in restarts) {
[13:24:41.480]                             name <- restart$name
[13:24:41.480]                             if (is.null(name)) 
[13:24:41.480]                               next
[13:24:41.480]                             if (!grepl(pattern, name)) 
[13:24:41.480]                               next
[13:24:41.480]                             invokeRestart(restart)
[13:24:41.480]                             muffled <- TRUE
[13:24:41.480]                             break
[13:24:41.480]                           }
[13:24:41.480]                         }
[13:24:41.480]                       }
[13:24:41.480]                       invisible(muffled)
[13:24:41.480]                     }
[13:24:41.480]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.480]                   }
[13:24:41.480]                 }
[13:24:41.480]                 else {
[13:24:41.480]                   if (TRUE) {
[13:24:41.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.480]                     {
[13:24:41.480]                       inherits <- base::inherits
[13:24:41.480]                       invokeRestart <- base::invokeRestart
[13:24:41.480]                       is.null <- base::is.null
[13:24:41.480]                       muffled <- FALSE
[13:24:41.480]                       if (inherits(cond, "message")) {
[13:24:41.480]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.480]                         if (muffled) 
[13:24:41.480]                           invokeRestart("muffleMessage")
[13:24:41.480]                       }
[13:24:41.480]                       else if (inherits(cond, "warning")) {
[13:24:41.480]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.480]                         if (muffled) 
[13:24:41.480]                           invokeRestart("muffleWarning")
[13:24:41.480]                       }
[13:24:41.480]                       else if (inherits(cond, "condition")) {
[13:24:41.480]                         if (!is.null(pattern)) {
[13:24:41.480]                           computeRestarts <- base::computeRestarts
[13:24:41.480]                           grepl <- base::grepl
[13:24:41.480]                           restarts <- computeRestarts(cond)
[13:24:41.480]                           for (restart in restarts) {
[13:24:41.480]                             name <- restart$name
[13:24:41.480]                             if (is.null(name)) 
[13:24:41.480]                               next
[13:24:41.480]                             if (!grepl(pattern, name)) 
[13:24:41.480]                               next
[13:24:41.480]                             invokeRestart(restart)
[13:24:41.480]                             muffled <- TRUE
[13:24:41.480]                             break
[13:24:41.480]                           }
[13:24:41.480]                         }
[13:24:41.480]                       }
[13:24:41.480]                       invisible(muffled)
[13:24:41.480]                     }
[13:24:41.480]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.480]                   }
[13:24:41.480]                 }
[13:24:41.480]             }
[13:24:41.480]         }))
[13:24:41.480]     }, error = function(ex) {
[13:24:41.480]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.480]                 ...future.rng), started = ...future.startTime, 
[13:24:41.480]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.480]             version = "1.8"), class = "FutureResult")
[13:24:41.480]     }, finally = {
[13:24:41.480]         if (!identical(...future.workdir, getwd())) 
[13:24:41.480]             setwd(...future.workdir)
[13:24:41.480]         {
[13:24:41.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.480]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.480]             }
[13:24:41.480]             base::options(...future.oldOptions)
[13:24:41.480]             if (.Platform$OS.type == "windows") {
[13:24:41.480]                 old_names <- names(...future.oldEnvVars)
[13:24:41.480]                 envs <- base::Sys.getenv()
[13:24:41.480]                 names <- names(envs)
[13:24:41.480]                 common <- intersect(names, old_names)
[13:24:41.480]                 added <- setdiff(names, old_names)
[13:24:41.480]                 removed <- setdiff(old_names, names)
[13:24:41.480]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.480]                   envs[common]]
[13:24:41.480]                 NAMES <- toupper(changed)
[13:24:41.480]                 args <- list()
[13:24:41.480]                 for (kk in seq_along(NAMES)) {
[13:24:41.480]                   name <- changed[[kk]]
[13:24:41.480]                   NAME <- NAMES[[kk]]
[13:24:41.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.480]                     next
[13:24:41.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.480]                 }
[13:24:41.480]                 NAMES <- toupper(added)
[13:24:41.480]                 for (kk in seq_along(NAMES)) {
[13:24:41.480]                   name <- added[[kk]]
[13:24:41.480]                   NAME <- NAMES[[kk]]
[13:24:41.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.480]                     next
[13:24:41.480]                   args[[name]] <- ""
[13:24:41.480]                 }
[13:24:41.480]                 NAMES <- toupper(removed)
[13:24:41.480]                 for (kk in seq_along(NAMES)) {
[13:24:41.480]                   name <- removed[[kk]]
[13:24:41.480]                   NAME <- NAMES[[kk]]
[13:24:41.480]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.480]                     next
[13:24:41.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.480]                 }
[13:24:41.480]                 if (length(args) > 0) 
[13:24:41.480]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.480]             }
[13:24:41.480]             else {
[13:24:41.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.480]             }
[13:24:41.480]             {
[13:24:41.480]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.480]                   0L) {
[13:24:41.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.480]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.480]                   base::options(opts)
[13:24:41.480]                 }
[13:24:41.480]                 {
[13:24:41.480]                   {
[13:24:41.480]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.480]                     NULL
[13:24:41.480]                   }
[13:24:41.480]                   options(future.plan = NULL)
[13:24:41.480]                   if (is.na(NA_character_)) 
[13:24:41.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.480]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.480]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.480]                     envir = parent.frame()) 
[13:24:41.480]                   {
[13:24:41.480]                     if (is.function(workers)) 
[13:24:41.480]                       workers <- workers()
[13:24:41.480]                     workers <- structure(as.integer(workers), 
[13:24:41.480]                       class = class(workers))
[13:24:41.480]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.480]                       workers >= 1)
[13:24:41.480]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.480]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.480]                     }
[13:24:41.480]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.480]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.480]                       envir = envir)
[13:24:41.480]                     if (!future$lazy) 
[13:24:41.480]                       future <- run(future)
[13:24:41.480]                     invisible(future)
[13:24:41.480]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.480]                 }
[13:24:41.480]             }
[13:24:41.480]         }
[13:24:41.480]     })
[13:24:41.480]     if (TRUE) {
[13:24:41.480]         base::sink(type = "output", split = FALSE)
[13:24:41.480]         if (TRUE) {
[13:24:41.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.480]         }
[13:24:41.480]         else {
[13:24:41.480]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.480]         }
[13:24:41.480]         base::close(...future.stdout)
[13:24:41.480]         ...future.stdout <- NULL
[13:24:41.480]     }
[13:24:41.480]     ...future.result$conditions <- ...future.conditions
[13:24:41.480]     ...future.result$finished <- base::Sys.time()
[13:24:41.480]     ...future.result
[13:24:41.480] }
[13:24:41.483] MultisessionFuture started
[13:24:41.484] - Launch lazy future ... done
[13:24:41.484] run() for ‘MultisessionFuture’ ... done
[13:24:41.484] resolve() on list ...
[13:24:41.484]  recursive: 0
[13:24:41.484]  length: 3
[13:24:41.484]  elements: ‘a’, ‘b’, ‘’
[13:24:41.484] run() for ‘Future’ ...
[13:24:41.485] - state: ‘created’
[13:24:41.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.499]   - Field: ‘node’
[13:24:41.499]   - Field: ‘label’
[13:24:41.499]   - Field: ‘local’
[13:24:41.499]   - Field: ‘owner’
[13:24:41.499]   - Field: ‘envir’
[13:24:41.500]   - Field: ‘workers’
[13:24:41.500]   - Field: ‘packages’
[13:24:41.500]   - Field: ‘gc’
[13:24:41.500]   - Field: ‘conditions’
[13:24:41.500]   - Field: ‘persistent’
[13:24:41.500]   - Field: ‘expr’
[13:24:41.500]   - Field: ‘uuid’
[13:24:41.501]   - Field: ‘seed’
[13:24:41.501]   - Field: ‘version’
[13:24:41.501]   - Field: ‘result’
[13:24:41.501]   - Field: ‘asynchronous’
[13:24:41.501]   - Field: ‘calls’
[13:24:41.501]   - Field: ‘globals’
[13:24:41.501]   - Field: ‘stdout’
[13:24:41.501]   - Field: ‘earlySignal’
[13:24:41.501]   - Field: ‘lazy’
[13:24:41.502]   - Field: ‘state’
[13:24:41.502] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.502] - Launch lazy future ...
[13:24:41.502] Packages needed by the future expression (n = 0): <none>
[13:24:41.502] Packages needed by future strategies (n = 0): <none>
[13:24:41.503] {
[13:24:41.503]     {
[13:24:41.503]         {
[13:24:41.503]             ...future.startTime <- base::Sys.time()
[13:24:41.503]             {
[13:24:41.503]                 {
[13:24:41.503]                   {
[13:24:41.503]                     {
[13:24:41.503]                       base::local({
[13:24:41.503]                         has_future <- base::requireNamespace("future", 
[13:24:41.503]                           quietly = TRUE)
[13:24:41.503]                         if (has_future) {
[13:24:41.503]                           ns <- base::getNamespace("future")
[13:24:41.503]                           version <- ns[[".package"]][["version"]]
[13:24:41.503]                           if (is.null(version)) 
[13:24:41.503]                             version <- utils::packageVersion("future")
[13:24:41.503]                         }
[13:24:41.503]                         else {
[13:24:41.503]                           version <- NULL
[13:24:41.503]                         }
[13:24:41.503]                         if (!has_future || version < "1.8.0") {
[13:24:41.503]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.503]                             "", base::R.version$version.string), 
[13:24:41.503]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.503]                               "release", "version")], collapse = " "), 
[13:24:41.503]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.503]                             info)
[13:24:41.503]                           info <- base::paste(info, collapse = "; ")
[13:24:41.503]                           if (!has_future) {
[13:24:41.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.503]                               info)
[13:24:41.503]                           }
[13:24:41.503]                           else {
[13:24:41.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.503]                               info, version)
[13:24:41.503]                           }
[13:24:41.503]                           base::stop(msg)
[13:24:41.503]                         }
[13:24:41.503]                       })
[13:24:41.503]                     }
[13:24:41.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.503]                     base::options(mc.cores = 1L)
[13:24:41.503]                   }
[13:24:41.503]                   options(future.plan = NULL)
[13:24:41.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.503]                 }
[13:24:41.503]                 ...future.workdir <- getwd()
[13:24:41.503]             }
[13:24:41.503]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.503]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.503]         }
[13:24:41.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.503]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.503]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.503]             base::names(...future.oldOptions))
[13:24:41.503]     }
[13:24:41.503]     if (FALSE) {
[13:24:41.503]     }
[13:24:41.503]     else {
[13:24:41.503]         if (TRUE) {
[13:24:41.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.503]                 open = "w")
[13:24:41.503]         }
[13:24:41.503]         else {
[13:24:41.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.503]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.503]         }
[13:24:41.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.503]             base::sink(type = "output", split = FALSE)
[13:24:41.503]             base::close(...future.stdout)
[13:24:41.503]         }, add = TRUE)
[13:24:41.503]     }
[13:24:41.503]     ...future.frame <- base::sys.nframe()
[13:24:41.503]     ...future.conditions <- base::list()
[13:24:41.503]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.503]     if (FALSE) {
[13:24:41.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.503]     }
[13:24:41.503]     ...future.result <- base::tryCatch({
[13:24:41.503]         base::withCallingHandlers({
[13:24:41.503]             ...future.value <- base::withVisible(base::local({
[13:24:41.503]                 ...future.makeSendCondition <- base::local({
[13:24:41.503]                   sendCondition <- NULL
[13:24:41.503]                   function(frame = 1L) {
[13:24:41.503]                     if (is.function(sendCondition)) 
[13:24:41.503]                       return(sendCondition)
[13:24:41.503]                     ns <- getNamespace("parallel")
[13:24:41.503]                     if (exists("sendData", mode = "function", 
[13:24:41.503]                       envir = ns)) {
[13:24:41.503]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.503]                         envir = ns)
[13:24:41.503]                       envir <- sys.frame(frame)
[13:24:41.503]                       master <- NULL
[13:24:41.503]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.503]                         !identical(envir, emptyenv())) {
[13:24:41.503]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.503]                           inherits = FALSE)) {
[13:24:41.503]                           master <- get("master", mode = "list", 
[13:24:41.503]                             envir = envir, inherits = FALSE)
[13:24:41.503]                           if (inherits(master, c("SOCKnode", 
[13:24:41.503]                             "SOCK0node"))) {
[13:24:41.503]                             sendCondition <<- function(cond) {
[13:24:41.503]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.503]                                 success = TRUE)
[13:24:41.503]                               parallel_sendData(master, data)
[13:24:41.503]                             }
[13:24:41.503]                             return(sendCondition)
[13:24:41.503]                           }
[13:24:41.503]                         }
[13:24:41.503]                         frame <- frame + 1L
[13:24:41.503]                         envir <- sys.frame(frame)
[13:24:41.503]                       }
[13:24:41.503]                     }
[13:24:41.503]                     sendCondition <<- function(cond) NULL
[13:24:41.503]                   }
[13:24:41.503]                 })
[13:24:41.503]                 withCallingHandlers({
[13:24:41.503]                   1
[13:24:41.503]                 }, immediateCondition = function(cond) {
[13:24:41.503]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.503]                   sendCondition(cond)
[13:24:41.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.503]                   {
[13:24:41.503]                     inherits <- base::inherits
[13:24:41.503]                     invokeRestart <- base::invokeRestart
[13:24:41.503]                     is.null <- base::is.null
[13:24:41.503]                     muffled <- FALSE
[13:24:41.503]                     if (inherits(cond, "message")) {
[13:24:41.503]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.503]                       if (muffled) 
[13:24:41.503]                         invokeRestart("muffleMessage")
[13:24:41.503]                     }
[13:24:41.503]                     else if (inherits(cond, "warning")) {
[13:24:41.503]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.503]                       if (muffled) 
[13:24:41.503]                         invokeRestart("muffleWarning")
[13:24:41.503]                     }
[13:24:41.503]                     else if (inherits(cond, "condition")) {
[13:24:41.503]                       if (!is.null(pattern)) {
[13:24:41.503]                         computeRestarts <- base::computeRestarts
[13:24:41.503]                         grepl <- base::grepl
[13:24:41.503]                         restarts <- computeRestarts(cond)
[13:24:41.503]                         for (restart in restarts) {
[13:24:41.503]                           name <- restart$name
[13:24:41.503]                           if (is.null(name)) 
[13:24:41.503]                             next
[13:24:41.503]                           if (!grepl(pattern, name)) 
[13:24:41.503]                             next
[13:24:41.503]                           invokeRestart(restart)
[13:24:41.503]                           muffled <- TRUE
[13:24:41.503]                           break
[13:24:41.503]                         }
[13:24:41.503]                       }
[13:24:41.503]                     }
[13:24:41.503]                     invisible(muffled)
[13:24:41.503]                   }
[13:24:41.503]                   muffleCondition(cond)
[13:24:41.503]                 })
[13:24:41.503]             }))
[13:24:41.503]             future::FutureResult(value = ...future.value$value, 
[13:24:41.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.503]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.503]                     ...future.globalenv.names))
[13:24:41.503]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.503]         }, condition = base::local({
[13:24:41.503]             c <- base::c
[13:24:41.503]             inherits <- base::inherits
[13:24:41.503]             invokeRestart <- base::invokeRestart
[13:24:41.503]             length <- base::length
[13:24:41.503]             list <- base::list
[13:24:41.503]             seq.int <- base::seq.int
[13:24:41.503]             signalCondition <- base::signalCondition
[13:24:41.503]             sys.calls <- base::sys.calls
[13:24:41.503]             `[[` <- base::`[[`
[13:24:41.503]             `+` <- base::`+`
[13:24:41.503]             `<<-` <- base::`<<-`
[13:24:41.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.503]                   3L)]
[13:24:41.503]             }
[13:24:41.503]             function(cond) {
[13:24:41.503]                 is_error <- inherits(cond, "error")
[13:24:41.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.503]                   NULL)
[13:24:41.503]                 if (is_error) {
[13:24:41.503]                   sessionInformation <- function() {
[13:24:41.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.503]                       search = base::search(), system = base::Sys.info())
[13:24:41.503]                   }
[13:24:41.503]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.503]                     cond$call), session = sessionInformation(), 
[13:24:41.503]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.503]                   signalCondition(cond)
[13:24:41.503]                 }
[13:24:41.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.503]                 "immediateCondition"))) {
[13:24:41.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.503]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.503]                   if (TRUE && !signal) {
[13:24:41.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.503]                     {
[13:24:41.503]                       inherits <- base::inherits
[13:24:41.503]                       invokeRestart <- base::invokeRestart
[13:24:41.503]                       is.null <- base::is.null
[13:24:41.503]                       muffled <- FALSE
[13:24:41.503]                       if (inherits(cond, "message")) {
[13:24:41.503]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.503]                         if (muffled) 
[13:24:41.503]                           invokeRestart("muffleMessage")
[13:24:41.503]                       }
[13:24:41.503]                       else if (inherits(cond, "warning")) {
[13:24:41.503]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.503]                         if (muffled) 
[13:24:41.503]                           invokeRestart("muffleWarning")
[13:24:41.503]                       }
[13:24:41.503]                       else if (inherits(cond, "condition")) {
[13:24:41.503]                         if (!is.null(pattern)) {
[13:24:41.503]                           computeRestarts <- base::computeRestarts
[13:24:41.503]                           grepl <- base::grepl
[13:24:41.503]                           restarts <- computeRestarts(cond)
[13:24:41.503]                           for (restart in restarts) {
[13:24:41.503]                             name <- restart$name
[13:24:41.503]                             if (is.null(name)) 
[13:24:41.503]                               next
[13:24:41.503]                             if (!grepl(pattern, name)) 
[13:24:41.503]                               next
[13:24:41.503]                             invokeRestart(restart)
[13:24:41.503]                             muffled <- TRUE
[13:24:41.503]                             break
[13:24:41.503]                           }
[13:24:41.503]                         }
[13:24:41.503]                       }
[13:24:41.503]                       invisible(muffled)
[13:24:41.503]                     }
[13:24:41.503]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.503]                   }
[13:24:41.503]                 }
[13:24:41.503]                 else {
[13:24:41.503]                   if (TRUE) {
[13:24:41.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.503]                     {
[13:24:41.503]                       inherits <- base::inherits
[13:24:41.503]                       invokeRestart <- base::invokeRestart
[13:24:41.503]                       is.null <- base::is.null
[13:24:41.503]                       muffled <- FALSE
[13:24:41.503]                       if (inherits(cond, "message")) {
[13:24:41.503]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.503]                         if (muffled) 
[13:24:41.503]                           invokeRestart("muffleMessage")
[13:24:41.503]                       }
[13:24:41.503]                       else if (inherits(cond, "warning")) {
[13:24:41.503]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.503]                         if (muffled) 
[13:24:41.503]                           invokeRestart("muffleWarning")
[13:24:41.503]                       }
[13:24:41.503]                       else if (inherits(cond, "condition")) {
[13:24:41.503]                         if (!is.null(pattern)) {
[13:24:41.503]                           computeRestarts <- base::computeRestarts
[13:24:41.503]                           grepl <- base::grepl
[13:24:41.503]                           restarts <- computeRestarts(cond)
[13:24:41.503]                           for (restart in restarts) {
[13:24:41.503]                             name <- restart$name
[13:24:41.503]                             if (is.null(name)) 
[13:24:41.503]                               next
[13:24:41.503]                             if (!grepl(pattern, name)) 
[13:24:41.503]                               next
[13:24:41.503]                             invokeRestart(restart)
[13:24:41.503]                             muffled <- TRUE
[13:24:41.503]                             break
[13:24:41.503]                           }
[13:24:41.503]                         }
[13:24:41.503]                       }
[13:24:41.503]                       invisible(muffled)
[13:24:41.503]                     }
[13:24:41.503]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.503]                   }
[13:24:41.503]                 }
[13:24:41.503]             }
[13:24:41.503]         }))
[13:24:41.503]     }, error = function(ex) {
[13:24:41.503]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.503]                 ...future.rng), started = ...future.startTime, 
[13:24:41.503]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.503]             version = "1.8"), class = "FutureResult")
[13:24:41.503]     }, finally = {
[13:24:41.503]         if (!identical(...future.workdir, getwd())) 
[13:24:41.503]             setwd(...future.workdir)
[13:24:41.503]         {
[13:24:41.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.503]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.503]             }
[13:24:41.503]             base::options(...future.oldOptions)
[13:24:41.503]             if (.Platform$OS.type == "windows") {
[13:24:41.503]                 old_names <- names(...future.oldEnvVars)
[13:24:41.503]                 envs <- base::Sys.getenv()
[13:24:41.503]                 names <- names(envs)
[13:24:41.503]                 common <- intersect(names, old_names)
[13:24:41.503]                 added <- setdiff(names, old_names)
[13:24:41.503]                 removed <- setdiff(old_names, names)
[13:24:41.503]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.503]                   envs[common]]
[13:24:41.503]                 NAMES <- toupper(changed)
[13:24:41.503]                 args <- list()
[13:24:41.503]                 for (kk in seq_along(NAMES)) {
[13:24:41.503]                   name <- changed[[kk]]
[13:24:41.503]                   NAME <- NAMES[[kk]]
[13:24:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.503]                     next
[13:24:41.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.503]                 }
[13:24:41.503]                 NAMES <- toupper(added)
[13:24:41.503]                 for (kk in seq_along(NAMES)) {
[13:24:41.503]                   name <- added[[kk]]
[13:24:41.503]                   NAME <- NAMES[[kk]]
[13:24:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.503]                     next
[13:24:41.503]                   args[[name]] <- ""
[13:24:41.503]                 }
[13:24:41.503]                 NAMES <- toupper(removed)
[13:24:41.503]                 for (kk in seq_along(NAMES)) {
[13:24:41.503]                   name <- removed[[kk]]
[13:24:41.503]                   NAME <- NAMES[[kk]]
[13:24:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.503]                     next
[13:24:41.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.503]                 }
[13:24:41.503]                 if (length(args) > 0) 
[13:24:41.503]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.503]             }
[13:24:41.503]             else {
[13:24:41.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.503]             }
[13:24:41.503]             {
[13:24:41.503]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.503]                   0L) {
[13:24:41.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.503]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.503]                   base::options(opts)
[13:24:41.503]                 }
[13:24:41.503]                 {
[13:24:41.503]                   {
[13:24:41.503]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.503]                     NULL
[13:24:41.503]                   }
[13:24:41.503]                   options(future.plan = NULL)
[13:24:41.503]                   if (is.na(NA_character_)) 
[13:24:41.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.503]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.503]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.503]                     envir = parent.frame()) 
[13:24:41.503]                   {
[13:24:41.503]                     if (is.function(workers)) 
[13:24:41.503]                       workers <- workers()
[13:24:41.503]                     workers <- structure(as.integer(workers), 
[13:24:41.503]                       class = class(workers))
[13:24:41.503]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.503]                       workers >= 1)
[13:24:41.503]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.503]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.503]                     }
[13:24:41.503]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.503]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.503]                       envir = envir)
[13:24:41.503]                     if (!future$lazy) 
[13:24:41.503]                       future <- run(future)
[13:24:41.503]                     invisible(future)
[13:24:41.503]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.503]                 }
[13:24:41.503]             }
[13:24:41.503]         }
[13:24:41.503]     })
[13:24:41.503]     if (TRUE) {
[13:24:41.503]         base::sink(type = "output", split = FALSE)
[13:24:41.503]         if (TRUE) {
[13:24:41.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.503]         }
[13:24:41.503]         else {
[13:24:41.503]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.503]         }
[13:24:41.503]         base::close(...future.stdout)
[13:24:41.503]         ...future.stdout <- NULL
[13:24:41.503]     }
[13:24:41.503]     ...future.result$conditions <- ...future.conditions
[13:24:41.503]     ...future.result$finished <- base::Sys.time()
[13:24:41.503]     ...future.result
[13:24:41.503] }
[13:24:41.507] MultisessionFuture started
[13:24:41.507] - Launch lazy future ... done
[13:24:41.507] run() for ‘MultisessionFuture’ ... done
[13:24:41.528]  length: 2 (resolved future 3)
[13:24:41.549] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.550] - Validating connection of MultisessionFuture
[13:24:41.550] - received message: FutureResult
[13:24:41.550] - Received FutureResult
[13:24:41.550] - Erased future from FutureRegistry
[13:24:41.551] result() for ClusterFuture ...
[13:24:41.551] - result already collected: FutureResult
[13:24:41.551] result() for ClusterFuture ... done
[13:24:41.551] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.551] Future #2
[13:24:41.551]  length: 1 (resolved future 2)
[13:24:41.562] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.562] - Validating connection of MultisessionFuture
[13:24:41.562] - received message: FutureResult
[13:24:41.562] - Received FutureResult
[13:24:41.562] - Erased future from FutureRegistry
[13:24:41.562] result() for ClusterFuture ...
[13:24:41.562] - result already collected: FutureResult
[13:24:41.562] result() for ClusterFuture ... done
[13:24:41.563] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.563] Future #1
[13:24:41.563]  length: 0 (resolved future 1)
[13:24:41.563] resolve() on list ... DONE
[13:24:41.563] getGlobalsAndPackages() ...
[13:24:41.563] Searching for globals...
[13:24:41.563] 
[13:24:41.564] Searching for globals ... DONE
[13:24:41.564] - globals: [0] <none>
[13:24:41.564] getGlobalsAndPackages() ... DONE
[13:24:41.564] getGlobalsAndPackages() ...
[13:24:41.564] Searching for globals...
[13:24:41.564] 
[13:24:41.565] Searching for globals ... DONE
[13:24:41.565] - globals: [0] <none>
[13:24:41.565] getGlobalsAndPackages() ... DONE
[13:24:41.565] resolve() on list ...
[13:24:41.565]  recursive: 0
[13:24:41.565]  length: 3
[13:24:41.565]  elements: ‘a’, ‘b’, ‘’
[13:24:41.565] run() for ‘Future’ ...
[13:24:41.565] - state: ‘created’
[13:24:41.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.584] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.584]   - Field: ‘node’
[13:24:41.584]   - Field: ‘label’
[13:24:41.584]   - Field: ‘local’
[13:24:41.584]   - Field: ‘owner’
[13:24:41.585]   - Field: ‘envir’
[13:24:41.585]   - Field: ‘workers’
[13:24:41.585]   - Field: ‘packages’
[13:24:41.585]   - Field: ‘gc’
[13:24:41.585]   - Field: ‘conditions’
[13:24:41.585]   - Field: ‘persistent’
[13:24:41.585]   - Field: ‘expr’
[13:24:41.585]   - Field: ‘uuid’
[13:24:41.585]   - Field: ‘seed’
[13:24:41.585]   - Field: ‘version’
[13:24:41.585]   - Field: ‘result’
[13:24:41.586]   - Field: ‘asynchronous’
[13:24:41.586]   - Field: ‘calls’
[13:24:41.586]   - Field: ‘globals’
[13:24:41.586]   - Field: ‘stdout’
[13:24:41.586]   - Field: ‘earlySignal’
[13:24:41.586]   - Field: ‘lazy’
[13:24:41.586]   - Field: ‘state’
[13:24:41.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.586] - Launch lazy future ...
[13:24:41.587] Packages needed by the future expression (n = 0): <none>
[13:24:41.587] Packages needed by future strategies (n = 0): <none>
[13:24:41.587] {
[13:24:41.587]     {
[13:24:41.587]         {
[13:24:41.587]             ...future.startTime <- base::Sys.time()
[13:24:41.587]             {
[13:24:41.587]                 {
[13:24:41.587]                   {
[13:24:41.587]                     {
[13:24:41.587]                       base::local({
[13:24:41.587]                         has_future <- base::requireNamespace("future", 
[13:24:41.587]                           quietly = TRUE)
[13:24:41.587]                         if (has_future) {
[13:24:41.587]                           ns <- base::getNamespace("future")
[13:24:41.587]                           version <- ns[[".package"]][["version"]]
[13:24:41.587]                           if (is.null(version)) 
[13:24:41.587]                             version <- utils::packageVersion("future")
[13:24:41.587]                         }
[13:24:41.587]                         else {
[13:24:41.587]                           version <- NULL
[13:24:41.587]                         }
[13:24:41.587]                         if (!has_future || version < "1.8.0") {
[13:24:41.587]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.587]                             "", base::R.version$version.string), 
[13:24:41.587]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.587]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.587]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.587]                               "release", "version")], collapse = " "), 
[13:24:41.587]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.587]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.587]                             info)
[13:24:41.587]                           info <- base::paste(info, collapse = "; ")
[13:24:41.587]                           if (!has_future) {
[13:24:41.587]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.587]                               info)
[13:24:41.587]                           }
[13:24:41.587]                           else {
[13:24:41.587]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.587]                               info, version)
[13:24:41.587]                           }
[13:24:41.587]                           base::stop(msg)
[13:24:41.587]                         }
[13:24:41.587]                       })
[13:24:41.587]                     }
[13:24:41.587]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.587]                     base::options(mc.cores = 1L)
[13:24:41.587]                   }
[13:24:41.587]                   options(future.plan = NULL)
[13:24:41.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.587]                 }
[13:24:41.587]                 ...future.workdir <- getwd()
[13:24:41.587]             }
[13:24:41.587]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.587]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.587]         }
[13:24:41.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.587]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.587]             base::names(...future.oldOptions))
[13:24:41.587]     }
[13:24:41.587]     if (FALSE) {
[13:24:41.587]     }
[13:24:41.587]     else {
[13:24:41.587]         if (TRUE) {
[13:24:41.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.587]                 open = "w")
[13:24:41.587]         }
[13:24:41.587]         else {
[13:24:41.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.587]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.587]         }
[13:24:41.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.587]             base::sink(type = "output", split = FALSE)
[13:24:41.587]             base::close(...future.stdout)
[13:24:41.587]         }, add = TRUE)
[13:24:41.587]     }
[13:24:41.587]     ...future.frame <- base::sys.nframe()
[13:24:41.587]     ...future.conditions <- base::list()
[13:24:41.587]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.587]     if (FALSE) {
[13:24:41.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.587]     }
[13:24:41.587]     ...future.result <- base::tryCatch({
[13:24:41.587]         base::withCallingHandlers({
[13:24:41.587]             ...future.value <- base::withVisible(base::local({
[13:24:41.587]                 ...future.makeSendCondition <- base::local({
[13:24:41.587]                   sendCondition <- NULL
[13:24:41.587]                   function(frame = 1L) {
[13:24:41.587]                     if (is.function(sendCondition)) 
[13:24:41.587]                       return(sendCondition)
[13:24:41.587]                     ns <- getNamespace("parallel")
[13:24:41.587]                     if (exists("sendData", mode = "function", 
[13:24:41.587]                       envir = ns)) {
[13:24:41.587]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.587]                         envir = ns)
[13:24:41.587]                       envir <- sys.frame(frame)
[13:24:41.587]                       master <- NULL
[13:24:41.587]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.587]                         !identical(envir, emptyenv())) {
[13:24:41.587]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.587]                           inherits = FALSE)) {
[13:24:41.587]                           master <- get("master", mode = "list", 
[13:24:41.587]                             envir = envir, inherits = FALSE)
[13:24:41.587]                           if (inherits(master, c("SOCKnode", 
[13:24:41.587]                             "SOCK0node"))) {
[13:24:41.587]                             sendCondition <<- function(cond) {
[13:24:41.587]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.587]                                 success = TRUE)
[13:24:41.587]                               parallel_sendData(master, data)
[13:24:41.587]                             }
[13:24:41.587]                             return(sendCondition)
[13:24:41.587]                           }
[13:24:41.587]                         }
[13:24:41.587]                         frame <- frame + 1L
[13:24:41.587]                         envir <- sys.frame(frame)
[13:24:41.587]                       }
[13:24:41.587]                     }
[13:24:41.587]                     sendCondition <<- function(cond) NULL
[13:24:41.587]                   }
[13:24:41.587]                 })
[13:24:41.587]                 withCallingHandlers({
[13:24:41.587]                   1
[13:24:41.587]                 }, immediateCondition = function(cond) {
[13:24:41.587]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.587]                   sendCondition(cond)
[13:24:41.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.587]                   {
[13:24:41.587]                     inherits <- base::inherits
[13:24:41.587]                     invokeRestart <- base::invokeRestart
[13:24:41.587]                     is.null <- base::is.null
[13:24:41.587]                     muffled <- FALSE
[13:24:41.587]                     if (inherits(cond, "message")) {
[13:24:41.587]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.587]                       if (muffled) 
[13:24:41.587]                         invokeRestart("muffleMessage")
[13:24:41.587]                     }
[13:24:41.587]                     else if (inherits(cond, "warning")) {
[13:24:41.587]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.587]                       if (muffled) 
[13:24:41.587]                         invokeRestart("muffleWarning")
[13:24:41.587]                     }
[13:24:41.587]                     else if (inherits(cond, "condition")) {
[13:24:41.587]                       if (!is.null(pattern)) {
[13:24:41.587]                         computeRestarts <- base::computeRestarts
[13:24:41.587]                         grepl <- base::grepl
[13:24:41.587]                         restarts <- computeRestarts(cond)
[13:24:41.587]                         for (restart in restarts) {
[13:24:41.587]                           name <- restart$name
[13:24:41.587]                           if (is.null(name)) 
[13:24:41.587]                             next
[13:24:41.587]                           if (!grepl(pattern, name)) 
[13:24:41.587]                             next
[13:24:41.587]                           invokeRestart(restart)
[13:24:41.587]                           muffled <- TRUE
[13:24:41.587]                           break
[13:24:41.587]                         }
[13:24:41.587]                       }
[13:24:41.587]                     }
[13:24:41.587]                     invisible(muffled)
[13:24:41.587]                   }
[13:24:41.587]                   muffleCondition(cond)
[13:24:41.587]                 })
[13:24:41.587]             }))
[13:24:41.587]             future::FutureResult(value = ...future.value$value, 
[13:24:41.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.587]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.587]                     ...future.globalenv.names))
[13:24:41.587]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.587]         }, condition = base::local({
[13:24:41.587]             c <- base::c
[13:24:41.587]             inherits <- base::inherits
[13:24:41.587]             invokeRestart <- base::invokeRestart
[13:24:41.587]             length <- base::length
[13:24:41.587]             list <- base::list
[13:24:41.587]             seq.int <- base::seq.int
[13:24:41.587]             signalCondition <- base::signalCondition
[13:24:41.587]             sys.calls <- base::sys.calls
[13:24:41.587]             `[[` <- base::`[[`
[13:24:41.587]             `+` <- base::`+`
[13:24:41.587]             `<<-` <- base::`<<-`
[13:24:41.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.587]                   3L)]
[13:24:41.587]             }
[13:24:41.587]             function(cond) {
[13:24:41.587]                 is_error <- inherits(cond, "error")
[13:24:41.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.587]                   NULL)
[13:24:41.587]                 if (is_error) {
[13:24:41.587]                   sessionInformation <- function() {
[13:24:41.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.587]                       search = base::search(), system = base::Sys.info())
[13:24:41.587]                   }
[13:24:41.587]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.587]                     cond$call), session = sessionInformation(), 
[13:24:41.587]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.587]                   signalCondition(cond)
[13:24:41.587]                 }
[13:24:41.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.587]                 "immediateCondition"))) {
[13:24:41.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.587]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.587]                   if (TRUE && !signal) {
[13:24:41.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.587]                     {
[13:24:41.587]                       inherits <- base::inherits
[13:24:41.587]                       invokeRestart <- base::invokeRestart
[13:24:41.587]                       is.null <- base::is.null
[13:24:41.587]                       muffled <- FALSE
[13:24:41.587]                       if (inherits(cond, "message")) {
[13:24:41.587]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.587]                         if (muffled) 
[13:24:41.587]                           invokeRestart("muffleMessage")
[13:24:41.587]                       }
[13:24:41.587]                       else if (inherits(cond, "warning")) {
[13:24:41.587]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.587]                         if (muffled) 
[13:24:41.587]                           invokeRestart("muffleWarning")
[13:24:41.587]                       }
[13:24:41.587]                       else if (inherits(cond, "condition")) {
[13:24:41.587]                         if (!is.null(pattern)) {
[13:24:41.587]                           computeRestarts <- base::computeRestarts
[13:24:41.587]                           grepl <- base::grepl
[13:24:41.587]                           restarts <- computeRestarts(cond)
[13:24:41.587]                           for (restart in restarts) {
[13:24:41.587]                             name <- restart$name
[13:24:41.587]                             if (is.null(name)) 
[13:24:41.587]                               next
[13:24:41.587]                             if (!grepl(pattern, name)) 
[13:24:41.587]                               next
[13:24:41.587]                             invokeRestart(restart)
[13:24:41.587]                             muffled <- TRUE
[13:24:41.587]                             break
[13:24:41.587]                           }
[13:24:41.587]                         }
[13:24:41.587]                       }
[13:24:41.587]                       invisible(muffled)
[13:24:41.587]                     }
[13:24:41.587]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.587]                   }
[13:24:41.587]                 }
[13:24:41.587]                 else {
[13:24:41.587]                   if (TRUE) {
[13:24:41.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.587]                     {
[13:24:41.587]                       inherits <- base::inherits
[13:24:41.587]                       invokeRestart <- base::invokeRestart
[13:24:41.587]                       is.null <- base::is.null
[13:24:41.587]                       muffled <- FALSE
[13:24:41.587]                       if (inherits(cond, "message")) {
[13:24:41.587]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.587]                         if (muffled) 
[13:24:41.587]                           invokeRestart("muffleMessage")
[13:24:41.587]                       }
[13:24:41.587]                       else if (inherits(cond, "warning")) {
[13:24:41.587]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.587]                         if (muffled) 
[13:24:41.587]                           invokeRestart("muffleWarning")
[13:24:41.587]                       }
[13:24:41.587]                       else if (inherits(cond, "condition")) {
[13:24:41.587]                         if (!is.null(pattern)) {
[13:24:41.587]                           computeRestarts <- base::computeRestarts
[13:24:41.587]                           grepl <- base::grepl
[13:24:41.587]                           restarts <- computeRestarts(cond)
[13:24:41.587]                           for (restart in restarts) {
[13:24:41.587]                             name <- restart$name
[13:24:41.587]                             if (is.null(name)) 
[13:24:41.587]                               next
[13:24:41.587]                             if (!grepl(pattern, name)) 
[13:24:41.587]                               next
[13:24:41.587]                             invokeRestart(restart)
[13:24:41.587]                             muffled <- TRUE
[13:24:41.587]                             break
[13:24:41.587]                           }
[13:24:41.587]                         }
[13:24:41.587]                       }
[13:24:41.587]                       invisible(muffled)
[13:24:41.587]                     }
[13:24:41.587]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.587]                   }
[13:24:41.587]                 }
[13:24:41.587]             }
[13:24:41.587]         }))
[13:24:41.587]     }, error = function(ex) {
[13:24:41.587]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.587]                 ...future.rng), started = ...future.startTime, 
[13:24:41.587]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.587]             version = "1.8"), class = "FutureResult")
[13:24:41.587]     }, finally = {
[13:24:41.587]         if (!identical(...future.workdir, getwd())) 
[13:24:41.587]             setwd(...future.workdir)
[13:24:41.587]         {
[13:24:41.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.587]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.587]             }
[13:24:41.587]             base::options(...future.oldOptions)
[13:24:41.587]             if (.Platform$OS.type == "windows") {
[13:24:41.587]                 old_names <- names(...future.oldEnvVars)
[13:24:41.587]                 envs <- base::Sys.getenv()
[13:24:41.587]                 names <- names(envs)
[13:24:41.587]                 common <- intersect(names, old_names)
[13:24:41.587]                 added <- setdiff(names, old_names)
[13:24:41.587]                 removed <- setdiff(old_names, names)
[13:24:41.587]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.587]                   envs[common]]
[13:24:41.587]                 NAMES <- toupper(changed)
[13:24:41.587]                 args <- list()
[13:24:41.587]                 for (kk in seq_along(NAMES)) {
[13:24:41.587]                   name <- changed[[kk]]
[13:24:41.587]                   NAME <- NAMES[[kk]]
[13:24:41.587]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.587]                     next
[13:24:41.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.587]                 }
[13:24:41.587]                 NAMES <- toupper(added)
[13:24:41.587]                 for (kk in seq_along(NAMES)) {
[13:24:41.587]                   name <- added[[kk]]
[13:24:41.587]                   NAME <- NAMES[[kk]]
[13:24:41.587]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.587]                     next
[13:24:41.587]                   args[[name]] <- ""
[13:24:41.587]                 }
[13:24:41.587]                 NAMES <- toupper(removed)
[13:24:41.587]                 for (kk in seq_along(NAMES)) {
[13:24:41.587]                   name <- removed[[kk]]
[13:24:41.587]                   NAME <- NAMES[[kk]]
[13:24:41.587]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.587]                     next
[13:24:41.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.587]                 }
[13:24:41.587]                 if (length(args) > 0) 
[13:24:41.587]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.587]             }
[13:24:41.587]             else {
[13:24:41.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.587]             }
[13:24:41.587]             {
[13:24:41.587]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.587]                   0L) {
[13:24:41.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.587]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.587]                   base::options(opts)
[13:24:41.587]                 }
[13:24:41.587]                 {
[13:24:41.587]                   {
[13:24:41.587]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.587]                     NULL
[13:24:41.587]                   }
[13:24:41.587]                   options(future.plan = NULL)
[13:24:41.587]                   if (is.na(NA_character_)) 
[13:24:41.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.587]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.587]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.587]                     envir = parent.frame()) 
[13:24:41.587]                   {
[13:24:41.587]                     if (is.function(workers)) 
[13:24:41.587]                       workers <- workers()
[13:24:41.587]                     workers <- structure(as.integer(workers), 
[13:24:41.587]                       class = class(workers))
[13:24:41.587]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.587]                       workers >= 1)
[13:24:41.587]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.587]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.587]                     }
[13:24:41.587]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.587]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.587]                       envir = envir)
[13:24:41.587]                     if (!future$lazy) 
[13:24:41.587]                       future <- run(future)
[13:24:41.587]                     invisible(future)
[13:24:41.587]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.587]                 }
[13:24:41.587]             }
[13:24:41.587]         }
[13:24:41.587]     })
[13:24:41.587]     if (TRUE) {
[13:24:41.587]         base::sink(type = "output", split = FALSE)
[13:24:41.587]         if (TRUE) {
[13:24:41.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.587]         }
[13:24:41.587]         else {
[13:24:41.587]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.587]         }
[13:24:41.587]         base::close(...future.stdout)
[13:24:41.587]         ...future.stdout <- NULL
[13:24:41.587]     }
[13:24:41.587]     ...future.result$conditions <- ...future.conditions
[13:24:41.587]     ...future.result$finished <- base::Sys.time()
[13:24:41.587]     ...future.result
[13:24:41.587] }
[13:24:41.590] MultisessionFuture started
[13:24:41.590] - Launch lazy future ... done
[13:24:41.590] run() for ‘MultisessionFuture’ ... done
[13:24:41.601] run() for ‘Future’ ...
[13:24:41.601] - state: ‘created’
[13:24:41.601] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.616] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.616] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.616]   - Field: ‘node’
[13:24:41.616]   - Field: ‘label’
[13:24:41.617]   - Field: ‘local’
[13:24:41.617]   - Field: ‘owner’
[13:24:41.617]   - Field: ‘envir’
[13:24:41.617]   - Field: ‘workers’
[13:24:41.617]   - Field: ‘packages’
[13:24:41.617]   - Field: ‘gc’
[13:24:41.617]   - Field: ‘conditions’
[13:24:41.617]   - Field: ‘persistent’
[13:24:41.617]   - Field: ‘expr’
[13:24:41.617]   - Field: ‘uuid’
[13:24:41.618]   - Field: ‘seed’
[13:24:41.618]   - Field: ‘version’
[13:24:41.618]   - Field: ‘result’
[13:24:41.618]   - Field: ‘asynchronous’
[13:24:41.618]   - Field: ‘calls’
[13:24:41.618]   - Field: ‘globals’
[13:24:41.618]   - Field: ‘stdout’
[13:24:41.618]   - Field: ‘earlySignal’
[13:24:41.618]   - Field: ‘lazy’
[13:24:41.618]   - Field: ‘state’
[13:24:41.619] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.619] - Launch lazy future ...
[13:24:41.619] Packages needed by the future expression (n = 0): <none>
[13:24:41.619] Packages needed by future strategies (n = 0): <none>
[13:24:41.619] {
[13:24:41.619]     {
[13:24:41.619]         {
[13:24:41.619]             ...future.startTime <- base::Sys.time()
[13:24:41.619]             {
[13:24:41.619]                 {
[13:24:41.619]                   {
[13:24:41.619]                     {
[13:24:41.619]                       base::local({
[13:24:41.619]                         has_future <- base::requireNamespace("future", 
[13:24:41.619]                           quietly = TRUE)
[13:24:41.619]                         if (has_future) {
[13:24:41.619]                           ns <- base::getNamespace("future")
[13:24:41.619]                           version <- ns[[".package"]][["version"]]
[13:24:41.619]                           if (is.null(version)) 
[13:24:41.619]                             version <- utils::packageVersion("future")
[13:24:41.619]                         }
[13:24:41.619]                         else {
[13:24:41.619]                           version <- NULL
[13:24:41.619]                         }
[13:24:41.619]                         if (!has_future || version < "1.8.0") {
[13:24:41.619]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.619]                             "", base::R.version$version.string), 
[13:24:41.619]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.619]                               "release", "version")], collapse = " "), 
[13:24:41.619]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.619]                             info)
[13:24:41.619]                           info <- base::paste(info, collapse = "; ")
[13:24:41.619]                           if (!has_future) {
[13:24:41.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.619]                               info)
[13:24:41.619]                           }
[13:24:41.619]                           else {
[13:24:41.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.619]                               info, version)
[13:24:41.619]                           }
[13:24:41.619]                           base::stop(msg)
[13:24:41.619]                         }
[13:24:41.619]                       })
[13:24:41.619]                     }
[13:24:41.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.619]                     base::options(mc.cores = 1L)
[13:24:41.619]                   }
[13:24:41.619]                   options(future.plan = NULL)
[13:24:41.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.619]                 }
[13:24:41.619]                 ...future.workdir <- getwd()
[13:24:41.619]             }
[13:24:41.619]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.619]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.619]         }
[13:24:41.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.619]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.619]             base::names(...future.oldOptions))
[13:24:41.619]     }
[13:24:41.619]     if (FALSE) {
[13:24:41.619]     }
[13:24:41.619]     else {
[13:24:41.619]         if (TRUE) {
[13:24:41.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.619]                 open = "w")
[13:24:41.619]         }
[13:24:41.619]         else {
[13:24:41.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.619]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.619]         }
[13:24:41.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.619]             base::sink(type = "output", split = FALSE)
[13:24:41.619]             base::close(...future.stdout)
[13:24:41.619]         }, add = TRUE)
[13:24:41.619]     }
[13:24:41.619]     ...future.frame <- base::sys.nframe()
[13:24:41.619]     ...future.conditions <- base::list()
[13:24:41.619]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.619]     if (FALSE) {
[13:24:41.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.619]     }
[13:24:41.619]     ...future.result <- base::tryCatch({
[13:24:41.619]         base::withCallingHandlers({
[13:24:41.619]             ...future.value <- base::withVisible(base::local({
[13:24:41.619]                 ...future.makeSendCondition <- base::local({
[13:24:41.619]                   sendCondition <- NULL
[13:24:41.619]                   function(frame = 1L) {
[13:24:41.619]                     if (is.function(sendCondition)) 
[13:24:41.619]                       return(sendCondition)
[13:24:41.619]                     ns <- getNamespace("parallel")
[13:24:41.619]                     if (exists("sendData", mode = "function", 
[13:24:41.619]                       envir = ns)) {
[13:24:41.619]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.619]                         envir = ns)
[13:24:41.619]                       envir <- sys.frame(frame)
[13:24:41.619]                       master <- NULL
[13:24:41.619]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.619]                         !identical(envir, emptyenv())) {
[13:24:41.619]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.619]                           inherits = FALSE)) {
[13:24:41.619]                           master <- get("master", mode = "list", 
[13:24:41.619]                             envir = envir, inherits = FALSE)
[13:24:41.619]                           if (inherits(master, c("SOCKnode", 
[13:24:41.619]                             "SOCK0node"))) {
[13:24:41.619]                             sendCondition <<- function(cond) {
[13:24:41.619]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.619]                                 success = TRUE)
[13:24:41.619]                               parallel_sendData(master, data)
[13:24:41.619]                             }
[13:24:41.619]                             return(sendCondition)
[13:24:41.619]                           }
[13:24:41.619]                         }
[13:24:41.619]                         frame <- frame + 1L
[13:24:41.619]                         envir <- sys.frame(frame)
[13:24:41.619]                       }
[13:24:41.619]                     }
[13:24:41.619]                     sendCondition <<- function(cond) NULL
[13:24:41.619]                   }
[13:24:41.619]                 })
[13:24:41.619]                 withCallingHandlers({
[13:24:41.619]                   2
[13:24:41.619]                 }, immediateCondition = function(cond) {
[13:24:41.619]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.619]                   sendCondition(cond)
[13:24:41.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.619]                   {
[13:24:41.619]                     inherits <- base::inherits
[13:24:41.619]                     invokeRestart <- base::invokeRestart
[13:24:41.619]                     is.null <- base::is.null
[13:24:41.619]                     muffled <- FALSE
[13:24:41.619]                     if (inherits(cond, "message")) {
[13:24:41.619]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.619]                       if (muffled) 
[13:24:41.619]                         invokeRestart("muffleMessage")
[13:24:41.619]                     }
[13:24:41.619]                     else if (inherits(cond, "warning")) {
[13:24:41.619]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.619]                       if (muffled) 
[13:24:41.619]                         invokeRestart("muffleWarning")
[13:24:41.619]                     }
[13:24:41.619]                     else if (inherits(cond, "condition")) {
[13:24:41.619]                       if (!is.null(pattern)) {
[13:24:41.619]                         computeRestarts <- base::computeRestarts
[13:24:41.619]                         grepl <- base::grepl
[13:24:41.619]                         restarts <- computeRestarts(cond)
[13:24:41.619]                         for (restart in restarts) {
[13:24:41.619]                           name <- restart$name
[13:24:41.619]                           if (is.null(name)) 
[13:24:41.619]                             next
[13:24:41.619]                           if (!grepl(pattern, name)) 
[13:24:41.619]                             next
[13:24:41.619]                           invokeRestart(restart)
[13:24:41.619]                           muffled <- TRUE
[13:24:41.619]                           break
[13:24:41.619]                         }
[13:24:41.619]                       }
[13:24:41.619]                     }
[13:24:41.619]                     invisible(muffled)
[13:24:41.619]                   }
[13:24:41.619]                   muffleCondition(cond)
[13:24:41.619]                 })
[13:24:41.619]             }))
[13:24:41.619]             future::FutureResult(value = ...future.value$value, 
[13:24:41.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.619]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.619]                     ...future.globalenv.names))
[13:24:41.619]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.619]         }, condition = base::local({
[13:24:41.619]             c <- base::c
[13:24:41.619]             inherits <- base::inherits
[13:24:41.619]             invokeRestart <- base::invokeRestart
[13:24:41.619]             length <- base::length
[13:24:41.619]             list <- base::list
[13:24:41.619]             seq.int <- base::seq.int
[13:24:41.619]             signalCondition <- base::signalCondition
[13:24:41.619]             sys.calls <- base::sys.calls
[13:24:41.619]             `[[` <- base::`[[`
[13:24:41.619]             `+` <- base::`+`
[13:24:41.619]             `<<-` <- base::`<<-`
[13:24:41.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.619]                   3L)]
[13:24:41.619]             }
[13:24:41.619]             function(cond) {
[13:24:41.619]                 is_error <- inherits(cond, "error")
[13:24:41.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.619]                   NULL)
[13:24:41.619]                 if (is_error) {
[13:24:41.619]                   sessionInformation <- function() {
[13:24:41.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.619]                       search = base::search(), system = base::Sys.info())
[13:24:41.619]                   }
[13:24:41.619]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.619]                     cond$call), session = sessionInformation(), 
[13:24:41.619]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.619]                   signalCondition(cond)
[13:24:41.619]                 }
[13:24:41.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.619]                 "immediateCondition"))) {
[13:24:41.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.619]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.619]                   if (TRUE && !signal) {
[13:24:41.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.619]                     {
[13:24:41.619]                       inherits <- base::inherits
[13:24:41.619]                       invokeRestart <- base::invokeRestart
[13:24:41.619]                       is.null <- base::is.null
[13:24:41.619]                       muffled <- FALSE
[13:24:41.619]                       if (inherits(cond, "message")) {
[13:24:41.619]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.619]                         if (muffled) 
[13:24:41.619]                           invokeRestart("muffleMessage")
[13:24:41.619]                       }
[13:24:41.619]                       else if (inherits(cond, "warning")) {
[13:24:41.619]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.619]                         if (muffled) 
[13:24:41.619]                           invokeRestart("muffleWarning")
[13:24:41.619]                       }
[13:24:41.619]                       else if (inherits(cond, "condition")) {
[13:24:41.619]                         if (!is.null(pattern)) {
[13:24:41.619]                           computeRestarts <- base::computeRestarts
[13:24:41.619]                           grepl <- base::grepl
[13:24:41.619]                           restarts <- computeRestarts(cond)
[13:24:41.619]                           for (restart in restarts) {
[13:24:41.619]                             name <- restart$name
[13:24:41.619]                             if (is.null(name)) 
[13:24:41.619]                               next
[13:24:41.619]                             if (!grepl(pattern, name)) 
[13:24:41.619]                               next
[13:24:41.619]                             invokeRestart(restart)
[13:24:41.619]                             muffled <- TRUE
[13:24:41.619]                             break
[13:24:41.619]                           }
[13:24:41.619]                         }
[13:24:41.619]                       }
[13:24:41.619]                       invisible(muffled)
[13:24:41.619]                     }
[13:24:41.619]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.619]                   }
[13:24:41.619]                 }
[13:24:41.619]                 else {
[13:24:41.619]                   if (TRUE) {
[13:24:41.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.619]                     {
[13:24:41.619]                       inherits <- base::inherits
[13:24:41.619]                       invokeRestart <- base::invokeRestart
[13:24:41.619]                       is.null <- base::is.null
[13:24:41.619]                       muffled <- FALSE
[13:24:41.619]                       if (inherits(cond, "message")) {
[13:24:41.619]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.619]                         if (muffled) 
[13:24:41.619]                           invokeRestart("muffleMessage")
[13:24:41.619]                       }
[13:24:41.619]                       else if (inherits(cond, "warning")) {
[13:24:41.619]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.619]                         if (muffled) 
[13:24:41.619]                           invokeRestart("muffleWarning")
[13:24:41.619]                       }
[13:24:41.619]                       else if (inherits(cond, "condition")) {
[13:24:41.619]                         if (!is.null(pattern)) {
[13:24:41.619]                           computeRestarts <- base::computeRestarts
[13:24:41.619]                           grepl <- base::grepl
[13:24:41.619]                           restarts <- computeRestarts(cond)
[13:24:41.619]                           for (restart in restarts) {
[13:24:41.619]                             name <- restart$name
[13:24:41.619]                             if (is.null(name)) 
[13:24:41.619]                               next
[13:24:41.619]                             if (!grepl(pattern, name)) 
[13:24:41.619]                               next
[13:24:41.619]                             invokeRestart(restart)
[13:24:41.619]                             muffled <- TRUE
[13:24:41.619]                             break
[13:24:41.619]                           }
[13:24:41.619]                         }
[13:24:41.619]                       }
[13:24:41.619]                       invisible(muffled)
[13:24:41.619]                     }
[13:24:41.619]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.619]                   }
[13:24:41.619]                 }
[13:24:41.619]             }
[13:24:41.619]         }))
[13:24:41.619]     }, error = function(ex) {
[13:24:41.619]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.619]                 ...future.rng), started = ...future.startTime, 
[13:24:41.619]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.619]             version = "1.8"), class = "FutureResult")
[13:24:41.619]     }, finally = {
[13:24:41.619]         if (!identical(...future.workdir, getwd())) 
[13:24:41.619]             setwd(...future.workdir)
[13:24:41.619]         {
[13:24:41.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.619]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.619]             }
[13:24:41.619]             base::options(...future.oldOptions)
[13:24:41.619]             if (.Platform$OS.type == "windows") {
[13:24:41.619]                 old_names <- names(...future.oldEnvVars)
[13:24:41.619]                 envs <- base::Sys.getenv()
[13:24:41.619]                 names <- names(envs)
[13:24:41.619]                 common <- intersect(names, old_names)
[13:24:41.619]                 added <- setdiff(names, old_names)
[13:24:41.619]                 removed <- setdiff(old_names, names)
[13:24:41.619]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.619]                   envs[common]]
[13:24:41.619]                 NAMES <- toupper(changed)
[13:24:41.619]                 args <- list()
[13:24:41.619]                 for (kk in seq_along(NAMES)) {
[13:24:41.619]                   name <- changed[[kk]]
[13:24:41.619]                   NAME <- NAMES[[kk]]
[13:24:41.619]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.619]                     next
[13:24:41.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.619]                 }
[13:24:41.619]                 NAMES <- toupper(added)
[13:24:41.619]                 for (kk in seq_along(NAMES)) {
[13:24:41.619]                   name <- added[[kk]]
[13:24:41.619]                   NAME <- NAMES[[kk]]
[13:24:41.619]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.619]                     next
[13:24:41.619]                   args[[name]] <- ""
[13:24:41.619]                 }
[13:24:41.619]                 NAMES <- toupper(removed)
[13:24:41.619]                 for (kk in seq_along(NAMES)) {
[13:24:41.619]                   name <- removed[[kk]]
[13:24:41.619]                   NAME <- NAMES[[kk]]
[13:24:41.619]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.619]                     next
[13:24:41.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.619]                 }
[13:24:41.619]                 if (length(args) > 0) 
[13:24:41.619]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.619]             }
[13:24:41.619]             else {
[13:24:41.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.619]             }
[13:24:41.619]             {
[13:24:41.619]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.619]                   0L) {
[13:24:41.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.619]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.619]                   base::options(opts)
[13:24:41.619]                 }
[13:24:41.619]                 {
[13:24:41.619]                   {
[13:24:41.619]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.619]                     NULL
[13:24:41.619]                   }
[13:24:41.619]                   options(future.plan = NULL)
[13:24:41.619]                   if (is.na(NA_character_)) 
[13:24:41.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.619]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.619]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.619]                     envir = parent.frame()) 
[13:24:41.619]                   {
[13:24:41.619]                     if (is.function(workers)) 
[13:24:41.619]                       workers <- workers()
[13:24:41.619]                     workers <- structure(as.integer(workers), 
[13:24:41.619]                       class = class(workers))
[13:24:41.619]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.619]                       workers >= 1)
[13:24:41.619]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.619]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.619]                     }
[13:24:41.619]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.619]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.619]                       envir = envir)
[13:24:41.619]                     if (!future$lazy) 
[13:24:41.619]                       future <- run(future)
[13:24:41.619]                     invisible(future)
[13:24:41.619]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.619]                 }
[13:24:41.619]             }
[13:24:41.619]         }
[13:24:41.619]     })
[13:24:41.619]     if (TRUE) {
[13:24:41.619]         base::sink(type = "output", split = FALSE)
[13:24:41.619]         if (TRUE) {
[13:24:41.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.619]         }
[13:24:41.619]         else {
[13:24:41.619]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.619]         }
[13:24:41.619]         base::close(...future.stdout)
[13:24:41.619]         ...future.stdout <- NULL
[13:24:41.619]     }
[13:24:41.619]     ...future.result$conditions <- ...future.conditions
[13:24:41.619]     ...future.result$finished <- base::Sys.time()
[13:24:41.619]     ...future.result
[13:24:41.619] }
[13:24:41.623] MultisessionFuture started
[13:24:41.623] - Launch lazy future ... done
[13:24:41.623] run() for ‘MultisessionFuture’ ... done
[13:24:41.634]  length: 2 (resolved future 3)
[13:24:41.644] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.644] - Validating connection of MultisessionFuture
[13:24:41.645] - received message: FutureResult
[13:24:41.645] - Received FutureResult
[13:24:41.645] - Erased future from FutureRegistry
[13:24:41.645] result() for ClusterFuture ...
[13:24:41.645] - result already collected: FutureResult
[13:24:41.645] result() for ClusterFuture ... done
[13:24:41.645] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.645] Future #1
[13:24:41.645]  length: 1 (resolved future 1)
[13:24:41.669] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.669] - Validating connection of MultisessionFuture
[13:24:41.669] - received message: FutureResult
[13:24:41.669] - Received FutureResult
[13:24:41.669] - Erased future from FutureRegistry
[13:24:41.669] result() for ClusterFuture ...
[13:24:41.669] - result already collected: FutureResult
[13:24:41.669] result() for ClusterFuture ... done
[13:24:41.670] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.670] Future #2
[13:24:41.670]  length: 0 (resolved future 2)
[13:24:41.670] resolve() on list ... DONE
[13:24:41.670] getGlobalsAndPackages() ...
[13:24:41.670] Searching for globals...
[13:24:41.670] 
[13:24:41.671] Searching for globals ... DONE
[13:24:41.671] - globals: [0] <none>
[13:24:41.671] getGlobalsAndPackages() ... DONE
[13:24:41.671] run() for ‘Future’ ...
[13:24:41.671] - state: ‘created’
[13:24:41.671] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.685] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.685]   - Field: ‘node’
[13:24:41.685]   - Field: ‘label’
[13:24:41.685]   - Field: ‘local’
[13:24:41.685]   - Field: ‘owner’
[13:24:41.685]   - Field: ‘envir’
[13:24:41.686]   - Field: ‘workers’
[13:24:41.686]   - Field: ‘packages’
[13:24:41.686]   - Field: ‘gc’
[13:24:41.686]   - Field: ‘conditions’
[13:24:41.686]   - Field: ‘persistent’
[13:24:41.686]   - Field: ‘expr’
[13:24:41.686]   - Field: ‘uuid’
[13:24:41.686]   - Field: ‘seed’
[13:24:41.686]   - Field: ‘version’
[13:24:41.686]   - Field: ‘result’
[13:24:41.687]   - Field: ‘asynchronous’
[13:24:41.687]   - Field: ‘calls’
[13:24:41.687]   - Field: ‘globals’
[13:24:41.687]   - Field: ‘stdout’
[13:24:41.687]   - Field: ‘earlySignal’
[13:24:41.687]   - Field: ‘lazy’
[13:24:41.687]   - Field: ‘state’
[13:24:41.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.687] - Launch lazy future ...
[13:24:41.688] Packages needed by the future expression (n = 0): <none>
[13:24:41.688] Packages needed by future strategies (n = 0): <none>
[13:24:41.688] {
[13:24:41.688]     {
[13:24:41.688]         {
[13:24:41.688]             ...future.startTime <- base::Sys.time()
[13:24:41.688]             {
[13:24:41.688]                 {
[13:24:41.688]                   {
[13:24:41.688]                     {
[13:24:41.688]                       base::local({
[13:24:41.688]                         has_future <- base::requireNamespace("future", 
[13:24:41.688]                           quietly = TRUE)
[13:24:41.688]                         if (has_future) {
[13:24:41.688]                           ns <- base::getNamespace("future")
[13:24:41.688]                           version <- ns[[".package"]][["version"]]
[13:24:41.688]                           if (is.null(version)) 
[13:24:41.688]                             version <- utils::packageVersion("future")
[13:24:41.688]                         }
[13:24:41.688]                         else {
[13:24:41.688]                           version <- NULL
[13:24:41.688]                         }
[13:24:41.688]                         if (!has_future || version < "1.8.0") {
[13:24:41.688]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.688]                             "", base::R.version$version.string), 
[13:24:41.688]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.688]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.688]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.688]                               "release", "version")], collapse = " "), 
[13:24:41.688]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.688]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.688]                             info)
[13:24:41.688]                           info <- base::paste(info, collapse = "; ")
[13:24:41.688]                           if (!has_future) {
[13:24:41.688]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.688]                               info)
[13:24:41.688]                           }
[13:24:41.688]                           else {
[13:24:41.688]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.688]                               info, version)
[13:24:41.688]                           }
[13:24:41.688]                           base::stop(msg)
[13:24:41.688]                         }
[13:24:41.688]                       })
[13:24:41.688]                     }
[13:24:41.688]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.688]                     base::options(mc.cores = 1L)
[13:24:41.688]                   }
[13:24:41.688]                   options(future.plan = NULL)
[13:24:41.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.688]                 }
[13:24:41.688]                 ...future.workdir <- getwd()
[13:24:41.688]             }
[13:24:41.688]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.688]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.688]         }
[13:24:41.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.688]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.688]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.688]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.688]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.688]             base::names(...future.oldOptions))
[13:24:41.688]     }
[13:24:41.688]     if (FALSE) {
[13:24:41.688]     }
[13:24:41.688]     else {
[13:24:41.688]         if (TRUE) {
[13:24:41.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.688]                 open = "w")
[13:24:41.688]         }
[13:24:41.688]         else {
[13:24:41.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.688]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.688]         }
[13:24:41.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.688]             base::sink(type = "output", split = FALSE)
[13:24:41.688]             base::close(...future.stdout)
[13:24:41.688]         }, add = TRUE)
[13:24:41.688]     }
[13:24:41.688]     ...future.frame <- base::sys.nframe()
[13:24:41.688]     ...future.conditions <- base::list()
[13:24:41.688]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.688]     if (FALSE) {
[13:24:41.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.688]     }
[13:24:41.688]     ...future.result <- base::tryCatch({
[13:24:41.688]         base::withCallingHandlers({
[13:24:41.688]             ...future.value <- base::withVisible(base::local({
[13:24:41.688]                 ...future.makeSendCondition <- base::local({
[13:24:41.688]                   sendCondition <- NULL
[13:24:41.688]                   function(frame = 1L) {
[13:24:41.688]                     if (is.function(sendCondition)) 
[13:24:41.688]                       return(sendCondition)
[13:24:41.688]                     ns <- getNamespace("parallel")
[13:24:41.688]                     if (exists("sendData", mode = "function", 
[13:24:41.688]                       envir = ns)) {
[13:24:41.688]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.688]                         envir = ns)
[13:24:41.688]                       envir <- sys.frame(frame)
[13:24:41.688]                       master <- NULL
[13:24:41.688]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.688]                         !identical(envir, emptyenv())) {
[13:24:41.688]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.688]                           inherits = FALSE)) {
[13:24:41.688]                           master <- get("master", mode = "list", 
[13:24:41.688]                             envir = envir, inherits = FALSE)
[13:24:41.688]                           if (inherits(master, c("SOCKnode", 
[13:24:41.688]                             "SOCK0node"))) {
[13:24:41.688]                             sendCondition <<- function(cond) {
[13:24:41.688]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.688]                                 success = TRUE)
[13:24:41.688]                               parallel_sendData(master, data)
[13:24:41.688]                             }
[13:24:41.688]                             return(sendCondition)
[13:24:41.688]                           }
[13:24:41.688]                         }
[13:24:41.688]                         frame <- frame + 1L
[13:24:41.688]                         envir <- sys.frame(frame)
[13:24:41.688]                       }
[13:24:41.688]                     }
[13:24:41.688]                     sendCondition <<- function(cond) NULL
[13:24:41.688]                   }
[13:24:41.688]                 })
[13:24:41.688]                 withCallingHandlers({
[13:24:41.688]                   1
[13:24:41.688]                 }, immediateCondition = function(cond) {
[13:24:41.688]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.688]                   sendCondition(cond)
[13:24:41.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.688]                   {
[13:24:41.688]                     inherits <- base::inherits
[13:24:41.688]                     invokeRestart <- base::invokeRestart
[13:24:41.688]                     is.null <- base::is.null
[13:24:41.688]                     muffled <- FALSE
[13:24:41.688]                     if (inherits(cond, "message")) {
[13:24:41.688]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.688]                       if (muffled) 
[13:24:41.688]                         invokeRestart("muffleMessage")
[13:24:41.688]                     }
[13:24:41.688]                     else if (inherits(cond, "warning")) {
[13:24:41.688]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.688]                       if (muffled) 
[13:24:41.688]                         invokeRestart("muffleWarning")
[13:24:41.688]                     }
[13:24:41.688]                     else if (inherits(cond, "condition")) {
[13:24:41.688]                       if (!is.null(pattern)) {
[13:24:41.688]                         computeRestarts <- base::computeRestarts
[13:24:41.688]                         grepl <- base::grepl
[13:24:41.688]                         restarts <- computeRestarts(cond)
[13:24:41.688]                         for (restart in restarts) {
[13:24:41.688]                           name <- restart$name
[13:24:41.688]                           if (is.null(name)) 
[13:24:41.688]                             next
[13:24:41.688]                           if (!grepl(pattern, name)) 
[13:24:41.688]                             next
[13:24:41.688]                           invokeRestart(restart)
[13:24:41.688]                           muffled <- TRUE
[13:24:41.688]                           break
[13:24:41.688]                         }
[13:24:41.688]                       }
[13:24:41.688]                     }
[13:24:41.688]                     invisible(muffled)
[13:24:41.688]                   }
[13:24:41.688]                   muffleCondition(cond)
[13:24:41.688]                 })
[13:24:41.688]             }))
[13:24:41.688]             future::FutureResult(value = ...future.value$value, 
[13:24:41.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.688]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.688]                     ...future.globalenv.names))
[13:24:41.688]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.688]         }, condition = base::local({
[13:24:41.688]             c <- base::c
[13:24:41.688]             inherits <- base::inherits
[13:24:41.688]             invokeRestart <- base::invokeRestart
[13:24:41.688]             length <- base::length
[13:24:41.688]             list <- base::list
[13:24:41.688]             seq.int <- base::seq.int
[13:24:41.688]             signalCondition <- base::signalCondition
[13:24:41.688]             sys.calls <- base::sys.calls
[13:24:41.688]             `[[` <- base::`[[`
[13:24:41.688]             `+` <- base::`+`
[13:24:41.688]             `<<-` <- base::`<<-`
[13:24:41.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.688]                   3L)]
[13:24:41.688]             }
[13:24:41.688]             function(cond) {
[13:24:41.688]                 is_error <- inherits(cond, "error")
[13:24:41.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.688]                   NULL)
[13:24:41.688]                 if (is_error) {
[13:24:41.688]                   sessionInformation <- function() {
[13:24:41.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.688]                       search = base::search(), system = base::Sys.info())
[13:24:41.688]                   }
[13:24:41.688]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.688]                     cond$call), session = sessionInformation(), 
[13:24:41.688]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.688]                   signalCondition(cond)
[13:24:41.688]                 }
[13:24:41.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.688]                 "immediateCondition"))) {
[13:24:41.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.688]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.688]                   if (TRUE && !signal) {
[13:24:41.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.688]                     {
[13:24:41.688]                       inherits <- base::inherits
[13:24:41.688]                       invokeRestart <- base::invokeRestart
[13:24:41.688]                       is.null <- base::is.null
[13:24:41.688]                       muffled <- FALSE
[13:24:41.688]                       if (inherits(cond, "message")) {
[13:24:41.688]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.688]                         if (muffled) 
[13:24:41.688]                           invokeRestart("muffleMessage")
[13:24:41.688]                       }
[13:24:41.688]                       else if (inherits(cond, "warning")) {
[13:24:41.688]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.688]                         if (muffled) 
[13:24:41.688]                           invokeRestart("muffleWarning")
[13:24:41.688]                       }
[13:24:41.688]                       else if (inherits(cond, "condition")) {
[13:24:41.688]                         if (!is.null(pattern)) {
[13:24:41.688]                           computeRestarts <- base::computeRestarts
[13:24:41.688]                           grepl <- base::grepl
[13:24:41.688]                           restarts <- computeRestarts(cond)
[13:24:41.688]                           for (restart in restarts) {
[13:24:41.688]                             name <- restart$name
[13:24:41.688]                             if (is.null(name)) 
[13:24:41.688]                               next
[13:24:41.688]                             if (!grepl(pattern, name)) 
[13:24:41.688]                               next
[13:24:41.688]                             invokeRestart(restart)
[13:24:41.688]                             muffled <- TRUE
[13:24:41.688]                             break
[13:24:41.688]                           }
[13:24:41.688]                         }
[13:24:41.688]                       }
[13:24:41.688]                       invisible(muffled)
[13:24:41.688]                     }
[13:24:41.688]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.688]                   }
[13:24:41.688]                 }
[13:24:41.688]                 else {
[13:24:41.688]                   if (TRUE) {
[13:24:41.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.688]                     {
[13:24:41.688]                       inherits <- base::inherits
[13:24:41.688]                       invokeRestart <- base::invokeRestart
[13:24:41.688]                       is.null <- base::is.null
[13:24:41.688]                       muffled <- FALSE
[13:24:41.688]                       if (inherits(cond, "message")) {
[13:24:41.688]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.688]                         if (muffled) 
[13:24:41.688]                           invokeRestart("muffleMessage")
[13:24:41.688]                       }
[13:24:41.688]                       else if (inherits(cond, "warning")) {
[13:24:41.688]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.688]                         if (muffled) 
[13:24:41.688]                           invokeRestart("muffleWarning")
[13:24:41.688]                       }
[13:24:41.688]                       else if (inherits(cond, "condition")) {
[13:24:41.688]                         if (!is.null(pattern)) {
[13:24:41.688]                           computeRestarts <- base::computeRestarts
[13:24:41.688]                           grepl <- base::grepl
[13:24:41.688]                           restarts <- computeRestarts(cond)
[13:24:41.688]                           for (restart in restarts) {
[13:24:41.688]                             name <- restart$name
[13:24:41.688]                             if (is.null(name)) 
[13:24:41.688]                               next
[13:24:41.688]                             if (!grepl(pattern, name)) 
[13:24:41.688]                               next
[13:24:41.688]                             invokeRestart(restart)
[13:24:41.688]                             muffled <- TRUE
[13:24:41.688]                             break
[13:24:41.688]                           }
[13:24:41.688]                         }
[13:24:41.688]                       }
[13:24:41.688]                       invisible(muffled)
[13:24:41.688]                     }
[13:24:41.688]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.688]                   }
[13:24:41.688]                 }
[13:24:41.688]             }
[13:24:41.688]         }))
[13:24:41.688]     }, error = function(ex) {
[13:24:41.688]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.688]                 ...future.rng), started = ...future.startTime, 
[13:24:41.688]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.688]             version = "1.8"), class = "FutureResult")
[13:24:41.688]     }, finally = {
[13:24:41.688]         if (!identical(...future.workdir, getwd())) 
[13:24:41.688]             setwd(...future.workdir)
[13:24:41.688]         {
[13:24:41.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.688]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.688]             }
[13:24:41.688]             base::options(...future.oldOptions)
[13:24:41.688]             if (.Platform$OS.type == "windows") {
[13:24:41.688]                 old_names <- names(...future.oldEnvVars)
[13:24:41.688]                 envs <- base::Sys.getenv()
[13:24:41.688]                 names <- names(envs)
[13:24:41.688]                 common <- intersect(names, old_names)
[13:24:41.688]                 added <- setdiff(names, old_names)
[13:24:41.688]                 removed <- setdiff(old_names, names)
[13:24:41.688]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.688]                   envs[common]]
[13:24:41.688]                 NAMES <- toupper(changed)
[13:24:41.688]                 args <- list()
[13:24:41.688]                 for (kk in seq_along(NAMES)) {
[13:24:41.688]                   name <- changed[[kk]]
[13:24:41.688]                   NAME <- NAMES[[kk]]
[13:24:41.688]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.688]                     next
[13:24:41.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.688]                 }
[13:24:41.688]                 NAMES <- toupper(added)
[13:24:41.688]                 for (kk in seq_along(NAMES)) {
[13:24:41.688]                   name <- added[[kk]]
[13:24:41.688]                   NAME <- NAMES[[kk]]
[13:24:41.688]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.688]                     next
[13:24:41.688]                   args[[name]] <- ""
[13:24:41.688]                 }
[13:24:41.688]                 NAMES <- toupper(removed)
[13:24:41.688]                 for (kk in seq_along(NAMES)) {
[13:24:41.688]                   name <- removed[[kk]]
[13:24:41.688]                   NAME <- NAMES[[kk]]
[13:24:41.688]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.688]                     next
[13:24:41.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.688]                 }
[13:24:41.688]                 if (length(args) > 0) 
[13:24:41.688]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.688]             }
[13:24:41.688]             else {
[13:24:41.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.688]             }
[13:24:41.688]             {
[13:24:41.688]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.688]                   0L) {
[13:24:41.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.688]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.688]                   base::options(opts)
[13:24:41.688]                 }
[13:24:41.688]                 {
[13:24:41.688]                   {
[13:24:41.688]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.688]                     NULL
[13:24:41.688]                   }
[13:24:41.688]                   options(future.plan = NULL)
[13:24:41.688]                   if (is.na(NA_character_)) 
[13:24:41.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.688]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.688]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.688]                     envir = parent.frame()) 
[13:24:41.688]                   {
[13:24:41.688]                     if (is.function(workers)) 
[13:24:41.688]                       workers <- workers()
[13:24:41.688]                     workers <- structure(as.integer(workers), 
[13:24:41.688]                       class = class(workers))
[13:24:41.688]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.688]                       workers >= 1)
[13:24:41.688]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.688]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.688]                     }
[13:24:41.688]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.688]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.688]                       envir = envir)
[13:24:41.688]                     if (!future$lazy) 
[13:24:41.688]                       future <- run(future)
[13:24:41.688]                     invisible(future)
[13:24:41.688]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.688]                 }
[13:24:41.688]             }
[13:24:41.688]         }
[13:24:41.688]     })
[13:24:41.688]     if (TRUE) {
[13:24:41.688]         base::sink(type = "output", split = FALSE)
[13:24:41.688]         if (TRUE) {
[13:24:41.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.688]         }
[13:24:41.688]         else {
[13:24:41.688]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.688]         }
[13:24:41.688]         base::close(...future.stdout)
[13:24:41.688]         ...future.stdout <- NULL
[13:24:41.688]     }
[13:24:41.688]     ...future.result$conditions <- ...future.conditions
[13:24:41.688]     ...future.result$finished <- base::Sys.time()
[13:24:41.688]     ...future.result
[13:24:41.688] }
[13:24:41.691] MultisessionFuture started
[13:24:41.691] - Launch lazy future ... done
[13:24:41.692] run() for ‘MultisessionFuture’ ... done
[13:24:41.692] getGlobalsAndPackages() ...
[13:24:41.692] Searching for globals...
[13:24:41.693] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:24:41.693] Searching for globals ... DONE
[13:24:41.693] Resolving globals: FALSE
[13:24:41.693] 
[13:24:41.693] 
[13:24:41.694] getGlobalsAndPackages() ... DONE
[13:24:41.694] run() for ‘Future’ ...
[13:24:41.694] - state: ‘created’
[13:24:41.694] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:41.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:41.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:41.708]   - Field: ‘node’
[13:24:41.708]   - Field: ‘label’
[13:24:41.708]   - Field: ‘local’
[13:24:41.708]   - Field: ‘owner’
[13:24:41.709]   - Field: ‘envir’
[13:24:41.709]   - Field: ‘workers’
[13:24:41.709]   - Field: ‘packages’
[13:24:41.709]   - Field: ‘gc’
[13:24:41.709]   - Field: ‘conditions’
[13:24:41.709]   - Field: ‘persistent’
[13:24:41.709]   - Field: ‘expr’
[13:24:41.709]   - Field: ‘uuid’
[13:24:41.709]   - Field: ‘seed’
[13:24:41.709]   - Field: ‘version’
[13:24:41.710]   - Field: ‘result’
[13:24:41.710]   - Field: ‘asynchronous’
[13:24:41.710]   - Field: ‘calls’
[13:24:41.710]   - Field: ‘globals’
[13:24:41.710]   - Field: ‘stdout’
[13:24:41.710]   - Field: ‘earlySignal’
[13:24:41.710]   - Field: ‘lazy’
[13:24:41.710]   - Field: ‘state’
[13:24:41.710] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:41.710] - Launch lazy future ...
[13:24:41.711] Packages needed by the future expression (n = 0): <none>
[13:24:41.711] Packages needed by future strategies (n = 0): <none>
[13:24:41.711] {
[13:24:41.711]     {
[13:24:41.711]         {
[13:24:41.711]             ...future.startTime <- base::Sys.time()
[13:24:41.711]             {
[13:24:41.711]                 {
[13:24:41.711]                   {
[13:24:41.711]                     {
[13:24:41.711]                       base::local({
[13:24:41.711]                         has_future <- base::requireNamespace("future", 
[13:24:41.711]                           quietly = TRUE)
[13:24:41.711]                         if (has_future) {
[13:24:41.711]                           ns <- base::getNamespace("future")
[13:24:41.711]                           version <- ns[[".package"]][["version"]]
[13:24:41.711]                           if (is.null(version)) 
[13:24:41.711]                             version <- utils::packageVersion("future")
[13:24:41.711]                         }
[13:24:41.711]                         else {
[13:24:41.711]                           version <- NULL
[13:24:41.711]                         }
[13:24:41.711]                         if (!has_future || version < "1.8.0") {
[13:24:41.711]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:41.711]                             "", base::R.version$version.string), 
[13:24:41.711]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:41.711]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:41.711]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:41.711]                               "release", "version")], collapse = " "), 
[13:24:41.711]                             hostname = base::Sys.info()[["nodename"]])
[13:24:41.711]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:41.711]                             info)
[13:24:41.711]                           info <- base::paste(info, collapse = "; ")
[13:24:41.711]                           if (!has_future) {
[13:24:41.711]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:41.711]                               info)
[13:24:41.711]                           }
[13:24:41.711]                           else {
[13:24:41.711]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:41.711]                               info, version)
[13:24:41.711]                           }
[13:24:41.711]                           base::stop(msg)
[13:24:41.711]                         }
[13:24:41.711]                       })
[13:24:41.711]                     }
[13:24:41.711]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:41.711]                     base::options(mc.cores = 1L)
[13:24:41.711]                   }
[13:24:41.711]                   options(future.plan = NULL)
[13:24:41.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:41.711]                 }
[13:24:41.711]                 ...future.workdir <- getwd()
[13:24:41.711]             }
[13:24:41.711]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:41.711]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:41.711]         }
[13:24:41.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:41.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:41.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:41.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:41.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:41.711]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:41.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:41.711]             base::names(...future.oldOptions))
[13:24:41.711]     }
[13:24:41.711]     if (FALSE) {
[13:24:41.711]     }
[13:24:41.711]     else {
[13:24:41.711]         if (TRUE) {
[13:24:41.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:41.711]                 open = "w")
[13:24:41.711]         }
[13:24:41.711]         else {
[13:24:41.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:41.711]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:41.711]         }
[13:24:41.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:41.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:41.711]             base::sink(type = "output", split = FALSE)
[13:24:41.711]             base::close(...future.stdout)
[13:24:41.711]         }, add = TRUE)
[13:24:41.711]     }
[13:24:41.711]     ...future.frame <- base::sys.nframe()
[13:24:41.711]     ...future.conditions <- base::list()
[13:24:41.711]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:41.711]     if (FALSE) {
[13:24:41.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:41.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:41.711]     }
[13:24:41.711]     ...future.result <- base::tryCatch({
[13:24:41.711]         base::withCallingHandlers({
[13:24:41.711]             ...future.value <- base::withVisible(base::local({
[13:24:41.711]                 ...future.makeSendCondition <- base::local({
[13:24:41.711]                   sendCondition <- NULL
[13:24:41.711]                   function(frame = 1L) {
[13:24:41.711]                     if (is.function(sendCondition)) 
[13:24:41.711]                       return(sendCondition)
[13:24:41.711]                     ns <- getNamespace("parallel")
[13:24:41.711]                     if (exists("sendData", mode = "function", 
[13:24:41.711]                       envir = ns)) {
[13:24:41.711]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:41.711]                         envir = ns)
[13:24:41.711]                       envir <- sys.frame(frame)
[13:24:41.711]                       master <- NULL
[13:24:41.711]                       while (!identical(envir, .GlobalEnv) && 
[13:24:41.711]                         !identical(envir, emptyenv())) {
[13:24:41.711]                         if (exists("master", mode = "list", envir = envir, 
[13:24:41.711]                           inherits = FALSE)) {
[13:24:41.711]                           master <- get("master", mode = "list", 
[13:24:41.711]                             envir = envir, inherits = FALSE)
[13:24:41.711]                           if (inherits(master, c("SOCKnode", 
[13:24:41.711]                             "SOCK0node"))) {
[13:24:41.711]                             sendCondition <<- function(cond) {
[13:24:41.711]                               data <- list(type = "VALUE", value = cond, 
[13:24:41.711]                                 success = TRUE)
[13:24:41.711]                               parallel_sendData(master, data)
[13:24:41.711]                             }
[13:24:41.711]                             return(sendCondition)
[13:24:41.711]                           }
[13:24:41.711]                         }
[13:24:41.711]                         frame <- frame + 1L
[13:24:41.711]                         envir <- sys.frame(frame)
[13:24:41.711]                       }
[13:24:41.711]                     }
[13:24:41.711]                     sendCondition <<- function(cond) NULL
[13:24:41.711]                   }
[13:24:41.711]                 })
[13:24:41.711]                 withCallingHandlers({
[13:24:41.711]                   {
[13:24:41.711]                     Sys.sleep(0.5)
[13:24:41.711]                     2
[13:24:41.711]                   }
[13:24:41.711]                 }, immediateCondition = function(cond) {
[13:24:41.711]                   sendCondition <- ...future.makeSendCondition()
[13:24:41.711]                   sendCondition(cond)
[13:24:41.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.711]                   {
[13:24:41.711]                     inherits <- base::inherits
[13:24:41.711]                     invokeRestart <- base::invokeRestart
[13:24:41.711]                     is.null <- base::is.null
[13:24:41.711]                     muffled <- FALSE
[13:24:41.711]                     if (inherits(cond, "message")) {
[13:24:41.711]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:41.711]                       if (muffled) 
[13:24:41.711]                         invokeRestart("muffleMessage")
[13:24:41.711]                     }
[13:24:41.711]                     else if (inherits(cond, "warning")) {
[13:24:41.711]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:41.711]                       if (muffled) 
[13:24:41.711]                         invokeRestart("muffleWarning")
[13:24:41.711]                     }
[13:24:41.711]                     else if (inherits(cond, "condition")) {
[13:24:41.711]                       if (!is.null(pattern)) {
[13:24:41.711]                         computeRestarts <- base::computeRestarts
[13:24:41.711]                         grepl <- base::grepl
[13:24:41.711]                         restarts <- computeRestarts(cond)
[13:24:41.711]                         for (restart in restarts) {
[13:24:41.711]                           name <- restart$name
[13:24:41.711]                           if (is.null(name)) 
[13:24:41.711]                             next
[13:24:41.711]                           if (!grepl(pattern, name)) 
[13:24:41.711]                             next
[13:24:41.711]                           invokeRestart(restart)
[13:24:41.711]                           muffled <- TRUE
[13:24:41.711]                           break
[13:24:41.711]                         }
[13:24:41.711]                       }
[13:24:41.711]                     }
[13:24:41.711]                     invisible(muffled)
[13:24:41.711]                   }
[13:24:41.711]                   muffleCondition(cond)
[13:24:41.711]                 })
[13:24:41.711]             }))
[13:24:41.711]             future::FutureResult(value = ...future.value$value, 
[13:24:41.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.711]                   ...future.rng), globalenv = if (FALSE) 
[13:24:41.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:41.711]                     ...future.globalenv.names))
[13:24:41.711]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:41.711]         }, condition = base::local({
[13:24:41.711]             c <- base::c
[13:24:41.711]             inherits <- base::inherits
[13:24:41.711]             invokeRestart <- base::invokeRestart
[13:24:41.711]             length <- base::length
[13:24:41.711]             list <- base::list
[13:24:41.711]             seq.int <- base::seq.int
[13:24:41.711]             signalCondition <- base::signalCondition
[13:24:41.711]             sys.calls <- base::sys.calls
[13:24:41.711]             `[[` <- base::`[[`
[13:24:41.711]             `+` <- base::`+`
[13:24:41.711]             `<<-` <- base::`<<-`
[13:24:41.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:41.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:41.711]                   3L)]
[13:24:41.711]             }
[13:24:41.711]             function(cond) {
[13:24:41.711]                 is_error <- inherits(cond, "error")
[13:24:41.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:41.711]                   NULL)
[13:24:41.711]                 if (is_error) {
[13:24:41.711]                   sessionInformation <- function() {
[13:24:41.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:41.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:41.711]                       search = base::search(), system = base::Sys.info())
[13:24:41.711]                   }
[13:24:41.711]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:41.711]                     cond$call), session = sessionInformation(), 
[13:24:41.711]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:41.711]                   signalCondition(cond)
[13:24:41.711]                 }
[13:24:41.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:41.711]                 "immediateCondition"))) {
[13:24:41.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:41.711]                   ...future.conditions[[length(...future.conditions) + 
[13:24:41.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:41.711]                   if (TRUE && !signal) {
[13:24:41.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.711]                     {
[13:24:41.711]                       inherits <- base::inherits
[13:24:41.711]                       invokeRestart <- base::invokeRestart
[13:24:41.711]                       is.null <- base::is.null
[13:24:41.711]                       muffled <- FALSE
[13:24:41.711]                       if (inherits(cond, "message")) {
[13:24:41.711]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.711]                         if (muffled) 
[13:24:41.711]                           invokeRestart("muffleMessage")
[13:24:41.711]                       }
[13:24:41.711]                       else if (inherits(cond, "warning")) {
[13:24:41.711]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.711]                         if (muffled) 
[13:24:41.711]                           invokeRestart("muffleWarning")
[13:24:41.711]                       }
[13:24:41.711]                       else if (inherits(cond, "condition")) {
[13:24:41.711]                         if (!is.null(pattern)) {
[13:24:41.711]                           computeRestarts <- base::computeRestarts
[13:24:41.711]                           grepl <- base::grepl
[13:24:41.711]                           restarts <- computeRestarts(cond)
[13:24:41.711]                           for (restart in restarts) {
[13:24:41.711]                             name <- restart$name
[13:24:41.711]                             if (is.null(name)) 
[13:24:41.711]                               next
[13:24:41.711]                             if (!grepl(pattern, name)) 
[13:24:41.711]                               next
[13:24:41.711]                             invokeRestart(restart)
[13:24:41.711]                             muffled <- TRUE
[13:24:41.711]                             break
[13:24:41.711]                           }
[13:24:41.711]                         }
[13:24:41.711]                       }
[13:24:41.711]                       invisible(muffled)
[13:24:41.711]                     }
[13:24:41.711]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.711]                   }
[13:24:41.711]                 }
[13:24:41.711]                 else {
[13:24:41.711]                   if (TRUE) {
[13:24:41.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:41.711]                     {
[13:24:41.711]                       inherits <- base::inherits
[13:24:41.711]                       invokeRestart <- base::invokeRestart
[13:24:41.711]                       is.null <- base::is.null
[13:24:41.711]                       muffled <- FALSE
[13:24:41.711]                       if (inherits(cond, "message")) {
[13:24:41.711]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:41.711]                         if (muffled) 
[13:24:41.711]                           invokeRestart("muffleMessage")
[13:24:41.711]                       }
[13:24:41.711]                       else if (inherits(cond, "warning")) {
[13:24:41.711]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:41.711]                         if (muffled) 
[13:24:41.711]                           invokeRestart("muffleWarning")
[13:24:41.711]                       }
[13:24:41.711]                       else if (inherits(cond, "condition")) {
[13:24:41.711]                         if (!is.null(pattern)) {
[13:24:41.711]                           computeRestarts <- base::computeRestarts
[13:24:41.711]                           grepl <- base::grepl
[13:24:41.711]                           restarts <- computeRestarts(cond)
[13:24:41.711]                           for (restart in restarts) {
[13:24:41.711]                             name <- restart$name
[13:24:41.711]                             if (is.null(name)) 
[13:24:41.711]                               next
[13:24:41.711]                             if (!grepl(pattern, name)) 
[13:24:41.711]                               next
[13:24:41.711]                             invokeRestart(restart)
[13:24:41.711]                             muffled <- TRUE
[13:24:41.711]                             break
[13:24:41.711]                           }
[13:24:41.711]                         }
[13:24:41.711]                       }
[13:24:41.711]                       invisible(muffled)
[13:24:41.711]                     }
[13:24:41.711]                     muffleCondition(cond, pattern = "^muffle")
[13:24:41.711]                   }
[13:24:41.711]                 }
[13:24:41.711]             }
[13:24:41.711]         }))
[13:24:41.711]     }, error = function(ex) {
[13:24:41.711]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:41.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:41.711]                 ...future.rng), started = ...future.startTime, 
[13:24:41.711]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:41.711]             version = "1.8"), class = "FutureResult")
[13:24:41.711]     }, finally = {
[13:24:41.711]         if (!identical(...future.workdir, getwd())) 
[13:24:41.711]             setwd(...future.workdir)
[13:24:41.711]         {
[13:24:41.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:41.711]                 ...future.oldOptions$nwarnings <- NULL
[13:24:41.711]             }
[13:24:41.711]             base::options(...future.oldOptions)
[13:24:41.711]             if (.Platform$OS.type == "windows") {
[13:24:41.711]                 old_names <- names(...future.oldEnvVars)
[13:24:41.711]                 envs <- base::Sys.getenv()
[13:24:41.711]                 names <- names(envs)
[13:24:41.711]                 common <- intersect(names, old_names)
[13:24:41.711]                 added <- setdiff(names, old_names)
[13:24:41.711]                 removed <- setdiff(old_names, names)
[13:24:41.711]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:41.711]                   envs[common]]
[13:24:41.711]                 NAMES <- toupper(changed)
[13:24:41.711]                 args <- list()
[13:24:41.711]                 for (kk in seq_along(NAMES)) {
[13:24:41.711]                   name <- changed[[kk]]
[13:24:41.711]                   NAME <- NAMES[[kk]]
[13:24:41.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.711]                     next
[13:24:41.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.711]                 }
[13:24:41.711]                 NAMES <- toupper(added)
[13:24:41.711]                 for (kk in seq_along(NAMES)) {
[13:24:41.711]                   name <- added[[kk]]
[13:24:41.711]                   NAME <- NAMES[[kk]]
[13:24:41.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.711]                     next
[13:24:41.711]                   args[[name]] <- ""
[13:24:41.711]                 }
[13:24:41.711]                 NAMES <- toupper(removed)
[13:24:41.711]                 for (kk in seq_along(NAMES)) {
[13:24:41.711]                   name <- removed[[kk]]
[13:24:41.711]                   NAME <- NAMES[[kk]]
[13:24:41.711]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:41.711]                     next
[13:24:41.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:41.711]                 }
[13:24:41.711]                 if (length(args) > 0) 
[13:24:41.711]                   base::do.call(base::Sys.setenv, args = args)
[13:24:41.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:41.711]             }
[13:24:41.711]             else {
[13:24:41.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:41.711]             }
[13:24:41.711]             {
[13:24:41.711]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:41.711]                   0L) {
[13:24:41.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:41.711]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:41.711]                   base::options(opts)
[13:24:41.711]                 }
[13:24:41.711]                 {
[13:24:41.711]                   {
[13:24:41.711]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:41.711]                     NULL
[13:24:41.711]                   }
[13:24:41.711]                   options(future.plan = NULL)
[13:24:41.711]                   if (is.na(NA_character_)) 
[13:24:41.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:41.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:41.711]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:41.711]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:41.711]                     envir = parent.frame()) 
[13:24:41.711]                   {
[13:24:41.711]                     if (is.function(workers)) 
[13:24:41.711]                       workers <- workers()
[13:24:41.711]                     workers <- structure(as.integer(workers), 
[13:24:41.711]                       class = class(workers))
[13:24:41.711]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:41.711]                       workers >= 1)
[13:24:41.711]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:41.711]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:41.711]                     }
[13:24:41.711]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:41.711]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:41.711]                       envir = envir)
[13:24:41.711]                     if (!future$lazy) 
[13:24:41.711]                       future <- run(future)
[13:24:41.711]                     invisible(future)
[13:24:41.711]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:41.711]                 }
[13:24:41.711]             }
[13:24:41.711]         }
[13:24:41.711]     })
[13:24:41.711]     if (TRUE) {
[13:24:41.711]         base::sink(type = "output", split = FALSE)
[13:24:41.711]         if (TRUE) {
[13:24:41.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:41.711]         }
[13:24:41.711]         else {
[13:24:41.711]             ...future.result["stdout"] <- base::list(NULL)
[13:24:41.711]         }
[13:24:41.711]         base::close(...future.stdout)
[13:24:41.711]         ...future.stdout <- NULL
[13:24:41.711]     }
[13:24:41.711]     ...future.result$conditions <- ...future.conditions
[13:24:41.711]     ...future.result$finished <- base::Sys.time()
[13:24:41.711]     ...future.result
[13:24:41.711] }
[13:24:41.715] MultisessionFuture started
[13:24:41.715] - Launch lazy future ... done
[13:24:41.715] run() for ‘MultisessionFuture’ ... done
[13:24:41.715] resolve() on list ...
[13:24:41.715]  recursive: 0
[13:24:41.715]  length: 1
[13:24:41.715] 
[13:24:41.737] receiveMessageFromWorker() for ClusterFuture ...
[13:24:41.737] - Validating connection of MultisessionFuture
[13:24:41.737] - received message: FutureResult
[13:24:41.737] - Received FutureResult
[13:24:41.738] - Erased future from FutureRegistry
[13:24:41.738] result() for ClusterFuture ...
[13:24:41.738] - result already collected: FutureResult
[13:24:41.738] result() for ClusterFuture ... done
[13:24:41.738] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:41.738] Future #1
[13:24:41.738]  length: 0 (resolved future 1)
[13:24:41.738] resolve() on list ... DONE
[13:24:41.739] resolve() on list ...
[13:24:41.739]  recursive: 0
[13:24:41.739]  length: 1
[13:24:41.739] 
[13:24:42.276] receiveMessageFromWorker() for ClusterFuture ...
[13:24:42.276] - Validating connection of MultisessionFuture
[13:24:42.276] - received message: FutureResult
[13:24:42.276] - Received FutureResult
[13:24:42.277] - Erased future from FutureRegistry
[13:24:42.277] result() for ClusterFuture ...
[13:24:42.277] - result already collected: FutureResult
[13:24:42.277] result() for ClusterFuture ... done
[13:24:42.277] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:42.277] Future #1
[13:24:42.277]  length: 0 (resolved future 1)
[13:24:42.277] resolve() on list ... DONE
[13:24:42.277] resolve() on list ...
[13:24:42.278]  recursive: 0
[13:24:42.278]  length: 1
[13:24:42.278] 
[13:24:42.278]  length: 0 (resolved future 1)
[13:24:42.278] resolve() on list ... DONE
[13:24:42.278] resolve() on list ...
[13:24:42.278]  recursive: 0
[13:24:42.278]  length: 4
[13:24:42.278] 
[13:24:42.278] Future #1
[13:24:42.279]  length: 3 (resolved future 1)
[13:24:42.279] Future #2
[13:24:42.279]  length: 2 (resolved future 2)
[13:24:42.279]  length: 1 (resolved future 3)
[13:24:42.279]  length: 0 (resolved future 4)
[13:24:42.279] resolve() on list ... DONE
[13:24:42.279] resolve() on list ...
[13:24:42.279]  recursive: 0
[13:24:42.279]  length: 4
[13:24:42.280] 
[13:24:42.280] Future #1
[13:24:42.280]  length: 3 (resolved future 1)
[13:24:42.280] Future #2
[13:24:42.280]  length: 2 (resolved future 2)
[13:24:42.280]  length: 1 (resolved future 3)
[13:24:42.280]  length: 0 (resolved future 4)
[13:24:42.280] resolve() on list ... DONE
[13:24:42.280] resolve() on list ...
[13:24:42.281]  recursive: 0
[13:24:42.281]  length: 1
[13:24:42.281] 
[13:24:42.281]  length: 0 (resolved future 1)
[13:24:42.281] resolve() on list ... DONE
[13:24:42.281] getGlobalsAndPackages() ...
[13:24:42.281] Searching for globals...
[13:24:42.282] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:42.282] Searching for globals ... DONE
[13:24:42.282] Resolving globals: FALSE
[13:24:42.283] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:42.283] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:42.283] - globals: [1] ‘kk’
[13:24:42.283] 
[13:24:42.283] getGlobalsAndPackages() ... DONE
[13:24:42.284] run() for ‘Future’ ...
[13:24:42.284] - state: ‘created’
[13:24:42.284] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:42.298] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:42.298] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:42.299]   - Field: ‘node’
[13:24:42.299]   - Field: ‘label’
[13:24:42.299]   - Field: ‘local’
[13:24:42.299]   - Field: ‘owner’
[13:24:42.299]   - Field: ‘envir’
[13:24:42.299]   - Field: ‘workers’
[13:24:42.299]   - Field: ‘packages’
[13:24:42.299]   - Field: ‘gc’
[13:24:42.299]   - Field: ‘conditions’
[13:24:42.300]   - Field: ‘persistent’
[13:24:42.300]   - Field: ‘expr’
[13:24:42.300]   - Field: ‘uuid’
[13:24:42.300]   - Field: ‘seed’
[13:24:42.300]   - Field: ‘version’
[13:24:42.300]   - Field: ‘result’
[13:24:42.300]   - Field: ‘asynchronous’
[13:24:42.300]   - Field: ‘calls’
[13:24:42.300]   - Field: ‘globals’
[13:24:42.300]   - Field: ‘stdout’
[13:24:42.301]   - Field: ‘earlySignal’
[13:24:42.301]   - Field: ‘lazy’
[13:24:42.301]   - Field: ‘state’
[13:24:42.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:42.301] - Launch lazy future ...
[13:24:42.301] Packages needed by the future expression (n = 0): <none>
[13:24:42.301] Packages needed by future strategies (n = 0): <none>
[13:24:42.302] {
[13:24:42.302]     {
[13:24:42.302]         {
[13:24:42.302]             ...future.startTime <- base::Sys.time()
[13:24:42.302]             {
[13:24:42.302]                 {
[13:24:42.302]                   {
[13:24:42.302]                     {
[13:24:42.302]                       base::local({
[13:24:42.302]                         has_future <- base::requireNamespace("future", 
[13:24:42.302]                           quietly = TRUE)
[13:24:42.302]                         if (has_future) {
[13:24:42.302]                           ns <- base::getNamespace("future")
[13:24:42.302]                           version <- ns[[".package"]][["version"]]
[13:24:42.302]                           if (is.null(version)) 
[13:24:42.302]                             version <- utils::packageVersion("future")
[13:24:42.302]                         }
[13:24:42.302]                         else {
[13:24:42.302]                           version <- NULL
[13:24:42.302]                         }
[13:24:42.302]                         if (!has_future || version < "1.8.0") {
[13:24:42.302]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:42.302]                             "", base::R.version$version.string), 
[13:24:42.302]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:42.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:42.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:42.302]                               "release", "version")], collapse = " "), 
[13:24:42.302]                             hostname = base::Sys.info()[["nodename"]])
[13:24:42.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:42.302]                             info)
[13:24:42.302]                           info <- base::paste(info, collapse = "; ")
[13:24:42.302]                           if (!has_future) {
[13:24:42.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:42.302]                               info)
[13:24:42.302]                           }
[13:24:42.302]                           else {
[13:24:42.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:42.302]                               info, version)
[13:24:42.302]                           }
[13:24:42.302]                           base::stop(msg)
[13:24:42.302]                         }
[13:24:42.302]                       })
[13:24:42.302]                     }
[13:24:42.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:42.302]                     base::options(mc.cores = 1L)
[13:24:42.302]                   }
[13:24:42.302]                   options(future.plan = NULL)
[13:24:42.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:42.302]                 }
[13:24:42.302]                 ...future.workdir <- getwd()
[13:24:42.302]             }
[13:24:42.302]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:42.302]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:42.302]         }
[13:24:42.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:42.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:42.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:42.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:42.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:42.302]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:42.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:42.302]             base::names(...future.oldOptions))
[13:24:42.302]     }
[13:24:42.302]     if (FALSE) {
[13:24:42.302]     }
[13:24:42.302]     else {
[13:24:42.302]         if (TRUE) {
[13:24:42.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:42.302]                 open = "w")
[13:24:42.302]         }
[13:24:42.302]         else {
[13:24:42.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:42.302]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:42.302]         }
[13:24:42.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:42.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:42.302]             base::sink(type = "output", split = FALSE)
[13:24:42.302]             base::close(...future.stdout)
[13:24:42.302]         }, add = TRUE)
[13:24:42.302]     }
[13:24:42.302]     ...future.frame <- base::sys.nframe()
[13:24:42.302]     ...future.conditions <- base::list()
[13:24:42.302]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:42.302]     if (FALSE) {
[13:24:42.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:42.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:42.302]     }
[13:24:42.302]     ...future.result <- base::tryCatch({
[13:24:42.302]         base::withCallingHandlers({
[13:24:42.302]             ...future.value <- base::withVisible(base::local({
[13:24:42.302]                 ...future.makeSendCondition <- base::local({
[13:24:42.302]                   sendCondition <- NULL
[13:24:42.302]                   function(frame = 1L) {
[13:24:42.302]                     if (is.function(sendCondition)) 
[13:24:42.302]                       return(sendCondition)
[13:24:42.302]                     ns <- getNamespace("parallel")
[13:24:42.302]                     if (exists("sendData", mode = "function", 
[13:24:42.302]                       envir = ns)) {
[13:24:42.302]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:42.302]                         envir = ns)
[13:24:42.302]                       envir <- sys.frame(frame)
[13:24:42.302]                       master <- NULL
[13:24:42.302]                       while (!identical(envir, .GlobalEnv) && 
[13:24:42.302]                         !identical(envir, emptyenv())) {
[13:24:42.302]                         if (exists("master", mode = "list", envir = envir, 
[13:24:42.302]                           inherits = FALSE)) {
[13:24:42.302]                           master <- get("master", mode = "list", 
[13:24:42.302]                             envir = envir, inherits = FALSE)
[13:24:42.302]                           if (inherits(master, c("SOCKnode", 
[13:24:42.302]                             "SOCK0node"))) {
[13:24:42.302]                             sendCondition <<- function(cond) {
[13:24:42.302]                               data <- list(type = "VALUE", value = cond, 
[13:24:42.302]                                 success = TRUE)
[13:24:42.302]                               parallel_sendData(master, data)
[13:24:42.302]                             }
[13:24:42.302]                             return(sendCondition)
[13:24:42.302]                           }
[13:24:42.302]                         }
[13:24:42.302]                         frame <- frame + 1L
[13:24:42.302]                         envir <- sys.frame(frame)
[13:24:42.302]                       }
[13:24:42.302]                     }
[13:24:42.302]                     sendCondition <<- function(cond) NULL
[13:24:42.302]                   }
[13:24:42.302]                 })
[13:24:42.302]                 withCallingHandlers({
[13:24:42.302]                   {
[13:24:42.302]                     Sys.sleep(0.1)
[13:24:42.302]                     kk
[13:24:42.302]                   }
[13:24:42.302]                 }, immediateCondition = function(cond) {
[13:24:42.302]                   sendCondition <- ...future.makeSendCondition()
[13:24:42.302]                   sendCondition(cond)
[13:24:42.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.302]                   {
[13:24:42.302]                     inherits <- base::inherits
[13:24:42.302]                     invokeRestart <- base::invokeRestart
[13:24:42.302]                     is.null <- base::is.null
[13:24:42.302]                     muffled <- FALSE
[13:24:42.302]                     if (inherits(cond, "message")) {
[13:24:42.302]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:42.302]                       if (muffled) 
[13:24:42.302]                         invokeRestart("muffleMessage")
[13:24:42.302]                     }
[13:24:42.302]                     else if (inherits(cond, "warning")) {
[13:24:42.302]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:42.302]                       if (muffled) 
[13:24:42.302]                         invokeRestart("muffleWarning")
[13:24:42.302]                     }
[13:24:42.302]                     else if (inherits(cond, "condition")) {
[13:24:42.302]                       if (!is.null(pattern)) {
[13:24:42.302]                         computeRestarts <- base::computeRestarts
[13:24:42.302]                         grepl <- base::grepl
[13:24:42.302]                         restarts <- computeRestarts(cond)
[13:24:42.302]                         for (restart in restarts) {
[13:24:42.302]                           name <- restart$name
[13:24:42.302]                           if (is.null(name)) 
[13:24:42.302]                             next
[13:24:42.302]                           if (!grepl(pattern, name)) 
[13:24:42.302]                             next
[13:24:42.302]                           invokeRestart(restart)
[13:24:42.302]                           muffled <- TRUE
[13:24:42.302]                           break
[13:24:42.302]                         }
[13:24:42.302]                       }
[13:24:42.302]                     }
[13:24:42.302]                     invisible(muffled)
[13:24:42.302]                   }
[13:24:42.302]                   muffleCondition(cond)
[13:24:42.302]                 })
[13:24:42.302]             }))
[13:24:42.302]             future::FutureResult(value = ...future.value$value, 
[13:24:42.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.302]                   ...future.rng), globalenv = if (FALSE) 
[13:24:42.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:42.302]                     ...future.globalenv.names))
[13:24:42.302]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:42.302]         }, condition = base::local({
[13:24:42.302]             c <- base::c
[13:24:42.302]             inherits <- base::inherits
[13:24:42.302]             invokeRestart <- base::invokeRestart
[13:24:42.302]             length <- base::length
[13:24:42.302]             list <- base::list
[13:24:42.302]             seq.int <- base::seq.int
[13:24:42.302]             signalCondition <- base::signalCondition
[13:24:42.302]             sys.calls <- base::sys.calls
[13:24:42.302]             `[[` <- base::`[[`
[13:24:42.302]             `+` <- base::`+`
[13:24:42.302]             `<<-` <- base::`<<-`
[13:24:42.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:42.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:42.302]                   3L)]
[13:24:42.302]             }
[13:24:42.302]             function(cond) {
[13:24:42.302]                 is_error <- inherits(cond, "error")
[13:24:42.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:42.302]                   NULL)
[13:24:42.302]                 if (is_error) {
[13:24:42.302]                   sessionInformation <- function() {
[13:24:42.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:42.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:42.302]                       search = base::search(), system = base::Sys.info())
[13:24:42.302]                   }
[13:24:42.302]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:42.302]                     cond$call), session = sessionInformation(), 
[13:24:42.302]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:42.302]                   signalCondition(cond)
[13:24:42.302]                 }
[13:24:42.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:42.302]                 "immediateCondition"))) {
[13:24:42.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:42.302]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:42.302]                   if (TRUE && !signal) {
[13:24:42.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.302]                     {
[13:24:42.302]                       inherits <- base::inherits
[13:24:42.302]                       invokeRestart <- base::invokeRestart
[13:24:42.302]                       is.null <- base::is.null
[13:24:42.302]                       muffled <- FALSE
[13:24:42.302]                       if (inherits(cond, "message")) {
[13:24:42.302]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.302]                         if (muffled) 
[13:24:42.302]                           invokeRestart("muffleMessage")
[13:24:42.302]                       }
[13:24:42.302]                       else if (inherits(cond, "warning")) {
[13:24:42.302]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.302]                         if (muffled) 
[13:24:42.302]                           invokeRestart("muffleWarning")
[13:24:42.302]                       }
[13:24:42.302]                       else if (inherits(cond, "condition")) {
[13:24:42.302]                         if (!is.null(pattern)) {
[13:24:42.302]                           computeRestarts <- base::computeRestarts
[13:24:42.302]                           grepl <- base::grepl
[13:24:42.302]                           restarts <- computeRestarts(cond)
[13:24:42.302]                           for (restart in restarts) {
[13:24:42.302]                             name <- restart$name
[13:24:42.302]                             if (is.null(name)) 
[13:24:42.302]                               next
[13:24:42.302]                             if (!grepl(pattern, name)) 
[13:24:42.302]                               next
[13:24:42.302]                             invokeRestart(restart)
[13:24:42.302]                             muffled <- TRUE
[13:24:42.302]                             break
[13:24:42.302]                           }
[13:24:42.302]                         }
[13:24:42.302]                       }
[13:24:42.302]                       invisible(muffled)
[13:24:42.302]                     }
[13:24:42.302]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.302]                   }
[13:24:42.302]                 }
[13:24:42.302]                 else {
[13:24:42.302]                   if (TRUE) {
[13:24:42.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.302]                     {
[13:24:42.302]                       inherits <- base::inherits
[13:24:42.302]                       invokeRestart <- base::invokeRestart
[13:24:42.302]                       is.null <- base::is.null
[13:24:42.302]                       muffled <- FALSE
[13:24:42.302]                       if (inherits(cond, "message")) {
[13:24:42.302]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.302]                         if (muffled) 
[13:24:42.302]                           invokeRestart("muffleMessage")
[13:24:42.302]                       }
[13:24:42.302]                       else if (inherits(cond, "warning")) {
[13:24:42.302]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.302]                         if (muffled) 
[13:24:42.302]                           invokeRestart("muffleWarning")
[13:24:42.302]                       }
[13:24:42.302]                       else if (inherits(cond, "condition")) {
[13:24:42.302]                         if (!is.null(pattern)) {
[13:24:42.302]                           computeRestarts <- base::computeRestarts
[13:24:42.302]                           grepl <- base::grepl
[13:24:42.302]                           restarts <- computeRestarts(cond)
[13:24:42.302]                           for (restart in restarts) {
[13:24:42.302]                             name <- restart$name
[13:24:42.302]                             if (is.null(name)) 
[13:24:42.302]                               next
[13:24:42.302]                             if (!grepl(pattern, name)) 
[13:24:42.302]                               next
[13:24:42.302]                             invokeRestart(restart)
[13:24:42.302]                             muffled <- TRUE
[13:24:42.302]                             break
[13:24:42.302]                           }
[13:24:42.302]                         }
[13:24:42.302]                       }
[13:24:42.302]                       invisible(muffled)
[13:24:42.302]                     }
[13:24:42.302]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.302]                   }
[13:24:42.302]                 }
[13:24:42.302]             }
[13:24:42.302]         }))
[13:24:42.302]     }, error = function(ex) {
[13:24:42.302]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:42.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.302]                 ...future.rng), started = ...future.startTime, 
[13:24:42.302]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:42.302]             version = "1.8"), class = "FutureResult")
[13:24:42.302]     }, finally = {
[13:24:42.302]         if (!identical(...future.workdir, getwd())) 
[13:24:42.302]             setwd(...future.workdir)
[13:24:42.302]         {
[13:24:42.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:42.302]                 ...future.oldOptions$nwarnings <- NULL
[13:24:42.302]             }
[13:24:42.302]             base::options(...future.oldOptions)
[13:24:42.302]             if (.Platform$OS.type == "windows") {
[13:24:42.302]                 old_names <- names(...future.oldEnvVars)
[13:24:42.302]                 envs <- base::Sys.getenv()
[13:24:42.302]                 names <- names(envs)
[13:24:42.302]                 common <- intersect(names, old_names)
[13:24:42.302]                 added <- setdiff(names, old_names)
[13:24:42.302]                 removed <- setdiff(old_names, names)
[13:24:42.302]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:42.302]                   envs[common]]
[13:24:42.302]                 NAMES <- toupper(changed)
[13:24:42.302]                 args <- list()
[13:24:42.302]                 for (kk in seq_along(NAMES)) {
[13:24:42.302]                   name <- changed[[kk]]
[13:24:42.302]                   NAME <- NAMES[[kk]]
[13:24:42.302]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.302]                     next
[13:24:42.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.302]                 }
[13:24:42.302]                 NAMES <- toupper(added)
[13:24:42.302]                 for (kk in seq_along(NAMES)) {
[13:24:42.302]                   name <- added[[kk]]
[13:24:42.302]                   NAME <- NAMES[[kk]]
[13:24:42.302]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.302]                     next
[13:24:42.302]                   args[[name]] <- ""
[13:24:42.302]                 }
[13:24:42.302]                 NAMES <- toupper(removed)
[13:24:42.302]                 for (kk in seq_along(NAMES)) {
[13:24:42.302]                   name <- removed[[kk]]
[13:24:42.302]                   NAME <- NAMES[[kk]]
[13:24:42.302]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.302]                     next
[13:24:42.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.302]                 }
[13:24:42.302]                 if (length(args) > 0) 
[13:24:42.302]                   base::do.call(base::Sys.setenv, args = args)
[13:24:42.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:42.302]             }
[13:24:42.302]             else {
[13:24:42.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:42.302]             }
[13:24:42.302]             {
[13:24:42.302]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:42.302]                   0L) {
[13:24:42.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:42.302]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:42.302]                   base::options(opts)
[13:24:42.302]                 }
[13:24:42.302]                 {
[13:24:42.302]                   {
[13:24:42.302]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:42.302]                     NULL
[13:24:42.302]                   }
[13:24:42.302]                   options(future.plan = NULL)
[13:24:42.302]                   if (is.na(NA_character_)) 
[13:24:42.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:42.302]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:42.302]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:42.302]                     envir = parent.frame()) 
[13:24:42.302]                   {
[13:24:42.302]                     if (is.function(workers)) 
[13:24:42.302]                       workers <- workers()
[13:24:42.302]                     workers <- structure(as.integer(workers), 
[13:24:42.302]                       class = class(workers))
[13:24:42.302]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:42.302]                       workers >= 1)
[13:24:42.302]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:42.302]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:42.302]                     }
[13:24:42.302]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:42.302]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:42.302]                       envir = envir)
[13:24:42.302]                     if (!future$lazy) 
[13:24:42.302]                       future <- run(future)
[13:24:42.302]                     invisible(future)
[13:24:42.302]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:42.302]                 }
[13:24:42.302]             }
[13:24:42.302]         }
[13:24:42.302]     })
[13:24:42.302]     if (TRUE) {
[13:24:42.302]         base::sink(type = "output", split = FALSE)
[13:24:42.302]         if (TRUE) {
[13:24:42.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:42.302]         }
[13:24:42.302]         else {
[13:24:42.302]             ...future.result["stdout"] <- base::list(NULL)
[13:24:42.302]         }
[13:24:42.302]         base::close(...future.stdout)
[13:24:42.302]         ...future.stdout <- NULL
[13:24:42.302]     }
[13:24:42.302]     ...future.result$conditions <- ...future.conditions
[13:24:42.302]     ...future.result$finished <- base::Sys.time()
[13:24:42.302]     ...future.result
[13:24:42.302] }
[13:24:42.305] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:24:42.305] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:24:42.305] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:24:42.305] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:24:42.306] MultisessionFuture started
[13:24:42.306] - Launch lazy future ... done
[13:24:42.306] run() for ‘MultisessionFuture’ ... done
[13:24:42.307] getGlobalsAndPackages() ...
[13:24:42.307] Searching for globals...
[13:24:42.308] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:42.308] Searching for globals ... DONE
[13:24:42.308] Resolving globals: FALSE
[13:24:42.308] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:42.309] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:42.309] - globals: [1] ‘kk’
[13:24:42.309] 
[13:24:42.309] getGlobalsAndPackages() ... DONE
[13:24:42.309] run() for ‘Future’ ...
[13:24:42.309] - state: ‘created’
[13:24:42.310] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:42.324] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:42.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:42.325]   - Field: ‘node’
[13:24:42.325]   - Field: ‘label’
[13:24:42.325]   - Field: ‘local’
[13:24:42.325]   - Field: ‘owner’
[13:24:42.325]   - Field: ‘envir’
[13:24:42.325]   - Field: ‘workers’
[13:24:42.325]   - Field: ‘packages’
[13:24:42.325]   - Field: ‘gc’
[13:24:42.326]   - Field: ‘conditions’
[13:24:42.326]   - Field: ‘persistent’
[13:24:42.326]   - Field: ‘expr’
[13:24:42.326]   - Field: ‘uuid’
[13:24:42.326]   - Field: ‘seed’
[13:24:42.326]   - Field: ‘version’
[13:24:42.326]   - Field: ‘result’
[13:24:42.329]   - Field: ‘asynchronous’
[13:24:42.329]   - Field: ‘calls’
[13:24:42.329]   - Field: ‘globals’
[13:24:42.330]   - Field: ‘stdout’
[13:24:42.330]   - Field: ‘earlySignal’
[13:24:42.330]   - Field: ‘lazy’
[13:24:42.330]   - Field: ‘state’
[13:24:42.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:42.330] - Launch lazy future ...
[13:24:42.330] Packages needed by the future expression (n = 0): <none>
[13:24:42.331] Packages needed by future strategies (n = 0): <none>
[13:24:42.331] {
[13:24:42.331]     {
[13:24:42.331]         {
[13:24:42.331]             ...future.startTime <- base::Sys.time()
[13:24:42.331]             {
[13:24:42.331]                 {
[13:24:42.331]                   {
[13:24:42.331]                     {
[13:24:42.331]                       base::local({
[13:24:42.331]                         has_future <- base::requireNamespace("future", 
[13:24:42.331]                           quietly = TRUE)
[13:24:42.331]                         if (has_future) {
[13:24:42.331]                           ns <- base::getNamespace("future")
[13:24:42.331]                           version <- ns[[".package"]][["version"]]
[13:24:42.331]                           if (is.null(version)) 
[13:24:42.331]                             version <- utils::packageVersion("future")
[13:24:42.331]                         }
[13:24:42.331]                         else {
[13:24:42.331]                           version <- NULL
[13:24:42.331]                         }
[13:24:42.331]                         if (!has_future || version < "1.8.0") {
[13:24:42.331]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:42.331]                             "", base::R.version$version.string), 
[13:24:42.331]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:42.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:42.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:42.331]                               "release", "version")], collapse = " "), 
[13:24:42.331]                             hostname = base::Sys.info()[["nodename"]])
[13:24:42.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:42.331]                             info)
[13:24:42.331]                           info <- base::paste(info, collapse = "; ")
[13:24:42.331]                           if (!has_future) {
[13:24:42.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:42.331]                               info)
[13:24:42.331]                           }
[13:24:42.331]                           else {
[13:24:42.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:42.331]                               info, version)
[13:24:42.331]                           }
[13:24:42.331]                           base::stop(msg)
[13:24:42.331]                         }
[13:24:42.331]                       })
[13:24:42.331]                     }
[13:24:42.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:42.331]                     base::options(mc.cores = 1L)
[13:24:42.331]                   }
[13:24:42.331]                   options(future.plan = NULL)
[13:24:42.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:42.331]                 }
[13:24:42.331]                 ...future.workdir <- getwd()
[13:24:42.331]             }
[13:24:42.331]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:42.331]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:42.331]         }
[13:24:42.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:42.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:42.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:42.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:42.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:42.331]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:42.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:42.331]             base::names(...future.oldOptions))
[13:24:42.331]     }
[13:24:42.331]     if (FALSE) {
[13:24:42.331]     }
[13:24:42.331]     else {
[13:24:42.331]         if (TRUE) {
[13:24:42.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:42.331]                 open = "w")
[13:24:42.331]         }
[13:24:42.331]         else {
[13:24:42.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:42.331]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:42.331]         }
[13:24:42.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:42.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:42.331]             base::sink(type = "output", split = FALSE)
[13:24:42.331]             base::close(...future.stdout)
[13:24:42.331]         }, add = TRUE)
[13:24:42.331]     }
[13:24:42.331]     ...future.frame <- base::sys.nframe()
[13:24:42.331]     ...future.conditions <- base::list()
[13:24:42.331]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:42.331]     if (FALSE) {
[13:24:42.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:42.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:42.331]     }
[13:24:42.331]     ...future.result <- base::tryCatch({
[13:24:42.331]         base::withCallingHandlers({
[13:24:42.331]             ...future.value <- base::withVisible(base::local({
[13:24:42.331]                 ...future.makeSendCondition <- base::local({
[13:24:42.331]                   sendCondition <- NULL
[13:24:42.331]                   function(frame = 1L) {
[13:24:42.331]                     if (is.function(sendCondition)) 
[13:24:42.331]                       return(sendCondition)
[13:24:42.331]                     ns <- getNamespace("parallel")
[13:24:42.331]                     if (exists("sendData", mode = "function", 
[13:24:42.331]                       envir = ns)) {
[13:24:42.331]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:42.331]                         envir = ns)
[13:24:42.331]                       envir <- sys.frame(frame)
[13:24:42.331]                       master <- NULL
[13:24:42.331]                       while (!identical(envir, .GlobalEnv) && 
[13:24:42.331]                         !identical(envir, emptyenv())) {
[13:24:42.331]                         if (exists("master", mode = "list", envir = envir, 
[13:24:42.331]                           inherits = FALSE)) {
[13:24:42.331]                           master <- get("master", mode = "list", 
[13:24:42.331]                             envir = envir, inherits = FALSE)
[13:24:42.331]                           if (inherits(master, c("SOCKnode", 
[13:24:42.331]                             "SOCK0node"))) {
[13:24:42.331]                             sendCondition <<- function(cond) {
[13:24:42.331]                               data <- list(type = "VALUE", value = cond, 
[13:24:42.331]                                 success = TRUE)
[13:24:42.331]                               parallel_sendData(master, data)
[13:24:42.331]                             }
[13:24:42.331]                             return(sendCondition)
[13:24:42.331]                           }
[13:24:42.331]                         }
[13:24:42.331]                         frame <- frame + 1L
[13:24:42.331]                         envir <- sys.frame(frame)
[13:24:42.331]                       }
[13:24:42.331]                     }
[13:24:42.331]                     sendCondition <<- function(cond) NULL
[13:24:42.331]                   }
[13:24:42.331]                 })
[13:24:42.331]                 withCallingHandlers({
[13:24:42.331]                   {
[13:24:42.331]                     Sys.sleep(0.1)
[13:24:42.331]                     kk
[13:24:42.331]                   }
[13:24:42.331]                 }, immediateCondition = function(cond) {
[13:24:42.331]                   sendCondition <- ...future.makeSendCondition()
[13:24:42.331]                   sendCondition(cond)
[13:24:42.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.331]                   {
[13:24:42.331]                     inherits <- base::inherits
[13:24:42.331]                     invokeRestart <- base::invokeRestart
[13:24:42.331]                     is.null <- base::is.null
[13:24:42.331]                     muffled <- FALSE
[13:24:42.331]                     if (inherits(cond, "message")) {
[13:24:42.331]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:42.331]                       if (muffled) 
[13:24:42.331]                         invokeRestart("muffleMessage")
[13:24:42.331]                     }
[13:24:42.331]                     else if (inherits(cond, "warning")) {
[13:24:42.331]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:42.331]                       if (muffled) 
[13:24:42.331]                         invokeRestart("muffleWarning")
[13:24:42.331]                     }
[13:24:42.331]                     else if (inherits(cond, "condition")) {
[13:24:42.331]                       if (!is.null(pattern)) {
[13:24:42.331]                         computeRestarts <- base::computeRestarts
[13:24:42.331]                         grepl <- base::grepl
[13:24:42.331]                         restarts <- computeRestarts(cond)
[13:24:42.331]                         for (restart in restarts) {
[13:24:42.331]                           name <- restart$name
[13:24:42.331]                           if (is.null(name)) 
[13:24:42.331]                             next
[13:24:42.331]                           if (!grepl(pattern, name)) 
[13:24:42.331]                             next
[13:24:42.331]                           invokeRestart(restart)
[13:24:42.331]                           muffled <- TRUE
[13:24:42.331]                           break
[13:24:42.331]                         }
[13:24:42.331]                       }
[13:24:42.331]                     }
[13:24:42.331]                     invisible(muffled)
[13:24:42.331]                   }
[13:24:42.331]                   muffleCondition(cond)
[13:24:42.331]                 })
[13:24:42.331]             }))
[13:24:42.331]             future::FutureResult(value = ...future.value$value, 
[13:24:42.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.331]                   ...future.rng), globalenv = if (FALSE) 
[13:24:42.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:42.331]                     ...future.globalenv.names))
[13:24:42.331]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:42.331]         }, condition = base::local({
[13:24:42.331]             c <- base::c
[13:24:42.331]             inherits <- base::inherits
[13:24:42.331]             invokeRestart <- base::invokeRestart
[13:24:42.331]             length <- base::length
[13:24:42.331]             list <- base::list
[13:24:42.331]             seq.int <- base::seq.int
[13:24:42.331]             signalCondition <- base::signalCondition
[13:24:42.331]             sys.calls <- base::sys.calls
[13:24:42.331]             `[[` <- base::`[[`
[13:24:42.331]             `+` <- base::`+`
[13:24:42.331]             `<<-` <- base::`<<-`
[13:24:42.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:42.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:42.331]                   3L)]
[13:24:42.331]             }
[13:24:42.331]             function(cond) {
[13:24:42.331]                 is_error <- inherits(cond, "error")
[13:24:42.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:42.331]                   NULL)
[13:24:42.331]                 if (is_error) {
[13:24:42.331]                   sessionInformation <- function() {
[13:24:42.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:42.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:42.331]                       search = base::search(), system = base::Sys.info())
[13:24:42.331]                   }
[13:24:42.331]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:42.331]                     cond$call), session = sessionInformation(), 
[13:24:42.331]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:42.331]                   signalCondition(cond)
[13:24:42.331]                 }
[13:24:42.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:42.331]                 "immediateCondition"))) {
[13:24:42.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:42.331]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:42.331]                   if (TRUE && !signal) {
[13:24:42.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.331]                     {
[13:24:42.331]                       inherits <- base::inherits
[13:24:42.331]                       invokeRestart <- base::invokeRestart
[13:24:42.331]                       is.null <- base::is.null
[13:24:42.331]                       muffled <- FALSE
[13:24:42.331]                       if (inherits(cond, "message")) {
[13:24:42.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.331]                         if (muffled) 
[13:24:42.331]                           invokeRestart("muffleMessage")
[13:24:42.331]                       }
[13:24:42.331]                       else if (inherits(cond, "warning")) {
[13:24:42.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.331]                         if (muffled) 
[13:24:42.331]                           invokeRestart("muffleWarning")
[13:24:42.331]                       }
[13:24:42.331]                       else if (inherits(cond, "condition")) {
[13:24:42.331]                         if (!is.null(pattern)) {
[13:24:42.331]                           computeRestarts <- base::computeRestarts
[13:24:42.331]                           grepl <- base::grepl
[13:24:42.331]                           restarts <- computeRestarts(cond)
[13:24:42.331]                           for (restart in restarts) {
[13:24:42.331]                             name <- restart$name
[13:24:42.331]                             if (is.null(name)) 
[13:24:42.331]                               next
[13:24:42.331]                             if (!grepl(pattern, name)) 
[13:24:42.331]                               next
[13:24:42.331]                             invokeRestart(restart)
[13:24:42.331]                             muffled <- TRUE
[13:24:42.331]                             break
[13:24:42.331]                           }
[13:24:42.331]                         }
[13:24:42.331]                       }
[13:24:42.331]                       invisible(muffled)
[13:24:42.331]                     }
[13:24:42.331]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.331]                   }
[13:24:42.331]                 }
[13:24:42.331]                 else {
[13:24:42.331]                   if (TRUE) {
[13:24:42.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.331]                     {
[13:24:42.331]                       inherits <- base::inherits
[13:24:42.331]                       invokeRestart <- base::invokeRestart
[13:24:42.331]                       is.null <- base::is.null
[13:24:42.331]                       muffled <- FALSE
[13:24:42.331]                       if (inherits(cond, "message")) {
[13:24:42.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.331]                         if (muffled) 
[13:24:42.331]                           invokeRestart("muffleMessage")
[13:24:42.331]                       }
[13:24:42.331]                       else if (inherits(cond, "warning")) {
[13:24:42.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.331]                         if (muffled) 
[13:24:42.331]                           invokeRestart("muffleWarning")
[13:24:42.331]                       }
[13:24:42.331]                       else if (inherits(cond, "condition")) {
[13:24:42.331]                         if (!is.null(pattern)) {
[13:24:42.331]                           computeRestarts <- base::computeRestarts
[13:24:42.331]                           grepl <- base::grepl
[13:24:42.331]                           restarts <- computeRestarts(cond)
[13:24:42.331]                           for (restart in restarts) {
[13:24:42.331]                             name <- restart$name
[13:24:42.331]                             if (is.null(name)) 
[13:24:42.331]                               next
[13:24:42.331]                             if (!grepl(pattern, name)) 
[13:24:42.331]                               next
[13:24:42.331]                             invokeRestart(restart)
[13:24:42.331]                             muffled <- TRUE
[13:24:42.331]                             break
[13:24:42.331]                           }
[13:24:42.331]                         }
[13:24:42.331]                       }
[13:24:42.331]                       invisible(muffled)
[13:24:42.331]                     }
[13:24:42.331]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.331]                   }
[13:24:42.331]                 }
[13:24:42.331]             }
[13:24:42.331]         }))
[13:24:42.331]     }, error = function(ex) {
[13:24:42.331]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:42.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.331]                 ...future.rng), started = ...future.startTime, 
[13:24:42.331]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:42.331]             version = "1.8"), class = "FutureResult")
[13:24:42.331]     }, finally = {
[13:24:42.331]         if (!identical(...future.workdir, getwd())) 
[13:24:42.331]             setwd(...future.workdir)
[13:24:42.331]         {
[13:24:42.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:42.331]                 ...future.oldOptions$nwarnings <- NULL
[13:24:42.331]             }
[13:24:42.331]             base::options(...future.oldOptions)
[13:24:42.331]             if (.Platform$OS.type == "windows") {
[13:24:42.331]                 old_names <- names(...future.oldEnvVars)
[13:24:42.331]                 envs <- base::Sys.getenv()
[13:24:42.331]                 names <- names(envs)
[13:24:42.331]                 common <- intersect(names, old_names)
[13:24:42.331]                 added <- setdiff(names, old_names)
[13:24:42.331]                 removed <- setdiff(old_names, names)
[13:24:42.331]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:42.331]                   envs[common]]
[13:24:42.331]                 NAMES <- toupper(changed)
[13:24:42.331]                 args <- list()
[13:24:42.331]                 for (kk in seq_along(NAMES)) {
[13:24:42.331]                   name <- changed[[kk]]
[13:24:42.331]                   NAME <- NAMES[[kk]]
[13:24:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.331]                     next
[13:24:42.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.331]                 }
[13:24:42.331]                 NAMES <- toupper(added)
[13:24:42.331]                 for (kk in seq_along(NAMES)) {
[13:24:42.331]                   name <- added[[kk]]
[13:24:42.331]                   NAME <- NAMES[[kk]]
[13:24:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.331]                     next
[13:24:42.331]                   args[[name]] <- ""
[13:24:42.331]                 }
[13:24:42.331]                 NAMES <- toupper(removed)
[13:24:42.331]                 for (kk in seq_along(NAMES)) {
[13:24:42.331]                   name <- removed[[kk]]
[13:24:42.331]                   NAME <- NAMES[[kk]]
[13:24:42.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.331]                     next
[13:24:42.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.331]                 }
[13:24:42.331]                 if (length(args) > 0) 
[13:24:42.331]                   base::do.call(base::Sys.setenv, args = args)
[13:24:42.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:42.331]             }
[13:24:42.331]             else {
[13:24:42.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:42.331]             }
[13:24:42.331]             {
[13:24:42.331]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:42.331]                   0L) {
[13:24:42.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:42.331]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:42.331]                   base::options(opts)
[13:24:42.331]                 }
[13:24:42.331]                 {
[13:24:42.331]                   {
[13:24:42.331]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:42.331]                     NULL
[13:24:42.331]                   }
[13:24:42.331]                   options(future.plan = NULL)
[13:24:42.331]                   if (is.na(NA_character_)) 
[13:24:42.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:42.331]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:42.331]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:42.331]                     envir = parent.frame()) 
[13:24:42.331]                   {
[13:24:42.331]                     if (is.function(workers)) 
[13:24:42.331]                       workers <- workers()
[13:24:42.331]                     workers <- structure(as.integer(workers), 
[13:24:42.331]                       class = class(workers))
[13:24:42.331]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:42.331]                       workers >= 1)
[13:24:42.331]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:42.331]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:42.331]                     }
[13:24:42.331]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:42.331]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:42.331]                       envir = envir)
[13:24:42.331]                     if (!future$lazy) 
[13:24:42.331]                       future <- run(future)
[13:24:42.331]                     invisible(future)
[13:24:42.331]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:42.331]                 }
[13:24:42.331]             }
[13:24:42.331]         }
[13:24:42.331]     })
[13:24:42.331]     if (TRUE) {
[13:24:42.331]         base::sink(type = "output", split = FALSE)
[13:24:42.331]         if (TRUE) {
[13:24:42.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:42.331]         }
[13:24:42.331]         else {
[13:24:42.331]             ...future.result["stdout"] <- base::list(NULL)
[13:24:42.331]         }
[13:24:42.331]         base::close(...future.stdout)
[13:24:42.331]         ...future.stdout <- NULL
[13:24:42.331]     }
[13:24:42.331]     ...future.result$conditions <- ...future.conditions
[13:24:42.331]     ...future.result$finished <- base::Sys.time()
[13:24:42.331]     ...future.result
[13:24:42.331] }
[13:24:42.334] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:24:42.334] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[13:24:42.335] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[13:24:42.335] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:24:42.336] MultisessionFuture started
[13:24:42.336] - Launch lazy future ... done
[13:24:42.336] run() for ‘MultisessionFuture’ ... done
[13:24:42.336] getGlobalsAndPackages() ...
[13:24:42.336] Searching for globals...
[13:24:42.337] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:42.337] Searching for globals ... DONE
[13:24:42.337] Resolving globals: FALSE
[13:24:42.338] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:42.338] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:42.338] - globals: [1] ‘kk’
[13:24:42.338] 
[13:24:42.338] getGlobalsAndPackages() ... DONE
[13:24:42.339] run() for ‘Future’ ...
[13:24:42.339] - state: ‘created’
[13:24:42.339] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:42.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:42.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:42.354]   - Field: ‘node’
[13:24:42.354]   - Field: ‘label’
[13:24:42.354]   - Field: ‘local’
[13:24:42.354]   - Field: ‘owner’
[13:24:42.354]   - Field: ‘envir’
[13:24:42.354]   - Field: ‘workers’
[13:24:42.354]   - Field: ‘packages’
[13:24:42.354]   - Field: ‘gc’
[13:24:42.354]   - Field: ‘conditions’
[13:24:42.355]   - Field: ‘persistent’
[13:24:42.355]   - Field: ‘expr’
[13:24:42.355]   - Field: ‘uuid’
[13:24:42.355]   - Field: ‘seed’
[13:24:42.355]   - Field: ‘version’
[13:24:42.355]   - Field: ‘result’
[13:24:42.355]   - Field: ‘asynchronous’
[13:24:42.355]   - Field: ‘calls’
[13:24:42.355]   - Field: ‘globals’
[13:24:42.355]   - Field: ‘stdout’
[13:24:42.355]   - Field: ‘earlySignal’
[13:24:42.356]   - Field: ‘lazy’
[13:24:42.356]   - Field: ‘state’
[13:24:42.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:42.356] - Launch lazy future ...
[13:24:42.356] Packages needed by the future expression (n = 0): <none>
[13:24:42.356] Packages needed by future strategies (n = 0): <none>
[13:24:42.357] {
[13:24:42.357]     {
[13:24:42.357]         {
[13:24:42.357]             ...future.startTime <- base::Sys.time()
[13:24:42.357]             {
[13:24:42.357]                 {
[13:24:42.357]                   {
[13:24:42.357]                     {
[13:24:42.357]                       base::local({
[13:24:42.357]                         has_future <- base::requireNamespace("future", 
[13:24:42.357]                           quietly = TRUE)
[13:24:42.357]                         if (has_future) {
[13:24:42.357]                           ns <- base::getNamespace("future")
[13:24:42.357]                           version <- ns[[".package"]][["version"]]
[13:24:42.357]                           if (is.null(version)) 
[13:24:42.357]                             version <- utils::packageVersion("future")
[13:24:42.357]                         }
[13:24:42.357]                         else {
[13:24:42.357]                           version <- NULL
[13:24:42.357]                         }
[13:24:42.357]                         if (!has_future || version < "1.8.0") {
[13:24:42.357]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:42.357]                             "", base::R.version$version.string), 
[13:24:42.357]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:42.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:42.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:42.357]                               "release", "version")], collapse = " "), 
[13:24:42.357]                             hostname = base::Sys.info()[["nodename"]])
[13:24:42.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:42.357]                             info)
[13:24:42.357]                           info <- base::paste(info, collapse = "; ")
[13:24:42.357]                           if (!has_future) {
[13:24:42.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:42.357]                               info)
[13:24:42.357]                           }
[13:24:42.357]                           else {
[13:24:42.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:42.357]                               info, version)
[13:24:42.357]                           }
[13:24:42.357]                           base::stop(msg)
[13:24:42.357]                         }
[13:24:42.357]                       })
[13:24:42.357]                     }
[13:24:42.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:42.357]                     base::options(mc.cores = 1L)
[13:24:42.357]                   }
[13:24:42.357]                   options(future.plan = NULL)
[13:24:42.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:42.357]                 }
[13:24:42.357]                 ...future.workdir <- getwd()
[13:24:42.357]             }
[13:24:42.357]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:42.357]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:42.357]         }
[13:24:42.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:42.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:42.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:42.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:42.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:42.357]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:42.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:42.357]             base::names(...future.oldOptions))
[13:24:42.357]     }
[13:24:42.357]     if (FALSE) {
[13:24:42.357]     }
[13:24:42.357]     else {
[13:24:42.357]         if (TRUE) {
[13:24:42.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:42.357]                 open = "w")
[13:24:42.357]         }
[13:24:42.357]         else {
[13:24:42.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:42.357]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:42.357]         }
[13:24:42.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:42.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:42.357]             base::sink(type = "output", split = FALSE)
[13:24:42.357]             base::close(...future.stdout)
[13:24:42.357]         }, add = TRUE)
[13:24:42.357]     }
[13:24:42.357]     ...future.frame <- base::sys.nframe()
[13:24:42.357]     ...future.conditions <- base::list()
[13:24:42.357]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:42.357]     if (FALSE) {
[13:24:42.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:42.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:42.357]     }
[13:24:42.357]     ...future.result <- base::tryCatch({
[13:24:42.357]         base::withCallingHandlers({
[13:24:42.357]             ...future.value <- base::withVisible(base::local({
[13:24:42.357]                 ...future.makeSendCondition <- base::local({
[13:24:42.357]                   sendCondition <- NULL
[13:24:42.357]                   function(frame = 1L) {
[13:24:42.357]                     if (is.function(sendCondition)) 
[13:24:42.357]                       return(sendCondition)
[13:24:42.357]                     ns <- getNamespace("parallel")
[13:24:42.357]                     if (exists("sendData", mode = "function", 
[13:24:42.357]                       envir = ns)) {
[13:24:42.357]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:42.357]                         envir = ns)
[13:24:42.357]                       envir <- sys.frame(frame)
[13:24:42.357]                       master <- NULL
[13:24:42.357]                       while (!identical(envir, .GlobalEnv) && 
[13:24:42.357]                         !identical(envir, emptyenv())) {
[13:24:42.357]                         if (exists("master", mode = "list", envir = envir, 
[13:24:42.357]                           inherits = FALSE)) {
[13:24:42.357]                           master <- get("master", mode = "list", 
[13:24:42.357]                             envir = envir, inherits = FALSE)
[13:24:42.357]                           if (inherits(master, c("SOCKnode", 
[13:24:42.357]                             "SOCK0node"))) {
[13:24:42.357]                             sendCondition <<- function(cond) {
[13:24:42.357]                               data <- list(type = "VALUE", value = cond, 
[13:24:42.357]                                 success = TRUE)
[13:24:42.357]                               parallel_sendData(master, data)
[13:24:42.357]                             }
[13:24:42.357]                             return(sendCondition)
[13:24:42.357]                           }
[13:24:42.357]                         }
[13:24:42.357]                         frame <- frame + 1L
[13:24:42.357]                         envir <- sys.frame(frame)
[13:24:42.357]                       }
[13:24:42.357]                     }
[13:24:42.357]                     sendCondition <<- function(cond) NULL
[13:24:42.357]                   }
[13:24:42.357]                 })
[13:24:42.357]                 withCallingHandlers({
[13:24:42.357]                   {
[13:24:42.357]                     Sys.sleep(0.1)
[13:24:42.357]                     kk
[13:24:42.357]                   }
[13:24:42.357]                 }, immediateCondition = function(cond) {
[13:24:42.357]                   sendCondition <- ...future.makeSendCondition()
[13:24:42.357]                   sendCondition(cond)
[13:24:42.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.357]                   {
[13:24:42.357]                     inherits <- base::inherits
[13:24:42.357]                     invokeRestart <- base::invokeRestart
[13:24:42.357]                     is.null <- base::is.null
[13:24:42.357]                     muffled <- FALSE
[13:24:42.357]                     if (inherits(cond, "message")) {
[13:24:42.357]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:42.357]                       if (muffled) 
[13:24:42.357]                         invokeRestart("muffleMessage")
[13:24:42.357]                     }
[13:24:42.357]                     else if (inherits(cond, "warning")) {
[13:24:42.357]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:42.357]                       if (muffled) 
[13:24:42.357]                         invokeRestart("muffleWarning")
[13:24:42.357]                     }
[13:24:42.357]                     else if (inherits(cond, "condition")) {
[13:24:42.357]                       if (!is.null(pattern)) {
[13:24:42.357]                         computeRestarts <- base::computeRestarts
[13:24:42.357]                         grepl <- base::grepl
[13:24:42.357]                         restarts <- computeRestarts(cond)
[13:24:42.357]                         for (restart in restarts) {
[13:24:42.357]                           name <- restart$name
[13:24:42.357]                           if (is.null(name)) 
[13:24:42.357]                             next
[13:24:42.357]                           if (!grepl(pattern, name)) 
[13:24:42.357]                             next
[13:24:42.357]                           invokeRestart(restart)
[13:24:42.357]                           muffled <- TRUE
[13:24:42.357]                           break
[13:24:42.357]                         }
[13:24:42.357]                       }
[13:24:42.357]                     }
[13:24:42.357]                     invisible(muffled)
[13:24:42.357]                   }
[13:24:42.357]                   muffleCondition(cond)
[13:24:42.357]                 })
[13:24:42.357]             }))
[13:24:42.357]             future::FutureResult(value = ...future.value$value, 
[13:24:42.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.357]                   ...future.rng), globalenv = if (FALSE) 
[13:24:42.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:42.357]                     ...future.globalenv.names))
[13:24:42.357]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:42.357]         }, condition = base::local({
[13:24:42.357]             c <- base::c
[13:24:42.357]             inherits <- base::inherits
[13:24:42.357]             invokeRestart <- base::invokeRestart
[13:24:42.357]             length <- base::length
[13:24:42.357]             list <- base::list
[13:24:42.357]             seq.int <- base::seq.int
[13:24:42.357]             signalCondition <- base::signalCondition
[13:24:42.357]             sys.calls <- base::sys.calls
[13:24:42.357]             `[[` <- base::`[[`
[13:24:42.357]             `+` <- base::`+`
[13:24:42.357]             `<<-` <- base::`<<-`
[13:24:42.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:42.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:42.357]                   3L)]
[13:24:42.357]             }
[13:24:42.357]             function(cond) {
[13:24:42.357]                 is_error <- inherits(cond, "error")
[13:24:42.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:42.357]                   NULL)
[13:24:42.357]                 if (is_error) {
[13:24:42.357]                   sessionInformation <- function() {
[13:24:42.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:42.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:42.357]                       search = base::search(), system = base::Sys.info())
[13:24:42.357]                   }
[13:24:42.357]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:42.357]                     cond$call), session = sessionInformation(), 
[13:24:42.357]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:42.357]                   signalCondition(cond)
[13:24:42.357]                 }
[13:24:42.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:42.357]                 "immediateCondition"))) {
[13:24:42.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:42.357]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:42.357]                   if (TRUE && !signal) {
[13:24:42.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.357]                     {
[13:24:42.357]                       inherits <- base::inherits
[13:24:42.357]                       invokeRestart <- base::invokeRestart
[13:24:42.357]                       is.null <- base::is.null
[13:24:42.357]                       muffled <- FALSE
[13:24:42.357]                       if (inherits(cond, "message")) {
[13:24:42.357]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.357]                         if (muffled) 
[13:24:42.357]                           invokeRestart("muffleMessage")
[13:24:42.357]                       }
[13:24:42.357]                       else if (inherits(cond, "warning")) {
[13:24:42.357]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.357]                         if (muffled) 
[13:24:42.357]                           invokeRestart("muffleWarning")
[13:24:42.357]                       }
[13:24:42.357]                       else if (inherits(cond, "condition")) {
[13:24:42.357]                         if (!is.null(pattern)) {
[13:24:42.357]                           computeRestarts <- base::computeRestarts
[13:24:42.357]                           grepl <- base::grepl
[13:24:42.357]                           restarts <- computeRestarts(cond)
[13:24:42.357]                           for (restart in restarts) {
[13:24:42.357]                             name <- restart$name
[13:24:42.357]                             if (is.null(name)) 
[13:24:42.357]                               next
[13:24:42.357]                             if (!grepl(pattern, name)) 
[13:24:42.357]                               next
[13:24:42.357]                             invokeRestart(restart)
[13:24:42.357]                             muffled <- TRUE
[13:24:42.357]                             break
[13:24:42.357]                           }
[13:24:42.357]                         }
[13:24:42.357]                       }
[13:24:42.357]                       invisible(muffled)
[13:24:42.357]                     }
[13:24:42.357]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.357]                   }
[13:24:42.357]                 }
[13:24:42.357]                 else {
[13:24:42.357]                   if (TRUE) {
[13:24:42.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.357]                     {
[13:24:42.357]                       inherits <- base::inherits
[13:24:42.357]                       invokeRestart <- base::invokeRestart
[13:24:42.357]                       is.null <- base::is.null
[13:24:42.357]                       muffled <- FALSE
[13:24:42.357]                       if (inherits(cond, "message")) {
[13:24:42.357]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.357]                         if (muffled) 
[13:24:42.357]                           invokeRestart("muffleMessage")
[13:24:42.357]                       }
[13:24:42.357]                       else if (inherits(cond, "warning")) {
[13:24:42.357]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.357]                         if (muffled) 
[13:24:42.357]                           invokeRestart("muffleWarning")
[13:24:42.357]                       }
[13:24:42.357]                       else if (inherits(cond, "condition")) {
[13:24:42.357]                         if (!is.null(pattern)) {
[13:24:42.357]                           computeRestarts <- base::computeRestarts
[13:24:42.357]                           grepl <- base::grepl
[13:24:42.357]                           restarts <- computeRestarts(cond)
[13:24:42.357]                           for (restart in restarts) {
[13:24:42.357]                             name <- restart$name
[13:24:42.357]                             if (is.null(name)) 
[13:24:42.357]                               next
[13:24:42.357]                             if (!grepl(pattern, name)) 
[13:24:42.357]                               next
[13:24:42.357]                             invokeRestart(restart)
[13:24:42.357]                             muffled <- TRUE
[13:24:42.357]                             break
[13:24:42.357]                           }
[13:24:42.357]                         }
[13:24:42.357]                       }
[13:24:42.357]                       invisible(muffled)
[13:24:42.357]                     }
[13:24:42.357]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.357]                   }
[13:24:42.357]                 }
[13:24:42.357]             }
[13:24:42.357]         }))
[13:24:42.357]     }, error = function(ex) {
[13:24:42.357]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:42.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.357]                 ...future.rng), started = ...future.startTime, 
[13:24:42.357]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:42.357]             version = "1.8"), class = "FutureResult")
[13:24:42.357]     }, finally = {
[13:24:42.357]         if (!identical(...future.workdir, getwd())) 
[13:24:42.357]             setwd(...future.workdir)
[13:24:42.357]         {
[13:24:42.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:42.357]                 ...future.oldOptions$nwarnings <- NULL
[13:24:42.357]             }
[13:24:42.357]             base::options(...future.oldOptions)
[13:24:42.357]             if (.Platform$OS.type == "windows") {
[13:24:42.357]                 old_names <- names(...future.oldEnvVars)
[13:24:42.357]                 envs <- base::Sys.getenv()
[13:24:42.357]                 names <- names(envs)
[13:24:42.357]                 common <- intersect(names, old_names)
[13:24:42.357]                 added <- setdiff(names, old_names)
[13:24:42.357]                 removed <- setdiff(old_names, names)
[13:24:42.357]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:42.357]                   envs[common]]
[13:24:42.357]                 NAMES <- toupper(changed)
[13:24:42.357]                 args <- list()
[13:24:42.357]                 for (kk in seq_along(NAMES)) {
[13:24:42.357]                   name <- changed[[kk]]
[13:24:42.357]                   NAME <- NAMES[[kk]]
[13:24:42.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.357]                     next
[13:24:42.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.357]                 }
[13:24:42.357]                 NAMES <- toupper(added)
[13:24:42.357]                 for (kk in seq_along(NAMES)) {
[13:24:42.357]                   name <- added[[kk]]
[13:24:42.357]                   NAME <- NAMES[[kk]]
[13:24:42.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.357]                     next
[13:24:42.357]                   args[[name]] <- ""
[13:24:42.357]                 }
[13:24:42.357]                 NAMES <- toupper(removed)
[13:24:42.357]                 for (kk in seq_along(NAMES)) {
[13:24:42.357]                   name <- removed[[kk]]
[13:24:42.357]                   NAME <- NAMES[[kk]]
[13:24:42.357]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.357]                     next
[13:24:42.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.357]                 }
[13:24:42.357]                 if (length(args) > 0) 
[13:24:42.357]                   base::do.call(base::Sys.setenv, args = args)
[13:24:42.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:42.357]             }
[13:24:42.357]             else {
[13:24:42.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:42.357]             }
[13:24:42.357]             {
[13:24:42.357]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:42.357]                   0L) {
[13:24:42.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:42.357]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:42.357]                   base::options(opts)
[13:24:42.357]                 }
[13:24:42.357]                 {
[13:24:42.357]                   {
[13:24:42.357]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:42.357]                     NULL
[13:24:42.357]                   }
[13:24:42.357]                   options(future.plan = NULL)
[13:24:42.357]                   if (is.na(NA_character_)) 
[13:24:42.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:42.357]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:42.357]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:42.357]                     envir = parent.frame()) 
[13:24:42.357]                   {
[13:24:42.357]                     if (is.function(workers)) 
[13:24:42.357]                       workers <- workers()
[13:24:42.357]                     workers <- structure(as.integer(workers), 
[13:24:42.357]                       class = class(workers))
[13:24:42.357]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:42.357]                       workers >= 1)
[13:24:42.357]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:42.357]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:42.357]                     }
[13:24:42.357]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:42.357]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:42.357]                       envir = envir)
[13:24:42.357]                     if (!future$lazy) 
[13:24:42.357]                       future <- run(future)
[13:24:42.357]                     invisible(future)
[13:24:42.357]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:42.357]                 }
[13:24:42.357]             }
[13:24:42.357]         }
[13:24:42.357]     })
[13:24:42.357]     if (TRUE) {
[13:24:42.357]         base::sink(type = "output", split = FALSE)
[13:24:42.357]         if (TRUE) {
[13:24:42.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:42.357]         }
[13:24:42.357]         else {
[13:24:42.357]             ...future.result["stdout"] <- base::list(NULL)
[13:24:42.357]         }
[13:24:42.357]         base::close(...future.stdout)
[13:24:42.357]         ...future.stdout <- NULL
[13:24:42.357]     }
[13:24:42.357]     ...future.result$conditions <- ...future.conditions
[13:24:42.357]     ...future.result$finished <- base::Sys.time()
[13:24:42.357]     ...future.result
[13:24:42.357] }
[13:24:42.359] Poll #1 (0): usedNodes() = 2, workers = 2
[13:24:42.391] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[13:24:42.423] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[13:24:42.455] Poll #4 (0.1 secs): usedNodes() = 2, workers = 2
[13:24:42.466] receiveMessageFromWorker() for ClusterFuture ...
[13:24:42.466] - Validating connection of MultisessionFuture
[13:24:42.466] - received message: FutureResult
[13:24:42.466] - Received FutureResult
[13:24:42.466] - Erased future from FutureRegistry
[13:24:42.467] result() for ClusterFuture ...
[13:24:42.467] - result already collected: FutureResult
[13:24:42.467] result() for ClusterFuture ... done
[13:24:42.467] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:42.467] result() for ClusterFuture ...
[13:24:42.467] - result already collected: FutureResult
[13:24:42.467] result() for ClusterFuture ... done
[13:24:42.467] result() for ClusterFuture ...
[13:24:42.467] - result already collected: FutureResult
[13:24:42.467] result() for ClusterFuture ... done
[13:24:42.468] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:24:42.468] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:24:42.469] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:24:42.469] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:24:42.469] MultisessionFuture started
[13:24:42.470] - Launch lazy future ... done
[13:24:42.470] run() for ‘MultisessionFuture’ ... done
[13:24:42.470] resolve() on list ...
[13:24:42.470]  recursive: 0
[13:24:42.470]  length: 3
[13:24:42.470] 
[13:24:42.470] Future #1
[13:24:42.470]  length: 2 (resolved future 1)
[13:24:42.502] receiveMessageFromWorker() for ClusterFuture ...
[13:24:42.503] - Validating connection of MultisessionFuture
[13:24:42.503] - received message: FutureResult
[13:24:42.503] - Received FutureResult
[13:24:42.503] - Erased future from FutureRegistry
[13:24:42.503] result() for ClusterFuture ...
[13:24:42.503] - result already collected: FutureResult
[13:24:42.503] result() for ClusterFuture ... done
[13:24:42.503] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:42.504] Future #2
[13:24:42.504]  length: 1 (resolved future 2)
[13:24:42.629] receiveMessageFromWorker() for ClusterFuture ...
[13:24:42.629] - Validating connection of MultisessionFuture
[13:24:42.629] - received message: FutureResult
[13:24:42.629] - Received FutureResult
[13:24:42.629] - Erased future from FutureRegistry
[13:24:42.630] result() for ClusterFuture ...
[13:24:42.630] - result already collected: FutureResult
[13:24:42.630] result() for ClusterFuture ... done
[13:24:42.630] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:42.630] Future #3
[13:24:42.630]  length: 0 (resolved future 3)
[13:24:42.630] resolve() on list ... DONE
[13:24:42.630] getGlobalsAndPackages() ...
[13:24:42.630] Searching for globals...
[13:24:42.631] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:42.632] Searching for globals ... DONE
[13:24:42.632] Resolving globals: FALSE
[13:24:42.632] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:42.632] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:42.633] - globals: [1] ‘kk’
[13:24:42.633] 
[13:24:42.633] getGlobalsAndPackages() ... DONE
[13:24:42.633] getGlobalsAndPackages() ...
[13:24:42.633] Searching for globals...
[13:24:42.634] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:42.634] Searching for globals ... DONE
[13:24:42.634] Resolving globals: FALSE
[13:24:42.635] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:42.635] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:42.635] - globals: [1] ‘kk’
[13:24:42.635] 
[13:24:42.635] getGlobalsAndPackages() ... DONE
[13:24:42.635] getGlobalsAndPackages() ...
[13:24:42.636] Searching for globals...
[13:24:42.637] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[13:24:42.637] Searching for globals ... DONE
[13:24:42.637] Resolving globals: FALSE
[13:24:42.637] The total size of the 1 globals is 56 bytes (56 bytes)
[13:24:42.637] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[13:24:42.638] - globals: [1] ‘kk’
[13:24:42.638] 
[13:24:42.638] getGlobalsAndPackages() ... DONE
[13:24:42.638] resolve() on list ...
[13:24:42.638]  recursive: 0
[13:24:42.638]  length: 3
[13:24:42.638] 
[13:24:42.638] run() for ‘Future’ ...
[13:24:42.639] - state: ‘created’
[13:24:42.639] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:42.652] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:42.653] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:42.653]   - Field: ‘node’
[13:24:42.653]   - Field: ‘label’
[13:24:42.653]   - Field: ‘local’
[13:24:42.653]   - Field: ‘owner’
[13:24:42.653]   - Field: ‘envir’
[13:24:42.653]   - Field: ‘workers’
[13:24:42.653]   - Field: ‘packages’
[13:24:42.653]   - Field: ‘gc’
[13:24:42.653]   - Field: ‘conditions’
[13:24:42.654]   - Field: ‘persistent’
[13:24:42.654]   - Field: ‘expr’
[13:24:42.654]   - Field: ‘uuid’
[13:24:42.654]   - Field: ‘seed’
[13:24:42.654]   - Field: ‘version’
[13:24:42.654]   - Field: ‘result’
[13:24:42.654]   - Field: ‘asynchronous’
[13:24:42.654]   - Field: ‘calls’
[13:24:42.654]   - Field: ‘globals’
[13:24:42.654]   - Field: ‘stdout’
[13:24:42.654]   - Field: ‘earlySignal’
[13:24:42.655]   - Field: ‘lazy’
[13:24:42.655]   - Field: ‘state’
[13:24:42.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:42.655] - Launch lazy future ...
[13:24:42.655] Packages needed by the future expression (n = 0): <none>
[13:24:42.655] Packages needed by future strategies (n = 0): <none>
[13:24:42.656] {
[13:24:42.656]     {
[13:24:42.656]         {
[13:24:42.656]             ...future.startTime <- base::Sys.time()
[13:24:42.656]             {
[13:24:42.656]                 {
[13:24:42.656]                   {
[13:24:42.656]                     {
[13:24:42.656]                       base::local({
[13:24:42.656]                         has_future <- base::requireNamespace("future", 
[13:24:42.656]                           quietly = TRUE)
[13:24:42.656]                         if (has_future) {
[13:24:42.656]                           ns <- base::getNamespace("future")
[13:24:42.656]                           version <- ns[[".package"]][["version"]]
[13:24:42.656]                           if (is.null(version)) 
[13:24:42.656]                             version <- utils::packageVersion("future")
[13:24:42.656]                         }
[13:24:42.656]                         else {
[13:24:42.656]                           version <- NULL
[13:24:42.656]                         }
[13:24:42.656]                         if (!has_future || version < "1.8.0") {
[13:24:42.656]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:42.656]                             "", base::R.version$version.string), 
[13:24:42.656]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:42.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:42.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:42.656]                               "release", "version")], collapse = " "), 
[13:24:42.656]                             hostname = base::Sys.info()[["nodename"]])
[13:24:42.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:42.656]                             info)
[13:24:42.656]                           info <- base::paste(info, collapse = "; ")
[13:24:42.656]                           if (!has_future) {
[13:24:42.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:42.656]                               info)
[13:24:42.656]                           }
[13:24:42.656]                           else {
[13:24:42.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:42.656]                               info, version)
[13:24:42.656]                           }
[13:24:42.656]                           base::stop(msg)
[13:24:42.656]                         }
[13:24:42.656]                       })
[13:24:42.656]                     }
[13:24:42.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:42.656]                     base::options(mc.cores = 1L)
[13:24:42.656]                   }
[13:24:42.656]                   options(future.plan = NULL)
[13:24:42.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:42.656]                 }
[13:24:42.656]                 ...future.workdir <- getwd()
[13:24:42.656]             }
[13:24:42.656]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:42.656]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:42.656]         }
[13:24:42.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:42.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:42.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:42.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:42.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:42.656]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:42.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:42.656]             base::names(...future.oldOptions))
[13:24:42.656]     }
[13:24:42.656]     if (FALSE) {
[13:24:42.656]     }
[13:24:42.656]     else {
[13:24:42.656]         if (TRUE) {
[13:24:42.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:42.656]                 open = "w")
[13:24:42.656]         }
[13:24:42.656]         else {
[13:24:42.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:42.656]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:42.656]         }
[13:24:42.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:42.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:42.656]             base::sink(type = "output", split = FALSE)
[13:24:42.656]             base::close(...future.stdout)
[13:24:42.656]         }, add = TRUE)
[13:24:42.656]     }
[13:24:42.656]     ...future.frame <- base::sys.nframe()
[13:24:42.656]     ...future.conditions <- base::list()
[13:24:42.656]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:42.656]     if (FALSE) {
[13:24:42.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:42.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:42.656]     }
[13:24:42.656]     ...future.result <- base::tryCatch({
[13:24:42.656]         base::withCallingHandlers({
[13:24:42.656]             ...future.value <- base::withVisible(base::local({
[13:24:42.656]                 ...future.makeSendCondition <- base::local({
[13:24:42.656]                   sendCondition <- NULL
[13:24:42.656]                   function(frame = 1L) {
[13:24:42.656]                     if (is.function(sendCondition)) 
[13:24:42.656]                       return(sendCondition)
[13:24:42.656]                     ns <- getNamespace("parallel")
[13:24:42.656]                     if (exists("sendData", mode = "function", 
[13:24:42.656]                       envir = ns)) {
[13:24:42.656]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:42.656]                         envir = ns)
[13:24:42.656]                       envir <- sys.frame(frame)
[13:24:42.656]                       master <- NULL
[13:24:42.656]                       while (!identical(envir, .GlobalEnv) && 
[13:24:42.656]                         !identical(envir, emptyenv())) {
[13:24:42.656]                         if (exists("master", mode = "list", envir = envir, 
[13:24:42.656]                           inherits = FALSE)) {
[13:24:42.656]                           master <- get("master", mode = "list", 
[13:24:42.656]                             envir = envir, inherits = FALSE)
[13:24:42.656]                           if (inherits(master, c("SOCKnode", 
[13:24:42.656]                             "SOCK0node"))) {
[13:24:42.656]                             sendCondition <<- function(cond) {
[13:24:42.656]                               data <- list(type = "VALUE", value = cond, 
[13:24:42.656]                                 success = TRUE)
[13:24:42.656]                               parallel_sendData(master, data)
[13:24:42.656]                             }
[13:24:42.656]                             return(sendCondition)
[13:24:42.656]                           }
[13:24:42.656]                         }
[13:24:42.656]                         frame <- frame + 1L
[13:24:42.656]                         envir <- sys.frame(frame)
[13:24:42.656]                       }
[13:24:42.656]                     }
[13:24:42.656]                     sendCondition <<- function(cond) NULL
[13:24:42.656]                   }
[13:24:42.656]                 })
[13:24:42.656]                 withCallingHandlers({
[13:24:42.656]                   {
[13:24:42.656]                     Sys.sleep(0.1)
[13:24:42.656]                     kk
[13:24:42.656]                   }
[13:24:42.656]                 }, immediateCondition = function(cond) {
[13:24:42.656]                   sendCondition <- ...future.makeSendCondition()
[13:24:42.656]                   sendCondition(cond)
[13:24:42.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.656]                   {
[13:24:42.656]                     inherits <- base::inherits
[13:24:42.656]                     invokeRestart <- base::invokeRestart
[13:24:42.656]                     is.null <- base::is.null
[13:24:42.656]                     muffled <- FALSE
[13:24:42.656]                     if (inherits(cond, "message")) {
[13:24:42.656]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:42.656]                       if (muffled) 
[13:24:42.656]                         invokeRestart("muffleMessage")
[13:24:42.656]                     }
[13:24:42.656]                     else if (inherits(cond, "warning")) {
[13:24:42.656]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:42.656]                       if (muffled) 
[13:24:42.656]                         invokeRestart("muffleWarning")
[13:24:42.656]                     }
[13:24:42.656]                     else if (inherits(cond, "condition")) {
[13:24:42.656]                       if (!is.null(pattern)) {
[13:24:42.656]                         computeRestarts <- base::computeRestarts
[13:24:42.656]                         grepl <- base::grepl
[13:24:42.656]                         restarts <- computeRestarts(cond)
[13:24:42.656]                         for (restart in restarts) {
[13:24:42.656]                           name <- restart$name
[13:24:42.656]                           if (is.null(name)) 
[13:24:42.656]                             next
[13:24:42.656]                           if (!grepl(pattern, name)) 
[13:24:42.656]                             next
[13:24:42.656]                           invokeRestart(restart)
[13:24:42.656]                           muffled <- TRUE
[13:24:42.656]                           break
[13:24:42.656]                         }
[13:24:42.656]                       }
[13:24:42.656]                     }
[13:24:42.656]                     invisible(muffled)
[13:24:42.656]                   }
[13:24:42.656]                   muffleCondition(cond)
[13:24:42.656]                 })
[13:24:42.656]             }))
[13:24:42.656]             future::FutureResult(value = ...future.value$value, 
[13:24:42.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.656]                   ...future.rng), globalenv = if (FALSE) 
[13:24:42.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:42.656]                     ...future.globalenv.names))
[13:24:42.656]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:42.656]         }, condition = base::local({
[13:24:42.656]             c <- base::c
[13:24:42.656]             inherits <- base::inherits
[13:24:42.656]             invokeRestart <- base::invokeRestart
[13:24:42.656]             length <- base::length
[13:24:42.656]             list <- base::list
[13:24:42.656]             seq.int <- base::seq.int
[13:24:42.656]             signalCondition <- base::signalCondition
[13:24:42.656]             sys.calls <- base::sys.calls
[13:24:42.656]             `[[` <- base::`[[`
[13:24:42.656]             `+` <- base::`+`
[13:24:42.656]             `<<-` <- base::`<<-`
[13:24:42.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:42.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:42.656]                   3L)]
[13:24:42.656]             }
[13:24:42.656]             function(cond) {
[13:24:42.656]                 is_error <- inherits(cond, "error")
[13:24:42.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:42.656]                   NULL)
[13:24:42.656]                 if (is_error) {
[13:24:42.656]                   sessionInformation <- function() {
[13:24:42.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:42.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:42.656]                       search = base::search(), system = base::Sys.info())
[13:24:42.656]                   }
[13:24:42.656]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:42.656]                     cond$call), session = sessionInformation(), 
[13:24:42.656]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:42.656]                   signalCondition(cond)
[13:24:42.656]                 }
[13:24:42.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:42.656]                 "immediateCondition"))) {
[13:24:42.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:42.656]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:42.656]                   if (TRUE && !signal) {
[13:24:42.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.656]                     {
[13:24:42.656]                       inherits <- base::inherits
[13:24:42.656]                       invokeRestart <- base::invokeRestart
[13:24:42.656]                       is.null <- base::is.null
[13:24:42.656]                       muffled <- FALSE
[13:24:42.656]                       if (inherits(cond, "message")) {
[13:24:42.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.656]                         if (muffled) 
[13:24:42.656]                           invokeRestart("muffleMessage")
[13:24:42.656]                       }
[13:24:42.656]                       else if (inherits(cond, "warning")) {
[13:24:42.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.656]                         if (muffled) 
[13:24:42.656]                           invokeRestart("muffleWarning")
[13:24:42.656]                       }
[13:24:42.656]                       else if (inherits(cond, "condition")) {
[13:24:42.656]                         if (!is.null(pattern)) {
[13:24:42.656]                           computeRestarts <- base::computeRestarts
[13:24:42.656]                           grepl <- base::grepl
[13:24:42.656]                           restarts <- computeRestarts(cond)
[13:24:42.656]                           for (restart in restarts) {
[13:24:42.656]                             name <- restart$name
[13:24:42.656]                             if (is.null(name)) 
[13:24:42.656]                               next
[13:24:42.656]                             if (!grepl(pattern, name)) 
[13:24:42.656]                               next
[13:24:42.656]                             invokeRestart(restart)
[13:24:42.656]                             muffled <- TRUE
[13:24:42.656]                             break
[13:24:42.656]                           }
[13:24:42.656]                         }
[13:24:42.656]                       }
[13:24:42.656]                       invisible(muffled)
[13:24:42.656]                     }
[13:24:42.656]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.656]                   }
[13:24:42.656]                 }
[13:24:42.656]                 else {
[13:24:42.656]                   if (TRUE) {
[13:24:42.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.656]                     {
[13:24:42.656]                       inherits <- base::inherits
[13:24:42.656]                       invokeRestart <- base::invokeRestart
[13:24:42.656]                       is.null <- base::is.null
[13:24:42.656]                       muffled <- FALSE
[13:24:42.656]                       if (inherits(cond, "message")) {
[13:24:42.656]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.656]                         if (muffled) 
[13:24:42.656]                           invokeRestart("muffleMessage")
[13:24:42.656]                       }
[13:24:42.656]                       else if (inherits(cond, "warning")) {
[13:24:42.656]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.656]                         if (muffled) 
[13:24:42.656]                           invokeRestart("muffleWarning")
[13:24:42.656]                       }
[13:24:42.656]                       else if (inherits(cond, "condition")) {
[13:24:42.656]                         if (!is.null(pattern)) {
[13:24:42.656]                           computeRestarts <- base::computeRestarts
[13:24:42.656]                           grepl <- base::grepl
[13:24:42.656]                           restarts <- computeRestarts(cond)
[13:24:42.656]                           for (restart in restarts) {
[13:24:42.656]                             name <- restart$name
[13:24:42.656]                             if (is.null(name)) 
[13:24:42.656]                               next
[13:24:42.656]                             if (!grepl(pattern, name)) 
[13:24:42.656]                               next
[13:24:42.656]                             invokeRestart(restart)
[13:24:42.656]                             muffled <- TRUE
[13:24:42.656]                             break
[13:24:42.656]                           }
[13:24:42.656]                         }
[13:24:42.656]                       }
[13:24:42.656]                       invisible(muffled)
[13:24:42.656]                     }
[13:24:42.656]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.656]                   }
[13:24:42.656]                 }
[13:24:42.656]             }
[13:24:42.656]         }))
[13:24:42.656]     }, error = function(ex) {
[13:24:42.656]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:42.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.656]                 ...future.rng), started = ...future.startTime, 
[13:24:42.656]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:42.656]             version = "1.8"), class = "FutureResult")
[13:24:42.656]     }, finally = {
[13:24:42.656]         if (!identical(...future.workdir, getwd())) 
[13:24:42.656]             setwd(...future.workdir)
[13:24:42.656]         {
[13:24:42.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:42.656]                 ...future.oldOptions$nwarnings <- NULL
[13:24:42.656]             }
[13:24:42.656]             base::options(...future.oldOptions)
[13:24:42.656]             if (.Platform$OS.type == "windows") {
[13:24:42.656]                 old_names <- names(...future.oldEnvVars)
[13:24:42.656]                 envs <- base::Sys.getenv()
[13:24:42.656]                 names <- names(envs)
[13:24:42.656]                 common <- intersect(names, old_names)
[13:24:42.656]                 added <- setdiff(names, old_names)
[13:24:42.656]                 removed <- setdiff(old_names, names)
[13:24:42.656]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:42.656]                   envs[common]]
[13:24:42.656]                 NAMES <- toupper(changed)
[13:24:42.656]                 args <- list()
[13:24:42.656]                 for (kk in seq_along(NAMES)) {
[13:24:42.656]                   name <- changed[[kk]]
[13:24:42.656]                   NAME <- NAMES[[kk]]
[13:24:42.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.656]                     next
[13:24:42.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.656]                 }
[13:24:42.656]                 NAMES <- toupper(added)
[13:24:42.656]                 for (kk in seq_along(NAMES)) {
[13:24:42.656]                   name <- added[[kk]]
[13:24:42.656]                   NAME <- NAMES[[kk]]
[13:24:42.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.656]                     next
[13:24:42.656]                   args[[name]] <- ""
[13:24:42.656]                 }
[13:24:42.656]                 NAMES <- toupper(removed)
[13:24:42.656]                 for (kk in seq_along(NAMES)) {
[13:24:42.656]                   name <- removed[[kk]]
[13:24:42.656]                   NAME <- NAMES[[kk]]
[13:24:42.656]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.656]                     next
[13:24:42.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.656]                 }
[13:24:42.656]                 if (length(args) > 0) 
[13:24:42.656]                   base::do.call(base::Sys.setenv, args = args)
[13:24:42.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:42.656]             }
[13:24:42.656]             else {
[13:24:42.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:42.656]             }
[13:24:42.656]             {
[13:24:42.656]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:42.656]                   0L) {
[13:24:42.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:42.656]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:42.656]                   base::options(opts)
[13:24:42.656]                 }
[13:24:42.656]                 {
[13:24:42.656]                   {
[13:24:42.656]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:42.656]                     NULL
[13:24:42.656]                   }
[13:24:42.656]                   options(future.plan = NULL)
[13:24:42.656]                   if (is.na(NA_character_)) 
[13:24:42.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:42.656]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:42.656]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:42.656]                     envir = parent.frame()) 
[13:24:42.656]                   {
[13:24:42.656]                     if (is.function(workers)) 
[13:24:42.656]                       workers <- workers()
[13:24:42.656]                     workers <- structure(as.integer(workers), 
[13:24:42.656]                       class = class(workers))
[13:24:42.656]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:42.656]                       workers >= 1)
[13:24:42.656]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:42.656]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:42.656]                     }
[13:24:42.656]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:42.656]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:42.656]                       envir = envir)
[13:24:42.656]                     if (!future$lazy) 
[13:24:42.656]                       future <- run(future)
[13:24:42.656]                     invisible(future)
[13:24:42.656]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:42.656]                 }
[13:24:42.656]             }
[13:24:42.656]         }
[13:24:42.656]     })
[13:24:42.656]     if (TRUE) {
[13:24:42.656]         base::sink(type = "output", split = FALSE)
[13:24:42.656]         if (TRUE) {
[13:24:42.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:42.656]         }
[13:24:42.656]         else {
[13:24:42.656]             ...future.result["stdout"] <- base::list(NULL)
[13:24:42.656]         }
[13:24:42.656]         base::close(...future.stdout)
[13:24:42.656]         ...future.stdout <- NULL
[13:24:42.656]     }
[13:24:42.656]     ...future.result$conditions <- ...future.conditions
[13:24:42.656]     ...future.result$finished <- base::Sys.time()
[13:24:42.656]     ...future.result
[13:24:42.656] }
[13:24:42.659] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:24:42.659] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:24:42.659] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:24:42.659] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:24:42.660] MultisessionFuture started
[13:24:42.660] - Launch lazy future ... done
[13:24:42.660] run() for ‘MultisessionFuture’ ... done
[13:24:42.671] run() for ‘Future’ ...
[13:24:42.671] - state: ‘created’
[13:24:42.671] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:42.685] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:42.686] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:42.686]   - Field: ‘node’
[13:24:42.686]   - Field: ‘label’
[13:24:42.686]   - Field: ‘local’
[13:24:42.686]   - Field: ‘owner’
[13:24:42.686]   - Field: ‘envir’
[13:24:42.686]   - Field: ‘workers’
[13:24:42.686]   - Field: ‘packages’
[13:24:42.686]   - Field: ‘gc’
[13:24:42.687]   - Field: ‘conditions’
[13:24:42.687]   - Field: ‘persistent’
[13:24:42.687]   - Field: ‘expr’
[13:24:42.687]   - Field: ‘uuid’
[13:24:42.687]   - Field: ‘seed’
[13:24:42.687]   - Field: ‘version’
[13:24:42.687]   - Field: ‘result’
[13:24:42.687]   - Field: ‘asynchronous’
[13:24:42.687]   - Field: ‘calls’
[13:24:42.687]   - Field: ‘globals’
[13:24:42.688]   - Field: ‘stdout’
[13:24:42.688]   - Field: ‘earlySignal’
[13:24:42.688]   - Field: ‘lazy’
[13:24:42.688]   - Field: ‘state’
[13:24:42.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:42.688] - Launch lazy future ...
[13:24:42.688] Packages needed by the future expression (n = 0): <none>
[13:24:42.688] Packages needed by future strategies (n = 0): <none>
[13:24:42.689] {
[13:24:42.689]     {
[13:24:42.689]         {
[13:24:42.689]             ...future.startTime <- base::Sys.time()
[13:24:42.689]             {
[13:24:42.689]                 {
[13:24:42.689]                   {
[13:24:42.689]                     {
[13:24:42.689]                       base::local({
[13:24:42.689]                         has_future <- base::requireNamespace("future", 
[13:24:42.689]                           quietly = TRUE)
[13:24:42.689]                         if (has_future) {
[13:24:42.689]                           ns <- base::getNamespace("future")
[13:24:42.689]                           version <- ns[[".package"]][["version"]]
[13:24:42.689]                           if (is.null(version)) 
[13:24:42.689]                             version <- utils::packageVersion("future")
[13:24:42.689]                         }
[13:24:42.689]                         else {
[13:24:42.689]                           version <- NULL
[13:24:42.689]                         }
[13:24:42.689]                         if (!has_future || version < "1.8.0") {
[13:24:42.689]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:42.689]                             "", base::R.version$version.string), 
[13:24:42.689]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:42.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:42.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:42.689]                               "release", "version")], collapse = " "), 
[13:24:42.689]                             hostname = base::Sys.info()[["nodename"]])
[13:24:42.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:42.689]                             info)
[13:24:42.689]                           info <- base::paste(info, collapse = "; ")
[13:24:42.689]                           if (!has_future) {
[13:24:42.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:42.689]                               info)
[13:24:42.689]                           }
[13:24:42.689]                           else {
[13:24:42.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:42.689]                               info, version)
[13:24:42.689]                           }
[13:24:42.689]                           base::stop(msg)
[13:24:42.689]                         }
[13:24:42.689]                       })
[13:24:42.689]                     }
[13:24:42.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:42.689]                     base::options(mc.cores = 1L)
[13:24:42.689]                   }
[13:24:42.689]                   options(future.plan = NULL)
[13:24:42.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:42.689]                 }
[13:24:42.689]                 ...future.workdir <- getwd()
[13:24:42.689]             }
[13:24:42.689]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:42.689]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:42.689]         }
[13:24:42.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:42.689]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:42.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:42.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:42.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:42.689]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:42.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:42.689]             base::names(...future.oldOptions))
[13:24:42.689]     }
[13:24:42.689]     if (FALSE) {
[13:24:42.689]     }
[13:24:42.689]     else {
[13:24:42.689]         if (TRUE) {
[13:24:42.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:42.689]                 open = "w")
[13:24:42.689]         }
[13:24:42.689]         else {
[13:24:42.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:42.689]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:42.689]         }
[13:24:42.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:42.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:42.689]             base::sink(type = "output", split = FALSE)
[13:24:42.689]             base::close(...future.stdout)
[13:24:42.689]         }, add = TRUE)
[13:24:42.689]     }
[13:24:42.689]     ...future.frame <- base::sys.nframe()
[13:24:42.689]     ...future.conditions <- base::list()
[13:24:42.689]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:42.689]     if (FALSE) {
[13:24:42.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:42.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:42.689]     }
[13:24:42.689]     ...future.result <- base::tryCatch({
[13:24:42.689]         base::withCallingHandlers({
[13:24:42.689]             ...future.value <- base::withVisible(base::local({
[13:24:42.689]                 ...future.makeSendCondition <- base::local({
[13:24:42.689]                   sendCondition <- NULL
[13:24:42.689]                   function(frame = 1L) {
[13:24:42.689]                     if (is.function(sendCondition)) 
[13:24:42.689]                       return(sendCondition)
[13:24:42.689]                     ns <- getNamespace("parallel")
[13:24:42.689]                     if (exists("sendData", mode = "function", 
[13:24:42.689]                       envir = ns)) {
[13:24:42.689]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:42.689]                         envir = ns)
[13:24:42.689]                       envir <- sys.frame(frame)
[13:24:42.689]                       master <- NULL
[13:24:42.689]                       while (!identical(envir, .GlobalEnv) && 
[13:24:42.689]                         !identical(envir, emptyenv())) {
[13:24:42.689]                         if (exists("master", mode = "list", envir = envir, 
[13:24:42.689]                           inherits = FALSE)) {
[13:24:42.689]                           master <- get("master", mode = "list", 
[13:24:42.689]                             envir = envir, inherits = FALSE)
[13:24:42.689]                           if (inherits(master, c("SOCKnode", 
[13:24:42.689]                             "SOCK0node"))) {
[13:24:42.689]                             sendCondition <<- function(cond) {
[13:24:42.689]                               data <- list(type = "VALUE", value = cond, 
[13:24:42.689]                                 success = TRUE)
[13:24:42.689]                               parallel_sendData(master, data)
[13:24:42.689]                             }
[13:24:42.689]                             return(sendCondition)
[13:24:42.689]                           }
[13:24:42.689]                         }
[13:24:42.689]                         frame <- frame + 1L
[13:24:42.689]                         envir <- sys.frame(frame)
[13:24:42.689]                       }
[13:24:42.689]                     }
[13:24:42.689]                     sendCondition <<- function(cond) NULL
[13:24:42.689]                   }
[13:24:42.689]                 })
[13:24:42.689]                 withCallingHandlers({
[13:24:42.689]                   {
[13:24:42.689]                     Sys.sleep(0.1)
[13:24:42.689]                     kk
[13:24:42.689]                   }
[13:24:42.689]                 }, immediateCondition = function(cond) {
[13:24:42.689]                   sendCondition <- ...future.makeSendCondition()
[13:24:42.689]                   sendCondition(cond)
[13:24:42.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.689]                   {
[13:24:42.689]                     inherits <- base::inherits
[13:24:42.689]                     invokeRestart <- base::invokeRestart
[13:24:42.689]                     is.null <- base::is.null
[13:24:42.689]                     muffled <- FALSE
[13:24:42.689]                     if (inherits(cond, "message")) {
[13:24:42.689]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:42.689]                       if (muffled) 
[13:24:42.689]                         invokeRestart("muffleMessage")
[13:24:42.689]                     }
[13:24:42.689]                     else if (inherits(cond, "warning")) {
[13:24:42.689]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:42.689]                       if (muffled) 
[13:24:42.689]                         invokeRestart("muffleWarning")
[13:24:42.689]                     }
[13:24:42.689]                     else if (inherits(cond, "condition")) {
[13:24:42.689]                       if (!is.null(pattern)) {
[13:24:42.689]                         computeRestarts <- base::computeRestarts
[13:24:42.689]                         grepl <- base::grepl
[13:24:42.689]                         restarts <- computeRestarts(cond)
[13:24:42.689]                         for (restart in restarts) {
[13:24:42.689]                           name <- restart$name
[13:24:42.689]                           if (is.null(name)) 
[13:24:42.689]                             next
[13:24:42.689]                           if (!grepl(pattern, name)) 
[13:24:42.689]                             next
[13:24:42.689]                           invokeRestart(restart)
[13:24:42.689]                           muffled <- TRUE
[13:24:42.689]                           break
[13:24:42.689]                         }
[13:24:42.689]                       }
[13:24:42.689]                     }
[13:24:42.689]                     invisible(muffled)
[13:24:42.689]                   }
[13:24:42.689]                   muffleCondition(cond)
[13:24:42.689]                 })
[13:24:42.689]             }))
[13:24:42.689]             future::FutureResult(value = ...future.value$value, 
[13:24:42.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.689]                   ...future.rng), globalenv = if (FALSE) 
[13:24:42.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:42.689]                     ...future.globalenv.names))
[13:24:42.689]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:42.689]         }, condition = base::local({
[13:24:42.689]             c <- base::c
[13:24:42.689]             inherits <- base::inherits
[13:24:42.689]             invokeRestart <- base::invokeRestart
[13:24:42.689]             length <- base::length
[13:24:42.689]             list <- base::list
[13:24:42.689]             seq.int <- base::seq.int
[13:24:42.689]             signalCondition <- base::signalCondition
[13:24:42.689]             sys.calls <- base::sys.calls
[13:24:42.689]             `[[` <- base::`[[`
[13:24:42.689]             `+` <- base::`+`
[13:24:42.689]             `<<-` <- base::`<<-`
[13:24:42.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:42.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:42.689]                   3L)]
[13:24:42.689]             }
[13:24:42.689]             function(cond) {
[13:24:42.689]                 is_error <- inherits(cond, "error")
[13:24:42.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:42.689]                   NULL)
[13:24:42.689]                 if (is_error) {
[13:24:42.689]                   sessionInformation <- function() {
[13:24:42.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:42.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:42.689]                       search = base::search(), system = base::Sys.info())
[13:24:42.689]                   }
[13:24:42.689]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:42.689]                     cond$call), session = sessionInformation(), 
[13:24:42.689]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:42.689]                   signalCondition(cond)
[13:24:42.689]                 }
[13:24:42.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:42.689]                 "immediateCondition"))) {
[13:24:42.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:42.689]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:42.689]                   if (TRUE && !signal) {
[13:24:42.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.689]                     {
[13:24:42.689]                       inherits <- base::inherits
[13:24:42.689]                       invokeRestart <- base::invokeRestart
[13:24:42.689]                       is.null <- base::is.null
[13:24:42.689]                       muffled <- FALSE
[13:24:42.689]                       if (inherits(cond, "message")) {
[13:24:42.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.689]                         if (muffled) 
[13:24:42.689]                           invokeRestart("muffleMessage")
[13:24:42.689]                       }
[13:24:42.689]                       else if (inherits(cond, "warning")) {
[13:24:42.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.689]                         if (muffled) 
[13:24:42.689]                           invokeRestart("muffleWarning")
[13:24:42.689]                       }
[13:24:42.689]                       else if (inherits(cond, "condition")) {
[13:24:42.689]                         if (!is.null(pattern)) {
[13:24:42.689]                           computeRestarts <- base::computeRestarts
[13:24:42.689]                           grepl <- base::grepl
[13:24:42.689]                           restarts <- computeRestarts(cond)
[13:24:42.689]                           for (restart in restarts) {
[13:24:42.689]                             name <- restart$name
[13:24:42.689]                             if (is.null(name)) 
[13:24:42.689]                               next
[13:24:42.689]                             if (!grepl(pattern, name)) 
[13:24:42.689]                               next
[13:24:42.689]                             invokeRestart(restart)
[13:24:42.689]                             muffled <- TRUE
[13:24:42.689]                             break
[13:24:42.689]                           }
[13:24:42.689]                         }
[13:24:42.689]                       }
[13:24:42.689]                       invisible(muffled)
[13:24:42.689]                     }
[13:24:42.689]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.689]                   }
[13:24:42.689]                 }
[13:24:42.689]                 else {
[13:24:42.689]                   if (TRUE) {
[13:24:42.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.689]                     {
[13:24:42.689]                       inherits <- base::inherits
[13:24:42.689]                       invokeRestart <- base::invokeRestart
[13:24:42.689]                       is.null <- base::is.null
[13:24:42.689]                       muffled <- FALSE
[13:24:42.689]                       if (inherits(cond, "message")) {
[13:24:42.689]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.689]                         if (muffled) 
[13:24:42.689]                           invokeRestart("muffleMessage")
[13:24:42.689]                       }
[13:24:42.689]                       else if (inherits(cond, "warning")) {
[13:24:42.689]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.689]                         if (muffled) 
[13:24:42.689]                           invokeRestart("muffleWarning")
[13:24:42.689]                       }
[13:24:42.689]                       else if (inherits(cond, "condition")) {
[13:24:42.689]                         if (!is.null(pattern)) {
[13:24:42.689]                           computeRestarts <- base::computeRestarts
[13:24:42.689]                           grepl <- base::grepl
[13:24:42.689]                           restarts <- computeRestarts(cond)
[13:24:42.689]                           for (restart in restarts) {
[13:24:42.689]                             name <- restart$name
[13:24:42.689]                             if (is.null(name)) 
[13:24:42.689]                               next
[13:24:42.689]                             if (!grepl(pattern, name)) 
[13:24:42.689]                               next
[13:24:42.689]                             invokeRestart(restart)
[13:24:42.689]                             muffled <- TRUE
[13:24:42.689]                             break
[13:24:42.689]                           }
[13:24:42.689]                         }
[13:24:42.689]                       }
[13:24:42.689]                       invisible(muffled)
[13:24:42.689]                     }
[13:24:42.689]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.689]                   }
[13:24:42.689]                 }
[13:24:42.689]             }
[13:24:42.689]         }))
[13:24:42.689]     }, error = function(ex) {
[13:24:42.689]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:42.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.689]                 ...future.rng), started = ...future.startTime, 
[13:24:42.689]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:42.689]             version = "1.8"), class = "FutureResult")
[13:24:42.689]     }, finally = {
[13:24:42.689]         if (!identical(...future.workdir, getwd())) 
[13:24:42.689]             setwd(...future.workdir)
[13:24:42.689]         {
[13:24:42.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:42.689]                 ...future.oldOptions$nwarnings <- NULL
[13:24:42.689]             }
[13:24:42.689]             base::options(...future.oldOptions)
[13:24:42.689]             if (.Platform$OS.type == "windows") {
[13:24:42.689]                 old_names <- names(...future.oldEnvVars)
[13:24:42.689]                 envs <- base::Sys.getenv()
[13:24:42.689]                 names <- names(envs)
[13:24:42.689]                 common <- intersect(names, old_names)
[13:24:42.689]                 added <- setdiff(names, old_names)
[13:24:42.689]                 removed <- setdiff(old_names, names)
[13:24:42.689]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:42.689]                   envs[common]]
[13:24:42.689]                 NAMES <- toupper(changed)
[13:24:42.689]                 args <- list()
[13:24:42.689]                 for (kk in seq_along(NAMES)) {
[13:24:42.689]                   name <- changed[[kk]]
[13:24:42.689]                   NAME <- NAMES[[kk]]
[13:24:42.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.689]                     next
[13:24:42.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.689]                 }
[13:24:42.689]                 NAMES <- toupper(added)
[13:24:42.689]                 for (kk in seq_along(NAMES)) {
[13:24:42.689]                   name <- added[[kk]]
[13:24:42.689]                   NAME <- NAMES[[kk]]
[13:24:42.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.689]                     next
[13:24:42.689]                   args[[name]] <- ""
[13:24:42.689]                 }
[13:24:42.689]                 NAMES <- toupper(removed)
[13:24:42.689]                 for (kk in seq_along(NAMES)) {
[13:24:42.689]                   name <- removed[[kk]]
[13:24:42.689]                   NAME <- NAMES[[kk]]
[13:24:42.689]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.689]                     next
[13:24:42.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.689]                 }
[13:24:42.689]                 if (length(args) > 0) 
[13:24:42.689]                   base::do.call(base::Sys.setenv, args = args)
[13:24:42.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:42.689]             }
[13:24:42.689]             else {
[13:24:42.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:42.689]             }
[13:24:42.689]             {
[13:24:42.689]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:42.689]                   0L) {
[13:24:42.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:42.689]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:42.689]                   base::options(opts)
[13:24:42.689]                 }
[13:24:42.689]                 {
[13:24:42.689]                   {
[13:24:42.689]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:42.689]                     NULL
[13:24:42.689]                   }
[13:24:42.689]                   options(future.plan = NULL)
[13:24:42.689]                   if (is.na(NA_character_)) 
[13:24:42.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:42.689]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:42.689]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:42.689]                     envir = parent.frame()) 
[13:24:42.689]                   {
[13:24:42.689]                     if (is.function(workers)) 
[13:24:42.689]                       workers <- workers()
[13:24:42.689]                     workers <- structure(as.integer(workers), 
[13:24:42.689]                       class = class(workers))
[13:24:42.689]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:42.689]                       workers >= 1)
[13:24:42.689]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:42.689]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:42.689]                     }
[13:24:42.689]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:42.689]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:42.689]                       envir = envir)
[13:24:42.689]                     if (!future$lazy) 
[13:24:42.689]                       future <- run(future)
[13:24:42.689]                     invisible(future)
[13:24:42.689]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:42.689]                 }
[13:24:42.689]             }
[13:24:42.689]         }
[13:24:42.689]     })
[13:24:42.689]     if (TRUE) {
[13:24:42.689]         base::sink(type = "output", split = FALSE)
[13:24:42.689]         if (TRUE) {
[13:24:42.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:42.689]         }
[13:24:42.689]         else {
[13:24:42.689]             ...future.result["stdout"] <- base::list(NULL)
[13:24:42.689]         }
[13:24:42.689]         base::close(...future.stdout)
[13:24:42.689]         ...future.stdout <- NULL
[13:24:42.689]     }
[13:24:42.689]     ...future.result$conditions <- ...future.conditions
[13:24:42.689]     ...future.result$finished <- base::Sys.time()
[13:24:42.689]     ...future.result
[13:24:42.689] }
[13:24:42.692] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[13:24:42.692] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[13:24:42.692] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[13:24:42.693] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[13:24:42.693] MultisessionFuture started
[13:24:42.693] - Launch lazy future ... done
[13:24:42.693] run() for ‘MultisessionFuture’ ... done
[13:24:42.704] run() for ‘Future’ ...
[13:24:42.704] - state: ‘created’
[13:24:42.704] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:42.719] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:42.719] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:42.719]   - Field: ‘node’
[13:24:42.719]   - Field: ‘label’
[13:24:42.720]   - Field: ‘local’
[13:24:42.720]   - Field: ‘owner’
[13:24:42.720]   - Field: ‘envir’
[13:24:42.720]   - Field: ‘workers’
[13:24:42.720]   - Field: ‘packages’
[13:24:42.720]   - Field: ‘gc’
[13:24:42.720]   - Field: ‘conditions’
[13:24:42.720]   - Field: ‘persistent’
[13:24:42.720]   - Field: ‘expr’
[13:24:42.720]   - Field: ‘uuid’
[13:24:42.721]   - Field: ‘seed’
[13:24:42.721]   - Field: ‘version’
[13:24:42.721]   - Field: ‘result’
[13:24:42.721]   - Field: ‘asynchronous’
[13:24:42.721]   - Field: ‘calls’
[13:24:42.721]   - Field: ‘globals’
[13:24:42.721]   - Field: ‘stdout’
[13:24:42.721]   - Field: ‘earlySignal’
[13:24:42.721]   - Field: ‘lazy’
[13:24:42.721]   - Field: ‘state’
[13:24:42.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:42.722] - Launch lazy future ...
[13:24:42.722] Packages needed by the future expression (n = 0): <none>
[13:24:42.722] Packages needed by future strategies (n = 0): <none>
[13:24:42.722] {
[13:24:42.722]     {
[13:24:42.722]         {
[13:24:42.722]             ...future.startTime <- base::Sys.time()
[13:24:42.722]             {
[13:24:42.722]                 {
[13:24:42.722]                   {
[13:24:42.722]                     {
[13:24:42.722]                       base::local({
[13:24:42.722]                         has_future <- base::requireNamespace("future", 
[13:24:42.722]                           quietly = TRUE)
[13:24:42.722]                         if (has_future) {
[13:24:42.722]                           ns <- base::getNamespace("future")
[13:24:42.722]                           version <- ns[[".package"]][["version"]]
[13:24:42.722]                           if (is.null(version)) 
[13:24:42.722]                             version <- utils::packageVersion("future")
[13:24:42.722]                         }
[13:24:42.722]                         else {
[13:24:42.722]                           version <- NULL
[13:24:42.722]                         }
[13:24:42.722]                         if (!has_future || version < "1.8.0") {
[13:24:42.722]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:42.722]                             "", base::R.version$version.string), 
[13:24:42.722]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:42.722]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:42.722]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:42.722]                               "release", "version")], collapse = " "), 
[13:24:42.722]                             hostname = base::Sys.info()[["nodename"]])
[13:24:42.722]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:42.722]                             info)
[13:24:42.722]                           info <- base::paste(info, collapse = "; ")
[13:24:42.722]                           if (!has_future) {
[13:24:42.722]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:42.722]                               info)
[13:24:42.722]                           }
[13:24:42.722]                           else {
[13:24:42.722]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:42.722]                               info, version)
[13:24:42.722]                           }
[13:24:42.722]                           base::stop(msg)
[13:24:42.722]                         }
[13:24:42.722]                       })
[13:24:42.722]                     }
[13:24:42.722]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:42.722]                     base::options(mc.cores = 1L)
[13:24:42.722]                   }
[13:24:42.722]                   options(future.plan = NULL)
[13:24:42.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:42.722]                 }
[13:24:42.722]                 ...future.workdir <- getwd()
[13:24:42.722]             }
[13:24:42.722]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:42.722]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:42.722]         }
[13:24:42.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:42.722]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:42.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:42.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:42.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:42.722]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:42.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:42.722]             base::names(...future.oldOptions))
[13:24:42.722]     }
[13:24:42.722]     if (FALSE) {
[13:24:42.722]     }
[13:24:42.722]     else {
[13:24:42.722]         if (TRUE) {
[13:24:42.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:42.722]                 open = "w")
[13:24:42.722]         }
[13:24:42.722]         else {
[13:24:42.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:42.722]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:42.722]         }
[13:24:42.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:42.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:42.722]             base::sink(type = "output", split = FALSE)
[13:24:42.722]             base::close(...future.stdout)
[13:24:42.722]         }, add = TRUE)
[13:24:42.722]     }
[13:24:42.722]     ...future.frame <- base::sys.nframe()
[13:24:42.722]     ...future.conditions <- base::list()
[13:24:42.722]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:42.722]     if (FALSE) {
[13:24:42.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:42.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:42.722]     }
[13:24:42.722]     ...future.result <- base::tryCatch({
[13:24:42.722]         base::withCallingHandlers({
[13:24:42.722]             ...future.value <- base::withVisible(base::local({
[13:24:42.722]                 ...future.makeSendCondition <- base::local({
[13:24:42.722]                   sendCondition <- NULL
[13:24:42.722]                   function(frame = 1L) {
[13:24:42.722]                     if (is.function(sendCondition)) 
[13:24:42.722]                       return(sendCondition)
[13:24:42.722]                     ns <- getNamespace("parallel")
[13:24:42.722]                     if (exists("sendData", mode = "function", 
[13:24:42.722]                       envir = ns)) {
[13:24:42.722]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:42.722]                         envir = ns)
[13:24:42.722]                       envir <- sys.frame(frame)
[13:24:42.722]                       master <- NULL
[13:24:42.722]                       while (!identical(envir, .GlobalEnv) && 
[13:24:42.722]                         !identical(envir, emptyenv())) {
[13:24:42.722]                         if (exists("master", mode = "list", envir = envir, 
[13:24:42.722]                           inherits = FALSE)) {
[13:24:42.722]                           master <- get("master", mode = "list", 
[13:24:42.722]                             envir = envir, inherits = FALSE)
[13:24:42.722]                           if (inherits(master, c("SOCKnode", 
[13:24:42.722]                             "SOCK0node"))) {
[13:24:42.722]                             sendCondition <<- function(cond) {
[13:24:42.722]                               data <- list(type = "VALUE", value = cond, 
[13:24:42.722]                                 success = TRUE)
[13:24:42.722]                               parallel_sendData(master, data)
[13:24:42.722]                             }
[13:24:42.722]                             return(sendCondition)
[13:24:42.722]                           }
[13:24:42.722]                         }
[13:24:42.722]                         frame <- frame + 1L
[13:24:42.722]                         envir <- sys.frame(frame)
[13:24:42.722]                       }
[13:24:42.722]                     }
[13:24:42.722]                     sendCondition <<- function(cond) NULL
[13:24:42.722]                   }
[13:24:42.722]                 })
[13:24:42.722]                 withCallingHandlers({
[13:24:42.722]                   {
[13:24:42.722]                     Sys.sleep(0.1)
[13:24:42.722]                     kk
[13:24:42.722]                   }
[13:24:42.722]                 }, immediateCondition = function(cond) {
[13:24:42.722]                   sendCondition <- ...future.makeSendCondition()
[13:24:42.722]                   sendCondition(cond)
[13:24:42.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.722]                   {
[13:24:42.722]                     inherits <- base::inherits
[13:24:42.722]                     invokeRestart <- base::invokeRestart
[13:24:42.722]                     is.null <- base::is.null
[13:24:42.722]                     muffled <- FALSE
[13:24:42.722]                     if (inherits(cond, "message")) {
[13:24:42.722]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:42.722]                       if (muffled) 
[13:24:42.722]                         invokeRestart("muffleMessage")
[13:24:42.722]                     }
[13:24:42.722]                     else if (inherits(cond, "warning")) {
[13:24:42.722]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:42.722]                       if (muffled) 
[13:24:42.722]                         invokeRestart("muffleWarning")
[13:24:42.722]                     }
[13:24:42.722]                     else if (inherits(cond, "condition")) {
[13:24:42.722]                       if (!is.null(pattern)) {
[13:24:42.722]                         computeRestarts <- base::computeRestarts
[13:24:42.722]                         grepl <- base::grepl
[13:24:42.722]                         restarts <- computeRestarts(cond)
[13:24:42.722]                         for (restart in restarts) {
[13:24:42.722]                           name <- restart$name
[13:24:42.722]                           if (is.null(name)) 
[13:24:42.722]                             next
[13:24:42.722]                           if (!grepl(pattern, name)) 
[13:24:42.722]                             next
[13:24:42.722]                           invokeRestart(restart)
[13:24:42.722]                           muffled <- TRUE
[13:24:42.722]                           break
[13:24:42.722]                         }
[13:24:42.722]                       }
[13:24:42.722]                     }
[13:24:42.722]                     invisible(muffled)
[13:24:42.722]                   }
[13:24:42.722]                   muffleCondition(cond)
[13:24:42.722]                 })
[13:24:42.722]             }))
[13:24:42.722]             future::FutureResult(value = ...future.value$value, 
[13:24:42.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.722]                   ...future.rng), globalenv = if (FALSE) 
[13:24:42.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:42.722]                     ...future.globalenv.names))
[13:24:42.722]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:42.722]         }, condition = base::local({
[13:24:42.722]             c <- base::c
[13:24:42.722]             inherits <- base::inherits
[13:24:42.722]             invokeRestart <- base::invokeRestart
[13:24:42.722]             length <- base::length
[13:24:42.722]             list <- base::list
[13:24:42.722]             seq.int <- base::seq.int
[13:24:42.722]             signalCondition <- base::signalCondition
[13:24:42.722]             sys.calls <- base::sys.calls
[13:24:42.722]             `[[` <- base::`[[`
[13:24:42.722]             `+` <- base::`+`
[13:24:42.722]             `<<-` <- base::`<<-`
[13:24:42.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:42.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:42.722]                   3L)]
[13:24:42.722]             }
[13:24:42.722]             function(cond) {
[13:24:42.722]                 is_error <- inherits(cond, "error")
[13:24:42.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:42.722]                   NULL)
[13:24:42.722]                 if (is_error) {
[13:24:42.722]                   sessionInformation <- function() {
[13:24:42.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:42.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:42.722]                       search = base::search(), system = base::Sys.info())
[13:24:42.722]                   }
[13:24:42.722]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:42.722]                     cond$call), session = sessionInformation(), 
[13:24:42.722]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:42.722]                   signalCondition(cond)
[13:24:42.722]                 }
[13:24:42.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:42.722]                 "immediateCondition"))) {
[13:24:42.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:42.722]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:42.722]                   if (TRUE && !signal) {
[13:24:42.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.722]                     {
[13:24:42.722]                       inherits <- base::inherits
[13:24:42.722]                       invokeRestart <- base::invokeRestart
[13:24:42.722]                       is.null <- base::is.null
[13:24:42.722]                       muffled <- FALSE
[13:24:42.722]                       if (inherits(cond, "message")) {
[13:24:42.722]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.722]                         if (muffled) 
[13:24:42.722]                           invokeRestart("muffleMessage")
[13:24:42.722]                       }
[13:24:42.722]                       else if (inherits(cond, "warning")) {
[13:24:42.722]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.722]                         if (muffled) 
[13:24:42.722]                           invokeRestart("muffleWarning")
[13:24:42.722]                       }
[13:24:42.722]                       else if (inherits(cond, "condition")) {
[13:24:42.722]                         if (!is.null(pattern)) {
[13:24:42.722]                           computeRestarts <- base::computeRestarts
[13:24:42.722]                           grepl <- base::grepl
[13:24:42.722]                           restarts <- computeRestarts(cond)
[13:24:42.722]                           for (restart in restarts) {
[13:24:42.722]                             name <- restart$name
[13:24:42.722]                             if (is.null(name)) 
[13:24:42.722]                               next
[13:24:42.722]                             if (!grepl(pattern, name)) 
[13:24:42.722]                               next
[13:24:42.722]                             invokeRestart(restart)
[13:24:42.722]                             muffled <- TRUE
[13:24:42.722]                             break
[13:24:42.722]                           }
[13:24:42.722]                         }
[13:24:42.722]                       }
[13:24:42.722]                       invisible(muffled)
[13:24:42.722]                     }
[13:24:42.722]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.722]                   }
[13:24:42.722]                 }
[13:24:42.722]                 else {
[13:24:42.722]                   if (TRUE) {
[13:24:42.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.722]                     {
[13:24:42.722]                       inherits <- base::inherits
[13:24:42.722]                       invokeRestart <- base::invokeRestart
[13:24:42.722]                       is.null <- base::is.null
[13:24:42.722]                       muffled <- FALSE
[13:24:42.722]                       if (inherits(cond, "message")) {
[13:24:42.722]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.722]                         if (muffled) 
[13:24:42.722]                           invokeRestart("muffleMessage")
[13:24:42.722]                       }
[13:24:42.722]                       else if (inherits(cond, "warning")) {
[13:24:42.722]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.722]                         if (muffled) 
[13:24:42.722]                           invokeRestart("muffleWarning")
[13:24:42.722]                       }
[13:24:42.722]                       else if (inherits(cond, "condition")) {
[13:24:42.722]                         if (!is.null(pattern)) {
[13:24:42.722]                           computeRestarts <- base::computeRestarts
[13:24:42.722]                           grepl <- base::grepl
[13:24:42.722]                           restarts <- computeRestarts(cond)
[13:24:42.722]                           for (restart in restarts) {
[13:24:42.722]                             name <- restart$name
[13:24:42.722]                             if (is.null(name)) 
[13:24:42.722]                               next
[13:24:42.722]                             if (!grepl(pattern, name)) 
[13:24:42.722]                               next
[13:24:42.722]                             invokeRestart(restart)
[13:24:42.722]                             muffled <- TRUE
[13:24:42.722]                             break
[13:24:42.722]                           }
[13:24:42.722]                         }
[13:24:42.722]                       }
[13:24:42.722]                       invisible(muffled)
[13:24:42.722]                     }
[13:24:42.722]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.722]                   }
[13:24:42.722]                 }
[13:24:42.722]             }
[13:24:42.722]         }))
[13:24:42.722]     }, error = function(ex) {
[13:24:42.722]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:42.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.722]                 ...future.rng), started = ...future.startTime, 
[13:24:42.722]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:42.722]             version = "1.8"), class = "FutureResult")
[13:24:42.722]     }, finally = {
[13:24:42.722]         if (!identical(...future.workdir, getwd())) 
[13:24:42.722]             setwd(...future.workdir)
[13:24:42.722]         {
[13:24:42.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:42.722]                 ...future.oldOptions$nwarnings <- NULL
[13:24:42.722]             }
[13:24:42.722]             base::options(...future.oldOptions)
[13:24:42.722]             if (.Platform$OS.type == "windows") {
[13:24:42.722]                 old_names <- names(...future.oldEnvVars)
[13:24:42.722]                 envs <- base::Sys.getenv()
[13:24:42.722]                 names <- names(envs)
[13:24:42.722]                 common <- intersect(names, old_names)
[13:24:42.722]                 added <- setdiff(names, old_names)
[13:24:42.722]                 removed <- setdiff(old_names, names)
[13:24:42.722]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:42.722]                   envs[common]]
[13:24:42.722]                 NAMES <- toupper(changed)
[13:24:42.722]                 args <- list()
[13:24:42.722]                 for (kk in seq_along(NAMES)) {
[13:24:42.722]                   name <- changed[[kk]]
[13:24:42.722]                   NAME <- NAMES[[kk]]
[13:24:42.722]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.722]                     next
[13:24:42.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.722]                 }
[13:24:42.722]                 NAMES <- toupper(added)
[13:24:42.722]                 for (kk in seq_along(NAMES)) {
[13:24:42.722]                   name <- added[[kk]]
[13:24:42.722]                   NAME <- NAMES[[kk]]
[13:24:42.722]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.722]                     next
[13:24:42.722]                   args[[name]] <- ""
[13:24:42.722]                 }
[13:24:42.722]                 NAMES <- toupper(removed)
[13:24:42.722]                 for (kk in seq_along(NAMES)) {
[13:24:42.722]                   name <- removed[[kk]]
[13:24:42.722]                   NAME <- NAMES[[kk]]
[13:24:42.722]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.722]                     next
[13:24:42.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.722]                 }
[13:24:42.722]                 if (length(args) > 0) 
[13:24:42.722]                   base::do.call(base::Sys.setenv, args = args)
[13:24:42.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:42.722]             }
[13:24:42.722]             else {
[13:24:42.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:42.722]             }
[13:24:42.722]             {
[13:24:42.722]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:42.722]                   0L) {
[13:24:42.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:42.722]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:42.722]                   base::options(opts)
[13:24:42.722]                 }
[13:24:42.722]                 {
[13:24:42.722]                   {
[13:24:42.722]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:42.722]                     NULL
[13:24:42.722]                   }
[13:24:42.722]                   options(future.plan = NULL)
[13:24:42.722]                   if (is.na(NA_character_)) 
[13:24:42.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:42.722]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:42.722]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:42.722]                     envir = parent.frame()) 
[13:24:42.722]                   {
[13:24:42.722]                     if (is.function(workers)) 
[13:24:42.722]                       workers <- workers()
[13:24:42.722]                     workers <- structure(as.integer(workers), 
[13:24:42.722]                       class = class(workers))
[13:24:42.722]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:42.722]                       workers >= 1)
[13:24:42.722]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:42.722]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:42.722]                     }
[13:24:42.722]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:42.722]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:42.722]                       envir = envir)
[13:24:42.722]                     if (!future$lazy) 
[13:24:42.722]                       future <- run(future)
[13:24:42.722]                     invisible(future)
[13:24:42.722]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:42.722]                 }
[13:24:42.722]             }
[13:24:42.722]         }
[13:24:42.722]     })
[13:24:42.722]     if (TRUE) {
[13:24:42.722]         base::sink(type = "output", split = FALSE)
[13:24:42.722]         if (TRUE) {
[13:24:42.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:42.722]         }
[13:24:42.722]         else {
[13:24:42.722]             ...future.result["stdout"] <- base::list(NULL)
[13:24:42.722]         }
[13:24:42.722]         base::close(...future.stdout)
[13:24:42.722]         ...future.stdout <- NULL
[13:24:42.722]     }
[13:24:42.722]     ...future.result$conditions <- ...future.conditions
[13:24:42.722]     ...future.result$finished <- base::Sys.time()
[13:24:42.722]     ...future.result
[13:24:42.722] }
[13:24:42.725] Poll #1 (0): usedNodes() = 2, workers = 2
[13:24:42.757] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[13:24:42.788] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[13:24:42.806] receiveMessageFromWorker() for ClusterFuture ...
[13:24:42.806] - Validating connection of MultisessionFuture
[13:24:42.806] - received message: FutureResult
[13:24:42.806] - Received FutureResult
[13:24:42.806] - Erased future from FutureRegistry
[13:24:42.806] result() for ClusterFuture ...
[13:24:42.806] - result already collected: FutureResult
[13:24:42.807] result() for ClusterFuture ... done
[13:24:42.807] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:42.807] result() for ClusterFuture ...
[13:24:42.807] - result already collected: FutureResult
[13:24:42.807] result() for ClusterFuture ... done
[13:24:42.807] result() for ClusterFuture ...
[13:24:42.807] - result already collected: FutureResult
[13:24:42.807] result() for ClusterFuture ... done
[13:24:42.808] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[13:24:42.808] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[13:24:42.808] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[13:24:42.809] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[13:24:42.809] MultisessionFuture started
[13:24:42.809] - Launch lazy future ... done
[13:24:42.809] run() for ‘MultisessionFuture’ ... done
[13:24:42.830] Future #1
[13:24:42.830]  length: 2 (resolved future 1)
[13:24:42.862] receiveMessageFromWorker() for ClusterFuture ...
[13:24:42.862] - Validating connection of MultisessionFuture
[13:24:42.862] - received message: FutureResult
[13:24:42.862] - Received FutureResult
[13:24:42.862] - Erased future from FutureRegistry
[13:24:42.863] result() for ClusterFuture ...
[13:24:42.863] - result already collected: FutureResult
[13:24:42.863] result() for ClusterFuture ... done
[13:24:42.863] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:42.863] Future #2
[13:24:42.863]  length: 1 (resolved future 2)
[13:24:42.966] receiveMessageFromWorker() for ClusterFuture ...
[13:24:42.967] - Validating connection of MultisessionFuture
[13:24:42.967] - received message: FutureResult
[13:24:42.967] - Received FutureResult
[13:24:42.967] - Erased future from FutureRegistry
[13:24:42.967] result() for ClusterFuture ...
[13:24:42.967] - result already collected: FutureResult
[13:24:42.967] result() for ClusterFuture ... done
[13:24:42.968] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:42.968] Future #3
[13:24:42.968]  length: 0 (resolved future 3)
[13:24:42.968] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[13:24:42.969] resolve() on environment ...
[13:24:42.969]  recursive: 0
[13:24:42.969]  elements: [2] ‘a’, ‘b’
[13:24:42.969]  length: 1 (resolved future 1)
[13:24:42.969]  length: 0 (resolved future 2)
[13:24:42.969] resolve() on environment ... DONE
[13:24:42.970] getGlobalsAndPackages() ...
[13:24:42.970] Searching for globals...
[13:24:42.970] 
[13:24:42.970] Searching for globals ... DONE
[13:24:42.970] - globals: [0] <none>
[13:24:42.970] getGlobalsAndPackages() ... DONE
[13:24:42.971] run() for ‘Future’ ...
[13:24:42.971] - state: ‘created’
[13:24:42.971] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:42.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:42.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:42.990]   - Field: ‘node’
[13:24:42.990]   - Field: ‘label’
[13:24:42.990]   - Field: ‘local’
[13:24:42.991]   - Field: ‘owner’
[13:24:42.991]   - Field: ‘envir’
[13:24:42.991]   - Field: ‘workers’
[13:24:42.991]   - Field: ‘packages’
[13:24:42.991]   - Field: ‘gc’
[13:24:42.991]   - Field: ‘conditions’
[13:24:42.991]   - Field: ‘persistent’
[13:24:42.991]   - Field: ‘expr’
[13:24:42.991]   - Field: ‘uuid’
[13:24:42.991]   - Field: ‘seed’
[13:24:42.992]   - Field: ‘version’
[13:24:42.992]   - Field: ‘result’
[13:24:42.992]   - Field: ‘asynchronous’
[13:24:42.992]   - Field: ‘calls’
[13:24:42.992]   - Field: ‘globals’
[13:24:42.992]   - Field: ‘stdout’
[13:24:42.992]   - Field: ‘earlySignal’
[13:24:42.992]   - Field: ‘lazy’
[13:24:42.992]   - Field: ‘state’
[13:24:42.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:42.993] - Launch lazy future ...
[13:24:42.993] Packages needed by the future expression (n = 0): <none>
[13:24:42.993] Packages needed by future strategies (n = 0): <none>
[13:24:42.993] {
[13:24:42.993]     {
[13:24:42.993]         {
[13:24:42.993]             ...future.startTime <- base::Sys.time()
[13:24:42.993]             {
[13:24:42.993]                 {
[13:24:42.993]                   {
[13:24:42.993]                     {
[13:24:42.993]                       base::local({
[13:24:42.993]                         has_future <- base::requireNamespace("future", 
[13:24:42.993]                           quietly = TRUE)
[13:24:42.993]                         if (has_future) {
[13:24:42.993]                           ns <- base::getNamespace("future")
[13:24:42.993]                           version <- ns[[".package"]][["version"]]
[13:24:42.993]                           if (is.null(version)) 
[13:24:42.993]                             version <- utils::packageVersion("future")
[13:24:42.993]                         }
[13:24:42.993]                         else {
[13:24:42.993]                           version <- NULL
[13:24:42.993]                         }
[13:24:42.993]                         if (!has_future || version < "1.8.0") {
[13:24:42.993]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:42.993]                             "", base::R.version$version.string), 
[13:24:42.993]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:42.993]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:42.993]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:42.993]                               "release", "version")], collapse = " "), 
[13:24:42.993]                             hostname = base::Sys.info()[["nodename"]])
[13:24:42.993]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:42.993]                             info)
[13:24:42.993]                           info <- base::paste(info, collapse = "; ")
[13:24:42.993]                           if (!has_future) {
[13:24:42.993]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:42.993]                               info)
[13:24:42.993]                           }
[13:24:42.993]                           else {
[13:24:42.993]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:42.993]                               info, version)
[13:24:42.993]                           }
[13:24:42.993]                           base::stop(msg)
[13:24:42.993]                         }
[13:24:42.993]                       })
[13:24:42.993]                     }
[13:24:42.993]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:42.993]                     base::options(mc.cores = 1L)
[13:24:42.993]                   }
[13:24:42.993]                   options(future.plan = NULL)
[13:24:42.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:42.993]                 }
[13:24:42.993]                 ...future.workdir <- getwd()
[13:24:42.993]             }
[13:24:42.993]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:42.993]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:42.993]         }
[13:24:42.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:42.993]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:42.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:42.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:42.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:42.993]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:42.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:42.993]             base::names(...future.oldOptions))
[13:24:42.993]     }
[13:24:42.993]     if (FALSE) {
[13:24:42.993]     }
[13:24:42.993]     else {
[13:24:42.993]         if (TRUE) {
[13:24:42.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:42.993]                 open = "w")
[13:24:42.993]         }
[13:24:42.993]         else {
[13:24:42.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:42.993]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:42.993]         }
[13:24:42.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:42.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:42.993]             base::sink(type = "output", split = FALSE)
[13:24:42.993]             base::close(...future.stdout)
[13:24:42.993]         }, add = TRUE)
[13:24:42.993]     }
[13:24:42.993]     ...future.frame <- base::sys.nframe()
[13:24:42.993]     ...future.conditions <- base::list()
[13:24:42.993]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:42.993]     if (FALSE) {
[13:24:42.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:42.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:42.993]     }
[13:24:42.993]     ...future.result <- base::tryCatch({
[13:24:42.993]         base::withCallingHandlers({
[13:24:42.993]             ...future.value <- base::withVisible(base::local({
[13:24:42.993]                 ...future.makeSendCondition <- base::local({
[13:24:42.993]                   sendCondition <- NULL
[13:24:42.993]                   function(frame = 1L) {
[13:24:42.993]                     if (is.function(sendCondition)) 
[13:24:42.993]                       return(sendCondition)
[13:24:42.993]                     ns <- getNamespace("parallel")
[13:24:42.993]                     if (exists("sendData", mode = "function", 
[13:24:42.993]                       envir = ns)) {
[13:24:42.993]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:42.993]                         envir = ns)
[13:24:42.993]                       envir <- sys.frame(frame)
[13:24:42.993]                       master <- NULL
[13:24:42.993]                       while (!identical(envir, .GlobalEnv) && 
[13:24:42.993]                         !identical(envir, emptyenv())) {
[13:24:42.993]                         if (exists("master", mode = "list", envir = envir, 
[13:24:42.993]                           inherits = FALSE)) {
[13:24:42.993]                           master <- get("master", mode = "list", 
[13:24:42.993]                             envir = envir, inherits = FALSE)
[13:24:42.993]                           if (inherits(master, c("SOCKnode", 
[13:24:42.993]                             "SOCK0node"))) {
[13:24:42.993]                             sendCondition <<- function(cond) {
[13:24:42.993]                               data <- list(type = "VALUE", value = cond, 
[13:24:42.993]                                 success = TRUE)
[13:24:42.993]                               parallel_sendData(master, data)
[13:24:42.993]                             }
[13:24:42.993]                             return(sendCondition)
[13:24:42.993]                           }
[13:24:42.993]                         }
[13:24:42.993]                         frame <- frame + 1L
[13:24:42.993]                         envir <- sys.frame(frame)
[13:24:42.993]                       }
[13:24:42.993]                     }
[13:24:42.993]                     sendCondition <<- function(cond) NULL
[13:24:42.993]                   }
[13:24:42.993]                 })
[13:24:42.993]                 withCallingHandlers({
[13:24:42.993]                   1
[13:24:42.993]                 }, immediateCondition = function(cond) {
[13:24:42.993]                   sendCondition <- ...future.makeSendCondition()
[13:24:42.993]                   sendCondition(cond)
[13:24:42.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.993]                   {
[13:24:42.993]                     inherits <- base::inherits
[13:24:42.993]                     invokeRestart <- base::invokeRestart
[13:24:42.993]                     is.null <- base::is.null
[13:24:42.993]                     muffled <- FALSE
[13:24:42.993]                     if (inherits(cond, "message")) {
[13:24:42.993]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:42.993]                       if (muffled) 
[13:24:42.993]                         invokeRestart("muffleMessage")
[13:24:42.993]                     }
[13:24:42.993]                     else if (inherits(cond, "warning")) {
[13:24:42.993]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:42.993]                       if (muffled) 
[13:24:42.993]                         invokeRestart("muffleWarning")
[13:24:42.993]                     }
[13:24:42.993]                     else if (inherits(cond, "condition")) {
[13:24:42.993]                       if (!is.null(pattern)) {
[13:24:42.993]                         computeRestarts <- base::computeRestarts
[13:24:42.993]                         grepl <- base::grepl
[13:24:42.993]                         restarts <- computeRestarts(cond)
[13:24:42.993]                         for (restart in restarts) {
[13:24:42.993]                           name <- restart$name
[13:24:42.993]                           if (is.null(name)) 
[13:24:42.993]                             next
[13:24:42.993]                           if (!grepl(pattern, name)) 
[13:24:42.993]                             next
[13:24:42.993]                           invokeRestart(restart)
[13:24:42.993]                           muffled <- TRUE
[13:24:42.993]                           break
[13:24:42.993]                         }
[13:24:42.993]                       }
[13:24:42.993]                     }
[13:24:42.993]                     invisible(muffled)
[13:24:42.993]                   }
[13:24:42.993]                   muffleCondition(cond)
[13:24:42.993]                 })
[13:24:42.993]             }))
[13:24:42.993]             future::FutureResult(value = ...future.value$value, 
[13:24:42.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.993]                   ...future.rng), globalenv = if (FALSE) 
[13:24:42.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:42.993]                     ...future.globalenv.names))
[13:24:42.993]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:42.993]         }, condition = base::local({
[13:24:42.993]             c <- base::c
[13:24:42.993]             inherits <- base::inherits
[13:24:42.993]             invokeRestart <- base::invokeRestart
[13:24:42.993]             length <- base::length
[13:24:42.993]             list <- base::list
[13:24:42.993]             seq.int <- base::seq.int
[13:24:42.993]             signalCondition <- base::signalCondition
[13:24:42.993]             sys.calls <- base::sys.calls
[13:24:42.993]             `[[` <- base::`[[`
[13:24:42.993]             `+` <- base::`+`
[13:24:42.993]             `<<-` <- base::`<<-`
[13:24:42.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:42.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:42.993]                   3L)]
[13:24:42.993]             }
[13:24:42.993]             function(cond) {
[13:24:42.993]                 is_error <- inherits(cond, "error")
[13:24:42.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:42.993]                   NULL)
[13:24:42.993]                 if (is_error) {
[13:24:42.993]                   sessionInformation <- function() {
[13:24:42.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:42.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:42.993]                       search = base::search(), system = base::Sys.info())
[13:24:42.993]                   }
[13:24:42.993]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:42.993]                     cond$call), session = sessionInformation(), 
[13:24:42.993]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:42.993]                   signalCondition(cond)
[13:24:42.993]                 }
[13:24:42.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:42.993]                 "immediateCondition"))) {
[13:24:42.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:42.993]                   ...future.conditions[[length(...future.conditions) + 
[13:24:42.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:42.993]                   if (TRUE && !signal) {
[13:24:42.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.993]                     {
[13:24:42.993]                       inherits <- base::inherits
[13:24:42.993]                       invokeRestart <- base::invokeRestart
[13:24:42.993]                       is.null <- base::is.null
[13:24:42.993]                       muffled <- FALSE
[13:24:42.993]                       if (inherits(cond, "message")) {
[13:24:42.993]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.993]                         if (muffled) 
[13:24:42.993]                           invokeRestart("muffleMessage")
[13:24:42.993]                       }
[13:24:42.993]                       else if (inherits(cond, "warning")) {
[13:24:42.993]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.993]                         if (muffled) 
[13:24:42.993]                           invokeRestart("muffleWarning")
[13:24:42.993]                       }
[13:24:42.993]                       else if (inherits(cond, "condition")) {
[13:24:42.993]                         if (!is.null(pattern)) {
[13:24:42.993]                           computeRestarts <- base::computeRestarts
[13:24:42.993]                           grepl <- base::grepl
[13:24:42.993]                           restarts <- computeRestarts(cond)
[13:24:42.993]                           for (restart in restarts) {
[13:24:42.993]                             name <- restart$name
[13:24:42.993]                             if (is.null(name)) 
[13:24:42.993]                               next
[13:24:42.993]                             if (!grepl(pattern, name)) 
[13:24:42.993]                               next
[13:24:42.993]                             invokeRestart(restart)
[13:24:42.993]                             muffled <- TRUE
[13:24:42.993]                             break
[13:24:42.993]                           }
[13:24:42.993]                         }
[13:24:42.993]                       }
[13:24:42.993]                       invisible(muffled)
[13:24:42.993]                     }
[13:24:42.993]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.993]                   }
[13:24:42.993]                 }
[13:24:42.993]                 else {
[13:24:42.993]                   if (TRUE) {
[13:24:42.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:42.993]                     {
[13:24:42.993]                       inherits <- base::inherits
[13:24:42.993]                       invokeRestart <- base::invokeRestart
[13:24:42.993]                       is.null <- base::is.null
[13:24:42.993]                       muffled <- FALSE
[13:24:42.993]                       if (inherits(cond, "message")) {
[13:24:42.993]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:42.993]                         if (muffled) 
[13:24:42.993]                           invokeRestart("muffleMessage")
[13:24:42.993]                       }
[13:24:42.993]                       else if (inherits(cond, "warning")) {
[13:24:42.993]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:42.993]                         if (muffled) 
[13:24:42.993]                           invokeRestart("muffleWarning")
[13:24:42.993]                       }
[13:24:42.993]                       else if (inherits(cond, "condition")) {
[13:24:42.993]                         if (!is.null(pattern)) {
[13:24:42.993]                           computeRestarts <- base::computeRestarts
[13:24:42.993]                           grepl <- base::grepl
[13:24:42.993]                           restarts <- computeRestarts(cond)
[13:24:42.993]                           for (restart in restarts) {
[13:24:42.993]                             name <- restart$name
[13:24:42.993]                             if (is.null(name)) 
[13:24:42.993]                               next
[13:24:42.993]                             if (!grepl(pattern, name)) 
[13:24:42.993]                               next
[13:24:42.993]                             invokeRestart(restart)
[13:24:42.993]                             muffled <- TRUE
[13:24:42.993]                             break
[13:24:42.993]                           }
[13:24:42.993]                         }
[13:24:42.993]                       }
[13:24:42.993]                       invisible(muffled)
[13:24:42.993]                     }
[13:24:42.993]                     muffleCondition(cond, pattern = "^muffle")
[13:24:42.993]                   }
[13:24:42.993]                 }
[13:24:42.993]             }
[13:24:42.993]         }))
[13:24:42.993]     }, error = function(ex) {
[13:24:42.993]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:42.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:42.993]                 ...future.rng), started = ...future.startTime, 
[13:24:42.993]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:42.993]             version = "1.8"), class = "FutureResult")
[13:24:42.993]     }, finally = {
[13:24:42.993]         if (!identical(...future.workdir, getwd())) 
[13:24:42.993]             setwd(...future.workdir)
[13:24:42.993]         {
[13:24:42.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:42.993]                 ...future.oldOptions$nwarnings <- NULL
[13:24:42.993]             }
[13:24:42.993]             base::options(...future.oldOptions)
[13:24:42.993]             if (.Platform$OS.type == "windows") {
[13:24:42.993]                 old_names <- names(...future.oldEnvVars)
[13:24:42.993]                 envs <- base::Sys.getenv()
[13:24:42.993]                 names <- names(envs)
[13:24:42.993]                 common <- intersect(names, old_names)
[13:24:42.993]                 added <- setdiff(names, old_names)
[13:24:42.993]                 removed <- setdiff(old_names, names)
[13:24:42.993]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:42.993]                   envs[common]]
[13:24:42.993]                 NAMES <- toupper(changed)
[13:24:42.993]                 args <- list()
[13:24:42.993]                 for (kk in seq_along(NAMES)) {
[13:24:42.993]                   name <- changed[[kk]]
[13:24:42.993]                   NAME <- NAMES[[kk]]
[13:24:42.993]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.993]                     next
[13:24:42.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.993]                 }
[13:24:42.993]                 NAMES <- toupper(added)
[13:24:42.993]                 for (kk in seq_along(NAMES)) {
[13:24:42.993]                   name <- added[[kk]]
[13:24:42.993]                   NAME <- NAMES[[kk]]
[13:24:42.993]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.993]                     next
[13:24:42.993]                   args[[name]] <- ""
[13:24:42.993]                 }
[13:24:42.993]                 NAMES <- toupper(removed)
[13:24:42.993]                 for (kk in seq_along(NAMES)) {
[13:24:42.993]                   name <- removed[[kk]]
[13:24:42.993]                   NAME <- NAMES[[kk]]
[13:24:42.993]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:42.993]                     next
[13:24:42.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:42.993]                 }
[13:24:42.993]                 if (length(args) > 0) 
[13:24:42.993]                   base::do.call(base::Sys.setenv, args = args)
[13:24:42.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:42.993]             }
[13:24:42.993]             else {
[13:24:42.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:42.993]             }
[13:24:42.993]             {
[13:24:42.993]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:42.993]                   0L) {
[13:24:42.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:42.993]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:42.993]                   base::options(opts)
[13:24:42.993]                 }
[13:24:42.993]                 {
[13:24:42.993]                   {
[13:24:42.993]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:42.993]                     NULL
[13:24:42.993]                   }
[13:24:42.993]                   options(future.plan = NULL)
[13:24:42.993]                   if (is.na(NA_character_)) 
[13:24:42.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:42.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:42.993]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:42.993]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:42.993]                     envir = parent.frame()) 
[13:24:42.993]                   {
[13:24:42.993]                     if (is.function(workers)) 
[13:24:42.993]                       workers <- workers()
[13:24:42.993]                     workers <- structure(as.integer(workers), 
[13:24:42.993]                       class = class(workers))
[13:24:42.993]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:42.993]                       workers >= 1)
[13:24:42.993]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:42.993]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:42.993]                     }
[13:24:42.993]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:42.993]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:42.993]                       envir = envir)
[13:24:42.993]                     if (!future$lazy) 
[13:24:42.993]                       future <- run(future)
[13:24:42.993]                     invisible(future)
[13:24:42.993]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:42.993]                 }
[13:24:42.993]             }
[13:24:42.993]         }
[13:24:42.993]     })
[13:24:42.993]     if (TRUE) {
[13:24:42.993]         base::sink(type = "output", split = FALSE)
[13:24:42.993]         if (TRUE) {
[13:24:42.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:42.993]         }
[13:24:42.993]         else {
[13:24:42.993]             ...future.result["stdout"] <- base::list(NULL)
[13:24:42.993]         }
[13:24:42.993]         base::close(...future.stdout)
[13:24:42.993]         ...future.stdout <- NULL
[13:24:42.993]     }
[13:24:42.993]     ...future.result$conditions <- ...future.conditions
[13:24:42.993]     ...future.result$finished <- base::Sys.time()
[13:24:42.993]     ...future.result
[13:24:42.993] }
[13:24:42.997] MultisessionFuture started
[13:24:42.997] - Launch lazy future ... done
[13:24:42.997] run() for ‘MultisessionFuture’ ... done
[13:24:42.997] getGlobalsAndPackages() ...
[13:24:42.997] Searching for globals...
[13:24:42.998] 
[13:24:42.998] Searching for globals ... DONE
[13:24:42.998] - globals: [0] <none>
[13:24:42.998] getGlobalsAndPackages() ... DONE
[13:24:42.998] run() for ‘Future’ ...
[13:24:42.998] - state: ‘created’
[13:24:42.998] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.013] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.013]   - Field: ‘node’
[13:24:43.013]   - Field: ‘label’
[13:24:43.013]   - Field: ‘local’
[13:24:43.014]   - Field: ‘owner’
[13:24:43.014]   - Field: ‘envir’
[13:24:43.014]   - Field: ‘workers’
[13:24:43.014]   - Field: ‘packages’
[13:24:43.014]   - Field: ‘gc’
[13:24:43.014]   - Field: ‘conditions’
[13:24:43.014]   - Field: ‘persistent’
[13:24:43.014]   - Field: ‘expr’
[13:24:43.014]   - Field: ‘uuid’
[13:24:43.014]   - Field: ‘seed’
[13:24:43.015]   - Field: ‘version’
[13:24:43.015]   - Field: ‘result’
[13:24:43.015]   - Field: ‘asynchronous’
[13:24:43.015]   - Field: ‘calls’
[13:24:43.015]   - Field: ‘globals’
[13:24:43.015]   - Field: ‘stdout’
[13:24:43.015]   - Field: ‘earlySignal’
[13:24:43.015]   - Field: ‘lazy’
[13:24:43.015]   - Field: ‘state’
[13:24:43.015] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.015] - Launch lazy future ...
[13:24:43.016] Packages needed by the future expression (n = 0): <none>
[13:24:43.016] Packages needed by future strategies (n = 0): <none>
[13:24:43.016] {
[13:24:43.016]     {
[13:24:43.016]         {
[13:24:43.016]             ...future.startTime <- base::Sys.time()
[13:24:43.016]             {
[13:24:43.016]                 {
[13:24:43.016]                   {
[13:24:43.016]                     {
[13:24:43.016]                       base::local({
[13:24:43.016]                         has_future <- base::requireNamespace("future", 
[13:24:43.016]                           quietly = TRUE)
[13:24:43.016]                         if (has_future) {
[13:24:43.016]                           ns <- base::getNamespace("future")
[13:24:43.016]                           version <- ns[[".package"]][["version"]]
[13:24:43.016]                           if (is.null(version)) 
[13:24:43.016]                             version <- utils::packageVersion("future")
[13:24:43.016]                         }
[13:24:43.016]                         else {
[13:24:43.016]                           version <- NULL
[13:24:43.016]                         }
[13:24:43.016]                         if (!has_future || version < "1.8.0") {
[13:24:43.016]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.016]                             "", base::R.version$version.string), 
[13:24:43.016]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.016]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.016]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.016]                               "release", "version")], collapse = " "), 
[13:24:43.016]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.016]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.016]                             info)
[13:24:43.016]                           info <- base::paste(info, collapse = "; ")
[13:24:43.016]                           if (!has_future) {
[13:24:43.016]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.016]                               info)
[13:24:43.016]                           }
[13:24:43.016]                           else {
[13:24:43.016]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.016]                               info, version)
[13:24:43.016]                           }
[13:24:43.016]                           base::stop(msg)
[13:24:43.016]                         }
[13:24:43.016]                       })
[13:24:43.016]                     }
[13:24:43.016]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.016]                     base::options(mc.cores = 1L)
[13:24:43.016]                   }
[13:24:43.016]                   options(future.plan = NULL)
[13:24:43.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.016]                 }
[13:24:43.016]                 ...future.workdir <- getwd()
[13:24:43.016]             }
[13:24:43.016]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.016]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.016]         }
[13:24:43.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.016]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.016]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.016]             base::names(...future.oldOptions))
[13:24:43.016]     }
[13:24:43.016]     if (FALSE) {
[13:24:43.016]     }
[13:24:43.016]     else {
[13:24:43.016]         if (TRUE) {
[13:24:43.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.016]                 open = "w")
[13:24:43.016]         }
[13:24:43.016]         else {
[13:24:43.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.016]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.016]         }
[13:24:43.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.016]             base::sink(type = "output", split = FALSE)
[13:24:43.016]             base::close(...future.stdout)
[13:24:43.016]         }, add = TRUE)
[13:24:43.016]     }
[13:24:43.016]     ...future.frame <- base::sys.nframe()
[13:24:43.016]     ...future.conditions <- base::list()
[13:24:43.016]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.016]     if (FALSE) {
[13:24:43.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.016]     }
[13:24:43.016]     ...future.result <- base::tryCatch({
[13:24:43.016]         base::withCallingHandlers({
[13:24:43.016]             ...future.value <- base::withVisible(base::local({
[13:24:43.016]                 ...future.makeSendCondition <- base::local({
[13:24:43.016]                   sendCondition <- NULL
[13:24:43.016]                   function(frame = 1L) {
[13:24:43.016]                     if (is.function(sendCondition)) 
[13:24:43.016]                       return(sendCondition)
[13:24:43.016]                     ns <- getNamespace("parallel")
[13:24:43.016]                     if (exists("sendData", mode = "function", 
[13:24:43.016]                       envir = ns)) {
[13:24:43.016]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.016]                         envir = ns)
[13:24:43.016]                       envir <- sys.frame(frame)
[13:24:43.016]                       master <- NULL
[13:24:43.016]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.016]                         !identical(envir, emptyenv())) {
[13:24:43.016]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.016]                           inherits = FALSE)) {
[13:24:43.016]                           master <- get("master", mode = "list", 
[13:24:43.016]                             envir = envir, inherits = FALSE)
[13:24:43.016]                           if (inherits(master, c("SOCKnode", 
[13:24:43.016]                             "SOCK0node"))) {
[13:24:43.016]                             sendCondition <<- function(cond) {
[13:24:43.016]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.016]                                 success = TRUE)
[13:24:43.016]                               parallel_sendData(master, data)
[13:24:43.016]                             }
[13:24:43.016]                             return(sendCondition)
[13:24:43.016]                           }
[13:24:43.016]                         }
[13:24:43.016]                         frame <- frame + 1L
[13:24:43.016]                         envir <- sys.frame(frame)
[13:24:43.016]                       }
[13:24:43.016]                     }
[13:24:43.016]                     sendCondition <<- function(cond) NULL
[13:24:43.016]                   }
[13:24:43.016]                 })
[13:24:43.016]                 withCallingHandlers({
[13:24:43.016]                   2
[13:24:43.016]                 }, immediateCondition = function(cond) {
[13:24:43.016]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.016]                   sendCondition(cond)
[13:24:43.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.016]                   {
[13:24:43.016]                     inherits <- base::inherits
[13:24:43.016]                     invokeRestart <- base::invokeRestart
[13:24:43.016]                     is.null <- base::is.null
[13:24:43.016]                     muffled <- FALSE
[13:24:43.016]                     if (inherits(cond, "message")) {
[13:24:43.016]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.016]                       if (muffled) 
[13:24:43.016]                         invokeRestart("muffleMessage")
[13:24:43.016]                     }
[13:24:43.016]                     else if (inherits(cond, "warning")) {
[13:24:43.016]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.016]                       if (muffled) 
[13:24:43.016]                         invokeRestart("muffleWarning")
[13:24:43.016]                     }
[13:24:43.016]                     else if (inherits(cond, "condition")) {
[13:24:43.016]                       if (!is.null(pattern)) {
[13:24:43.016]                         computeRestarts <- base::computeRestarts
[13:24:43.016]                         grepl <- base::grepl
[13:24:43.016]                         restarts <- computeRestarts(cond)
[13:24:43.016]                         for (restart in restarts) {
[13:24:43.016]                           name <- restart$name
[13:24:43.016]                           if (is.null(name)) 
[13:24:43.016]                             next
[13:24:43.016]                           if (!grepl(pattern, name)) 
[13:24:43.016]                             next
[13:24:43.016]                           invokeRestart(restart)
[13:24:43.016]                           muffled <- TRUE
[13:24:43.016]                           break
[13:24:43.016]                         }
[13:24:43.016]                       }
[13:24:43.016]                     }
[13:24:43.016]                     invisible(muffled)
[13:24:43.016]                   }
[13:24:43.016]                   muffleCondition(cond)
[13:24:43.016]                 })
[13:24:43.016]             }))
[13:24:43.016]             future::FutureResult(value = ...future.value$value, 
[13:24:43.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.016]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.016]                     ...future.globalenv.names))
[13:24:43.016]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.016]         }, condition = base::local({
[13:24:43.016]             c <- base::c
[13:24:43.016]             inherits <- base::inherits
[13:24:43.016]             invokeRestart <- base::invokeRestart
[13:24:43.016]             length <- base::length
[13:24:43.016]             list <- base::list
[13:24:43.016]             seq.int <- base::seq.int
[13:24:43.016]             signalCondition <- base::signalCondition
[13:24:43.016]             sys.calls <- base::sys.calls
[13:24:43.016]             `[[` <- base::`[[`
[13:24:43.016]             `+` <- base::`+`
[13:24:43.016]             `<<-` <- base::`<<-`
[13:24:43.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.016]                   3L)]
[13:24:43.016]             }
[13:24:43.016]             function(cond) {
[13:24:43.016]                 is_error <- inherits(cond, "error")
[13:24:43.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.016]                   NULL)
[13:24:43.016]                 if (is_error) {
[13:24:43.016]                   sessionInformation <- function() {
[13:24:43.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.016]                       search = base::search(), system = base::Sys.info())
[13:24:43.016]                   }
[13:24:43.016]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.016]                     cond$call), session = sessionInformation(), 
[13:24:43.016]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.016]                   signalCondition(cond)
[13:24:43.016]                 }
[13:24:43.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.016]                 "immediateCondition"))) {
[13:24:43.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.016]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.016]                   if (TRUE && !signal) {
[13:24:43.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.016]                     {
[13:24:43.016]                       inherits <- base::inherits
[13:24:43.016]                       invokeRestart <- base::invokeRestart
[13:24:43.016]                       is.null <- base::is.null
[13:24:43.016]                       muffled <- FALSE
[13:24:43.016]                       if (inherits(cond, "message")) {
[13:24:43.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.016]                         if (muffled) 
[13:24:43.016]                           invokeRestart("muffleMessage")
[13:24:43.016]                       }
[13:24:43.016]                       else if (inherits(cond, "warning")) {
[13:24:43.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.016]                         if (muffled) 
[13:24:43.016]                           invokeRestart("muffleWarning")
[13:24:43.016]                       }
[13:24:43.016]                       else if (inherits(cond, "condition")) {
[13:24:43.016]                         if (!is.null(pattern)) {
[13:24:43.016]                           computeRestarts <- base::computeRestarts
[13:24:43.016]                           grepl <- base::grepl
[13:24:43.016]                           restarts <- computeRestarts(cond)
[13:24:43.016]                           for (restart in restarts) {
[13:24:43.016]                             name <- restart$name
[13:24:43.016]                             if (is.null(name)) 
[13:24:43.016]                               next
[13:24:43.016]                             if (!grepl(pattern, name)) 
[13:24:43.016]                               next
[13:24:43.016]                             invokeRestart(restart)
[13:24:43.016]                             muffled <- TRUE
[13:24:43.016]                             break
[13:24:43.016]                           }
[13:24:43.016]                         }
[13:24:43.016]                       }
[13:24:43.016]                       invisible(muffled)
[13:24:43.016]                     }
[13:24:43.016]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.016]                   }
[13:24:43.016]                 }
[13:24:43.016]                 else {
[13:24:43.016]                   if (TRUE) {
[13:24:43.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.016]                     {
[13:24:43.016]                       inherits <- base::inherits
[13:24:43.016]                       invokeRestart <- base::invokeRestart
[13:24:43.016]                       is.null <- base::is.null
[13:24:43.016]                       muffled <- FALSE
[13:24:43.016]                       if (inherits(cond, "message")) {
[13:24:43.016]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.016]                         if (muffled) 
[13:24:43.016]                           invokeRestart("muffleMessage")
[13:24:43.016]                       }
[13:24:43.016]                       else if (inherits(cond, "warning")) {
[13:24:43.016]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.016]                         if (muffled) 
[13:24:43.016]                           invokeRestart("muffleWarning")
[13:24:43.016]                       }
[13:24:43.016]                       else if (inherits(cond, "condition")) {
[13:24:43.016]                         if (!is.null(pattern)) {
[13:24:43.016]                           computeRestarts <- base::computeRestarts
[13:24:43.016]                           grepl <- base::grepl
[13:24:43.016]                           restarts <- computeRestarts(cond)
[13:24:43.016]                           for (restart in restarts) {
[13:24:43.016]                             name <- restart$name
[13:24:43.016]                             if (is.null(name)) 
[13:24:43.016]                               next
[13:24:43.016]                             if (!grepl(pattern, name)) 
[13:24:43.016]                               next
[13:24:43.016]                             invokeRestart(restart)
[13:24:43.016]                             muffled <- TRUE
[13:24:43.016]                             break
[13:24:43.016]                           }
[13:24:43.016]                         }
[13:24:43.016]                       }
[13:24:43.016]                       invisible(muffled)
[13:24:43.016]                     }
[13:24:43.016]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.016]                   }
[13:24:43.016]                 }
[13:24:43.016]             }
[13:24:43.016]         }))
[13:24:43.016]     }, error = function(ex) {
[13:24:43.016]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.016]                 ...future.rng), started = ...future.startTime, 
[13:24:43.016]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.016]             version = "1.8"), class = "FutureResult")
[13:24:43.016]     }, finally = {
[13:24:43.016]         if (!identical(...future.workdir, getwd())) 
[13:24:43.016]             setwd(...future.workdir)
[13:24:43.016]         {
[13:24:43.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.016]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.016]             }
[13:24:43.016]             base::options(...future.oldOptions)
[13:24:43.016]             if (.Platform$OS.type == "windows") {
[13:24:43.016]                 old_names <- names(...future.oldEnvVars)
[13:24:43.016]                 envs <- base::Sys.getenv()
[13:24:43.016]                 names <- names(envs)
[13:24:43.016]                 common <- intersect(names, old_names)
[13:24:43.016]                 added <- setdiff(names, old_names)
[13:24:43.016]                 removed <- setdiff(old_names, names)
[13:24:43.016]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.016]                   envs[common]]
[13:24:43.016]                 NAMES <- toupper(changed)
[13:24:43.016]                 args <- list()
[13:24:43.016]                 for (kk in seq_along(NAMES)) {
[13:24:43.016]                   name <- changed[[kk]]
[13:24:43.016]                   NAME <- NAMES[[kk]]
[13:24:43.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.016]                     next
[13:24:43.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.016]                 }
[13:24:43.016]                 NAMES <- toupper(added)
[13:24:43.016]                 for (kk in seq_along(NAMES)) {
[13:24:43.016]                   name <- added[[kk]]
[13:24:43.016]                   NAME <- NAMES[[kk]]
[13:24:43.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.016]                     next
[13:24:43.016]                   args[[name]] <- ""
[13:24:43.016]                 }
[13:24:43.016]                 NAMES <- toupper(removed)
[13:24:43.016]                 for (kk in seq_along(NAMES)) {
[13:24:43.016]                   name <- removed[[kk]]
[13:24:43.016]                   NAME <- NAMES[[kk]]
[13:24:43.016]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.016]                     next
[13:24:43.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.016]                 }
[13:24:43.016]                 if (length(args) > 0) 
[13:24:43.016]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.016]             }
[13:24:43.016]             else {
[13:24:43.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.016]             }
[13:24:43.016]             {
[13:24:43.016]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.016]                   0L) {
[13:24:43.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.016]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.016]                   base::options(opts)
[13:24:43.016]                 }
[13:24:43.016]                 {
[13:24:43.016]                   {
[13:24:43.016]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.016]                     NULL
[13:24:43.016]                   }
[13:24:43.016]                   options(future.plan = NULL)
[13:24:43.016]                   if (is.na(NA_character_)) 
[13:24:43.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.016]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.016]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.016]                     envir = parent.frame()) 
[13:24:43.016]                   {
[13:24:43.016]                     if (is.function(workers)) 
[13:24:43.016]                       workers <- workers()
[13:24:43.016]                     workers <- structure(as.integer(workers), 
[13:24:43.016]                       class = class(workers))
[13:24:43.016]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.016]                       workers >= 1)
[13:24:43.016]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.016]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.016]                     }
[13:24:43.016]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.016]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.016]                       envir = envir)
[13:24:43.016]                     if (!future$lazy) 
[13:24:43.016]                       future <- run(future)
[13:24:43.016]                     invisible(future)
[13:24:43.016]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.016]                 }
[13:24:43.016]             }
[13:24:43.016]         }
[13:24:43.016]     })
[13:24:43.016]     if (TRUE) {
[13:24:43.016]         base::sink(type = "output", split = FALSE)
[13:24:43.016]         if (TRUE) {
[13:24:43.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.016]         }
[13:24:43.016]         else {
[13:24:43.016]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.016]         }
[13:24:43.016]         base::close(...future.stdout)
[13:24:43.016]         ...future.stdout <- NULL
[13:24:43.016]     }
[13:24:43.016]     ...future.result$conditions <- ...future.conditions
[13:24:43.016]     ...future.result$finished <- base::Sys.time()
[13:24:43.016]     ...future.result
[13:24:43.016] }
[13:24:43.020] MultisessionFuture started
[13:24:43.020] - Launch lazy future ... done
[13:24:43.020] run() for ‘MultisessionFuture’ ... done
[13:24:43.020] resolve() on environment ...
[13:24:43.020]  recursive: 0
[13:24:43.021]  elements: [3] ‘a’, ‘b’, ‘c’
[13:24:43.021] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.022] - Validating connection of MultisessionFuture
[13:24:43.022] - received message: FutureResult
[13:24:43.022] - Received FutureResult
[13:24:43.022] - Erased future from FutureRegistry
[13:24:43.022] result() for ClusterFuture ...
[13:24:43.022] - result already collected: FutureResult
[13:24:43.022] result() for ClusterFuture ... done
[13:24:43.022] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.022] Future #1
[13:24:43.023]  length: 2 (resolved future 1)
[13:24:43.033]  length: 1 (resolved future 3)
[13:24:43.065] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.065] - Validating connection of MultisessionFuture
[13:24:43.065] - received message: FutureResult
[13:24:43.065] - Received FutureResult
[13:24:43.065] - Erased future from FutureRegistry
[13:24:43.065] result() for ClusterFuture ...
[13:24:43.066] - result already collected: FutureResult
[13:24:43.066] result() for ClusterFuture ... done
[13:24:43.066] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.066] Future #2
[13:24:43.066]  length: 0 (resolved future 2)
[13:24:43.066] resolve() on environment ... DONE
[13:24:43.067] getGlobalsAndPackages() ...
[13:24:43.067] Searching for globals...
[13:24:43.067] - globals found: [1] ‘{’
[13:24:43.068] Searching for globals ... DONE
[13:24:43.068] Resolving globals: FALSE
[13:24:43.068] 
[13:24:43.068] 
[13:24:43.068] getGlobalsAndPackages() ... DONE
[13:24:43.068] run() for ‘Future’ ...
[13:24:43.069] - state: ‘created’
[13:24:43.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.084] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.084] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.085]   - Field: ‘node’
[13:24:43.085]   - Field: ‘label’
[13:24:43.085]   - Field: ‘local’
[13:24:43.085]   - Field: ‘owner’
[13:24:43.085]   - Field: ‘envir’
[13:24:43.085]   - Field: ‘workers’
[13:24:43.085]   - Field: ‘packages’
[13:24:43.085]   - Field: ‘gc’
[13:24:43.085]   - Field: ‘conditions’
[13:24:43.085]   - Field: ‘persistent’
[13:24:43.086]   - Field: ‘expr’
[13:24:43.086]   - Field: ‘uuid’
[13:24:43.086]   - Field: ‘seed’
[13:24:43.086]   - Field: ‘version’
[13:24:43.086]   - Field: ‘result’
[13:24:43.086]   - Field: ‘asynchronous’
[13:24:43.086]   - Field: ‘calls’
[13:24:43.086]   - Field: ‘globals’
[13:24:43.086]   - Field: ‘stdout’
[13:24:43.086]   - Field: ‘earlySignal’
[13:24:43.086]   - Field: ‘lazy’
[13:24:43.087]   - Field: ‘state’
[13:24:43.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.087] - Launch lazy future ...
[13:24:43.087] Packages needed by the future expression (n = 0): <none>
[13:24:43.087] Packages needed by future strategies (n = 0): <none>
[13:24:43.088] {
[13:24:43.088]     {
[13:24:43.088]         {
[13:24:43.088]             ...future.startTime <- base::Sys.time()
[13:24:43.088]             {
[13:24:43.088]                 {
[13:24:43.088]                   {
[13:24:43.088]                     {
[13:24:43.088]                       base::local({
[13:24:43.088]                         has_future <- base::requireNamespace("future", 
[13:24:43.088]                           quietly = TRUE)
[13:24:43.088]                         if (has_future) {
[13:24:43.088]                           ns <- base::getNamespace("future")
[13:24:43.088]                           version <- ns[[".package"]][["version"]]
[13:24:43.088]                           if (is.null(version)) 
[13:24:43.088]                             version <- utils::packageVersion("future")
[13:24:43.088]                         }
[13:24:43.088]                         else {
[13:24:43.088]                           version <- NULL
[13:24:43.088]                         }
[13:24:43.088]                         if (!has_future || version < "1.8.0") {
[13:24:43.088]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.088]                             "", base::R.version$version.string), 
[13:24:43.088]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.088]                               "release", "version")], collapse = " "), 
[13:24:43.088]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.088]                             info)
[13:24:43.088]                           info <- base::paste(info, collapse = "; ")
[13:24:43.088]                           if (!has_future) {
[13:24:43.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.088]                               info)
[13:24:43.088]                           }
[13:24:43.088]                           else {
[13:24:43.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.088]                               info, version)
[13:24:43.088]                           }
[13:24:43.088]                           base::stop(msg)
[13:24:43.088]                         }
[13:24:43.088]                       })
[13:24:43.088]                     }
[13:24:43.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.088]                     base::options(mc.cores = 1L)
[13:24:43.088]                   }
[13:24:43.088]                   options(future.plan = NULL)
[13:24:43.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.088]                 }
[13:24:43.088]                 ...future.workdir <- getwd()
[13:24:43.088]             }
[13:24:43.088]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.088]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.088]         }
[13:24:43.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.088]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.088]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.088]             base::names(...future.oldOptions))
[13:24:43.088]     }
[13:24:43.088]     if (FALSE) {
[13:24:43.088]     }
[13:24:43.088]     else {
[13:24:43.088]         if (TRUE) {
[13:24:43.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.088]                 open = "w")
[13:24:43.088]         }
[13:24:43.088]         else {
[13:24:43.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.088]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.088]         }
[13:24:43.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.088]             base::sink(type = "output", split = FALSE)
[13:24:43.088]             base::close(...future.stdout)
[13:24:43.088]         }, add = TRUE)
[13:24:43.088]     }
[13:24:43.088]     ...future.frame <- base::sys.nframe()
[13:24:43.088]     ...future.conditions <- base::list()
[13:24:43.088]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.088]     if (FALSE) {
[13:24:43.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.088]     }
[13:24:43.088]     ...future.result <- base::tryCatch({
[13:24:43.088]         base::withCallingHandlers({
[13:24:43.088]             ...future.value <- base::withVisible(base::local({
[13:24:43.088]                 ...future.makeSendCondition <- base::local({
[13:24:43.088]                   sendCondition <- NULL
[13:24:43.088]                   function(frame = 1L) {
[13:24:43.088]                     if (is.function(sendCondition)) 
[13:24:43.088]                       return(sendCondition)
[13:24:43.088]                     ns <- getNamespace("parallel")
[13:24:43.088]                     if (exists("sendData", mode = "function", 
[13:24:43.088]                       envir = ns)) {
[13:24:43.088]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.088]                         envir = ns)
[13:24:43.088]                       envir <- sys.frame(frame)
[13:24:43.088]                       master <- NULL
[13:24:43.088]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.088]                         !identical(envir, emptyenv())) {
[13:24:43.088]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.088]                           inherits = FALSE)) {
[13:24:43.088]                           master <- get("master", mode = "list", 
[13:24:43.088]                             envir = envir, inherits = FALSE)
[13:24:43.088]                           if (inherits(master, c("SOCKnode", 
[13:24:43.088]                             "SOCK0node"))) {
[13:24:43.088]                             sendCondition <<- function(cond) {
[13:24:43.088]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.088]                                 success = TRUE)
[13:24:43.088]                               parallel_sendData(master, data)
[13:24:43.088]                             }
[13:24:43.088]                             return(sendCondition)
[13:24:43.088]                           }
[13:24:43.088]                         }
[13:24:43.088]                         frame <- frame + 1L
[13:24:43.088]                         envir <- sys.frame(frame)
[13:24:43.088]                       }
[13:24:43.088]                     }
[13:24:43.088]                     sendCondition <<- function(cond) NULL
[13:24:43.088]                   }
[13:24:43.088]                 })
[13:24:43.088]                 withCallingHandlers({
[13:24:43.088]                   {
[13:24:43.088]                     1
[13:24:43.088]                   }
[13:24:43.088]                 }, immediateCondition = function(cond) {
[13:24:43.088]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.088]                   sendCondition(cond)
[13:24:43.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.088]                   {
[13:24:43.088]                     inherits <- base::inherits
[13:24:43.088]                     invokeRestart <- base::invokeRestart
[13:24:43.088]                     is.null <- base::is.null
[13:24:43.088]                     muffled <- FALSE
[13:24:43.088]                     if (inherits(cond, "message")) {
[13:24:43.088]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.088]                       if (muffled) 
[13:24:43.088]                         invokeRestart("muffleMessage")
[13:24:43.088]                     }
[13:24:43.088]                     else if (inherits(cond, "warning")) {
[13:24:43.088]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.088]                       if (muffled) 
[13:24:43.088]                         invokeRestart("muffleWarning")
[13:24:43.088]                     }
[13:24:43.088]                     else if (inherits(cond, "condition")) {
[13:24:43.088]                       if (!is.null(pattern)) {
[13:24:43.088]                         computeRestarts <- base::computeRestarts
[13:24:43.088]                         grepl <- base::grepl
[13:24:43.088]                         restarts <- computeRestarts(cond)
[13:24:43.088]                         for (restart in restarts) {
[13:24:43.088]                           name <- restart$name
[13:24:43.088]                           if (is.null(name)) 
[13:24:43.088]                             next
[13:24:43.088]                           if (!grepl(pattern, name)) 
[13:24:43.088]                             next
[13:24:43.088]                           invokeRestart(restart)
[13:24:43.088]                           muffled <- TRUE
[13:24:43.088]                           break
[13:24:43.088]                         }
[13:24:43.088]                       }
[13:24:43.088]                     }
[13:24:43.088]                     invisible(muffled)
[13:24:43.088]                   }
[13:24:43.088]                   muffleCondition(cond)
[13:24:43.088]                 })
[13:24:43.088]             }))
[13:24:43.088]             future::FutureResult(value = ...future.value$value, 
[13:24:43.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.088]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.088]                     ...future.globalenv.names))
[13:24:43.088]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.088]         }, condition = base::local({
[13:24:43.088]             c <- base::c
[13:24:43.088]             inherits <- base::inherits
[13:24:43.088]             invokeRestart <- base::invokeRestart
[13:24:43.088]             length <- base::length
[13:24:43.088]             list <- base::list
[13:24:43.088]             seq.int <- base::seq.int
[13:24:43.088]             signalCondition <- base::signalCondition
[13:24:43.088]             sys.calls <- base::sys.calls
[13:24:43.088]             `[[` <- base::`[[`
[13:24:43.088]             `+` <- base::`+`
[13:24:43.088]             `<<-` <- base::`<<-`
[13:24:43.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.088]                   3L)]
[13:24:43.088]             }
[13:24:43.088]             function(cond) {
[13:24:43.088]                 is_error <- inherits(cond, "error")
[13:24:43.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.088]                   NULL)
[13:24:43.088]                 if (is_error) {
[13:24:43.088]                   sessionInformation <- function() {
[13:24:43.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.088]                       search = base::search(), system = base::Sys.info())
[13:24:43.088]                   }
[13:24:43.088]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.088]                     cond$call), session = sessionInformation(), 
[13:24:43.088]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.088]                   signalCondition(cond)
[13:24:43.088]                 }
[13:24:43.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.088]                 "immediateCondition"))) {
[13:24:43.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.088]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.088]                   if (TRUE && !signal) {
[13:24:43.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.088]                     {
[13:24:43.088]                       inherits <- base::inherits
[13:24:43.088]                       invokeRestart <- base::invokeRestart
[13:24:43.088]                       is.null <- base::is.null
[13:24:43.088]                       muffled <- FALSE
[13:24:43.088]                       if (inherits(cond, "message")) {
[13:24:43.088]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.088]                         if (muffled) 
[13:24:43.088]                           invokeRestart("muffleMessage")
[13:24:43.088]                       }
[13:24:43.088]                       else if (inherits(cond, "warning")) {
[13:24:43.088]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.088]                         if (muffled) 
[13:24:43.088]                           invokeRestart("muffleWarning")
[13:24:43.088]                       }
[13:24:43.088]                       else if (inherits(cond, "condition")) {
[13:24:43.088]                         if (!is.null(pattern)) {
[13:24:43.088]                           computeRestarts <- base::computeRestarts
[13:24:43.088]                           grepl <- base::grepl
[13:24:43.088]                           restarts <- computeRestarts(cond)
[13:24:43.088]                           for (restart in restarts) {
[13:24:43.088]                             name <- restart$name
[13:24:43.088]                             if (is.null(name)) 
[13:24:43.088]                               next
[13:24:43.088]                             if (!grepl(pattern, name)) 
[13:24:43.088]                               next
[13:24:43.088]                             invokeRestart(restart)
[13:24:43.088]                             muffled <- TRUE
[13:24:43.088]                             break
[13:24:43.088]                           }
[13:24:43.088]                         }
[13:24:43.088]                       }
[13:24:43.088]                       invisible(muffled)
[13:24:43.088]                     }
[13:24:43.088]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.088]                   }
[13:24:43.088]                 }
[13:24:43.088]                 else {
[13:24:43.088]                   if (TRUE) {
[13:24:43.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.088]                     {
[13:24:43.088]                       inherits <- base::inherits
[13:24:43.088]                       invokeRestart <- base::invokeRestart
[13:24:43.088]                       is.null <- base::is.null
[13:24:43.088]                       muffled <- FALSE
[13:24:43.088]                       if (inherits(cond, "message")) {
[13:24:43.088]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.088]                         if (muffled) 
[13:24:43.088]                           invokeRestart("muffleMessage")
[13:24:43.088]                       }
[13:24:43.088]                       else if (inherits(cond, "warning")) {
[13:24:43.088]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.088]                         if (muffled) 
[13:24:43.088]                           invokeRestart("muffleWarning")
[13:24:43.088]                       }
[13:24:43.088]                       else if (inherits(cond, "condition")) {
[13:24:43.088]                         if (!is.null(pattern)) {
[13:24:43.088]                           computeRestarts <- base::computeRestarts
[13:24:43.088]                           grepl <- base::grepl
[13:24:43.088]                           restarts <- computeRestarts(cond)
[13:24:43.088]                           for (restart in restarts) {
[13:24:43.088]                             name <- restart$name
[13:24:43.088]                             if (is.null(name)) 
[13:24:43.088]                               next
[13:24:43.088]                             if (!grepl(pattern, name)) 
[13:24:43.088]                               next
[13:24:43.088]                             invokeRestart(restart)
[13:24:43.088]                             muffled <- TRUE
[13:24:43.088]                             break
[13:24:43.088]                           }
[13:24:43.088]                         }
[13:24:43.088]                       }
[13:24:43.088]                       invisible(muffled)
[13:24:43.088]                     }
[13:24:43.088]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.088]                   }
[13:24:43.088]                 }
[13:24:43.088]             }
[13:24:43.088]         }))
[13:24:43.088]     }, error = function(ex) {
[13:24:43.088]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.088]                 ...future.rng), started = ...future.startTime, 
[13:24:43.088]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.088]             version = "1.8"), class = "FutureResult")
[13:24:43.088]     }, finally = {
[13:24:43.088]         if (!identical(...future.workdir, getwd())) 
[13:24:43.088]             setwd(...future.workdir)
[13:24:43.088]         {
[13:24:43.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.088]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.088]             }
[13:24:43.088]             base::options(...future.oldOptions)
[13:24:43.088]             if (.Platform$OS.type == "windows") {
[13:24:43.088]                 old_names <- names(...future.oldEnvVars)
[13:24:43.088]                 envs <- base::Sys.getenv()
[13:24:43.088]                 names <- names(envs)
[13:24:43.088]                 common <- intersect(names, old_names)
[13:24:43.088]                 added <- setdiff(names, old_names)
[13:24:43.088]                 removed <- setdiff(old_names, names)
[13:24:43.088]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.088]                   envs[common]]
[13:24:43.088]                 NAMES <- toupper(changed)
[13:24:43.088]                 args <- list()
[13:24:43.088]                 for (kk in seq_along(NAMES)) {
[13:24:43.088]                   name <- changed[[kk]]
[13:24:43.088]                   NAME <- NAMES[[kk]]
[13:24:43.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.088]                     next
[13:24:43.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.088]                 }
[13:24:43.088]                 NAMES <- toupper(added)
[13:24:43.088]                 for (kk in seq_along(NAMES)) {
[13:24:43.088]                   name <- added[[kk]]
[13:24:43.088]                   NAME <- NAMES[[kk]]
[13:24:43.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.088]                     next
[13:24:43.088]                   args[[name]] <- ""
[13:24:43.088]                 }
[13:24:43.088]                 NAMES <- toupper(removed)
[13:24:43.088]                 for (kk in seq_along(NAMES)) {
[13:24:43.088]                   name <- removed[[kk]]
[13:24:43.088]                   NAME <- NAMES[[kk]]
[13:24:43.088]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.088]                     next
[13:24:43.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.088]                 }
[13:24:43.088]                 if (length(args) > 0) 
[13:24:43.088]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.088]             }
[13:24:43.088]             else {
[13:24:43.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.088]             }
[13:24:43.088]             {
[13:24:43.088]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.088]                   0L) {
[13:24:43.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.088]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.088]                   base::options(opts)
[13:24:43.088]                 }
[13:24:43.088]                 {
[13:24:43.088]                   {
[13:24:43.088]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.088]                     NULL
[13:24:43.088]                   }
[13:24:43.088]                   options(future.plan = NULL)
[13:24:43.088]                   if (is.na(NA_character_)) 
[13:24:43.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.088]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.088]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.088]                     envir = parent.frame()) 
[13:24:43.088]                   {
[13:24:43.088]                     if (is.function(workers)) 
[13:24:43.088]                       workers <- workers()
[13:24:43.088]                     workers <- structure(as.integer(workers), 
[13:24:43.088]                       class = class(workers))
[13:24:43.088]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.088]                       workers >= 1)
[13:24:43.088]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.088]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.088]                     }
[13:24:43.088]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.088]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.088]                       envir = envir)
[13:24:43.088]                     if (!future$lazy) 
[13:24:43.088]                       future <- run(future)
[13:24:43.088]                     invisible(future)
[13:24:43.088]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.088]                 }
[13:24:43.088]             }
[13:24:43.088]         }
[13:24:43.088]     })
[13:24:43.088]     if (TRUE) {
[13:24:43.088]         base::sink(type = "output", split = FALSE)
[13:24:43.088]         if (TRUE) {
[13:24:43.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.088]         }
[13:24:43.088]         else {
[13:24:43.088]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.088]         }
[13:24:43.088]         base::close(...future.stdout)
[13:24:43.088]         ...future.stdout <- NULL
[13:24:43.088]     }
[13:24:43.088]     ...future.result$conditions <- ...future.conditions
[13:24:43.088]     ...future.result$finished <- base::Sys.time()
[13:24:43.088]     ...future.result
[13:24:43.088] }
[13:24:43.091] MultisessionFuture started
[13:24:43.091] - Launch lazy future ... done
[13:24:43.091] run() for ‘MultisessionFuture’ ... done
[13:24:43.091] getGlobalsAndPackages() ...
[13:24:43.092] Searching for globals...
[13:24:43.092] - globals found: [1] ‘{’
[13:24:43.092] Searching for globals ... DONE
[13:24:43.092] Resolving globals: FALSE
[13:24:43.093] 
[13:24:43.093] 
[13:24:43.093] getGlobalsAndPackages() ... DONE
[13:24:43.093] run() for ‘Future’ ...
[13:24:43.093] - state: ‘created’
[13:24:43.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.108] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.108]   - Field: ‘node’
[13:24:43.108]   - Field: ‘label’
[13:24:43.108]   - Field: ‘local’
[13:24:43.108]   - Field: ‘owner’
[13:24:43.108]   - Field: ‘envir’
[13:24:43.109]   - Field: ‘workers’
[13:24:43.109]   - Field: ‘packages’
[13:24:43.109]   - Field: ‘gc’
[13:24:43.109]   - Field: ‘conditions’
[13:24:43.109]   - Field: ‘persistent’
[13:24:43.109]   - Field: ‘expr’
[13:24:43.109]   - Field: ‘uuid’
[13:24:43.109]   - Field: ‘seed’
[13:24:43.109]   - Field: ‘version’
[13:24:43.109]   - Field: ‘result’
[13:24:43.110]   - Field: ‘asynchronous’
[13:24:43.110]   - Field: ‘calls’
[13:24:43.110]   - Field: ‘globals’
[13:24:43.110]   - Field: ‘stdout’
[13:24:43.110]   - Field: ‘earlySignal’
[13:24:43.110]   - Field: ‘lazy’
[13:24:43.110]   - Field: ‘state’
[13:24:43.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.110] - Launch lazy future ...
[13:24:43.111] Packages needed by the future expression (n = 0): <none>
[13:24:43.111] Packages needed by future strategies (n = 0): <none>
[13:24:43.111] {
[13:24:43.111]     {
[13:24:43.111]         {
[13:24:43.111]             ...future.startTime <- base::Sys.time()
[13:24:43.111]             {
[13:24:43.111]                 {
[13:24:43.111]                   {
[13:24:43.111]                     {
[13:24:43.111]                       base::local({
[13:24:43.111]                         has_future <- base::requireNamespace("future", 
[13:24:43.111]                           quietly = TRUE)
[13:24:43.111]                         if (has_future) {
[13:24:43.111]                           ns <- base::getNamespace("future")
[13:24:43.111]                           version <- ns[[".package"]][["version"]]
[13:24:43.111]                           if (is.null(version)) 
[13:24:43.111]                             version <- utils::packageVersion("future")
[13:24:43.111]                         }
[13:24:43.111]                         else {
[13:24:43.111]                           version <- NULL
[13:24:43.111]                         }
[13:24:43.111]                         if (!has_future || version < "1.8.0") {
[13:24:43.111]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.111]                             "", base::R.version$version.string), 
[13:24:43.111]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.111]                               "release", "version")], collapse = " "), 
[13:24:43.111]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.111]                             info)
[13:24:43.111]                           info <- base::paste(info, collapse = "; ")
[13:24:43.111]                           if (!has_future) {
[13:24:43.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.111]                               info)
[13:24:43.111]                           }
[13:24:43.111]                           else {
[13:24:43.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.111]                               info, version)
[13:24:43.111]                           }
[13:24:43.111]                           base::stop(msg)
[13:24:43.111]                         }
[13:24:43.111]                       })
[13:24:43.111]                     }
[13:24:43.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.111]                     base::options(mc.cores = 1L)
[13:24:43.111]                   }
[13:24:43.111]                   options(future.plan = NULL)
[13:24:43.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.111]                 }
[13:24:43.111]                 ...future.workdir <- getwd()
[13:24:43.111]             }
[13:24:43.111]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.111]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.111]         }
[13:24:43.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.111]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.111]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.111]             base::names(...future.oldOptions))
[13:24:43.111]     }
[13:24:43.111]     if (FALSE) {
[13:24:43.111]     }
[13:24:43.111]     else {
[13:24:43.111]         if (TRUE) {
[13:24:43.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.111]                 open = "w")
[13:24:43.111]         }
[13:24:43.111]         else {
[13:24:43.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.111]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.111]         }
[13:24:43.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.111]             base::sink(type = "output", split = FALSE)
[13:24:43.111]             base::close(...future.stdout)
[13:24:43.111]         }, add = TRUE)
[13:24:43.111]     }
[13:24:43.111]     ...future.frame <- base::sys.nframe()
[13:24:43.111]     ...future.conditions <- base::list()
[13:24:43.111]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.111]     if (FALSE) {
[13:24:43.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.111]     }
[13:24:43.111]     ...future.result <- base::tryCatch({
[13:24:43.111]         base::withCallingHandlers({
[13:24:43.111]             ...future.value <- base::withVisible(base::local({
[13:24:43.111]                 ...future.makeSendCondition <- base::local({
[13:24:43.111]                   sendCondition <- NULL
[13:24:43.111]                   function(frame = 1L) {
[13:24:43.111]                     if (is.function(sendCondition)) 
[13:24:43.111]                       return(sendCondition)
[13:24:43.111]                     ns <- getNamespace("parallel")
[13:24:43.111]                     if (exists("sendData", mode = "function", 
[13:24:43.111]                       envir = ns)) {
[13:24:43.111]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.111]                         envir = ns)
[13:24:43.111]                       envir <- sys.frame(frame)
[13:24:43.111]                       master <- NULL
[13:24:43.111]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.111]                         !identical(envir, emptyenv())) {
[13:24:43.111]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.111]                           inherits = FALSE)) {
[13:24:43.111]                           master <- get("master", mode = "list", 
[13:24:43.111]                             envir = envir, inherits = FALSE)
[13:24:43.111]                           if (inherits(master, c("SOCKnode", 
[13:24:43.111]                             "SOCK0node"))) {
[13:24:43.111]                             sendCondition <<- function(cond) {
[13:24:43.111]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.111]                                 success = TRUE)
[13:24:43.111]                               parallel_sendData(master, data)
[13:24:43.111]                             }
[13:24:43.111]                             return(sendCondition)
[13:24:43.111]                           }
[13:24:43.111]                         }
[13:24:43.111]                         frame <- frame + 1L
[13:24:43.111]                         envir <- sys.frame(frame)
[13:24:43.111]                       }
[13:24:43.111]                     }
[13:24:43.111]                     sendCondition <<- function(cond) NULL
[13:24:43.111]                   }
[13:24:43.111]                 })
[13:24:43.111]                 withCallingHandlers({
[13:24:43.111]                   {
[13:24:43.111]                     2
[13:24:43.111]                   }
[13:24:43.111]                 }, immediateCondition = function(cond) {
[13:24:43.111]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.111]                   sendCondition(cond)
[13:24:43.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.111]                   {
[13:24:43.111]                     inherits <- base::inherits
[13:24:43.111]                     invokeRestart <- base::invokeRestart
[13:24:43.111]                     is.null <- base::is.null
[13:24:43.111]                     muffled <- FALSE
[13:24:43.111]                     if (inherits(cond, "message")) {
[13:24:43.111]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.111]                       if (muffled) 
[13:24:43.111]                         invokeRestart("muffleMessage")
[13:24:43.111]                     }
[13:24:43.111]                     else if (inherits(cond, "warning")) {
[13:24:43.111]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.111]                       if (muffled) 
[13:24:43.111]                         invokeRestart("muffleWarning")
[13:24:43.111]                     }
[13:24:43.111]                     else if (inherits(cond, "condition")) {
[13:24:43.111]                       if (!is.null(pattern)) {
[13:24:43.111]                         computeRestarts <- base::computeRestarts
[13:24:43.111]                         grepl <- base::grepl
[13:24:43.111]                         restarts <- computeRestarts(cond)
[13:24:43.111]                         for (restart in restarts) {
[13:24:43.111]                           name <- restart$name
[13:24:43.111]                           if (is.null(name)) 
[13:24:43.111]                             next
[13:24:43.111]                           if (!grepl(pattern, name)) 
[13:24:43.111]                             next
[13:24:43.111]                           invokeRestart(restart)
[13:24:43.111]                           muffled <- TRUE
[13:24:43.111]                           break
[13:24:43.111]                         }
[13:24:43.111]                       }
[13:24:43.111]                     }
[13:24:43.111]                     invisible(muffled)
[13:24:43.111]                   }
[13:24:43.111]                   muffleCondition(cond)
[13:24:43.111]                 })
[13:24:43.111]             }))
[13:24:43.111]             future::FutureResult(value = ...future.value$value, 
[13:24:43.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.111]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.111]                     ...future.globalenv.names))
[13:24:43.111]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.111]         }, condition = base::local({
[13:24:43.111]             c <- base::c
[13:24:43.111]             inherits <- base::inherits
[13:24:43.111]             invokeRestart <- base::invokeRestart
[13:24:43.111]             length <- base::length
[13:24:43.111]             list <- base::list
[13:24:43.111]             seq.int <- base::seq.int
[13:24:43.111]             signalCondition <- base::signalCondition
[13:24:43.111]             sys.calls <- base::sys.calls
[13:24:43.111]             `[[` <- base::`[[`
[13:24:43.111]             `+` <- base::`+`
[13:24:43.111]             `<<-` <- base::`<<-`
[13:24:43.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.111]                   3L)]
[13:24:43.111]             }
[13:24:43.111]             function(cond) {
[13:24:43.111]                 is_error <- inherits(cond, "error")
[13:24:43.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.111]                   NULL)
[13:24:43.111]                 if (is_error) {
[13:24:43.111]                   sessionInformation <- function() {
[13:24:43.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.111]                       search = base::search(), system = base::Sys.info())
[13:24:43.111]                   }
[13:24:43.111]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.111]                     cond$call), session = sessionInformation(), 
[13:24:43.111]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.111]                   signalCondition(cond)
[13:24:43.111]                 }
[13:24:43.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.111]                 "immediateCondition"))) {
[13:24:43.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.111]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.111]                   if (TRUE && !signal) {
[13:24:43.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.111]                     {
[13:24:43.111]                       inherits <- base::inherits
[13:24:43.111]                       invokeRestart <- base::invokeRestart
[13:24:43.111]                       is.null <- base::is.null
[13:24:43.111]                       muffled <- FALSE
[13:24:43.111]                       if (inherits(cond, "message")) {
[13:24:43.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.111]                         if (muffled) 
[13:24:43.111]                           invokeRestart("muffleMessage")
[13:24:43.111]                       }
[13:24:43.111]                       else if (inherits(cond, "warning")) {
[13:24:43.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.111]                         if (muffled) 
[13:24:43.111]                           invokeRestart("muffleWarning")
[13:24:43.111]                       }
[13:24:43.111]                       else if (inherits(cond, "condition")) {
[13:24:43.111]                         if (!is.null(pattern)) {
[13:24:43.111]                           computeRestarts <- base::computeRestarts
[13:24:43.111]                           grepl <- base::grepl
[13:24:43.111]                           restarts <- computeRestarts(cond)
[13:24:43.111]                           for (restart in restarts) {
[13:24:43.111]                             name <- restart$name
[13:24:43.111]                             if (is.null(name)) 
[13:24:43.111]                               next
[13:24:43.111]                             if (!grepl(pattern, name)) 
[13:24:43.111]                               next
[13:24:43.111]                             invokeRestart(restart)
[13:24:43.111]                             muffled <- TRUE
[13:24:43.111]                             break
[13:24:43.111]                           }
[13:24:43.111]                         }
[13:24:43.111]                       }
[13:24:43.111]                       invisible(muffled)
[13:24:43.111]                     }
[13:24:43.111]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.111]                   }
[13:24:43.111]                 }
[13:24:43.111]                 else {
[13:24:43.111]                   if (TRUE) {
[13:24:43.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.111]                     {
[13:24:43.111]                       inherits <- base::inherits
[13:24:43.111]                       invokeRestart <- base::invokeRestart
[13:24:43.111]                       is.null <- base::is.null
[13:24:43.111]                       muffled <- FALSE
[13:24:43.111]                       if (inherits(cond, "message")) {
[13:24:43.111]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.111]                         if (muffled) 
[13:24:43.111]                           invokeRestart("muffleMessage")
[13:24:43.111]                       }
[13:24:43.111]                       else if (inherits(cond, "warning")) {
[13:24:43.111]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.111]                         if (muffled) 
[13:24:43.111]                           invokeRestart("muffleWarning")
[13:24:43.111]                       }
[13:24:43.111]                       else if (inherits(cond, "condition")) {
[13:24:43.111]                         if (!is.null(pattern)) {
[13:24:43.111]                           computeRestarts <- base::computeRestarts
[13:24:43.111]                           grepl <- base::grepl
[13:24:43.111]                           restarts <- computeRestarts(cond)
[13:24:43.111]                           for (restart in restarts) {
[13:24:43.111]                             name <- restart$name
[13:24:43.111]                             if (is.null(name)) 
[13:24:43.111]                               next
[13:24:43.111]                             if (!grepl(pattern, name)) 
[13:24:43.111]                               next
[13:24:43.111]                             invokeRestart(restart)
[13:24:43.111]                             muffled <- TRUE
[13:24:43.111]                             break
[13:24:43.111]                           }
[13:24:43.111]                         }
[13:24:43.111]                       }
[13:24:43.111]                       invisible(muffled)
[13:24:43.111]                     }
[13:24:43.111]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.111]                   }
[13:24:43.111]                 }
[13:24:43.111]             }
[13:24:43.111]         }))
[13:24:43.111]     }, error = function(ex) {
[13:24:43.111]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.111]                 ...future.rng), started = ...future.startTime, 
[13:24:43.111]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.111]             version = "1.8"), class = "FutureResult")
[13:24:43.111]     }, finally = {
[13:24:43.111]         if (!identical(...future.workdir, getwd())) 
[13:24:43.111]             setwd(...future.workdir)
[13:24:43.111]         {
[13:24:43.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.111]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.111]             }
[13:24:43.111]             base::options(...future.oldOptions)
[13:24:43.111]             if (.Platform$OS.type == "windows") {
[13:24:43.111]                 old_names <- names(...future.oldEnvVars)
[13:24:43.111]                 envs <- base::Sys.getenv()
[13:24:43.111]                 names <- names(envs)
[13:24:43.111]                 common <- intersect(names, old_names)
[13:24:43.111]                 added <- setdiff(names, old_names)
[13:24:43.111]                 removed <- setdiff(old_names, names)
[13:24:43.111]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.111]                   envs[common]]
[13:24:43.111]                 NAMES <- toupper(changed)
[13:24:43.111]                 args <- list()
[13:24:43.111]                 for (kk in seq_along(NAMES)) {
[13:24:43.111]                   name <- changed[[kk]]
[13:24:43.111]                   NAME <- NAMES[[kk]]
[13:24:43.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.111]                     next
[13:24:43.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.111]                 }
[13:24:43.111]                 NAMES <- toupper(added)
[13:24:43.111]                 for (kk in seq_along(NAMES)) {
[13:24:43.111]                   name <- added[[kk]]
[13:24:43.111]                   NAME <- NAMES[[kk]]
[13:24:43.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.111]                     next
[13:24:43.111]                   args[[name]] <- ""
[13:24:43.111]                 }
[13:24:43.111]                 NAMES <- toupper(removed)
[13:24:43.111]                 for (kk in seq_along(NAMES)) {
[13:24:43.111]                   name <- removed[[kk]]
[13:24:43.111]                   NAME <- NAMES[[kk]]
[13:24:43.111]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.111]                     next
[13:24:43.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.111]                 }
[13:24:43.111]                 if (length(args) > 0) 
[13:24:43.111]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.111]             }
[13:24:43.111]             else {
[13:24:43.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.111]             }
[13:24:43.111]             {
[13:24:43.111]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.111]                   0L) {
[13:24:43.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.111]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.111]                   base::options(opts)
[13:24:43.111]                 }
[13:24:43.111]                 {
[13:24:43.111]                   {
[13:24:43.111]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.111]                     NULL
[13:24:43.111]                   }
[13:24:43.111]                   options(future.plan = NULL)
[13:24:43.111]                   if (is.na(NA_character_)) 
[13:24:43.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.111]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.111]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.111]                     envir = parent.frame()) 
[13:24:43.111]                   {
[13:24:43.111]                     if (is.function(workers)) 
[13:24:43.111]                       workers <- workers()
[13:24:43.111]                     workers <- structure(as.integer(workers), 
[13:24:43.111]                       class = class(workers))
[13:24:43.111]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.111]                       workers >= 1)
[13:24:43.111]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.111]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.111]                     }
[13:24:43.111]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.111]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.111]                       envir = envir)
[13:24:43.111]                     if (!future$lazy) 
[13:24:43.111]                       future <- run(future)
[13:24:43.111]                     invisible(future)
[13:24:43.111]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.111]                 }
[13:24:43.111]             }
[13:24:43.111]         }
[13:24:43.111]     })
[13:24:43.111]     if (TRUE) {
[13:24:43.111]         base::sink(type = "output", split = FALSE)
[13:24:43.111]         if (TRUE) {
[13:24:43.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.111]         }
[13:24:43.111]         else {
[13:24:43.111]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.111]         }
[13:24:43.111]         base::close(...future.stdout)
[13:24:43.111]         ...future.stdout <- NULL
[13:24:43.111]     }
[13:24:43.111]     ...future.result$conditions <- ...future.conditions
[13:24:43.111]     ...future.result$finished <- base::Sys.time()
[13:24:43.111]     ...future.result
[13:24:43.111] }
[13:24:43.114] MultisessionFuture started
[13:24:43.115] - Launch lazy future ... done
[13:24:43.115] run() for ‘MultisessionFuture’ ... done
[13:24:43.115] resolve() on environment ...
[13:24:43.115]  recursive: 0
[13:24:43.116]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:24:43.137]  length: 2 (resolved future 3)
[13:24:43.148] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.148] - Validating connection of MultisessionFuture
[13:24:43.148] - received message: FutureResult
[13:24:43.148] - Received FutureResult
[13:24:43.148] - Erased future from FutureRegistry
[13:24:43.148] result() for ClusterFuture ...
[13:24:43.149] - result already collected: FutureResult
[13:24:43.149] result() for ClusterFuture ... done
[13:24:43.149] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.149] Future #1
[13:24:43.149]  length: 1 (resolved future 1)
[13:24:43.170] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.170] - Validating connection of MultisessionFuture
[13:24:43.170] - received message: FutureResult
[13:24:43.170] - Received FutureResult
[13:24:43.170] - Erased future from FutureRegistry
[13:24:43.171] result() for ClusterFuture ...
[13:24:43.171] - result already collected: FutureResult
[13:24:43.171] result() for ClusterFuture ... done
[13:24:43.171] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.171] Future #2
[13:24:43.171]  length: 0 (resolved future 2)
[13:24:43.171] resolve() on environment ... DONE
[13:24:43.172] getGlobalsAndPackages() ...
[13:24:43.172] Searching for globals...
[13:24:43.172] - globals found: [1] ‘{’
[13:24:43.173] Searching for globals ... DONE
[13:24:43.173] Resolving globals: FALSE
[13:24:43.173] 
[13:24:43.173] 
[13:24:43.173] getGlobalsAndPackages() ... DONE
[13:24:43.173] run() for ‘Future’ ...
[13:24:43.173] - state: ‘created’
[13:24:43.174] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.187] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.188]   - Field: ‘node’
[13:24:43.188]   - Field: ‘label’
[13:24:43.188]   - Field: ‘local’
[13:24:43.188]   - Field: ‘owner’
[13:24:43.188]   - Field: ‘envir’
[13:24:43.188]   - Field: ‘workers’
[13:24:43.188]   - Field: ‘packages’
[13:24:43.188]   - Field: ‘gc’
[13:24:43.188]   - Field: ‘conditions’
[13:24:43.188]   - Field: ‘persistent’
[13:24:43.189]   - Field: ‘expr’
[13:24:43.189]   - Field: ‘uuid’
[13:24:43.189]   - Field: ‘seed’
[13:24:43.189]   - Field: ‘version’
[13:24:43.189]   - Field: ‘result’
[13:24:43.189]   - Field: ‘asynchronous’
[13:24:43.189]   - Field: ‘calls’
[13:24:43.189]   - Field: ‘globals’
[13:24:43.189]   - Field: ‘stdout’
[13:24:43.189]   - Field: ‘earlySignal’
[13:24:43.190]   - Field: ‘lazy’
[13:24:43.190]   - Field: ‘state’
[13:24:43.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.190] - Launch lazy future ...
[13:24:43.190] Packages needed by the future expression (n = 0): <none>
[13:24:43.190] Packages needed by future strategies (n = 0): <none>
[13:24:43.191] {
[13:24:43.191]     {
[13:24:43.191]         {
[13:24:43.191]             ...future.startTime <- base::Sys.time()
[13:24:43.191]             {
[13:24:43.191]                 {
[13:24:43.191]                   {
[13:24:43.191]                     {
[13:24:43.191]                       base::local({
[13:24:43.191]                         has_future <- base::requireNamespace("future", 
[13:24:43.191]                           quietly = TRUE)
[13:24:43.191]                         if (has_future) {
[13:24:43.191]                           ns <- base::getNamespace("future")
[13:24:43.191]                           version <- ns[[".package"]][["version"]]
[13:24:43.191]                           if (is.null(version)) 
[13:24:43.191]                             version <- utils::packageVersion("future")
[13:24:43.191]                         }
[13:24:43.191]                         else {
[13:24:43.191]                           version <- NULL
[13:24:43.191]                         }
[13:24:43.191]                         if (!has_future || version < "1.8.0") {
[13:24:43.191]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.191]                             "", base::R.version$version.string), 
[13:24:43.191]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.191]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.191]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.191]                               "release", "version")], collapse = " "), 
[13:24:43.191]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.191]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.191]                             info)
[13:24:43.191]                           info <- base::paste(info, collapse = "; ")
[13:24:43.191]                           if (!has_future) {
[13:24:43.191]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.191]                               info)
[13:24:43.191]                           }
[13:24:43.191]                           else {
[13:24:43.191]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.191]                               info, version)
[13:24:43.191]                           }
[13:24:43.191]                           base::stop(msg)
[13:24:43.191]                         }
[13:24:43.191]                       })
[13:24:43.191]                     }
[13:24:43.191]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.191]                     base::options(mc.cores = 1L)
[13:24:43.191]                   }
[13:24:43.191]                   options(future.plan = NULL)
[13:24:43.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.191]                 }
[13:24:43.191]                 ...future.workdir <- getwd()
[13:24:43.191]             }
[13:24:43.191]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.191]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.191]         }
[13:24:43.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.191]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.191]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.191]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.191]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.191]             base::names(...future.oldOptions))
[13:24:43.191]     }
[13:24:43.191]     if (FALSE) {
[13:24:43.191]     }
[13:24:43.191]     else {
[13:24:43.191]         if (TRUE) {
[13:24:43.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.191]                 open = "w")
[13:24:43.191]         }
[13:24:43.191]         else {
[13:24:43.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.191]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.191]         }
[13:24:43.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.191]             base::sink(type = "output", split = FALSE)
[13:24:43.191]             base::close(...future.stdout)
[13:24:43.191]         }, add = TRUE)
[13:24:43.191]     }
[13:24:43.191]     ...future.frame <- base::sys.nframe()
[13:24:43.191]     ...future.conditions <- base::list()
[13:24:43.191]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.191]     if (FALSE) {
[13:24:43.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.191]     }
[13:24:43.191]     ...future.result <- base::tryCatch({
[13:24:43.191]         base::withCallingHandlers({
[13:24:43.191]             ...future.value <- base::withVisible(base::local({
[13:24:43.191]                 ...future.makeSendCondition <- base::local({
[13:24:43.191]                   sendCondition <- NULL
[13:24:43.191]                   function(frame = 1L) {
[13:24:43.191]                     if (is.function(sendCondition)) 
[13:24:43.191]                       return(sendCondition)
[13:24:43.191]                     ns <- getNamespace("parallel")
[13:24:43.191]                     if (exists("sendData", mode = "function", 
[13:24:43.191]                       envir = ns)) {
[13:24:43.191]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.191]                         envir = ns)
[13:24:43.191]                       envir <- sys.frame(frame)
[13:24:43.191]                       master <- NULL
[13:24:43.191]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.191]                         !identical(envir, emptyenv())) {
[13:24:43.191]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.191]                           inherits = FALSE)) {
[13:24:43.191]                           master <- get("master", mode = "list", 
[13:24:43.191]                             envir = envir, inherits = FALSE)
[13:24:43.191]                           if (inherits(master, c("SOCKnode", 
[13:24:43.191]                             "SOCK0node"))) {
[13:24:43.191]                             sendCondition <<- function(cond) {
[13:24:43.191]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.191]                                 success = TRUE)
[13:24:43.191]                               parallel_sendData(master, data)
[13:24:43.191]                             }
[13:24:43.191]                             return(sendCondition)
[13:24:43.191]                           }
[13:24:43.191]                         }
[13:24:43.191]                         frame <- frame + 1L
[13:24:43.191]                         envir <- sys.frame(frame)
[13:24:43.191]                       }
[13:24:43.191]                     }
[13:24:43.191]                     sendCondition <<- function(cond) NULL
[13:24:43.191]                   }
[13:24:43.191]                 })
[13:24:43.191]                 withCallingHandlers({
[13:24:43.191]                   {
[13:24:43.191]                     1
[13:24:43.191]                   }
[13:24:43.191]                 }, immediateCondition = function(cond) {
[13:24:43.191]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.191]                   sendCondition(cond)
[13:24:43.191]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.191]                   {
[13:24:43.191]                     inherits <- base::inherits
[13:24:43.191]                     invokeRestart <- base::invokeRestart
[13:24:43.191]                     is.null <- base::is.null
[13:24:43.191]                     muffled <- FALSE
[13:24:43.191]                     if (inherits(cond, "message")) {
[13:24:43.191]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.191]                       if (muffled) 
[13:24:43.191]                         invokeRestart("muffleMessage")
[13:24:43.191]                     }
[13:24:43.191]                     else if (inherits(cond, "warning")) {
[13:24:43.191]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.191]                       if (muffled) 
[13:24:43.191]                         invokeRestart("muffleWarning")
[13:24:43.191]                     }
[13:24:43.191]                     else if (inherits(cond, "condition")) {
[13:24:43.191]                       if (!is.null(pattern)) {
[13:24:43.191]                         computeRestarts <- base::computeRestarts
[13:24:43.191]                         grepl <- base::grepl
[13:24:43.191]                         restarts <- computeRestarts(cond)
[13:24:43.191]                         for (restart in restarts) {
[13:24:43.191]                           name <- restart$name
[13:24:43.191]                           if (is.null(name)) 
[13:24:43.191]                             next
[13:24:43.191]                           if (!grepl(pattern, name)) 
[13:24:43.191]                             next
[13:24:43.191]                           invokeRestart(restart)
[13:24:43.191]                           muffled <- TRUE
[13:24:43.191]                           break
[13:24:43.191]                         }
[13:24:43.191]                       }
[13:24:43.191]                     }
[13:24:43.191]                     invisible(muffled)
[13:24:43.191]                   }
[13:24:43.191]                   muffleCondition(cond)
[13:24:43.191]                 })
[13:24:43.191]             }))
[13:24:43.191]             future::FutureResult(value = ...future.value$value, 
[13:24:43.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.191]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.191]                     ...future.globalenv.names))
[13:24:43.191]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.191]         }, condition = base::local({
[13:24:43.191]             c <- base::c
[13:24:43.191]             inherits <- base::inherits
[13:24:43.191]             invokeRestart <- base::invokeRestart
[13:24:43.191]             length <- base::length
[13:24:43.191]             list <- base::list
[13:24:43.191]             seq.int <- base::seq.int
[13:24:43.191]             signalCondition <- base::signalCondition
[13:24:43.191]             sys.calls <- base::sys.calls
[13:24:43.191]             `[[` <- base::`[[`
[13:24:43.191]             `+` <- base::`+`
[13:24:43.191]             `<<-` <- base::`<<-`
[13:24:43.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.191]                   3L)]
[13:24:43.191]             }
[13:24:43.191]             function(cond) {
[13:24:43.191]                 is_error <- inherits(cond, "error")
[13:24:43.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.191]                   NULL)
[13:24:43.191]                 if (is_error) {
[13:24:43.191]                   sessionInformation <- function() {
[13:24:43.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.191]                       search = base::search(), system = base::Sys.info())
[13:24:43.191]                   }
[13:24:43.191]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.191]                     cond$call), session = sessionInformation(), 
[13:24:43.191]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.191]                   signalCondition(cond)
[13:24:43.191]                 }
[13:24:43.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.191]                 "immediateCondition"))) {
[13:24:43.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.191]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.191]                   if (TRUE && !signal) {
[13:24:43.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.191]                     {
[13:24:43.191]                       inherits <- base::inherits
[13:24:43.191]                       invokeRestart <- base::invokeRestart
[13:24:43.191]                       is.null <- base::is.null
[13:24:43.191]                       muffled <- FALSE
[13:24:43.191]                       if (inherits(cond, "message")) {
[13:24:43.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.191]                         if (muffled) 
[13:24:43.191]                           invokeRestart("muffleMessage")
[13:24:43.191]                       }
[13:24:43.191]                       else if (inherits(cond, "warning")) {
[13:24:43.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.191]                         if (muffled) 
[13:24:43.191]                           invokeRestart("muffleWarning")
[13:24:43.191]                       }
[13:24:43.191]                       else if (inherits(cond, "condition")) {
[13:24:43.191]                         if (!is.null(pattern)) {
[13:24:43.191]                           computeRestarts <- base::computeRestarts
[13:24:43.191]                           grepl <- base::grepl
[13:24:43.191]                           restarts <- computeRestarts(cond)
[13:24:43.191]                           for (restart in restarts) {
[13:24:43.191]                             name <- restart$name
[13:24:43.191]                             if (is.null(name)) 
[13:24:43.191]                               next
[13:24:43.191]                             if (!grepl(pattern, name)) 
[13:24:43.191]                               next
[13:24:43.191]                             invokeRestart(restart)
[13:24:43.191]                             muffled <- TRUE
[13:24:43.191]                             break
[13:24:43.191]                           }
[13:24:43.191]                         }
[13:24:43.191]                       }
[13:24:43.191]                       invisible(muffled)
[13:24:43.191]                     }
[13:24:43.191]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.191]                   }
[13:24:43.191]                 }
[13:24:43.191]                 else {
[13:24:43.191]                   if (TRUE) {
[13:24:43.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.191]                     {
[13:24:43.191]                       inherits <- base::inherits
[13:24:43.191]                       invokeRestart <- base::invokeRestart
[13:24:43.191]                       is.null <- base::is.null
[13:24:43.191]                       muffled <- FALSE
[13:24:43.191]                       if (inherits(cond, "message")) {
[13:24:43.191]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.191]                         if (muffled) 
[13:24:43.191]                           invokeRestart("muffleMessage")
[13:24:43.191]                       }
[13:24:43.191]                       else if (inherits(cond, "warning")) {
[13:24:43.191]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.191]                         if (muffled) 
[13:24:43.191]                           invokeRestart("muffleWarning")
[13:24:43.191]                       }
[13:24:43.191]                       else if (inherits(cond, "condition")) {
[13:24:43.191]                         if (!is.null(pattern)) {
[13:24:43.191]                           computeRestarts <- base::computeRestarts
[13:24:43.191]                           grepl <- base::grepl
[13:24:43.191]                           restarts <- computeRestarts(cond)
[13:24:43.191]                           for (restart in restarts) {
[13:24:43.191]                             name <- restart$name
[13:24:43.191]                             if (is.null(name)) 
[13:24:43.191]                               next
[13:24:43.191]                             if (!grepl(pattern, name)) 
[13:24:43.191]                               next
[13:24:43.191]                             invokeRestart(restart)
[13:24:43.191]                             muffled <- TRUE
[13:24:43.191]                             break
[13:24:43.191]                           }
[13:24:43.191]                         }
[13:24:43.191]                       }
[13:24:43.191]                       invisible(muffled)
[13:24:43.191]                     }
[13:24:43.191]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.191]                   }
[13:24:43.191]                 }
[13:24:43.191]             }
[13:24:43.191]         }))
[13:24:43.191]     }, error = function(ex) {
[13:24:43.191]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.191]                 ...future.rng), started = ...future.startTime, 
[13:24:43.191]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.191]             version = "1.8"), class = "FutureResult")
[13:24:43.191]     }, finally = {
[13:24:43.191]         if (!identical(...future.workdir, getwd())) 
[13:24:43.191]             setwd(...future.workdir)
[13:24:43.191]         {
[13:24:43.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.191]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.191]             }
[13:24:43.191]             base::options(...future.oldOptions)
[13:24:43.191]             if (.Platform$OS.type == "windows") {
[13:24:43.191]                 old_names <- names(...future.oldEnvVars)
[13:24:43.191]                 envs <- base::Sys.getenv()
[13:24:43.191]                 names <- names(envs)
[13:24:43.191]                 common <- intersect(names, old_names)
[13:24:43.191]                 added <- setdiff(names, old_names)
[13:24:43.191]                 removed <- setdiff(old_names, names)
[13:24:43.191]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.191]                   envs[common]]
[13:24:43.191]                 NAMES <- toupper(changed)
[13:24:43.191]                 args <- list()
[13:24:43.191]                 for (kk in seq_along(NAMES)) {
[13:24:43.191]                   name <- changed[[kk]]
[13:24:43.191]                   NAME <- NAMES[[kk]]
[13:24:43.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.191]                     next
[13:24:43.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.191]                 }
[13:24:43.191]                 NAMES <- toupper(added)
[13:24:43.191]                 for (kk in seq_along(NAMES)) {
[13:24:43.191]                   name <- added[[kk]]
[13:24:43.191]                   NAME <- NAMES[[kk]]
[13:24:43.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.191]                     next
[13:24:43.191]                   args[[name]] <- ""
[13:24:43.191]                 }
[13:24:43.191]                 NAMES <- toupper(removed)
[13:24:43.191]                 for (kk in seq_along(NAMES)) {
[13:24:43.191]                   name <- removed[[kk]]
[13:24:43.191]                   NAME <- NAMES[[kk]]
[13:24:43.191]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.191]                     next
[13:24:43.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.191]                 }
[13:24:43.191]                 if (length(args) > 0) 
[13:24:43.191]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.191]             }
[13:24:43.191]             else {
[13:24:43.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.191]             }
[13:24:43.191]             {
[13:24:43.191]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.191]                   0L) {
[13:24:43.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.191]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.191]                   base::options(opts)
[13:24:43.191]                 }
[13:24:43.191]                 {
[13:24:43.191]                   {
[13:24:43.191]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.191]                     NULL
[13:24:43.191]                   }
[13:24:43.191]                   options(future.plan = NULL)
[13:24:43.191]                   if (is.na(NA_character_)) 
[13:24:43.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.191]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.191]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.191]                     envir = parent.frame()) 
[13:24:43.191]                   {
[13:24:43.191]                     if (is.function(workers)) 
[13:24:43.191]                       workers <- workers()
[13:24:43.191]                     workers <- structure(as.integer(workers), 
[13:24:43.191]                       class = class(workers))
[13:24:43.191]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.191]                       workers >= 1)
[13:24:43.191]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.191]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.191]                     }
[13:24:43.191]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.191]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.191]                       envir = envir)
[13:24:43.191]                     if (!future$lazy) 
[13:24:43.191]                       future <- run(future)
[13:24:43.191]                     invisible(future)
[13:24:43.191]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.191]                 }
[13:24:43.191]             }
[13:24:43.191]         }
[13:24:43.191]     })
[13:24:43.191]     if (TRUE) {
[13:24:43.191]         base::sink(type = "output", split = FALSE)
[13:24:43.191]         if (TRUE) {
[13:24:43.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.191]         }
[13:24:43.191]         else {
[13:24:43.191]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.191]         }
[13:24:43.191]         base::close(...future.stdout)
[13:24:43.191]         ...future.stdout <- NULL
[13:24:43.191]     }
[13:24:43.191]     ...future.result$conditions <- ...future.conditions
[13:24:43.191]     ...future.result$finished <- base::Sys.time()
[13:24:43.191]     ...future.result
[13:24:43.191] }
[13:24:43.194] MultisessionFuture started
[13:24:43.194] - Launch lazy future ... done
[13:24:43.194] run() for ‘MultisessionFuture’ ... done
[13:24:43.194] getGlobalsAndPackages() ...
[13:24:43.195] Searching for globals...
[13:24:43.195] - globals found: [1] ‘{’
[13:24:43.195] Searching for globals ... DONE
[13:24:43.195] Resolving globals: FALSE
[13:24:43.196] 
[13:24:43.196] 
[13:24:43.196] getGlobalsAndPackages() ... DONE
[13:24:43.196] run() for ‘Future’ ...
[13:24:43.196] - state: ‘created’
[13:24:43.196] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.211] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.211]   - Field: ‘node’
[13:24:43.211]   - Field: ‘label’
[13:24:43.211]   - Field: ‘local’
[13:24:43.211]   - Field: ‘owner’
[13:24:43.212]   - Field: ‘envir’
[13:24:43.212]   - Field: ‘workers’
[13:24:43.212]   - Field: ‘packages’
[13:24:43.212]   - Field: ‘gc’
[13:24:43.212]   - Field: ‘conditions’
[13:24:43.212]   - Field: ‘persistent’
[13:24:43.212]   - Field: ‘expr’
[13:24:43.212]   - Field: ‘uuid’
[13:24:43.212]   - Field: ‘seed’
[13:24:43.212]   - Field: ‘version’
[13:24:43.213]   - Field: ‘result’
[13:24:43.213]   - Field: ‘asynchronous’
[13:24:43.213]   - Field: ‘calls’
[13:24:43.213]   - Field: ‘globals’
[13:24:43.213]   - Field: ‘stdout’
[13:24:43.213]   - Field: ‘earlySignal’
[13:24:43.213]   - Field: ‘lazy’
[13:24:43.213]   - Field: ‘state’
[13:24:43.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.213] - Launch lazy future ...
[13:24:43.214] Packages needed by the future expression (n = 0): <none>
[13:24:43.214] Packages needed by future strategies (n = 0): <none>
[13:24:43.214] {
[13:24:43.214]     {
[13:24:43.214]         {
[13:24:43.214]             ...future.startTime <- base::Sys.time()
[13:24:43.214]             {
[13:24:43.214]                 {
[13:24:43.214]                   {
[13:24:43.214]                     {
[13:24:43.214]                       base::local({
[13:24:43.214]                         has_future <- base::requireNamespace("future", 
[13:24:43.214]                           quietly = TRUE)
[13:24:43.214]                         if (has_future) {
[13:24:43.214]                           ns <- base::getNamespace("future")
[13:24:43.214]                           version <- ns[[".package"]][["version"]]
[13:24:43.214]                           if (is.null(version)) 
[13:24:43.214]                             version <- utils::packageVersion("future")
[13:24:43.214]                         }
[13:24:43.214]                         else {
[13:24:43.214]                           version <- NULL
[13:24:43.214]                         }
[13:24:43.214]                         if (!has_future || version < "1.8.0") {
[13:24:43.214]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.214]                             "", base::R.version$version.string), 
[13:24:43.214]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.214]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.214]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.214]                               "release", "version")], collapse = " "), 
[13:24:43.214]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.214]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.214]                             info)
[13:24:43.214]                           info <- base::paste(info, collapse = "; ")
[13:24:43.214]                           if (!has_future) {
[13:24:43.214]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.214]                               info)
[13:24:43.214]                           }
[13:24:43.214]                           else {
[13:24:43.214]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.214]                               info, version)
[13:24:43.214]                           }
[13:24:43.214]                           base::stop(msg)
[13:24:43.214]                         }
[13:24:43.214]                       })
[13:24:43.214]                     }
[13:24:43.214]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.214]                     base::options(mc.cores = 1L)
[13:24:43.214]                   }
[13:24:43.214]                   options(future.plan = NULL)
[13:24:43.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.214]                 }
[13:24:43.214]                 ...future.workdir <- getwd()
[13:24:43.214]             }
[13:24:43.214]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.214]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.214]         }
[13:24:43.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.214]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.214]             base::names(...future.oldOptions))
[13:24:43.214]     }
[13:24:43.214]     if (FALSE) {
[13:24:43.214]     }
[13:24:43.214]     else {
[13:24:43.214]         if (TRUE) {
[13:24:43.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.214]                 open = "w")
[13:24:43.214]         }
[13:24:43.214]         else {
[13:24:43.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.214]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.214]         }
[13:24:43.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.214]             base::sink(type = "output", split = FALSE)
[13:24:43.214]             base::close(...future.stdout)
[13:24:43.214]         }, add = TRUE)
[13:24:43.214]     }
[13:24:43.214]     ...future.frame <- base::sys.nframe()
[13:24:43.214]     ...future.conditions <- base::list()
[13:24:43.214]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.214]     if (FALSE) {
[13:24:43.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.214]     }
[13:24:43.214]     ...future.result <- base::tryCatch({
[13:24:43.214]         base::withCallingHandlers({
[13:24:43.214]             ...future.value <- base::withVisible(base::local({
[13:24:43.214]                 ...future.makeSendCondition <- base::local({
[13:24:43.214]                   sendCondition <- NULL
[13:24:43.214]                   function(frame = 1L) {
[13:24:43.214]                     if (is.function(sendCondition)) 
[13:24:43.214]                       return(sendCondition)
[13:24:43.214]                     ns <- getNamespace("parallel")
[13:24:43.214]                     if (exists("sendData", mode = "function", 
[13:24:43.214]                       envir = ns)) {
[13:24:43.214]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.214]                         envir = ns)
[13:24:43.214]                       envir <- sys.frame(frame)
[13:24:43.214]                       master <- NULL
[13:24:43.214]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.214]                         !identical(envir, emptyenv())) {
[13:24:43.214]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.214]                           inherits = FALSE)) {
[13:24:43.214]                           master <- get("master", mode = "list", 
[13:24:43.214]                             envir = envir, inherits = FALSE)
[13:24:43.214]                           if (inherits(master, c("SOCKnode", 
[13:24:43.214]                             "SOCK0node"))) {
[13:24:43.214]                             sendCondition <<- function(cond) {
[13:24:43.214]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.214]                                 success = TRUE)
[13:24:43.214]                               parallel_sendData(master, data)
[13:24:43.214]                             }
[13:24:43.214]                             return(sendCondition)
[13:24:43.214]                           }
[13:24:43.214]                         }
[13:24:43.214]                         frame <- frame + 1L
[13:24:43.214]                         envir <- sys.frame(frame)
[13:24:43.214]                       }
[13:24:43.214]                     }
[13:24:43.214]                     sendCondition <<- function(cond) NULL
[13:24:43.214]                   }
[13:24:43.214]                 })
[13:24:43.214]                 withCallingHandlers({
[13:24:43.214]                   {
[13:24:43.214]                     2
[13:24:43.214]                   }
[13:24:43.214]                 }, immediateCondition = function(cond) {
[13:24:43.214]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.214]                   sendCondition(cond)
[13:24:43.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.214]                   {
[13:24:43.214]                     inherits <- base::inherits
[13:24:43.214]                     invokeRestart <- base::invokeRestart
[13:24:43.214]                     is.null <- base::is.null
[13:24:43.214]                     muffled <- FALSE
[13:24:43.214]                     if (inherits(cond, "message")) {
[13:24:43.214]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.214]                       if (muffled) 
[13:24:43.214]                         invokeRestart("muffleMessage")
[13:24:43.214]                     }
[13:24:43.214]                     else if (inherits(cond, "warning")) {
[13:24:43.214]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.214]                       if (muffled) 
[13:24:43.214]                         invokeRestart("muffleWarning")
[13:24:43.214]                     }
[13:24:43.214]                     else if (inherits(cond, "condition")) {
[13:24:43.214]                       if (!is.null(pattern)) {
[13:24:43.214]                         computeRestarts <- base::computeRestarts
[13:24:43.214]                         grepl <- base::grepl
[13:24:43.214]                         restarts <- computeRestarts(cond)
[13:24:43.214]                         for (restart in restarts) {
[13:24:43.214]                           name <- restart$name
[13:24:43.214]                           if (is.null(name)) 
[13:24:43.214]                             next
[13:24:43.214]                           if (!grepl(pattern, name)) 
[13:24:43.214]                             next
[13:24:43.214]                           invokeRestart(restart)
[13:24:43.214]                           muffled <- TRUE
[13:24:43.214]                           break
[13:24:43.214]                         }
[13:24:43.214]                       }
[13:24:43.214]                     }
[13:24:43.214]                     invisible(muffled)
[13:24:43.214]                   }
[13:24:43.214]                   muffleCondition(cond)
[13:24:43.214]                 })
[13:24:43.214]             }))
[13:24:43.214]             future::FutureResult(value = ...future.value$value, 
[13:24:43.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.214]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.214]                     ...future.globalenv.names))
[13:24:43.214]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.214]         }, condition = base::local({
[13:24:43.214]             c <- base::c
[13:24:43.214]             inherits <- base::inherits
[13:24:43.214]             invokeRestart <- base::invokeRestart
[13:24:43.214]             length <- base::length
[13:24:43.214]             list <- base::list
[13:24:43.214]             seq.int <- base::seq.int
[13:24:43.214]             signalCondition <- base::signalCondition
[13:24:43.214]             sys.calls <- base::sys.calls
[13:24:43.214]             `[[` <- base::`[[`
[13:24:43.214]             `+` <- base::`+`
[13:24:43.214]             `<<-` <- base::`<<-`
[13:24:43.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.214]                   3L)]
[13:24:43.214]             }
[13:24:43.214]             function(cond) {
[13:24:43.214]                 is_error <- inherits(cond, "error")
[13:24:43.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.214]                   NULL)
[13:24:43.214]                 if (is_error) {
[13:24:43.214]                   sessionInformation <- function() {
[13:24:43.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.214]                       search = base::search(), system = base::Sys.info())
[13:24:43.214]                   }
[13:24:43.214]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.214]                     cond$call), session = sessionInformation(), 
[13:24:43.214]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.214]                   signalCondition(cond)
[13:24:43.214]                 }
[13:24:43.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.214]                 "immediateCondition"))) {
[13:24:43.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.214]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.214]                   if (TRUE && !signal) {
[13:24:43.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.214]                     {
[13:24:43.214]                       inherits <- base::inherits
[13:24:43.214]                       invokeRestart <- base::invokeRestart
[13:24:43.214]                       is.null <- base::is.null
[13:24:43.214]                       muffled <- FALSE
[13:24:43.214]                       if (inherits(cond, "message")) {
[13:24:43.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.214]                         if (muffled) 
[13:24:43.214]                           invokeRestart("muffleMessage")
[13:24:43.214]                       }
[13:24:43.214]                       else if (inherits(cond, "warning")) {
[13:24:43.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.214]                         if (muffled) 
[13:24:43.214]                           invokeRestart("muffleWarning")
[13:24:43.214]                       }
[13:24:43.214]                       else if (inherits(cond, "condition")) {
[13:24:43.214]                         if (!is.null(pattern)) {
[13:24:43.214]                           computeRestarts <- base::computeRestarts
[13:24:43.214]                           grepl <- base::grepl
[13:24:43.214]                           restarts <- computeRestarts(cond)
[13:24:43.214]                           for (restart in restarts) {
[13:24:43.214]                             name <- restart$name
[13:24:43.214]                             if (is.null(name)) 
[13:24:43.214]                               next
[13:24:43.214]                             if (!grepl(pattern, name)) 
[13:24:43.214]                               next
[13:24:43.214]                             invokeRestart(restart)
[13:24:43.214]                             muffled <- TRUE
[13:24:43.214]                             break
[13:24:43.214]                           }
[13:24:43.214]                         }
[13:24:43.214]                       }
[13:24:43.214]                       invisible(muffled)
[13:24:43.214]                     }
[13:24:43.214]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.214]                   }
[13:24:43.214]                 }
[13:24:43.214]                 else {
[13:24:43.214]                   if (TRUE) {
[13:24:43.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.214]                     {
[13:24:43.214]                       inherits <- base::inherits
[13:24:43.214]                       invokeRestart <- base::invokeRestart
[13:24:43.214]                       is.null <- base::is.null
[13:24:43.214]                       muffled <- FALSE
[13:24:43.214]                       if (inherits(cond, "message")) {
[13:24:43.214]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.214]                         if (muffled) 
[13:24:43.214]                           invokeRestart("muffleMessage")
[13:24:43.214]                       }
[13:24:43.214]                       else if (inherits(cond, "warning")) {
[13:24:43.214]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.214]                         if (muffled) 
[13:24:43.214]                           invokeRestart("muffleWarning")
[13:24:43.214]                       }
[13:24:43.214]                       else if (inherits(cond, "condition")) {
[13:24:43.214]                         if (!is.null(pattern)) {
[13:24:43.214]                           computeRestarts <- base::computeRestarts
[13:24:43.214]                           grepl <- base::grepl
[13:24:43.214]                           restarts <- computeRestarts(cond)
[13:24:43.214]                           for (restart in restarts) {
[13:24:43.214]                             name <- restart$name
[13:24:43.214]                             if (is.null(name)) 
[13:24:43.214]                               next
[13:24:43.214]                             if (!grepl(pattern, name)) 
[13:24:43.214]                               next
[13:24:43.214]                             invokeRestart(restart)
[13:24:43.214]                             muffled <- TRUE
[13:24:43.214]                             break
[13:24:43.214]                           }
[13:24:43.214]                         }
[13:24:43.214]                       }
[13:24:43.214]                       invisible(muffled)
[13:24:43.214]                     }
[13:24:43.214]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.214]                   }
[13:24:43.214]                 }
[13:24:43.214]             }
[13:24:43.214]         }))
[13:24:43.214]     }, error = function(ex) {
[13:24:43.214]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.214]                 ...future.rng), started = ...future.startTime, 
[13:24:43.214]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.214]             version = "1.8"), class = "FutureResult")
[13:24:43.214]     }, finally = {
[13:24:43.214]         if (!identical(...future.workdir, getwd())) 
[13:24:43.214]             setwd(...future.workdir)
[13:24:43.214]         {
[13:24:43.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.214]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.214]             }
[13:24:43.214]             base::options(...future.oldOptions)
[13:24:43.214]             if (.Platform$OS.type == "windows") {
[13:24:43.214]                 old_names <- names(...future.oldEnvVars)
[13:24:43.214]                 envs <- base::Sys.getenv()
[13:24:43.214]                 names <- names(envs)
[13:24:43.214]                 common <- intersect(names, old_names)
[13:24:43.214]                 added <- setdiff(names, old_names)
[13:24:43.214]                 removed <- setdiff(old_names, names)
[13:24:43.214]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.214]                   envs[common]]
[13:24:43.214]                 NAMES <- toupper(changed)
[13:24:43.214]                 args <- list()
[13:24:43.214]                 for (kk in seq_along(NAMES)) {
[13:24:43.214]                   name <- changed[[kk]]
[13:24:43.214]                   NAME <- NAMES[[kk]]
[13:24:43.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.214]                     next
[13:24:43.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.214]                 }
[13:24:43.214]                 NAMES <- toupper(added)
[13:24:43.214]                 for (kk in seq_along(NAMES)) {
[13:24:43.214]                   name <- added[[kk]]
[13:24:43.214]                   NAME <- NAMES[[kk]]
[13:24:43.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.214]                     next
[13:24:43.214]                   args[[name]] <- ""
[13:24:43.214]                 }
[13:24:43.214]                 NAMES <- toupper(removed)
[13:24:43.214]                 for (kk in seq_along(NAMES)) {
[13:24:43.214]                   name <- removed[[kk]]
[13:24:43.214]                   NAME <- NAMES[[kk]]
[13:24:43.214]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.214]                     next
[13:24:43.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.214]                 }
[13:24:43.214]                 if (length(args) > 0) 
[13:24:43.214]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.214]             }
[13:24:43.214]             else {
[13:24:43.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.214]             }
[13:24:43.214]             {
[13:24:43.214]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.214]                   0L) {
[13:24:43.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.214]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.214]                   base::options(opts)
[13:24:43.214]                 }
[13:24:43.214]                 {
[13:24:43.214]                   {
[13:24:43.214]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.214]                     NULL
[13:24:43.214]                   }
[13:24:43.214]                   options(future.plan = NULL)
[13:24:43.214]                   if (is.na(NA_character_)) 
[13:24:43.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.214]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.214]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.214]                     envir = parent.frame()) 
[13:24:43.214]                   {
[13:24:43.214]                     if (is.function(workers)) 
[13:24:43.214]                       workers <- workers()
[13:24:43.214]                     workers <- structure(as.integer(workers), 
[13:24:43.214]                       class = class(workers))
[13:24:43.214]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.214]                       workers >= 1)
[13:24:43.214]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.214]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.214]                     }
[13:24:43.214]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.214]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.214]                       envir = envir)
[13:24:43.214]                     if (!future$lazy) 
[13:24:43.214]                       future <- run(future)
[13:24:43.214]                     invisible(future)
[13:24:43.214]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.214]                 }
[13:24:43.214]             }
[13:24:43.214]         }
[13:24:43.214]     })
[13:24:43.214]     if (TRUE) {
[13:24:43.214]         base::sink(type = "output", split = FALSE)
[13:24:43.214]         if (TRUE) {
[13:24:43.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.214]         }
[13:24:43.214]         else {
[13:24:43.214]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.214]         }
[13:24:43.214]         base::close(...future.stdout)
[13:24:43.214]         ...future.stdout <- NULL
[13:24:43.214]     }
[13:24:43.214]     ...future.result$conditions <- ...future.conditions
[13:24:43.214]     ...future.result$finished <- base::Sys.time()
[13:24:43.214]     ...future.result
[13:24:43.214] }
[13:24:43.218] MultisessionFuture started
[13:24:43.218] - Launch lazy future ... done
[13:24:43.218] run() for ‘MultisessionFuture’ ... done
[13:24:43.219] resolve() on environment ...
[13:24:43.219]  recursive: 0
[13:24:43.219]  elements: [3] ‘a’
[13:24:43.240]  length: 2 (resolved future 3)
[13:24:43.251] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.251] - Validating connection of MultisessionFuture
[13:24:43.251] - received message: FutureResult
[13:24:43.252] - Received FutureResult
[13:24:43.252] - Erased future from FutureRegistry
[13:24:43.252] result() for ClusterFuture ...
[13:24:43.252] - result already collected: FutureResult
[13:24:43.252] result() for ClusterFuture ... done
[13:24:43.252] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.252] Future #1
[13:24:43.252]  length: 1 (resolved future 1)
[13:24:43.273] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.273] - Validating connection of MultisessionFuture
[13:24:43.274] - received message: FutureResult
[13:24:43.274] - Received FutureResult
[13:24:43.274] - Erased future from FutureRegistry
[13:24:43.274] result() for ClusterFuture ...
[13:24:43.274] - result already collected: FutureResult
[13:24:43.274] result() for ClusterFuture ... done
[13:24:43.274] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.274] Future #2
[13:24:43.274]  length: 0 (resolved future 2)
[13:24:43.275] resolve() on environment ... DONE
[13:24:43.275] resolve() on environment ...
[13:24:43.275]  recursive: 0
[13:24:43.276]  elements: [3] ‘b’
[13:24:43.276] Future #1
[13:24:43.276]  length: 2 (resolved future 1)
[13:24:43.276] Future #2
[13:24:43.276]  length: 1 (resolved future 2)
[13:24:43.276]  length: 0 (resolved future 3)
[13:24:43.276] resolve() on environment ... DONE
[13:24:43.280] resolve() on environment ...
[13:24:43.280]  recursive: 0
[13:24:43.281]  elements: [3] ‘c’
[13:24:43.281] Future #1
[13:24:43.281]  length: 2 (resolved future 1)
[13:24:43.281] Future #2
[13:24:43.281]  length: 1 (resolved future 2)
[13:24:43.281]  length: 0 (resolved future 3)
[13:24:43.281] resolve() on environment ... DONE
[13:24:43.282] resolve() on environment ...
[13:24:43.282]  recursive: 0
[13:24:43.282]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[13:24:43.283] Future #1
[13:24:43.283] result() for ClusterFuture ...
[13:24:43.283] - result already collected: FutureResult
[13:24:43.283] result() for ClusterFuture ... done
[13:24:43.283] result() for ClusterFuture ...
[13:24:43.283] - result already collected: FutureResult
[13:24:43.283] result() for ClusterFuture ... done
[13:24:43.283]  length: 2 (resolved future 1)
[13:24:43.283] Future #2
[13:24:43.283] result() for ClusterFuture ...
[13:24:43.284] - result already collected: FutureResult
[13:24:43.284] result() for ClusterFuture ... done
[13:24:43.284] result() for ClusterFuture ...
[13:24:43.284] - result already collected: FutureResult
[13:24:43.284] result() for ClusterFuture ... done
[13:24:43.284]  length: 1 (resolved future 2)
[13:24:43.284]  length: 0 (resolved future 3)
[13:24:43.284] resolve() on environment ... DONE
[13:24:43.285] resolve() on environment ...
[13:24:43.285]  recursive: 99
[13:24:43.285]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[13:24:43.285] Future #1
[13:24:43.285] result() for ClusterFuture ...
[13:24:43.285] - result already collected: FutureResult
[13:24:43.286] result() for ClusterFuture ... done
[13:24:43.286] result() for ClusterFuture ...
[13:24:43.286] - result already collected: FutureResult
[13:24:43.286] result() for ClusterFuture ... done
[13:24:43.286] A MultisessionFuture was resolved
[13:24:43.286]  length: 2 (resolved future 1)
[13:24:43.286] Future #2
[13:24:43.286] result() for ClusterFuture ...
[13:24:43.286] - result already collected: FutureResult
[13:24:43.286] result() for ClusterFuture ... done
[13:24:43.287] result() for ClusterFuture ...
[13:24:43.287] - result already collected: FutureResult
[13:24:43.287] result() for ClusterFuture ... done
[13:24:43.287] A MultisessionFuture was resolved
[13:24:43.287]  length: 1 (resolved future 2)
[13:24:43.287]  length: 0 (resolved future 3)
[13:24:43.287] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[13:24:43.288] resolve() on list environment ...
[13:24:43.288]  recursive: 0
[13:24:43.288]  length: 2
[13:24:43.289]  elements: ‘a’, ‘b’
[13:24:43.289]  length: 1 (resolved future 1)
[13:24:43.289]  length: 0 (resolved future 2)
[13:24:43.289] resolve() on list environment ... DONE
[13:24:43.289] getGlobalsAndPackages() ...
[13:24:43.289] Searching for globals...
[13:24:43.289] 
[13:24:43.289] Searching for globals ... DONE
[13:24:43.290] - globals: [0] <none>
[13:24:43.290] getGlobalsAndPackages() ... DONE
[13:24:43.290] run() for ‘Future’ ...
[13:24:43.290] - state: ‘created’
[13:24:43.290] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.304] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.305]   - Field: ‘node’
[13:24:43.305]   - Field: ‘label’
[13:24:43.305]   - Field: ‘local’
[13:24:43.305]   - Field: ‘owner’
[13:24:43.305]   - Field: ‘envir’
[13:24:43.305]   - Field: ‘workers’
[13:24:43.305]   - Field: ‘packages’
[13:24:43.305]   - Field: ‘gc’
[13:24:43.305]   - Field: ‘conditions’
[13:24:43.306]   - Field: ‘persistent’
[13:24:43.306]   - Field: ‘expr’
[13:24:43.306]   - Field: ‘uuid’
[13:24:43.306]   - Field: ‘seed’
[13:24:43.306]   - Field: ‘version’
[13:24:43.306]   - Field: ‘result’
[13:24:43.306]   - Field: ‘asynchronous’
[13:24:43.306]   - Field: ‘calls’
[13:24:43.306]   - Field: ‘globals’
[13:24:43.306]   - Field: ‘stdout’
[13:24:43.307]   - Field: ‘earlySignal’
[13:24:43.307]   - Field: ‘lazy’
[13:24:43.307]   - Field: ‘state’
[13:24:43.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.307] - Launch lazy future ...
[13:24:43.307] Packages needed by the future expression (n = 0): <none>
[13:24:43.307] Packages needed by future strategies (n = 0): <none>
[13:24:43.308] {
[13:24:43.308]     {
[13:24:43.308]         {
[13:24:43.308]             ...future.startTime <- base::Sys.time()
[13:24:43.308]             {
[13:24:43.308]                 {
[13:24:43.308]                   {
[13:24:43.308]                     {
[13:24:43.308]                       base::local({
[13:24:43.308]                         has_future <- base::requireNamespace("future", 
[13:24:43.308]                           quietly = TRUE)
[13:24:43.308]                         if (has_future) {
[13:24:43.308]                           ns <- base::getNamespace("future")
[13:24:43.308]                           version <- ns[[".package"]][["version"]]
[13:24:43.308]                           if (is.null(version)) 
[13:24:43.308]                             version <- utils::packageVersion("future")
[13:24:43.308]                         }
[13:24:43.308]                         else {
[13:24:43.308]                           version <- NULL
[13:24:43.308]                         }
[13:24:43.308]                         if (!has_future || version < "1.8.0") {
[13:24:43.308]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.308]                             "", base::R.version$version.string), 
[13:24:43.308]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.308]                               "release", "version")], collapse = " "), 
[13:24:43.308]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.308]                             info)
[13:24:43.308]                           info <- base::paste(info, collapse = "; ")
[13:24:43.308]                           if (!has_future) {
[13:24:43.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.308]                               info)
[13:24:43.308]                           }
[13:24:43.308]                           else {
[13:24:43.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.308]                               info, version)
[13:24:43.308]                           }
[13:24:43.308]                           base::stop(msg)
[13:24:43.308]                         }
[13:24:43.308]                       })
[13:24:43.308]                     }
[13:24:43.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.308]                     base::options(mc.cores = 1L)
[13:24:43.308]                   }
[13:24:43.308]                   options(future.plan = NULL)
[13:24:43.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.308]                 }
[13:24:43.308]                 ...future.workdir <- getwd()
[13:24:43.308]             }
[13:24:43.308]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.308]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.308]         }
[13:24:43.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.308]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.308]             base::names(...future.oldOptions))
[13:24:43.308]     }
[13:24:43.308]     if (FALSE) {
[13:24:43.308]     }
[13:24:43.308]     else {
[13:24:43.308]         if (TRUE) {
[13:24:43.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.308]                 open = "w")
[13:24:43.308]         }
[13:24:43.308]         else {
[13:24:43.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.308]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.308]         }
[13:24:43.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.308]             base::sink(type = "output", split = FALSE)
[13:24:43.308]             base::close(...future.stdout)
[13:24:43.308]         }, add = TRUE)
[13:24:43.308]     }
[13:24:43.308]     ...future.frame <- base::sys.nframe()
[13:24:43.308]     ...future.conditions <- base::list()
[13:24:43.308]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.308]     if (FALSE) {
[13:24:43.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.308]     }
[13:24:43.308]     ...future.result <- base::tryCatch({
[13:24:43.308]         base::withCallingHandlers({
[13:24:43.308]             ...future.value <- base::withVisible(base::local({
[13:24:43.308]                 ...future.makeSendCondition <- base::local({
[13:24:43.308]                   sendCondition <- NULL
[13:24:43.308]                   function(frame = 1L) {
[13:24:43.308]                     if (is.function(sendCondition)) 
[13:24:43.308]                       return(sendCondition)
[13:24:43.308]                     ns <- getNamespace("parallel")
[13:24:43.308]                     if (exists("sendData", mode = "function", 
[13:24:43.308]                       envir = ns)) {
[13:24:43.308]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.308]                         envir = ns)
[13:24:43.308]                       envir <- sys.frame(frame)
[13:24:43.308]                       master <- NULL
[13:24:43.308]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.308]                         !identical(envir, emptyenv())) {
[13:24:43.308]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.308]                           inherits = FALSE)) {
[13:24:43.308]                           master <- get("master", mode = "list", 
[13:24:43.308]                             envir = envir, inherits = FALSE)
[13:24:43.308]                           if (inherits(master, c("SOCKnode", 
[13:24:43.308]                             "SOCK0node"))) {
[13:24:43.308]                             sendCondition <<- function(cond) {
[13:24:43.308]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.308]                                 success = TRUE)
[13:24:43.308]                               parallel_sendData(master, data)
[13:24:43.308]                             }
[13:24:43.308]                             return(sendCondition)
[13:24:43.308]                           }
[13:24:43.308]                         }
[13:24:43.308]                         frame <- frame + 1L
[13:24:43.308]                         envir <- sys.frame(frame)
[13:24:43.308]                       }
[13:24:43.308]                     }
[13:24:43.308]                     sendCondition <<- function(cond) NULL
[13:24:43.308]                   }
[13:24:43.308]                 })
[13:24:43.308]                 withCallingHandlers({
[13:24:43.308]                   1
[13:24:43.308]                 }, immediateCondition = function(cond) {
[13:24:43.308]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.308]                   sendCondition(cond)
[13:24:43.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.308]                   {
[13:24:43.308]                     inherits <- base::inherits
[13:24:43.308]                     invokeRestart <- base::invokeRestart
[13:24:43.308]                     is.null <- base::is.null
[13:24:43.308]                     muffled <- FALSE
[13:24:43.308]                     if (inherits(cond, "message")) {
[13:24:43.308]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.308]                       if (muffled) 
[13:24:43.308]                         invokeRestart("muffleMessage")
[13:24:43.308]                     }
[13:24:43.308]                     else if (inherits(cond, "warning")) {
[13:24:43.308]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.308]                       if (muffled) 
[13:24:43.308]                         invokeRestart("muffleWarning")
[13:24:43.308]                     }
[13:24:43.308]                     else if (inherits(cond, "condition")) {
[13:24:43.308]                       if (!is.null(pattern)) {
[13:24:43.308]                         computeRestarts <- base::computeRestarts
[13:24:43.308]                         grepl <- base::grepl
[13:24:43.308]                         restarts <- computeRestarts(cond)
[13:24:43.308]                         for (restart in restarts) {
[13:24:43.308]                           name <- restart$name
[13:24:43.308]                           if (is.null(name)) 
[13:24:43.308]                             next
[13:24:43.308]                           if (!grepl(pattern, name)) 
[13:24:43.308]                             next
[13:24:43.308]                           invokeRestart(restart)
[13:24:43.308]                           muffled <- TRUE
[13:24:43.308]                           break
[13:24:43.308]                         }
[13:24:43.308]                       }
[13:24:43.308]                     }
[13:24:43.308]                     invisible(muffled)
[13:24:43.308]                   }
[13:24:43.308]                   muffleCondition(cond)
[13:24:43.308]                 })
[13:24:43.308]             }))
[13:24:43.308]             future::FutureResult(value = ...future.value$value, 
[13:24:43.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.308]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.308]                     ...future.globalenv.names))
[13:24:43.308]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.308]         }, condition = base::local({
[13:24:43.308]             c <- base::c
[13:24:43.308]             inherits <- base::inherits
[13:24:43.308]             invokeRestart <- base::invokeRestart
[13:24:43.308]             length <- base::length
[13:24:43.308]             list <- base::list
[13:24:43.308]             seq.int <- base::seq.int
[13:24:43.308]             signalCondition <- base::signalCondition
[13:24:43.308]             sys.calls <- base::sys.calls
[13:24:43.308]             `[[` <- base::`[[`
[13:24:43.308]             `+` <- base::`+`
[13:24:43.308]             `<<-` <- base::`<<-`
[13:24:43.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.308]                   3L)]
[13:24:43.308]             }
[13:24:43.308]             function(cond) {
[13:24:43.308]                 is_error <- inherits(cond, "error")
[13:24:43.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.308]                   NULL)
[13:24:43.308]                 if (is_error) {
[13:24:43.308]                   sessionInformation <- function() {
[13:24:43.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.308]                       search = base::search(), system = base::Sys.info())
[13:24:43.308]                   }
[13:24:43.308]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.308]                     cond$call), session = sessionInformation(), 
[13:24:43.308]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.308]                   signalCondition(cond)
[13:24:43.308]                 }
[13:24:43.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.308]                 "immediateCondition"))) {
[13:24:43.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.308]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.308]                   if (TRUE && !signal) {
[13:24:43.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.308]                     {
[13:24:43.308]                       inherits <- base::inherits
[13:24:43.308]                       invokeRestart <- base::invokeRestart
[13:24:43.308]                       is.null <- base::is.null
[13:24:43.308]                       muffled <- FALSE
[13:24:43.308]                       if (inherits(cond, "message")) {
[13:24:43.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.308]                         if (muffled) 
[13:24:43.308]                           invokeRestart("muffleMessage")
[13:24:43.308]                       }
[13:24:43.308]                       else if (inherits(cond, "warning")) {
[13:24:43.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.308]                         if (muffled) 
[13:24:43.308]                           invokeRestart("muffleWarning")
[13:24:43.308]                       }
[13:24:43.308]                       else if (inherits(cond, "condition")) {
[13:24:43.308]                         if (!is.null(pattern)) {
[13:24:43.308]                           computeRestarts <- base::computeRestarts
[13:24:43.308]                           grepl <- base::grepl
[13:24:43.308]                           restarts <- computeRestarts(cond)
[13:24:43.308]                           for (restart in restarts) {
[13:24:43.308]                             name <- restart$name
[13:24:43.308]                             if (is.null(name)) 
[13:24:43.308]                               next
[13:24:43.308]                             if (!grepl(pattern, name)) 
[13:24:43.308]                               next
[13:24:43.308]                             invokeRestart(restart)
[13:24:43.308]                             muffled <- TRUE
[13:24:43.308]                             break
[13:24:43.308]                           }
[13:24:43.308]                         }
[13:24:43.308]                       }
[13:24:43.308]                       invisible(muffled)
[13:24:43.308]                     }
[13:24:43.308]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.308]                   }
[13:24:43.308]                 }
[13:24:43.308]                 else {
[13:24:43.308]                   if (TRUE) {
[13:24:43.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.308]                     {
[13:24:43.308]                       inherits <- base::inherits
[13:24:43.308]                       invokeRestart <- base::invokeRestart
[13:24:43.308]                       is.null <- base::is.null
[13:24:43.308]                       muffled <- FALSE
[13:24:43.308]                       if (inherits(cond, "message")) {
[13:24:43.308]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.308]                         if (muffled) 
[13:24:43.308]                           invokeRestart("muffleMessage")
[13:24:43.308]                       }
[13:24:43.308]                       else if (inherits(cond, "warning")) {
[13:24:43.308]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.308]                         if (muffled) 
[13:24:43.308]                           invokeRestart("muffleWarning")
[13:24:43.308]                       }
[13:24:43.308]                       else if (inherits(cond, "condition")) {
[13:24:43.308]                         if (!is.null(pattern)) {
[13:24:43.308]                           computeRestarts <- base::computeRestarts
[13:24:43.308]                           grepl <- base::grepl
[13:24:43.308]                           restarts <- computeRestarts(cond)
[13:24:43.308]                           for (restart in restarts) {
[13:24:43.308]                             name <- restart$name
[13:24:43.308]                             if (is.null(name)) 
[13:24:43.308]                               next
[13:24:43.308]                             if (!grepl(pattern, name)) 
[13:24:43.308]                               next
[13:24:43.308]                             invokeRestart(restart)
[13:24:43.308]                             muffled <- TRUE
[13:24:43.308]                             break
[13:24:43.308]                           }
[13:24:43.308]                         }
[13:24:43.308]                       }
[13:24:43.308]                       invisible(muffled)
[13:24:43.308]                     }
[13:24:43.308]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.308]                   }
[13:24:43.308]                 }
[13:24:43.308]             }
[13:24:43.308]         }))
[13:24:43.308]     }, error = function(ex) {
[13:24:43.308]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.308]                 ...future.rng), started = ...future.startTime, 
[13:24:43.308]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.308]             version = "1.8"), class = "FutureResult")
[13:24:43.308]     }, finally = {
[13:24:43.308]         if (!identical(...future.workdir, getwd())) 
[13:24:43.308]             setwd(...future.workdir)
[13:24:43.308]         {
[13:24:43.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.308]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.308]             }
[13:24:43.308]             base::options(...future.oldOptions)
[13:24:43.308]             if (.Platform$OS.type == "windows") {
[13:24:43.308]                 old_names <- names(...future.oldEnvVars)
[13:24:43.308]                 envs <- base::Sys.getenv()
[13:24:43.308]                 names <- names(envs)
[13:24:43.308]                 common <- intersect(names, old_names)
[13:24:43.308]                 added <- setdiff(names, old_names)
[13:24:43.308]                 removed <- setdiff(old_names, names)
[13:24:43.308]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.308]                   envs[common]]
[13:24:43.308]                 NAMES <- toupper(changed)
[13:24:43.308]                 args <- list()
[13:24:43.308]                 for (kk in seq_along(NAMES)) {
[13:24:43.308]                   name <- changed[[kk]]
[13:24:43.308]                   NAME <- NAMES[[kk]]
[13:24:43.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.308]                     next
[13:24:43.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.308]                 }
[13:24:43.308]                 NAMES <- toupper(added)
[13:24:43.308]                 for (kk in seq_along(NAMES)) {
[13:24:43.308]                   name <- added[[kk]]
[13:24:43.308]                   NAME <- NAMES[[kk]]
[13:24:43.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.308]                     next
[13:24:43.308]                   args[[name]] <- ""
[13:24:43.308]                 }
[13:24:43.308]                 NAMES <- toupper(removed)
[13:24:43.308]                 for (kk in seq_along(NAMES)) {
[13:24:43.308]                   name <- removed[[kk]]
[13:24:43.308]                   NAME <- NAMES[[kk]]
[13:24:43.308]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.308]                     next
[13:24:43.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.308]                 }
[13:24:43.308]                 if (length(args) > 0) 
[13:24:43.308]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.308]             }
[13:24:43.308]             else {
[13:24:43.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.308]             }
[13:24:43.308]             {
[13:24:43.308]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.308]                   0L) {
[13:24:43.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.308]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.308]                   base::options(opts)
[13:24:43.308]                 }
[13:24:43.308]                 {
[13:24:43.308]                   {
[13:24:43.308]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.308]                     NULL
[13:24:43.308]                   }
[13:24:43.308]                   options(future.plan = NULL)
[13:24:43.308]                   if (is.na(NA_character_)) 
[13:24:43.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.308]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.308]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.308]                     envir = parent.frame()) 
[13:24:43.308]                   {
[13:24:43.308]                     if (is.function(workers)) 
[13:24:43.308]                       workers <- workers()
[13:24:43.308]                     workers <- structure(as.integer(workers), 
[13:24:43.308]                       class = class(workers))
[13:24:43.308]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.308]                       workers >= 1)
[13:24:43.308]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.308]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.308]                     }
[13:24:43.308]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.308]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.308]                       envir = envir)
[13:24:43.308]                     if (!future$lazy) 
[13:24:43.308]                       future <- run(future)
[13:24:43.308]                     invisible(future)
[13:24:43.308]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.308]                 }
[13:24:43.308]             }
[13:24:43.308]         }
[13:24:43.308]     })
[13:24:43.308]     if (TRUE) {
[13:24:43.308]         base::sink(type = "output", split = FALSE)
[13:24:43.308]         if (TRUE) {
[13:24:43.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.308]         }
[13:24:43.308]         else {
[13:24:43.308]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.308]         }
[13:24:43.308]         base::close(...future.stdout)
[13:24:43.308]         ...future.stdout <- NULL
[13:24:43.308]     }
[13:24:43.308]     ...future.result$conditions <- ...future.conditions
[13:24:43.308]     ...future.result$finished <- base::Sys.time()
[13:24:43.308]     ...future.result
[13:24:43.308] }
[13:24:43.311] MultisessionFuture started
[13:24:43.311] - Launch lazy future ... done
[13:24:43.311] run() for ‘MultisessionFuture’ ... done
[13:24:43.312] getGlobalsAndPackages() ...
[13:24:43.312] Searching for globals...
[13:24:43.312] 
[13:24:43.312] Searching for globals ... DONE
[13:24:43.312] - globals: [0] <none>
[13:24:43.312] getGlobalsAndPackages() ... DONE
[13:24:43.312] run() for ‘Future’ ...
[13:24:43.313] - state: ‘created’
[13:24:43.313] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.328] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.328]   - Field: ‘node’
[13:24:43.328]   - Field: ‘label’
[13:24:43.328]   - Field: ‘local’
[13:24:43.328]   - Field: ‘owner’
[13:24:43.329]   - Field: ‘envir’
[13:24:43.329]   - Field: ‘workers’
[13:24:43.329]   - Field: ‘packages’
[13:24:43.329]   - Field: ‘gc’
[13:24:43.329]   - Field: ‘conditions’
[13:24:43.329]   - Field: ‘persistent’
[13:24:43.329]   - Field: ‘expr’
[13:24:43.329]   - Field: ‘uuid’
[13:24:43.329]   - Field: ‘seed’
[13:24:43.329]   - Field: ‘version’
[13:24:43.329]   - Field: ‘result’
[13:24:43.330]   - Field: ‘asynchronous’
[13:24:43.330]   - Field: ‘calls’
[13:24:43.330]   - Field: ‘globals’
[13:24:43.330]   - Field: ‘stdout’
[13:24:43.330]   - Field: ‘earlySignal’
[13:24:43.330]   - Field: ‘lazy’
[13:24:43.330]   - Field: ‘state’
[13:24:43.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.330] - Launch lazy future ...
[13:24:43.331] Packages needed by the future expression (n = 0): <none>
[13:24:43.331] Packages needed by future strategies (n = 0): <none>
[13:24:43.331] {
[13:24:43.331]     {
[13:24:43.331]         {
[13:24:43.331]             ...future.startTime <- base::Sys.time()
[13:24:43.331]             {
[13:24:43.331]                 {
[13:24:43.331]                   {
[13:24:43.331]                     {
[13:24:43.331]                       base::local({
[13:24:43.331]                         has_future <- base::requireNamespace("future", 
[13:24:43.331]                           quietly = TRUE)
[13:24:43.331]                         if (has_future) {
[13:24:43.331]                           ns <- base::getNamespace("future")
[13:24:43.331]                           version <- ns[[".package"]][["version"]]
[13:24:43.331]                           if (is.null(version)) 
[13:24:43.331]                             version <- utils::packageVersion("future")
[13:24:43.331]                         }
[13:24:43.331]                         else {
[13:24:43.331]                           version <- NULL
[13:24:43.331]                         }
[13:24:43.331]                         if (!has_future || version < "1.8.0") {
[13:24:43.331]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.331]                             "", base::R.version$version.string), 
[13:24:43.331]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.331]                               "release", "version")], collapse = " "), 
[13:24:43.331]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.331]                             info)
[13:24:43.331]                           info <- base::paste(info, collapse = "; ")
[13:24:43.331]                           if (!has_future) {
[13:24:43.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.331]                               info)
[13:24:43.331]                           }
[13:24:43.331]                           else {
[13:24:43.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.331]                               info, version)
[13:24:43.331]                           }
[13:24:43.331]                           base::stop(msg)
[13:24:43.331]                         }
[13:24:43.331]                       })
[13:24:43.331]                     }
[13:24:43.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.331]                     base::options(mc.cores = 1L)
[13:24:43.331]                   }
[13:24:43.331]                   options(future.plan = NULL)
[13:24:43.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.331]                 }
[13:24:43.331]                 ...future.workdir <- getwd()
[13:24:43.331]             }
[13:24:43.331]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.331]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.331]         }
[13:24:43.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.331]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.331]             base::names(...future.oldOptions))
[13:24:43.331]     }
[13:24:43.331]     if (FALSE) {
[13:24:43.331]     }
[13:24:43.331]     else {
[13:24:43.331]         if (TRUE) {
[13:24:43.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.331]                 open = "w")
[13:24:43.331]         }
[13:24:43.331]         else {
[13:24:43.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.331]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.331]         }
[13:24:43.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.331]             base::sink(type = "output", split = FALSE)
[13:24:43.331]             base::close(...future.stdout)
[13:24:43.331]         }, add = TRUE)
[13:24:43.331]     }
[13:24:43.331]     ...future.frame <- base::sys.nframe()
[13:24:43.331]     ...future.conditions <- base::list()
[13:24:43.331]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.331]     if (FALSE) {
[13:24:43.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.331]     }
[13:24:43.331]     ...future.result <- base::tryCatch({
[13:24:43.331]         base::withCallingHandlers({
[13:24:43.331]             ...future.value <- base::withVisible(base::local({
[13:24:43.331]                 ...future.makeSendCondition <- base::local({
[13:24:43.331]                   sendCondition <- NULL
[13:24:43.331]                   function(frame = 1L) {
[13:24:43.331]                     if (is.function(sendCondition)) 
[13:24:43.331]                       return(sendCondition)
[13:24:43.331]                     ns <- getNamespace("parallel")
[13:24:43.331]                     if (exists("sendData", mode = "function", 
[13:24:43.331]                       envir = ns)) {
[13:24:43.331]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.331]                         envir = ns)
[13:24:43.331]                       envir <- sys.frame(frame)
[13:24:43.331]                       master <- NULL
[13:24:43.331]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.331]                         !identical(envir, emptyenv())) {
[13:24:43.331]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.331]                           inherits = FALSE)) {
[13:24:43.331]                           master <- get("master", mode = "list", 
[13:24:43.331]                             envir = envir, inherits = FALSE)
[13:24:43.331]                           if (inherits(master, c("SOCKnode", 
[13:24:43.331]                             "SOCK0node"))) {
[13:24:43.331]                             sendCondition <<- function(cond) {
[13:24:43.331]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.331]                                 success = TRUE)
[13:24:43.331]                               parallel_sendData(master, data)
[13:24:43.331]                             }
[13:24:43.331]                             return(sendCondition)
[13:24:43.331]                           }
[13:24:43.331]                         }
[13:24:43.331]                         frame <- frame + 1L
[13:24:43.331]                         envir <- sys.frame(frame)
[13:24:43.331]                       }
[13:24:43.331]                     }
[13:24:43.331]                     sendCondition <<- function(cond) NULL
[13:24:43.331]                   }
[13:24:43.331]                 })
[13:24:43.331]                 withCallingHandlers({
[13:24:43.331]                   2
[13:24:43.331]                 }, immediateCondition = function(cond) {
[13:24:43.331]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.331]                   sendCondition(cond)
[13:24:43.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.331]                   {
[13:24:43.331]                     inherits <- base::inherits
[13:24:43.331]                     invokeRestart <- base::invokeRestart
[13:24:43.331]                     is.null <- base::is.null
[13:24:43.331]                     muffled <- FALSE
[13:24:43.331]                     if (inherits(cond, "message")) {
[13:24:43.331]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.331]                       if (muffled) 
[13:24:43.331]                         invokeRestart("muffleMessage")
[13:24:43.331]                     }
[13:24:43.331]                     else if (inherits(cond, "warning")) {
[13:24:43.331]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.331]                       if (muffled) 
[13:24:43.331]                         invokeRestart("muffleWarning")
[13:24:43.331]                     }
[13:24:43.331]                     else if (inherits(cond, "condition")) {
[13:24:43.331]                       if (!is.null(pattern)) {
[13:24:43.331]                         computeRestarts <- base::computeRestarts
[13:24:43.331]                         grepl <- base::grepl
[13:24:43.331]                         restarts <- computeRestarts(cond)
[13:24:43.331]                         for (restart in restarts) {
[13:24:43.331]                           name <- restart$name
[13:24:43.331]                           if (is.null(name)) 
[13:24:43.331]                             next
[13:24:43.331]                           if (!grepl(pattern, name)) 
[13:24:43.331]                             next
[13:24:43.331]                           invokeRestart(restart)
[13:24:43.331]                           muffled <- TRUE
[13:24:43.331]                           break
[13:24:43.331]                         }
[13:24:43.331]                       }
[13:24:43.331]                     }
[13:24:43.331]                     invisible(muffled)
[13:24:43.331]                   }
[13:24:43.331]                   muffleCondition(cond)
[13:24:43.331]                 })
[13:24:43.331]             }))
[13:24:43.331]             future::FutureResult(value = ...future.value$value, 
[13:24:43.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.331]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.331]                     ...future.globalenv.names))
[13:24:43.331]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.331]         }, condition = base::local({
[13:24:43.331]             c <- base::c
[13:24:43.331]             inherits <- base::inherits
[13:24:43.331]             invokeRestart <- base::invokeRestart
[13:24:43.331]             length <- base::length
[13:24:43.331]             list <- base::list
[13:24:43.331]             seq.int <- base::seq.int
[13:24:43.331]             signalCondition <- base::signalCondition
[13:24:43.331]             sys.calls <- base::sys.calls
[13:24:43.331]             `[[` <- base::`[[`
[13:24:43.331]             `+` <- base::`+`
[13:24:43.331]             `<<-` <- base::`<<-`
[13:24:43.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.331]                   3L)]
[13:24:43.331]             }
[13:24:43.331]             function(cond) {
[13:24:43.331]                 is_error <- inherits(cond, "error")
[13:24:43.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.331]                   NULL)
[13:24:43.331]                 if (is_error) {
[13:24:43.331]                   sessionInformation <- function() {
[13:24:43.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.331]                       search = base::search(), system = base::Sys.info())
[13:24:43.331]                   }
[13:24:43.331]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.331]                     cond$call), session = sessionInformation(), 
[13:24:43.331]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.331]                   signalCondition(cond)
[13:24:43.331]                 }
[13:24:43.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.331]                 "immediateCondition"))) {
[13:24:43.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.331]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.331]                   if (TRUE && !signal) {
[13:24:43.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.331]                     {
[13:24:43.331]                       inherits <- base::inherits
[13:24:43.331]                       invokeRestart <- base::invokeRestart
[13:24:43.331]                       is.null <- base::is.null
[13:24:43.331]                       muffled <- FALSE
[13:24:43.331]                       if (inherits(cond, "message")) {
[13:24:43.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.331]                         if (muffled) 
[13:24:43.331]                           invokeRestart("muffleMessage")
[13:24:43.331]                       }
[13:24:43.331]                       else if (inherits(cond, "warning")) {
[13:24:43.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.331]                         if (muffled) 
[13:24:43.331]                           invokeRestart("muffleWarning")
[13:24:43.331]                       }
[13:24:43.331]                       else if (inherits(cond, "condition")) {
[13:24:43.331]                         if (!is.null(pattern)) {
[13:24:43.331]                           computeRestarts <- base::computeRestarts
[13:24:43.331]                           grepl <- base::grepl
[13:24:43.331]                           restarts <- computeRestarts(cond)
[13:24:43.331]                           for (restart in restarts) {
[13:24:43.331]                             name <- restart$name
[13:24:43.331]                             if (is.null(name)) 
[13:24:43.331]                               next
[13:24:43.331]                             if (!grepl(pattern, name)) 
[13:24:43.331]                               next
[13:24:43.331]                             invokeRestart(restart)
[13:24:43.331]                             muffled <- TRUE
[13:24:43.331]                             break
[13:24:43.331]                           }
[13:24:43.331]                         }
[13:24:43.331]                       }
[13:24:43.331]                       invisible(muffled)
[13:24:43.331]                     }
[13:24:43.331]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.331]                   }
[13:24:43.331]                 }
[13:24:43.331]                 else {
[13:24:43.331]                   if (TRUE) {
[13:24:43.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.331]                     {
[13:24:43.331]                       inherits <- base::inherits
[13:24:43.331]                       invokeRestart <- base::invokeRestart
[13:24:43.331]                       is.null <- base::is.null
[13:24:43.331]                       muffled <- FALSE
[13:24:43.331]                       if (inherits(cond, "message")) {
[13:24:43.331]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.331]                         if (muffled) 
[13:24:43.331]                           invokeRestart("muffleMessage")
[13:24:43.331]                       }
[13:24:43.331]                       else if (inherits(cond, "warning")) {
[13:24:43.331]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.331]                         if (muffled) 
[13:24:43.331]                           invokeRestart("muffleWarning")
[13:24:43.331]                       }
[13:24:43.331]                       else if (inherits(cond, "condition")) {
[13:24:43.331]                         if (!is.null(pattern)) {
[13:24:43.331]                           computeRestarts <- base::computeRestarts
[13:24:43.331]                           grepl <- base::grepl
[13:24:43.331]                           restarts <- computeRestarts(cond)
[13:24:43.331]                           for (restart in restarts) {
[13:24:43.331]                             name <- restart$name
[13:24:43.331]                             if (is.null(name)) 
[13:24:43.331]                               next
[13:24:43.331]                             if (!grepl(pattern, name)) 
[13:24:43.331]                               next
[13:24:43.331]                             invokeRestart(restart)
[13:24:43.331]                             muffled <- TRUE
[13:24:43.331]                             break
[13:24:43.331]                           }
[13:24:43.331]                         }
[13:24:43.331]                       }
[13:24:43.331]                       invisible(muffled)
[13:24:43.331]                     }
[13:24:43.331]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.331]                   }
[13:24:43.331]                 }
[13:24:43.331]             }
[13:24:43.331]         }))
[13:24:43.331]     }, error = function(ex) {
[13:24:43.331]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.331]                 ...future.rng), started = ...future.startTime, 
[13:24:43.331]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.331]             version = "1.8"), class = "FutureResult")
[13:24:43.331]     }, finally = {
[13:24:43.331]         if (!identical(...future.workdir, getwd())) 
[13:24:43.331]             setwd(...future.workdir)
[13:24:43.331]         {
[13:24:43.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.331]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.331]             }
[13:24:43.331]             base::options(...future.oldOptions)
[13:24:43.331]             if (.Platform$OS.type == "windows") {
[13:24:43.331]                 old_names <- names(...future.oldEnvVars)
[13:24:43.331]                 envs <- base::Sys.getenv()
[13:24:43.331]                 names <- names(envs)
[13:24:43.331]                 common <- intersect(names, old_names)
[13:24:43.331]                 added <- setdiff(names, old_names)
[13:24:43.331]                 removed <- setdiff(old_names, names)
[13:24:43.331]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.331]                   envs[common]]
[13:24:43.331]                 NAMES <- toupper(changed)
[13:24:43.331]                 args <- list()
[13:24:43.331]                 for (kk in seq_along(NAMES)) {
[13:24:43.331]                   name <- changed[[kk]]
[13:24:43.331]                   NAME <- NAMES[[kk]]
[13:24:43.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.331]                     next
[13:24:43.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.331]                 }
[13:24:43.331]                 NAMES <- toupper(added)
[13:24:43.331]                 for (kk in seq_along(NAMES)) {
[13:24:43.331]                   name <- added[[kk]]
[13:24:43.331]                   NAME <- NAMES[[kk]]
[13:24:43.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.331]                     next
[13:24:43.331]                   args[[name]] <- ""
[13:24:43.331]                 }
[13:24:43.331]                 NAMES <- toupper(removed)
[13:24:43.331]                 for (kk in seq_along(NAMES)) {
[13:24:43.331]                   name <- removed[[kk]]
[13:24:43.331]                   NAME <- NAMES[[kk]]
[13:24:43.331]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.331]                     next
[13:24:43.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.331]                 }
[13:24:43.331]                 if (length(args) > 0) 
[13:24:43.331]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.331]             }
[13:24:43.331]             else {
[13:24:43.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.331]             }
[13:24:43.331]             {
[13:24:43.331]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.331]                   0L) {
[13:24:43.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.331]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.331]                   base::options(opts)
[13:24:43.331]                 }
[13:24:43.331]                 {
[13:24:43.331]                   {
[13:24:43.331]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.331]                     NULL
[13:24:43.331]                   }
[13:24:43.331]                   options(future.plan = NULL)
[13:24:43.331]                   if (is.na(NA_character_)) 
[13:24:43.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.331]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.331]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.331]                     envir = parent.frame()) 
[13:24:43.331]                   {
[13:24:43.331]                     if (is.function(workers)) 
[13:24:43.331]                       workers <- workers()
[13:24:43.331]                     workers <- structure(as.integer(workers), 
[13:24:43.331]                       class = class(workers))
[13:24:43.331]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.331]                       workers >= 1)
[13:24:43.331]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.331]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.331]                     }
[13:24:43.331]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.331]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.331]                       envir = envir)
[13:24:43.331]                     if (!future$lazy) 
[13:24:43.331]                       future <- run(future)
[13:24:43.331]                     invisible(future)
[13:24:43.331]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.331]                 }
[13:24:43.331]             }
[13:24:43.331]         }
[13:24:43.331]     })
[13:24:43.331]     if (TRUE) {
[13:24:43.331]         base::sink(type = "output", split = FALSE)
[13:24:43.331]         if (TRUE) {
[13:24:43.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.331]         }
[13:24:43.331]         else {
[13:24:43.331]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.331]         }
[13:24:43.331]         base::close(...future.stdout)
[13:24:43.331]         ...future.stdout <- NULL
[13:24:43.331]     }
[13:24:43.331]     ...future.result$conditions <- ...future.conditions
[13:24:43.331]     ...future.result$finished <- base::Sys.time()
[13:24:43.331]     ...future.result
[13:24:43.331] }
[13:24:43.334] MultisessionFuture started
[13:24:43.334] - Launch lazy future ... done
[13:24:43.335] run() for ‘MultisessionFuture’ ... done
[13:24:43.335] resolve() on list environment ...
[13:24:43.335]  recursive: 0
[13:24:43.336]  length: 3
[13:24:43.336]  elements: ‘a’, ‘b’, ‘c’
[13:24:43.357]  length: 2 (resolved future 3)
[13:24:43.368] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.368] - Validating connection of MultisessionFuture
[13:24:43.368] - received message: FutureResult
[13:24:43.369] - Received FutureResult
[13:24:43.369] - Erased future from FutureRegistry
[13:24:43.369] result() for ClusterFuture ...
[13:24:43.369] - result already collected: FutureResult
[13:24:43.369] result() for ClusterFuture ... done
[13:24:43.369] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.369] Future #1
[13:24:43.369]  length: 1 (resolved future 1)
[13:24:43.391] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.391] - Validating connection of MultisessionFuture
[13:24:43.391] - received message: FutureResult
[13:24:43.391] - Received FutureResult
[13:24:43.391] - Erased future from FutureRegistry
[13:24:43.391] result() for ClusterFuture ...
[13:24:43.391] - result already collected: FutureResult
[13:24:43.391] result() for ClusterFuture ... done
[13:24:43.392] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.392] Future #2
[13:24:43.392]  length: 0 (resolved future 2)
[13:24:43.392] resolve() on list environment ... DONE
[13:24:43.393] getGlobalsAndPackages() ...
[13:24:43.393] Searching for globals...
[13:24:43.393] - globals found: [1] ‘{’
[13:24:43.394] Searching for globals ... DONE
[13:24:43.394] Resolving globals: FALSE
[13:24:43.394] 
[13:24:43.394] 
[13:24:43.394] getGlobalsAndPackages() ... DONE
[13:24:43.394] run() for ‘Future’ ...
[13:24:43.394] - state: ‘created’
[13:24:43.395] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.409] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.410] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.410]   - Field: ‘node’
[13:24:43.410]   - Field: ‘label’
[13:24:43.410]   - Field: ‘local’
[13:24:43.410]   - Field: ‘owner’
[13:24:43.410]   - Field: ‘envir’
[13:24:43.410]   - Field: ‘workers’
[13:24:43.410]   - Field: ‘packages’
[13:24:43.410]   - Field: ‘gc’
[13:24:43.410]   - Field: ‘conditions’
[13:24:43.411]   - Field: ‘persistent’
[13:24:43.411]   - Field: ‘expr’
[13:24:43.411]   - Field: ‘uuid’
[13:24:43.411]   - Field: ‘seed’
[13:24:43.411]   - Field: ‘version’
[13:24:43.411]   - Field: ‘result’
[13:24:43.411]   - Field: ‘asynchronous’
[13:24:43.411]   - Field: ‘calls’
[13:24:43.411]   - Field: ‘globals’
[13:24:43.411]   - Field: ‘stdout’
[13:24:43.411]   - Field: ‘earlySignal’
[13:24:43.412]   - Field: ‘lazy’
[13:24:43.412]   - Field: ‘state’
[13:24:43.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.412] - Launch lazy future ...
[13:24:43.412] Packages needed by the future expression (n = 0): <none>
[13:24:43.412] Packages needed by future strategies (n = 0): <none>
[13:24:43.413] {
[13:24:43.413]     {
[13:24:43.413]         {
[13:24:43.413]             ...future.startTime <- base::Sys.time()
[13:24:43.413]             {
[13:24:43.413]                 {
[13:24:43.413]                   {
[13:24:43.413]                     {
[13:24:43.413]                       base::local({
[13:24:43.413]                         has_future <- base::requireNamespace("future", 
[13:24:43.413]                           quietly = TRUE)
[13:24:43.413]                         if (has_future) {
[13:24:43.413]                           ns <- base::getNamespace("future")
[13:24:43.413]                           version <- ns[[".package"]][["version"]]
[13:24:43.413]                           if (is.null(version)) 
[13:24:43.413]                             version <- utils::packageVersion("future")
[13:24:43.413]                         }
[13:24:43.413]                         else {
[13:24:43.413]                           version <- NULL
[13:24:43.413]                         }
[13:24:43.413]                         if (!has_future || version < "1.8.0") {
[13:24:43.413]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.413]                             "", base::R.version$version.string), 
[13:24:43.413]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.413]                               "release", "version")], collapse = " "), 
[13:24:43.413]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.413]                             info)
[13:24:43.413]                           info <- base::paste(info, collapse = "; ")
[13:24:43.413]                           if (!has_future) {
[13:24:43.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.413]                               info)
[13:24:43.413]                           }
[13:24:43.413]                           else {
[13:24:43.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.413]                               info, version)
[13:24:43.413]                           }
[13:24:43.413]                           base::stop(msg)
[13:24:43.413]                         }
[13:24:43.413]                       })
[13:24:43.413]                     }
[13:24:43.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.413]                     base::options(mc.cores = 1L)
[13:24:43.413]                   }
[13:24:43.413]                   options(future.plan = NULL)
[13:24:43.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.413]                 }
[13:24:43.413]                 ...future.workdir <- getwd()
[13:24:43.413]             }
[13:24:43.413]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.413]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.413]         }
[13:24:43.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.413]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.413]             base::names(...future.oldOptions))
[13:24:43.413]     }
[13:24:43.413]     if (FALSE) {
[13:24:43.413]     }
[13:24:43.413]     else {
[13:24:43.413]         if (TRUE) {
[13:24:43.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.413]                 open = "w")
[13:24:43.413]         }
[13:24:43.413]         else {
[13:24:43.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.413]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.413]         }
[13:24:43.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.413]             base::sink(type = "output", split = FALSE)
[13:24:43.413]             base::close(...future.stdout)
[13:24:43.413]         }, add = TRUE)
[13:24:43.413]     }
[13:24:43.413]     ...future.frame <- base::sys.nframe()
[13:24:43.413]     ...future.conditions <- base::list()
[13:24:43.413]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.413]     if (FALSE) {
[13:24:43.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.413]     }
[13:24:43.413]     ...future.result <- base::tryCatch({
[13:24:43.413]         base::withCallingHandlers({
[13:24:43.413]             ...future.value <- base::withVisible(base::local({
[13:24:43.413]                 ...future.makeSendCondition <- base::local({
[13:24:43.413]                   sendCondition <- NULL
[13:24:43.413]                   function(frame = 1L) {
[13:24:43.413]                     if (is.function(sendCondition)) 
[13:24:43.413]                       return(sendCondition)
[13:24:43.413]                     ns <- getNamespace("parallel")
[13:24:43.413]                     if (exists("sendData", mode = "function", 
[13:24:43.413]                       envir = ns)) {
[13:24:43.413]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.413]                         envir = ns)
[13:24:43.413]                       envir <- sys.frame(frame)
[13:24:43.413]                       master <- NULL
[13:24:43.413]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.413]                         !identical(envir, emptyenv())) {
[13:24:43.413]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.413]                           inherits = FALSE)) {
[13:24:43.413]                           master <- get("master", mode = "list", 
[13:24:43.413]                             envir = envir, inherits = FALSE)
[13:24:43.413]                           if (inherits(master, c("SOCKnode", 
[13:24:43.413]                             "SOCK0node"))) {
[13:24:43.413]                             sendCondition <<- function(cond) {
[13:24:43.413]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.413]                                 success = TRUE)
[13:24:43.413]                               parallel_sendData(master, data)
[13:24:43.413]                             }
[13:24:43.413]                             return(sendCondition)
[13:24:43.413]                           }
[13:24:43.413]                         }
[13:24:43.413]                         frame <- frame + 1L
[13:24:43.413]                         envir <- sys.frame(frame)
[13:24:43.413]                       }
[13:24:43.413]                     }
[13:24:43.413]                     sendCondition <<- function(cond) NULL
[13:24:43.413]                   }
[13:24:43.413]                 })
[13:24:43.413]                 withCallingHandlers({
[13:24:43.413]                   {
[13:24:43.413]                     1
[13:24:43.413]                   }
[13:24:43.413]                 }, immediateCondition = function(cond) {
[13:24:43.413]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.413]                   sendCondition(cond)
[13:24:43.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.413]                   {
[13:24:43.413]                     inherits <- base::inherits
[13:24:43.413]                     invokeRestart <- base::invokeRestart
[13:24:43.413]                     is.null <- base::is.null
[13:24:43.413]                     muffled <- FALSE
[13:24:43.413]                     if (inherits(cond, "message")) {
[13:24:43.413]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.413]                       if (muffled) 
[13:24:43.413]                         invokeRestart("muffleMessage")
[13:24:43.413]                     }
[13:24:43.413]                     else if (inherits(cond, "warning")) {
[13:24:43.413]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.413]                       if (muffled) 
[13:24:43.413]                         invokeRestart("muffleWarning")
[13:24:43.413]                     }
[13:24:43.413]                     else if (inherits(cond, "condition")) {
[13:24:43.413]                       if (!is.null(pattern)) {
[13:24:43.413]                         computeRestarts <- base::computeRestarts
[13:24:43.413]                         grepl <- base::grepl
[13:24:43.413]                         restarts <- computeRestarts(cond)
[13:24:43.413]                         for (restart in restarts) {
[13:24:43.413]                           name <- restart$name
[13:24:43.413]                           if (is.null(name)) 
[13:24:43.413]                             next
[13:24:43.413]                           if (!grepl(pattern, name)) 
[13:24:43.413]                             next
[13:24:43.413]                           invokeRestart(restart)
[13:24:43.413]                           muffled <- TRUE
[13:24:43.413]                           break
[13:24:43.413]                         }
[13:24:43.413]                       }
[13:24:43.413]                     }
[13:24:43.413]                     invisible(muffled)
[13:24:43.413]                   }
[13:24:43.413]                   muffleCondition(cond)
[13:24:43.413]                 })
[13:24:43.413]             }))
[13:24:43.413]             future::FutureResult(value = ...future.value$value, 
[13:24:43.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.413]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.413]                     ...future.globalenv.names))
[13:24:43.413]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.413]         }, condition = base::local({
[13:24:43.413]             c <- base::c
[13:24:43.413]             inherits <- base::inherits
[13:24:43.413]             invokeRestart <- base::invokeRestart
[13:24:43.413]             length <- base::length
[13:24:43.413]             list <- base::list
[13:24:43.413]             seq.int <- base::seq.int
[13:24:43.413]             signalCondition <- base::signalCondition
[13:24:43.413]             sys.calls <- base::sys.calls
[13:24:43.413]             `[[` <- base::`[[`
[13:24:43.413]             `+` <- base::`+`
[13:24:43.413]             `<<-` <- base::`<<-`
[13:24:43.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.413]                   3L)]
[13:24:43.413]             }
[13:24:43.413]             function(cond) {
[13:24:43.413]                 is_error <- inherits(cond, "error")
[13:24:43.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.413]                   NULL)
[13:24:43.413]                 if (is_error) {
[13:24:43.413]                   sessionInformation <- function() {
[13:24:43.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.413]                       search = base::search(), system = base::Sys.info())
[13:24:43.413]                   }
[13:24:43.413]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.413]                     cond$call), session = sessionInformation(), 
[13:24:43.413]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.413]                   signalCondition(cond)
[13:24:43.413]                 }
[13:24:43.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.413]                 "immediateCondition"))) {
[13:24:43.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.413]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.413]                   if (TRUE && !signal) {
[13:24:43.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.413]                     {
[13:24:43.413]                       inherits <- base::inherits
[13:24:43.413]                       invokeRestart <- base::invokeRestart
[13:24:43.413]                       is.null <- base::is.null
[13:24:43.413]                       muffled <- FALSE
[13:24:43.413]                       if (inherits(cond, "message")) {
[13:24:43.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.413]                         if (muffled) 
[13:24:43.413]                           invokeRestart("muffleMessage")
[13:24:43.413]                       }
[13:24:43.413]                       else if (inherits(cond, "warning")) {
[13:24:43.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.413]                         if (muffled) 
[13:24:43.413]                           invokeRestart("muffleWarning")
[13:24:43.413]                       }
[13:24:43.413]                       else if (inherits(cond, "condition")) {
[13:24:43.413]                         if (!is.null(pattern)) {
[13:24:43.413]                           computeRestarts <- base::computeRestarts
[13:24:43.413]                           grepl <- base::grepl
[13:24:43.413]                           restarts <- computeRestarts(cond)
[13:24:43.413]                           for (restart in restarts) {
[13:24:43.413]                             name <- restart$name
[13:24:43.413]                             if (is.null(name)) 
[13:24:43.413]                               next
[13:24:43.413]                             if (!grepl(pattern, name)) 
[13:24:43.413]                               next
[13:24:43.413]                             invokeRestart(restart)
[13:24:43.413]                             muffled <- TRUE
[13:24:43.413]                             break
[13:24:43.413]                           }
[13:24:43.413]                         }
[13:24:43.413]                       }
[13:24:43.413]                       invisible(muffled)
[13:24:43.413]                     }
[13:24:43.413]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.413]                   }
[13:24:43.413]                 }
[13:24:43.413]                 else {
[13:24:43.413]                   if (TRUE) {
[13:24:43.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.413]                     {
[13:24:43.413]                       inherits <- base::inherits
[13:24:43.413]                       invokeRestart <- base::invokeRestart
[13:24:43.413]                       is.null <- base::is.null
[13:24:43.413]                       muffled <- FALSE
[13:24:43.413]                       if (inherits(cond, "message")) {
[13:24:43.413]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.413]                         if (muffled) 
[13:24:43.413]                           invokeRestart("muffleMessage")
[13:24:43.413]                       }
[13:24:43.413]                       else if (inherits(cond, "warning")) {
[13:24:43.413]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.413]                         if (muffled) 
[13:24:43.413]                           invokeRestart("muffleWarning")
[13:24:43.413]                       }
[13:24:43.413]                       else if (inherits(cond, "condition")) {
[13:24:43.413]                         if (!is.null(pattern)) {
[13:24:43.413]                           computeRestarts <- base::computeRestarts
[13:24:43.413]                           grepl <- base::grepl
[13:24:43.413]                           restarts <- computeRestarts(cond)
[13:24:43.413]                           for (restart in restarts) {
[13:24:43.413]                             name <- restart$name
[13:24:43.413]                             if (is.null(name)) 
[13:24:43.413]                               next
[13:24:43.413]                             if (!grepl(pattern, name)) 
[13:24:43.413]                               next
[13:24:43.413]                             invokeRestart(restart)
[13:24:43.413]                             muffled <- TRUE
[13:24:43.413]                             break
[13:24:43.413]                           }
[13:24:43.413]                         }
[13:24:43.413]                       }
[13:24:43.413]                       invisible(muffled)
[13:24:43.413]                     }
[13:24:43.413]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.413]                   }
[13:24:43.413]                 }
[13:24:43.413]             }
[13:24:43.413]         }))
[13:24:43.413]     }, error = function(ex) {
[13:24:43.413]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.413]                 ...future.rng), started = ...future.startTime, 
[13:24:43.413]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.413]             version = "1.8"), class = "FutureResult")
[13:24:43.413]     }, finally = {
[13:24:43.413]         if (!identical(...future.workdir, getwd())) 
[13:24:43.413]             setwd(...future.workdir)
[13:24:43.413]         {
[13:24:43.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.413]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.413]             }
[13:24:43.413]             base::options(...future.oldOptions)
[13:24:43.413]             if (.Platform$OS.type == "windows") {
[13:24:43.413]                 old_names <- names(...future.oldEnvVars)
[13:24:43.413]                 envs <- base::Sys.getenv()
[13:24:43.413]                 names <- names(envs)
[13:24:43.413]                 common <- intersect(names, old_names)
[13:24:43.413]                 added <- setdiff(names, old_names)
[13:24:43.413]                 removed <- setdiff(old_names, names)
[13:24:43.413]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.413]                   envs[common]]
[13:24:43.413]                 NAMES <- toupper(changed)
[13:24:43.413]                 args <- list()
[13:24:43.413]                 for (kk in seq_along(NAMES)) {
[13:24:43.413]                   name <- changed[[kk]]
[13:24:43.413]                   NAME <- NAMES[[kk]]
[13:24:43.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.413]                     next
[13:24:43.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.413]                 }
[13:24:43.413]                 NAMES <- toupper(added)
[13:24:43.413]                 for (kk in seq_along(NAMES)) {
[13:24:43.413]                   name <- added[[kk]]
[13:24:43.413]                   NAME <- NAMES[[kk]]
[13:24:43.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.413]                     next
[13:24:43.413]                   args[[name]] <- ""
[13:24:43.413]                 }
[13:24:43.413]                 NAMES <- toupper(removed)
[13:24:43.413]                 for (kk in seq_along(NAMES)) {
[13:24:43.413]                   name <- removed[[kk]]
[13:24:43.413]                   NAME <- NAMES[[kk]]
[13:24:43.413]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.413]                     next
[13:24:43.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.413]                 }
[13:24:43.413]                 if (length(args) > 0) 
[13:24:43.413]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.413]             }
[13:24:43.413]             else {
[13:24:43.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.413]             }
[13:24:43.413]             {
[13:24:43.413]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.413]                   0L) {
[13:24:43.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.413]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.413]                   base::options(opts)
[13:24:43.413]                 }
[13:24:43.413]                 {
[13:24:43.413]                   {
[13:24:43.413]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.413]                     NULL
[13:24:43.413]                   }
[13:24:43.413]                   options(future.plan = NULL)
[13:24:43.413]                   if (is.na(NA_character_)) 
[13:24:43.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.413]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.413]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.413]                     envir = parent.frame()) 
[13:24:43.413]                   {
[13:24:43.413]                     if (is.function(workers)) 
[13:24:43.413]                       workers <- workers()
[13:24:43.413]                     workers <- structure(as.integer(workers), 
[13:24:43.413]                       class = class(workers))
[13:24:43.413]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.413]                       workers >= 1)
[13:24:43.413]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.413]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.413]                     }
[13:24:43.413]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.413]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.413]                       envir = envir)
[13:24:43.413]                     if (!future$lazy) 
[13:24:43.413]                       future <- run(future)
[13:24:43.413]                     invisible(future)
[13:24:43.413]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.413]                 }
[13:24:43.413]             }
[13:24:43.413]         }
[13:24:43.413]     })
[13:24:43.413]     if (TRUE) {
[13:24:43.413]         base::sink(type = "output", split = FALSE)
[13:24:43.413]         if (TRUE) {
[13:24:43.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.413]         }
[13:24:43.413]         else {
[13:24:43.413]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.413]         }
[13:24:43.413]         base::close(...future.stdout)
[13:24:43.413]         ...future.stdout <- NULL
[13:24:43.413]     }
[13:24:43.413]     ...future.result$conditions <- ...future.conditions
[13:24:43.413]     ...future.result$finished <- base::Sys.time()
[13:24:43.413]     ...future.result
[13:24:43.413] }
[13:24:43.416] MultisessionFuture started
[13:24:43.416] - Launch lazy future ... done
[13:24:43.417] run() for ‘MultisessionFuture’ ... done
[13:24:43.417] getGlobalsAndPackages() ...
[13:24:43.417] Searching for globals...
[13:24:43.418] - globals found: [1] ‘{’
[13:24:43.418] Searching for globals ... DONE
[13:24:43.418] Resolving globals: FALSE
[13:24:43.418] 
[13:24:43.418] 
[13:24:43.418] getGlobalsAndPackages() ... DONE
[13:24:43.419] run() for ‘Future’ ...
[13:24:43.419] - state: ‘created’
[13:24:43.419] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.434] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.434]   - Field: ‘node’
[13:24:43.434]   - Field: ‘label’
[13:24:43.434]   - Field: ‘local’
[13:24:43.434]   - Field: ‘owner’
[13:24:43.434]   - Field: ‘envir’
[13:24:43.434]   - Field: ‘workers’
[13:24:43.435]   - Field: ‘packages’
[13:24:43.435]   - Field: ‘gc’
[13:24:43.435]   - Field: ‘conditions’
[13:24:43.435]   - Field: ‘persistent’
[13:24:43.435]   - Field: ‘expr’
[13:24:43.435]   - Field: ‘uuid’
[13:24:43.435]   - Field: ‘seed’
[13:24:43.435]   - Field: ‘version’
[13:24:43.435]   - Field: ‘result’
[13:24:43.435]   - Field: ‘asynchronous’
[13:24:43.435]   - Field: ‘calls’
[13:24:43.436]   - Field: ‘globals’
[13:24:43.436]   - Field: ‘stdout’
[13:24:43.436]   - Field: ‘earlySignal’
[13:24:43.436]   - Field: ‘lazy’
[13:24:43.436]   - Field: ‘state’
[13:24:43.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.436] - Launch lazy future ...
[13:24:43.436] Packages needed by the future expression (n = 0): <none>
[13:24:43.437] Packages needed by future strategies (n = 0): <none>
[13:24:43.437] {
[13:24:43.437]     {
[13:24:43.437]         {
[13:24:43.437]             ...future.startTime <- base::Sys.time()
[13:24:43.437]             {
[13:24:43.437]                 {
[13:24:43.437]                   {
[13:24:43.437]                     {
[13:24:43.437]                       base::local({
[13:24:43.437]                         has_future <- base::requireNamespace("future", 
[13:24:43.437]                           quietly = TRUE)
[13:24:43.437]                         if (has_future) {
[13:24:43.437]                           ns <- base::getNamespace("future")
[13:24:43.437]                           version <- ns[[".package"]][["version"]]
[13:24:43.437]                           if (is.null(version)) 
[13:24:43.437]                             version <- utils::packageVersion("future")
[13:24:43.437]                         }
[13:24:43.437]                         else {
[13:24:43.437]                           version <- NULL
[13:24:43.437]                         }
[13:24:43.437]                         if (!has_future || version < "1.8.0") {
[13:24:43.437]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.437]                             "", base::R.version$version.string), 
[13:24:43.437]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.437]                               "release", "version")], collapse = " "), 
[13:24:43.437]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.437]                             info)
[13:24:43.437]                           info <- base::paste(info, collapse = "; ")
[13:24:43.437]                           if (!has_future) {
[13:24:43.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.437]                               info)
[13:24:43.437]                           }
[13:24:43.437]                           else {
[13:24:43.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.437]                               info, version)
[13:24:43.437]                           }
[13:24:43.437]                           base::stop(msg)
[13:24:43.437]                         }
[13:24:43.437]                       })
[13:24:43.437]                     }
[13:24:43.437]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.437]                     base::options(mc.cores = 1L)
[13:24:43.437]                   }
[13:24:43.437]                   options(future.plan = NULL)
[13:24:43.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.437]                 }
[13:24:43.437]                 ...future.workdir <- getwd()
[13:24:43.437]             }
[13:24:43.437]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.437]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.437]         }
[13:24:43.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.437]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.437]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.437]             base::names(...future.oldOptions))
[13:24:43.437]     }
[13:24:43.437]     if (FALSE) {
[13:24:43.437]     }
[13:24:43.437]     else {
[13:24:43.437]         if (TRUE) {
[13:24:43.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.437]                 open = "w")
[13:24:43.437]         }
[13:24:43.437]         else {
[13:24:43.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.437]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.437]         }
[13:24:43.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.437]             base::sink(type = "output", split = FALSE)
[13:24:43.437]             base::close(...future.stdout)
[13:24:43.437]         }, add = TRUE)
[13:24:43.437]     }
[13:24:43.437]     ...future.frame <- base::sys.nframe()
[13:24:43.437]     ...future.conditions <- base::list()
[13:24:43.437]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.437]     if (FALSE) {
[13:24:43.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.437]     }
[13:24:43.437]     ...future.result <- base::tryCatch({
[13:24:43.437]         base::withCallingHandlers({
[13:24:43.437]             ...future.value <- base::withVisible(base::local({
[13:24:43.437]                 ...future.makeSendCondition <- base::local({
[13:24:43.437]                   sendCondition <- NULL
[13:24:43.437]                   function(frame = 1L) {
[13:24:43.437]                     if (is.function(sendCondition)) 
[13:24:43.437]                       return(sendCondition)
[13:24:43.437]                     ns <- getNamespace("parallel")
[13:24:43.437]                     if (exists("sendData", mode = "function", 
[13:24:43.437]                       envir = ns)) {
[13:24:43.437]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.437]                         envir = ns)
[13:24:43.437]                       envir <- sys.frame(frame)
[13:24:43.437]                       master <- NULL
[13:24:43.437]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.437]                         !identical(envir, emptyenv())) {
[13:24:43.437]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.437]                           inherits = FALSE)) {
[13:24:43.437]                           master <- get("master", mode = "list", 
[13:24:43.437]                             envir = envir, inherits = FALSE)
[13:24:43.437]                           if (inherits(master, c("SOCKnode", 
[13:24:43.437]                             "SOCK0node"))) {
[13:24:43.437]                             sendCondition <<- function(cond) {
[13:24:43.437]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.437]                                 success = TRUE)
[13:24:43.437]                               parallel_sendData(master, data)
[13:24:43.437]                             }
[13:24:43.437]                             return(sendCondition)
[13:24:43.437]                           }
[13:24:43.437]                         }
[13:24:43.437]                         frame <- frame + 1L
[13:24:43.437]                         envir <- sys.frame(frame)
[13:24:43.437]                       }
[13:24:43.437]                     }
[13:24:43.437]                     sendCondition <<- function(cond) NULL
[13:24:43.437]                   }
[13:24:43.437]                 })
[13:24:43.437]                 withCallingHandlers({
[13:24:43.437]                   {
[13:24:43.437]                     2
[13:24:43.437]                   }
[13:24:43.437]                 }, immediateCondition = function(cond) {
[13:24:43.437]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.437]                   sendCondition(cond)
[13:24:43.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.437]                   {
[13:24:43.437]                     inherits <- base::inherits
[13:24:43.437]                     invokeRestart <- base::invokeRestart
[13:24:43.437]                     is.null <- base::is.null
[13:24:43.437]                     muffled <- FALSE
[13:24:43.437]                     if (inherits(cond, "message")) {
[13:24:43.437]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.437]                       if (muffled) 
[13:24:43.437]                         invokeRestart("muffleMessage")
[13:24:43.437]                     }
[13:24:43.437]                     else if (inherits(cond, "warning")) {
[13:24:43.437]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.437]                       if (muffled) 
[13:24:43.437]                         invokeRestart("muffleWarning")
[13:24:43.437]                     }
[13:24:43.437]                     else if (inherits(cond, "condition")) {
[13:24:43.437]                       if (!is.null(pattern)) {
[13:24:43.437]                         computeRestarts <- base::computeRestarts
[13:24:43.437]                         grepl <- base::grepl
[13:24:43.437]                         restarts <- computeRestarts(cond)
[13:24:43.437]                         for (restart in restarts) {
[13:24:43.437]                           name <- restart$name
[13:24:43.437]                           if (is.null(name)) 
[13:24:43.437]                             next
[13:24:43.437]                           if (!grepl(pattern, name)) 
[13:24:43.437]                             next
[13:24:43.437]                           invokeRestart(restart)
[13:24:43.437]                           muffled <- TRUE
[13:24:43.437]                           break
[13:24:43.437]                         }
[13:24:43.437]                       }
[13:24:43.437]                     }
[13:24:43.437]                     invisible(muffled)
[13:24:43.437]                   }
[13:24:43.437]                   muffleCondition(cond)
[13:24:43.437]                 })
[13:24:43.437]             }))
[13:24:43.437]             future::FutureResult(value = ...future.value$value, 
[13:24:43.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.437]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.437]                     ...future.globalenv.names))
[13:24:43.437]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.437]         }, condition = base::local({
[13:24:43.437]             c <- base::c
[13:24:43.437]             inherits <- base::inherits
[13:24:43.437]             invokeRestart <- base::invokeRestart
[13:24:43.437]             length <- base::length
[13:24:43.437]             list <- base::list
[13:24:43.437]             seq.int <- base::seq.int
[13:24:43.437]             signalCondition <- base::signalCondition
[13:24:43.437]             sys.calls <- base::sys.calls
[13:24:43.437]             `[[` <- base::`[[`
[13:24:43.437]             `+` <- base::`+`
[13:24:43.437]             `<<-` <- base::`<<-`
[13:24:43.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.437]                   3L)]
[13:24:43.437]             }
[13:24:43.437]             function(cond) {
[13:24:43.437]                 is_error <- inherits(cond, "error")
[13:24:43.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.437]                   NULL)
[13:24:43.437]                 if (is_error) {
[13:24:43.437]                   sessionInformation <- function() {
[13:24:43.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.437]                       search = base::search(), system = base::Sys.info())
[13:24:43.437]                   }
[13:24:43.437]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.437]                     cond$call), session = sessionInformation(), 
[13:24:43.437]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.437]                   signalCondition(cond)
[13:24:43.437]                 }
[13:24:43.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.437]                 "immediateCondition"))) {
[13:24:43.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.437]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.437]                   if (TRUE && !signal) {
[13:24:43.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.437]                     {
[13:24:43.437]                       inherits <- base::inherits
[13:24:43.437]                       invokeRestart <- base::invokeRestart
[13:24:43.437]                       is.null <- base::is.null
[13:24:43.437]                       muffled <- FALSE
[13:24:43.437]                       if (inherits(cond, "message")) {
[13:24:43.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.437]                         if (muffled) 
[13:24:43.437]                           invokeRestart("muffleMessage")
[13:24:43.437]                       }
[13:24:43.437]                       else if (inherits(cond, "warning")) {
[13:24:43.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.437]                         if (muffled) 
[13:24:43.437]                           invokeRestart("muffleWarning")
[13:24:43.437]                       }
[13:24:43.437]                       else if (inherits(cond, "condition")) {
[13:24:43.437]                         if (!is.null(pattern)) {
[13:24:43.437]                           computeRestarts <- base::computeRestarts
[13:24:43.437]                           grepl <- base::grepl
[13:24:43.437]                           restarts <- computeRestarts(cond)
[13:24:43.437]                           for (restart in restarts) {
[13:24:43.437]                             name <- restart$name
[13:24:43.437]                             if (is.null(name)) 
[13:24:43.437]                               next
[13:24:43.437]                             if (!grepl(pattern, name)) 
[13:24:43.437]                               next
[13:24:43.437]                             invokeRestart(restart)
[13:24:43.437]                             muffled <- TRUE
[13:24:43.437]                             break
[13:24:43.437]                           }
[13:24:43.437]                         }
[13:24:43.437]                       }
[13:24:43.437]                       invisible(muffled)
[13:24:43.437]                     }
[13:24:43.437]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.437]                   }
[13:24:43.437]                 }
[13:24:43.437]                 else {
[13:24:43.437]                   if (TRUE) {
[13:24:43.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.437]                     {
[13:24:43.437]                       inherits <- base::inherits
[13:24:43.437]                       invokeRestart <- base::invokeRestart
[13:24:43.437]                       is.null <- base::is.null
[13:24:43.437]                       muffled <- FALSE
[13:24:43.437]                       if (inherits(cond, "message")) {
[13:24:43.437]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.437]                         if (muffled) 
[13:24:43.437]                           invokeRestart("muffleMessage")
[13:24:43.437]                       }
[13:24:43.437]                       else if (inherits(cond, "warning")) {
[13:24:43.437]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.437]                         if (muffled) 
[13:24:43.437]                           invokeRestart("muffleWarning")
[13:24:43.437]                       }
[13:24:43.437]                       else if (inherits(cond, "condition")) {
[13:24:43.437]                         if (!is.null(pattern)) {
[13:24:43.437]                           computeRestarts <- base::computeRestarts
[13:24:43.437]                           grepl <- base::grepl
[13:24:43.437]                           restarts <- computeRestarts(cond)
[13:24:43.437]                           for (restart in restarts) {
[13:24:43.437]                             name <- restart$name
[13:24:43.437]                             if (is.null(name)) 
[13:24:43.437]                               next
[13:24:43.437]                             if (!grepl(pattern, name)) 
[13:24:43.437]                               next
[13:24:43.437]                             invokeRestart(restart)
[13:24:43.437]                             muffled <- TRUE
[13:24:43.437]                             break
[13:24:43.437]                           }
[13:24:43.437]                         }
[13:24:43.437]                       }
[13:24:43.437]                       invisible(muffled)
[13:24:43.437]                     }
[13:24:43.437]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.437]                   }
[13:24:43.437]                 }
[13:24:43.437]             }
[13:24:43.437]         }))
[13:24:43.437]     }, error = function(ex) {
[13:24:43.437]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.437]                 ...future.rng), started = ...future.startTime, 
[13:24:43.437]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.437]             version = "1.8"), class = "FutureResult")
[13:24:43.437]     }, finally = {
[13:24:43.437]         if (!identical(...future.workdir, getwd())) 
[13:24:43.437]             setwd(...future.workdir)
[13:24:43.437]         {
[13:24:43.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.437]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.437]             }
[13:24:43.437]             base::options(...future.oldOptions)
[13:24:43.437]             if (.Platform$OS.type == "windows") {
[13:24:43.437]                 old_names <- names(...future.oldEnvVars)
[13:24:43.437]                 envs <- base::Sys.getenv()
[13:24:43.437]                 names <- names(envs)
[13:24:43.437]                 common <- intersect(names, old_names)
[13:24:43.437]                 added <- setdiff(names, old_names)
[13:24:43.437]                 removed <- setdiff(old_names, names)
[13:24:43.437]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.437]                   envs[common]]
[13:24:43.437]                 NAMES <- toupper(changed)
[13:24:43.437]                 args <- list()
[13:24:43.437]                 for (kk in seq_along(NAMES)) {
[13:24:43.437]                   name <- changed[[kk]]
[13:24:43.437]                   NAME <- NAMES[[kk]]
[13:24:43.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.437]                     next
[13:24:43.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.437]                 }
[13:24:43.437]                 NAMES <- toupper(added)
[13:24:43.437]                 for (kk in seq_along(NAMES)) {
[13:24:43.437]                   name <- added[[kk]]
[13:24:43.437]                   NAME <- NAMES[[kk]]
[13:24:43.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.437]                     next
[13:24:43.437]                   args[[name]] <- ""
[13:24:43.437]                 }
[13:24:43.437]                 NAMES <- toupper(removed)
[13:24:43.437]                 for (kk in seq_along(NAMES)) {
[13:24:43.437]                   name <- removed[[kk]]
[13:24:43.437]                   NAME <- NAMES[[kk]]
[13:24:43.437]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.437]                     next
[13:24:43.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.437]                 }
[13:24:43.437]                 if (length(args) > 0) 
[13:24:43.437]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.437]             }
[13:24:43.437]             else {
[13:24:43.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.437]             }
[13:24:43.437]             {
[13:24:43.437]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.437]                   0L) {
[13:24:43.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.437]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.437]                   base::options(opts)
[13:24:43.437]                 }
[13:24:43.437]                 {
[13:24:43.437]                   {
[13:24:43.437]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.437]                     NULL
[13:24:43.437]                   }
[13:24:43.437]                   options(future.plan = NULL)
[13:24:43.437]                   if (is.na(NA_character_)) 
[13:24:43.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.437]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.437]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.437]                     envir = parent.frame()) 
[13:24:43.437]                   {
[13:24:43.437]                     if (is.function(workers)) 
[13:24:43.437]                       workers <- workers()
[13:24:43.437]                     workers <- structure(as.integer(workers), 
[13:24:43.437]                       class = class(workers))
[13:24:43.437]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.437]                       workers >= 1)
[13:24:43.437]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.437]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.437]                     }
[13:24:43.437]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.437]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.437]                       envir = envir)
[13:24:43.437]                     if (!future$lazy) 
[13:24:43.437]                       future <- run(future)
[13:24:43.437]                     invisible(future)
[13:24:43.437]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.437]                 }
[13:24:43.437]             }
[13:24:43.437]         }
[13:24:43.437]     })
[13:24:43.437]     if (TRUE) {
[13:24:43.437]         base::sink(type = "output", split = FALSE)
[13:24:43.437]         if (TRUE) {
[13:24:43.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.437]         }
[13:24:43.437]         else {
[13:24:43.437]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.437]         }
[13:24:43.437]         base::close(...future.stdout)
[13:24:43.437]         ...future.stdout <- NULL
[13:24:43.437]     }
[13:24:43.437]     ...future.result$conditions <- ...future.conditions
[13:24:43.437]     ...future.result$finished <- base::Sys.time()
[13:24:43.437]     ...future.result
[13:24:43.437] }
[13:24:43.440] MultisessionFuture started
[13:24:43.441] - Launch lazy future ... done
[13:24:43.441] run() for ‘MultisessionFuture’ ... done
[13:24:43.441] resolve() on list environment ...
[13:24:43.441]  recursive: 0
[13:24:43.442]  length: 3
[13:24:43.442]  elements: ‘a’, ‘b’, ‘c’
[13:24:43.463]  length: 2 (resolved future 3)
[13:24:43.474] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.474] - Validating connection of MultisessionFuture
[13:24:43.475] - received message: FutureResult
[13:24:43.475] - Received FutureResult
[13:24:43.475] - Erased future from FutureRegistry
[13:24:43.475] result() for ClusterFuture ...
[13:24:43.475] - result already collected: FutureResult
[13:24:43.475] result() for ClusterFuture ... done
[13:24:43.475] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.475] Future #1
[13:24:43.475]  length: 1 (resolved future 1)
[13:24:43.497] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.497] - Validating connection of MultisessionFuture
[13:24:43.497] - received message: FutureResult
[13:24:43.497] - Received FutureResult
[13:24:43.497] - Erased future from FutureRegistry
[13:24:43.497] result() for ClusterFuture ...
[13:24:43.497] - result already collected: FutureResult
[13:24:43.498] result() for ClusterFuture ... done
[13:24:43.498] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.498] Future #2
[13:24:43.498]  length: 0 (resolved future 2)
[13:24:43.498] resolve() on list environment ... DONE
[13:24:43.498] getGlobalsAndPackages() ...
[13:24:43.499] Searching for globals...
[13:24:43.499] - globals found: [1] ‘{’
[13:24:43.499] Searching for globals ... DONE
[13:24:43.499] Resolving globals: FALSE
[13:24:43.500] 
[13:24:43.500] 
[13:24:43.500] getGlobalsAndPackages() ... DONE
[13:24:43.500] run() for ‘Future’ ...
[13:24:43.500] - state: ‘created’
[13:24:43.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.515] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.515]   - Field: ‘node’
[13:24:43.515]   - Field: ‘label’
[13:24:43.515]   - Field: ‘local’
[13:24:43.515]   - Field: ‘owner’
[13:24:43.515]   - Field: ‘envir’
[13:24:43.515]   - Field: ‘workers’
[13:24:43.516]   - Field: ‘packages’
[13:24:43.516]   - Field: ‘gc’
[13:24:43.516]   - Field: ‘conditions’
[13:24:43.516]   - Field: ‘persistent’
[13:24:43.516]   - Field: ‘expr’
[13:24:43.516]   - Field: ‘uuid’
[13:24:43.516]   - Field: ‘seed’
[13:24:43.516]   - Field: ‘version’
[13:24:43.516]   - Field: ‘result’
[13:24:43.517]   - Field: ‘asynchronous’
[13:24:43.517]   - Field: ‘calls’
[13:24:43.517]   - Field: ‘globals’
[13:24:43.517]   - Field: ‘stdout’
[13:24:43.517]   - Field: ‘earlySignal’
[13:24:43.517]   - Field: ‘lazy’
[13:24:43.517]   - Field: ‘state’
[13:24:43.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.517] - Launch lazy future ...
[13:24:43.518] Packages needed by the future expression (n = 0): <none>
[13:24:43.518] Packages needed by future strategies (n = 0): <none>
[13:24:43.518] {
[13:24:43.518]     {
[13:24:43.518]         {
[13:24:43.518]             ...future.startTime <- base::Sys.time()
[13:24:43.518]             {
[13:24:43.518]                 {
[13:24:43.518]                   {
[13:24:43.518]                     {
[13:24:43.518]                       base::local({
[13:24:43.518]                         has_future <- base::requireNamespace("future", 
[13:24:43.518]                           quietly = TRUE)
[13:24:43.518]                         if (has_future) {
[13:24:43.518]                           ns <- base::getNamespace("future")
[13:24:43.518]                           version <- ns[[".package"]][["version"]]
[13:24:43.518]                           if (is.null(version)) 
[13:24:43.518]                             version <- utils::packageVersion("future")
[13:24:43.518]                         }
[13:24:43.518]                         else {
[13:24:43.518]                           version <- NULL
[13:24:43.518]                         }
[13:24:43.518]                         if (!has_future || version < "1.8.0") {
[13:24:43.518]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.518]                             "", base::R.version$version.string), 
[13:24:43.518]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.518]                               "release", "version")], collapse = " "), 
[13:24:43.518]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.518]                             info)
[13:24:43.518]                           info <- base::paste(info, collapse = "; ")
[13:24:43.518]                           if (!has_future) {
[13:24:43.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.518]                               info)
[13:24:43.518]                           }
[13:24:43.518]                           else {
[13:24:43.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.518]                               info, version)
[13:24:43.518]                           }
[13:24:43.518]                           base::stop(msg)
[13:24:43.518]                         }
[13:24:43.518]                       })
[13:24:43.518]                     }
[13:24:43.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.518]                     base::options(mc.cores = 1L)
[13:24:43.518]                   }
[13:24:43.518]                   options(future.plan = NULL)
[13:24:43.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.518]                 }
[13:24:43.518]                 ...future.workdir <- getwd()
[13:24:43.518]             }
[13:24:43.518]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.518]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.518]         }
[13:24:43.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.518]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.518]             base::names(...future.oldOptions))
[13:24:43.518]     }
[13:24:43.518]     if (FALSE) {
[13:24:43.518]     }
[13:24:43.518]     else {
[13:24:43.518]         if (TRUE) {
[13:24:43.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.518]                 open = "w")
[13:24:43.518]         }
[13:24:43.518]         else {
[13:24:43.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.518]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.518]         }
[13:24:43.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.518]             base::sink(type = "output", split = FALSE)
[13:24:43.518]             base::close(...future.stdout)
[13:24:43.518]         }, add = TRUE)
[13:24:43.518]     }
[13:24:43.518]     ...future.frame <- base::sys.nframe()
[13:24:43.518]     ...future.conditions <- base::list()
[13:24:43.518]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.518]     if (FALSE) {
[13:24:43.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.518]     }
[13:24:43.518]     ...future.result <- base::tryCatch({
[13:24:43.518]         base::withCallingHandlers({
[13:24:43.518]             ...future.value <- base::withVisible(base::local({
[13:24:43.518]                 ...future.makeSendCondition <- base::local({
[13:24:43.518]                   sendCondition <- NULL
[13:24:43.518]                   function(frame = 1L) {
[13:24:43.518]                     if (is.function(sendCondition)) 
[13:24:43.518]                       return(sendCondition)
[13:24:43.518]                     ns <- getNamespace("parallel")
[13:24:43.518]                     if (exists("sendData", mode = "function", 
[13:24:43.518]                       envir = ns)) {
[13:24:43.518]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.518]                         envir = ns)
[13:24:43.518]                       envir <- sys.frame(frame)
[13:24:43.518]                       master <- NULL
[13:24:43.518]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.518]                         !identical(envir, emptyenv())) {
[13:24:43.518]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.518]                           inherits = FALSE)) {
[13:24:43.518]                           master <- get("master", mode = "list", 
[13:24:43.518]                             envir = envir, inherits = FALSE)
[13:24:43.518]                           if (inherits(master, c("SOCKnode", 
[13:24:43.518]                             "SOCK0node"))) {
[13:24:43.518]                             sendCondition <<- function(cond) {
[13:24:43.518]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.518]                                 success = TRUE)
[13:24:43.518]                               parallel_sendData(master, data)
[13:24:43.518]                             }
[13:24:43.518]                             return(sendCondition)
[13:24:43.518]                           }
[13:24:43.518]                         }
[13:24:43.518]                         frame <- frame + 1L
[13:24:43.518]                         envir <- sys.frame(frame)
[13:24:43.518]                       }
[13:24:43.518]                     }
[13:24:43.518]                     sendCondition <<- function(cond) NULL
[13:24:43.518]                   }
[13:24:43.518]                 })
[13:24:43.518]                 withCallingHandlers({
[13:24:43.518]                   {
[13:24:43.518]                     1
[13:24:43.518]                   }
[13:24:43.518]                 }, immediateCondition = function(cond) {
[13:24:43.518]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.518]                   sendCondition(cond)
[13:24:43.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.518]                   {
[13:24:43.518]                     inherits <- base::inherits
[13:24:43.518]                     invokeRestart <- base::invokeRestart
[13:24:43.518]                     is.null <- base::is.null
[13:24:43.518]                     muffled <- FALSE
[13:24:43.518]                     if (inherits(cond, "message")) {
[13:24:43.518]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.518]                       if (muffled) 
[13:24:43.518]                         invokeRestart("muffleMessage")
[13:24:43.518]                     }
[13:24:43.518]                     else if (inherits(cond, "warning")) {
[13:24:43.518]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.518]                       if (muffled) 
[13:24:43.518]                         invokeRestart("muffleWarning")
[13:24:43.518]                     }
[13:24:43.518]                     else if (inherits(cond, "condition")) {
[13:24:43.518]                       if (!is.null(pattern)) {
[13:24:43.518]                         computeRestarts <- base::computeRestarts
[13:24:43.518]                         grepl <- base::grepl
[13:24:43.518]                         restarts <- computeRestarts(cond)
[13:24:43.518]                         for (restart in restarts) {
[13:24:43.518]                           name <- restart$name
[13:24:43.518]                           if (is.null(name)) 
[13:24:43.518]                             next
[13:24:43.518]                           if (!grepl(pattern, name)) 
[13:24:43.518]                             next
[13:24:43.518]                           invokeRestart(restart)
[13:24:43.518]                           muffled <- TRUE
[13:24:43.518]                           break
[13:24:43.518]                         }
[13:24:43.518]                       }
[13:24:43.518]                     }
[13:24:43.518]                     invisible(muffled)
[13:24:43.518]                   }
[13:24:43.518]                   muffleCondition(cond)
[13:24:43.518]                 })
[13:24:43.518]             }))
[13:24:43.518]             future::FutureResult(value = ...future.value$value, 
[13:24:43.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.518]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.518]                     ...future.globalenv.names))
[13:24:43.518]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.518]         }, condition = base::local({
[13:24:43.518]             c <- base::c
[13:24:43.518]             inherits <- base::inherits
[13:24:43.518]             invokeRestart <- base::invokeRestart
[13:24:43.518]             length <- base::length
[13:24:43.518]             list <- base::list
[13:24:43.518]             seq.int <- base::seq.int
[13:24:43.518]             signalCondition <- base::signalCondition
[13:24:43.518]             sys.calls <- base::sys.calls
[13:24:43.518]             `[[` <- base::`[[`
[13:24:43.518]             `+` <- base::`+`
[13:24:43.518]             `<<-` <- base::`<<-`
[13:24:43.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.518]                   3L)]
[13:24:43.518]             }
[13:24:43.518]             function(cond) {
[13:24:43.518]                 is_error <- inherits(cond, "error")
[13:24:43.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.518]                   NULL)
[13:24:43.518]                 if (is_error) {
[13:24:43.518]                   sessionInformation <- function() {
[13:24:43.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.518]                       search = base::search(), system = base::Sys.info())
[13:24:43.518]                   }
[13:24:43.518]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.518]                     cond$call), session = sessionInformation(), 
[13:24:43.518]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.518]                   signalCondition(cond)
[13:24:43.518]                 }
[13:24:43.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.518]                 "immediateCondition"))) {
[13:24:43.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.518]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.518]                   if (TRUE && !signal) {
[13:24:43.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.518]                     {
[13:24:43.518]                       inherits <- base::inherits
[13:24:43.518]                       invokeRestart <- base::invokeRestart
[13:24:43.518]                       is.null <- base::is.null
[13:24:43.518]                       muffled <- FALSE
[13:24:43.518]                       if (inherits(cond, "message")) {
[13:24:43.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.518]                         if (muffled) 
[13:24:43.518]                           invokeRestart("muffleMessage")
[13:24:43.518]                       }
[13:24:43.518]                       else if (inherits(cond, "warning")) {
[13:24:43.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.518]                         if (muffled) 
[13:24:43.518]                           invokeRestart("muffleWarning")
[13:24:43.518]                       }
[13:24:43.518]                       else if (inherits(cond, "condition")) {
[13:24:43.518]                         if (!is.null(pattern)) {
[13:24:43.518]                           computeRestarts <- base::computeRestarts
[13:24:43.518]                           grepl <- base::grepl
[13:24:43.518]                           restarts <- computeRestarts(cond)
[13:24:43.518]                           for (restart in restarts) {
[13:24:43.518]                             name <- restart$name
[13:24:43.518]                             if (is.null(name)) 
[13:24:43.518]                               next
[13:24:43.518]                             if (!grepl(pattern, name)) 
[13:24:43.518]                               next
[13:24:43.518]                             invokeRestart(restart)
[13:24:43.518]                             muffled <- TRUE
[13:24:43.518]                             break
[13:24:43.518]                           }
[13:24:43.518]                         }
[13:24:43.518]                       }
[13:24:43.518]                       invisible(muffled)
[13:24:43.518]                     }
[13:24:43.518]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.518]                   }
[13:24:43.518]                 }
[13:24:43.518]                 else {
[13:24:43.518]                   if (TRUE) {
[13:24:43.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.518]                     {
[13:24:43.518]                       inherits <- base::inherits
[13:24:43.518]                       invokeRestart <- base::invokeRestart
[13:24:43.518]                       is.null <- base::is.null
[13:24:43.518]                       muffled <- FALSE
[13:24:43.518]                       if (inherits(cond, "message")) {
[13:24:43.518]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.518]                         if (muffled) 
[13:24:43.518]                           invokeRestart("muffleMessage")
[13:24:43.518]                       }
[13:24:43.518]                       else if (inherits(cond, "warning")) {
[13:24:43.518]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.518]                         if (muffled) 
[13:24:43.518]                           invokeRestart("muffleWarning")
[13:24:43.518]                       }
[13:24:43.518]                       else if (inherits(cond, "condition")) {
[13:24:43.518]                         if (!is.null(pattern)) {
[13:24:43.518]                           computeRestarts <- base::computeRestarts
[13:24:43.518]                           grepl <- base::grepl
[13:24:43.518]                           restarts <- computeRestarts(cond)
[13:24:43.518]                           for (restart in restarts) {
[13:24:43.518]                             name <- restart$name
[13:24:43.518]                             if (is.null(name)) 
[13:24:43.518]                               next
[13:24:43.518]                             if (!grepl(pattern, name)) 
[13:24:43.518]                               next
[13:24:43.518]                             invokeRestart(restart)
[13:24:43.518]                             muffled <- TRUE
[13:24:43.518]                             break
[13:24:43.518]                           }
[13:24:43.518]                         }
[13:24:43.518]                       }
[13:24:43.518]                       invisible(muffled)
[13:24:43.518]                     }
[13:24:43.518]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.518]                   }
[13:24:43.518]                 }
[13:24:43.518]             }
[13:24:43.518]         }))
[13:24:43.518]     }, error = function(ex) {
[13:24:43.518]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.518]                 ...future.rng), started = ...future.startTime, 
[13:24:43.518]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.518]             version = "1.8"), class = "FutureResult")
[13:24:43.518]     }, finally = {
[13:24:43.518]         if (!identical(...future.workdir, getwd())) 
[13:24:43.518]             setwd(...future.workdir)
[13:24:43.518]         {
[13:24:43.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.518]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.518]             }
[13:24:43.518]             base::options(...future.oldOptions)
[13:24:43.518]             if (.Platform$OS.type == "windows") {
[13:24:43.518]                 old_names <- names(...future.oldEnvVars)
[13:24:43.518]                 envs <- base::Sys.getenv()
[13:24:43.518]                 names <- names(envs)
[13:24:43.518]                 common <- intersect(names, old_names)
[13:24:43.518]                 added <- setdiff(names, old_names)
[13:24:43.518]                 removed <- setdiff(old_names, names)
[13:24:43.518]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.518]                   envs[common]]
[13:24:43.518]                 NAMES <- toupper(changed)
[13:24:43.518]                 args <- list()
[13:24:43.518]                 for (kk in seq_along(NAMES)) {
[13:24:43.518]                   name <- changed[[kk]]
[13:24:43.518]                   NAME <- NAMES[[kk]]
[13:24:43.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.518]                     next
[13:24:43.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.518]                 }
[13:24:43.518]                 NAMES <- toupper(added)
[13:24:43.518]                 for (kk in seq_along(NAMES)) {
[13:24:43.518]                   name <- added[[kk]]
[13:24:43.518]                   NAME <- NAMES[[kk]]
[13:24:43.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.518]                     next
[13:24:43.518]                   args[[name]] <- ""
[13:24:43.518]                 }
[13:24:43.518]                 NAMES <- toupper(removed)
[13:24:43.518]                 for (kk in seq_along(NAMES)) {
[13:24:43.518]                   name <- removed[[kk]]
[13:24:43.518]                   NAME <- NAMES[[kk]]
[13:24:43.518]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.518]                     next
[13:24:43.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.518]                 }
[13:24:43.518]                 if (length(args) > 0) 
[13:24:43.518]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.518]             }
[13:24:43.518]             else {
[13:24:43.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.518]             }
[13:24:43.518]             {
[13:24:43.518]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.518]                   0L) {
[13:24:43.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.518]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.518]                   base::options(opts)
[13:24:43.518]                 }
[13:24:43.518]                 {
[13:24:43.518]                   {
[13:24:43.518]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.518]                     NULL
[13:24:43.518]                   }
[13:24:43.518]                   options(future.plan = NULL)
[13:24:43.518]                   if (is.na(NA_character_)) 
[13:24:43.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.518]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.518]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.518]                     envir = parent.frame()) 
[13:24:43.518]                   {
[13:24:43.518]                     if (is.function(workers)) 
[13:24:43.518]                       workers <- workers()
[13:24:43.518]                     workers <- structure(as.integer(workers), 
[13:24:43.518]                       class = class(workers))
[13:24:43.518]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.518]                       workers >= 1)
[13:24:43.518]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.518]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.518]                     }
[13:24:43.518]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.518]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.518]                       envir = envir)
[13:24:43.518]                     if (!future$lazy) 
[13:24:43.518]                       future <- run(future)
[13:24:43.518]                     invisible(future)
[13:24:43.518]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.518]                 }
[13:24:43.518]             }
[13:24:43.518]         }
[13:24:43.518]     })
[13:24:43.518]     if (TRUE) {
[13:24:43.518]         base::sink(type = "output", split = FALSE)
[13:24:43.518]         if (TRUE) {
[13:24:43.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.518]         }
[13:24:43.518]         else {
[13:24:43.518]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.518]         }
[13:24:43.518]         base::close(...future.stdout)
[13:24:43.518]         ...future.stdout <- NULL
[13:24:43.518]     }
[13:24:43.518]     ...future.result$conditions <- ...future.conditions
[13:24:43.518]     ...future.result$finished <- base::Sys.time()
[13:24:43.518]     ...future.result
[13:24:43.518] }
[13:24:43.521] MultisessionFuture started
[13:24:43.522] - Launch lazy future ... done
[13:24:43.522] run() for ‘MultisessionFuture’ ... done
[13:24:43.522] getGlobalsAndPackages() ...
[13:24:43.522] Searching for globals...
[13:24:43.523] - globals found: [2] ‘{’, ‘Sys.sleep’
[13:24:43.523] Searching for globals ... DONE
[13:24:43.523] Resolving globals: FALSE
[13:24:43.524] 
[13:24:43.524] 
[13:24:43.524] getGlobalsAndPackages() ... DONE
[13:24:43.524] run() for ‘Future’ ...
[13:24:43.524] - state: ‘created’
[13:24:43.527] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.544] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.544]   - Field: ‘node’
[13:24:43.545]   - Field: ‘label’
[13:24:43.545]   - Field: ‘local’
[13:24:43.545]   - Field: ‘owner’
[13:24:43.545]   - Field: ‘envir’
[13:24:43.545]   - Field: ‘workers’
[13:24:43.545]   - Field: ‘packages’
[13:24:43.545]   - Field: ‘gc’
[13:24:43.545]   - Field: ‘conditions’
[13:24:43.545]   - Field: ‘persistent’
[13:24:43.545]   - Field: ‘expr’
[13:24:43.545]   - Field: ‘uuid’
[13:24:43.546]   - Field: ‘seed’
[13:24:43.546]   - Field: ‘version’
[13:24:43.546]   - Field: ‘result’
[13:24:43.546]   - Field: ‘asynchronous’
[13:24:43.546]   - Field: ‘calls’
[13:24:43.546]   - Field: ‘globals’
[13:24:43.546]   - Field: ‘stdout’
[13:24:43.546]   - Field: ‘earlySignal’
[13:24:43.546]   - Field: ‘lazy’
[13:24:43.546]   - Field: ‘state’
[13:24:43.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.547] - Launch lazy future ...
[13:24:43.547] Packages needed by the future expression (n = 0): <none>
[13:24:43.547] Packages needed by future strategies (n = 0): <none>
[13:24:43.547] {
[13:24:43.547]     {
[13:24:43.547]         {
[13:24:43.547]             ...future.startTime <- base::Sys.time()
[13:24:43.547]             {
[13:24:43.547]                 {
[13:24:43.547]                   {
[13:24:43.547]                     {
[13:24:43.547]                       base::local({
[13:24:43.547]                         has_future <- base::requireNamespace("future", 
[13:24:43.547]                           quietly = TRUE)
[13:24:43.547]                         if (has_future) {
[13:24:43.547]                           ns <- base::getNamespace("future")
[13:24:43.547]                           version <- ns[[".package"]][["version"]]
[13:24:43.547]                           if (is.null(version)) 
[13:24:43.547]                             version <- utils::packageVersion("future")
[13:24:43.547]                         }
[13:24:43.547]                         else {
[13:24:43.547]                           version <- NULL
[13:24:43.547]                         }
[13:24:43.547]                         if (!has_future || version < "1.8.0") {
[13:24:43.547]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.547]                             "", base::R.version$version.string), 
[13:24:43.547]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.547]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.547]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.547]                               "release", "version")], collapse = " "), 
[13:24:43.547]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.547]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.547]                             info)
[13:24:43.547]                           info <- base::paste(info, collapse = "; ")
[13:24:43.547]                           if (!has_future) {
[13:24:43.547]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.547]                               info)
[13:24:43.547]                           }
[13:24:43.547]                           else {
[13:24:43.547]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.547]                               info, version)
[13:24:43.547]                           }
[13:24:43.547]                           base::stop(msg)
[13:24:43.547]                         }
[13:24:43.547]                       })
[13:24:43.547]                     }
[13:24:43.547]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.547]                     base::options(mc.cores = 1L)
[13:24:43.547]                   }
[13:24:43.547]                   options(future.plan = NULL)
[13:24:43.547]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.547]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.547]                 }
[13:24:43.547]                 ...future.workdir <- getwd()
[13:24:43.547]             }
[13:24:43.547]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.547]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.547]         }
[13:24:43.547]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.547]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.547]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.547]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.547]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.547]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.547]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.547]             base::names(...future.oldOptions))
[13:24:43.547]     }
[13:24:43.547]     if (FALSE) {
[13:24:43.547]     }
[13:24:43.547]     else {
[13:24:43.547]         if (TRUE) {
[13:24:43.547]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.547]                 open = "w")
[13:24:43.547]         }
[13:24:43.547]         else {
[13:24:43.547]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.547]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.547]         }
[13:24:43.547]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.547]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.547]             base::sink(type = "output", split = FALSE)
[13:24:43.547]             base::close(...future.stdout)
[13:24:43.547]         }, add = TRUE)
[13:24:43.547]     }
[13:24:43.547]     ...future.frame <- base::sys.nframe()
[13:24:43.547]     ...future.conditions <- base::list()
[13:24:43.547]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.547]     if (FALSE) {
[13:24:43.547]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.547]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.547]     }
[13:24:43.547]     ...future.result <- base::tryCatch({
[13:24:43.547]         base::withCallingHandlers({
[13:24:43.547]             ...future.value <- base::withVisible(base::local({
[13:24:43.547]                 ...future.makeSendCondition <- base::local({
[13:24:43.547]                   sendCondition <- NULL
[13:24:43.547]                   function(frame = 1L) {
[13:24:43.547]                     if (is.function(sendCondition)) 
[13:24:43.547]                       return(sendCondition)
[13:24:43.547]                     ns <- getNamespace("parallel")
[13:24:43.547]                     if (exists("sendData", mode = "function", 
[13:24:43.547]                       envir = ns)) {
[13:24:43.547]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.547]                         envir = ns)
[13:24:43.547]                       envir <- sys.frame(frame)
[13:24:43.547]                       master <- NULL
[13:24:43.547]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.547]                         !identical(envir, emptyenv())) {
[13:24:43.547]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.547]                           inherits = FALSE)) {
[13:24:43.547]                           master <- get("master", mode = "list", 
[13:24:43.547]                             envir = envir, inherits = FALSE)
[13:24:43.547]                           if (inherits(master, c("SOCKnode", 
[13:24:43.547]                             "SOCK0node"))) {
[13:24:43.547]                             sendCondition <<- function(cond) {
[13:24:43.547]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.547]                                 success = TRUE)
[13:24:43.547]                               parallel_sendData(master, data)
[13:24:43.547]                             }
[13:24:43.547]                             return(sendCondition)
[13:24:43.547]                           }
[13:24:43.547]                         }
[13:24:43.547]                         frame <- frame + 1L
[13:24:43.547]                         envir <- sys.frame(frame)
[13:24:43.547]                       }
[13:24:43.547]                     }
[13:24:43.547]                     sendCondition <<- function(cond) NULL
[13:24:43.547]                   }
[13:24:43.547]                 })
[13:24:43.547]                 withCallingHandlers({
[13:24:43.547]                   {
[13:24:43.547]                     Sys.sleep(0.5)
[13:24:43.547]                     2
[13:24:43.547]                   }
[13:24:43.547]                 }, immediateCondition = function(cond) {
[13:24:43.547]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.547]                   sendCondition(cond)
[13:24:43.547]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.547]                   {
[13:24:43.547]                     inherits <- base::inherits
[13:24:43.547]                     invokeRestart <- base::invokeRestart
[13:24:43.547]                     is.null <- base::is.null
[13:24:43.547]                     muffled <- FALSE
[13:24:43.547]                     if (inherits(cond, "message")) {
[13:24:43.547]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.547]                       if (muffled) 
[13:24:43.547]                         invokeRestart("muffleMessage")
[13:24:43.547]                     }
[13:24:43.547]                     else if (inherits(cond, "warning")) {
[13:24:43.547]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.547]                       if (muffled) 
[13:24:43.547]                         invokeRestart("muffleWarning")
[13:24:43.547]                     }
[13:24:43.547]                     else if (inherits(cond, "condition")) {
[13:24:43.547]                       if (!is.null(pattern)) {
[13:24:43.547]                         computeRestarts <- base::computeRestarts
[13:24:43.547]                         grepl <- base::grepl
[13:24:43.547]                         restarts <- computeRestarts(cond)
[13:24:43.547]                         for (restart in restarts) {
[13:24:43.547]                           name <- restart$name
[13:24:43.547]                           if (is.null(name)) 
[13:24:43.547]                             next
[13:24:43.547]                           if (!grepl(pattern, name)) 
[13:24:43.547]                             next
[13:24:43.547]                           invokeRestart(restart)
[13:24:43.547]                           muffled <- TRUE
[13:24:43.547]                           break
[13:24:43.547]                         }
[13:24:43.547]                       }
[13:24:43.547]                     }
[13:24:43.547]                     invisible(muffled)
[13:24:43.547]                   }
[13:24:43.547]                   muffleCondition(cond)
[13:24:43.547]                 })
[13:24:43.547]             }))
[13:24:43.547]             future::FutureResult(value = ...future.value$value, 
[13:24:43.547]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.547]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.547]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.547]                     ...future.globalenv.names))
[13:24:43.547]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.547]         }, condition = base::local({
[13:24:43.547]             c <- base::c
[13:24:43.547]             inherits <- base::inherits
[13:24:43.547]             invokeRestart <- base::invokeRestart
[13:24:43.547]             length <- base::length
[13:24:43.547]             list <- base::list
[13:24:43.547]             seq.int <- base::seq.int
[13:24:43.547]             signalCondition <- base::signalCondition
[13:24:43.547]             sys.calls <- base::sys.calls
[13:24:43.547]             `[[` <- base::`[[`
[13:24:43.547]             `+` <- base::`+`
[13:24:43.547]             `<<-` <- base::`<<-`
[13:24:43.547]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.547]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.547]                   3L)]
[13:24:43.547]             }
[13:24:43.547]             function(cond) {
[13:24:43.547]                 is_error <- inherits(cond, "error")
[13:24:43.547]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.547]                   NULL)
[13:24:43.547]                 if (is_error) {
[13:24:43.547]                   sessionInformation <- function() {
[13:24:43.547]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.547]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.547]                       search = base::search(), system = base::Sys.info())
[13:24:43.547]                   }
[13:24:43.547]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.547]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.547]                     cond$call), session = sessionInformation(), 
[13:24:43.547]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.547]                   signalCondition(cond)
[13:24:43.547]                 }
[13:24:43.547]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.547]                 "immediateCondition"))) {
[13:24:43.547]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.547]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.547]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.547]                   if (TRUE && !signal) {
[13:24:43.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.547]                     {
[13:24:43.547]                       inherits <- base::inherits
[13:24:43.547]                       invokeRestart <- base::invokeRestart
[13:24:43.547]                       is.null <- base::is.null
[13:24:43.547]                       muffled <- FALSE
[13:24:43.547]                       if (inherits(cond, "message")) {
[13:24:43.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.547]                         if (muffled) 
[13:24:43.547]                           invokeRestart("muffleMessage")
[13:24:43.547]                       }
[13:24:43.547]                       else if (inherits(cond, "warning")) {
[13:24:43.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.547]                         if (muffled) 
[13:24:43.547]                           invokeRestart("muffleWarning")
[13:24:43.547]                       }
[13:24:43.547]                       else if (inherits(cond, "condition")) {
[13:24:43.547]                         if (!is.null(pattern)) {
[13:24:43.547]                           computeRestarts <- base::computeRestarts
[13:24:43.547]                           grepl <- base::grepl
[13:24:43.547]                           restarts <- computeRestarts(cond)
[13:24:43.547]                           for (restart in restarts) {
[13:24:43.547]                             name <- restart$name
[13:24:43.547]                             if (is.null(name)) 
[13:24:43.547]                               next
[13:24:43.547]                             if (!grepl(pattern, name)) 
[13:24:43.547]                               next
[13:24:43.547]                             invokeRestart(restart)
[13:24:43.547]                             muffled <- TRUE
[13:24:43.547]                             break
[13:24:43.547]                           }
[13:24:43.547]                         }
[13:24:43.547]                       }
[13:24:43.547]                       invisible(muffled)
[13:24:43.547]                     }
[13:24:43.547]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.547]                   }
[13:24:43.547]                 }
[13:24:43.547]                 else {
[13:24:43.547]                   if (TRUE) {
[13:24:43.547]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.547]                     {
[13:24:43.547]                       inherits <- base::inherits
[13:24:43.547]                       invokeRestart <- base::invokeRestart
[13:24:43.547]                       is.null <- base::is.null
[13:24:43.547]                       muffled <- FALSE
[13:24:43.547]                       if (inherits(cond, "message")) {
[13:24:43.547]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.547]                         if (muffled) 
[13:24:43.547]                           invokeRestart("muffleMessage")
[13:24:43.547]                       }
[13:24:43.547]                       else if (inherits(cond, "warning")) {
[13:24:43.547]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.547]                         if (muffled) 
[13:24:43.547]                           invokeRestart("muffleWarning")
[13:24:43.547]                       }
[13:24:43.547]                       else if (inherits(cond, "condition")) {
[13:24:43.547]                         if (!is.null(pattern)) {
[13:24:43.547]                           computeRestarts <- base::computeRestarts
[13:24:43.547]                           grepl <- base::grepl
[13:24:43.547]                           restarts <- computeRestarts(cond)
[13:24:43.547]                           for (restart in restarts) {
[13:24:43.547]                             name <- restart$name
[13:24:43.547]                             if (is.null(name)) 
[13:24:43.547]                               next
[13:24:43.547]                             if (!grepl(pattern, name)) 
[13:24:43.547]                               next
[13:24:43.547]                             invokeRestart(restart)
[13:24:43.547]                             muffled <- TRUE
[13:24:43.547]                             break
[13:24:43.547]                           }
[13:24:43.547]                         }
[13:24:43.547]                       }
[13:24:43.547]                       invisible(muffled)
[13:24:43.547]                     }
[13:24:43.547]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.547]                   }
[13:24:43.547]                 }
[13:24:43.547]             }
[13:24:43.547]         }))
[13:24:43.547]     }, error = function(ex) {
[13:24:43.547]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.547]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.547]                 ...future.rng), started = ...future.startTime, 
[13:24:43.547]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.547]             version = "1.8"), class = "FutureResult")
[13:24:43.547]     }, finally = {
[13:24:43.547]         if (!identical(...future.workdir, getwd())) 
[13:24:43.547]             setwd(...future.workdir)
[13:24:43.547]         {
[13:24:43.547]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.547]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.547]             }
[13:24:43.547]             base::options(...future.oldOptions)
[13:24:43.547]             if (.Platform$OS.type == "windows") {
[13:24:43.547]                 old_names <- names(...future.oldEnvVars)
[13:24:43.547]                 envs <- base::Sys.getenv()
[13:24:43.547]                 names <- names(envs)
[13:24:43.547]                 common <- intersect(names, old_names)
[13:24:43.547]                 added <- setdiff(names, old_names)
[13:24:43.547]                 removed <- setdiff(old_names, names)
[13:24:43.547]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.547]                   envs[common]]
[13:24:43.547]                 NAMES <- toupper(changed)
[13:24:43.547]                 args <- list()
[13:24:43.547]                 for (kk in seq_along(NAMES)) {
[13:24:43.547]                   name <- changed[[kk]]
[13:24:43.547]                   NAME <- NAMES[[kk]]
[13:24:43.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.547]                     next
[13:24:43.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.547]                 }
[13:24:43.547]                 NAMES <- toupper(added)
[13:24:43.547]                 for (kk in seq_along(NAMES)) {
[13:24:43.547]                   name <- added[[kk]]
[13:24:43.547]                   NAME <- NAMES[[kk]]
[13:24:43.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.547]                     next
[13:24:43.547]                   args[[name]] <- ""
[13:24:43.547]                 }
[13:24:43.547]                 NAMES <- toupper(removed)
[13:24:43.547]                 for (kk in seq_along(NAMES)) {
[13:24:43.547]                   name <- removed[[kk]]
[13:24:43.547]                   NAME <- NAMES[[kk]]
[13:24:43.547]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.547]                     next
[13:24:43.547]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.547]                 }
[13:24:43.547]                 if (length(args) > 0) 
[13:24:43.547]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.547]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.547]             }
[13:24:43.547]             else {
[13:24:43.547]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.547]             }
[13:24:43.547]             {
[13:24:43.547]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.547]                   0L) {
[13:24:43.547]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.547]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.547]                   base::options(opts)
[13:24:43.547]                 }
[13:24:43.547]                 {
[13:24:43.547]                   {
[13:24:43.547]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.547]                     NULL
[13:24:43.547]                   }
[13:24:43.547]                   options(future.plan = NULL)
[13:24:43.547]                   if (is.na(NA_character_)) 
[13:24:43.547]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.547]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.547]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.547]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.547]                     envir = parent.frame()) 
[13:24:43.547]                   {
[13:24:43.547]                     if (is.function(workers)) 
[13:24:43.547]                       workers <- workers()
[13:24:43.547]                     workers <- structure(as.integer(workers), 
[13:24:43.547]                       class = class(workers))
[13:24:43.547]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.547]                       workers >= 1)
[13:24:43.547]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.547]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.547]                     }
[13:24:43.547]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.547]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.547]                       envir = envir)
[13:24:43.547]                     if (!future$lazy) 
[13:24:43.547]                       future <- run(future)
[13:24:43.547]                     invisible(future)
[13:24:43.547]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.547]                 }
[13:24:43.547]             }
[13:24:43.547]         }
[13:24:43.547]     })
[13:24:43.547]     if (TRUE) {
[13:24:43.547]         base::sink(type = "output", split = FALSE)
[13:24:43.547]         if (TRUE) {
[13:24:43.547]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.547]         }
[13:24:43.547]         else {
[13:24:43.547]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.547]         }
[13:24:43.547]         base::close(...future.stdout)
[13:24:43.547]         ...future.stdout <- NULL
[13:24:43.547]     }
[13:24:43.547]     ...future.result$conditions <- ...future.conditions
[13:24:43.547]     ...future.result$finished <- base::Sys.time()
[13:24:43.547]     ...future.result
[13:24:43.547] }
[13:24:43.551] MultisessionFuture started
[13:24:43.551] - Launch lazy future ... done
[13:24:43.551] run() for ‘MultisessionFuture’ ... done
[13:24:43.551] getGlobalsAndPackages() ...
[13:24:43.552] Searching for globals...
[13:24:43.552] - globals found: [1] ‘{’
[13:24:43.552] Searching for globals ... DONE
[13:24:43.552] Resolving globals: FALSE
[13:24:43.553] 
[13:24:43.553] 
[13:24:43.553] getGlobalsAndPackages() ... DONE
[13:24:43.553] run() for ‘Future’ ...
[13:24:43.553] - state: ‘created’
[13:24:43.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:24:43.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:24:43.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:24:43.568]   - Field: ‘node’
[13:24:43.568]   - Field: ‘label’
[13:24:43.568]   - Field: ‘local’
[13:24:43.568]   - Field: ‘owner’
[13:24:43.568]   - Field: ‘envir’
[13:24:43.568]   - Field: ‘workers’
[13:24:43.568]   - Field: ‘packages’
[13:24:43.568]   - Field: ‘gc’
[13:24:43.569]   - Field: ‘conditions’
[13:24:43.569]   - Field: ‘persistent’
[13:24:43.569]   - Field: ‘expr’
[13:24:43.569]   - Field: ‘uuid’
[13:24:43.569]   - Field: ‘seed’
[13:24:43.569]   - Field: ‘version’
[13:24:43.569]   - Field: ‘result’
[13:24:43.569]   - Field: ‘asynchronous’
[13:24:43.569]   - Field: ‘calls’
[13:24:43.569]   - Field: ‘globals’
[13:24:43.570]   - Field: ‘stdout’
[13:24:43.570]   - Field: ‘earlySignal’
[13:24:43.570]   - Field: ‘lazy’
[13:24:43.570]   - Field: ‘state’
[13:24:43.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:24:43.570] - Launch lazy future ...
[13:24:43.570] Packages needed by the future expression (n = 0): <none>
[13:24:43.570] Packages needed by future strategies (n = 0): <none>
[13:24:43.571] {
[13:24:43.571]     {
[13:24:43.571]         {
[13:24:43.571]             ...future.startTime <- base::Sys.time()
[13:24:43.571]             {
[13:24:43.571]                 {
[13:24:43.571]                   {
[13:24:43.571]                     {
[13:24:43.571]                       base::local({
[13:24:43.571]                         has_future <- base::requireNamespace("future", 
[13:24:43.571]                           quietly = TRUE)
[13:24:43.571]                         if (has_future) {
[13:24:43.571]                           ns <- base::getNamespace("future")
[13:24:43.571]                           version <- ns[[".package"]][["version"]]
[13:24:43.571]                           if (is.null(version)) 
[13:24:43.571]                             version <- utils::packageVersion("future")
[13:24:43.571]                         }
[13:24:43.571]                         else {
[13:24:43.571]                           version <- NULL
[13:24:43.571]                         }
[13:24:43.571]                         if (!has_future || version < "1.8.0") {
[13:24:43.571]                           info <- base::c(r_version = base::gsub("R version ", 
[13:24:43.571]                             "", base::R.version$version.string), 
[13:24:43.571]                             platform = base::sprintf("%s (%s-bit)", 
[13:24:43.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:24:43.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:24:43.571]                               "release", "version")], collapse = " "), 
[13:24:43.571]                             hostname = base::Sys.info()[["nodename"]])
[13:24:43.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:24:43.571]                             info)
[13:24:43.571]                           info <- base::paste(info, collapse = "; ")
[13:24:43.571]                           if (!has_future) {
[13:24:43.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:24:43.571]                               info)
[13:24:43.571]                           }
[13:24:43.571]                           else {
[13:24:43.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:24:43.571]                               info, version)
[13:24:43.571]                           }
[13:24:43.571]                           base::stop(msg)
[13:24:43.571]                         }
[13:24:43.571]                       })
[13:24:43.571]                     }
[13:24:43.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:24:43.571]                     base::options(mc.cores = 1L)
[13:24:43.571]                   }
[13:24:43.571]                   options(future.plan = NULL)
[13:24:43.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:24:43.571]                 }
[13:24:43.571]                 ...future.workdir <- getwd()
[13:24:43.571]             }
[13:24:43.571]             ...future.oldOptions <- base::as.list(base::.Options)
[13:24:43.571]             ...future.oldEnvVars <- base::Sys.getenv()
[13:24:43.571]         }
[13:24:43.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:24:43.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:24:43.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:24:43.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:24:43.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:24:43.571]             future.stdout.windows.reencode = NULL, width = 80L)
[13:24:43.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:24:43.571]             base::names(...future.oldOptions))
[13:24:43.571]     }
[13:24:43.571]     if (FALSE) {
[13:24:43.571]     }
[13:24:43.571]     else {
[13:24:43.571]         if (TRUE) {
[13:24:43.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:24:43.571]                 open = "w")
[13:24:43.571]         }
[13:24:43.571]         else {
[13:24:43.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:24:43.571]                 windows = "NUL", "/dev/null"), open = "w")
[13:24:43.571]         }
[13:24:43.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:24:43.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:24:43.571]             base::sink(type = "output", split = FALSE)
[13:24:43.571]             base::close(...future.stdout)
[13:24:43.571]         }, add = TRUE)
[13:24:43.571]     }
[13:24:43.571]     ...future.frame <- base::sys.nframe()
[13:24:43.571]     ...future.conditions <- base::list()
[13:24:43.571]     ...future.rng <- base::globalenv()$.Random.seed
[13:24:43.571]     if (FALSE) {
[13:24:43.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:24:43.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:24:43.571]     }
[13:24:43.571]     ...future.result <- base::tryCatch({
[13:24:43.571]         base::withCallingHandlers({
[13:24:43.571]             ...future.value <- base::withVisible(base::local({
[13:24:43.571]                 ...future.makeSendCondition <- base::local({
[13:24:43.571]                   sendCondition <- NULL
[13:24:43.571]                   function(frame = 1L) {
[13:24:43.571]                     if (is.function(sendCondition)) 
[13:24:43.571]                       return(sendCondition)
[13:24:43.571]                     ns <- getNamespace("parallel")
[13:24:43.571]                     if (exists("sendData", mode = "function", 
[13:24:43.571]                       envir = ns)) {
[13:24:43.571]                       parallel_sendData <- get("sendData", mode = "function", 
[13:24:43.571]                         envir = ns)
[13:24:43.571]                       envir <- sys.frame(frame)
[13:24:43.571]                       master <- NULL
[13:24:43.571]                       while (!identical(envir, .GlobalEnv) && 
[13:24:43.571]                         !identical(envir, emptyenv())) {
[13:24:43.571]                         if (exists("master", mode = "list", envir = envir, 
[13:24:43.571]                           inherits = FALSE)) {
[13:24:43.571]                           master <- get("master", mode = "list", 
[13:24:43.571]                             envir = envir, inherits = FALSE)
[13:24:43.571]                           if (inherits(master, c("SOCKnode", 
[13:24:43.571]                             "SOCK0node"))) {
[13:24:43.571]                             sendCondition <<- function(cond) {
[13:24:43.571]                               data <- list(type = "VALUE", value = cond, 
[13:24:43.571]                                 success = TRUE)
[13:24:43.571]                               parallel_sendData(master, data)
[13:24:43.571]                             }
[13:24:43.571]                             return(sendCondition)
[13:24:43.571]                           }
[13:24:43.571]                         }
[13:24:43.571]                         frame <- frame + 1L
[13:24:43.571]                         envir <- sys.frame(frame)
[13:24:43.571]                       }
[13:24:43.571]                     }
[13:24:43.571]                     sendCondition <<- function(cond) NULL
[13:24:43.571]                   }
[13:24:43.571]                 })
[13:24:43.571]                 withCallingHandlers({
[13:24:43.571]                   {
[13:24:43.571]                     3
[13:24:43.571]                   }
[13:24:43.571]                 }, immediateCondition = function(cond) {
[13:24:43.571]                   sendCondition <- ...future.makeSendCondition()
[13:24:43.571]                   sendCondition(cond)
[13:24:43.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.571]                   {
[13:24:43.571]                     inherits <- base::inherits
[13:24:43.571]                     invokeRestart <- base::invokeRestart
[13:24:43.571]                     is.null <- base::is.null
[13:24:43.571]                     muffled <- FALSE
[13:24:43.571]                     if (inherits(cond, "message")) {
[13:24:43.571]                       muffled <- grepl(pattern, "muffleMessage")
[13:24:43.571]                       if (muffled) 
[13:24:43.571]                         invokeRestart("muffleMessage")
[13:24:43.571]                     }
[13:24:43.571]                     else if (inherits(cond, "warning")) {
[13:24:43.571]                       muffled <- grepl(pattern, "muffleWarning")
[13:24:43.571]                       if (muffled) 
[13:24:43.571]                         invokeRestart("muffleWarning")
[13:24:43.571]                     }
[13:24:43.571]                     else if (inherits(cond, "condition")) {
[13:24:43.571]                       if (!is.null(pattern)) {
[13:24:43.571]                         computeRestarts <- base::computeRestarts
[13:24:43.571]                         grepl <- base::grepl
[13:24:43.571]                         restarts <- computeRestarts(cond)
[13:24:43.571]                         for (restart in restarts) {
[13:24:43.571]                           name <- restart$name
[13:24:43.571]                           if (is.null(name)) 
[13:24:43.571]                             next
[13:24:43.571]                           if (!grepl(pattern, name)) 
[13:24:43.571]                             next
[13:24:43.571]                           invokeRestart(restart)
[13:24:43.571]                           muffled <- TRUE
[13:24:43.571]                           break
[13:24:43.571]                         }
[13:24:43.571]                       }
[13:24:43.571]                     }
[13:24:43.571]                     invisible(muffled)
[13:24:43.571]                   }
[13:24:43.571]                   muffleCondition(cond)
[13:24:43.571]                 })
[13:24:43.571]             }))
[13:24:43.571]             future::FutureResult(value = ...future.value$value, 
[13:24:43.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.571]                   ...future.rng), globalenv = if (FALSE) 
[13:24:43.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:24:43.571]                     ...future.globalenv.names))
[13:24:43.571]                 else NULL, started = ...future.startTime, version = "1.8")
[13:24:43.571]         }, condition = base::local({
[13:24:43.571]             c <- base::c
[13:24:43.571]             inherits <- base::inherits
[13:24:43.571]             invokeRestart <- base::invokeRestart
[13:24:43.571]             length <- base::length
[13:24:43.571]             list <- base::list
[13:24:43.571]             seq.int <- base::seq.int
[13:24:43.571]             signalCondition <- base::signalCondition
[13:24:43.571]             sys.calls <- base::sys.calls
[13:24:43.571]             `[[` <- base::`[[`
[13:24:43.571]             `+` <- base::`+`
[13:24:43.571]             `<<-` <- base::`<<-`
[13:24:43.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:24:43.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:24:43.571]                   3L)]
[13:24:43.571]             }
[13:24:43.571]             function(cond) {
[13:24:43.571]                 is_error <- inherits(cond, "error")
[13:24:43.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:24:43.571]                   NULL)
[13:24:43.571]                 if (is_error) {
[13:24:43.571]                   sessionInformation <- function() {
[13:24:43.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:24:43.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:24:43.571]                       search = base::search(), system = base::Sys.info())
[13:24:43.571]                   }
[13:24:43.571]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:24:43.571]                     cond$call), session = sessionInformation(), 
[13:24:43.571]                     timestamp = base::Sys.time(), signaled = 0L)
[13:24:43.571]                   signalCondition(cond)
[13:24:43.571]                 }
[13:24:43.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:24:43.571]                 "immediateCondition"))) {
[13:24:43.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:24:43.571]                   ...future.conditions[[length(...future.conditions) + 
[13:24:43.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:24:43.571]                   if (TRUE && !signal) {
[13:24:43.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.571]                     {
[13:24:43.571]                       inherits <- base::inherits
[13:24:43.571]                       invokeRestart <- base::invokeRestart
[13:24:43.571]                       is.null <- base::is.null
[13:24:43.571]                       muffled <- FALSE
[13:24:43.571]                       if (inherits(cond, "message")) {
[13:24:43.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.571]                         if (muffled) 
[13:24:43.571]                           invokeRestart("muffleMessage")
[13:24:43.571]                       }
[13:24:43.571]                       else if (inherits(cond, "warning")) {
[13:24:43.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.571]                         if (muffled) 
[13:24:43.571]                           invokeRestart("muffleWarning")
[13:24:43.571]                       }
[13:24:43.571]                       else if (inherits(cond, "condition")) {
[13:24:43.571]                         if (!is.null(pattern)) {
[13:24:43.571]                           computeRestarts <- base::computeRestarts
[13:24:43.571]                           grepl <- base::grepl
[13:24:43.571]                           restarts <- computeRestarts(cond)
[13:24:43.571]                           for (restart in restarts) {
[13:24:43.571]                             name <- restart$name
[13:24:43.571]                             if (is.null(name)) 
[13:24:43.571]                               next
[13:24:43.571]                             if (!grepl(pattern, name)) 
[13:24:43.571]                               next
[13:24:43.571]                             invokeRestart(restart)
[13:24:43.571]                             muffled <- TRUE
[13:24:43.571]                             break
[13:24:43.571]                           }
[13:24:43.571]                         }
[13:24:43.571]                       }
[13:24:43.571]                       invisible(muffled)
[13:24:43.571]                     }
[13:24:43.571]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.571]                   }
[13:24:43.571]                 }
[13:24:43.571]                 else {
[13:24:43.571]                   if (TRUE) {
[13:24:43.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:24:43.571]                     {
[13:24:43.571]                       inherits <- base::inherits
[13:24:43.571]                       invokeRestart <- base::invokeRestart
[13:24:43.571]                       is.null <- base::is.null
[13:24:43.571]                       muffled <- FALSE
[13:24:43.571]                       if (inherits(cond, "message")) {
[13:24:43.571]                         muffled <- grepl(pattern, "muffleMessage")
[13:24:43.571]                         if (muffled) 
[13:24:43.571]                           invokeRestart("muffleMessage")
[13:24:43.571]                       }
[13:24:43.571]                       else if (inherits(cond, "warning")) {
[13:24:43.571]                         muffled <- grepl(pattern, "muffleWarning")
[13:24:43.571]                         if (muffled) 
[13:24:43.571]                           invokeRestart("muffleWarning")
[13:24:43.571]                       }
[13:24:43.571]                       else if (inherits(cond, "condition")) {
[13:24:43.571]                         if (!is.null(pattern)) {
[13:24:43.571]                           computeRestarts <- base::computeRestarts
[13:24:43.571]                           grepl <- base::grepl
[13:24:43.571]                           restarts <- computeRestarts(cond)
[13:24:43.571]                           for (restart in restarts) {
[13:24:43.571]                             name <- restart$name
[13:24:43.571]                             if (is.null(name)) 
[13:24:43.571]                               next
[13:24:43.571]                             if (!grepl(pattern, name)) 
[13:24:43.571]                               next
[13:24:43.571]                             invokeRestart(restart)
[13:24:43.571]                             muffled <- TRUE
[13:24:43.571]                             break
[13:24:43.571]                           }
[13:24:43.571]                         }
[13:24:43.571]                       }
[13:24:43.571]                       invisible(muffled)
[13:24:43.571]                     }
[13:24:43.571]                     muffleCondition(cond, pattern = "^muffle")
[13:24:43.571]                   }
[13:24:43.571]                 }
[13:24:43.571]             }
[13:24:43.571]         }))
[13:24:43.571]     }, error = function(ex) {
[13:24:43.571]         base::structure(base::list(value = NULL, visible = NULL, 
[13:24:43.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:24:43.571]                 ...future.rng), started = ...future.startTime, 
[13:24:43.571]             finished = Sys.time(), session_uuid = NA_character_, 
[13:24:43.571]             version = "1.8"), class = "FutureResult")
[13:24:43.571]     }, finally = {
[13:24:43.571]         if (!identical(...future.workdir, getwd())) 
[13:24:43.571]             setwd(...future.workdir)
[13:24:43.571]         {
[13:24:43.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:24:43.571]                 ...future.oldOptions$nwarnings <- NULL
[13:24:43.571]             }
[13:24:43.571]             base::options(...future.oldOptions)
[13:24:43.571]             if (.Platform$OS.type == "windows") {
[13:24:43.571]                 old_names <- names(...future.oldEnvVars)
[13:24:43.571]                 envs <- base::Sys.getenv()
[13:24:43.571]                 names <- names(envs)
[13:24:43.571]                 common <- intersect(names, old_names)
[13:24:43.571]                 added <- setdiff(names, old_names)
[13:24:43.571]                 removed <- setdiff(old_names, names)
[13:24:43.571]                 changed <- common[...future.oldEnvVars[common] != 
[13:24:43.571]                   envs[common]]
[13:24:43.571]                 NAMES <- toupper(changed)
[13:24:43.571]                 args <- list()
[13:24:43.571]                 for (kk in seq_along(NAMES)) {
[13:24:43.571]                   name <- changed[[kk]]
[13:24:43.571]                   NAME <- NAMES[[kk]]
[13:24:43.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.571]                     next
[13:24:43.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.571]                 }
[13:24:43.571]                 NAMES <- toupper(added)
[13:24:43.571]                 for (kk in seq_along(NAMES)) {
[13:24:43.571]                   name <- added[[kk]]
[13:24:43.571]                   NAME <- NAMES[[kk]]
[13:24:43.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.571]                     next
[13:24:43.571]                   args[[name]] <- ""
[13:24:43.571]                 }
[13:24:43.571]                 NAMES <- toupper(removed)
[13:24:43.571]                 for (kk in seq_along(NAMES)) {
[13:24:43.571]                   name <- removed[[kk]]
[13:24:43.571]                   NAME <- NAMES[[kk]]
[13:24:43.571]                   if (name != NAME && is.element(NAME, old_names)) 
[13:24:43.571]                     next
[13:24:43.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:24:43.571]                 }
[13:24:43.571]                 if (length(args) > 0) 
[13:24:43.571]                   base::do.call(base::Sys.setenv, args = args)
[13:24:43.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:24:43.571]             }
[13:24:43.571]             else {
[13:24:43.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:24:43.571]             }
[13:24:43.571]             {
[13:24:43.571]                 if (base::length(...future.futureOptionsAdded) > 
[13:24:43.571]                   0L) {
[13:24:43.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:24:43.571]                   base::names(opts) <- ...future.futureOptionsAdded
[13:24:43.571]                   base::options(opts)
[13:24:43.571]                 }
[13:24:43.571]                 {
[13:24:43.571]                   {
[13:24:43.571]                     base::options(mc.cores = ...future.mc.cores.old)
[13:24:43.571]                     NULL
[13:24:43.571]                   }
[13:24:43.571]                   options(future.plan = NULL)
[13:24:43.571]                   if (is.na(NA_character_)) 
[13:24:43.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:24:43.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:24:43.571]                   future::plan(list(function (..., workers = availableCores(), 
[13:24:43.571]                     lazy = FALSE, rscript_libs = .libPaths(), 
[13:24:43.571]                     envir = parent.frame()) 
[13:24:43.571]                   {
[13:24:43.571]                     if (is.function(workers)) 
[13:24:43.571]                       workers <- workers()
[13:24:43.571]                     workers <- structure(as.integer(workers), 
[13:24:43.571]                       class = class(workers))
[13:24:43.571]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[13:24:43.571]                       workers >= 1)
[13:24:43.571]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[13:24:43.571]                       return(sequential(..., lazy = TRUE, envir = envir))
[13:24:43.571]                     }
[13:24:43.571]                     future <- MultisessionFuture(..., workers = workers, 
[13:24:43.571]                       lazy = lazy, rscript_libs = rscript_libs, 
[13:24:43.571]                       envir = envir)
[13:24:43.571]                     if (!future$lazy) 
[13:24:43.571]                       future <- run(future)
[13:24:43.571]                     invisible(future)
[13:24:43.571]                   }), .cleanup = FALSE, .init = FALSE)
[13:24:43.571]                 }
[13:24:43.571]             }
[13:24:43.571]         }
[13:24:43.571]     })
[13:24:43.571]     if (TRUE) {
[13:24:43.571]         base::sink(type = "output", split = FALSE)
[13:24:43.571]         if (TRUE) {
[13:24:43.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:24:43.571]         }
[13:24:43.571]         else {
[13:24:43.571]             ...future.result["stdout"] <- base::list(NULL)
[13:24:43.571]         }
[13:24:43.571]         base::close(...future.stdout)
[13:24:43.571]         ...future.stdout <- NULL
[13:24:43.571]     }
[13:24:43.571]     ...future.result$conditions <- ...future.conditions
[13:24:43.571]     ...future.result$finished <- base::Sys.time()
[13:24:43.571]     ...future.result
[13:24:43.571] }
[13:24:43.573] Poll #1 (0): usedNodes() = 2, workers = 2
[13:24:43.584] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.584] - Validating connection of MultisessionFuture
[13:24:43.584] - received message: FutureResult
[13:24:43.585] - Received FutureResult
[13:24:43.585] - Erased future from FutureRegistry
[13:24:43.585] result() for ClusterFuture ...
[13:24:43.585] - result already collected: FutureResult
[13:24:43.585] result() for ClusterFuture ... done
[13:24:43.585] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.585] result() for ClusterFuture ...
[13:24:43.585] - result already collected: FutureResult
[13:24:43.585] result() for ClusterFuture ... done
[13:24:43.585] result() for ClusterFuture ...
[13:24:43.585] - result already collected: FutureResult
[13:24:43.586] result() for ClusterFuture ... done
[13:24:43.587] MultisessionFuture started
[13:24:43.587] - Launch lazy future ... done
[13:24:43.587] run() for ‘MultisessionFuture’ ... done
[13:24:43.587] resolve() on list environment ...
[13:24:43.588]  recursive: 0
[13:24:43.588]  length: 4
[13:24:43.588]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:43.589] Future #1
[13:24:43.589]  length: 3 (resolved future 1)
[13:24:43.610]  length: 2 (resolved future 4)
[13:24:43.633] receiveMessageFromWorker() for ClusterFuture ...
[13:24:43.633] - Validating connection of MultisessionFuture
[13:24:43.633] - received message: FutureResult
[13:24:43.634] - Received FutureResult
[13:24:43.634] - Erased future from FutureRegistry
[13:24:43.634] result() for ClusterFuture ...
[13:24:43.634] - result already collected: FutureResult
[13:24:43.634] result() for ClusterFuture ... done
[13:24:43.634] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:43.634] Future #3
[13:24:43.634]  length: 1 (resolved future 3)
[13:24:44.102] receiveMessageFromWorker() for ClusterFuture ...
[13:24:44.102] - Validating connection of MultisessionFuture
[13:24:44.102] - received message: FutureResult
[13:24:44.102] - Received FutureResult
[13:24:44.102] - Erased future from FutureRegistry
[13:24:44.103] result() for ClusterFuture ...
[13:24:44.103] - result already collected: FutureResult
[13:24:44.103] result() for ClusterFuture ... done
[13:24:44.103] receiveMessageFromWorker() for ClusterFuture ... done
[13:24:44.103] Future #2
[13:24:44.103]  length: 0 (resolved future 2)
[13:24:44.103] resolve() on list environment ... DONE
[13:24:44.104] resolve() on list environment ...
[13:24:44.104]  recursive: 0
[13:24:44.104]  length: 4
[13:24:44.104]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:44.105] Future #1
[13:24:44.105]  length: 3 (resolved future 1)
[13:24:44.105] Future #2
[13:24:44.105]  length: 2 (resolved future 2)
[13:24:44.105] Future #3
[13:24:44.105]  length: 1 (resolved future 3)
[13:24:44.105]  length: 0 (resolved future 4)
[13:24:44.105] resolve() on list environment ... DONE
[13:24:44.106] resolve() on list environment ...
[13:24:44.106]  recursive: 0
[13:24:44.107]  length: 4
[13:24:44.107]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:44.107] Future #1
[13:24:44.107]  length: 3 (resolved future 1)
[13:24:44.107] Future #2
[13:24:44.107]  length: 2 (resolved future 2)
[13:24:44.107] Future #3
[13:24:44.107]  length: 1 (resolved future 3)
[13:24:44.108]  length: 0 (resolved future 4)
[13:24:44.108] resolve() on list environment ... DONE
[13:24:44.108] resolve() on list environment ...
[13:24:44.108]  recursive: 0
[13:24:44.109]  length: 4
[13:24:44.109]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:44.109] Future #1
[13:24:44.109]  length: 3 (resolved future 1)
[13:24:44.109] Future #2
[13:24:44.109]  length: 2 (resolved future 2)
[13:24:44.110] Future #3
[13:24:44.110]  length: 1 (resolved future 3)
[13:24:44.110]  length: 0 (resolved future 4)
[13:24:44.110] resolve() on list environment ... DONE
[13:24:44.110] resolve() on list environment ...
[13:24:44.110]  recursive: 0
[13:24:44.111]  length: 4
[13:24:44.111]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:44.111] Future #1
[13:24:44.111] result() for ClusterFuture ...
[13:24:44.112] - result already collected: FutureResult
[13:24:44.112] result() for ClusterFuture ... done
[13:24:44.112] result() for ClusterFuture ...
[13:24:44.112] - result already collected: FutureResult
[13:24:44.112] result() for ClusterFuture ... done
[13:24:44.112]  length: 3 (resolved future 1)
[13:24:44.112] Future #2
[13:24:44.112] result() for ClusterFuture ...
[13:24:44.112] - result already collected: FutureResult
[13:24:44.112] result() for ClusterFuture ... done
[13:24:44.112] result() for ClusterFuture ...
[13:24:44.113] - result already collected: FutureResult
[13:24:44.113] result() for ClusterFuture ... done
[13:24:44.113]  length: 2 (resolved future 2)
[13:24:44.113] Future #3
[13:24:44.113] result() for ClusterFuture ...
[13:24:44.113] - result already collected: FutureResult
[13:24:44.113] result() for ClusterFuture ... done
[13:24:44.113] result() for ClusterFuture ...
[13:24:44.113] - result already collected: FutureResult
[13:24:44.113] result() for ClusterFuture ... done
[13:24:44.114]  length: 1 (resolved future 3)
[13:24:44.114]  length: 0 (resolved future 4)
[13:24:44.114] resolve() on list environment ... DONE
[13:24:44.114] resolve() on list environment ...
[13:24:44.114]  recursive: 99
[13:24:44.115]  length: 4
[13:24:44.115]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[13:24:44.115] Future #1
[13:24:44.115] result() for ClusterFuture ...
[13:24:44.115] - result already collected: FutureResult
[13:24:44.115] result() for ClusterFuture ... done
[13:24:44.116] result() for ClusterFuture ...
[13:24:44.116] - result already collected: FutureResult
[13:24:44.116] result() for ClusterFuture ... done
[13:24:44.116] A MultisessionFuture was resolved
[13:24:44.116]  length: 3 (resolved future 1)
[13:24:44.116] Future #2
[13:24:44.116] result() for ClusterFuture ...
[13:24:44.116] - result already collected: FutureResult
[13:24:44.116] result() for ClusterFuture ... done
[13:24:44.116] result() for ClusterFuture ...
[13:24:44.117] - result already collected: FutureResult
[13:24:44.117] result() for ClusterFuture ... done
[13:24:44.117] A MultisessionFuture was resolved
[13:24:44.117]  length: 2 (resolved future 2)
[13:24:44.117] Future #3
[13:24:44.117] result() for ClusterFuture ...
[13:24:44.117] - result already collected: FutureResult
[13:24:44.117] result() for ClusterFuture ... done
[13:24:44.117] result() for ClusterFuture ...
[13:24:44.117] - result already collected: FutureResult
[13:24:44.117] result() for ClusterFuture ... done
[13:24:44.118] A MultisessionFuture was resolved
[13:24:44.118]  length: 1 (resolved future 3)
[13:24:44.118]  length: 0 (resolved future 4)
[13:24:44.118] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[13:24:44.121] resolve() on list ...
[13:24:44.121]  recursive: 0
[13:24:44.121]  length: 3
[13:24:44.121] 
[13:24:44.121]  length: 2 (resolved future 1)
[13:24:44.121]  length: 1 (resolved future 2)
[13:24:44.122]  length: 0 (resolved future 3)
[13:24:44.122] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[13:24:44.123] plan(): Setting new future strategy stack:
[13:24:44.123] List of future strategies:
[13:24:44.123] 1. FutureStrategy:
[13:24:44.123]    - args: function (..., envir = parent.frame())
[13:24:44.123]    - tweaked: FALSE
[13:24:44.123]    - call: future::plan(oplan)
[13:24:44.123] plan(): nbrOfWorkers() = 1
> 
